<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="5.3.0_0_2fd7a9ecc" segtype="sentence" srclang="en-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv xml:lang="en-US">
        <seg>(Irreflexivity)</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>（非反射）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>(Reflexivity)</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>（反射性）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>(Symmetry)</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>（対称性）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>(Transitive comparability)</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>（推移的比較性）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>(Transitive incomparability)</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>（推移的比較不能性）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>(Transitivity)</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>（推移性）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>(true, new<bpt i="1" x="1">&lt;w1&gt;</bpt>Member)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if <bpt i="2" x="2">&lt;c2&gt;</bpt>new<bpt i="3" x="3">&lt;w3&gt;</bpt>Member<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> was not contained in <bpt i="4" x="4">&lt;c4&gt;</bpt>self<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>(true, new<bpt i="1" x="1">&lt;w1&gt;</bpt>Member)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、もし<bpt i="2" x="2">&lt;c2&gt;</bpt>new<bpt i="3" x="3">&lt;w3&gt;</bpt>Member<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt>self<ept i="4">&lt;/c4&gt;</ept>に含まれなかったならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>(true, new<bpt i="1" x="1">&lt;w1&gt;</bpt>Member)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if <bpt i="2" x="2">&lt;c2&gt;</bpt>new<bpt i="3" x="3">&lt;w3&gt;</bpt>Member<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> was not contained in the set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>(true, new<bpt i="1" x="1">&lt;w1&gt;</bpt>Member)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、もし<bpt i="2" x="2">&lt;c2&gt;</bpt>new<bpt i="3" x="3">&lt;w3&gt;</bpt>Member<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>がこの集合の中に含まれなかったならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_CLOSED<bpt i="2" x="2">&lt;w2&gt;</bpt>_ENUM<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> for simple enumerations that can never gain new cases</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_CLOSED<bpt i="2" x="2">&lt;w2&gt;</bpt>_ENUM<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を決して新しいケース節が増えることが出来ない単純な列挙に対して</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_ENUM<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> for simple enumerations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_ENUM<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を単純な列挙に対して</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_OPTIONS<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> for enumerations whose cases can be grouped into sets of options</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_OPTIONS<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を、それのケース節がひとそろいのオプションへとグループにできる列挙に対して</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_TYPED<bpt i="2" x="2">&lt;w2&gt;</bpt>_ENUM<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> for enumerations with a raw value type that you specify</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_TYPED<bpt i="2" x="2">&lt;w2&gt;</bpt>_ENUM<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を、あなたが指定する生の値型を使う列挙に対して</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_TYPED<bpt i="2" x="2">&lt;w2&gt;</bpt>_EXTENSIBLE<bpt i="3" x="3">&lt;w3&gt;</bpt>_ENUM<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> for enumerations that you expect might gain more cases</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_TYPED<bpt i="2" x="2">&lt;w2&gt;</bpt>_EXTENSIBLE<bpt i="3" x="3">&lt;w3&gt;</bpt>_ENUM<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を、もっとケース節が増えることをあなたが予想する列挙に対して</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Range<ept i="0">&lt;/c0&gt;</ept> instances can represent an empty interval, unlike <bpt i="1" x="1">&lt;c1&gt;</bpt>Closed<bpt i="2" x="2">&lt;w2&gt;</bpt>Range<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Range<ept i="0">&lt;/c0&gt;</ept>インスタンスは、空の間隔を表すことができます、<bpt i="1" x="1">&lt;c1&gt;</bpt>Closed<bpt i="2" x="2">&lt;w2&gt;</bpt>Range<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>とは違って。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>T<bpt i="1" x="1">&lt;w1&gt;</bpt>.min<bpt i="2" x="2">&lt;w2&gt;</bpt>.is<bpt i="3" x="3">&lt;w3&gt;</bpt>Multiple(of: -1)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="4" x="4">&lt;c4&gt;</bpt>true<ept i="4">&lt;/c4&gt;</ept> for signed integer <bpt i="5" x="5">&lt;c5&gt;</bpt>T<ept i="5">&lt;/c5&gt;</ept>, even though the quotient <bpt i="6" x="6">&lt;c6&gt;</bpt>T<bpt i="7" x="7">&lt;w7&gt;</bpt>.min / -1<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> isn’t representable in type <bpt i="8" x="8">&lt;c8&gt;</bpt>T<ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>T<bpt i="1" x="1">&lt;w1&gt;</bpt>.min<bpt i="2" x="2">&lt;w2&gt;</bpt>.is<bpt i="3" x="3">&lt;w3&gt;</bpt>Multiple(of: -1)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="4" x="4">&lt;c4&gt;</bpt>true<ept i="4">&lt;/c4&gt;</ept>です、符号付き整数<bpt i="5" x="5">&lt;c5&gt;</bpt>T<ept i="5">&lt;/c5&gt;</ept>に対して、たとえ商<bpt i="6" x="6">&lt;c6&gt;</bpt>T<bpt i="7" x="7">&lt;w7&gt;</bpt>.min / -1<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>が型<bpt i="8" x="8">&lt;c8&gt;</bpt>T<ept i="8">&lt;/c8&gt;</ept>で表現可能でなくてさえ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>ancestor<bpt i="1" x="1">&lt;w1&gt;</bpt>Representation<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is ignored if <bpt i="2" x="2">&lt;c2&gt;</bpt>subject<ept i="2">&lt;/c2&gt;</ept> is not a class instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>ancestor<bpt i="1" x="1">&lt;w1&gt;</bpt>Representation<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、<bpt i="2" x="2">&lt;c2&gt;</bpt>subject<ept i="2">&lt;/c2&gt;</ept>がクラスインスタンスでないならば無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>are<bpt i="1" x="1">&lt;w1&gt;</bpt>Equivalent(a, a)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is always <bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>are<bpt i="1" x="1">&lt;w1&gt;</bpt>Equivalent(a, a)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は常に<bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>are<bpt i="1" x="1">&lt;w1&gt;</bpt>Equivalent(a, b)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> implies <bpt i="2" x="2">&lt;c2&gt;</bpt>are<bpt i="3" x="3">&lt;w3&gt;</bpt>Equivalent(b, a)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>are<bpt i="1" x="1">&lt;w1&gt;</bpt>Equivalent(a, b)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>are<bpt i="3" x="3">&lt;w3&gt;</bpt>Equivalent(b, a)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を意味する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>are<bpt i="1" x="1">&lt;w1&gt;</bpt>In<bpt i="2" x="2">&lt;w2&gt;</bpt>Increasing<bpt i="3" x="3">&lt;w3&gt;</bpt>Order(a, a)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is always <bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>are<bpt i="1" x="1">&lt;w1&gt;</bpt>In<bpt i="2" x="2">&lt;w2&gt;</bpt>Increasing<bpt i="3" x="3">&lt;w3&gt;</bpt>Order(a, a)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は常に<bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>are<bpt i="1" x="1">&lt;w1&gt;</bpt>In<bpt i="2" x="2">&lt;w2&gt;</bpt>Increasing<bpt i="3" x="3">&lt;w3&gt;</bpt>Order<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be a <bpt i="4" x="4">&lt;e4&gt;</bpt>strict weak ordering<ept i="4">&lt;/e4&gt;</ept> over the elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>are<bpt i="1" x="1">&lt;w1&gt;</bpt>In<bpt i="2" x="2">&lt;w2&gt;</bpt>Increasing<bpt i="3" x="3">&lt;w3&gt;</bpt>Order<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、それら要素に対して<bpt i="4" x="4">&lt;e4&gt;</bpt>厳密弱順序<ept i="4">&lt;/e4&gt;</ept>でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>c<bpt i="1" x="1">&lt;w1&gt;</bpt>.lazy<bpt i="2" x="2">&lt;w2&gt;</bpt>.reversed().map(f)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> maps lazily and returns a <bpt i="3" x="3">&lt;c3&gt;</bpt>Lazy<bpt i="4" x="4">&lt;w4&gt;</bpt>Map<bpt i="5" x="5">&lt;w5&gt;</bpt>Collection<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>c<bpt i="1" x="1">&lt;w1&gt;</bpt>.lazy<bpt i="2" x="2">&lt;w2&gt;</bpt>.reversed().map(f)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は遅延にマップして<bpt i="3" x="3">&lt;c3&gt;</bpt>Lazy<bpt i="4" x="4">&lt;w4&gt;</bpt>Map<bpt i="5" x="5">&lt;w5&gt;</bpt>Collection<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>を返します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>c<bpt i="1" x="1">&lt;w1&gt;</bpt>.reversed().map(f)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> maps eagerly and returns a new array</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>c<bpt i="1" x="1">&lt;w1&gt;</bpt>.reversed().map(f)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、先行にマップして新しい配列を返します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>c<bpt i="1" x="1">&lt;w1&gt;</bpt>.reversed()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> does not create new storage</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>c<bpt i="1" x="1">&lt;w1&gt;</bpt>.reversed()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、新しいストレージを作成しません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>elements<ept i="0">&lt;/c0&gt;</ept> must be finite.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>elements<ept i="0">&lt;/c0&gt;</ept>は有限でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>end<ept i="0">&lt;/c0&gt;</ept> must be a valid index of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>end<ept i="0">&lt;/c0&gt;</ept>はコレクションのひとつの有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is always reachable from <bpt i="2" x="2">&lt;c2&gt;</bpt>start<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> by zero or more applications of <bpt i="4" x="4">&lt;c4&gt;</bpt>index(after:)<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、常に<bpt i="2" x="2">&lt;c2&gt;</bpt>start<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>から<bpt i="4" x="4">&lt;c4&gt;</bpt>index(after:)<ept i="4">&lt;/c4&gt;</ept>のゼロまたはそれ以上の適用によって到達可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>hash<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is deprecated as a <bpt i="2" x="2">&lt;c2&gt;</bpt>Hashable<ept i="2">&lt;/c2&gt;</ept> requirement.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>hash<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、<bpt i="2" x="2">&lt;c2&gt;</bpt>Hashable<ept i="2">&lt;/c2&gt;</ept>要件として非推奨にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept> must be greater than <bpt i="1" x="1">&lt;c1&gt;</bpt>start<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>start<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>より大きくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept> must be less than <bpt i="1" x="1">&lt;c1&gt;</bpt>end<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>end<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>より少なくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>index<ept i="0">&lt;/c0&gt;</ept> must be a valid index into the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>index<ept i="0">&lt;/c0&gt;</ept>はコレクションに対する有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>index<ept i="0">&lt;/c0&gt;</ept> must be a valid index of the collection that is not equal to the collection’s end index.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>index<ept i="0">&lt;/c0&gt;</ept>は、このコレクションの有効なインデックスでなければなりません、そしてこのコレクションの持つ末尾インデックスと等しくてはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>index<ept i="0">&lt;/c0&gt;</ept> must be a valid index of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>index<ept i="0">&lt;/c0&gt;</ept>はコレクションの有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>index<ept i="0">&lt;/c0&gt;</ept> must be in the range <bpt i="1" x="1">&lt;c1&gt;</bpt>0..<it pos="begin" x="2">&lt;scalar&lt;w2&gt;</it>Count<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>index<ept i="0">&lt;/c0&gt;</ept>は、範囲<bpt i="1" x="1">&lt;c1&gt;</bpt>0..<it pos="begin" x="2">&lt;scalar&lt;w2&gt;</it>Count<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の中になければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>initial<bpt i="1" x="1">&lt;w1&gt;</bpt>Result<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is passed to <bpt i="2" x="2">&lt;c2&gt;</bpt>next<bpt i="3" x="3">&lt;w3&gt;</bpt>Partial<bpt i="4" x="4">&lt;w4&gt;</bpt>Result<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> the first time the closure is executed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>initial<bpt i="1" x="1">&lt;w1&gt;</bpt>Result<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>next<bpt i="3" x="3">&lt;w3&gt;</bpt>Partial<bpt i="4" x="4">&lt;w4&gt;</bpt>Result<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に、クロージャが実行される最初の時に渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>k<ept i="0">&lt;/c0&gt;</ept> must be greater than or equal to zero and must not exceed the number of elements in the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>k<ept i="0">&lt;/c0&gt;</ept>は、ゼロより大きいか等しくなければなりません、そしてコレクションの中の要素の数を越えてはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>k<ept i="0">&lt;/c0&gt;</ept> must be greater than or equal to zero, and must be less than or equal to the number of elements in the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>k<ept i="0">&lt;/c0&gt;</ept>は、ゼロより大きいか等しくなければなりません、そしてコレクションの要素数より少ないか等しくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>k<ept i="0">&lt;/c0&gt;</ept> must be greater than or equal to zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>k<ept i="0">&lt;/c0&gt;</ept>は、ゼロより大きいか等しくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Length<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be greater than or equal to zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Length<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、ゼロより大きいか等しくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>n<ept i="0">&lt;/c0&gt;</ept> must be greater than or equal to zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>n<ept i="0">&lt;/c0&gt;</ept>は、ゼロより大きいか等しくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept> must be finite.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>は有限でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>position<ept i="0">&lt;/c0&gt;</ept> must be a valid index of the collection that is not equal to the <bpt i="1" x="1">&lt;c1&gt;</bpt>end<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>position<ept i="0">&lt;/c0&gt;</ept>はコレクションの有効なインデックスで、<bpt i="1" x="1">&lt;c1&gt;</bpt>end<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>プロパティと等しくないものでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>position<ept i="0">&lt;/c0&gt;</ept> must be a valid index of the collection that is not equal to the collection’s end index.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>position<ept i="0">&lt;/c0&gt;</ept>は、このコレクションの有効なインデックスでなければなりません、そしてこのコレクションの持つ末尾インデックスと等しくてはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>position<ept i="0">&lt;/c0&gt;</ept> must be a valid index of the range, and must not equal the range’s end index.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>position<ept i="0">&lt;/c0&gt;</ept>は、この範囲の有効なインデックスでなければなりません、そしてこの範囲の持つ末尾インデックスと等しくてはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>position<ept i="0">&lt;/c0&gt;</ept> must be a valid index of the set, and must not be equal to the set’s end index.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>position<ept i="0">&lt;/c0&gt;</ept>は、この集合の有効なインデックスでなければなりません、そしてこの集合の持つ末尾インデックスと等しくてはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>possible<bpt i="1" x="1">&lt;w1&gt;</bpt>Strict<bpt i="2" x="2">&lt;w2&gt;</bpt>Subset<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be finite.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>possible<bpt i="1" x="1">&lt;w1&gt;</bpt>Strict<bpt i="2" x="2">&lt;w2&gt;</bpt>Subset<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は有限でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>possible<bpt i="1" x="1">&lt;w1&gt;</bpt>Strict<bpt i="2" x="2">&lt;w2&gt;</bpt>Superset<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be finite.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>possible<bpt i="1" x="1">&lt;w1&gt;</bpt>Strict<bpt i="2" x="2">&lt;w2&gt;</bpt>Superset<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は有限でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>possible<bpt i="1" x="1">&lt;w1&gt;</bpt>Subset<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be finite.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>possible<bpt i="1" x="1">&lt;w1&gt;</bpt>Subset<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、有限でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>possible<bpt i="1" x="1">&lt;w1&gt;</bpt>Superset<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be finite.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>possible<bpt i="1" x="1">&lt;w1&gt;</bpt>Superset<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は有限でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>range<ept i="0">&lt;/c0&gt;</ept> must not be empty.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>range<ept i="0">&lt;/c0&gt;</ept>は空であってはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>s<bpt i="1" x="1">&lt;w1&gt;</bpt>.lazy<bpt i="2" x="2">&lt;w2&gt;</bpt>.filter { ... }<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, for an arbitrary sequence <bpt i="3" x="3">&lt;c3&gt;</bpt>s<ept i="3">&lt;/c3&gt;</ept>, is a <bpt i="4" x="4">&lt;c4&gt;</bpt>Lazy<bpt i="5" x="5">&lt;w5&gt;</bpt>Filter<bpt i="6" x="6">&lt;w6&gt;</bpt>Sequence<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>s<bpt i="1" x="1">&lt;w1&gt;</bpt>.lazy<bpt i="2" x="2">&lt;w2&gt;</bpt>.filter { ... }<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、随意のシーケンス<bpt i="3" x="3">&lt;c3&gt;</bpt>s<ept i="3">&lt;/c3&gt;</ept>のための、ひとつの<bpt i="4" x="4">&lt;c4&gt;</bpt>Lazy<bpt i="5" x="5">&lt;w5&gt;</bpt>Filter<bpt i="6" x="6">&lt;w6&gt;</bpt>Sequence<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>scalars<ept i="0">&lt;/c0&gt;</ept> must have the same number of elements as the vector type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>scalars<ept i="0">&lt;/c0&gt;</ept>は、ベクター型と同じ数の要素を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>source<ept i="0">&lt;/c0&gt;</ept> must be representable in this type after rounding toward zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>source<ept i="0">&lt;/c0&gt;</ept>は、ゼロへの丸め後にこの型において表現可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>start<ept i="0">&lt;/c0&gt;</ept> must be a valid index of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>start<ept i="0">&lt;/c0&gt;</ept>はコレクションのひとつの有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>transform<ept i="0">&lt;/c0&gt;</ept> accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>transform<ept i="0">&lt;/c0&gt;</ept>はこのシーケンスのひとつの要素をそれのパラメータとして受け取り、同じもしくは異なる型の変換された値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if <bpt i="1" x="1">&lt;c1&gt;</bpt>element<ept i="1">&lt;/c1&gt;</ept> is contained in the range expression; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>、もし<bpt i="1" x="1">&lt;c1&gt;</bpt>element<ept i="1">&lt;/c1&gt;</ept>がこの範囲式に含まれるならば；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if <bpt i="1" x="1">&lt;c1&gt;</bpt>element<ept i="1">&lt;/c1&gt;</ept> is contained in the range; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>element<ept i="1">&lt;/c1&gt;</ept>がこの範囲に含まれるならば<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if <bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept> has been offset by exactly <bpt i="2" x="2">&lt;c2&gt;</bpt>distance<ept i="2">&lt;/c2&gt;</ept> steps without going beyond <bpt i="3" x="3">&lt;c3&gt;</bpt>limit<ept i="3">&lt;/c3&gt;</ept>; otherwise, <bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>、もし<bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept>が正確に<bpt i="2" x="2">&lt;c2&gt;</bpt>distance<ept i="2">&lt;/c2&gt;</ept>幅だけ<bpt i="3" x="3">&lt;c3&gt;</bpt>limit<ept i="3">&lt;/c3&gt;</ept>を越えていくことなく補われたならば；そうでなければ、<bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if <bpt i="1" x="1">&lt;c1&gt;</bpt>lhs<ept i="1">&lt;/c1&gt;</ept> is greater than or equal to <bpt i="2" x="2">&lt;c2&gt;</bpt>rhs<ept i="2">&lt;/c2&gt;</ept>; otherwise, <bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>を、<bpt i="1" x="1">&lt;c1&gt;</bpt>lhs<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>rhs<ept i="2">&lt;/c2&gt;</ept>より大きいか等しいならば返します；そうでなければ、<bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if <bpt i="1" x="1">&lt;c1&gt;</bpt>member<ept i="1">&lt;/c1&gt;</ept> exists in the set; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>member<ept i="1">&lt;/c1&gt;</ept>がこの集合に含まれるならば<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if the <bpt i="1" x="1">&lt;c1&gt;</bpt>lhs<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>rhs<ept i="2">&lt;/c2&gt;</ept> have the same elements; otherwise, <bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>lhs<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>rhs<ept i="2">&lt;/c2&gt;</ept>が同じ要素を持つならば<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>；そうでなければ<bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if the element was found in the sequence; otherwise, <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要素がシーケンスにおいて見つけられなかったならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>；そうでなければ、<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if the initial elements of the sequence are equivalent to the elements of <bpt i="1" x="1">&lt;c1&gt;</bpt>possible<bpt i="2" x="2">&lt;w2&gt;</bpt>Prefix<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>; otherwise, <bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>、もしシーケンスの冒頭の要素が<bpt i="1" x="1">&lt;c1&gt;</bpt>possible<bpt i="2" x="2">&lt;w2&gt;</bpt>Prefix<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の要素と等しいならば；そうでなければ<bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if the initial elements of the sequence are the same as the elements of <bpt i="1" x="1">&lt;c1&gt;</bpt>possible<bpt i="2" x="2">&lt;w2&gt;</bpt>Prefix<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>; otherwise, <bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>、もしシーケンスの冒頭の要素が<bpt i="1" x="1">&lt;c1&gt;</bpt>possible<bpt i="2" x="2">&lt;w2&gt;</bpt>Prefix<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の要素と同じならば；そうでなければ<bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if the option set contains <bpt i="1" x="1">&lt;c1&gt;</bpt>member<ept i="1">&lt;/c1&gt;</ept>; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オプションセットが<bpt i="1" x="1">&lt;c1&gt;</bpt>member<ept i="1">&lt;/c1&gt;</ept>を含むならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>；そうでなければ<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if the sequence contains an element that satisfies <bpt i="1" x="1">&lt;c1&gt;</bpt>predicate<ept i="1">&lt;/c1&gt;</ept>; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスが<bpt i="1" x="1">&lt;c1&gt;</bpt>predicate<ept i="1">&lt;/c1&gt;</ept>を満たす要素を含むならば<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if the sequence contains only elements that satisfy <bpt i="1" x="1">&lt;c1&gt;</bpt>predicate<ept i="1">&lt;/c1&gt;</ept>; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>、もしシーケンスが<bpt i="1" x="1">&lt;c1&gt;</bpt>predicate<ept i="1">&lt;/c1&gt;</ept>を満たす要素のみを含むならば；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if the set has no elements in common with <bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合が<bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>と共通の要素を持たないならば<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if the set is a strict subset of <bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合が<bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>の狭義の部分集合ならば<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if the set is a strict superset of <bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合が<bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>の狭義の上位集合であるならば<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if the set is a strict superset of <bpt i="1" x="1">&lt;c1&gt;</bpt>possible<bpt i="2" x="2">&lt;w2&gt;</bpt>Strict<bpt i="3" x="3">&lt;w3&gt;</bpt>Subset<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>; otherwise, <bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>、もしこの集合が<bpt i="1" x="1">&lt;c1&gt;</bpt>possible<bpt i="2" x="2">&lt;w2&gt;</bpt>Strict<bpt i="3" x="3">&lt;w3&gt;</bpt>Subset<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の狭義の上位集合であるならば；そうでなければ、<bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if the set is a subset of <bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合が<bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>の部分集合ならば<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if the set is a subset of <bpt i="1" x="1">&lt;c1&gt;</bpt>possible<bpt i="2" x="2">&lt;w2&gt;</bpt>Superset<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>; otherwise, <bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>、もしこの集合が<bpt i="1" x="1">&lt;c1&gt;</bpt>possible<bpt i="2" x="2">&lt;w2&gt;</bpt>Superset<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の部分集合ならば；そうでなければ、<bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if the set is a superset of <bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合が<bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>の上位集合であるならば<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if the set is a superset of <bpt i="1" x="1">&lt;c1&gt;</bpt>possible<bpt i="2" x="2">&lt;w2&gt;</bpt>Subset<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>; otherwise, <bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>、この集合が<bpt i="1" x="1">&lt;c1&gt;</bpt>possible<bpt i="2" x="2">&lt;w2&gt;</bpt>Subset<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の上位集合であるならば；そうでなければ、<bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if this range and <bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept> have at least one element in common; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この範囲と<bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>が少なくとも１つの共通の要素を持つならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if this sequence and <bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept> contain equivalent items, using <bpt i="2" x="2">&lt;c2&gt;</bpt>are<bpt i="3" x="3">&lt;w3&gt;</bpt>Equivalent<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> as the equivalence test; otherwise, <bpt i="4" x="4">&lt;c4&gt;</bpt>false.<ept i="4">&lt;/c4&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>、このシーケンスと<bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>are<bpt i="3" x="3">&lt;w3&gt;</bpt>Equivalent<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を同等性テストとして使って同じ要素らを含むならば；そうでなければ、<bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if this sequence and <bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept> contain the same elements in the same order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスと<bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>が同じ要素を同じ順序で含んでいるならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if this sequence precedes <bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept> in a dictionary ordering as ordered by <bpt i="2" x="2">&lt;c2&gt;</bpt>are<bpt i="3" x="3">&lt;w3&gt;</bpt>In<bpt i="4" x="4">&lt;w4&gt;</bpt>Increasing<bpt i="5" x="5">&lt;w5&gt;</bpt>Order<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>; otherwise, <bpt i="6" x="6">&lt;c6&gt;</bpt>false<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>、もしこのシーケンスが<bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>に、<bpt i="2" x="2">&lt;c2&gt;</bpt>are<bpt i="3" x="3">&lt;w3&gt;</bpt>In<bpt i="4" x="4">&lt;w4&gt;</bpt>Increasing<bpt i="5" x="5">&lt;w5&gt;</bpt>Order<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>によって並べられる通りの字典順序において先行するならば；そうでなければ、<bpt i="6" x="6">&lt;c6&gt;</bpt>false<ept i="6">&lt;/c6&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if this sequence precedes <bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept> in a dictionary ordering; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスが<bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>に、ある字典順序において先行するならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> is the set is strict subset of <bpt i="1" x="1">&lt;c1&gt;</bpt>possible<bpt i="2" x="2">&lt;w2&gt;</bpt>Strict<bpt i="3" x="3">&lt;w3&gt;</bpt>Superset<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>; otherwise, <bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>ならばこの集合は<bpt i="1" x="1">&lt;c1&gt;</bpt>possible<bpt i="2" x="2">&lt;w2&gt;</bpt>Strict<bpt i="3" x="3">&lt;w3&gt;</bpt>Superset<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の狭義の部分集合です；そうでなければ、<bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<bpt i="1" x="1">&lt;w1&gt;</bpt>.contains(e) &amp;&amp; y<bpt i="2" x="2">&lt;w2&gt;</bpt>.contains(e)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if and only if <bpt i="3" x="3">&lt;c3&gt;</bpt>x<bpt i="4" x="4">&lt;w4&gt;</bpt>.intersection(y).contains(e)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<bpt i="1" x="1">&lt;w1&gt;</bpt>.contains(e) &amp;&amp; y<bpt i="2" x="2">&lt;w2&gt;</bpt>.contains(e)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> は次の場合に限ります <bpt i="3" x="3">&lt;c3&gt;</bpt>x<bpt i="4" x="4">&lt;w4&gt;</bpt>.intersection(y).contains(e)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<bpt i="1" x="1">&lt;w1&gt;</bpt>.contains(e)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> implies <bpt i="2" x="2">&lt;c2&gt;</bpt>x<bpt i="3" x="3">&lt;w3&gt;</bpt>.union(y).contains(e)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<bpt i="1" x="1">&lt;w1&gt;</bpt>.contains(e)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> は暗黙的に <bpt i="2" x="2">&lt;c2&gt;</bpt>x<bpt i="3" x="3">&lt;w3&gt;</bpt>.union(y).contains(e)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<bpt i="1" x="1">&lt;w1&gt;</bpt>.is<bpt i="2" x="2">&lt;w2&gt;</bpt>Multiple(of: 0)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept> if <bpt i="4" x="4">&lt;c4&gt;</bpt>x<ept i="4">&lt;/c4&gt;</ept> is zero and <bpt i="5" x="5">&lt;c5&gt;</bpt>false<ept i="5">&lt;/c5&gt;</ept> otherwise.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<bpt i="1" x="1">&lt;w1&gt;</bpt>.is<bpt i="2" x="2">&lt;w2&gt;</bpt>Multiple(of: 0)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept>です、もし<bpt i="4" x="4">&lt;c4&gt;</bpt>x<ept i="4">&lt;/c4&gt;</ept>がゼロであるならば、そしてそうでなければ<bpt i="5" x="5">&lt;c5&gt;</bpt>false<ept i="5">&lt;/c5&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<bpt i="1" x="1">&lt;w1&gt;</bpt>.is<bpt i="2" x="2">&lt;w2&gt;</bpt>Strict<bpt i="3" x="3">&lt;w3&gt;</bpt>Subset(of: y)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if and only if <bpt i="4" x="4">&lt;c4&gt;</bpt>x<bpt i="5" x="5">&lt;w5&gt;</bpt>.is<bpt i="6" x="6">&lt;w6&gt;</bpt>Subset(of: y) &amp;&amp; x != y<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<bpt i="1" x="1">&lt;w1&gt;</bpt>.is<bpt i="2" x="2">&lt;w2&gt;</bpt>Strict<bpt i="3" x="3">&lt;w3&gt;</bpt>Subset(of: y)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> は次の場合に限ります <bpt i="4" x="4">&lt;c4&gt;</bpt>x<bpt i="5" x="5">&lt;w5&gt;</bpt>.is<bpt i="6" x="6">&lt;w6&gt;</bpt>Subset(of: y) &amp;&amp; x != y<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<bpt i="1" x="1">&lt;w1&gt;</bpt>.is<bpt i="2" x="2">&lt;w2&gt;</bpt>Strict<bpt i="3" x="3">&lt;w3&gt;</bpt>Superset(of: y)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if and only if <bpt i="4" x="4">&lt;c4&gt;</bpt>x<bpt i="5" x="5">&lt;w5&gt;</bpt>.is<bpt i="6" x="6">&lt;w6&gt;</bpt>Superset(of: y) &amp;&amp; x != y<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<bpt i="1" x="1">&lt;w1&gt;</bpt>.is<bpt i="2" x="2">&lt;w2&gt;</bpt>Strict<bpt i="3" x="3">&lt;w3&gt;</bpt>Superset(of: y)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> は次の場合に限ります <bpt i="4" x="4">&lt;c4&gt;</bpt>x<bpt i="5" x="5">&lt;w5&gt;</bpt>.is<bpt i="6" x="6">&lt;w6&gt;</bpt>Superset(of: y) &amp;&amp; x != y<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<bpt i="1" x="1">&lt;w1&gt;</bpt>.is<bpt i="2" x="2">&lt;w2&gt;</bpt>Subset(of: y)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if and only if <bpt i="3" x="3">&lt;c3&gt;</bpt>y<bpt i="4" x="4">&lt;w4&gt;</bpt>.is<bpt i="5" x="5">&lt;w5&gt;</bpt>Superset(of: x)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<bpt i="1" x="1">&lt;w1&gt;</bpt>.is<bpt i="2" x="2">&lt;w2&gt;</bpt>Subset(of: y)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> は次の場合に限ります <bpt i="3" x="3">&lt;c3&gt;</bpt>y<bpt i="4" x="4">&lt;w4&gt;</bpt>.is<bpt i="5" x="5">&lt;w5&gt;</bpt>Superset(of: x)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<bpt i="1" x="1">&lt;w1&gt;</bpt>.is<bpt i="2" x="2">&lt;w2&gt;</bpt>Subset(of: y)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> implies <bpt i="3" x="3">&lt;c3&gt;</bpt>x<bpt i="4" x="4">&lt;w4&gt;</bpt>.union(y) == y<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<bpt i="1" x="1">&lt;w1&gt;</bpt>.is<bpt i="2" x="2">&lt;w2&gt;</bpt>Subset(of: y)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> は暗黙的に <bpt i="3" x="3">&lt;c3&gt;</bpt>x<bpt i="4" x="4">&lt;w4&gt;</bpt>.union(y) == y<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<bpt i="1" x="1">&lt;w1&gt;</bpt>.is<bpt i="2" x="2">&lt;w2&gt;</bpt>Superset(of: y)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> implies <bpt i="3" x="3">&lt;c3&gt;</bpt>x<bpt i="4" x="4">&lt;w4&gt;</bpt>.union(y) == x<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<bpt i="1" x="1">&lt;w1&gt;</bpt>.is<bpt i="2" x="2">&lt;w2&gt;</bpt>Superset(of: y)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> は暗黙的に <bpt i="3" x="3">&lt;c3&gt;</bpt>x<bpt i="4" x="4">&lt;w4&gt;</bpt>.union(y) == x<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<bpt i="1" x="1">&lt;w1&gt;</bpt>.union(y).contains(e)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> implies <bpt i="2" x="2">&lt;c2&gt;</bpt>x<bpt i="3" x="3">&lt;w3&gt;</bpt>.contains(e) || y<bpt i="4" x="4">&lt;w4&gt;</bpt>.contains(e)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<bpt i="1" x="1">&lt;w1&gt;</bpt>.union(y).contains(e)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> は暗黙的に <bpt i="2" x="2">&lt;c2&gt;</bpt>x<bpt i="3" x="3">&lt;w3&gt;</bpt>.contains(e) || y<bpt i="4" x="4">&lt;w4&gt;</bpt>.contains(e)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Optional<bpt i="2" x="2">&lt;w2&gt;</bpt>.none<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is equivalent to the <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept> literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Optional<bpt i="2" x="2">&lt;w2&gt;</bpt>.none<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>は、<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>リテラルに等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>count<ept i="1">&lt;/c1&gt;</ept> must be zero or greater.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>count<ept i="1">&lt;/c1&gt;</ept>は、ゼロまたはより大きくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>distance<ept i="1">&lt;/c1&gt;</ept> must not be negative unless the collection conforms to the <bpt i="2" x="2">&lt;c2&gt;</bpt>Bidirectional<bpt i="3" x="3">&lt;w3&gt;</bpt>Collection<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>distance<ept i="1">&lt;/c1&gt;</ept>は、そのコレクションが<bpt i="2" x="2">&lt;c2&gt;</bpt>Bidirectional<bpt i="3" x="3">&lt;w3&gt;</bpt>Collection<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルに準拠するのでない限り、負であってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>radix<ept i="1">&lt;/c1&gt;</ept> must be in the range <bpt i="2" x="2">&lt;c2&gt;</bpt>2...36<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>radix<ept i="1">&lt;/c1&gt;</ept>は、範囲<bpt i="2" x="2">&lt;c2&gt;</bpt>2...36<ept i="2">&lt;/c2&gt;</ept>の中でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>rhs<ept i="1">&lt;/c1&gt;</ept> must not be zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>rhs<ept i="1">&lt;/c1&gt;</ept>は、ゼロではなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Shipping<bpt i="3" x="3">&lt;w3&gt;</bpt>Options<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> includes a <bpt i="4" x="4">&lt;c4&gt;</bpt>raw<bpt i="5" x="5">&lt;w5&gt;</bpt>Value<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> property of type <bpt i="6" x="6">&lt;c6&gt;</bpt>Int<ept i="6">&lt;/c6&gt;</ept> that stores the bit mask of available shipping options.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Shipping<bpt i="3" x="3">&lt;w3&gt;</bpt>Options<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は、型<bpt i="6" x="6">&lt;c6&gt;</bpt>Int<ept i="6">&lt;/c6&gt;</ept>の<bpt i="4" x="4">&lt;c4&gt;</bpt>raw<bpt i="5" x="5">&lt;w5&gt;</bpt>Value<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>プロパティを含みます、それは可能な出荷オプションのビットマスクを格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>T<ept i="2">&lt;/c2&gt;</ept> may have a lower minimal alignment that trades runtime performance for space efficiency.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>T<ept i="2">&lt;/c2&gt;</ept>は、空間能率に対する実行時性能と引き換えに、より低い極小のアラインメントを持ってもかまいません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>element<ept i="2">&lt;/c2&gt;</ept> is contained in the range if it is greater than or equal to the lower bound and less than the upper bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>element<ept i="2">&lt;/c2&gt;</ept>が範囲の中のに含まれるのは、それが下方境界より大きいか等しく上方境界より少ない場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>max<bpt i="3" x="3">&lt;w3&gt;</bpt>Splits<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> must be greater than or equal to zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>max<bpt i="3" x="3">&lt;w3&gt;</bpt>Splits<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は、ゼロより大きいか等しくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>for<ept i="3">&lt;/c3&gt;</ept>-<bpt i="4" x="4">&lt;c4&gt;</bpt>in<ept i="4">&lt;/c4&gt;</ept> loops are safe in this regard.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>for<ept i="3">&lt;/c3&gt;</ept>-<bpt i="4" x="4">&lt;c4&gt;</bpt>in<ept i="4">&lt;/c4&gt;</ept>ループはこの点に関して安全です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>Optional<bpt i="5" x="5">&lt;w5&gt;</bpt>.some(Wrapped)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> stores a wrapped value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>Optional<bpt i="5" x="5">&lt;w5&gt;</bpt>.some(Wrapped)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は、あるラップされた値を格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt>Range<bpt i="7" x="7">&lt;w7&gt;</bpt>Replaceable<bpt i="8" x="8">&lt;w8&gt;</bpt>Collection<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> provides default implementations of all its other methods using this initializer and method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt>Range<bpt i="7" x="7">&lt;w7&gt;</bpt>Replaceable<bpt i="8" x="8">&lt;w8&gt;</bpt>Collection<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>は、それの他のメソッドすべての省略時の実装をこのイニシャライザとメソッドを使って提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>Required.<ept i="0">&lt;/s0&gt;</ept> Default implementation provided.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>必須。<ept i="0">&lt;/s0&gt;</ept> 省略時の実装の提供。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>Required.<ept i="0">&lt;/s0&gt;</ept> Default implementations provided.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>必須。<ept i="0">&lt;/s0&gt;</ept> いくつかの省略時の実装の提供。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>See Also<ept i="0">&lt;/s0&gt;</ept><bpt i="1" x="1">&lt;s1&gt;</bpt> <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;p3&gt;</bpt><ept i="3">&lt;/p3&gt;</ept><ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/s1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>参照<ept i="0">&lt;/s0&gt;</ept><bpt i="1" x="1">&lt;s1&gt;</bpt> <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;p3&gt;</bpt><ept i="3">&lt;/p3&gt;</ept><ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/s1&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A 16-bit signed integer value type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>16ビット符号つき整数値型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A 32-bit signed integer value type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>32ビット符号つき整数値型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A 64-bit integer value converts to an <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<bpt i="3" x="3">&lt;w3&gt;</bpt>.Value<bpt i="4" x="4">&lt;w4&gt;</bpt>Type<bpt i="5" x="5">&lt;w5&gt;</bpt>.int<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>64ビット整数値は、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<bpt i="3" x="3">&lt;w3&gt;</bpt>.Value<bpt i="4" x="4">&lt;w4&gt;</bpt>Type<bpt i="5" x="5">&lt;w5&gt;</bpt>.int<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>に変わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A 64-bit signed integer value type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>64ビット符号付き整数値型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<ept i="0">&lt;/c0&gt;</ept> that provides its own implementation of this method must also guarantee that an equivalent buffer of its <bpt i="1" x="1">&lt;c1&gt;</bpt>Sub<bpt i="2" x="2">&lt;w2&gt;</bpt>Sequence<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> can be generated by advancing the pointer by the distance to the slice’s <bpt i="3" x="3">&lt;c3&gt;</bpt>start<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドのそれ独自の実装を提供する<bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<ept i="0">&lt;/c0&gt;</ept>はまた、それの<bpt i="1" x="1">&lt;c1&gt;</bpt>Sub<bpt i="2" x="2">&lt;w2&gt;</bpt>Sequence<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の同等のバッファが、スライスのもつ<bpt i="3" x="3">&lt;c3&gt;</bpt>start<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>への隔たりだけポインタを前進することによって生成されることを保証しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<ept i="0">&lt;/c0&gt;</ept> whose elements consist of those in a <bpt i="1" x="1">&lt;c1&gt;</bpt>Base<ept i="1">&lt;/c1&gt;</ept> <bpt i="2" x="2">&lt;c2&gt;</bpt>Collection<ept i="2">&lt;/c2&gt;</ept> passed through a transform function returning <bpt i="3" x="3">&lt;c3&gt;</bpt>Element<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある<bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<ept i="0">&lt;/c0&gt;</ept>、その要素は<bpt i="1" x="1">&lt;c1&gt;</bpt>Base<ept i="1">&lt;/c1&gt;</ept> <bpt i="2" x="2">&lt;c2&gt;</bpt>Collection<ept i="2">&lt;/c2&gt;</ept>の中のものから成り、<bpt i="3" x="3">&lt;c3&gt;</bpt>Element<ept i="3">&lt;/c3&gt;</ept>を返す変換関数を通して渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>Result<ept i="0">&lt;/c0&gt;</ept> instance with the result of evaluating <bpt i="1" x="1">&lt;c1&gt;</bpt>transform<ept i="1">&lt;/c1&gt;</ept> as the new failure value if this instance represents a failure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある<bpt i="0" x="0">&lt;c0&gt;</bpt>Result<ept i="0">&lt;/c0&gt;</ept>インスタンスで<bpt i="1" x="1">&lt;c1&gt;</bpt>transform<ept i="1">&lt;/c1&gt;</ept>を評価する結果をもちます、もしこのインスタンスが失敗を表すならば新しい失敗値として。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>Result<ept i="0">&lt;/c0&gt;</ept> instance with the result of evaluating <bpt i="1" x="1">&lt;c1&gt;</bpt>transform<ept i="1">&lt;/c1&gt;</ept> as the new success value if this instance represents a success.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある<bpt i="0" x="0">&lt;c0&gt;</bpt>Result<ept i="0">&lt;/c0&gt;</ept>インスタンス、<bpt i="1" x="1">&lt;c1&gt;</bpt>transform<ept i="1">&lt;/c1&gt;</ept>を評価する結果をもつ、もしこのインスタンスが成功を表すならば新しい成功値として。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>Result<ept i="0">&lt;/c0&gt;</ept> instance, either from the closure or the previous <bpt i="1" x="1">&lt;c1&gt;</bpt>.failure<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Result<ept i="0">&lt;/c0&gt;</ept>インスタンス、クロージャまたは前の<bpt i="1" x="1">&lt;c1&gt;</bpt>.failure<ept i="1">&lt;/c1&gt;</ept>のどちらかから。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>Result<ept i="0">&lt;/c0&gt;</ept> instance, either from the closure or the previous <bpt i="1" x="1">&lt;c1&gt;</bpt>.success<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Result<ept i="0">&lt;/c0&gt;</ept>インスタンス、クロージャまたは前の<bpt i="1" x="1">&lt;c1&gt;</bpt>.success<ept i="1">&lt;/c1&gt;</ept>のどちらかから。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>Sequence<ept i="0">&lt;/c0&gt;</ept> that can contain the same elements as this one, possibly with a simpler type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このものと同じ要素を、できる限りより簡単な型で、含む<bpt i="0" x="0">&lt;c0&gt;</bpt>Sequence<ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>Sequence<ept i="0">&lt;/c0&gt;</ept> whose elements consist of those in a <bpt i="1" x="1">&lt;c1&gt;</bpt>Base<ept i="1">&lt;/c1&gt;</ept> <bpt i="2" x="2">&lt;c2&gt;</bpt>Sequence<ept i="2">&lt;/c2&gt;</ept> passed through a transform function returning <bpt i="3" x="3">&lt;c3&gt;</bpt>Element<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある<bpt i="0" x="0">&lt;c0&gt;</bpt>Sequence<ept i="0">&lt;/c0&gt;</ept>、その要素は<bpt i="1" x="1">&lt;c1&gt;</bpt>Base<ept i="1">&lt;/c1&gt;</ept> <bpt i="2" x="2">&lt;c2&gt;</bpt>Sequencellection<ept i="2">&lt;/c2&gt;</ept>の中のものから成り、<bpt i="3" x="3">&lt;c3&gt;</bpt>Element<ept i="3">&lt;/c3&gt;</ept>を返す変換関数を通して渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A <bpt i="1" x="1">&lt;c1&gt;</bpt>Reversed<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> instance wraps an underlying collection and provides access to its elements in reverse order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Reversed<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>インスタンスは、基礎をなすコレクションをラップして、それの要素へのアクセスを逆順で提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A <bpt i="4" x="4">&lt;c4&gt;</bpt>Range<ept i="4">&lt;/c4&gt;</ept> instance does not contain its upper bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>Range<ept i="4">&lt;/c4&gt;</ept>インスタンスはそれの上方の境界を含みません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Boolean value indicating whether the collection is empty.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションが空かどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Boolean value indicating whether the range contains no elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲が何の要素も含まないかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Boolean value indicating whether this type is a signed integer type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型が符号付き整数型であるかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Boolean value that indicates whether the set has no elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合が要素をひとつも持たないかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Boolean value that indicates whether the set is empty.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合が空かどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Combine publisher that publishes each member of the sequence as a separate element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるCombineパブリッシャー、それはシーケンスの各要素を別個の要素として発行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Combine publisher that publishes this instance’s result to each subscriber exactly once, or fails immediately if the result indicates failure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるCombineパブリッシャー、それはこのインスタンスのもつ結果を各加入者に正確に一度だけ発行します、または結果が不成功を指し示すならば直ぐに失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Combine publisher that publishes this instance’s value to each subscriber exactly once, if it has a value at all.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるCombineパブリッシャー、それはこのインスタンスのもつ値を各加入者に正確に一度だけ発行します、とにかくそれが値を持つならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A SIMD vector of a fixed number of elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>固定された数の要素のSIMDベクター。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A bitwise AND operation results in a value that has each bit set to <bpt i="0" x="0">&lt;c0&gt;</bpt>1<ept i="0">&lt;/c0&gt;</ept> where <bpt i="1" x="1">&lt;e1&gt;</bpt>both<ept i="1">&lt;/e1&gt;</ept> of its arguments have that bit set to <bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ビット単位AND演算は、ある値という結果になります、それが各ビットを<bpt i="0" x="0">&lt;c0&gt;</bpt>1<ept i="0">&lt;/c0&gt;</ept>に設定するのは、<bpt i="1" x="1">&lt;e1&gt;</bpt>両方<ept i="1">&lt;/e1&gt;</ept>のそれの引数が、そのビットを<bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>に設定するところです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A bitwise OR operation results in a value that has each bit set to <bpt i="0" x="0">&lt;c0&gt;</bpt>1<ept i="0">&lt;/c0&gt;</ept> where <bpt i="1" x="1">&lt;e1&gt;</bpt>one or both<ept i="1">&lt;/e1&gt;</ept> of its arguments have that bit set to <bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ビット単位OR演算は、ある値という結果になります、それが各ビットを<bpt i="0" x="0">&lt;c0&gt;</bpt>1<ept i="0">&lt;/c0&gt;</ept>に設定するのは、<bpt i="1" x="1">&lt;e1&gt;</bpt>一方または両方<ept i="1">&lt;/e1&gt;</ept>のそれの引数が、そのビットを<bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>に設定するところです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A bitwise XOR operation, also known as an exclusive OR operation, results in a value that has each bit set to <bpt i="0" x="0">&lt;c0&gt;</bpt>1<ept i="0">&lt;/c0&gt;</ept> where <bpt i="1" x="1">&lt;e1&gt;</bpt>one or the other but not both<ept i="1">&lt;/e1&gt;</ept> of its arguments had that bit set to <bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ビット単位XOR演算、または排他的OR演算として知られるものは、１つの値という結果になり、それは各ビットが<bpt i="0" x="0">&lt;c0&gt;</bpt>1<ept i="0">&lt;/c0&gt;</ept>に設定されます、そこにおいて<bpt i="1" x="1">&lt;e1&gt;</bpt>一方または他方しかし両方でなく<ept i="1">&lt;/e1&gt;</ept>それの引数がそのビットを<bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A class that conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Custom<bpt i="1" x="1">&lt;w1&gt;</bpt>Reflectable<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol can control how its mirror represents ancestor classes by initializing the mirror with an <bpt i="2" x="2">&lt;c2&gt;</bpt>Ancestor<bpt i="3" x="3">&lt;w3&gt;</bpt>Representation<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Custom<bpt i="1" x="1">&lt;w1&gt;</bpt>Reflectable<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠するクラスは、どのようにそれのミラーが先祖クラスを表すかを、ミラーを<bpt i="2" x="2">&lt;c2&gt;</bpt>Ancestor<bpt i="3" x="3">&lt;w3&gt;</bpt>Representation<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>で初期化することで制御できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A class whose instances contain a property of type <bpt i="0" x="0">&lt;c0&gt;</bpt>Header<ept i="0">&lt;/c0&gt;</ept> and raw storage for an array of <bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept>, whose size is determined at instance creation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクラス、そのインスタンスは型<bpt i="0" x="0">&lt;c0&gt;</bpt>Header<ept i="0">&lt;/c0&gt;</ept>のプロパティと、そのサイズがインスタンス作成時に決められる、<bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept>配列の生のストレージを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closed range to convert to a <bpt i="0" x="0">&lt;c0&gt;</bpt>Range<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Range<ept i="0">&lt;/c0&gt;</ept>インスタンスへ変換することになるある完結範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that accepts an element of this sequence as its argument and returns a sequence or collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それはこのシーケンスのひとつの要素をそれの引数として受け取って、あるシーケンスまたはコレクションを返すものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that accepts an element of this sequence as its argument and returns an optional value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それはこのシーケンスのひとつの要素をそれの引数として受け取って、ひとつのオプショナルの値を返すものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the <bpt i="0" x="0">&lt;c0&gt;</bpt>next<bpt i="1" x="1">&lt;w1&gt;</bpt>Partial<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> closure or returned to the caller.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それは蓄積値をシーケンスのいち要素と結合して新しい蓄積値とし、<bpt i="0" x="0">&lt;c0&gt;</bpt>next<bpt i="1" x="1">&lt;w1&gt;</bpt>Partial<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>クロージャの次の呼び出しにおいて使われるか、呼び出し側に返されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that returns <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if its argument should be used to split the sequence; otherwise, <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>１つのクロージャ、それはそれの引数が使われてシーケンスを分割するならば<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>を；そうでなければ、<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that returns a Boolean value indicating whether two elements are equivalent.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの要素が等しいかどうかを指し示しているブール値を返すクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それは１つの要素を引数として取り、コレクションがその要素で分割されるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an element as its argument and returns a Boolean value indicating whether the element should be included in the returned set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それはある要素をそれの引数として取り、その要素が返される集合に含まれるべきかどうかを示すブール値を返すものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それは１つの要素をそれの引数として取り、渡された要素が合致するものであるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an element of the sequence as a parameter.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それはシーケンスの１要素を引数として取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an element of the sequence as its argument and returns <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if the element should be included or <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept> if it should be excluded.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それはシーケンスの１つの要素をそれの引数として取り、その要素が含まれるべきならば<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>をまたはそれが除外されるべきならば<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an element of the sequence as its argument and returns <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if the element should be included or <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept> otherwise.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それはシーケンスの１つの要素をそれの引数として取り、その要素が含まれるべきならば<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>を、またはそうでなければ<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an element of the sequence as its argument and returns <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if the element should be skipped or <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept> if it should be included.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それはシーケンスの１つの要素をそれの引数として取り、その要素が省かれるべきならば<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>をまたはそれが含まれるべきならば<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an element of the sequence as its argument and returns <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if the element should be skipped or <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept> otherwise.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それはシーケンスの１つの要素をそれの引数として取り、その要素が省かれるべきならば<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>を、またはそうでなければ<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それはシーケンスの１つの要素をそれの引数として取り、その要素が合致するものかどうかを指し示しているブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それはシーケンスの１つの要素をそれの引数として取り、その要素が結果に含まれるべきかどうかを指し示しているブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それはシーケンスの１つの要素をそれの引数として取り、その要素が返される配列に含まれるべきかどうかを指し示しているブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それはシーケンスの１つの要素をそれの引数として取り、その要素が返されるコレクションに含まれるべきかどうかを指し示しているブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be removed from the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それはシーケンスの１つの要素をそれの引数として取り、その要素がコレクションから除去されるべきかどうかを指し示しているブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それはこのシーケンスの１つの要素をそれの引数として取り、渡された要素が合致するものであるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それはこのシーケンスの１つの要素をそれの引数として取り、渡された要素がある条件を満たすかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes the failure value of the instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インスタンスの失敗値をとるクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes the success value of the instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのインスタンスの成功した値をとるクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes the success value of this instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このインスタンスの成功した値をとるクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes the unwrapped value of the instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このインスタンスのアンラップされた値をとるクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that updates the accumulating value with an element of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>蓄積される値をこのシーケンスのある要素を使って更新するクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection containing a single element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>単一の要素を含んでいるコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection containing the same elements as a <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept> collection, but on which some operations such as <bpt i="1" x="1">&lt;c1&gt;</bpt>map<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>filter<ept i="2">&lt;/c2&gt;</ept> are implemented lazily.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept>コレクションと同じ要素を含んでいるあるコレクション、しかしそれの上で何らかの演算、例えば<bpt i="1" x="1">&lt;c1&gt;</bpt>map<ept i="1">&lt;/c1&gt;</ept>や<bpt i="2" x="2">&lt;c2&gt;</bpt>filter<ept i="2">&lt;/c2&gt;</ept>が遅延に実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection containing the words of this value’s binary representation, in order from the least significant to most significant.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値の持つバイナリ表現の単語いくらかを含んでいるコレクション、最下位から最上位への順番で。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection of <bpt i="0" x="0">&lt;c0&gt;</bpt>Child<ept i="0">&lt;/c0&gt;</ept> elements describing the structure of the reflected subject.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Child<ept i="0">&lt;/c0&gt;</ept>要素のコレクションで、リフレクションされる主題の構造体を記述しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection of insertions and removals that describe the difference between two ordered collection states.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの順序付きコレクション状態の間の差異を記述するいくらかの挿入と除去からなるあるコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection of the elements that <bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Included<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> allowed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Included<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を認められた要素それらからなるあるコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection on which normally-eager operations such as <bpt i="0" x="0">&lt;c0&gt;</bpt>map<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>filter<ept i="1">&lt;/c1&gt;</ept> are implemented lazily.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるコレクション、それにおいては通常は先行な演算、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>map<ept i="0">&lt;/c0&gt;</ept>や<bpt i="1" x="1">&lt;c1&gt;</bpt>filter<ept i="1">&lt;/c1&gt;</ept>は、遅延に実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection or finite sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションまたは有限のシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection that presents the elements of its base collection in reverse order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるコレクション、それは、それの基盤コレクションの要素を逆順で提示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection that represents a contiguous subrange of the collection’s elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションのもつ要素の隣接下位範囲を表すコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection that supports backward as well as forward traversal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>前方にだけでなく後方へ辿っていくこともサポートするコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection that supports efficient random-access index traversal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>効率のよい無作為アクセスのインデックス探査をサポートするコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection that supports replacement of an arbitrary subrange of elements with the elements of another collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>随意の下位範囲の要素を別のコレクションの要素で置き換えることをサポートするコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection that supports subscript assignment.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>添え字を使った代入をサポートするコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection whose element type is <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> but that is always empty.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それの要素型は<bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>である、しかし常に空であるコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection whose elements are all identical.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるコレクション、その要素は全て同一です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection whose elements are key-value pairs.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それの要素がキー値ペアであるコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection’s <bpt i="0" x="0">&lt;c0&gt;</bpt>indices<ept i="0">&lt;/c0&gt;</ept> property can hold a strong reference to the collection itself, causing the collection to be non-uniquely referenced.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるコレクションの<bpt i="0" x="0">&lt;c0&gt;</bpt>indices<ept i="0">&lt;/c0&gt;</ept>プロパティは、そのコレクション自身に対する強い参照を保持でき、そのコレクションが特有にでなくとも参照されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection’s <bpt i="0" x="0">&lt;c0&gt;</bpt>indices<ept i="0">&lt;/c0&gt;</ept> property can hold a strong reference to the collection itself, causing the collection to be nonuniquely referenced.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるコレクションの<bpt i="0" x="0">&lt;c0&gt;</bpt>indices<ept i="0">&lt;/c0&gt;</ept>プロパティは、そのコレクション自身に対する強い参照を保持でき、そのコレクションが非特有に参照されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A common timing mistake is expecting the results of an asynchronous call to be available within the calling synchronous code.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>よくあるタイミング間違いは、非同期呼び出しの結果が、呼び出している同期的コード内部で利用可能であると予想することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A concrete container that provides a view into a decoder’s storage, making the encoded properties of a decodable type accessible by keys.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある具体的なコンテナで、あるデコーダの持つストレージへのビューを提供します、デコーダ可能型のエンコードされたプロパティをキーによってアクセス可能にしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A concrete container that provides a view into an encoder’s storage, making the encoded properties of an encodable type accessible by keys.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある具体的なコンテナで、あるエンコーダの持つストレージへのビューを提供します、エンコード可能型のエンコードされたプロパティをキーによってアクセス可能にしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A conforming sequence that is not a collection is allowed to produce an arbitrary sequence of elements in the second <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> loop.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>準拠しているシーケンスでコレクションではないものは、２番目の<bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>ループにおいて幾つかの要素からなる随意のシーケンスを生み出すことを許可されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A container that can support the storage and direct decoding of a single nonkeyed value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>単一非キー値のストレージおよび直接デコーディングをサポートできるコンテナ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A container that can support the storage and direct encoding of a single non-keyed value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>単一非キー値のストレージおよび直接エンコーディングをサポートできるコンテナ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A custom <bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Number<bpt i="2" x="2">&lt;w2&gt;</bpt>Generator<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type can have different characteristics than the default <bpt i="3" x="3">&lt;c3&gt;</bpt>System<bpt i="4" x="4">&lt;w4&gt;</bpt>Random<bpt i="5" x="5">&lt;w5&gt;</bpt>Number<bpt i="6" x="6">&lt;w6&gt;</bpt>Generator<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あつらえの<bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Number<bpt i="2" x="2">&lt;w2&gt;</bpt>Generator<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型は、省略時の<bpt i="3" x="3">&lt;c3&gt;</bpt>System<bpt i="4" x="4">&lt;w4&gt;</bpt>Random<bpt i="5" x="5">&lt;w5&gt;</bpt>Number<bpt i="6" x="6">&lt;w6&gt;</bpt>Generator<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>型とは異なる特徴を持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A custom playground Quick Look for the <bpt i="0" x="0">&lt;c0&gt;</bpt>Int64<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Int64<ept i="0">&lt;/c0&gt;</ept>インスタンスのためのあつらえのプレイグラウンド「クイックルック」。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A custom playground Quick Look for the <bpt i="0" x="0">&lt;c0&gt;</bpt>Int8<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Int8<ept i="0">&lt;/c0&gt;</ept>インスタンスのためのあつらえのプレイグラウンド「クイックルック」。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A decoded value of the requested type, or <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> if the <bpt i="1" x="1">&lt;c1&gt;</bpt>Decoder<ept i="1">&lt;/c1&gt;</ept> does not have an entry associated with the given key, or if the value is a null value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要求された型にデコード済みの値、または<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>、もし<bpt i="1" x="1">&lt;c1&gt;</bpt>Decoder<ept i="1">&lt;/c1&gt;</ept>が与えられたキーに関連する登録項目を持たない場合は、またはその値がnull値の場合は。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A dictionary literal to use as the structure for the mirror.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ミラーのための構造体として使うことになる辞書リテラル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A failure, storing a <bpt i="0" x="0">&lt;c0&gt;</bpt>Failure<ept i="0">&lt;/c0&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある失敗、<bpt i="0" x="0">&lt;c0&gt;</bpt>Failure<ept i="0">&lt;/c0&gt;</ept>値を格納しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A flattened view of the elements of this sequence of sequences.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>複数のシーケンスからなるこのシーケンスの要素のある平坦なビュー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A floating-point value to convert to an integer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>整数へと変換する浮動小数点値．</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A four-element vector created by appending a scalar to a three-element vector.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるスカラーを３要素ベクターに追加することによって作成される４要素ベクター。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A function that produces the initial <bpt i="0" x="0">&lt;c0&gt;</bpt>Header<ept i="0">&lt;/c0&gt;</ept> instance stored in the buffer, given the <bpt i="1" x="1">&lt;c1&gt;</bpt>buffer<ept i="1">&lt;/c1&gt;</ept> object and a function that can be called on it to get the actual number of allocated elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>バッファに格納される初期<bpt i="0" x="0">&lt;c0&gt;</bpt>Header<ept i="0">&lt;/c0&gt;</ept>インスタンスを生成する関数、<bpt i="1" x="1">&lt;c1&gt;</bpt>buffer<ept i="1">&lt;/c1&gt;</ept>オブジェクトおよびそれの上で呼び出されて割り当てられた要素の実際の数を得る関数を与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A half-length vector made up of the even elements of the vector.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ベクターの偶数番目の要素から作り上げられる半分長のベクター。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A half-length vector made up of the high elements of the vector.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ベクターの高い方の要素からから作り上げられる半分長のベクター。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A half-length vector made up of the low elements of the vector.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ベクターの低い方の要素からから作り上げられる半分長のベクター。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A half-length vector made up of the odd elements of the vector.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ベクターの奇数番目の要素から作り上げられる半分長のベクター。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A half-open interval from a lower bound up to, but not including, an upper bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下側の境界から、上側の境界まで、しかしそれを含んでいない、半開間隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A key path from a specific root type to a specific resulting value type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>特定の根本の型から特定の結果値の型へのキーパス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A key path referring to storage that can be accessed through a value of type <bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型<bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept>の値を通してアクセス可能なストレージを参照しているキーパス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A key path that supports reading from and writing to the resulting value with reference semantics.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果値からのよみ出し及びそれへの書き込みを参照意味論でサポートするキーパス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A key path that supports reading from and writing to the resulting value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果値からのよみ出し及びそれへの書き込みをサポートするキーパス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A keyed decoding container view into <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>へのキー付きデコーディングコンテナビュー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A lazy <bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<ept i="0">&lt;/c0&gt;</ept> wrapper that includes the elements of an underlying collection that satisfy a predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>遅延な<bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<ept i="0">&lt;/c0&gt;</ept>ラッパー、それは根底にあるコレクションの要素のうち、ある述部を満足させるものを含めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A lazy collection wrapper that includes the initial consecutive elements of an underlying collection that satisfy a predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>遅延collectionラッパー、それは根底にあるコレクションのうち、ある述部を満足させる、最初の連続した要素を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A lazy wrapper that includes the elements of an underlying collection after any initial consecutive elements that satisfy a predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>遅延なラッパー、それは根底にあるコレクションのうち、ある述部を満足させる何らかの最初の連続した要素の後ろの要素らを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A lightweight collection of key-value pairs.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キー値ペアの軽量コレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A list of elements of the new set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい集合の要素のリスト。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A mapping closure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>マップを行うクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A member of the set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合の中のひとつのメンバ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A mirror describes the parts that make up a particular instance, such as the instance’s stored properties, collection or tuple elements, or its active enumeration case.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ミラーは様々な部分を叙述します、それらはある特定のインスタンスを作り上げるものです、例えばそのインスタンスのもつ格納プロパティ、コレクションまたはタプルの要素、またはそれの動的列挙ケース節など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A mirror of the subject’s superclass, if one exists.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>主題の持つスーパークラスのミラー、もしそれが存在するならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A mirror that reflects the <bpt i="0" x="0">&lt;c0&gt;</bpt>Int64<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Int64<ept i="0">&lt;/c0&gt;</ept>インスタンスを反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A mirror that reflects the <bpt i="0" x="0">&lt;c0&gt;</bpt>Int8<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Int8<ept i="0">&lt;/c0&gt;</ept>インスタンスを反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A mirror that reflects the iterator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのイテレータを反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A mirror that reflects the set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その集合を反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A mutable pointer addressing an Objective-C reference that doesn’t own its target.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それのターゲットを所有しないObjective-C参照をアドレス指定している可変ポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A new <bpt i="0" x="0">&lt;c0&gt;</bpt>Decoder<ept i="0">&lt;/c0&gt;</ept> to pass to <bpt i="1" x="1">&lt;c1&gt;</bpt>super<bpt i="2" x="2">&lt;w2&gt;</bpt>.init(from:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>super<bpt i="2" x="2">&lt;w2&gt;</bpt>.init(from:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に渡すための新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>Decoder<ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A new encoder to pass to <bpt i="0" x="0">&lt;c0&gt;</bpt>super<bpt i="1" x="1">&lt;w1&gt;</bpt>.encode(to:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>super<bpt i="1" x="1">&lt;w1&gt;</bpt>.encode(to:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に渡すための新しいエンコーダ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A new instance initialized with <bpt i="0" x="0">&lt;c0&gt;</bpt>raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> will be equivalent to this instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>で初期化された新しいインスタンスは、このインスタンスに相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A new keyed encoding container.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいキー付けされるエンコーディングコンテナ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A new option set made up of the elements contained in this set, in <bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>, or in both.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合の中に、<bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>の中に、または両方の中に含まれる要素から作り上げられるオプションセット。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A new option set with only the elements contained in both this set and <bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合と<bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>の両方に含まれる要素のみをもつ新しいオプションセット。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A new option set with only the elements contained in either this set or <bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>, but not in both.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合または<bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>のどちらかに、しかし両方にではなく含まれる要素のみをもつ新しいオプションセット。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A new range clamped to the bounds of <bpt i="0" x="0">&lt;c0&gt;</bpt>limits<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>limits<ept i="0">&lt;/c0&gt;</ept>の境界内に制限された、新しい範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A new set with the unique elements of this set and <bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合と<bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>との特有な要素を持つ新しい集合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A new set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい集合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A new unkeyed encoding container.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいキー付けされないエンコーディングコンテナ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A numeric value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある数値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A partial half-open interval up to, but not including, an upper bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>上側の境界までの、しかしそれを含まない部分的半開間隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A partial interval extending upward from a lower bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある下側の境界から上向きに拡張する部分的な間隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A partial interval up to, and including, an upper bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある上側の境界までの、そしてそれを含んでいる部分的な間隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A partially type-erased key path, from a concrete root type to any resulting value type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある部分的な型消去キーパス、具体的な根本の型から何らかの結果値の型への。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A position in a <bpt i="0" x="0">&lt;c0&gt;</bpt>Lazy<bpt i="1" x="1">&lt;w1&gt;</bpt>Prefix<bpt i="2" x="2">&lt;w2&gt;</bpt>While<bpt i="3" x="3">&lt;w3&gt;</bpt>Collection<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> or <bpt i="4" x="4">&lt;c4&gt;</bpt>Lazy<bpt i="5" x="5">&lt;w5&gt;</bpt>Prefix<bpt i="6" x="6">&lt;w6&gt;</bpt>While<bpt i="7" x="7">&lt;w7&gt;</bpt>Bidirectional<bpt i="8" x="8">&lt;w8&gt;</bpt>Collection<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Lazy<bpt i="1" x="1">&lt;w1&gt;</bpt>Prefix<bpt i="2" x="2">&lt;w2&gt;</bpt>While<bpt i="3" x="3">&lt;w3&gt;</bpt>Collection<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>または<bpt i="4" x="4">&lt;c4&gt;</bpt>Lazy<bpt i="5" x="5">&lt;w5&gt;</bpt>Prefix<bpt i="6" x="6">&lt;w6&gt;</bpt>While<bpt i="7" x="7">&lt;w7&gt;</bpt>Bidirectional<bpt i="8" x="8">&lt;w8&gt;</bpt>Collection<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>インスタンスの中のある位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A predicate that returns <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if its first argument should be ordered before its second argument; otherwise, <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある述部、それはそれの最初の引数がそれの２番目の引数の前に並べられるべきならば<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>を返します；そうでなければ、<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A predicate that returns <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if its two arguments are equivalent; otherwise, <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある述部、それはそれの２つの引数が等しいならば<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>を返します；そうでなければ、<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A predicate used to partition the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションに仕切りをするのに使われる述部。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A property has inline, directly addressable storage when it is a stored property for which no additional work is required to extract or set the value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるプロパティは、インラインに、直接にアドレス指定可能なストレージを持ちます、それが値を抽出または設定するのに追加的な仕事が要求されない格納プロパティである場合は。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A protocol for legitimate arguments to <bpt i="0" x="0">&lt;c0&gt;</bpt>Mirror<ept i="0">&lt;/c0&gt;</ept>’s <bpt i="1" x="1">&lt;c1&gt;</bpt>descendant<ept i="1">&lt;/c1&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Mirror<ept i="0">&lt;/c0&gt;</ept>の<bpt i="1" x="1">&lt;c1&gt;</bpt>descendant<ept i="1">&lt;/c1&gt;</ept>メソッドへの合法的な引数に対するプロトコル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A random element from the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このコレクションからのある無作為の要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A random value of <bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept> in the range <bpt i="1" x="1">&lt;c1&gt;</bpt>0..<it pos="begin" x="2">&lt;upper&lt;w2&gt;</it>Bound<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある無作為な<bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept>の値で範囲<bpt i="1" x="1">&lt;c1&gt;</bpt>0..<it pos="begin" x="2">&lt;upper&lt;w2&gt;</it>Bound<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の中のもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A random value of <bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある無作為な<bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept>の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A random value within the bounds of <bpt i="0" x="0">&lt;c0&gt;</bpt>range<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>range<ept i="0">&lt;/c0&gt;</ept>の境界内のある無作為な値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A range expression that represents the entire range of a collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるコレクションの全体の範囲を表す範囲式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A range of the collection’s indices.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションのもつインデックスのある範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A range of the range’s indices.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この範囲のインデックスの範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A range suitable for slicing <bpt i="0" x="0">&lt;c0&gt;</bpt>collection<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>スライスする<bpt i="0" x="0">&lt;c0&gt;</bpt>collection<ept i="0">&lt;/c0&gt;</ept>に対して適している範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A range to check for elements in common.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>共通の要素を調べる範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A range to compare.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>比較する範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A range-replaceable collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲置換可能なコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A reimagined Swift computed property that expresses the same functionality—getting the components of a color—can be written as a four-element tuple:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>再度考えられたSwift計算プロパティで同じ機能性を表現するもの — ある色の構成要素の取得 — は、４要素のタプルとして記述されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A representation of the substructure and display style of an instance of any type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下位構造体の表現と何らかの型のインスタンスの表示形式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A representation of this integer with the byte order swapped.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この整数のバイト順交換した表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence built around an iterator of type <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型<bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept>のイテレータに基づいて構築されるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence consisting of all the elements contained in each segment contained in some <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept> sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>何らかの<bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept>シーケンスに含まれる各断片の中に含まれるいくらかの要素から成るシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence containing the same elements as a <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept> sequence, but on which some operations such as <bpt i="1" x="1">&lt;c1&gt;</bpt>map<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>filter<ept i="2">&lt;/c2&gt;</ept> are implemented lazily.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept>シーケンスと同じ要素を含んでいるシーケンス、しかしそれの上で何らかの演算、例えば<bpt i="1" x="1">&lt;c1&gt;</bpt>map<ept i="1">&lt;/c1&gt;</ept>や<bpt i="2" x="2">&lt;c2&gt;</bpt>filter<ept i="2">&lt;/c2&gt;</ept>が遅延に実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence containing the same elements as this one, possibly with a simpler type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このものと同じ要素を、できる限りより簡単な型で、含むシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence containing the same elements as this sequence, but on which some operations, such as <bpt i="0" x="0">&lt;c0&gt;</bpt>map<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>filter<ept i="1">&lt;/c1&gt;</ept>, are implemented lazily.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスと同じ要素を含んでいるシーケンス、しかしそれの上で何らかの演算、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>map<ept i="0">&lt;/c0&gt;</ept>や<bpt i="1" x="1">&lt;c1&gt;</bpt>filter<ept i="1">&lt;/c1&gt;</ept>が遅延に実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence is a list of values that you can step through one at a time.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスは値のリストで、あなたが一度に１つずつ段階処理していくことができるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence leaving off the specified number of elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された数の要素を取り除いたあるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence of elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>いくつかの要素からなるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence of pairs built out of two underlying sequences.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの根底にあるシーケンスから組み立てられるペアからなるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence of pairs enumerating the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスを列挙している、ペアからなるあるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence of the initial, consecutive elements that satisfy <bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>を満たす冒頭の、隣接する要素からなるあるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence of values formed by striding over a closed interval.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある完結間隔の全体をまたぐことで形成されるいくつかの値からなるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence of values formed by striding over a half-open interval.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある半開間隔の全体をまたぐことで形成されるいくつかの値からなるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence on which normally-eager sequence operations are implemented lazily.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンス、それにおいては通常は先行な演算は、遅延に実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence should provide its iterator in O(1).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスはそれのイテレータをO(1)で提供すべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence starting after the initial, consecutive elements that satisfy <bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>を満たす冒頭の、隣接する要素の後で始まるあるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence starting after the specified number of elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された数の要素の後で始まるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence starting at the beginning of this sequence with at most <bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Length<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスの先端で始まる多くとも<bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Length<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>要素のあるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence that lazily consumes and drops <bpt i="0" x="0">&lt;c0&gt;</bpt>n<ept i="0">&lt;/c0&gt;</ept> elements from an underlying <bpt i="1" x="1">&lt;c1&gt;</bpt>Base<ept i="1">&lt;/c1&gt;</ept> iterator before possibly returning the first available element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>おそらくは最初の利用可能な要素が返る前に<bpt i="0" x="0">&lt;c0&gt;</bpt>n<ept i="0">&lt;/c0&gt;</ept>個の要素をある基礎をなす<bpt i="1" x="1">&lt;c1&gt;</bpt>Base<ept i="1">&lt;/c1&gt;</ept>イテレータから遅延に消費して落とすあるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence that only consumes up to <bpt i="0" x="0">&lt;c0&gt;</bpt>n<ept i="0">&lt;/c0&gt;</ept> elements from an underlying <bpt i="1" x="1">&lt;c1&gt;</bpt>Base<ept i="1">&lt;/c1&gt;</ept> iterator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最大で<bpt i="0" x="0">&lt;c0&gt;</bpt>n<ept i="0">&lt;/c0&gt;</ept>個の要素まで基礎をなす<bpt i="1" x="1">&lt;c1&gt;</bpt>Base<ept i="1">&lt;/c1&gt;</ept>イテレータからただ消費しきるあるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence that presents the elements of a base sequence of sequences concatenated using a given separator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンス、それはいくらかのシーケンスからなるある基盤となるシーケンスの要素らを、与えられた分離子を使って連結して提示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence that represents a contiguous subrange of the collection’s elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの要素の隣接下位範囲を表すシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence to compare to this sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンス、このシーケンスと比べることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence to insert between each of this sequence’s elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスの要素それぞれの間に挿入されるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence whose elements are produced via repeated applications of a closure to some mutable state.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャをある何らかの可変の状態へ繰り返し適用することでその要素が生み出されるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence whose elements can be traversed multiple times, nondestructively, and accessed by an indexed subscript.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンス、それの要素は複数回探査されることが非破壊的に可能です、そしてある添え字で指し示すことによってアクセスされることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence whose elements consist of the elements of some base sequence that also satisfy a given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンス、それは何らかの基盤シーケンスの要素でさらにまた与えられた述部を満足させるものから成る要素たちです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence whose elements consist of the elements that follow the initial consecutive elements of some base sequence that satisfy a given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンス、それの要素は何らかの基盤シーケンスの、ある与えられた述部を満足させる最初の隣接要素の後に続く要素それらから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence whose elements consist of the initial consecutive elements of some base sequence that satisfy a given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンス、それの要素は何かの基盤シーケンスのもので、与えられた述部を満足させる最初の連続した要素から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A service which can execute jobs.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ジョブを遂行できるあるサービス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A set of the elements that <bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Included<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> allows.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Included<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が許可する要素からなる集合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A set of the same type as the current set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>現在の集合と同じ型の集合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A set of the same type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同じ型の集合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>１つの集合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A shuffled array of this sequence’s elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスの持つ要素からなる、あるシャッフルされた配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A single, concatenated string.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>単一の、連結された文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A singleton actor whose executor is equivalent to the main dispatch queue.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシングルトンアクター、それのエグゼキュータはメインディスパッチキューと同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sink subscriber connected to the result’s publisher receives the output <bpt i="3" x="3">&lt;c3&gt;</bpt>1<ept i="3">&lt;/c3&gt;</ept>, followed by a normal completion (<bpt i="4" x="4">&lt;a4&gt;</bpt><bpt i="5" x="5">&lt;c5&gt;</bpt>Subscribers<bpt i="6" x="6">&lt;w6&gt;</bpt>.Completion<bpt i="7" x="7">&lt;w7&gt;</bpt>.finished<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept><ept i="4">&lt;/a4&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果のもつパブリッシャーに接続した流し先の加入者は出力<bpt i="3" x="3">&lt;c3&gt;</bpt>1<ept i="3">&lt;/c3&gt;</ept>、それに続けてある正常完了（<bpt i="4" x="4">&lt;a4&gt;</bpt><bpt i="5" x="5">&lt;c5&gt;</bpt>Subscribers<bpt i="6" x="6">&lt;w6&gt;</bpt>.Completion<bpt i="7" x="7">&lt;w7&gt;</bpt>.finished<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept><ept i="4">&lt;/a4&gt;</ept>）を受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sink subscriber connected to this result’s publisher immediately receives a termination (<bpt i="7" x="7">&lt;a7&gt;</bpt><bpt i="8" x="8">&lt;c8&gt;</bpt>Subscribers<bpt i="9" x="9">&lt;w9&gt;</bpt>.Completion<bpt i="10" x="10">&lt;w10&gt;</bpt>.failure(_:)<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept><ept i="7">&lt;/a7&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果のもつパブリッシャーに接続した流し先の加入者は、直ぐにある終了（<bpt i="7" x="7">&lt;a7&gt;</bpt><bpt i="8" x="8">&lt;c8&gt;</bpt>Subscribers<bpt i="9" x="9">&lt;w9&gt;</bpt>.Completion<bpt i="10" x="10">&lt;w10&gt;</bpt>.failure(_:)<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept><ept i="7">&lt;/a7&gt;</ept>）を受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sorted array of the sequence’s elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンス要素のソート済み配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A stable sort preserves the relative order of elements for which <bpt i="0" x="0">&lt;c0&gt;</bpt>are<bpt i="1" x="1">&lt;w1&gt;</bpt>In<bpt i="2" x="2">&lt;w2&gt;</bpt>Increasing<bpt i="3" x="3">&lt;w3&gt;</bpt>Order<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> does not establish an order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>安定ソートは、それに対して<bpt i="0" x="0">&lt;c0&gt;</bpt>are<bpt i="1" x="1">&lt;w1&gt;</bpt>In<bpt i="2" x="2">&lt;w2&gt;</bpt>Increasing<bpt i="3" x="3">&lt;w3&gt;</bpt>Order<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が順序を確立しない要素らの相対順序を保存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A stable sort preserves the relative order of elements that compare equal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>安定ソートは、等しいと比較される要素それらの相対順序を保存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A string that represents the contents of the dictionary, suitable for debugging.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書の内容を表す文字列、デバッグに適するもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A string that represents the contents of the dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書の内容を表す文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A string that represents the contents of the set, suitable for debugging.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合の内容を表す文字列、デバッグに適するもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A string that represents the contents of the set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合の内容を表す文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A string to insert between each of the elements in this sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスの要素のそれぞれの間に挿入されることになる文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A string, formatted according to the default list format style.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある文字列、それは省略時のリスト書式形式により書式設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A string, formatted according to the provided style.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある文字列、提供された形式により書式設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A subsequence starting after the specified number of elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された数の要素の後から始まる下位シーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A subsequence starting at the <bpt i="0" x="0">&lt;c0&gt;</bpt>start<ept i="0">&lt;/c0&gt;</ept> position.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>start<ept i="0">&lt;/c0&gt;</ept>位置から始まる下位シーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A subsequence starting at the beginning of this collection with at most <bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Length<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このコレクションの先端で始まる多くとも<bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Length<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>要素の下位シーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A subsequence terminating at the end of the collection with at most <bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Length<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの末端で終わっていて多くとも<bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Length<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の要素を持つ下位シーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A subsequence that leaves off <bpt i="0" x="0">&lt;c0&gt;</bpt>k<ept i="0">&lt;/c0&gt;</ept> elements from the end.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>k<ept i="0">&lt;/c0&gt;</ept>個の要素を終わりから取り除いた下位シーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A subsequence that leaves off the specified number of elements at the end.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された数の要素が末尾から無くなっているシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A subsequence up to, and including, the <bpt i="0" x="0">&lt;c0&gt;</bpt>end<ept i="0">&lt;/c0&gt;</ept> position.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>end<ept i="0">&lt;/c0&gt;</ept>位置に至るまでの、そしてそれを含む、下位シーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A subsequence up to, but not including, the <bpt i="0" x="0">&lt;c0&gt;</bpt>end<ept i="0">&lt;/c0&gt;</ept> position.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>end<ept i="0">&lt;/c0&gt;</ept>位置に至るまでの、しかしそれを含まないシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A success, storing a <bpt i="0" x="0">&lt;c0&gt;</bpt>Success<ept i="0">&lt;/c0&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある成功、<bpt i="0" x="0">&lt;c0&gt;</bpt>Success<ept i="0">&lt;/c0&gt;</ept>値を格納しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A suggested display style for the reflected subject.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>リフレクションされる主題のための１つの提案の表示形式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A suggestion of how a mirror’s subject is to be interpreted.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>どのようにMirrorの持つsubjectが解釈されるようになるかの提案。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A textual description of the vector.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ベクターのテキスト記述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A textual representation of the identifier, suitable for debugging.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その識別子のテキスト表現、デバッグに適するもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A textual representation of the pointer, suitable for debugging.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのポインタのテキスト表現、デバッグに適するもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A textual representation of the range, suitable for debugging.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲のテキスト表現、デバッグに適するもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A textual representation of the range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲のテキスト表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A textual representation of this instance, suitable for debugging.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのインスタンスのテキスト表現、デバッグに適するもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A textual representation of this instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このインスタンスのテキスト表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A textual representation of this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値のテキスト表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A three-element vector created by appending a scalar to a two-element vector.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるスカラーを２要素ベクターに追加することによって作成される３要素ベクター。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A throwing closure to evaluate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>評価することになるスローするクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A timing scenario you should avoid is calling the <bpt i="8" x="8">&lt;s8&gt;</bpt><bpt i="9" x="9">&lt;c9&gt;</bpt>data<bpt i="10" x="10">&lt;w10&gt;</bpt>Task(with:<bpt i="11" x="11">&lt;w11&gt;</bpt>completion<bpt i="12" x="12">&lt;w12&gt;</bpt>Handler:)<ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/c9&gt;</ept><ept i="8">&lt;/s8&gt;</ept> method within your app's <bpt i="13" x="13">&lt;a13&gt;</bpt><bpt i="14" x="14">&lt;c14&gt;</bpt>view<bpt i="15" x="15">&lt;w15&gt;</bpt>Did<bpt i="16" x="16">&lt;w16&gt;</bpt>Load()<ept i="16">&lt;/w16&gt;</ept><ept i="15">&lt;/w15&gt;</ept><ept i="14">&lt;/c14&gt;</ept><ept i="13">&lt;/a13&gt;</ept> method and attempting to use the results outside of the closure you pass as the completion handler.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが避けるべきタイミングシナリオは、<bpt i="8" x="8">&lt;s8&gt;</bpt><bpt i="9" x="9">&lt;c9&gt;</bpt>data<bpt i="10" x="10">&lt;w10&gt;</bpt>Task(with:<bpt i="11" x="11">&lt;w11&gt;</bpt>completion<bpt i="12" x="12">&lt;w12&gt;</bpt>Handler:)<ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/c9&gt;</ept><ept i="8">&lt;/s8&gt;</ept>メソッドをあなたのアプリの<bpt i="13" x="13">&lt;a13&gt;</bpt><bpt i="14" x="14">&lt;c14&gt;</bpt>view<bpt i="15" x="15">&lt;w15&gt;</bpt>Did<bpt i="16" x="16">&lt;w16&gt;</bpt>Load()<ept i="16">&lt;/w16&gt;</ept><ept i="15">&lt;/w15&gt;</ept><ept i="14">&lt;/c14&gt;</ept><ept i="13">&lt;/a13&gt;</ept>メソッド内部で呼び出す、そして結果をあなたが完了ハンドラとして渡したクロージャの外部で使うのを試みることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A tuple containing the high and low parts of a double-width integer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２倍幅整数の高および低部分を含んでいるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A tuple containing the high and low parts of the result of multiplying this value and <bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値と<bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>を乗算する結果の高および低部分を含んでいるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A tuple containing the quotient and remainder of <bpt i="0" x="0">&lt;c0&gt;</bpt>dividend<ept i="0">&lt;/c0&gt;</ept> divided by this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>dividend<ept i="0">&lt;/c0&gt;</ept>をこの値で除算した商と余りを含んでいるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A tuple containing the quotient and remainder of this value divided by <bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept>によって除算されたこの値の商と余りを含んでいるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A tuple containing the result of the addition along with a Boolean value indicating whether overflow occurred.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>加算の結果とそれだけでなくオーバーフローがその演算において起こったかどうかを示すブール値を含んでいるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A tuple containing the result of the division along with a Boolean value indicating whether overflow occurred.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>除算の結果とそれだけでなくオーバーフローがその演算において起こったかどうかを示すブール値を含んでいるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A tuple containing the result of the multiplication along with a Boolean value indicating whether overflow occurred.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>乗算の結果とそれだけでなくオーバーフローが起こったかどうかを示すブール値を含んでいるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A tuple containing the result of the operation along with a Boolean value indicating whether overflow occurred.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>演算の結果とそれだけでなくオーバーフローが起こったかどうかを示すブール値を含んでいるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A tuple containing the result of the subtraction along with a Boolean value indicating whether overflow occurred.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>減算の結果とそれだけでなくオーバーフローが起こったかどうかを示すブール値を含んでいるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A tuple of the lower and upper bounds of the range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この範囲の下方および上方境界からなるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type for which the conforming type provides a containment test.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある型、それに対して準拠しているが格納テストを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type representing an error value that can be thrown.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>スローされることが可能なあるエラー値を表している型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type representing continuous, one-dimensional values that can be offset and measured.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オフセットできて計測できる、連続的な、一次元の値を表している型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type representing the sequence’s elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスの持つ要素を表している型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type representing the stable identity of the entity associated with an instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるインスタンスと結び付けられた登録項目の安定した同一性を表しているある型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can be converted to and from an associated raw value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある結び付けられた生の値へおよびそれから変換できる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can be represented as a string in a lossless, unambiguous way.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるロスレスの、曖昧さのない方法で、文字列として表現できる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can be used as an element in a SIMD vector.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>SIMDベクターにおける要素として使用できるある型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can be used to slice a collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションをスライスするために使われる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can function as storage for a SIMD vector type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある型、それは、SIMDベクター型に対するストレージとして機能できるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can represent both positive and negative values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>正と負の値の両方を表せる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can represent the absolute value of any possible value of the conforming type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>準拠する型の何らかの可能な値の絶対値を表すことのできる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can represent the absolute value of any possible value of this type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型の何らかの可能な値の絶対値を表すことのできる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that conforms to <bpt i="0" x="0">&lt;c0&gt;</bpt>Range<bpt i="1" x="1">&lt;w1&gt;</bpt>Expression<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> can convert itself to a <bpt i="2" x="2">&lt;c2&gt;</bpt>Range&lt;Bound&gt;<ept i="2">&lt;/c2&gt;</ept> of indices within a given collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Range<bpt i="1" x="1">&lt;w1&gt;</bpt>Expression<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠する型は、それ自身を指定コレクション内のインデックスの<bpt i="2" x="2">&lt;c2&gt;</bpt>Range&lt;Bound&gt;<ept i="2">&lt;/c2&gt;</ept>に変換できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that conforms to <bpt i="0" x="0">&lt;c0&gt;</bpt>Range<bpt i="1" x="1">&lt;w1&gt;</bpt>Replaceable<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> can choose how to respond when this method is called.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Range<bpt i="1" x="1">&lt;w1&gt;</bpt>Replaceable<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠する型は、このメソッドが呼ばれた時どのような応答をするか選ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that explicitly supplies its own mirror, but whose descendant classes are not represented in the mirror unless they also override <bpt i="0" x="0">&lt;c0&gt;</bpt>custom<bpt i="1" x="1">&lt;w1&gt;</bpt>Mirror<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>明示的にそれ独自のMirrorを提供するある型、しかしそれの子孫クラスはそれらがまた<bpt i="0" x="0">&lt;c0&gt;</bpt>custom<bpt i="1" x="1">&lt;w1&gt;</bpt>Mirror<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をオーバーライドしない限りはMirrorで表現されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that explicitly supplies its own mirror.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>明示的にそれ自身のMirrorを提供する型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that iterates over a collection using its indices.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるコレクション全体に渡ってそれのインデックスを使って繰り返し処理する型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that presents a mathematical set interface to a bit set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>数学的なセットインターフェイスをビットセットに与える型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that provides a collection of all of its values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それの値の全てからなるコレクションを提供する型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that provides a view into a decoder’s storage and is used to hold the encoded properties of a decodable type in a keyed manner.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある型で、あるデコーダの持つストレージへのビューを提供し、そしてデコーダ可能型のエンコードされたプロパティをキー流儀で保持するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that provides a view into a decoder’s storage and is used to hold the encoded properties of a decodable type sequentially, without keys.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある型で、あるデコーダの持つストレージへのビューを提供し、そしてデコーダ可能型のエンコードされたプロパティを順次的に、キーなしで保持するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that provides a view into an encoder’s storage and is used to hold the encoded properties of an encodable type in a keyed manner.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある型で、あるエンコーダの持つストレージへのビューを提供し、そしてエンコード可能型のエンコードされたプロパティをキー流儀で保持するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that provides a view into an encoder’s storage and is used to hold the encoded properties of an encodable type sequentially, without keys.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある型で、あるエンコーダの持つストレージへのビューを提供し、そしてエンコード可能型のエンコードされたプロパティを順次的に、キーなしで保持するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that provides mathematical set operations.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>数学的な集合演算を提供する型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that provides sequential, iterated access to its elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>順次的な、繰り返されるアクセスをそれの要素に提供するある型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that provides the collection’s iteration interface and encapsulates its iteration state.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのコレクションの持つ反復インターフェイスを提供してそれの反復状態をカプセル化するある型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that provides the sequence’s iteration interface and encapsulates its iteration state.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのシーケンスの持つ反復インターフェイスを提供してそれの反復状態をカプセル化するある型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that provides uniformly distributed random data.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>一様分布無作為データを提供する型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that represents a globally-unique actor that can be used to isolate various declarations anywhere in the program.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある型、それはあるグローバルに特有なアクターを表します、それはさまざまな宣言をどこでもプログラムの中で分離するために使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that represents a position in the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの中のある位置を表す型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that represents a position in the range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲の中のある位置を表す型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that represents a valid position in the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>有効な位置をそのコレクションにおいて表している型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that represents an integer literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある整数リテラルを表す型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that represents either a wrapped value or <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>, the absence of a value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ラップされた値または、値の不在である<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>、どちらかを表すある型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that represents the distance between two values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの値の間の隔たりを表す型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that represents the indices that are valid for subscripting the collection, in ascending order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>昇順での、コレクションの添え字として有効なインデックスを表す型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that represents the words of this integer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この整数のワードを表す型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that supplies a custom description for playground logging.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>プレイグラウンドログのためにあつらえの記述を提供する型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that supplies the values of a sequence one at a time.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンスに属する値を一度に１つ提供する型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type used to format lists of items with a separator and conjunction appropriate for a given locale.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>項目いくつかからなるリストをある与えられたロケールに適した区切りと接続詞で書式設定するために使われるある型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type with a customized textual representation suitable for debugging purposes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>デバッグ目的に都合がよいようにカスタマイズされた原文の表現を持つ型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type with a customized textual representation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>カスタマイズされた原文の表現を持つ型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type with values that support addition and subtraction.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>加算と減算をサポートする値を持つ型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type with values that support multiplication.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>乗算をサポートする値をもつ型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type-erased key path, from any root type to any resulting value type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型消去キーパス、何らかの根本の型から何らかの結果値の型への。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type’s size does not include any dynamically allocated or out of line storage.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある型のもつ大きさは、あらゆる動的にアロケートされるおよびアウトオブラインのストレージを含みません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A unique identifier for a class instance or metatype.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクラスインスタンスまたはメタタイプのための固有な識別子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A unit of scheduleable work.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>予定可能な仕事の単位。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A valid buffer class is non-<bpt i="0" x="0">&lt;c0&gt;</bpt>@objc<ept i="0">&lt;/c0&gt;</ept>, with no declared stored properties.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>有効なバッファクラスは、非<bpt i="0" x="0">&lt;c0&gt;</bpt>@objc<ept i="0">&lt;/c0&gt;</ept>で、宣言された保存プロパティを持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A valid index of the array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この配列の有効なインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A valid index of the collection to use as a limit.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>限度として使うためのそのコレクションの有効なインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A valid index of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのコレクションの有効なインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value less than or equal to the number of elements in the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このコレクションの中の要素の数より少ないか等しい値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value less than or equal to the number of elements in the sequence, calculated nondestructively.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスの要素数より少ないか等しい値、非破壊的に計算されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value of the requested type, if present for the given key and convertible to the requested type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要請された型の値、もし与えられたキーに対して存在して要請された型に変換可能ならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value representative of the type to describe.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>描写することになる型の典型であるある値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value stored into a subscript of a <bpt i="0" x="0">&lt;c0&gt;</bpt>Mutable<bpt i="1" x="1">&lt;w1&gt;</bpt>Collection<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance must subsequently be accessible at that same position.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Mutable<bpt i="1" x="1">&lt;w1&gt;</bpt>Collection<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスのある添え字へと格納される値は、その後にその同じ位置でアクセス可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value that is offset from this value by <bpt i="0" x="0">&lt;c0&gt;</bpt>n<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値から<bpt i="0" x="0">&lt;c0&gt;</bpt>n<ept i="0">&lt;/c0&gt;</ept>をオフセットされる値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value that represents either a success or a failure, including an associated value in each case.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>成功または失敗のどちらかを表すある値、それぞれの場合での関連値を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value to compare.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>比較する値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value to convert to this type of integer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型の整数へと変換される値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value to convert to this type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型へと変換される値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value to match against <bpt i="0" x="0">&lt;c0&gt;</bpt>pattern<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>pattern<ept i="0">&lt;/c0&gt;</ept>と照合することになるある値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value to use as the big-endian representation of the new integer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい整数のビッグエンディアン表現として使う値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value to use as the little-endian representation of the new integer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい整数のリトルエンディアン表現として使う値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value to use as the source of the new instance’s binary representation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいインスタンスの持つバイナリ表現のソースとして使うための値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A variadic list of elements of the new set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい集合の要素からなる可変長引数リスト。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A vector formed by rounding each lane of the source vector to an integral value according to the specified rounding <bpt i="0" x="0">&lt;c0&gt;</bpt>rule<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ソースベクターの各レーンをある整数値へとこの指定された丸め<bpt i="0" x="0">&lt;c0&gt;</bpt>rule<ept i="0">&lt;/c0&gt;</ept>により丸めることによって形成されるあるベクター。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A vector mask with the result of a pointwise equality comparison.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるポイント単位同等比較の結果を持つベクターマスク。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A vector mask with the result of a pointwise greater-than comparison.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ポイント単位大なり比較の結果を持つベクターマスク。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A vector mask with the result of a pointwise greater-than-or-equal-to comparison.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ポイント単位大なり同等比較の結果を持つベクターマスク。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A vector mask with the result of a pointwise inequality comparison.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるポイント単位不等比較の結果をもつベクターマスク。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A vector mask with the result of a pointwise less-than comparison.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ポイント単位小なり比較の結果を持つベクターマスク。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A vector mask with the result of a pointwise less-than-or-equal-to comparison.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ポイント単位小なり同等比較の結果を持つベクターマスク。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A vector of 16 scalar values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>16スカラー値のベクター。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A vector of 32 scalar values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>32スカラー値のベクター。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A vector of 64 scalar values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>64スカラー値のベクター。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A vector of eight scalar values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>８つのスカラー値のベクター。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A vector of four scalar values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>４つのスカラー値のベクター。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A vector of three scalar values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>３つのスカラー値のベクター。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A vector of two scalar values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つのスカラー値のベクター。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A vector with one in all lanes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>全てのレーンに１つでのあるベクター。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A vector with the specified value in all lanes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>全てのレーンでこの指定された値を持つベクター。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A vector with zero in all lanes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>全てのレーンにおいてゼロをもつあるベクター。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A wrapper around an opaque C pointer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>不透明Cポインターの周りのラッパー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accesses a contiguous subrange of the collection’s elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションのもついくらかの要素からなるある連続した下位範囲にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accesses the contiguous subrange of the collection’s elements specified by a range expression.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲式によって指定される、コレクションの要素からなる連続した下位範囲にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accesses the element at <bpt i="0" x="0">&lt;c0&gt;</bpt>position<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>position<ept i="0">&lt;/c0&gt;</ept>での要素にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accesses the element at specified position.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された位置で要素にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accesses the element at the specified index.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定されたインデックスでの要素にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accesses the element at the specified position.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された位置で要素にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accesses the member at the given position.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた位置でのメンバにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accesses the scalar at the specified position.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された位置でスカラーにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accesses the subsequence bounded by the given range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた範囲によって仕切られた下位シーケンスにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accessing <bpt i="3" x="3">&lt;c3&gt;</bpt>end<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, the <bpt i="5" x="5">&lt;c5&gt;</bpt>last<ept i="5">&lt;/c5&gt;</ept> property, or calling methods that depend on moving indices might not have the documented complexity.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>end<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>、<bpt i="5" x="5">&lt;c5&gt;</bpt>last<ept i="5">&lt;/c5&gt;</ept>プロパティにアクセスすること、または移動するインデックスに依存するメソッドを呼び出すことは、文書化される計算量を持たないかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accessing <bpt i="7" x="7">&lt;c7&gt;</bpt>end<bpt i="8" x="8">&lt;w8&gt;</bpt>Index<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>, the <bpt i="9" x="9">&lt;c9&gt;</bpt>last<ept i="9">&lt;/c9&gt;</ept> property, or calling methods that depend on moving indices might not have the documented complexity.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="7" x="7">&lt;c7&gt;</bpt>end<bpt i="8" x="8">&lt;w8&gt;</bpt>Index<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>、<bpt i="9" x="9">&lt;c9&gt;</bpt>last<ept i="9">&lt;/c9&gt;</ept>プロパティにアクセスすること、または移動するインデックスに依存するメソッドを呼び出すことは、文書化される計算量を持たないかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accessing Buffer Contents</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>バッファ内容にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accessing Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要素にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accessing Individual Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>個々の要素にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accessing Underlying Storage</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>基礎をなすストレージにアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accessing the Layout of a Type</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある型のレイアウトにアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accessing the Layout of a Value</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値のレイアウトにアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accessing the Raw Value</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>生の値にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accessing this property in the case of a <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept> value is a serious programming error and could lead to undefined behavior or a runtime error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>値の場合にこのプロパティにアクセスすることは、重大なプログラミングエラーです、そして未定義挙動または実行時エラーに至らせるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Add macros to your Objective-C types to group their values in Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>マクロをあなたのObjective-C型に加えて、それらの値をSwiftにおいてグループにまとめます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adding Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要素の追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adding IteratorProtocol Conformance to Your Type</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>IteratorProtocol準拠をあなたの型に加える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adding New Lazy Operations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい遅延演算を加える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adding and Removing Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要素の追加と削除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adds an element to the end of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある要素をコレクションの終わりに加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adds the elements of a sequence or collection to the end of this collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンスまたコレクションに属するいくつかの要素をこのコレクションの終わりに加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adds the elements of the given set to the set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた集合の要素をこの集合に加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adds the given element to the option set if it is not already a member.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた要素を、それがすでにメンバでないならばオプションセットに加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adds two values and produces their sum.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの値を加算してそれらの合計を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adds two values and stores the result in the left-hand-side variable, wrapping any overflow.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの値を加算して結果を左手側の変数に格納します、あらゆるオーバーフローをラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adds two values and stores the result in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの値を加算して、結果を左手側の変数に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adopt and interoperate with Cocoa design patterns in your Swift apps.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>CocoaデザインパターンをあなたのSwiftアプリにおいて採用および相互運用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adopting this protocol in your custom types lets you perform set-related operations such as membership tests, unions, and intersections on those types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型をあなたのあつらえの型において採用することは、あなたにセット関連演算を行わせます、例えば、それらの型上での帰属テスト、合併、そして交叉など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Advances to the next element and returns it, or <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> if no next element exists.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の要素へ進んでそれを返します、または次の要素が存在しないならば<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>After You Finish</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがやり終えたあと</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>After applying the macro, the name you use in your Swift code will be what you've chosen by using the macro.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このマクロを適用後、あなたのSwiftコードにおいてあなたが使う名前は、あなたがマクロを使うことにで選択したものになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>After partitioning a collection, there is a pivot index <bpt i="0" x="0">&lt;c0&gt;</bpt>p<ept i="0">&lt;/c0&gt;</ept> where no element before <bpt i="1" x="1">&lt;c1&gt;</bpt>p<ept i="1">&lt;/c1&gt;</ept> satisfies the <bpt i="2" x="2">&lt;c2&gt;</bpt>belongs<bpt i="3" x="3">&lt;w3&gt;</bpt>In<bpt i="4" x="4">&lt;w4&gt;</bpt>Second<bpt i="5" x="5">&lt;w5&gt;</bpt>Partition<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> predicate and every element at or after <bpt i="6" x="6">&lt;c6&gt;</bpt>p<ept i="6">&lt;/c6&gt;</ept> satisfies <bpt i="7" x="7">&lt;c7&gt;</bpt>belongs<bpt i="8" x="8">&lt;w8&gt;</bpt>In<bpt i="9" x="9">&lt;w9&gt;</bpt>Second<bpt i="10" x="10">&lt;w10&gt;</bpt>Partition<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションを仕切った後、あるピボットインデックス<bpt i="0" x="0">&lt;c0&gt;</bpt>p<ept i="0">&lt;/c0&gt;</ept>があります、そこで<bpt i="1" x="1">&lt;c1&gt;</bpt>p<ept i="1">&lt;/c1&gt;</ept>の前の要素は１つも<bpt i="2" x="2">&lt;c2&gt;</bpt>belongs<bpt i="3" x="3">&lt;w3&gt;</bpt>In<bpt i="4" x="4">&lt;w4&gt;</bpt>Second<bpt i="5" x="5">&lt;w5&gt;</bpt>Partition<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>述部を満たさず、そして<bpt i="6" x="6">&lt;c6&gt;</bpt>p<ept i="6">&lt;/c6&gt;</ept>でのまたは後のあらゆる要素は<bpt i="7" x="7">&lt;c7&gt;</bpt>belongs<bpt i="8" x="8">&lt;w8&gt;</bpt>In<bpt i="9" x="9">&lt;w9&gt;</bpt>Second<bpt i="10" x="10">&lt;w10&gt;</bpt>Partition<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>を満たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>After some time of inactivity, the user’s session may expire, leaving the app in a <bpt i="2" x="2">&lt;e2&gt;</bpt>session expired<ept i="2">&lt;/e2&gt;</ept> state.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>しばらく活動がない後に、ユーザのセッションは期限切れになるかもしれません、アプリを<bpt i="2" x="2">&lt;e2&gt;</bpt>期限切れセッション<ept i="2">&lt;/e2&gt;</ept>の状態のままにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>After the user has registered or logged into an account, the state is <bpt i="1" x="1">&lt;e1&gt;</bpt>logged in<ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ユーザがアカウントに登録またはログインした後は、状態は<bpt i="1" x="1">&lt;e1&gt;</bpt>ログイン済み<ept i="1">&lt;/e1&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>After using <bpt i="0" x="0">&lt;c0&gt;</bpt>first<bpt i="1" x="1">&lt;w1&gt;</bpt>Index(of:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to find the position of a particular element in a collection, you can use it to access the element by subscripting.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>first<bpt i="1" x="1">&lt;w1&gt;</bpt>Index(of:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使って特定の要素の位置をあるコレクションの中で見つけた後、あなたは添え字によって要素にアクセスするのにそれを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>After using <bpt i="0" x="0">&lt;c0&gt;</bpt>last<bpt i="1" x="1">&lt;w1&gt;</bpt>Index(of:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>last<bpt i="1" x="1">&lt;w1&gt;</bpt>Index(of:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使って特定の要素の最後のインスタンスの位置をあるコレクションの中で見つけた後、あなたは添え字によって要素にアクセスするのにそれを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>All elements satisfying this predicate are ordered after all elements not satisfying it.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この述部を満たす全ての要素は、それを満たさない全ての要素の後に並べられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>All other object instances are annotated as <bpt i="4" x="4">&lt;c4&gt;</bpt>nonnull<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>全ての他のオブジェクトインスタンスは、<bpt i="4" x="4">&lt;c4&gt;</bpt>nonnull<ept i="4">&lt;/c4&gt;</ept>であると注釈を付けられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>All the elements following the specified position are moved to close the gap.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された位置に続く要素すべては、隙間を埋めるように移動されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>All the keys the <bpt i="0" x="0">&lt;c0&gt;</bpt>Decoder<ept i="0">&lt;/c0&gt;</ept> has for this container.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Decoder<ept i="0">&lt;/c0&gt;</ept>がこのコンテナに対して持っている全てのキー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>All the keys the decoder has for this container.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>デコーダがこのコンテナに対して持っている全てのキー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Alternatively, a predicate can be satisfied by a range of <bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept> elements or a general condition.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるいは、述部は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept>要素のある範囲またはある一般的条件によって満たされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Alternatively, if your type can act as its own iterator, implementing the requirements of the <bpt i="0" x="0">&lt;c0&gt;</bpt>Iterator<bpt i="1" x="1">&lt;w1&gt;</bpt>Protocol<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol and declaring conformance to both <bpt i="2" x="2">&lt;c2&gt;</bpt>Sequence<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>Iterator<bpt i="4" x="4">&lt;w4&gt;</bpt>Protocol<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> are sufficient.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるいはまた、あなたの型がそれ自身イテレータとして振る舞うならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>Iterator<bpt i="1" x="1">&lt;w1&gt;</bpt>Protocol<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルの要件を実装することと<bpt i="2" x="2">&lt;c2&gt;</bpt>Sequence<ept i="2">&lt;/c2&gt;</ept>および<bpt i="3" x="3">&lt;c3&gt;</bpt>Iterator<bpt i="4" x="4">&lt;w4&gt;</bpt>Protocol<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>の両方に対する準拠を宣言することで十分です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Alternatively, to create an option set instance with multiple members, assign an array literal with multiple static members of the option set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるいはまた、複数のメンバをもつ１つのオプションセットインスタンスを作成するには、オプションセットの複数の静的メンバをもつ配列リテラルを割り当ててください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Alternatively, use this method to sort a collection of elements that do conform to <bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept> when you want the sort to be descending instead of ascending.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そうではなくて、あなたが昇順ではなく降順でソートしたい場合は、このメソッドを使って<bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept>に準拠する要素からなるコレクションをソートしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Although <bpt i="2" x="2">&lt;c2&gt;</bpt>.express<ept i="2">&lt;/c2&gt;</ept> is not a member of <bpt i="3" x="3">&lt;c3&gt;</bpt>options<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>.express<ept i="4">&lt;/c4&gt;</ept> subsumes the remaining <bpt i="5" x="5">&lt;c5&gt;</bpt>.second<bpt i="6" x="6">&lt;w6&gt;</bpt>Day<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> element of the option set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>とは言え<bpt i="2" x="2">&lt;c2&gt;</bpt>.express<ept i="2">&lt;/c2&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>options<ept i="3">&lt;/c3&gt;</ept>のメンバではありません、しかし<bpt i="4" x="4">&lt;c4&gt;</bpt>.express<ept i="4">&lt;/c4&gt;</ept>はこのオプションセットの残りの要素<bpt i="5" x="5">&lt;c5&gt;</bpt>.second<bpt i="6" x="6">&lt;w6&gt;</bpt>Day<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>を包含します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Although an <bpt i="3" x="3">&lt;e3&gt;</bpt>actual<ept i="3">&lt;/e3&gt;</ept> dictionary is arbitrarily-ordered, when you create a mirror with a dictionary literal, the ordering of the mirror’s <bpt i="4" x="4">&lt;c4&gt;</bpt>children<ept i="4">&lt;/c4&gt;</ept> will exactly match that of the literal you pass.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;e3&gt;</bpt>actual<ept i="3">&lt;/e3&gt;</ept>辞書は気まぐれに順番付けられますが、あなたがミラーを辞書リテラルで作成する時、ミラーの持つ<bpt i="4" x="4">&lt;c4&gt;</bpt>children<ept i="4">&lt;/c4&gt;</ept>の順番付けは正確にあなたが渡すリテラルのそれと一致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Always use a multiple of a type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>stride<ept i="0">&lt;/c0&gt;</ept> instead of its <bpt i="1" x="1">&lt;c1&gt;</bpt>size<ept i="1">&lt;/c1&gt;</ept> when allocating memory or accounting for the distance between instances in memory.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>メモリをアロケートするまたはメモリ中のインスタンス間の隔たりを計上する場合には、常にある型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>stride<ept i="0">&lt;/c0&gt;</ept>の倍数を使ってください、それの<bpt i="1" x="1">&lt;c1&gt;</bpt>size<ept i="1">&lt;/c1&gt;</ept>ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Always use the slice’s <bpt i="0" x="0">&lt;c0&gt;</bpt>start<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property instead of assuming that its indices start at a particular value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>常にスライスの<bpt i="0" x="0">&lt;c0&gt;</bpt>start<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティを使ってください、それのインデックスが特定の値で始まると決めてかかるのではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An 8-bit signed integer value type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>8ビット符号つき整数値型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An array containing the elements of this sequence in reverse order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスの要素を逆順に含んでいる配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An array containing the transformed elements of this sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスの変換済み要素を含んでいる配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An array of subsequences, split from this collection’s elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このコレクションの要素を分割した、下位シーケンスいくらかからなる配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An array of subsequences, split from this sequence’s elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスの要素を分割した、下位シーケンスいくらかからなる配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An array of the elements that <bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Included<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> allowed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Included<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が許可する要素からなる配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An array of the non-<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> results of calling <bpt i="1" x="1">&lt;c1&gt;</bpt>transform<ept i="1">&lt;/c1&gt;</ept> with each element of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスの各要素で<bpt i="1" x="1">&lt;c1&gt;</bpt>transform<ept i="1">&lt;/c1&gt;</ept>を呼ぶことの非<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>の結果の配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An array of this sequence’s elements in a shuffled order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスの持つ要素からなる配列、シャッフルされた順番で。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An element equal to <bpt i="0" x="0">&lt;c0&gt;</bpt>new<bpt i="1" x="1">&lt;w1&gt;</bpt>Member<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the set already contained such a member; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合がすでにそのようなメンバを含んでいるならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>new<bpt i="1" x="1">&lt;w1&gt;</bpt>Member<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に等しい要素；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An element of the reflected instance’s structure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>リフレクションされる（自己言及、自己参照の対象の）インスタンスの持つ構造体の中のある要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An element to insert into the set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合に挿入されることになる要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An element to look for in the set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合において捜される要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An element to search for in the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このコレクションにおいて捜される要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An element to search for in the set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合において捜される要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An empty <bpt i="0" x="0">&lt;c0&gt;</bpt>Range<ept i="0">&lt;/c0&gt;</ept> instance has equal lower and upper bounds.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>空の<bpt i="0" x="0">&lt;c0&gt;</bpt>Range<ept i="0">&lt;/c0&gt;</ept>インスタンスは、等しい下方および上方境界を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An enumeration of the elements of a sequence or collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスまたはコレクションの要素の列挙。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An equivalent range must be representable as an instance of Range&lt;Bound&gt;.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同等の範囲が、Range&lt;Bound&gt;のインスタンスとして表現可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An implementation detail of key path expressions; do not use this protocol directly.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キーパス式の実装詳細；このプロトコルを直接に使わないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An index offset by <bpt i="0" x="0">&lt;c0&gt;</bpt>distance<ept i="0">&lt;/c0&gt;</ept> from the index <bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept>, unless that index would be beyond <bpt i="2" x="2">&lt;c2&gt;</bpt>limit<ept i="2">&lt;/c2&gt;</ept> in the direction of movement.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>distance<ept i="0">&lt;/c0&gt;</ept>だけインデックス<bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept>から補われたインデックス、そのインデックスが<bpt i="2" x="2">&lt;c2&gt;</bpt>limit<ept i="2">&lt;/c2&gt;</ept>を移動方向において越える場合を除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An index offset by <bpt i="0" x="0">&lt;c0&gt;</bpt>distance<ept i="0">&lt;/c0&gt;</ept> from the index <bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>distance<ept i="0">&lt;/c0&gt;</ept>だけインデックス<bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept>から補われるインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An index that traverses the same positions as an underlying index, with inverted traversal direction.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある基礎をなすインデックスが指すのと同じ幾つかの位置を、逆の走査順で辿っていくインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An instance of a class.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクラスのインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An instance representing the state of the receiver with the difference applied, or <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> if the difference is incompatible with the receiver’s state.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>適用された差異をもつレシーバの状態を表しているインスタンス、または<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>、もし差異がレシーバのもつ状態と相容れないならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An instance that is expressed as a literal can also be used with this operator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>リテラルとして表されるインスタンスはまた、この演算子とともに使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An integer to compare.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>比較する整数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An integer to convert to this type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型へと変換する整数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An integer type that can represent both positive and negative values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>正および負の値の両方を表すことができる整数型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An integer type that can represent only nonnegative values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>非負値だけを表すことができる整数型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An integer type that uses a fixed size for every instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あらゆるインスタンスに対して固定された大きさを使う整数型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An integer type with a binary representation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>バイナリ表現での整数型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An integer value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある整数値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An interval from a lower bound up to, and including, an upper bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下側の境界から、上側の境界までの、そしてそれを含む、間隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An iterator for a <bpt i="0" x="0">&lt;c0&gt;</bpt>Stride<bpt i="1" x="1">&lt;w1&gt;</bpt>Through<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Stride<bpt i="1" x="1">&lt;w1&gt;</bpt>Through<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスのためのイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An iterator for a <bpt i="0" x="0">&lt;c0&gt;</bpt>Stride<bpt i="1" x="1">&lt;w1&gt;</bpt>To<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Stride<bpt i="1" x="1">&lt;w1&gt;</bpt>To<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスのためのイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An iterator over the elements traversed by a base iterator that follow the initial consecutive elements that satisfy a given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある基盤イテレータによって辿られる要素で、与えられた述部を満足させる最初の連続した要素に続くものすべてを対象とするイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An iterator over the elements traversed by some base iterator that also satisfy a given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>何らかの基盤イテレータによって辿られるいくらかの要素でさらにまた与えられた述部を満足させるものを対象とするイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An iterator over the initial elements traversed by a base iterator that satisfy a given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある基盤イテレータによって辿られるもので、与えられた述部を満足させる最初の要素らを対象とするイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An iterator over the members of a <bpt i="0" x="0">&lt;c0&gt;</bpt>Set&lt;Element&gt;<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Set&lt;Element&gt;<ept i="0">&lt;/c0&gt;</ept>のメンバーすべてを対象とするイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An iterator that presents the elements of the sequences traversed by a base iterator, concatenated using a given separator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるイテレータ、それは基盤イテレータによって辿っていかれるいくらかのシーケンスに属する要素らを、与えられた分離子を使って連結して提示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An object representing a dynamic, unordered, uniquing collection, for use instead of a <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>Set<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> variable in cases that require reference semantics.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>動的な、順序なしの、特有なコレクションを表しているオブジェクト、参照意味論を必要とする場合に<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>Set<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>変数の代わりに使うため。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An object representing a static, unordered, uniquing collection, for use instead of a <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>Set<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> constant in cases that require reference semantics.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>静的な、順序なしの、特有なコレクションを表しているオブジェクト、参照意味論を必要とする場合に<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>Set<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>定数の代わりに使うため。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An option set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるオプションセット。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An optional value to compare.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>比較することになるオプショナル値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An ordered, random-access collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>順序付けられた、無作為アクセスのコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An overshift results in <bpt i="3" x="3">&lt;c3&gt;</bpt>-1<ept i="3">&lt;/c3&gt;</ept> for a negative value of <bpt i="4" x="4">&lt;c4&gt;</bpt>lhs<ept i="4">&lt;/c4&gt;</ept> or <bpt i="5" x="5">&lt;c5&gt;</bpt>0<ept i="5">&lt;/c5&gt;</ept> for a nonnegative value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オーバーシフトは、負の値の<bpt i="3" x="3">&lt;c3&gt;</bpt>lhs<ept i="3">&lt;/c3&gt;</ept>に対して<bpt i="4" x="4">&lt;c4&gt;</bpt>-1<ept i="4">&lt;/c4&gt;</ept>または非負値に対して<bpt i="5" x="5">&lt;c5&gt;</bpt>0<ept i="5">&lt;/c5&gt;</ept>という結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An unkeyed decoding container view into <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>へのキー無しデコーディングコンテナビュー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An unordered collection of unique elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>特有な要素いくつかからなるある順番付けられないコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An unowned reference to a serial executor (a <bpt i="0" x="0">&lt;c0&gt;</bpt>Serial<bpt i="1" x="1">&lt;w1&gt;</bpt>Executor<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> value).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある直列遂行者（シリアルエグゼキュータ）への非所有参照（<bpt i="0" x="0">&lt;c0&gt;</bpt>Serial<bpt i="1" x="1">&lt;w1&gt;</bpt>Executor<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>値）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An unsigned 64-bit random value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>符号なし64ビット無作為値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Annotate Nullability of Individual Declarations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>個々の宣言のヌル可能性に注釈を付ける</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Annotate Regions as Nonnullable</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>領域に非ヌル可能性として注釈を付ける</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Annotate property declarations, parameter types, and return types that are simple objects or block pointers using the <bpt i="0" x="0">&lt;c0&gt;</bpt>nullable<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>nonnull<ept i="1">&lt;/c1&gt;</ept>, and <bpt i="2" x="2">&lt;c2&gt;</bpt>null<bpt i="3" x="3">&lt;w3&gt;</bpt>_resettable<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> property attributes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>プロパティ宣言、パラメータ型、そして戻り値で、<bpt i="0" x="0">&lt;c0&gt;</bpt>nullable<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>nonnull<ept i="1">&lt;/c1&gt;</ept>、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>null<bpt i="3" x="3">&lt;w3&gt;</bpt>_resettable<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロパティ属性を使っている単純なオブジェクトまたはブロックパラメータであるものに注釈を付けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Another integer to compare.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>比較するもう一方の整数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Another integer value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>もう１つの整数値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Another optional value to compare.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>もう一方の比較するオプショナル値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Another range to compare.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>もう一方の比較する範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Another range-replaceable collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>もう一方の範囲置換可能なコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Another set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>もう一方の集合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Another valid index of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの別の有効なインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Another value to compare.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>もう一方の比較する値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Any fractional part of the value passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>source<ept i="0">&lt;/c0&gt;</ept> is removed, rounding the value toward zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>source<ept i="0">&lt;/c0&gt;</ept>として渡される値の小数部分は何であれ取り除かれます、値はゼロへと丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Any fractional part of the value passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>source<ept i="0">&lt;/c0&gt;</ept> is removed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>source<ept i="0">&lt;/c0&gt;</ept>として渡される値の小数部分は何であれ取り除かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Any remaining mirror path components.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あらゆる残りのミラーパス構成要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Appends the elements of a sequence to a range-replaceable collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンスの要素を範囲置換コレクションに加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Applies the given difference to this collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた差異をこのコレクションに適用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Apply CF_SWIFT_NAME to Related Functions</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>CF_SWIFT_NAMEを関連した関数に適用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Apply macros to your Objective-C APIs to customize how they're imported into Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>マクロをあなたのObjective-C APIに適用して、それらがSwiftにインポートされる方法をカスタマイズします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Applying AppKit Graphic Operations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>AppKitグラフィック演算子を適用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Applying the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_REFINED<bpt i="2" x="2">&lt;w2&gt;</bpt>_FOR<bpt i="3" x="3">&lt;w3&gt;</bpt>_SWIFT<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> macro exposes the existing Objective-C API for reuse in your refined API.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_REFINED<bpt i="2" x="2">&lt;w2&gt;</bpt>_FOR<bpt i="3" x="3">&lt;w3&gt;</bpt>_SWIFT<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>マクロを適用することは、既存のObjective-C APIを、あなたの改良されたAPIにおいて再利用するために公開します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As You Work</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが作業するとき</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As a consequence, don’t assume that multiple <bpt i="1" x="1">&lt;c1&gt;</bpt>for<ept i="1">&lt;/c1&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt>in<ept i="2">&lt;/c2&gt;</ept> loops on a sequence will either resume iteration or restart from the beginning:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果として、あるシーケンス上での複数の<bpt i="1" x="1">&lt;c1&gt;</bpt>for<ept i="1">&lt;/c1&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt>in<ept i="2">&lt;/c2&gt;</ept>ループが反復を途中から再開するかまたは初めから再度着手するか、どちらかを決めてかからないでください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As a result, you can chain multiple <bpt i="2" x="2">&lt;c2&gt;</bpt>??<ept i="2">&lt;/c2&gt;</ept> operators together.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果として、あなたは複数の<bpt i="2" x="2">&lt;c2&gt;</bpt>??<ept i="2">&lt;/c2&gt;</ept>を一緒に鎖状につなげることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As an example, to check whether a sequence includes a particular value, you can test each value sequentially until you’ve found a match or reached the end of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>１つの例として、あるシーケンスが特定の値を含むかどうか確認するために、あなたは各値を順次テストすることが、あなたが一致するものを見つけるかそのシーケンスの終わりに達するまで行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As soon as the sequence has run out of elements, all subsequent calls return <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスが要素を使い果たすやいなや、全てのその後の呼び出しは<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As such, it should be possible to re-create an instance from its string representation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それなので、それはそれの文字列表現からインスタンスの再度作成が可能であるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As you work with Objective-C APIs, you’ll need to know how Swift translates certain Objective-C language features.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがObjective-C APIを扱うとき、あなたはスウィフトがどのように特定のObjective-C言語機能を翻訳するか知っている必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Associated Types</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>さまざまな関連型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Assume that <bpt i="2" x="2">&lt;c2&gt;</bpt>S<ept i="2">&lt;/c2&gt;</ept> is a custom type that conforms to the <bpt i="3" x="3">&lt;c3&gt;</bpt>Set<bpt i="4" x="4">&lt;w4&gt;</bpt>Algebra<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> protocol, <bpt i="5" x="5">&lt;c5&gt;</bpt>x<ept i="5">&lt;/c5&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt>y<ept i="6">&lt;/c6&gt;</ept> are instances of <bpt i="7" x="7">&lt;c7&gt;</bpt>S<ept i="7">&lt;/c7&gt;</ept>, and <bpt i="8" x="8">&lt;c8&gt;</bpt>e<ept i="8">&lt;/c8&gt;</ept> is of type <bpt i="9" x="9">&lt;c9&gt;</bpt>S<bpt i="10" x="10">&lt;w10&gt;</bpt>.Element<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>—the type that the set holds.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>S<ept i="2">&lt;/c2&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>Set<bpt i="4" x="4">&lt;w4&gt;</bpt>Algebra<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>プロトコルに準拠するあつらえの型、<bpt i="5" x="5">&lt;c5&gt;</bpt>x<ept i="5">&lt;/c5&gt;</ept>と<bpt i="6" x="6">&lt;c6&gt;</bpt>y<ept i="6">&lt;/c6&gt;</ept>は<bpt i="7" x="7">&lt;c7&gt;</bpt>S<ept i="7">&lt;/c7&gt;</ept>のインスタンス、そして<bpt i="8" x="8">&lt;c8&gt;</bpt>e<ept i="8">&lt;/c8&gt;</ept>は型<bpt i="9" x="9">&lt;c9&gt;</bpt>S<bpt i="10" x="10">&lt;w10&gt;</bpt>.Element<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> — 集合が保持する型、と仮定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>At least one of the sequences must be finite.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>少なくともシーケンスのうちの一方は有限でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Attempting to access an element by using an index outside the bounds of the slice may result in a runtime error, even if that index is valid for the original collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある要素にスライスの境界外のインデックスを使ってアクセスを試みることは、実行時エラーという結果になるでしょう、たとえそのインデックスが元々のコレクションに対して有効であるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Attempting to access an element by using an index outside the bounds of the slice’s indices may result in a runtime error, even if that index is valid for the original collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある要素にスライスのもつインデックスの境界外のインデックスを使ってアクセスを試みることは、実行時エラーという結果になるでしょう、たとえそのインデックスが元々のコレクションに対して有効であるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Attempting to call the <bpt i="0" x="0">&lt;c0&gt;</bpt>collection<bpt i="1" x="1">&lt;w1&gt;</bpt>With<bpt i="2" x="2">&lt;w2&gt;</bpt>Values:<bpt i="3" x="3">&lt;w3&gt;</bpt>for<bpt i="4" x="4">&lt;w4&gt;</bpt>Keys:<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method in Swift results in a compiler error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>collection<bpt i="1" x="1">&lt;w1&gt;</bpt>With<bpt i="2" x="2">&lt;w2&gt;</bpt>Values:<bpt i="3" x="3">&lt;w3&gt;</bpt>for<bpt i="4" x="4">&lt;w4&gt;</bpt>Keys:<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドをスウィフトにおいて呼び出す試みは、コンパイラエラーという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Attempting to remove more elements than exist in the collection triggers a runtime error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの中に存在するより多くの要素の削除を試みることは実行時エラーの引き金となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Attempting to remove the same shipping option a second time results in <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>, because <bpt i="3" x="3">&lt;c3&gt;</bpt>options<ept i="3">&lt;/c3&gt;</ept> no longer contains <bpt i="4" x="4">&lt;c4&gt;</bpt>.priority<ept i="4">&lt;/c4&gt;</ept> as a member.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同じ出荷オプションの削除を２回目に試みることは<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>という結果になります、<bpt i="3" x="3">&lt;c3&gt;</bpt>options<ept i="3">&lt;/c3&gt;</ept>はもはや<bpt i="4" x="4">&lt;c4&gt;</bpt>.priority<ept i="4">&lt;/c4&gt;</ept>をメンバとして含まないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Array<bpt i="2" x="2">&lt;w2&gt;</bpt>Literal<bpt i="3" x="3">&lt;w3&gt;</bpt>Element<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is <bpt i="4" x="4">&lt;c4&gt;</bpt><ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>Element<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Array<bpt i="2" x="2">&lt;w2&gt;</bpt>Literal<bpt i="3" x="3">&lt;w3&gt;</bpt>Element<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt><ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>Element<ept i="5">&lt;/c5&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept> conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt>Comparable<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Comparable<ept i="2">&lt;/c2&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept> conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt>Equatable<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Equatable<ept i="2">&lt;/c2&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept> conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt>Sequence<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Sequence<ept i="2">&lt;/c2&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept> conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt>String<bpt i="3" x="3">&lt;w3&gt;</bpt>Protocol<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>String<bpt i="3" x="3">&lt;w3&gt;</bpt>Protocol<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>(CGRect, NSColor)<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>(CGRect, NSColor)<ept i="2">&lt;/c2&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>(CGRect, gray: CGFloat)<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>(CGRect, gray: CGFloat)<ept i="2">&lt;/c2&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>NSRect<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>NSRect<ept i="2">&lt;/c2&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Elements<ept i="1">&lt;/c1&gt;</ept> conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt>Lazy<bpt i="3" x="3">&lt;w3&gt;</bpt>Collection<bpt i="4" x="4">&lt;w4&gt;</bpt>Protocol<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Elements<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Lazy<bpt i="3" x="3">&lt;w3&gt;</bpt>Collection<bpt i="4" x="4">&lt;w4&gt;</bpt>Protocol<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Elements<ept i="1">&lt;/c1&gt;</ept> conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt>Lazy<bpt i="3" x="3">&lt;w3&gt;</bpt>Sequence<bpt i="4" x="4">&lt;w4&gt;</bpt>Protocol<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Elements<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Lazy<bpt i="3" x="3">&lt;w3&gt;</bpt>Sequence<bpt i="4" x="4">&lt;w4&gt;</bpt>Protocol<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Index<ept i="1">&lt;/c1&gt;</ept> conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt>Strideable<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>Indices<ept i="3">&lt;/c3&gt;</ept> is <bpt i="4" x="4">&lt;c4&gt;</bpt>Range<it pos="begin" x="5">&lt;Self&lt;w5&gt;</it>.Index&gt;<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, and <bpt i="6" x="6">&lt;c6&gt;</bpt><ept i="6">&lt;/c6&gt;</ept><bpt i="7" x="7">&lt;c7&gt;</bpt>Index<ept i="7">&lt;/c7&gt;</ept><bpt i="8" x="8">&lt;c8&gt;</bpt>.<ept i="8">&lt;/c8&gt;</ept><bpt i="9" x="9">&lt;c9&gt;</bpt>Stride<ept i="9">&lt;/c9&gt;</ept> is <bpt i="10" x="10">&lt;c10&gt;</bpt>Int<ept i="10">&lt;/c10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Index<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Strideable<ept i="2">&lt;/c2&gt;</ept>に準拠する、<bpt i="3" x="3">&lt;c3&gt;</bpt>Indices<ept i="3">&lt;/c3&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt>Range<it pos="begin" x="5">&lt;Self&lt;w5&gt;</it>.Index&gt;<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>である、そして<bpt i="6" x="6">&lt;c6&gt;</bpt><ept i="6">&lt;/c6&gt;</ept><bpt i="7" x="7">&lt;c7&gt;</bpt>Index<ept i="7">&lt;/c7&gt;</ept><bpt i="8" x="8">&lt;c8&gt;</bpt>.<ept i="8">&lt;/c8&gt;</ept><bpt i="9" x="9">&lt;c9&gt;</bpt>Stride<ept i="9">&lt;/c9&gt;</ept>が<bpt i="10" x="10">&lt;c10&gt;</bpt>Int<ept i="10">&lt;/c10&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Raw<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Fixed<bpt i="4" x="4">&lt;w4&gt;</bpt>Width<bpt i="5" x="5">&lt;w5&gt;</bpt>Integer<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Raw<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Fixed<bpt i="4" x="4">&lt;w4&gt;</bpt>Width<bpt i="5" x="5">&lt;w5&gt;</bpt>Integer<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Scalar<ept i="1">&lt;/c1&gt;</ept> conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt>Binary<bpt i="3" x="3">&lt;w3&gt;</bpt>Floating<bpt i="4" x="4">&lt;w4&gt;</bpt>Point<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt><ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>Scalar<ept i="6">&lt;/c6&gt;</ept><bpt i="7" x="7">&lt;c7&gt;</bpt>.<ept i="7">&lt;/c7&gt;</ept><bpt i="8" x="8">&lt;c8&gt;</bpt>Raw<bpt i="9" x="9">&lt;w9&gt;</bpt>Significand<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> conforms to <bpt i="10" x="10">&lt;c10&gt;</bpt>Fixed<bpt i="11" x="11">&lt;w11&gt;</bpt>Width<bpt i="12" x="12">&lt;w12&gt;</bpt>Integer<ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Scalar<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Binary<bpt i="3" x="3">&lt;w3&gt;</bpt>Floating<bpt i="4" x="4">&lt;w4&gt;</bpt>Point<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に準拠するそして<bpt i="5" x="5">&lt;c5&gt;</bpt><ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>Scalar<ept i="6">&lt;/c6&gt;</ept><bpt i="7" x="7">&lt;c7&gt;</bpt>.<ept i="7">&lt;/c7&gt;</ept><bpt i="8" x="8">&lt;c8&gt;</bpt>Raw<bpt i="9" x="9">&lt;w9&gt;</bpt>Significand<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>が<bpt i="10" x="10">&lt;c10&gt;</bpt>Fixed<bpt i="11" x="11">&lt;w11&gt;</bpt>Width<bpt i="12" x="12">&lt;w12&gt;</bpt>Integer<ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Scalar<ept i="1">&lt;/c1&gt;</ept> conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt>Comparable<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Scalar<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Comparable<ept i="2">&lt;/c2&gt;</ept>に準拠する場合に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Scalar<ept i="1">&lt;/c1&gt;</ept> conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt>Fixed<bpt i="3" x="3">&lt;w3&gt;</bpt>Width<bpt i="4" x="4">&lt;w4&gt;</bpt>Integer<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Scalar<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Fixed<bpt i="3" x="3">&lt;w3&gt;</bpt>Width<bpt i="4" x="4">&lt;w4&gt;</bpt>Integer<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に準拠する場合に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Scalar<ept i="1">&lt;/c1&gt;</ept> conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt>Floating<bpt i="3" x="3">&lt;w3&gt;</bpt>Point<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Scalar<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Floating<bpt i="3" x="3">&lt;w3&gt;</bpt>Point<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に準拠する場合に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Bidirectional<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>Base<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>.<ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>Index<ept i="5">&lt;/c5&gt;</ept> conforms to <bpt i="6" x="6">&lt;c6&gt;</bpt>Hashable<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Bidirectional<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="3" x="3">&lt;c3&gt;</bpt>Base<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>.<ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>Index<ept i="5">&lt;/c5&gt;</ept>が<bpt i="6" x="6">&lt;c6&gt;</bpt>Hashable<ept i="6">&lt;/c6&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Bidirectional<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Bidirectional<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Collection<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Collection<ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Lazy<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<bpt i="3" x="3">&lt;w3&gt;</bpt>Protocol<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>Base<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Collection<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Lazy<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<bpt i="3" x="3">&lt;w3&gt;</bpt>Protocol<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="4" x="4">&lt;c4&gt;</bpt>Base<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Collection<ept i="5">&lt;/c5&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Lazy<bpt i="2" x="2">&lt;w2&gt;</bpt>Sequence<bpt i="3" x="3">&lt;w3&gt;</bpt>Protocol<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Lazy<bpt i="2" x="2">&lt;w2&gt;</bpt>Sequence<bpt i="3" x="3">&lt;w3&gt;</bpt>Protocol<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する場合に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Comparable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Comparable<ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>Base<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Bidirectional<bpt i="6" x="6">&lt;w6&gt;</bpt>Collection<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>に準拠するそして<bpt i="4" x="4">&lt;c4&gt;</bpt>Base<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Bidirectional<bpt i="6" x="6">&lt;w6&gt;</bpt>Collection<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>Base<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Collection<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>に準拠するそして<bpt i="4" x="4">&lt;c4&gt;</bpt>Base<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Collection<ept i="5">&lt;/c5&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Sequence<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>Base<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Lazy<bpt i="6" x="6">&lt;w6&gt;</bpt>Sequence<bpt i="7" x="7">&lt;w7&gt;</bpt>Protocol<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Sequence<ept i="3">&lt;/c3&gt;</ept>に準拠するそして<bpt i="4" x="4">&lt;c4&gt;</bpt>Base<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Lazy<bpt i="6" x="6">&lt;w6&gt;</bpt>Sequence<bpt i="7" x="7">&lt;w7&gt;</bpt>Protocol<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Sequence<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Sequence<ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>String<bpt i="4" x="4">&lt;w4&gt;</bpt>Protocol<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>String<bpt i="4" x="4">&lt;w4&gt;</bpt>Protocol<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept> is <bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>Base<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Bidirectional<bpt i="6" x="6">&lt;w6&gt;</bpt>Collection<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>であるそして<bpt i="4" x="4">&lt;c4&gt;</bpt>Base<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Bidirectional<bpt i="6" x="6">&lt;w6&gt;</bpt>Collection<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept> is <bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Element<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Comparable<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Element<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Comparable<ept i="5">&lt;/c5&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Element<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Equatable<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Element<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Equatable<ept i="5">&lt;/c5&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Element<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Sequence<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Element<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Sequence<ept i="5">&lt;/c5&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Element<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>String<bpt i="6" x="6">&lt;w6&gt;</bpt>Protocol<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Element<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>String<bpt i="6" x="6">&lt;w6&gt;</bpt>Protocol<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Index<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Strideable<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>Base<bpt i="5" x="5">&lt;w5&gt;</bpt>.Indices<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is <bpt i="6" x="6">&lt;c6&gt;</bpt>Range<it pos="begin" x="7">&lt;Base&lt;w7&gt;</it>.Index&gt;<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, <bpt i="8" x="8">&lt;c8&gt;</bpt>Base<ept i="8">&lt;/c8&gt;</ept><bpt i="9" x="9">&lt;c9&gt;</bpt>.<ept i="9">&lt;/c9&gt;</ept><bpt i="10" x="10">&lt;c10&gt;</bpt>Index<ept i="10">&lt;/c10&gt;</ept><bpt i="11" x="11">&lt;c11&gt;</bpt>.<ept i="11">&lt;/c11&gt;</ept><bpt i="12" x="12">&lt;c12&gt;</bpt>Stride<ept i="12">&lt;/c12&gt;</ept> is <bpt i="13" x="13">&lt;c13&gt;</bpt>Int<ept i="13">&lt;/c13&gt;</ept>, and <bpt i="14" x="14">&lt;c14&gt;</bpt>Base<ept i="14">&lt;/c14&gt;</ept> conforms to <bpt i="15" x="15">&lt;c15&gt;</bpt>Random<bpt i="16" x="16">&lt;w16&gt;</bpt>Access<bpt i="17" x="17">&lt;w17&gt;</bpt>Collection<ept i="17">&lt;/w17&gt;</ept><ept i="16">&lt;/w16&gt;</ept><ept i="15">&lt;/c15&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Index<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Strideable<ept i="3">&lt;/c3&gt;</ept>に準拠する、<bpt i="4" x="4">&lt;c4&gt;</bpt>Base<bpt i="5" x="5">&lt;w5&gt;</bpt>.Indices<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>が<bpt i="6" x="6">&lt;c6&gt;</bpt>Range<it pos="begin" x="7">&lt;Base&lt;w7&gt;</it>.Index&gt;<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>である、<bpt i="8" x="8">&lt;c8&gt;</bpt>Base<ept i="8">&lt;/c8&gt;</ept><bpt i="9" x="9">&lt;c9&gt;</bpt>.<ept i="9">&lt;/c9&gt;</ept><bpt i="10" x="10">&lt;c10&gt;</bpt>Index<ept i="10">&lt;/c10&gt;</ept><bpt i="11" x="11">&lt;c11&gt;</bpt>.<ept i="11">&lt;/c11&gt;</ept><bpt i="12" x="12">&lt;c12&gt;</bpt>Stride<ept i="12">&lt;/c12&gt;</ept>が<bpt i="13" x="13">&lt;c13&gt;</bpt>Int<ept i="13">&lt;/c13&gt;</ept>である、そして<bpt i="14" x="14">&lt;c14&gt;</bpt>Base<ept i="14">&lt;/c14&gt;</ept>が<bpt i="15" x="15">&lt;c15&gt;</bpt>Random<bpt i="16" x="16">&lt;w16&gt;</bpt>Access<bpt i="17" x="17">&lt;w17&gt;</bpt>Collection<ept i="17">&lt;/w17&gt;</ept><ept i="16">&lt;/w16&gt;</ept><ept i="15">&lt;/c15&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<bpt i="1" x="1">&lt;w1&gt;</bpt>.Indices<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>Default<bpt i="3" x="3">&lt;w3&gt;</bpt>Indices<it pos="begin" x="4">&lt;Lazy&lt;w4&gt;</it>Map<bpt i="5" x="5">&lt;w5&gt;</bpt>Sequence&lt;Base, Element&gt;&gt;<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt>Base<ept i="6">&lt;/c6&gt;</ept> conforms to <bpt i="7" x="7">&lt;c7&gt;</bpt>Collection<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<bpt i="1" x="1">&lt;w1&gt;</bpt>.Indices<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Default<bpt i="3" x="3">&lt;w3&gt;</bpt>Indices<it pos="begin" x="4">&lt;Lazy&lt;w4&gt;</it>Map<bpt i="5" x="5">&lt;w5&gt;</bpt>Sequence&lt;Base, Element&gt;&gt;<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>であるそして<bpt i="6" x="6">&lt;c6&gt;</bpt>Base<ept i="6">&lt;/c6&gt;</ept>が<bpt i="7" x="7">&lt;c7&gt;</bpt>Collection<ept i="7">&lt;/c7&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<bpt i="1" x="1">&lt;w1&gt;</bpt>.Indices<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>Default<bpt i="3" x="3">&lt;w3&gt;</bpt>Indices<it pos="begin" x="4">&lt;Lazy&lt;w4&gt;</it>Sequence&lt;Base&gt;&gt;<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt>Base<ept i="5">&lt;/c5&gt;</ept> conforms to <bpt i="6" x="6">&lt;c6&gt;</bpt>Collection<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<bpt i="1" x="1">&lt;w1&gt;</bpt>.Indices<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Default<bpt i="3" x="3">&lt;w3&gt;</bpt>Indices<it pos="begin" x="4">&lt;Lazy&lt;w4&gt;</it>Sequence&lt;Base&gt;&gt;<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>であるそして<bpt i="5" x="5">&lt;c5&gt;</bpt>Base<ept i="5">&lt;/c5&gt;</ept>が<bpt i="6" x="6">&lt;c6&gt;</bpt>Collection<ept i="6">&lt;/c6&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Binary<bpt i="2" x="2">&lt;w2&gt;</bpt>Integer<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Binary<bpt i="2" x="2">&lt;w2&gt;</bpt>Integer<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>Bound<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Strideable<ept i="3">&lt;/c3&gt;</ept>, and <bpt i="4" x="4">&lt;c4&gt;</bpt>Bound<ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>.<ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>Stride<ept i="6">&lt;/c6&gt;</ept> conforms to <bpt i="7" x="7">&lt;c7&gt;</bpt>Signed<bpt i="8" x="8">&lt;w8&gt;</bpt>Integer<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠する、<bpt i="2" x="2">&lt;c2&gt;</bpt>Bound<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Strideable<ept i="3">&lt;/c3&gt;</ept>に準拠する、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>Bound<ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>.<ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>Stride<ept i="6">&lt;/c6&gt;</ept>が<bpt i="7" x="7">&lt;c7&gt;</bpt>Signed<bpt i="8" x="8">&lt;w8&gt;</bpt>Integer<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Sequence<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>Bound<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Strideable<ept i="3">&lt;/c3&gt;</ept>, and <bpt i="4" x="4">&lt;c4&gt;</bpt>Bound<ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>.<ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>Stride<ept i="6">&lt;/c6&gt;</ept> conforms to <bpt i="7" x="7">&lt;c7&gt;</bpt>Signed<bpt i="8" x="8">&lt;w8&gt;</bpt>Integer<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Sequence<ept i="1">&lt;/c1&gt;</ept>に準拠する、<bpt i="2" x="2">&lt;c2&gt;</bpt>Bound<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Strideable<ept i="3">&lt;/c3&gt;</ept>に準拠する、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>Bound<ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>.<ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>Stride<ept i="6">&lt;/c6&gt;</ept>が<bpt i="7" x="7">&lt;c7&gt;</bpt>Signed<bpt i="8" x="8">&lt;w8&gt;</bpt>Integer<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Strideable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Bound<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Stride<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Signed<bpt i="6" x="6">&lt;w6&gt;</bpt>Integer<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Strideable<ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="2" x="2">&lt;c2&gt;</bpt>Bound<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Stride<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Signed<bpt i="6" x="6">&lt;w6&gt;</bpt>Integer<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Strideable<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>Bound<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Stride<ept i="4">&lt;/c4&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>Int<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>Bound<ept i="6">&lt;/c6&gt;</ept> conforms to <bpt i="7" x="7">&lt;c7&gt;</bpt>Strideable<ept i="7">&lt;/c7&gt;</ept>, and <bpt i="8" x="8">&lt;c8&gt;</bpt>Bound<ept i="8">&lt;/c8&gt;</ept><bpt i="9" x="9">&lt;c9&gt;</bpt>.<ept i="9">&lt;/c9&gt;</ept><bpt i="10" x="10">&lt;c10&gt;</bpt>Stride<ept i="10">&lt;/c10&gt;</ept> conforms to <bpt i="11" x="11">&lt;c11&gt;</bpt>Signed<bpt i="12" x="12">&lt;w12&gt;</bpt>Integer<ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Strideable<ept i="1">&lt;/c1&gt;</ept>に準拠する、<bpt i="2" x="2">&lt;c2&gt;</bpt>Bound<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Stride<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Int<ept i="5">&lt;/c5&gt;</ept>である、<bpt i="6" x="6">&lt;c6&gt;</bpt>Bound<ept i="6">&lt;/c6&gt;</ept>が<bpt i="7" x="7">&lt;c7&gt;</bpt>Strideable<ept i="7">&lt;/c7&gt;</ept>に準拠する、そして<bpt i="8" x="8">&lt;c8&gt;</bpt>Bound<ept i="8">&lt;/c8&gt;</ept><bpt i="9" x="9">&lt;c9&gt;</bpt>.<ept i="9">&lt;/c9&gt;</ept><bpt i="10" x="10">&lt;c10&gt;</bpt>Stride<ept i="10">&lt;/c10&gt;</ept>が<bpt i="11" x="11">&lt;c11&gt;</bpt>Signed<bpt i="12" x="12">&lt;w12&gt;</bpt>Integer<ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>String<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>Bound<ept i="3">&lt;/c3&gt;</ept> conforms to <bpt i="4" x="4">&lt;c4&gt;</bpt>Strideable<ept i="4">&lt;/c4&gt;</ept>, and <bpt i="5" x="5">&lt;c5&gt;</bpt>Bound<ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>.<ept i="6">&lt;/c6&gt;</ept><bpt i="7" x="7">&lt;c7&gt;</bpt>Stride<ept i="7">&lt;/c7&gt;</ept> conforms to <bpt i="8" x="8">&lt;c8&gt;</bpt>Signed<bpt i="9" x="9">&lt;w9&gt;</bpt>Integer<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>String<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する、<bpt i="3" x="3">&lt;c3&gt;</bpt>Bound<ept i="3">&lt;/c3&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt>Strideable<ept i="4">&lt;/c4&gt;</ept>に準拠する、そして<bpt i="5" x="5">&lt;c5&gt;</bpt>Bound<ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>.<ept i="6">&lt;/c6&gt;</ept><bpt i="7" x="7">&lt;c7&gt;</bpt>Stride<ept i="7">&lt;/c7&gt;</ept>が<bpt i="8" x="8">&lt;c8&gt;</bpt>Signed<bpt i="9" x="9">&lt;w9&gt;</bpt>Integer<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>Attributed<bpt i="2" x="2">&lt;w2&gt;</bpt>String<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Index<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Attributed<bpt i="2" x="2">&lt;w2&gt;</bpt>String<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Index<ept i="4">&lt;/c4&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>Date<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Date<ept i="1">&lt;/c1&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>Bound<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Strideable<ept i="3">&lt;/c3&gt;</ept>, and <bpt i="4" x="4">&lt;c4&gt;</bpt>Bound<ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>.<ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>Stride<ept i="6">&lt;/c6&gt;</ept> conforms to <bpt i="7" x="7">&lt;c7&gt;</bpt>Signed<bpt i="8" x="8">&lt;w8&gt;</bpt>Integer<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>である、<bpt i="2" x="2">&lt;c2&gt;</bpt>Bound<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Strideable<ept i="3">&lt;/c3&gt;</ept>に準拠する、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>Bound<ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>.<ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>Stride<ept i="6">&lt;/c6&gt;</ept>が<bpt i="7" x="7">&lt;c7&gt;</bpt>Signed<bpt i="8" x="8">&lt;w8&gt;</bpt>Integer<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>.<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Index<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>.<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Index<ept i="3">&lt;/c3&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Base<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Bidirectional<bpt i="4" x="4">&lt;w4&gt;</bpt>Collection<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="2" x="2">&lt;c2&gt;</bpt>Base<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Bidirectional<bpt i="4" x="4">&lt;w4&gt;</bpt>Collection<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Base<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Collection<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="2" x="2">&lt;c2&gt;</bpt>Base<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Collection<ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Sequence<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Sequence<ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>String<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>String<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>Any<bpt i="2" x="2">&lt;w2&gt;</bpt>Hashable<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Any<bpt i="2" x="2">&lt;w2&gt;</bpt>Hashable<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Base<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Bidirectional<bpt i="4" x="4">&lt;w4&gt;</bpt>Collection<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>であるそして<bpt i="2" x="2">&lt;c2&gt;</bpt>Base<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Bidirectional<bpt i="4" x="4">&lt;w4&gt;</bpt>Collection<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>UInt8<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>UInt8<ept i="1">&lt;/c1&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Failure<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>Error<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Failure<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Error<ept i="1">&lt;/c1&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Lazy<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>&lt;<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Base<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>&gt;<ept i="4">&lt;/c4&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>Base<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Lazy<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>&lt;<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Base<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>&gt;<ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>Base<ept i="5">&lt;/c5&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Never<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Any<bpt i="2" x="2">&lt;w2&gt;</bpt>Object<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Never<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Any<bpt i="2" x="2">&lt;w2&gt;</bpt>Object<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Prefix<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<it pos="begin" x="2">&lt;Base&gt;.Iterator&lt;w2&gt;</it>.Element<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Comparable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Prefix<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<it pos="begin" x="2">&lt;Base&gt;.Iterator&lt;w2&gt;</it>.Element<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Comparable<ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Prefix<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<it pos="begin" x="2">&lt;Base&gt;.Iterator&lt;w2&gt;</it>.Element<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Prefix<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<it pos="begin" x="2">&lt;Base&gt;.Iterator&lt;w2&gt;</it>.Element<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Prefix<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<it pos="begin" x="2">&lt;Base&gt;.Iterator&lt;w2&gt;</it>.Element<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Sequence<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Prefix<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<it pos="begin" x="2">&lt;Base&gt;.Iterator&lt;w2&gt;</it>.Element<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Sequence<ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Prefix<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<it pos="begin" x="2">&lt;Base&gt;.Iterator&lt;w2&gt;</it>.Element<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>String<bpt i="4" x="4">&lt;w4&gt;</bpt>Protocol<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Prefix<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<it pos="begin" x="2">&lt;Base&gt;.Iterator&lt;w2&gt;</it>.Element<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>String<bpt i="4" x="4">&lt;w4&gt;</bpt>Protocol<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Binary<bpt i="2" x="2">&lt;w2&gt;</bpt>Floating<bpt i="3" x="3">&lt;w3&gt;</bpt>Point<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>Scalar<ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>.<ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>Raw<bpt i="7" x="7">&lt;w7&gt;</bpt>Significand<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> conforms to <bpt i="8" x="8">&lt;c8&gt;</bpt>Fixed<bpt i="9" x="9">&lt;w9&gt;</bpt>Width<bpt i="10" x="10">&lt;w10&gt;</bpt>Integer<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Binary<bpt i="2" x="2">&lt;w2&gt;</bpt>Floating<bpt i="3" x="3">&lt;w3&gt;</bpt>Point<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="4" x="4">&lt;c4&gt;</bpt>Scalar<ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>.<ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>Raw<bpt i="7" x="7">&lt;w7&gt;</bpt>Significand<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>が<bpt i="8" x="8">&lt;c8&gt;</bpt>Fixed<bpt i="9" x="9">&lt;w9&gt;</bpt>Width<bpt i="10" x="10">&lt;w10&gt;</bpt>Integer<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Binary<bpt i="2" x="2">&lt;w2&gt;</bpt>Floating<bpt i="3" x="3">&lt;w3&gt;</bpt>Point<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Binary<bpt i="2" x="2">&lt;w2&gt;</bpt>Floating<bpt i="3" x="3">&lt;w3&gt;</bpt>Point<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する場合に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>に準拠する場合に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Fixed<bpt i="2" x="2">&lt;w2&gt;</bpt>Width<bpt i="3" x="3">&lt;w3&gt;</bpt>Integer<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Fixed<bpt i="2" x="2">&lt;w2&gt;</bpt>Width<bpt i="3" x="3">&lt;w3&gt;</bpt>Integer<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する場合に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Floating<bpt i="2" x="2">&lt;w2&gt;</bpt>Point<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Floating<bpt i="2" x="2">&lt;w2&gt;</bpt>Point<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する場合に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>Float16<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Float16<ept i="1">&lt;/c1&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>Float<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Float<ept i="1">&lt;/c1&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>Int16<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Int16<ept i="1">&lt;/c1&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>Int32<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Int32<ept i="1">&lt;/c1&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>Int64<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Int64<ept i="1">&lt;/c1&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>Int8<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Int8<ept i="1">&lt;/c1&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>UInt16<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>UInt16<ept i="1">&lt;/c1&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>UInt32<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>UInt32<ept i="1">&lt;/c1&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>UInt64<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>UInt64<ept i="1">&lt;/c1&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>UInt8<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>UInt8<ept i="1">&lt;/c1&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>UInt<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>UInt<ept i="1">&lt;/c1&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Additive<bpt i="2" x="2">&lt;w2&gt;</bpt>Arithmetic<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt><ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Scalar<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Floating<bpt i="6" x="6">&lt;w6&gt;</bpt>Point<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Additive<bpt i="2" x="2">&lt;w2&gt;</bpt>Arithmetic<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="3" x="3">&lt;c3&gt;</bpt><ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Scalar<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Floating<bpt i="6" x="6">&lt;w6&gt;</bpt>Point<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Bidirectional<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>Self<ept i="3">&lt;/c3&gt;</ept> is <bpt i="4" x="4">&lt;c4&gt;</bpt><ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>Sub<bpt i="6" x="6">&lt;w6&gt;</bpt>Sequence<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Bidirectional<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="3" x="3">&lt;c3&gt;</bpt>Self<ept i="3">&lt;/c3&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt><ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>Sub<bpt i="6" x="6">&lt;w6&gt;</bpt>Sequence<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Bidirectional<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Bidirectional<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>Bool<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Bool<ept i="5">&lt;/c5&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>Double<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>に準拠して<bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Double<ept i="5">&lt;/c5&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>Float<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>に準拠して<bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Float<ept i="5">&lt;/c5&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>Int16<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>に準拠して<bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Int16<ept i="5">&lt;/c5&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>Int32<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>に準拠して<bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Int32<ept i="5">&lt;/c5&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>Int64<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>に準拠して<bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Int64<ept i="5">&lt;/c5&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>Int8<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>に準拠して<bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Int8<ept i="5">&lt;/c5&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>Int<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>に準拠し<bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Int<ept i="5">&lt;/c5&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>String<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>に準拠する、そして<bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>String<ept i="5">&lt;/c5&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>UInt16<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>に準拠して<bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>UInt16<ept i="5">&lt;/c5&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>UInt32<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>に準拠して<bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>UInt32<ept i="5">&lt;/c5&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>UInt64<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>に準拠して<bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>UInt64<ept i="5">&lt;/c5&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>UInt8<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>に準拠して<bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>UInt8<ept i="5">&lt;/c5&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>UInt<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>に準拠して<bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>UInt<ept i="5">&lt;/c5&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>Bool<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>に準拠して<bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Bool<ept i="5">&lt;/c5&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>Double<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>に準拠して<bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Double<ept i="5">&lt;/c5&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>Float<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>に準拠して<bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Float<ept i="5">&lt;/c5&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>Int16<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>に準拠して<bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Int16<ept i="5">&lt;/c5&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>Int32<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>に準拠して<bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Int32<ept i="5">&lt;/c5&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>Int64<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>に準拠して<bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Int64<ept i="5">&lt;/c5&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>Int8<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>に準拠して<bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Int8<ept i="5">&lt;/c5&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>Int<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>に準拠して<bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Int<ept i="5">&lt;/c5&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>String<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>に準拠して<bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>String<ept i="5">&lt;/c5&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>UInt16<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>に準拠して<bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>UInt16<ept i="5">&lt;/c5&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>UInt32<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>に準拠して<bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>UInt32<ept i="5">&lt;/c5&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>UInt64<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>に準拠して<bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>UInt64<ept i="5">&lt;/c5&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>UInt8<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>に準拠して<bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>UInt8<ept i="5">&lt;/c5&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>UInt<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>に準拠して<bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>UInt<ept i="5">&lt;/c5&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Fixed<bpt i="2" x="2">&lt;w2&gt;</bpt>Width<bpt i="3" x="3">&lt;w3&gt;</bpt>Integer<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Fixed<bpt i="2" x="2">&lt;w2&gt;</bpt>Width<bpt i="3" x="3">&lt;w3&gt;</bpt>Integer<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Hashable<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="2" x="2">&lt;c2&gt;</bpt><ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Hashable<ept i="5">&lt;/c5&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Mutable<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Mutable<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Random<bpt i="2" x="2">&lt;w2&gt;</bpt>Access<bpt i="3" x="3">&lt;w3&gt;</bpt>Collection<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt><ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>Element<ept i="5">&lt;/c5&gt;</ept> conforms to <bpt i="6" x="6">&lt;c6&gt;</bpt>Comparable<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Random<bpt i="2" x="2">&lt;w2&gt;</bpt>Access<bpt i="3" x="3">&lt;w3&gt;</bpt>Collection<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="4" x="4">&lt;c4&gt;</bpt><ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>Element<ept i="5">&lt;/c5&gt;</ept>が<bpt i="6" x="6">&lt;c6&gt;</bpt>Comparable<ept i="6">&lt;/c6&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Random<bpt i="2" x="2">&lt;w2&gt;</bpt>Access<bpt i="3" x="3">&lt;w3&gt;</bpt>Collection<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Random<bpt i="2" x="2">&lt;w2&gt;</bpt>Access<bpt i="3" x="3">&lt;w3&gt;</bpt>Collection<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt><ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt><ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt><ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Elements<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt><ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Elements<ept i="2">&lt;/c2&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt><ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Iterator<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt><ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Iterator<ept i="2">&lt;/c2&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt><ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Sub<bpt i="3" x="3">&lt;w3&gt;</bpt>Sequence<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt><ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Sub<bpt i="3" x="3">&lt;w3&gt;</bpt>Sequence<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Success<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Failure<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Success<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="2" x="2">&lt;c2&gt;</bpt>Failure<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Success<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Failure<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Hashable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Success<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="2" x="2">&lt;c2&gt;</bpt>Failure<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Hashable<ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<bpt i="2" x="2">&lt;w2&gt;</bpt>With<bpt i="3" x="3">&lt;w3&gt;</bpt>Configuration<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<bpt i="2" x="2">&lt;w2&gt;</bpt>With<bpt i="3" x="3">&lt;w3&gt;</bpt>Configuration<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<bpt i="2" x="2">&lt;w2&gt;</bpt>With<bpt i="3" x="3">&lt;w3&gt;</bpt>Configuration<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<bpt i="2" x="2">&lt;w2&gt;</bpt>With<bpt i="3" x="3">&lt;w3&gt;</bpt>Configuration<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Gesture<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Gesture<ept i="1">&lt;/c1&gt;</ept>に準拠する場合に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>View<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>View<ept i="1">&lt;/c1&gt;</ept>に準拠する場合に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Basic Arithmetic</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>基本算術</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Basic Behaviors</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>基本の挙動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Basic Collections</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>基本コレクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Basic Values</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>基本的な値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Be aware, therefore, that general operations on <bpt i="6" x="6">&lt;c6&gt;</bpt>Lazy<bpt i="7" x="7">&lt;w7&gt;</bpt>Filter<bpt i="8" x="8">&lt;w8&gt;</bpt>Collection<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> instances may not have the documented complexity.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>自覚すべきは、したがって、<bpt i="6" x="6">&lt;c6&gt;</bpt>Lazy<bpt i="7" x="7">&lt;w7&gt;</bpt>Filter<bpt i="8" x="8">&lt;w8&gt;</bpt>Collection<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>インスタンス上での全体的な演算が複雑に記述されるものを持たないようにすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Be aware, therefore, that general operations on lazy collections may not have the documented complexity.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>自覚すべきは、したがって、遅延コレクション上での一般的な演算が複雑に記述されるものを持たないようにすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because <bpt i="0" x="0">&lt;c0&gt;</bpt>Range<ept i="0">&lt;/c0&gt;</ept> represents a half-open range, a <bpt i="1" x="1">&lt;c1&gt;</bpt>Range<ept i="1">&lt;/c1&gt;</ept> instance does not contain its upper bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Range<ept i="0">&lt;/c0&gt;</ept>は半開範囲を表すことから、<bpt i="1" x="1">&lt;c1&gt;</bpt>Range<ept i="1">&lt;/c1&gt;</ept>インスタンスはそれの上方の境界を含みません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because Swift provides several ways to safely unwrap optional values, you can choose the one that helps you write clear, concise code.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftは安全にオプショナル値をアンラップするために複数の方法を提供するので、あなたは明快な、簡潔なコードを記述する助けとしてその１つを選ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because a <bpt i="0" x="0">&lt;c0&gt;</bpt>Partial<bpt i="1" x="1">&lt;w1&gt;</bpt>Range<bpt i="2" x="2">&lt;w2&gt;</bpt>From<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> sequence counts upward indefinitely, do not use one with methods that read the entire sequence before returning, such as <bpt i="3" x="3">&lt;c3&gt;</bpt>map(_:)<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>filter(_:)<ept i="4">&lt;/c4&gt;</ept>, or <bpt i="5" x="5">&lt;c5&gt;</bpt>suffix(_:)<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Partial<bpt i="1" x="1">&lt;w1&gt;</bpt>Range<bpt i="2" x="2">&lt;w2&gt;</bpt>From<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>シーケンスが上向きに無限に数えることから、返す前にシーケンス全体を読み出すメソッド、例えば<bpt i="3" x="3">&lt;c3&gt;</bpt>map(_:)<ept i="3">&lt;/c3&gt;</ept>、<bpt i="4" x="4">&lt;c4&gt;</bpt>filter(_:)<ept i="4">&lt;/c4&gt;</ept>、または<bpt i="5" x="5">&lt;c5&gt;</bpt>suffix(_:)<ept i="5">&lt;/c5&gt;</ept>などを持つものと一緒に使わないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because a half-open range does not include its upper bound, the ranges in the following example do not overlap:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>半壊範囲はそれの上方の範囲を含まないことから、以下の例の範囲は重なりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because a set is not an ordered collection, the “first” element may not be the first element that was added to the set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合は順序付けられたコレクションではないことから、「最初」の要素は集合に加えられた最初の要素ではないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because calling a closure can change the local and global state of your app, the code you write on the lines after passing a closure needs to be written with a careful consideration of <bpt i="0" x="0">&lt;e0&gt;</bpt>when<ept i="0">&lt;/e0&gt;</ept> that closure is called.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>クロージャ呼び出しはあなたのアプリのローカルおよびグローバルな状態を変える可能性があることから、クロージャを渡す後の行であなたが書くコードは、<bpt i="0" x="0">&lt;e0&gt;</bpt>いつ<ept i="0">&lt;/e0&gt;</ept>そのクロージャが呼び出されるか注意深く考えて書かれる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because closures can contain code that interacts with multiple parts of an app, it's important to understand the different ways closures can be called by the APIs you pass them to.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>クロージャはアプリの複数の部分と相互作用するコードを含むことが可能なため、クロージャが、あなたがそれを渡す相手であるAPIによって呼び出される様々に異なる方法を理解するのは重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because enumerations define a finite number of states, and can bundle associated values with each individual state, you can use them to model the state of your app and its internal processes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>列挙がある有限の数の状態を定義する、そして個々の状態それぞれに関連値を束ねることから、あなたはそれらを使ってあなたのアプリの状態とそれの内部処理をモデル化できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because floating-point types such as <bpt i="0" x="0">&lt;c0&gt;</bpt>Float<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept> are their own <bpt i="2" x="2">&lt;c2&gt;</bpt>Stride<ept i="2">&lt;/c2&gt;</ept> types, they cannot be used as the bounds of a countable range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>浮動小数点型、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>Float<ept i="0">&lt;/c0&gt;</ept>および<bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept>は、それら独自の<bpt i="2" x="2">&lt;c2&gt;</bpt>Stride<ept i="2">&lt;/c2&gt;</ept>型であるので、それらは可付番範囲の境界として使われることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because of this, the index is always in-range and no trap can occur.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このために、インデックスは常に範囲内です、そしてトラップは起こりえません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because structures in C can't have methods, property accessors, or custom initializers, you often need to write such functionality using global functions.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Cでの構造体はメソッド、プロパティアクセッサ、またはあつらえのイニシャライザを持つことができないことから、あなたはしばしばそのような機能性をグローバル関数を使って書く必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because the <bpt i="0" x="0">&lt;c0&gt;</bpt>Signed<bpt i="1" x="1">&lt;w1&gt;</bpt>Numeric<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol provides default implementations of both of its required methods, you don’t need to do anything beyond declaring conformance to the protocol and ensuring that the values of your type support negation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Signed<bpt i="1" x="1">&lt;w1&gt;</bpt>Numeric<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルはそれの必須メソッドの両方の省略時の実装を提供することから、あなたは、プロトコルへの準拠を宣言することおよびあなたの型の値が負をサポートするのを確実にすること以上に何もする必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because the <bpt i="4" x="4">&lt;c4&gt;</bpt>Int8<ept i="4">&lt;/c4&gt;</ept> type can represent <bpt i="5" x="5">&lt;c5&gt;</bpt>127<ept i="5">&lt;/c5&gt;</ept> at maximum, the attempt to create <bpt i="6" x="6">&lt;c6&gt;</bpt>z<ept i="6">&lt;/c6&gt;</ept> with a value of <bpt i="7" x="7">&lt;c7&gt;</bpt>1000<ept i="7">&lt;/c7&gt;</ept> results in a runtime error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>Int8<ept i="4">&lt;/c4&gt;</ept>型は、最大で<bpt i="5" x="5">&lt;c5&gt;</bpt>127<ept i="5">&lt;/c5&gt;</ept>を表せることから、<bpt i="6" x="6">&lt;c6&gt;</bpt>z<ept i="6">&lt;/c6&gt;</ept>を<bpt i="7" x="7">&lt;c7&gt;</bpt>1000<ept i="7">&lt;/c7&gt;</ept>の値で作成する試みは、実行時エラーという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because this initializer does not perform any checks, it should be used as an optimization only when you are absolutely certain that <bpt i="0" x="0">&lt;c0&gt;</bpt>lower<ept i="0">&lt;/c0&gt;</ept> is less than or equal to <bpt i="1" x="1">&lt;c1&gt;</bpt>upper<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザは何ら確認を行わないので、それは、あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>lower<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>upper<ept i="1">&lt;/c1&gt;</ept>より少ないか等しいことを絶対に確信している場合にのみ１つの最適化として使われるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because you can’t subclass Swift classes in Objective-C, it’s best to choose a class in your app that doesn’t have any subclasses.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがスウィフトクラスをObjective-Cにおいてサブクラス化できないので、あなたのアプリにおいて全くサブクラスを持たないクラスを選択するのは最も良いことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Before shifting, the masking left shift operator masks the shift to this range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シフトする前に、マスク左シフト演算子は、シフトをマスクしてこの範囲にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Before shifting, the masking right shift operator masks the shift to this range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シフトする前に、マスク右シフト演算子は、シフトをマスクしてこの範囲にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Behind the scenes, Swift uses the <bpt i="0" x="0">&lt;c0&gt;</bpt>animals<ept i="0">&lt;/c0&gt;</ept> array’s iterator to loop over the contents of the array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>舞台裏で、Swiftは<bpt i="0" x="0">&lt;c0&gt;</bpt>animals<ept i="0">&lt;/c0&gt;</ept>配列のもつイテレータを使って、その配列の要素のすべてにわたって繰り返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Besides maintaining the order of the original dictionary literal, <bpt i="3" x="3">&lt;c3&gt;</bpt>Key<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<bpt i="5" x="5">&lt;w5&gt;</bpt>Pairs<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> also allows duplicates keys.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>元の辞書リテラルの順番を保守するのと並んで、<bpt i="3" x="3">&lt;c3&gt;</bpt>Key<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<bpt i="5" x="5">&lt;w5&gt;</bpt>Pairs<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>はまた重複キーを許可します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Bits are randomly distributed so that every value of <bpt i="1" x="1">&lt;c1&gt;</bpt>T<ept i="1">&lt;/c1&gt;</ept> is equally likely to be returned.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それらビットは無作為に分布します、それで<bpt i="1" x="1">&lt;c1&gt;</bpt>T<ept i="1">&lt;/c1&gt;</ept>の全ての値は等しく返される可能性をもちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Both <bpt i="2" x="2">&lt;c2&gt;</bpt>now(_:)<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>later(_:)<ept i="3">&lt;/c3&gt;</ept> accept a closure and call it, but <bpt i="4" x="4">&lt;c4&gt;</bpt>later(_:)<ept i="4">&lt;/c4&gt;</ept> waits a couple seconds before calling its closure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>now(_:)<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>later(_:)<ept i="3">&lt;/c3&gt;</ept>の両方ともクロージャを受け取りそれを呼び出します、しかし<bpt i="4" x="4">&lt;c4&gt;</bpt>later(_:)<ept i="4">&lt;/c4&gt;</ept>はそれのクロージャを呼び出す前に２秒ほど待ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Both kinds of availability specifier are also available in Objective-C.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>両方の種類の利用可能性指定子はまた、Objective-Cにおいても役立てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Both parameters must be valid indices of the collection and not equal to <bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>両方のパラメータは、このコレクションの有効なインデックスであり、<bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と等しくない必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Both parameters must be valid indices of the collection that are not equal to <bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>両方のパラメータは、このコレクションの有効なインデックスで、<bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と等しくない必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Bridging Between Set and NSSet</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>SetとNSSetの間のブリッジ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Bridging from <bpt i="0" x="0">&lt;c0&gt;</bpt>NSSet<ept i="0">&lt;/c0&gt;</ept> to <bpt i="1" x="1">&lt;c1&gt;</bpt>Set<ept i="1">&lt;/c1&gt;</ept> first calls the <bpt i="2" x="2">&lt;c2&gt;</bpt>copy(with:)<ept i="2">&lt;/c2&gt;</ept> method (<bpt i="3" x="3">&lt;c3&gt;</bpt>- copy<bpt i="4" x="4">&lt;w4&gt;</bpt>With<bpt i="5" x="5">&lt;w5&gt;</bpt>Zone:<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> in Objective-C) on the set to get an immutable copy and then performs additional Swift bookkeeping work that takes O(1) time.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NSSet<ept i="0">&lt;/c0&gt;</ept>から<bpt i="1" x="1">&lt;c1&gt;</bpt>Set<ept i="1">&lt;/c1&gt;</ept>へのブリッジは、最初に<bpt i="2" x="2">&lt;c2&gt;</bpt>copy(with:)<ept i="2">&lt;/c2&gt;</ept>メソッド（Objective-Cにおける<bpt i="3" x="3">&lt;c3&gt;</bpt>- copy<bpt i="4" x="4">&lt;w4&gt;</bpt>With<bpt i="5" x="5">&lt;w5&gt;</bpt>Zone:<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>）を集合上で呼び出すことで可変のコピーを取得して、それからO(1)時間をとる追加的なSwift簿記作業を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Bridging from <bpt i="0" x="0">&lt;c0&gt;</bpt>Set<ept i="0">&lt;/c0&gt;</ept> to <bpt i="1" x="1">&lt;c1&gt;</bpt>NSSet<ept i="1">&lt;/c1&gt;</ept> always takes O(1) time and space.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Set<ept i="0">&lt;/c0&gt;</ept>から<bpt i="1" x="1">&lt;c1&gt;</bpt>NSSet<ept i="1">&lt;/c1&gt;</ept>へのブリッジは、常にO(1)の時間と空間をとります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Buffer Implementation</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Buffer 実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>By default, a collection conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Sequence<ept i="0">&lt;/c0&gt;</ept> protocol by supplying <bpt i="1" x="1">&lt;c1&gt;</bpt>Indexing<bpt i="2" x="2">&lt;w2&gt;</bpt>Iterator<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> as its associated <bpt i="3" x="3">&lt;c3&gt;</bpt>Iterator<ept i="3">&lt;/c3&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>初期状態で、あるコレクションは<bpt i="0" x="0">&lt;c0&gt;</bpt>Sequence<ept i="0">&lt;/c0&gt;</ept>プロトコルに、<bpt i="1" x="1">&lt;c1&gt;</bpt>Indexing<bpt i="2" x="2">&lt;w2&gt;</bpt>Iterator<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>をそれの関連<bpt i="3" x="3">&lt;c3&gt;</bpt>Iterator<ept i="3">&lt;/c3&gt;</ept>型として提供することによって準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>By default, most types in the standard library are hashable, including strings, numeric and Boolean types, enumeration cases without associated values, and even sets themselves.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>初期状態で、標準ライブラリの中のほとんどの型はハッシュ化されています、文字列、数のおよびブールの型、関連値なしの列挙ケース節、そして集合それら自身さえも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>By default, the <bpt i="5" x="5">&lt;c5&gt;</bpt>custom<bpt i="6" x="6">&lt;w6&gt;</bpt>Mirror<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> implementation of any ancestors is ignored.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>初期状態では、あらゆる先祖の<bpt i="5" x="5">&lt;c5&gt;</bpt>custom<bpt i="6" x="6">&lt;w6&gt;</bpt>Mirror<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>実装は無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>C Interoperability</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>C互換性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>C and Objective-C Pointers</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>CおよびObjective-Cポインタ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calculates the result of shifting a value’s binary representation the specified number of digits to the right, masking the shift amount to the type’s bit width, and stores the result in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値のバイナリ表現を指定された桁数だけ右にシフトする結果を計算します、シフト量をその型のもつビット幅にマスクしています、そして結果を左手側の変数に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Call <bpt i="0" x="0">&lt;c0&gt;</bpt>body(p)<ept i="0">&lt;/c0&gt;</ept>, where <bpt i="1" x="1">&lt;c1&gt;</bpt>p<ept i="1">&lt;/c1&gt;</ept> is a pointer to the collection’s contiguous storage.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>body(p)<ept i="0">&lt;/c0&gt;</ept>を呼び出します、ここで<bpt i="1" x="1">&lt;c1&gt;</bpt>p<ept i="1">&lt;/c1&gt;</ept>はコレクションのもつ隣接ストレージへのポインタです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Call <bpt i="0" x="0">&lt;c0&gt;</bpt>body(p)<ept i="0">&lt;/c0&gt;</ept>, where <bpt i="1" x="1">&lt;c1&gt;</bpt>p<ept i="1">&lt;/c1&gt;</ept> is a pointer to the collection’s mutable contiguous storage.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>body(p)<ept i="0">&lt;/c0&gt;</ept>を呼び出します、ここで<bpt i="1" x="1">&lt;c1&gt;</bpt>p<ept i="1">&lt;/c1&gt;</ept>はコレクションのもつ可変の隣接ストレージへのポインタです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Call <bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept> with <bpt i="1" x="1">&lt;c1&gt;</bpt>Unsafe<bpt i="2" x="2">&lt;w2&gt;</bpt>Mutable<bpt i="3" x="3">&lt;w3&gt;</bpt>Pointer<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>s to the stored <bpt i="4" x="4">&lt;c4&gt;</bpt>Header<ept i="4">&lt;/c4&gt;</ept> and raw <bpt i="5" x="5">&lt;c5&gt;</bpt>Element<ept i="5">&lt;/c5&gt;</ept> storage.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>格納<bpt i="4" x="4">&lt;c4&gt;</bpt>Header<ept i="4">&lt;/c4&gt;</ept>および<bpt i="5" x="5">&lt;c5&gt;</bpt>Element<ept i="5">&lt;/c5&gt;</ept>生ストレージそれぞれへの<bpt i="1" x="1">&lt;c1&gt;</bpt>Unsafe<bpt i="2" x="2">&lt;w2&gt;</bpt>Mutable<bpt i="3" x="3">&lt;w3&gt;</bpt>Pointer<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>を使って<bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept>を呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Call <bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept> with an <bpt i="1" x="1">&lt;c1&gt;</bpt>Unsafe<bpt i="2" x="2">&lt;w2&gt;</bpt>Mutable<bpt i="3" x="3">&lt;w3&gt;</bpt>Pointer<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> to the <bpt i="4" x="4">&lt;c4&gt;</bpt>Element<ept i="4">&lt;/c4&gt;</ept> storage.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>ストレージへの<bpt i="1" x="1">&lt;c1&gt;</bpt>Unsafe<bpt i="2" x="2">&lt;w2&gt;</bpt>Mutable<bpt i="3" x="3">&lt;w3&gt;</bpt>Pointer<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>を使って<bpt i="4" x="4">&lt;c4&gt;</bpt>body<ept i="4">&lt;/c4&gt;</ept>を呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Call <bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept> with an <bpt i="1" x="1">&lt;c1&gt;</bpt>Unsafe<bpt i="2" x="2">&lt;w2&gt;</bpt>Mutable<bpt i="3" x="3">&lt;w3&gt;</bpt>Pointer<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> to the stored <bpt i="4" x="4">&lt;c4&gt;</bpt>Header<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この格納<bpt i="0" x="0">&lt;c0&gt;</bpt>Header<ept i="0">&lt;/c0&gt;</ept>への<bpt i="1" x="1">&lt;c1&gt;</bpt>Unsafe<bpt i="2" x="2">&lt;w2&gt;</bpt>Mutable<bpt i="3" x="3">&lt;w3&gt;</bpt>Pointer<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>を使って<bpt i="4" x="4">&lt;c4&gt;</bpt>body<ept i="4">&lt;/c4&gt;</ept>を呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Call <bpt i="0" x="0">&lt;c0&gt;</bpt>random<bpt i="1" x="1">&lt;w1&gt;</bpt>Element()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to select a random element from an array or another collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>random<bpt i="1" x="1">&lt;w1&gt;</bpt>Element()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を呼び出して、ある無作為な要素を配列または別のコレクションから選んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Call <bpt i="0" x="0">&lt;c0&gt;</bpt>random<bpt i="1" x="1">&lt;w1&gt;</bpt>Element(using:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to select a random element from an array or another collection when you are using a custom random number generator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>random<bpt i="1" x="1">&lt;w1&gt;</bpt>Element(using:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を呼び出して、あなたがあつらえの無作為数生成子を使っている場合に、ある無作為な要素を配列または別のコレクションから選んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Call <bpt i="2" x="2">&lt;c2&gt;</bpt>hasher<bpt i="3" x="3">&lt;w3&gt;</bpt>.combine(_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> with each of these components.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>hasher<bpt i="3" x="3">&lt;w3&gt;</bpt>.combine(_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>をそれら構成要素とともに呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Call the initializer that wraps a throwing expression when you need to serialize or memoize the result.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>スローする式をラップするイニシャライザを呼び出します、あなたが結果をシリアライズまたは記憶する必要がある時に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Callers should apply the same preconditions to the return value as they would to a range provided directly by the user.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>呼び出し側は、同じ前提条件を戻り値に適用すべきです、それらがユーザによって直接に提供される範囲にするように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calling <bpt i="0" x="0">&lt;c0&gt;</bpt>flat<bpt i="1" x="1">&lt;w1&gt;</bpt>Map(_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> on a sequence <bpt i="2" x="2">&lt;c2&gt;</bpt>s<ept i="2">&lt;/c2&gt;</ept> is equivalent to calling <bpt i="3" x="3">&lt;c3&gt;</bpt>s<bpt i="4" x="4">&lt;w4&gt;</bpt>.map(transform).joined()<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>flat<bpt i="1" x="1">&lt;w1&gt;</bpt>Map(_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をあるシーケンス<bpt i="2" x="2">&lt;c2&gt;</bpt>s<ept i="2">&lt;/c2&gt;</ept>上で呼び出すことは、<bpt i="3" x="3">&lt;c3&gt;</bpt>s<bpt i="4" x="4">&lt;w4&gt;</bpt>.map(transform).joined()<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>を呼び出すことに等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calling <bpt i="2" x="2">&lt;c2&gt;</bpt>swap<bpt i="3" x="3">&lt;w3&gt;</bpt>At(_:<bpt i="4" x="4">&lt;w4&gt;</bpt>_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> with the same index as both <bpt i="5" x="5">&lt;c5&gt;</bpt>i<ept i="5">&lt;/c5&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt>j<ept i="6">&lt;/c6&gt;</ept> has no effect.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>swap<bpt i="3" x="3">&lt;w3&gt;</bpt>At(_:<bpt i="4" x="4">&lt;w4&gt;</bpt>_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を<bpt i="5" x="5">&lt;c5&gt;</bpt>i<ept i="5">&lt;/c5&gt;</ept>と<bpt i="6" x="6">&lt;c6&gt;</bpt>j<ept i="6">&lt;/c6&gt;</ept>両方で同じインデックスで呼び出すことは、効果を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calling Objective-C APIs Asynchronously</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-C APIを非同期に呼び出す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calling the <bpt i="0" x="0">&lt;c0&gt;</bpt>get<bpt i="1" x="1">&lt;w1&gt;</bpt>Red(red:<bpt i="2" x="2">&lt;w2&gt;</bpt>green:<bpt i="3" x="3">&lt;w3&gt;</bpt>blue:<bpt i="4" x="4">&lt;w4&gt;</bpt>alpha:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method in Swift requires passing four in-out parameters.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>get<bpt i="1" x="1">&lt;w1&gt;</bpt>Red(red:<bpt i="2" x="2">&lt;w2&gt;</bpt>green:<bpt i="3" x="3">&lt;w3&gt;</bpt>blue:<bpt i="4" x="4">&lt;w4&gt;</bpt>alpha:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドをSwiftにおいて呼び出すことは、インアウトパラメータを渡すことを必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calling the <bpt i="0" x="0">&lt;c0&gt;</bpt>reserve<bpt i="1" x="1">&lt;w1&gt;</bpt>Capacity(_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method on a set with bridged storage triggers a copy to contiguous storage even if the existing storage has room to store <bpt i="2" x="2">&lt;c2&gt;</bpt>minimum<bpt i="3" x="3">&lt;w3&gt;</bpt>Capacity<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>reserve<bpt i="1" x="1">&lt;w1&gt;</bpt>Capacity(_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドをブリッジされたストレージを持つ集合で呼び出すことは、隣接ストレージへのコピーを引き起こします、たとえ既存のストレージに<bpt i="2" x="2">&lt;c2&gt;</bpt>minimum<bpt i="3" x="3">&lt;w3&gt;</bpt>Capacity<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>要素を格納する余地があるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calling the <bpt i="2" x="2">&lt;c2&gt;</bpt>remove<bpt i="3" x="3">&lt;w3&gt;</bpt>Subrange(_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method instead is preferred.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>remove<bpt i="3" x="3">&lt;w3&gt;</bpt>Subrange(_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドを代わりに呼ぶことが好まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calling the <bpt i="6" x="6">&lt;c6&gt;</bpt>insert(contents<bpt i="7" x="7">&lt;w7&gt;</bpt>Of:<bpt i="8" x="8">&lt;w8&gt;</bpt>at:)<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> method instead is preferred.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt>insert(contents<bpt i="7" x="7">&lt;w7&gt;</bpt>Of:<bpt i="8" x="8">&lt;w8&gt;</bpt>at:)<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>メソッドを代わりに呼ぶことが好まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calling the related <bpt i="0" x="0">&lt;c0&gt;</bpt>sorted()<ept i="0">&lt;/c0&gt;</ept> method is equivalent to calling this method and passing the less-than operator (<bpt i="1" x="1">&lt;c1&gt;</bpt>&lt;<ept i="1">&lt;/c1&gt;</ept>) as the predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>関連した<bpt i="0" x="0">&lt;c0&gt;</bpt>sorted()<ept i="0">&lt;/c0&gt;</ept>メソッドを呼び出すことは、このメソッドを呼び出して、より小さい演算子（<bpt i="1" x="1">&lt;c1&gt;</bpt>&lt;<ept i="1">&lt;/c1&gt;</ept>）を述部として渡すことと等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calling this method may invalidate all saved indices of this collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを呼び出すことは、このコレクションの全ての保存されたインデックスを無効にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calling this method may invalidate any existing indices for use with this collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを呼び出すことは、このコレクションで使うためのあらゆる既存のインデックスを無効にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calling this property directly is discouraged.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このプロパティを直接に呼び出すことは、推奨されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calls the given closure on each element in the sequence in the same order as a <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> loop.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定されたクロージャをそのシーケンスの各要素上で<bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>ループと同じ順番で呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Cast instances of the Objective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>id<ept i="0">&lt;/c0&gt;</ept> type to a specific Swift type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>id<ept i="0">&lt;/c0&gt;</ept>のインスタンスをSwift型にキャストします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Check Availability</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>利用可能性を調べる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Checking for Containment</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>制約を調べる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Choose a New Name and Declaration</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい名前と宣言を選択する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Clamping a Range</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲を固定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Class prefixes are optional in Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>クラス接頭辞は、スウィフトでは随意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Clean Up Your Code</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのコードを掃除する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Closed enumerations are useful for representing a finite set of states that you expect people to switch over using a switch statement.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>完結列挙は、人々がスイッチ文を使って切り替えることをあなたが期待する、ある有限な一揃いの状態を表すのに役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Closures you pass to APIs can be called synchronously (immediately) or asynchronously (sometime later).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがAPIに渡すクロージャは、同期的に（直ちに）または非同期的に（いつか後で）呼び出されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Coalescing Nil Values</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>nil値の合体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Cocoa Design Patterns</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Cocoaデザインパターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Collection Implementations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクション実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Collection Mutability</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの可変性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Collection Traversal</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクション横断</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Collections</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>さまざまなコレクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Collections that conform to <bpt i="0" x="0">&lt;c0&gt;</bpt>Mutable<bpt i="1" x="1">&lt;w1&gt;</bpt>Collection<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> gain the ability to change the value of their elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Mutable<bpt i="1" x="1">&lt;w1&gt;</bpt>Collection<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠するコレクションは、それらの要素の値を変更する能力を獲得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Combining Sets</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合を結合する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Command-click a Swift class name to see its generated header.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>スウィフトクラス名をコマンド-クリックして、その生成ヘッダを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Common protocol to which all actors conform.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それへと全てのアクターが準拠する共通プロコル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Comparing Buffers</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>バッファの比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Comparing Optional Values</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オプショナル値の比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Comparing Ranges</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲の比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Comparing Ranges as Collections</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲をコレクションとして比較する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Comparing Results</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値を比較する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Comparing Sequences</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスを比較する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Comparing Sets</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合を比較する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Comparing Values</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値の比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complex pointer types, such as <bpt i="5" x="5">&lt;c5&gt;</bpt>id *<ept i="5">&lt;/c5&gt;</ept>, must be explicitly annotated using these annotations.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>複雑なポインタ型、例えば<bpt i="5" x="5">&lt;c5&gt;</bpt>id *<ept i="5">&lt;/c5&gt;</ept>などは、これら注釈を使って、明示的に注釈を付けられなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: Amortized O(1) if the set does not wrap a bridged <bpt i="0" x="0">&lt;c0&gt;</bpt>NSSet<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：この集合がブリッジされた<bpt i="0" x="0">&lt;c0&gt;</bpt>NSSet<ept i="0">&lt;/c0&gt;</ept>をラップしないならば、均してO(1)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(1)</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(1) if <bpt i="0" x="0">&lt;c0&gt;</bpt>Index<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Random<bpt i="2" x="2">&lt;w2&gt;</bpt>Access<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>; O(<bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept>) otherwise.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：<bpt i="0" x="0">&lt;c0&gt;</bpt>Index<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Random<bpt i="2" x="2">&lt;w2&gt;</bpt>Access<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠するならばO(1)；そうでないならばO(<bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept>)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(1) if <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Random<bpt i="2" x="2">&lt;w2&gt;</bpt>Access<bpt i="3" x="3">&lt;w3&gt;</bpt>Collection<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>; O(<bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept>) otherwise.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：<bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Random<bpt i="2" x="2">&lt;w2&gt;</bpt>Access<bpt i="3" x="3">&lt;w3&gt;</bpt>Collection<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠するならばO(1)；そうでないならばO(<bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept>)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(1) if the collection conforms to <bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>; otherwise, O(<bpt i="3" x="3">&lt;e3&gt;</bpt>k<ept i="3">&lt;/e3&gt;</ept>), where <bpt i="4" x="4">&lt;e4&gt;</bpt>k<ept i="4">&lt;/e4&gt;</ept> is equal to <bpt i="5" x="5">&lt;c5&gt;</bpt>max<bpt i="6" x="6">&lt;w6&gt;</bpt>Length<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：コレクションが<bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠するならば、O(1)；そうでなければ、O(<bpt i="3" x="3">&lt;e3&gt;</bpt>k<ept i="3">&lt;/e3&gt;</ept>)、そこで<bpt i="4" x="4">&lt;e4&gt;</bpt>k<ept i="4">&lt;/e4&gt;</ept>は<bpt i="5" x="5">&lt;c5&gt;</bpt>max<bpt i="6" x="6">&lt;w6&gt;</bpt>Length<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>に相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(1) if the collection conforms to <bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>; otherwise, O(<bpt i="3" x="3">&lt;e3&gt;</bpt>k<ept i="3">&lt;/e3&gt;</ept>), where <bpt i="4" x="4">&lt;e4&gt;</bpt>k<ept i="4">&lt;/e4&gt;</ept> is the absolute value of <bpt i="5" x="5">&lt;c5&gt;</bpt>distance<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：もしコレクションが<bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠するならば、O(1)；そうでなければ、O(<bpt i="3" x="3">&lt;e3&gt;</bpt>k<ept i="3">&lt;/e3&gt;</ept>)、そこで<bpt i="4" x="4">&lt;e4&gt;</bpt>k<ept i="4">&lt;/e4&gt;</ept>は<bpt i="5" x="5">&lt;c5&gt;</bpt>distance<ept i="5">&lt;/c5&gt;</ept>の値の絶対値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(1) if the collection conforms to <bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>; otherwise, O(<bpt i="3" x="3">&lt;e3&gt;</bpt>k<ept i="3">&lt;/e3&gt;</ept>), where <bpt i="4" x="4">&lt;e4&gt;</bpt>k<ept i="4">&lt;/e4&gt;</ept> is the number of elements to drop from the beginning of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：コレクションが<bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠するならば、O(1)；そうでなければ、O(<bpt i="3" x="3">&lt;e3&gt;</bpt>k<ept i="3">&lt;/e3&gt;</ept>)、そこで<bpt i="4" x="4">&lt;e4&gt;</bpt>k<ept i="4">&lt;/e4&gt;</ept>はコレクションの冒頭から除外する要素の数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(1) if the collection conforms to <bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>; otherwise, O(<bpt i="3" x="3">&lt;e3&gt;</bpt>k<ept i="3">&lt;/e3&gt;</ept>), where <bpt i="4" x="4">&lt;e4&gt;</bpt>k<ept i="4">&lt;/e4&gt;</ept> is the number of elements to drop.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：コレクションが<bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠するならば、O(1)；そうでなければ、O(<bpt i="3" x="3">&lt;e3&gt;</bpt>k<ept i="3">&lt;/e3&gt;</ept>)、そこで<bpt i="4" x="4">&lt;e4&gt;</bpt>k<ept i="4">&lt;/e4&gt;</ept>は除外される要素の数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(1) if the collection conforms to <bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>; otherwise, O(<bpt i="3" x="3">&lt;e3&gt;</bpt>k<ept i="3">&lt;/e3&gt;</ept>), where <bpt i="4" x="4">&lt;e4&gt;</bpt>k<ept i="4">&lt;/e4&gt;</ept> is the number of elements to remove.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(1)、もしコレクションが<bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠するならば；そうでなければ、O(<bpt i="3" x="3">&lt;e3&gt;</bpt>k<ept i="3">&lt;/e3&gt;</ept>)、そこで<bpt i="4" x="4">&lt;e4&gt;</bpt>k<ept i="4">&lt;/e4&gt;</ept>は除去される要素の数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(1) if the collection conforms to <bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>; otherwise, O(<bpt i="3" x="3">&lt;e3&gt;</bpt>k<ept i="3">&lt;/e3&gt;</ept>), where <bpt i="4" x="4">&lt;e4&gt;</bpt>k<ept i="4">&lt;/e4&gt;</ept> is the number of elements to select from the beginning of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：コレクションが<bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠するならば、O(1)；そうでなければ、O(<bpt i="3" x="3">&lt;e3&gt;</bpt>k<ept i="3">&lt;/e3&gt;</ept>)、そこで<bpt i="4" x="4">&lt;e4&gt;</bpt>k<ept i="4">&lt;/e4&gt;</ept>はコレクションの冒頭から選択する要素の数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(1) if the collection conforms to <bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>; otherwise, O(<bpt i="3" x="3">&lt;e3&gt;</bpt>k<ept i="3">&lt;/e3&gt;</ept>), where <bpt i="4" x="4">&lt;e4&gt;</bpt>k<ept i="4">&lt;/e4&gt;</ept> is the resulting distance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(1)、もしコレクションが<bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠するならば；そうでなければ、O(<bpt i="3" x="3">&lt;e3&gt;</bpt>k<ept i="3">&lt;/e3&gt;</ept>)、そこで<bpt i="4" x="4">&lt;e4&gt;</bpt>k<ept i="4">&lt;/e4&gt;</ept>は結果の隔たりです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(1) if the collection conforms to <bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>; otherwise, O(<bpt i="3" x="3">&lt;e3&gt;</bpt>k<ept i="3">&lt;/e3&gt;</ept>), where <bpt i="4" x="4">&lt;e4&gt;</bpt>k<ept i="4">&lt;/e4&gt;</ept> is the specified number of elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(1)、もしコレクションが<bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠するならば；そうでなければ、O(<bpt i="3" x="3">&lt;e3&gt;</bpt>k<ept i="3">&lt;/e3&gt;</ept>)、そこで<bpt i="4" x="4">&lt;e4&gt;</bpt>k<ept i="4">&lt;/e4&gt;</ept>は指定した要素の数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(1) if the collection conforms to <bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>; otherwise, O(<bpt i="3" x="3">&lt;e3&gt;</bpt>n<ept i="3">&lt;/e3&gt;</ept>), where <bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept> is the length of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(1)、もしコレクションが<bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠するならば；そうでなければ、O(<bpt i="3" x="3">&lt;e3&gt;</bpt>n<ept i="3">&lt;/e3&gt;</ept>)、そこで<bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept>はコレクションの長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(1) on average, over many calls to <bpt i="0" x="0">&lt;c0&gt;</bpt>append(_:)<ept i="0">&lt;/c0&gt;</ept> on the same collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：同じコレクション上での<bpt i="0" x="0">&lt;c0&gt;</bpt>append(_:)<ept i="0">&lt;/c0&gt;</ept>への多くの呼び出しに対して、均してO(1)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(1), except if the sequence also conforms to <bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(1)、例外としてシーケンスが同様に<bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<ept i="0">&lt;/c0&gt;</ept>に準拠する場合を除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(1), with O(<bpt i="0" x="0">&lt;e0&gt;</bpt>k<ept i="0">&lt;/e0&gt;</ept>) deferred to each iteration of the result, where <bpt i="1" x="1">&lt;e1&gt;</bpt>k<ept i="1">&lt;/e1&gt;</ept> is the number of elements to drop from the beginning of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(1)、結果の各反復に対してO(<bpt i="0" x="0">&lt;e0&gt;</bpt>k<ept i="0">&lt;/e0&gt;</ept>)延期されて、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>k<ept i="1">&lt;/e1&gt;</ept>はシーケンスの冒頭から除かれる要素の数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(1).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(1)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;c0&gt;</bpt>separator<bpt i="1" x="1">&lt;w1&gt;</bpt>.count<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;c0&gt;</bpt>separator<bpt i="1" x="1">&lt;w1&gt;</bpt>.count<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>k<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>k<ept i="1">&lt;/e1&gt;</ept> is the length of the result.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>k<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>k<ept i="1">&lt;/e1&gt;</ept>は結果の長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>k<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>k<ept i="1">&lt;/e1&gt;</ept> is the number of elements to drop from the beginning of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>k<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>k<ept i="1">&lt;/e1&gt;</ept>はシーケンスの冒頭から除かれる要素の数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>k<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>k<ept i="1">&lt;/e1&gt;</ept> is the specified number of elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>k<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>k<ept i="1">&lt;/e1&gt;</ept>は指定された要素の数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept> + <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>), where <bpt i="2" x="2">&lt;e2&gt;</bpt>m<ept i="2">&lt;/e2&gt;</ept> is the length of this sequence and <bpt i="3" x="3">&lt;e3&gt;</bpt>n<ept i="3">&lt;/e3&gt;</ept> is the length of the result.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept> + <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>)、ここで<bpt i="2" x="2">&lt;e2&gt;</bpt>m<ept i="2">&lt;/e2&gt;</ept>はこのシーケンスの長さで、<bpt i="3" x="3">&lt;e3&gt;</bpt>n<ept i="3">&lt;/e3&gt;</ept>は結果の長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept> + <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>), where <bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept> is the length of this sequence and <bpt i="3" x="3">&lt;e3&gt;</bpt>m<ept i="3">&lt;/e3&gt;</ept> is the length of the result.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept> + <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>)、ここで<bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept>はこのシーケンスの長さで、<bpt i="3" x="3">&lt;e3&gt;</bpt>m<ept i="3">&lt;/e3&gt;</ept>は結果の長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept> is the length of <bpt i="2" x="2">&lt;c2&gt;</bpt>new<bpt i="3" x="3">&lt;w3&gt;</bpt>Elements<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>new<bpt i="3" x="3">&lt;w3&gt;</bpt>Elements<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept> is the length of the right-hand-side argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept>は右手側の引数の長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept> is the lesser of the length of the sequence and the length of <bpt i="2" x="2">&lt;c2&gt;</bpt>other<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept>はシーケンスの長さと<bpt i="2" x="2">&lt;c2&gt;</bpt>other<ept i="2">&lt;/c2&gt;</ept>の長さのより短い方です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept> is the lesser of the length of the sequence and the length of <bpt i="2" x="2">&lt;c2&gt;</bpt>possible<bpt i="3" x="3">&lt;w3&gt;</bpt>Prefix<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept>はシーケスの長さと<bpt i="2" x="2">&lt;c2&gt;</bpt>possible<bpt i="3" x="3">&lt;w3&gt;</bpt>Prefix<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の長さのより短い方です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept> + <bpt i="1" x="1">&lt;e1&gt;</bpt>c<ept i="1">&lt;/e1&gt;</ept>), where <bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept> is <bpt i="3" x="3">&lt;c3&gt;</bpt>self<bpt i="4" x="4">&lt;w4&gt;</bpt>.count<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> and <bpt i="5" x="5">&lt;e5&gt;</bpt>c<ept i="5">&lt;/e5&gt;</ept> is the number of changes contained by the parameter.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept> + <bpt i="1" x="1">&lt;e1&gt;</bpt>c<ept i="1">&lt;/e1&gt;</ept>)、ここで<bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>self<bpt i="4" x="4">&lt;w4&gt;</bpt>.count<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>です、そして<bpt i="5" x="5">&lt;e5&gt;</bpt>c<ept i="5">&lt;/e5&gt;</ept>はパラメータによって含まれる変更の数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept> + <bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept>), where <bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept> is length of this collection and <bpt i="3" x="3">&lt;e3&gt;</bpt>m<ept i="3">&lt;/e3&gt;</ept> is the length of <bpt i="4" x="4">&lt;c4&gt;</bpt>new<bpt i="5" x="5">&lt;w5&gt;</bpt>Elements<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept> + <bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept>)、ここで<bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept>は配列の長さです、そして<bpt i="3" x="3">&lt;e3&gt;</bpt>m<ept i="3">&lt;/e3&gt;</ept>は<bpt i="4" x="4">&lt;c4&gt;</bpt>new<bpt i="5" x="5">&lt;w5&gt;</bpt>Elements<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept> log <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>), where <bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept> is the length of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept> log <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>)、ここで<bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept>はコレクションの長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept> log <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>), where <bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept> is the length of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept> log <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>)、ここで<bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept>はシーケンスの長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the length of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>はコレクションの長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the length of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>はシーケンスの長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the number of elements in the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>はコレクションの中の要素数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the ratio between unfiltered and filtered collection counts.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>はコレクションのフィルタされないものとフィルタされたもの数の比率です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: Worst case performance is O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept> * <bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept>), where <bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept> is the count of this collection and <bpt i="3" x="3">&lt;e3&gt;</bpt>m<ept i="3">&lt;/e3&gt;</ept> is <bpt i="4" x="4">&lt;c4&gt;</bpt>other<bpt i="5" x="5">&lt;w5&gt;</bpt>.count<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：最悪の場合の性能は、O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept> * <bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept>)です、ここで<bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept>はこのコレクションの総数です、そして<bpt i="3" x="3">&lt;e3&gt;</bpt>m<ept i="3">&lt;/e3&gt;</ept>は<bpt i="4" x="4">&lt;c4&gt;</bpt>other<bpt i="5" x="5">&lt;w5&gt;</bpt>.count<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforming Types</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これらの型が準拠</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforming to the MutableCollection Protocol</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>MutableCollectionプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforming to the Numeric Protocol</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Numericプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforming to the RandomAccessCollection Protocol</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>RandomAccessCollectionプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforming to the RandomNumberGenerator Protocol</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>RandomNumberGeneratorプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforming to the RangeReplaceableCollection Protocol</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>RangeReplaceableCollectionプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforming to the Sequence Protocol</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Sequenceプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforming to the SetAlgebra Protocol</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>SetAlgebraプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforming to the SignedNumeric Protocol</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>SignedNumericプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms To</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次に準拠</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Bidirectional<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>Base<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>.<ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>Index<ept i="5">&lt;/c5&gt;</ept> conforms to <bpt i="6" x="6">&lt;c6&gt;</bpt>Hashable<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Bidirectional<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="3" x="3">&lt;c3&gt;</bpt>Base<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>.<ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>Index<ept i="5">&lt;/c5&gt;</ept>が<bpt i="6" x="6">&lt;c6&gt;</bpt>Hashable<ept i="6">&lt;/c6&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Collection<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Base<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Index<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Hashable<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Collection<ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="2" x="2">&lt;c2&gt;</bpt>Base<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Index<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Hashable<ept i="5">&lt;/c5&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Lazy<bpt i="2" x="2">&lt;w2&gt;</bpt>Sequence<bpt i="3" x="3">&lt;w3&gt;</bpt>Protocol<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Lazy<bpt i="2" x="2">&lt;w2&gt;</bpt>Sequence<bpt i="3" x="3">&lt;w3&gt;</bpt>Protocol<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Mutable<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Mutable<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Range<bpt i="2" x="2">&lt;w2&gt;</bpt>Replaceable<bpt i="3" x="3">&lt;w3&gt;</bpt>Collection<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Range<bpt i="2" x="2">&lt;w2&gt;</bpt>Replaceable<bpt i="3" x="3">&lt;w3&gt;</bpt>Collection<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Strideable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Bound<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Stride<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Signed<bpt i="6" x="6">&lt;w6&gt;</bpt>Integer<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Strideable<ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="2" x="2">&lt;c2&gt;</bpt>Bound<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Stride<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Signed<bpt i="6" x="6">&lt;w6&gt;</bpt>Integer<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>である時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>に準拠している時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>UInt8<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>UInt8<ept i="1">&lt;/c1&gt;</ept>である場合に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>Float<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Scalar<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Float<ept i="1">&lt;/c1&gt;</ept>である時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Success<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Failure<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Success<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="2" x="2">&lt;c2&gt;</bpt>Failure<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Success<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Failure<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Hashable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Success<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="2" x="2">&lt;c2&gt;</bpt>Failure<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Hashable<ept i="3">&lt;/c3&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Value<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Mutable<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Value<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Mutable<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<bpt i="2" x="2">&lt;w2&gt;</bpt>With<bpt i="3" x="3">&lt;w3&gt;</bpt>Configuration<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<bpt i="2" x="2">&lt;w2&gt;</bpt>With<bpt i="3" x="3">&lt;w3&gt;</bpt>Configuration<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠している時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<bpt i="2" x="2">&lt;w2&gt;</bpt>With<bpt i="3" x="3">&lt;w3&gt;</bpt>Configuration<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<bpt i="2" x="2">&lt;w2&gt;</bpt>With<bpt i="3" x="3">&lt;w3&gt;</bpt>Configuration<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠している時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Gesture<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Gesture<ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>View<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>View<ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Consider an app that requires a user to log into an account.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ユーザがアカウントにログインするように要求するアプリを考えください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Contains a buffer object, and provides access to an instance of <bpt i="0" x="0">&lt;c0&gt;</bpt>Header<ept i="0">&lt;/c0&gt;</ept> and contiguous storage for an arbitrary number of <bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept> instances stored in that buffer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>バッファオブジェクトを収容します、そして<bpt i="0" x="0">&lt;c0&gt;</bpt>Header<ept i="0">&lt;/c0&gt;</ept>のインスタンスへのアクセスおよびそのバッファに格納される随意の数の<bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept>インスタンスの隣接保管を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conversely, the comparison returns <bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept> if only one of the arguments is <bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept> or if the two arguments wrap values that are not equal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>反対に、この比較が<bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>を返すのは、引数のうち１つだけが<bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept>であるか、２つの引数が等しくない値をラップする場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Convert the Throwing Expression to a Result</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>スローする式を結果へと変換する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Convert this executor value to the optimized form of borrowed executor references.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このエグゼキュータ値を、最適化された形式の借用エグセキュータ参照へと変換します。。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Converting Ranges</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲を変換する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Converting a Result to a Throwing Expression</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果をスローする式へ変換する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Converting a Throwing Expression to a Result</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>スローする式を結果へ変換する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Converts a typed <bpt i="0" x="0">&lt;c0&gt;</bpt>Unsafe<bpt i="1" x="1">&lt;w1&gt;</bpt>Mutable<bpt i="2" x="2">&lt;w2&gt;</bpt>Pointer<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to an opaque C pointer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型付けされた<bpt i="0" x="0">&lt;c0&gt;</bpt>Unsafe<bpt i="1" x="1">&lt;w1&gt;</bpt>Mutable<bpt i="2" x="2">&lt;w2&gt;</bpt>Pointer<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を不透明Cポインタへと変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Converts a typed <bpt i="0" x="0">&lt;c0&gt;</bpt>Unsafe<bpt i="1" x="1">&lt;w1&gt;</bpt>Pointer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to an opaque C pointer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型付けされた<bpt i="0" x="0">&lt;c0&gt;</bpt>Unsafe<bpt i="1" x="1">&lt;w1&gt;</bpt>Pointer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を不透明Cポインタへと変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Copying an iterator is safe, but advancing one copy of an iterator by calling its <bpt i="2" x="2">&lt;c2&gt;</bpt>next()<ept i="2">&lt;/c2&gt;</ept> method may invalidate other copies of that iterator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるイテレータをコピーすることは安全です、しかしあるインスタンスの１つのコピーをそれのメソッド<bpt i="2" x="2">&lt;c2&gt;</bpt>next()<ept i="2">&lt;/c2&gt;</ept>メソッドを呼び出すことによって前に進めることは、そのイテレータの他のコピーを無価値にするでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Create a Swift class for your corresponding Objective-C .m and .h files by choosing File &gt; New &gt; File &gt; (iOS, watchOS, tvOS, or macOS) &gt; Source &gt; Swift File.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるSwiftクラスをあなたの対応するObjective-C .m と .h ファイルに対して、「File &gt; New &gt; File &gt; (iOS、watchOS、tvOS、またはmacOS) &gt; Source &gt; Swift File」を選択することによって作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Create a new instance of the most-derived class, calling <bpt i="0" x="0">&lt;c0&gt;</bpt>factory<ept i="0">&lt;/c0&gt;</ept> on the partially-constructed object to generate an initial <bpt i="1" x="1">&lt;c1&gt;</bpt>Header<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最も派生したクラスの新しいインスンタスを作成します、部分的に組み立てられたオブジェクト上で<bpt i="0" x="0">&lt;c0&gt;</bpt>factory<ept i="0">&lt;/c0&gt;</ept>を呼び出して初期<bpt i="1" x="1">&lt;c1&gt;</bpt>Value<ept i="1">&lt;/c1&gt;</ept>を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Create a new range using the half-open range operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>..&lt;<ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい範囲を半開範囲演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>..&lt;<ept i="0">&lt;/c0&gt;</ept>）を使って作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Create with new storage containing an initial <bpt i="0" x="0">&lt;c0&gt;</bpt>Header<ept i="0">&lt;/c0&gt;</ept> and space for at least <bpt i="1" x="1">&lt;c1&gt;</bpt>minimum<bpt i="2" x="2">&lt;w2&gt;</bpt>Capacity<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> <bpt i="3" x="3">&lt;c3&gt;</bpt>element<ept i="3">&lt;/c3&gt;</ept>s.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある初期<bpt i="0" x="0">&lt;c0&gt;</bpt>Header<ept i="0">&lt;/c0&gt;</ept>と少なくとも<bpt i="1" x="1">&lt;c1&gt;</bpt>minimum<bpt i="2" x="2">&lt;w2&gt;</bpt>Capacity<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> <bpt i="3" x="3">&lt;c3&gt;</bpt>element<ept i="3">&lt;/c3&gt;</ept>に対する空間を格納している新しいストレージを使って作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a 64-bit integer from another integer wrapped in a data value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある64ビット整数をデータ値の中にラップされる別の整数から作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a collection containing the specified number of the given element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された数の与えられた要素を含んでいるコレクションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a mirror representing the given subject using a dictionary literal for the structure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた主題を表すミラーを、その構造体のための辞書リテラルを使って作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a mirror representing the given subject with a specified structure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた主題を表すミラーを指定の構造体で作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a mirror representing the given subject with unlabeled children.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた主題を表すミラーを幾つかのラベルを付けられない子で作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a mirror that reflects on the given instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたインスタンスを反映するミラーを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new <bpt i="0" x="0">&lt;c0&gt;</bpt>Key<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<bpt i="2" x="2">&lt;w2&gt;</bpt>Pairs<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance from the given dictionary literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Key<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<bpt i="2" x="2">&lt;w2&gt;</bpt>Pairs<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを与えられた辞書リテラルから作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new collection by concatenating the elements of a collection and a sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるコレクションとあるシーケンスの要素を連結することによって新しいコレクションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new collection by concatenating the elements of a sequence and a collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンスとあるコレクションの要素を連結することによって新しいコレクションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new collection by concatenating the elements of two collections.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つのコレクションの要素を連結することによって新しいコレクションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new collection containing the specified number of a single, repeated value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された数の、ある単一の値の繰り返しを含んでいる新しいコレクションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new index into a reversed collection for the position before the specified index.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>逆にされたコレクションへのある新しいインデックスを、指定されたインデックスの前の位置に対して、作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance by decoding from the given decoder, when the type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>Bool<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいインスタンスをこの与えられたデコーダからデコードすることによって作成します、型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Bool<ept i="2">&lt;/c2&gt;</ept>である場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance by decoding from the given decoder, when the type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>Double<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいインスタンスをこの与えられたデコーダからデコードすることによって作成します、型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Double<ept i="2">&lt;/c2&gt;</ept>である場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance by decoding from the given decoder, when the type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>Float<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいインスタンスをこの与えられたデコーダからデコードすることによって作成します、型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Float<ept i="2">&lt;/c2&gt;</ept>である場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance by decoding from the given decoder, when the type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>Int16<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいインスタンスをこの与えられたデコーダからデコードすることによって作成します、型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Int16<ept i="2">&lt;/c2&gt;</ept>である場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance by decoding from the given decoder, when the type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>Int32<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいインスタンスをこの与えられたデコーダからデコードすることによって作成します、型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Int32<ept i="2">&lt;/c2&gt;</ept>である場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance by decoding from the given decoder, when the type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>Int64<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいインスタンスをこの与えられたデコーダからデコードすることによって作成します、型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Int64<ept i="2">&lt;/c2&gt;</ept>である場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance by decoding from the given decoder, when the type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>Int8<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいインスタンスをこの与えられたデコーダからデコードすることによって作成します、型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Int8<ept i="2">&lt;/c2&gt;</ept>である場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance by decoding from the given decoder, when the type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいインスタンスをこの与えられたデコーダからデコードすることによって作成します、型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>である場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance by decoding from the given decoder, when the type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいインスタンスをこの与えられたデコーダからデコードすることによって作成します、型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>である場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance by decoding from the given decoder, when the type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>UInt16<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいインスタンスをこの与えられたデコーダからデコードすることによって作成します、型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>UInt16<ept i="2">&lt;/c2&gt;</ept>である場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance by decoding from the given decoder, when the type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>UInt32<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいインスタンスをこの与えられたデコーダからデコードすることによって作成します、型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>UInt32<ept i="2">&lt;/c2&gt;</ept>である場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance by decoding from the given decoder, when the type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>UInt64<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいインスタンスをこの与えられたデコーダからデコードすることによって作成します、型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>UInt64<ept i="2">&lt;/c2&gt;</ept>である場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance by decoding from the given decoder, when the type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>UInt8<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいインスタンスをこの与えられたデコーダからデコードすることによって作成します、型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>UInt8<ept i="2">&lt;/c2&gt;</ept>である場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance by decoding from the given decoder, when the type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>UInt<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいインスタンスをこの与えられたデコーダからデコードすることによって作成します、型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>UInt<ept i="2">&lt;/c2&gt;</ept>である場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance by decoding from the given decoder.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたデコーダからデコードすることで新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance from the bit pattern of the given instance by truncating or sign-extending if needed to fit this type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>もしこの型に適合するのに必要ならば切り詰めるか符号拡張によって、指定インスタンスのビットパターンから新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance from the given integer, if it can be represented exactly.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた整数から新しいインスタンスを作成します、もしそれが正確に表現できるならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance from the given integer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた整数から新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance of a collection containing the elements of a sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンスの要素を含んでいるあるコレクションの新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance with the given container.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたコンテナで新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance with the representable value that’s closest to the given integer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた整数に最も近い表現可能な値を使って新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance with the same memory representation as the given value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた値と同じメモリ表現で新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance with the specified raw value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された生の値を持つ新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new integer value from the given string and radix.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた文字列と基数から新しい整数値を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new integer value from the given string.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた文字列から新しい整数値を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new option set from the given raw value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた生の値から新しいオプションセットを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new result by evaluating a throwing closure, capturing the returned value as a success, or any thrown error as a failure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい結果を、あるスローするクロージャを評価することによって作成します、返される値をある成功としてキャプチャしています、または何からのスローされたエラーをある失敗として。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new set by decoding from the given decoder.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたデコーダからデコードすることで新しい集合を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new set from a finite sequence of items.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>いくつかの要素からなる有限のシーケンスから集合を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new value equal to zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ゼロに等しい新しい値を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new vector by decoding scalars from the given decoder.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある新しいベクターをこの与えられたデコーダからスカラーをデコードすることによって作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new vector from the given elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある新しいベクターをこの与えられた要素それらから作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new vector from the given vector of floating-point values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある新しいベクターをこの与えられた浮動小数点値のベクターから作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new vector from the given vector of integers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある新しいベクターを整数からなるこの与えられたベクターから作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new vector from the given vector, clamping the values of the given vector’s elements if necessary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある新しいベクターをこの与えられたベクターから作成します、与えられたベクターのもつ要素の値を必要に応じてクランプします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new vector from the given vector, rounding the given vector’s of elements using the specified rounding rule.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある新しいベクターをこの与えられたベクターから作成します、与えられたベクターのもつ要素を指定された丸め規則を使って丸めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new vector from the given vector, truncating the bit patterns of the given vector’s elements if necessary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある新しいベクターをこの与えられたベクターから作成します、与えられたベクターのもつ要素のビットパターンを必要に応じて切り詰めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new vector from two half-length vectors.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある新しいベクターは２つの半分長のベクターから作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new, empty collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい、空のコレクションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a publisher that delivers the specified output and finishes normally.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された出力を配達して通常に終了するパブリッシャーを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a publisher that delivers the specified result.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された結果を配達するあるパブリッシャーを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a publisher that immediately terminates upon subscription with the given failure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この与えられた失敗で定期購読上で直ぐに終了するパブリッシャーを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a publisher to emit the value of the optional, or to finish immediately if the optional doesn’t have a value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるパブリッシャーを作成してオプショナルの値を発布します、またはそのオプショナルが値を持たないならば直ちに終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a sequence that presents the elements of <bpt i="0" x="0">&lt;c0&gt;</bpt>base<ept i="0">&lt;/c0&gt;</ept> sequences concatenated using <bpt i="1" x="1">&lt;c1&gt;</bpt>separator<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンス、それは<bpt i="0" x="0">&lt;c0&gt;</bpt>base<ept i="0">&lt;/c0&gt;</ept>シーケンスたちの要素を、与えられた<bpt i="1" x="1">&lt;c1&gt;</bpt>separator<ept i="1">&lt;/c1&gt;</ept>を使って連結して提示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a set containing the elements of the given array literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた配列リテラルの要素を含んでいる集合を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a vector from the given sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるベクターをこの与えられたシーケンスから作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a vector from the specified elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるベクターをこの指定された要素それらから作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a vector with zero in all lanes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるベクターを全レーンにおいてゼロで作成します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an <bpt i="0" x="0">&lt;c0&gt;</bpt>Opaque<bpt i="1" x="1">&lt;w1&gt;</bpt>Pointer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> from a given address in memory.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>メモリ中の与えられたアドレスから<bpt i="0" x="0">&lt;c0&gt;</bpt>Opaque<bpt i="1" x="1">&lt;w1&gt;</bpt>Pointer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an empty option set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>空のオプションセットを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an empty set with preallocated space for at least the specified number of elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>空の集合を、あらかじめアロケートされたスペースで少なくとも指定された要素数に対して作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an empty set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>空の集合を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an instance equivalent to the given <bpt i="0" x="0">&lt;c0&gt;</bpt>Closed<bpt i="1" x="1">&lt;w1&gt;</bpt>Range<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた<bpt i="0" x="0">&lt;c0&gt;</bpt>Closed<bpt i="1" x="1">&lt;w1&gt;</bpt>Range<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と等しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an instance initialized to the specified integer value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された整数値に初期化されるインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an instance initialized with <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>で初期化されるインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an instance that stores the given value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた値を格納するインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an instance that uniquely identifies the given class instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたクラスインスタンスを固有に識別するインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an instance that uniquely identifies the given metatype.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたメタタイプを固有に識別するインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an instance whose iterator is a copy of <bpt i="0" x="0">&lt;c0&gt;</bpt>base<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それのイテレータが<bpt i="0" x="0">&lt;c0&gt;</bpt>base<ept i="0">&lt;/c0&gt;</ept>のコピーであるインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an instance with the given bounds.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた境界を使ってインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an integer from its big-endian representation, changing the byte order if necessary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それのビッグエンディアン表現から整数を作成します、必要ならばバイト順を変更します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an integer from its little-endian representation, changing the byte order if necessary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それのリトルエンディアン表現から整数を作成します、必要ならばバイト順を変更します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an integer from the given floating-point value, if it can be represented exactly.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた浮動小数点値から整数を作成します、もしそれが正確に表現可能ならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an integer from the given floating-point value, rounding toward zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた浮動小数点値から整数を作成します、ゼロへの丸めを行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an iterator that presents the elements of the sequences traversed by <bpt i="0" x="0">&lt;c0&gt;</bpt>base<ept i="0">&lt;/c0&gt;</ept>, concatenated using <bpt i="1" x="1">&lt;c1&gt;</bpt>separator<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるイテレータ、それは<bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept>によって辿っていかれるいくらかのシーケンスに属するいくらかの要素を、<bpt i="1" x="1">&lt;c1&gt;</bpt>separator<ept i="1">&lt;/c1&gt;</ept>を使って連結して提示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creating a Buffer</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>バッファの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creating a New Collection</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいコレクションの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creating a Nil Value</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>nil値の作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creating a Range</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲を作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creating a Result Publisher</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果パブリッシャーを作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creating a Set</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合の作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creating a Value</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値の作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creating an Iterator</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>イテレータを作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creating an Optional Publisher</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オプショナルパブリッシャーを作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creating an Optional Value</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オプショナル値の作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creating and iterating over a <bpt i="0" x="0">&lt;c0&gt;</bpt>Countdown<ept i="0">&lt;/c0&gt;</ept> sequence uses a <bpt i="1" x="1">&lt;c1&gt;</bpt>Countdown<bpt i="2" x="2">&lt;w2&gt;</bpt>Iterator<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> to handle the iteration.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Countdown<ept i="0">&lt;/c0&gt;</ept>シーケンス全体にわたっての作成や反復は、その反復を取り扱う<bpt i="1" x="1">&lt;c1&gt;</bpt>Countdown<bpt i="2" x="2">&lt;w2&gt;</bpt>Iterator<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Customizing C APIs</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>C APIのカスタマイズ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Customizing Objective-C APIs</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-C APIをカスタマイズする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Customizing Your C Code for Swift</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのCコードをSwift用にカスタマイズする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Customizing Your Type's Reflection</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたの型のリフレクションのカスタマイズ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Data Flow and Control Flow</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>データの流れと制御の流れ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Debugging and Reflection</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>デバッグとリフレクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Declaration</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Declare Closed Enumerations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>完結列挙を宣言する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Declare Option Sets</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オプションセットを宣言する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Declare Simple Enumerations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>単純な列挙を宣言する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Declare Typed Enumerations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型付き列挙を宣言する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Declare Typed Extensible Enumerations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型付き拡張可能列挙を宣言する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Declare a <bpt i="2" x="2">&lt;c2&gt;</bpt>next()<ept i="2">&lt;/c2&gt;</ept> method that advances one step in the related sequence and returns the current element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>next()<ept i="2">&lt;/c2&gt;</ept>メソッドを宣言してください、それは関連シーケンスにおいて一歩前へ進みます、そして現在の要素を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Declare additional preconfigured option set values as static properties initialized with an array literal containing other option values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>追加のあらかじめ構成されるオプションセット値を、他のオプション値を含んでいる配列リテラルで初期化される静的プロパティとして宣言してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Declare simple macros as global constants, and translate complex macros into functions.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>単純なマクロをグローバルな定数として宣言してください、そして複雑なマクロを関数へと翻訳してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Declaring Publisher Topography</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>パブリッシャー地勢を宣言する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Declaring Publisher Topology</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>パブリッシャー地勢を宣言する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Decoders should provide types conforming to <bpt i="0" x="0">&lt;c0&gt;</bpt>Unkeyed<bpt i="1" x="1">&lt;w1&gt;</bpt>Decoding<bpt i="2" x="2">&lt;w2&gt;</bpt>Container<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> for their format.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それらデコーダーは、それらの形式に対して<bpt i="0" x="0">&lt;c0&gt;</bpt>Unkeyed<bpt i="1" x="1">&lt;w1&gt;</bpt>Decoding<bpt i="2" x="2">&lt;w2&gt;</bpt>Container<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠する型を提供すべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Decodes a null value for the given key.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたキーに対してnull値をデコードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Decodes a value of the given type for the given key, if present.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された型の値を与えられたキーに対してデコードします、もし存在するならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Decodes a value of the given type for the given key.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された型の値を与えられたキーに対してデコードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Decoding Containers</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>デコーディングコンテナ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Decoding a Value</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値をデコードする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Default Implementations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Default Literal Types</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時のリテラル型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Denote instance (<bpt i="0" x="0">&lt;c0&gt;</bpt>-<ept i="0">&lt;/c0&gt;</ept>) and class (<bpt i="1" x="1">&lt;c1&gt;</bpt>+<ept i="1">&lt;/c1&gt;</ept>) methods with <bpt i="2" x="2">&lt;c2&gt;</bpt>func<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>class func<ept i="3">&lt;/c3&gt;</ept>, respectively.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インスタンス（<bpt i="0" x="0">&lt;c0&gt;</bpt>-<ept i="0">&lt;/c0&gt;</ept>）およびクラス（<bpt i="1" x="1">&lt;c1&gt;</bpt>+<ept i="1">&lt;/c1&gt;</ept>）メソッドであることを、それぞれ<bpt i="2" x="2">&lt;c2&gt;</bpt>func<ept i="2">&lt;/c2&gt;</ept>および<bpt i="3" x="3">&lt;c3&gt;</bpt>class func<ept i="3">&lt;/c3&gt;</ept>で示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Depending on the type, it may make sense to allocate more or less storage than requested or to take no action at all.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型によって、要請されたよりも多くまたは少なく割り当てるまたは全く行動を起こさないことが道理にかなっているかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Depending on the type, it may make sense to allocate more or less storage than requested, or to take no action at all.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型によって、要請されたよりも多くまたは少なく割り当てること、または全く行動を起こさないことが道理にかなっているかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Deprecated</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>非推奨</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Describing a Range</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲を記述する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Describing a Set</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるSetの記述</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Designating Nullability in Objective-C APIs</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-C APIにおいてヌル可能性を指定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Different keyed containers from the same <bpt i="0" x="0">&lt;c0&gt;</bpt>Decoder<ept i="0">&lt;/c0&gt;</ept> may return different keys here; it is possible to encode with multiple key types which are not convertible to one another.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同じ<bpt i="0" x="0">&lt;c0&gt;</bpt>Decoder<ept i="0">&lt;/c0&gt;</ept>からの異なるキー付けコンテナは、異なるキーをここで返すかもしれません；互いに変換できないところの複数のキー型を使ってエンコードすることは可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Different keyed containers from the same decoder may return different keys here, because it is possible to encode with multiple key types which are not convertible to one another.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同じデコーダからの異なるキー付けコンテナは、異なるキーをここで返すかもしれません、なぜなら互いに変換できないところの複数のキー型を使ってエンコードすることは可能だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Digest Implementations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要約実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Discussion</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>解説</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Divides the first value by the second and stores the quotient in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最初の値を２番目の値で除算して、商を左手側の変数に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Divides the first value by the second and stores the remainder in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最初の値を２番目の値で除算して、余りを左手側の変数に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Dividing by zero is not an error when using this method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ゼロによる除算は、このメソッドを使う場合はエラーではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Do not call this initializer directly.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザを直接に呼ばないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Do not declare new conformances to this protocol; they will not work as expected.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい準拠事項をこのプロトコルに宣言しないでください；
それは期待するようには機能しないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Do not rely on a previously stored index value after altering a collection with any operation that can change its length.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるコレクションをそれの長さを変える何らかの演算で手直し後に、以前に格納されたインデックス値を当てにしないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Do not save hash values to use during a future execution.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>将来の実行の間に使うためにハッシュ値を保存しないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Doing so crashes your app:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そうすることはあなたのアプリをクラッシュさせます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Doing so may become a compile-time error in the future.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そうすることは、コンパイル時エラーに将来はなるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Don't Put Critical Code in a Closure That Might Not Be Called</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>呼び出されないかもしれないクロージャの中に重大なコードを置かないでください</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Don't Spread State Across Multiple Variables</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>状態を複数の変数に渡って広げないでください</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Don't Write Code That Makes a One-Time Change in a Closure That's Called Multiple Times</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>一回限りの変更をするコードを複数回呼び出されるクロージャの中に書かないでください</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Don't use the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_CLOSED<bpt i="2" x="2">&lt;w2&gt;</bpt>_ENUM<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> macro if:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_CLOSED<bpt i="2" x="2">&lt;w2&gt;</bpt>_ENUM<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使わないでください、もし：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Don’t actually use <bpt i="0" x="0">&lt;c0&gt;</bpt>map<ept i="0">&lt;/c0&gt;</ept> for this purpose, however, because it creates and discards the resulting array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>しかしながら、実際に<bpt i="0" x="0">&lt;c0&gt;</bpt>map<ept i="0">&lt;/c0&gt;</ept>をこの目的のために使わないでください、なぜならそれは結果の配列を作成してそして放棄するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Don’t delete the <bpt i="1" x="1">&lt;c1&gt;</bpt>.m<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>.h<ept i="2">&lt;/c2&gt;</ept> files immediately; use them to troubleshoot.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>.m<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>.h<ept i="2">&lt;/c2&gt;</ept>ファイルを直ぐに削除しないでください；それらを不具合対処のために使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>During instance creation, in particular during <bpt i="0" x="0">&lt;c0&gt;</bpt>Managed<bpt i="1" x="1">&lt;w1&gt;</bpt>Buffer<bpt i="2" x="2">&lt;w2&gt;</bpt>.create<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>’s call to initialize, <bpt i="3" x="3">&lt;c3&gt;</bpt>Managed<bpt i="4" x="4">&lt;w4&gt;</bpt>Buffer<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>’s <bpt i="5" x="5">&lt;c5&gt;</bpt>header<ept i="5">&lt;/c5&gt;</ept> property is as-yet uninitialized, and therefore reading the <bpt i="6" x="6">&lt;c6&gt;</bpt>header<ept i="6">&lt;/c6&gt;</ept> property during <bpt i="7" x="7">&lt;c7&gt;</bpt>Managed<bpt i="8" x="8">&lt;w8&gt;</bpt>Buffer<bpt i="9" x="9">&lt;w9&gt;</bpt>.create<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> is undefined.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インスタンス作成の間、特に<bpt i="0" x="0">&lt;c0&gt;</bpt>Managed<bpt i="1" x="1">&lt;w1&gt;</bpt>Buffer<bpt i="2" x="2">&lt;w2&gt;</bpt>.create<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>でのイニシャライザ呼び出しの間、<bpt i="3" x="3">&lt;c3&gt;</bpt>Managed<bpt i="4" x="4">&lt;w4&gt;</bpt>Buffer<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>の<bpt i="5" x="5">&lt;c5&gt;</bpt>header<ept i="5">&lt;/c5&gt;</ept>プロパティは今の所まだイニシャライズされていません、そしてそれゆえ<bpt i="6" x="6">&lt;c6&gt;</bpt>header<ept i="6">&lt;/c6&gt;</ept>プロパティを読み出すことは<bpt i="7" x="7">&lt;c7&gt;</bpt>Managed<bpt i="8" x="8">&lt;w8&gt;</bpt>Buffer<bpt i="9" x="9">&lt;w9&gt;</bpt>.create<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>の間は未定義です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Each bit of <bpt i="0" x="0">&lt;c0&gt;</bpt>raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> potentially represents an element of the option set, though raw values may include bits that are not defined as distinct values of the <bpt i="2" x="2">&lt;c2&gt;</bpt>Option<bpt i="3" x="3">&lt;w3&gt;</bpt>Set<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の各ビットは、潜在的にオプションセットの１つの要素を表します、けれども生の値は他とまったく異なった<bpt i="2" x="2">&lt;c2&gt;</bpt>Option<bpt i="3" x="3">&lt;w3&gt;</bpt>Set<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型の値として定義されないビットを含んでも構いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Each call to <bpt i="4" x="4">&lt;c4&gt;</bpt>next()<ept i="4">&lt;/c4&gt;</ept> must produce a uniform and independent random value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>next()<ept i="4">&lt;/c4&gt;</ept>への各呼び出しは、一様で独立した無作為値を生成しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Each integer argument selects the child at that offset.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>各整数引数は、子をそのオフセットで選択します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Each string argument requires a linear search, and unless the underlying collection supports random-access traversal, each integer argument also requires a linear operation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>各文字列引数は線形探索を要求します、そして基底コレクションがランダムアクセス走査をサポートしない限り、各整数引数もまた線形演算を要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Each string argument selects the first child with a matching label.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>各文字列引数は、合致するラベルを持つ最初の子を選択します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Each time an element of the lazy sequence <bpt i="0" x="0">&lt;c0&gt;</bpt>doubled<ept i="0">&lt;/c0&gt;</ept> is accessed, the closure accesses and transforms an element of the underlying array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この遅延シーケンス<bpt i="0" x="0">&lt;c0&gt;</bpt>doubled<ept i="0">&lt;/c0&gt;</ept>の要素がアクセスされるたびごとに、クロージャはその基礎をなす配列の要素にアクセスおよび変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Each time the <bpt i="0" x="0">&lt;c0&gt;</bpt>next()<ept i="0">&lt;/c0&gt;</ept> method is called on a <bpt i="1" x="1">&lt;c1&gt;</bpt>Countdown<bpt i="2" x="2">&lt;w2&gt;</bpt>Iterator<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> instance, it calculates the new next value, checks to see whether it has reached zero, and then returns either the number, or <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept> if the iterator is finished returning elements of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>next()<ept i="0">&lt;/c0&gt;</ept>メソッドが<bpt i="1" x="1">&lt;c1&gt;</bpt>Countdown<bpt i="2" x="2">&lt;w2&gt;</bpt>Iterator<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>インスタンス上で呼ばれるたびに、それは新しい次の値を計算し、それがゼロに届いたか見るために調べ、そしてそれからその数、またはそのイテレータがシーケンスの要素を返すことを完了するならば<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>のどちらかを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Effectively managing state, the bits of data that keep track of how the app is being used at the moment, is an important part of a developing your app.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>効果的に状態、どのようにその時アプリが使われるかの情報を得る少量のデータ、を管理することは、あなたのアプリの開発の重要な部分です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Elements are sorted in ascending order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要素は昇順にソートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Elements that are in only one or the other are left out of the result of the intersection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>どちらか一方にだけある要素は、交叉の結果から除外されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Elements that are used to split the collection are not returned as part of any subsequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションを分割するのに使われる要素らは、どれかの下位シーケンスの一部として返されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Elements that are used to split the sequence are not returned as part of any subsequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスを分割するのに使われる要素らは、どれかの下位シーケンスの一部として返されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encoders should provide types conforming to <bpt i="0" x="0">&lt;c0&gt;</bpt>Keyed<bpt i="1" x="1">&lt;w1&gt;</bpt>Encoding<bpt i="2" x="2">&lt;w2&gt;</bpt>Container<bpt i="3" x="3">&lt;w3&gt;</bpt>Protocol<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> for their format.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それらエンコーダは、それらの形式に対して<bpt i="0" x="0">&lt;c0&gt;</bpt>Keyed<bpt i="1" x="1">&lt;w1&gt;</bpt>Encoding<bpt i="2" x="2">&lt;w2&gt;</bpt>Container<bpt i="3" x="3">&lt;w3&gt;</bpt>Protocol<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠する型を提供すべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encodes a null value for the given key.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたキーに対してnull値をエンコードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encodes a reference to the given object only if it is encoded unconditionally elsewhere in the payload (previously, or in the future).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたオブジェクトへの参照をエンコードします、それがそのペイロードの中のどこか他の所で無条件にエンコードをされる（以前に、またはこの先に）場合に限ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encodes the elements of this set into the given encoder in an unkeyed container.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合の要素を指定されたエンコーダへとあるキー付けされないコンテナにおいてエンコードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encodes the given value for the given key if it is not <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたキーに対して与えられた値をエンコードします、それが<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>でないならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encodes the given value for the given key.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたキーに対して与えられた値をエンコードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encodes the scalars of this vector into the given encoder in an unkeyed container.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このベクターのスカラーそれらをこの与えられたエンコーダへとキー付けされないコンテナの中に符号化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encodes this optional value into the given encoder.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このオプショナル値を与えられたエンコーダにエンコードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encodes this value into the given encoder, when the type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>Bool<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値をその与えられたデコーダへとデコードします、その型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Bool<ept i="2">&lt;/c2&gt;</ept>である場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encodes this value into the given encoder, when the type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>Double<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値をその与えられたデコーダへとデコードします、その型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Double<ept i="2">&lt;/c2&gt;</ept>である場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encodes this value into the given encoder, when the type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>Float<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値をその与えられたデコーダへとデコードします、その型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Float<ept i="2">&lt;/c2&gt;</ept>である場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encodes this value into the given encoder, when the type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>Int16<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値をその与えられたデコーダへとデコードします、その型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Int16<ept i="2">&lt;/c2&gt;</ept>である場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encodes this value into the given encoder, when the type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>Int32<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値をその与えられたデコーダへとデコードします、その型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Int32<ept i="2">&lt;/c2&gt;</ept>である場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encodes this value into the given encoder, when the type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>Int64<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値をその与えられたデコーダへとデコードします、その型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Int64<ept i="2">&lt;/c2&gt;</ept>である場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encodes this value into the given encoder, when the type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>Int8<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値をその与えられたデコーダへとデコードします、その型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Int8<ept i="2">&lt;/c2&gt;</ept>である場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encodes this value into the given encoder, when the type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値をその与えられたデコーダへとデコードします、その型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>である場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encodes this value into the given encoder, when the type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値をその与えられたデコーダへとデコードします、その型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>である場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encodes this value into the given encoder, when the type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>UInt16<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値をその与えられたデコーダへとデコードします、その型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>UInt16<ept i="2">&lt;/c2&gt;</ept>である場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encodes this value into the given encoder, when the type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>UInt32<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値をその与えられたデコーダへとデコードします、その型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>UInt32<ept i="2">&lt;/c2&gt;</ept>である場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encodes this value into the given encoder, when the type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>UInt64<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値をその与えられたデコーダへとデコードします、その型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>UInt64<ept i="2">&lt;/c2&gt;</ept>である場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encodes this value into the given encoder, when the type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>UInt8<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値をその与えられたデコーダへとデコードします、その型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>UInt8<ept i="2">&lt;/c2&gt;</ept>である場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encodes this value into the given encoder, when the type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>UInt<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値をその与えられたデコーダへとデコードします、その型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>UInt<ept i="2">&lt;/c2&gt;</ept>である場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encodes this value into the given encoder.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値を与えられたエンコーダにエンコードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encoding Containers</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>エンコーディングコンテナ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encoding a Value</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値をエンコードする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encoding and Decoding</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>エンコーディングとデコーディング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encoding and Decoding a Range</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある範囲を符号化そして復号する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encoding, Decoding, and Serialization</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>エンコード、デコード、そしてシリアライズ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Enumeration Case</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>列挙ケース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Enumeration Cases</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>列挙ケース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Enumerations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Enumerations imported using the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_ENUM<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> macro won't fail when you initialize one with a raw value that does not correspond to an enumeration case.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_ENUM<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>マクロを使ってインポートされる列挙は、あなたが列挙ケース節に一致しない生の値を持つものを初期化する場合に、失敗しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Enumerations with Raw Values</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>生の値を持つ列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Equality is the inverse of inequality.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同等性は、不等性の裏返しです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Equivalent to <bpt i="0" x="0">&lt;c0&gt;</bpt>indices<bpt i="1" x="1">&lt;w1&gt;</bpt>.reduce(into: 0) { $0 &amp;+= self[$1] }<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>indices<bpt i="1" x="1">&lt;w1&gt;</bpt>.reduce(into: 0) { $0 &amp;+= self[$1] }<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に等しい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Equivalent to calling <bpt i="0" x="0">&lt;c0&gt;</bpt>super<bpt i="1" x="1">&lt;w1&gt;</bpt>Decoder(for<bpt i="2" x="2">&lt;w2&gt;</bpt>Key:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> with <bpt i="3" x="3">&lt;c3&gt;</bpt>Key(string<bpt i="4" x="4">&lt;w4&gt;</bpt>Value: "super", int<bpt i="5" x="5">&lt;w5&gt;</bpt>Value: 0)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>super<bpt i="1" x="1">&lt;w1&gt;</bpt>Decoder(for<bpt i="2" x="2">&lt;w2&gt;</bpt>Key:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> with <bpt i="3" x="3">&lt;c3&gt;</bpt>Key(string<bpt i="4" x="4">&lt;w4&gt;</bpt>Value: "super", int<bpt i="5" x="5">&lt;w5&gt;</bpt>Value: 0)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>を呼び出すことと同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Equivalent to calling <bpt i="0" x="0">&lt;c0&gt;</bpt>super<bpt i="1" x="1">&lt;w1&gt;</bpt>Encoder(for<bpt i="2" x="2">&lt;w2&gt;</bpt>Key:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> with <bpt i="3" x="3">&lt;c3&gt;</bpt>Key(string<bpt i="4" x="4">&lt;w4&gt;</bpt>Value: "super", int<bpt i="5" x="5">&lt;w5&gt;</bpt>Value: 0)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>super<bpt i="1" x="1">&lt;w1&gt;</bpt>Encoder(for<bpt i="2" x="2">&lt;w2&gt;</bpt>Key:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> with <bpt i="3" x="3">&lt;c3&gt;</bpt>Key(string<bpt i="4" x="4">&lt;w4&gt;</bpt>Value: "super", int<bpt i="5" x="5">&lt;w5&gt;</bpt>Value: 0)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>を呼び出すことと同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Equivalent to:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次に等しい：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Errors</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>エラー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Evaluates the given closure when this <bpt i="0" x="0">&lt;c0&gt;</bpt>Optional<ept i="0">&lt;/c0&gt;</ept> instance is not <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>, passing the unwrapped value as a parameter.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたクロージャをこの<bpt i="0" x="0">&lt;c0&gt;</bpt>Optional<ept i="0">&lt;/c0&gt;</ept>インスタンスが<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>でない場合に評価します、アンラップされた値をパラメータとして渡しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Even something as simple as printing a sequence of letters can be affected by the timing of a closure call:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>一連の文字を印字するような単純なことでさえ、クロージャ呼び出しの時機によって影響される可能性があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Even though the line that prints <bpt i="4" x="4">&lt;c4&gt;</bpt>A<ept i="4">&lt;/c4&gt;</ept> is first in the code, it's ordered later in the output.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>たとえ<bpt i="4" x="4">&lt;c4&gt;</bpt>A<ept i="4">&lt;/c4&gt;</ept>を印字する行がコードにおいて最初であっても、それは出力においてもっと後の順番にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Every distinct value of the conforming type has a corresponding unique value of the <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type, but there may be values of the <bpt i="2" x="2">&lt;c2&gt;</bpt>Raw<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type that don’t have a corresponding value of the conforming type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>準拠する型のすべての個々の値は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型の対応する特有な値を持ちます、しかし準拠する型の値に対応しない<bpt i="2" x="2">&lt;c2&gt;</bpt>Raw<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型の値があっても構いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Every element of <bpt i="2" x="2">&lt;c2&gt;</bpt>numbers<ept i="2">&lt;/c2&gt;</ept> up to, but not including, the first negative value is included in the result.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最初の負の値までの、しかしそれを含まない、<bpt i="2" x="2">&lt;c2&gt;</bpt>numbers<ept i="2">&lt;/c2&gt;</ept>のすべての要素は、この結果の中に含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Every value in the range <bpt i="3" x="3">&lt;c3&gt;</bpt>0..<it pos="begin" x="4">&lt;upper&lt;w4&gt;</it>Bound<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is equally likely to be returned.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲<bpt i="3" x="3">&lt;c3&gt;</bpt>0..<it pos="begin" x="4">&lt;upper&lt;w4&gt;</it>Bound<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>の中の全ての値は、等しく返される可能性をもちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Everything from your implementation and interface goes directly into this single Swift file.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたの実装とインタフェースからのすべては、直接この単一のスウィフトファイルに入ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Example Buffer Class</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>バッファクラスの例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Exchanges the values at the specified indices of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのコレクションの指定インデックスでの値を交換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Excluding Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要素を除外する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Execute the given body closure on the main actor.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたbodyクロージャを主アクター上で遂行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Exiting a Program</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>プログラムの終了</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Expected Performance</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>期待される性能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Expose the Existing Implementation</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>既存の実装を公開する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Extensible enumerations are imported in a similar fashion to nonextensible ones, except that they receive an additional initializer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>拡張可能列挙は、それらが追加的なイニシャライザを受け取ることを除いては、同じようなやり方で拡張可能でないものにインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Extracts the scalars at specified indices to form a SIMD16.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>形式SIMD16への指定インデックスそれらでのスカラーを抽出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Extracts the scalars at specified indices to form a SIMD2.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>形式SIMD2への指定インデックスそれらでのスカラーを抽出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Extracts the scalars at specified indices to form a SIMD3.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>形式SIMD3への指定インデックスそれらでのスカラーを抽出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Extracts the scalars at specified indices to form a SIMD32.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>形式SIMD32への指定インデックスそれらでのスカラーを抽出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Extracts the scalars at specified indices to form a SIMD4.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>形式SIMD4への指定インデックスそれらでのスカラーを抽出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Extracts the scalars at specified indices to form a SIMD64.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>形式SIMD64への指定インデックスそれらでのスカラーを抽出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Extracts the scalars at specified indices to form a SIMD8.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>形式SIMD8への指定インデックスそれらでのスカラーを抽出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Fill out an Objective-C bridging header if you need to access Objective-C code from the same app target in your Swift file.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-Cブリッジヘッダを記入してください、もしあなたがObjective-CコードにあなたのSwiftファイルにおいて同じアプリターゲットからアクセスする必要があるならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Finally, you can give all lazy sequences a lazy <bpt i="0" x="0">&lt;c0&gt;</bpt>scan(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最終的に、あなたは全ての遅延シーケンスをある遅延<bpt i="0" x="0">&lt;c0&gt;</bpt>scan(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドに与えることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Finding Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要素を見つける</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>First Steps</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>初歩</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>First, retrieve a sequence’s iterator, and then call the iterator’s <bpt i="2" x="2">&lt;c2&gt;</bpt>next()<ept i="2">&lt;/c2&gt;</ept> method until it returns <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>まず、あるシーケンスのもつイテレータを見つけて取ってきてください、そしてそのイテレータの持つ<bpt i="2" x="2">&lt;c2&gt;</bpt>next()<ept i="2">&lt;/c2&gt;</ept>メソッドを、それが<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>を返すまで呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>First, the function finds the position of the last even number as a <bpt i="0" x="0">&lt;c0&gt;</bpt>Reversed<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> in a reversed view of the array of numbers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最初に、この関数は最後の偶数の位置を、数からなる配列の逆にされたビューにおける<bpt i="0" x="0">&lt;c0&gt;</bpt>Reversed<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として捜します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For a value <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>, a distance <bpt i="1" x="1">&lt;c1&gt;</bpt>n<ept i="1">&lt;/c1&gt;</ept>, and a value <bpt i="2" x="2">&lt;c2&gt;</bpt>y = x<bpt i="3" x="3">&lt;w3&gt;</bpt>.advanced(by: n)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>x<bpt i="5" x="5">&lt;w5&gt;</bpt>.distance(to: y) == n<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>、隔たり<bpt i="1" x="1">&lt;c1&gt;</bpt>n<ept i="1">&lt;/c1&gt;</ept>、および値<bpt i="2" x="2">&lt;c2&gt;</bpt>y = x<bpt i="3" x="3">&lt;w3&gt;</bpt>.advanced(by: n)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に対して、<bpt i="4" x="4">&lt;c4&gt;</bpt>x<bpt i="5" x="5">&lt;w5&gt;</bpt>.distance(to: y) == n<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For a value <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>, the result of <bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.divided<bpt i="3" x="3">&lt;w3&gt;</bpt>Reporting<bpt i="4" x="4">&lt;w4&gt;</bpt>Overflow(by: 0)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>(x, true)<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.divided<bpt i="3" x="3">&lt;w3&gt;</bpt>Reporting<bpt i="4" x="4">&lt;w4&gt;</bpt>Overflow(by: 0)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の結果は<bpt i="5" x="5">&lt;c5&gt;</bpt>(x, true)<ept i="5">&lt;/c5&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For a value <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>, the result of <bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.remainder<bpt i="3" x="3">&lt;w3&gt;</bpt>Reporting<bpt i="4" x="4">&lt;w4&gt;</bpt>Overflow(dividing<bpt i="5" x="5">&lt;w5&gt;</bpt>By: 0)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is <bpt i="6" x="6">&lt;c6&gt;</bpt>(x, true)<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.remainder<bpt i="3" x="3">&lt;w3&gt;</bpt>Reporting<bpt i="4" x="4">&lt;w4&gt;</bpt>Overflow(dividing<bpt i="5" x="5">&lt;w5&gt;</bpt>By: 0)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の結果は<bpt i="6" x="6">&lt;c6&gt;</bpt>(x, true)<ept i="6">&lt;/c6&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For all other kinds of declaration—such as properties, enumeration cases, and type aliases—you use the macro as a suffix.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>全ての他の種類の宣言に対して — 例えばプロパティ、列挙ケース節、そして型エイリアスなど — あなたはこのマクロを接尾辞として使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For an example of how Swift imports unannotated declarations, consider the following code:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>どのようにSwiftが注釈を付けられない宣言をインポートするかの例として、以下のコードを考慮してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For an index <bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept> into a collection <bpt i="1" x="1">&lt;c1&gt;</bpt>c<ept i="1">&lt;/c1&gt;</ept>, calling <bpt i="2" x="2">&lt;c2&gt;</bpt>c<bpt i="3" x="3">&lt;w3&gt;</bpt>.index(after: i)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> returns the same index every time.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクション<bpt i="0" x="0">&lt;c0&gt;</bpt>c<ept i="0">&lt;/c0&gt;</ept>へのインデックス<bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt>c<bpt i="3" x="3">&lt;w3&gt;</bpt>.index(after: i)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を呼び出すことはいつでも同じインデックスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For any enumeration with a string, integer, or floating-point raw type, the Swift compiler automatically adds <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Representable<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>文字列、整数、または浮動小数点の生の型を持つ何らかの列挙に対して、Swiftコンパイラは自動的に<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Representable<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠を加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For any numeric value <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.magnitude<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is the absolute value of <bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>何らかの数値<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.magnitude<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>の絶対値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For any two integers <bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept>, their quotient <bpt i="2" x="2">&lt;c2&gt;</bpt>q<ept i="2">&lt;/c2&gt;</ept>, and their remainder <bpt i="3" x="3">&lt;c3&gt;</bpt>r<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>a == b * q + r<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>何らかの２つの整数<bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept>、それらの商<bpt i="2" x="2">&lt;c2&gt;</bpt>q<ept i="2">&lt;/c2&gt;</ept>、そしてそれらの余り<bpt i="3" x="3">&lt;c3&gt;</bpt>r<ept i="3">&lt;/c3&gt;</ept>に対して、<bpt i="4" x="4">&lt;c4&gt;</bpt>a == b * q + r<ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For any value, <bpt i="0" x="0">&lt;c0&gt;</bpt>x + .zero == x<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>.zero + x == x<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あらゆる値に対して、<bpt i="0" x="0">&lt;c0&gt;</bpt>x + .zero == x<ept i="0">&lt;/c0&gt;</ept>かつ<bpt i="1" x="1">&lt;c1&gt;</bpt>.zero + x == x<ept i="1">&lt;/c1&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For any values <bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>a != b<ept i="2">&lt;/c2&gt;</ept> implies that <bpt i="3" x="3">&lt;c3&gt;</bpt>a == b<ept i="3">&lt;/c3&gt;</ept> is <bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>何らかの<bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt>a != b<ept i="2">&lt;/c2&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>a == b<ept i="3">&lt;/c3&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>であることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For any values <bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>a == b<ept i="2">&lt;/c2&gt;</ept> implies that <bpt i="3" x="3">&lt;c3&gt;</bpt>a != b<ept i="3">&lt;/c3&gt;</ept> is <bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>何らかの値<bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt>a == b<ept i="2">&lt;/c2&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>a != b<ept i="3">&lt;/c3&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>であることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For bridging to be possible, the <bpt i="3" x="3">&lt;c3&gt;</bpt>Element<ept i="3">&lt;/c3&gt;</ept> type of a set must be a class, an <bpt i="4" x="4">&lt;c4&gt;</bpt>@objc<ept i="4">&lt;/c4&gt;</ept> protocol (a protocol imported from Objective-C or marked with the <bpt i="5" x="5">&lt;c5&gt;</bpt>@objc<ept i="5">&lt;/c5&gt;</ept> attribute), or a type that bridges to a Foundation type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ブリッジが可能にされるには、集合の<bpt i="3" x="3">&lt;c3&gt;</bpt>Element<ept i="3">&lt;/c3&gt;</ept>型は、クラス、<bpt i="4" x="4">&lt;c4&gt;</bpt>@objc<ept i="4">&lt;/c4&gt;</ept>プロトコル（Objective-Cからインポートされるまたは<bpt i="5" x="5">&lt;c5&gt;</bpt>@objc<ept i="5">&lt;/c5&gt;</ept>属性で印されるプロトコル）、またはあるFoundation型にブリッジする型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For clearer, more concise code, the example above could use the array’s <bpt i="1" x="1">&lt;c1&gt;</bpt>contains(_:)<ept i="1">&lt;/c1&gt;</ept> method, which every sequence inherits from <bpt i="2" x="2">&lt;c2&gt;</bpt>Sequence<ept i="2">&lt;/c2&gt;</ept>, instead of iterating manually:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>より明確な、もっと簡潔なコードのために、上のコードは、すべてのシーケンスが<bpt i="2" x="2">&lt;c2&gt;</bpt>Sequence<ept i="2">&lt;/c2&gt;</ept>から継承する、配列のもつ<bpt i="1" x="1">&lt;c1&gt;</bpt>contains(_:)<ept i="1">&lt;/c1&gt;</ept>メソッドを使うことが、労力を要する反復の代わりに可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For collections that don’t conform to <bpt i="3" x="3">&lt;c3&gt;</bpt>Random<bpt i="4" x="4">&lt;w4&gt;</bpt>Access<bpt i="5" x="5">&lt;w5&gt;</bpt>Collection<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, accessing the <bpt i="6" x="6">&lt;c6&gt;</bpt>count<ept i="6">&lt;/c6&gt;</ept> property iterates through the elements of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>Random<bpt i="4" x="4">&lt;w4&gt;</bpt>Access<bpt i="5" x="5">&lt;w5&gt;</bpt>Collection<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に準拠しないコレクションに対して、<bpt i="6" x="6">&lt;c6&gt;</bpt>count<ept i="6">&lt;/c6&gt;</ept>プロパティにアクセスすることはコレクションの要素を始めから終わりまで反復します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For detailed information about specifying platform availability, see <bpt i="0" x="0">&lt;a0&gt;</bpt>Declaration Attributes<ept i="0">&lt;/a0&gt;</ept> in <bpt i="1" x="1">&lt;a1&gt;</bpt>The Swift Programming Language<ept i="1">&lt;/a1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>プラットホーム利用可能性の指定についての詳細な情報として、<bpt i="0" x="0">&lt;a0&gt;</bpt>宣言属性<ept i="0">&lt;/a0&gt;</ept>を<bpt i="1" x="1">&lt;a1&gt;</bpt>The Swift Programming Language<ept i="1">&lt;/a1&gt;</ept>で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For encoders which don’t support this feature, the default implementation encodes the given object unconditionally.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この機能をサポートしないエンコーダに対して、省略時の実装は与えられたオブジェクトを無条件にエンコードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For every change in state, you need to provides updates for both <bpt i="0" x="0">&lt;c0&gt;</bpt>user<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>session<bpt i="2" x="2">&lt;w2&gt;</bpt>Expired<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> in tandem.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>状態におけるすべての変化に対して、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>user<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>session<bpt i="2" x="2">&lt;w2&gt;</bpt>Expired<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の両方に対して相前後して更新を提供する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example,</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, <bpt i="0" x="0">&lt;c0&gt;</bpt>doubled<ept i="0">&lt;/c0&gt;</ept> in this code sample is a sequence containing the values <bpt i="1" x="1">&lt;c1&gt;</bpt>2<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>4<ept i="2">&lt;/c2&gt;</ept>, and <bpt i="3" x="3">&lt;c3&gt;</bpt>6<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、このコード見本の中の<bpt i="0" x="0">&lt;c0&gt;</bpt>doubled<ept i="0">&lt;/c0&gt;</ept>は、値<bpt i="1" x="1">&lt;c1&gt;</bpt>2<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>4<ept i="2">&lt;/c2&gt;</ept>、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>6<ept i="3">&lt;/c3&gt;</ept>を含んでいるあるシーケンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, <bpt i="6" x="6">&lt;e6&gt;</bpt>6<ept i="6">&lt;/e6&gt;</ept> is a multiple of <bpt i="7" x="7">&lt;e7&gt;</bpt>3<ept i="7">&lt;/e7&gt;</ept> because <bpt i="8" x="8">&lt;e8&gt;</bpt>6 = 2*3<ept i="8">&lt;/e8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、<bpt i="6" x="6">&lt;e6&gt;</bpt>6<ept i="6">&lt;/e6&gt;</ept>は<bpt i="7" x="7">&lt;e7&gt;</bpt>3<ept i="7">&lt;/e7&gt;</ept>の倍数です、なぜなら<bpt i="8" x="8">&lt;e8&gt;</bpt>6 = 2*3<ept i="8">&lt;/e8&gt;</ept>なので。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, a random-access collection’s <bpt i="0" x="0">&lt;c0&gt;</bpt>count<ept i="0">&lt;/c0&gt;</ept> property is calculated in O(1) instead of requiring iteration of an entire collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、無作為アクセスコレクションのもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>count<ept i="0">&lt;/c0&gt;</ept>プロパティは、コレクション全体の反復を要求したりせずにO(1)で計算されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, a seedable generator can be used to generate a repeatable sequence of random values for testing purposes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、シード可能生成子は、繰り返し可能な一連の無作為値を、テスト目的で生成するために使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, after filtering a set of prime numbers to remove any below 10, you can create a new set by using this initializer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、ひとそろいの素数をフィルタして10の前のどんなものも削除した後で、あなたは新しい集合をこのイニシャライザを使って作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, an eager <bpt i="3" x="3">&lt;c3&gt;</bpt>scan(_:<bpt i="4" x="4">&lt;w4&gt;</bpt>_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> method is defined as follows:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、ある即時<bpt i="3" x="3">&lt;c3&gt;</bpt>scan(_:<bpt i="4" x="4">&lt;w4&gt;</bpt>_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>メソッドは以下のように定義されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, consider a custom <bpt i="0" x="0">&lt;c0&gt;</bpt>Countdown<ept i="0">&lt;/c0&gt;</ept> sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あるあつらえの<bpt i="0" x="0">&lt;c0&gt;</bpt>Countdown<ept i="0">&lt;/c0&gt;</ept>シーケンスを考えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, consider a custom type called <bpt i="0" x="0">&lt;c0&gt;</bpt>Shipping<bpt i="1" x="1">&lt;w1&gt;</bpt>Options<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> that is an option set of the possible ways to ship a customer’s purchase.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>Shipping<bpt i="1" x="1">&lt;w1&gt;</bpt>Options<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と呼ばれるあつらえの型を考えてください、それは顧客の購入品を出荷する可能な方法のオプションセットです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, for a variable <bpt i="1" x="1">&lt;c1&gt;</bpt>root<ept i="1">&lt;/c1&gt;</ept> of type <bpt i="2" x="2">&lt;c2&gt;</bpt>T<ept i="2">&lt;/c2&gt;</ept>, a key path <bpt i="3" x="3">&lt;c3&gt;</bpt>key<ept i="3">&lt;/c3&gt;</ept> of type <bpt i="4" x="4">&lt;c4&gt;</bpt>Writable<bpt i="5" x="5">&lt;w5&gt;</bpt>Key<bpt i="6" x="6">&lt;w6&gt;</bpt>Path&lt;T, U&gt;<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, and a <bpt i="7" x="7">&lt;c7&gt;</bpt>value<ept i="7">&lt;/c7&gt;</ept> of type <bpt i="8" x="8">&lt;c8&gt;</bpt>U<ept i="8">&lt;/c8&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、変数<bpt i="1" x="1">&lt;c1&gt;</bpt>root<ept i="1">&lt;/c1&gt;</ept>で型<bpt i="2" x="2">&lt;c2&gt;</bpt>T<ept i="2">&lt;/c2&gt;</ept>、キーパス<bpt i="3" x="3">&lt;c3&gt;</bpt>key<ept i="3">&lt;/c3&gt;</ept>で型<bpt i="4" x="4">&lt;c4&gt;</bpt>Writable<bpt i="5" x="5">&lt;w5&gt;</bpt>Key<bpt i="6" x="6">&lt;w6&gt;</bpt>Path&lt;T, U&gt;<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>、そして<bpt i="7" x="7">&lt;c7&gt;</bpt>value<ept i="7">&lt;/c7&gt;</ept>で型<bpt i="8" x="8">&lt;c8&gt;</bpt>U<ept i="8">&lt;/c8&gt;</ept>に対して：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, if a variable has the type <bpt i="3" x="3">&lt;c3&gt;</bpt>Int?<ept i="3">&lt;/c3&gt;</ept>, that’s just another way of writing <bpt i="4" x="4">&lt;c4&gt;</bpt>Optional&lt;Int&gt;<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、ある変数が型<bpt i="3" x="3">&lt;c3&gt;</bpt>Int?<ept i="3">&lt;/c3&gt;</ept>を持つとすれば、それは<bpt i="4" x="4">&lt;c4&gt;</bpt>Optional&lt;Int&gt;<ept i="4">&lt;/c4&gt;</ept>を記述することのありきたりのやり方です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, if there are parts of your codebase to which you haven't added nullability annotations, now's the time to add them.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、ヌル可能性注釈を加えてないなあなたのコード基盤の部分があるならば、今こそそれらを加える時です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, in a fixed-width integer type with a <bpt i="0" x="0">&lt;c0&gt;</bpt>bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Width<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> value of 8, the number <bpt i="2" x="2">&lt;e2&gt;</bpt>31<ept i="2">&lt;/e2&gt;</ept> has five bits equal to <bpt i="3" x="3">&lt;e3&gt;</bpt>1<ept i="3">&lt;/e3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、８の<bpt i="0" x="0">&lt;c0&gt;</bpt>bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Width<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>値を持つ固定長整数型において、数<bpt i="2" x="2">&lt;e2&gt;</bpt>31<ept i="2">&lt;/e2&gt;</ept>は<bpt i="3" x="3">&lt;e3&gt;</bpt>1<ept i="3">&lt;/e3&gt;</ept>に等しいビットを５つ持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, in an integer type with a <bpt i="0" x="0">&lt;c0&gt;</bpt>bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Width<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> value of 8, the number <bpt i="2" x="2">&lt;e2&gt;</bpt>31<ept i="2">&lt;/e2&gt;</ept> has three leading zeros.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、８の<bpt i="0" x="0">&lt;c0&gt;</bpt>bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Width<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>値を持つ整数型において、数<bpt i="2" x="2">&lt;e2&gt;</bpt>31<ept i="2">&lt;/e2&gt;</ept>は３つの先頭のゼロを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, in the <bpt i="0" x="0">&lt;c0&gt;</bpt>Product<bpt i="1" x="1">&lt;w1&gt;</bpt>Category<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type defined here, only <bpt i="2" x="2">&lt;c2&gt;</bpt>\.update<bpt i="3" x="3">&lt;w3&gt;</bpt>Counter<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>\.identifier<ept i="4">&lt;/c4&gt;</ept>, and <bpt i="5" x="5">&lt;c5&gt;</bpt>\.identifier<bpt i="6" x="6">&lt;w6&gt;</bpt>.name<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> refer to properties with inline, directly addressable storage:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、ここで定義される<bpt i="0" x="0">&lt;c0&gt;</bpt>Product<bpt i="1" x="1">&lt;w1&gt;</bpt>Category<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型において、<bpt i="2" x="2">&lt;c2&gt;</bpt>\.update<bpt i="3" x="3">&lt;w3&gt;</bpt>Counter<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>\.identifier<ept i="4">&lt;/c4&gt;</ept>、そして<bpt i="5" x="5">&lt;c5&gt;</bpt>\.identifier<bpt i="6" x="6">&lt;w6&gt;</bpt>.name<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>だけがインラインに、直接にアドレス指定可能なストレージでのプロパティを参照します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, iterating over an instance of <bpt i="1" x="1">&lt;c1&gt;</bpt>Partial<bpt i="2" x="2">&lt;w2&gt;</bpt>Range<bpt i="3" x="3">&lt;w3&gt;</bpt>From&lt;Int&gt;<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> traps when the sequence’s next value would be above <bpt i="4" x="4">&lt;c4&gt;</bpt>Int<bpt i="5" x="5">&lt;w5&gt;</bpt>.max<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、<bpt i="1" x="1">&lt;c1&gt;</bpt>Partial<bpt i="2" x="2">&lt;w2&gt;</bpt>Range<bpt i="3" x="3">&lt;w3&gt;</bpt>From&lt;Int&gt;<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>のインスタンスの全体にわたって反復することは、そのシーケンスの次の値が<bpt i="4" x="4">&lt;c4&gt;</bpt>Int<bpt i="5" x="5">&lt;w5&gt;</bpt>.max<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>より上となる場合にトラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, passing <bpt i="0" x="0">&lt;c0&gt;</bpt>1, "two", 3<ept i="0">&lt;/c0&gt;</ept> as arguments to <bpt i="1" x="1">&lt;c1&gt;</bpt>my<bpt i="2" x="2">&lt;w2&gt;</bpt>Mirror<bpt i="3" x="3">&lt;w3&gt;</bpt>.descendant(_:<bpt i="4" x="4">&lt;w4&gt;</bpt>_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is equivalent to:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>1, "two", 3<ept i="0">&lt;/c0&gt;</ept>を引数として<bpt i="1" x="1">&lt;c1&gt;</bpt>my<bpt i="2" x="2">&lt;w2&gt;</bpt>Mirror<bpt i="3" x="3">&lt;w3&gt;</bpt>.descendant(_:<bpt i="4" x="4">&lt;w4&gt;</bpt>_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に渡すことは、次と同等です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, passing a closed range with an upper bound of <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<bpt i="1" x="1">&lt;w1&gt;</bpt>.max<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> triggers a runtime error, because the resulting half-open range would require an upper bound of <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<bpt i="3" x="3">&lt;w3&gt;</bpt>.max + 1<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, which is not representable as</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、完結範囲を<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<bpt i="1" x="1">&lt;w1&gt;</bpt>.max<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の上方境界で渡すことは実行時エラーの引き金となります、なぜなら結果の半開範囲は<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<bpt i="3" x="3">&lt;w3&gt;</bpt>.max + 1<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の上方境界を要求するからです。それはのように表されることができません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>Counter<ept i="0">&lt;/c0&gt;</ept> enumeration defined here has an <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept> raw value type and gives the first case a raw value of <bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、ここで定義される<bpt i="0" x="0">&lt;c0&gt;</bpt>Counter<ept i="0">&lt;/c0&gt;</ept>列挙は、<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>の生の値型を持ち、そして最初のケース節に生の値の<bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>を与えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>contains()<ept i="0">&lt;/c0&gt;</ept> method on <bpt i="1" x="1">&lt;c1&gt;</bpt>allowed<bpt i="2" x="2">&lt;w2&gt;</bpt>Moves<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> performs a bitwise AND operation to check whether the option set contains an element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>contains()<ept i="0">&lt;/c0&gt;</ept>メソドは<bpt i="1" x="1">&lt;c1&gt;</bpt>allowed<bpt i="2" x="2">&lt;w2&gt;</bpt>Moves<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>上で、ビット単位AND演算を実行して、オプションセットがある要素を含むかどうか調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>later(_:)<ept i="0">&lt;/c0&gt;</ept> method above is comparable to the <bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>URLSession<ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept> class's <bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>data<bpt i="5" x="5">&lt;w5&gt;</bpt>Task(with:<bpt i="6" x="6">&lt;w6&gt;</bpt>completion<bpt i="7" x="7">&lt;w7&gt;</bpt>Handler:)<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept> method, which is also asynchronous.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、上の<bpt i="0" x="0">&lt;c0&gt;</bpt>later(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドは、<bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>URLSession<ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept>クラスの<bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>data<bpt i="5" x="5">&lt;w5&gt;</bpt>Task(with:<bpt i="6" x="6">&lt;w6&gt;</bpt>completion<bpt i="7" x="7">&lt;w7&gt;</bpt>Handler:)<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>メソッドと似ています、それもまた非同期です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the <bpt i="9" x="9">&lt;c9&gt;</bpt>Direction<ept i="9">&lt;/c9&gt;</ept> type defines an option set for the four directions you can move in a game.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、<bpt i="9" x="9">&lt;c9&gt;</bpt>Direction<ept i="9">&lt;/c9&gt;</ept>型はオプションセットをあるゲームにおいてあなたが動かせる４つの方向のために定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the <bpt i="9" x="9">&lt;c9&gt;</bpt>remove<bpt i="10" x="10">&lt;w10&gt;</bpt>Subrange(_:)<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> method is implemented by calling <bpt i="11" x="11">&lt;c11&gt;</bpt>replace<bpt i="12" x="12">&lt;w12&gt;</bpt>Subrange(_:<bpt i="13" x="13">&lt;w13&gt;</bpt>with:)<ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> with an empty collection for the <bpt i="14" x="14">&lt;c14&gt;</bpt>new<bpt i="15" x="15">&lt;w15&gt;</bpt>Elements<ept i="15">&lt;/w15&gt;</ept><ept i="14">&lt;/c14&gt;</ept> parameter.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、<bpt i="9" x="9">&lt;c9&gt;</bpt>remove<bpt i="10" x="10">&lt;w10&gt;</bpt>Subrange(_:)<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>メソッドは、<bpt i="11" x="11">&lt;c11&gt;</bpt>replace<bpt i="12" x="12">&lt;w12&gt;</bpt>Subrange(_:<bpt i="13" x="13">&lt;w13&gt;</bpt>with:)<ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>を<bpt i="14" x="14">&lt;c14&gt;</bpt>new<bpt i="15" x="15">&lt;w15&gt;</bpt>Elements<ept i="15">&lt;/w15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>パラメータに対して空のコレクションで呼び出すことによって実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the following conversions result in <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、次の変換は<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>という結果になります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the following conversions result in <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、以下の変換は<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>という結果になります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the integer value 1050 can be represented in its entirety as the string “1050”.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、整数値1050はそっくりそのまま文字列「1050」として表されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the number <bpt i="0" x="0">&lt;e0&gt;</bpt>-8<ept i="0">&lt;/e0&gt;</ept> has three trailing zeros.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、数<bpt i="0" x="0">&lt;e0&gt;</bpt>-8<ept i="0">&lt;/e0&gt;</ept>は後に続くゼロを３つ持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the output formatting for a <bpt i="2" x="2">&lt;a2&gt;</bpt><bpt i="3" x="3">&lt;c3&gt;</bpt>JSONEncoder<ept i="3">&lt;/c3&gt;</ept><ept i="2">&lt;/a2&gt;</ept> instance can be sorted and can use ample white space at the same time, so it's valid to specify both options in an option set: <bpt i="4" x="4">&lt;c4&gt;</bpt>[.sorted, .pretty<bpt i="5" x="5">&lt;w5&gt;</bpt>Printed]<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、<bpt i="2" x="2">&lt;a2&gt;</bpt><bpt i="3" x="3">&lt;c3&gt;</bpt>JSONEncoder<ept i="3">&lt;/c3&gt;</ept><ept i="2">&lt;/a2&gt;</ept>インスタンスに対する出力書式設定は、ソート可能です、そして同時に豊富な空白を使用可能です、それでそれは両方のオプションをあるオプションセットにおいて指定することは有効です：<bpt i="4" x="4">&lt;c4&gt;</bpt>[.sorted, .pretty<bpt i="5" x="5">&lt;w5&gt;</bpt>Printed]<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the result of the failable <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept> initializer is unconditionally unwrapped in the example below.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、この失敗できる<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>イニシャライザの結果は、下の例において無条件にアンラップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the size of a <bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept> instance is <bpt i="1" x="1">&lt;c1&gt;</bpt>Memory<bpt i="2" x="2">&lt;w2&gt;</bpt>Layout&lt;Double&gt;.size<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept>インスタンスのサイズは、<bpt i="1" x="1">&lt;c1&gt;</bpt>Memory<bpt i="2" x="2">&lt;w2&gt;</bpt>Layout&lt;Double&gt;.size<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, this <bpt i="3" x="3">&lt;c3&gt;</bpt>Weekday<ept i="3">&lt;/c3&gt;</ept> enumeration provides static methods that return a random day of the week:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、この<bpt i="3" x="3">&lt;c3&gt;</bpt>Weekday<ept i="3">&lt;/c3&gt;</ept>列挙は、無作為な曜日を返す静的メソッドを提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, to display the last twenty children of a mirror if they can be accessed efficiently, you write the following code:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あるミラーの最後の20個の子を表示するにはそれらが効率的にアクセスされるならば、あなたは以下のコードを書きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, to get the reversed version of a string, reverse its characters and initialize a new <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> instance from the result.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、ある文字列の逆版を得るには、それの文字を逆にして、新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>インスタンスをその結果から初期化してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, to specify a nonnullable pointer to a nullable object reference, use <bpt i="6" x="6">&lt;c6&gt;</bpt>_Nullable id * _Nonnull<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、ヌル可能性オブジェクト参照への非ヌル可能性ポインタを指定するには、<bpt i="6" x="6">&lt;c6&gt;</bpt>_Nullable id * _Nonnull<ept i="6">&lt;/c6&gt;</ept>を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, using a <bpt i="0" x="0">&lt;c0&gt;</bpt>Partial<bpt i="1" x="1">&lt;w1&gt;</bpt>Range<bpt i="2" x="2">&lt;w2&gt;</bpt>From<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> range expression with an array accesses the subrange from the start of the range expression until the end of the array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>Partial<bpt i="1" x="1">&lt;w1&gt;</bpt>Range<bpt i="2" x="2">&lt;w2&gt;</bpt>From<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>範囲式をある配列で使うことは、その下位範囲に範囲式の始まりから配列の終わりまでにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, using the negation operator (prefix <bpt i="0" x="0">&lt;c0&gt;</bpt>-<ept i="0">&lt;/c0&gt;</ept>) with <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<bpt i="2" x="2">&lt;w2&gt;</bpt>.min<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> results in a runtime error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、否定演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>-<ept i="0">&lt;/c0&gt;</ept>）を<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<bpt i="2" x="2">&lt;w2&gt;</bpt>.min<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>と使うことは、実行時エラーという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, when converting a 16-bit value to an 8-bit type, only the lower 8 bits of <bpt i="3" x="3">&lt;c3&gt;</bpt>source<ept i="3">&lt;/c3&gt;</ept> are used.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、16bit値を8bit型へ変換する場合、<bpt i="3" x="3">&lt;c3&gt;</bpt>source<ept i="3">&lt;/c3&gt;</ept>の最も下位の8ビットが使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, when you pass an instance to the <bpt i="1" x="1">&lt;c1&gt;</bpt>dump(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>_:<bpt i="3" x="3">&lt;w3&gt;</bpt>_:<bpt i="4" x="4">&lt;w4&gt;</bpt>_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> function, a mirror is used to render that instance’s runtime contents.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたがあるインスタンスを<bpt i="1" x="1">&lt;c1&gt;</bpt>dump(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>_:<bpt i="3" x="3">&lt;w3&gt;</bpt>_:<bpt i="4" x="4">&lt;w4&gt;</bpt>_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>関数に渡す場合、あるミラーがそのインスタンスのもつ実行時の内容を描画するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you can add elements to an array of strings by calling any of the inserting or appending operations that the <bpt i="0" x="0">&lt;c0&gt;</bpt>Range<bpt i="1" x="1">&lt;w1&gt;</bpt>Replaceable<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol defines.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたはいくつかの要素をある配列に加えることが、<bpt i="0" x="0">&lt;c0&gt;</bpt>Range<bpt i="1" x="1">&lt;w1&gt;</bpt>Replaceable<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルが定義する何らかの挿入または追加を行う演算を呼び出すことによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you can concatenate the elements of a <bpt i="1" x="1">&lt;c1&gt;</bpt>Range&lt;Int&gt;<ept i="1">&lt;/c1&gt;</ept> instance and an integer array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたはある<bpt i="1" x="1">&lt;c1&gt;</bpt>Range&lt;Int&gt;<ept i="1">&lt;/c1&gt;</ept>インスタンスとある整数配列とに属する要素を連結することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you can concatenate the elements of an integer array and a <bpt i="1" x="1">&lt;c1&gt;</bpt>Range&lt;Int&gt;<ept i="1">&lt;/c1&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたはある整数配列とある<bpt i="1" x="1">&lt;c1&gt;</bpt>Range&lt;Int&gt;<ept i="1">&lt;/c1&gt;</ept>インスタンスとに属する要素を連結することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you can concatenate the elements of two integer arrays.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたは２つの整数配列に属する要素を連結することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you can double the elements of an array of doubles or a range of integers:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたはdoubleのある配列または整数のある範囲の要素を倍にできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you can efficiently test a set for membership of an element or check its intersection with another set:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたはある要素の帰属について能率的にテストすること、またはそれの別の集合との交差を調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you can replace an element of an array by using its subscript.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたは配列の中のある要素をそれの添え字を使うことによって置き換えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you can shuffle the numbers between <bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>9<ept i="1">&lt;/c1&gt;</ept> by calling the <bpt i="2" x="2">&lt;c2&gt;</bpt>shuffled()<ept i="2">&lt;/c2&gt;</ept> method on that range:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>9<ept i="1">&lt;/c1&gt;</ept>の間の数をシャッフルすることが、<bpt i="2" x="2">&lt;c2&gt;</bpt>shuffled()<ept i="2">&lt;/c2&gt;</ept>メソッドをその範囲上で呼び出すことによって可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you can shuffle the numbers between <bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>9<ept i="1">&lt;/c1&gt;</ept> by calling the <bpt i="2" x="2">&lt;c2&gt;</bpt>shuffled(using:)<ept i="2">&lt;/c2&gt;</ept> method on that range:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>9<ept i="1">&lt;/c1&gt;</ept>の間の数をシャッフルすることが、<bpt i="2" x="2">&lt;c2&gt;</bpt>shuffled(using:)<ept i="2">&lt;/c2&gt;</ept>メソッドをその範囲上で呼び出すことによって可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you can sort <bpt i="0" x="0">&lt;e0&gt;</bpt>part<ept i="0">&lt;/e0&gt;</ept> of a mutable collection by calling the mutable <bpt i="1" x="1">&lt;c1&gt;</bpt>sort()<ept i="1">&lt;/c1&gt;</ept> method on a subscripted subsequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたはある可変コレクションの<bpt i="0" x="0">&lt;e0&gt;</bpt>一部分<ept i="0">&lt;/e0&gt;</ept>をソートすることが可変<bpt i="1" x="1">&lt;c1&gt;</bpt>sort()<ept i="1">&lt;/c1&gt;</ept>メソッドを添え字で指定した下位シーケンス上で行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you can test whether the first <bpt i="3" x="3">&lt;c3&gt;</bpt>UInt8<ept i="3">&lt;/c3&gt;</ept> value in a string’s UTF-8 encoding is equal to the first <bpt i="4" x="4">&lt;c4&gt;</bpt>UInt32<ept i="4">&lt;/c4&gt;</ept> value in its Unicode scalar view:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたはある文字列のUTF-8符号化の中の最初の<bpt i="3" x="3">&lt;c3&gt;</bpt>UInt8<ept i="3">&lt;/c3&gt;</ept>値が、それのユニコードスカラー値での最初の<bpt i="4" x="4">&lt;c4&gt;</bpt>UInt32<ept i="4">&lt;/c4&gt;</ept>と等しいかどうかを試験できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you can test whether the first <bpt i="3" x="3">&lt;c3&gt;</bpt>UInt8<ept i="3">&lt;/c3&gt;</ept> value in a string’s UTF-8 encoding is not equal to the first <bpt i="4" x="4">&lt;c4&gt;</bpt>UInt32<ept i="4">&lt;/c4&gt;</ept> value in its Unicode scalar view:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたはある文字列のUTF-8符号化の中の最初の<bpt i="3" x="3">&lt;c3&gt;</bpt>UInt8<ept i="3">&lt;/c3&gt;</ept>値が、それのユニコードスカラー値での最初の<bpt i="4" x="4">&lt;c4&gt;</bpt>UInt32<ept i="4">&lt;/c4&gt;</ept>と等しくないかどうかを試験できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you can use the <bpt i="0" x="0">&lt;c0&gt;</bpt>shuffle(using:)<ept i="0">&lt;/c0&gt;</ept> method to randomly reorder the elements of an array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>shuffle(using:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使って、配列の要素を無作為に再配列することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたはこのメソッドを整数からなる配列で使うことで、隣接する同等の項目をフィルタしたり頻度を数えたりできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you can use this method on an array of numbers to find their sum or product.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたはこのメソッドを数値いくつかからなる配列で使うことで、それらの和または積を見つけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you could create an <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<bpt i="1" x="1">&lt;w1&gt;</bpt>Pairs<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> structure that holds a list of two-integer tuples and use an initializer that accepts a <bpt i="2" x="2">&lt;c2&gt;</bpt>Key<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<bpt i="4" x="4">&lt;w4&gt;</bpt>Pairs<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<bpt i="1" x="1">&lt;w1&gt;</bpt>Pairs<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>構造体を作成することができます、それは２整数のタプルのリストを保持して、<bpt i="2" x="2">&lt;c2&gt;</bpt>Key<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<bpt i="4" x="4">&lt;w4&gt;</bpt>Pairs<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスを受け入れるイニシャライザを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you create an empty <bpt i="0" x="0">&lt;c0&gt;</bpt>Set<ept i="0">&lt;/c0&gt;</ept> instance with either this initializer or with an empty array literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたは空の<bpt i="0" x="0">&lt;c0&gt;</bpt>Set<ept i="0">&lt;/c0&gt;</ept>インスタンスを、このイニシャライザでまたは空の配列リテラルでのどちらかで作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you may need to serialize the result or pass it as a value to another part of your app that handles the result data.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたは結果をシリアライズするまたはそれをある値としてあなたのアプリの別の部分に、結果データを処理するものに渡す必要があるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you may run a series of randomness tests and compute the statistical average of both a range of numbers returned from a random number generator, as well as the failure rate of calling the API.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたは一連の無作為性テストを走らせて、無作為数生成子から返されたある範囲の数、それだけでなくそのAPI呼び出しの失敗割合の両方の統計上の平均を計算するかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you might replace an Objective-C constant with a Swift constant that's nested inside a containing Swift type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたはObjective-C定数を、含んでいるSwift型の内部に入れ子にされるSwift定数と置き換えるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you might typically use a <bpt i="2" x="2">&lt;c2&gt;</bpt>for<ept i="2">&lt;/c2&gt;</ept>-<bpt i="3" x="3">&lt;c3&gt;</bpt>in<ept i="3">&lt;/c3&gt;</ept> loop to print each of the elements in an array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたは概して<bpt i="2" x="2">&lt;c2&gt;</bpt>for<ept i="2">&lt;/c2&gt;</ept>-<bpt i="3" x="3">&lt;c3&gt;</bpt>in<ept i="3">&lt;/c3&gt;</ept>ループを使って、ある配列の中の各要素を出力するかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For instances of <bpt i="6" x="6">&lt;c6&gt;</bpt>NSSet<ept i="6">&lt;/c6&gt;</ept> that are already immutable, <bpt i="7" x="7">&lt;c7&gt;</bpt>copy(with:)<ept i="7">&lt;/c7&gt;</ept> returns the same set in constant time; otherwise, the copying performance is unspecified.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>元から不変である<bpt i="6" x="6">&lt;c6&gt;</bpt>NSSet<ept i="6">&lt;/c6&gt;</ept>のインスタンスに対しては、<bpt i="7" x="7">&lt;c7&gt;</bpt>copy(with:)<ept i="7">&lt;/c7&gt;</ept>は同じ集合を定数時間で返します；そうでなければ、コピーすることの性能は不定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For integer types, any remainder of the division is discarded.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>整数型に対して、除算の余りは何であれ破棄されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For more about arithmetic with overflow operators, see <bpt i="0" x="0">&lt;a0&gt;</bpt>Overflow Operators<ept i="0">&lt;/a0&gt;</ept> in <bpt i="1" x="1">&lt;e1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>The Swift Programming Language<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オーバーフロー演算子を使う算術についてさらには、<bpt i="0" x="0">&lt;a0&gt;</bpt>オーバーフロー演算子<ept i="0">&lt;/a0&gt;</ept>を<bpt i="1" x="1">&lt;e1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Swiftプログラミング言語<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/e1&gt;</ept>で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For more information about list format styles, see <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>List<bpt i="2" x="2">&lt;w2&gt;</bpt>Format<bpt i="3" x="3">&lt;w3&gt;</bpt>Style<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>リスト書式形式についてのさらなる情報として、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>List<bpt i="2" x="2">&lt;w2&gt;</bpt>Format<bpt i="3" x="3">&lt;w3&gt;</bpt>Style<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For more information, see <bpt i="0" x="0">&lt;a0&gt;</bpt>Objective-C and C Code Customization<ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>詳細は、<bpt i="0" x="0">&lt;a0&gt;</bpt>Objective-CとCコードのカスタム化<ept i="0">&lt;/a0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For most purposes, the <bpt i="0" x="0">&lt;c0&gt;</bpt>Managed<bpt i="1" x="1">&lt;w1&gt;</bpt>Buffer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> class works fine for this purpose, and can simply be used on its own.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ほとんどの用途に対して、<bpt i="0" x="0">&lt;c0&gt;</bpt>Managed<bpt i="1" x="1">&lt;w1&gt;</bpt>Buffer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>クラスはこの目的のためにすぐれて機能します、そして簡単に単独で使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For operations that require adding or removing elements, see the <bpt i="2" x="2">&lt;c2&gt;</bpt>Range<bpt i="3" x="3">&lt;w3&gt;</bpt>Replaceable<bpt i="4" x="4">&lt;w4&gt;</bpt>Collection<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol instead.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要素の追加や削除を要求する演算に対しては、<bpt i="2" x="2">&lt;c2&gt;</bpt>Range<bpt i="3" x="3">&lt;w3&gt;</bpt>Replaceable<bpt i="4" x="4">&lt;w4&gt;</bpt>Collection<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルを代わりに見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For ordinary sets, an element equal to <bpt i="0" x="0">&lt;c0&gt;</bpt>member<ept i="0">&lt;/c0&gt;</ept> if <bpt i="1" x="1">&lt;c1&gt;</bpt>member<ept i="1">&lt;/c1&gt;</ept> is contained in the set; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>普通の集合に対して、<bpt i="1" x="1">&lt;c1&gt;</bpt>member<ept i="1">&lt;/c1&gt;</ept>が集合に含まれているならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>member<ept i="0">&lt;/c0&gt;</ept>に等しい要素；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For ordinary sets, an element equal to <bpt i="0" x="0">&lt;c0&gt;</bpt>new<bpt i="1" x="1">&lt;w1&gt;</bpt>Member<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if the set already contained such a member; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>普通の集合に対して、集合がすでにそのようなメンバを含んでいるならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>new<bpt i="1" x="1">&lt;w1&gt;</bpt>Member<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に等しい要素；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For other collections the counters may be out of range or of the wrong type to use as an index.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>他のコレクションに対してこれらのカウンタは、インデックスとして使うのには範囲外または間違った型になるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For sets where the set type and element type are the same, like <bpt i="0" x="0">&lt;c0&gt;</bpt>Option<bpt i="1" x="1">&lt;w1&gt;</bpt>Set<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> types, this method returns any intersection between the set and <bpt i="2" x="2">&lt;c2&gt;</bpt>[member]<ept i="2">&lt;/c2&gt;</ept>, or <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept> if the intersection is empty.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Option<bpt i="1" x="1">&lt;w1&gt;</bpt>Set<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型など、集合型と要素型が同じであるところの集合に対して、このメソッドは集合と<bpt i="2" x="2">&lt;c2&gt;</bpt>[member]<ept i="2">&lt;/c2&gt;</ept>の間の何らかの交叉、または交叉が空ならば<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For sets where the set type and element type are the same, like <bpt i="0" x="0">&lt;c0&gt;</bpt>Option<bpt i="1" x="1">&lt;w1&gt;</bpt>Set<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> types, this method returns any intersection between the set and <bpt i="2" x="2">&lt;c2&gt;</bpt>[new<bpt i="3" x="3">&lt;w3&gt;</bpt>Member]<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, or <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept> if the intersection is empty.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Option<bpt i="1" x="1">&lt;w1&gt;</bpt>Set<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型など、集合型と要素型が同じであるところの集合に対して、このメソッドは集合と<bpt i="2" x="2">&lt;c2&gt;</bpt>[new<bpt i="3" x="3">&lt;w3&gt;</bpt>Member]<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の間の何らかの交叉、または交叉が空ならば<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For signed integer types, this value is <bpt i="0" x="0">&lt;c0&gt;</bpt>(2 ** (bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Width - 1)) - 1<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, where <bpt i="2" x="2">&lt;c2&gt;</bpt>**<ept i="2">&lt;/c2&gt;</ept> is exponentiation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>符号付き整数型に対して、この値は<bpt i="0" x="0">&lt;c0&gt;</bpt>(2 ** (bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Width - 1)) - 1<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>です、そこで<bpt i="2" x="2">&lt;c2&gt;</bpt>**<ept i="2">&lt;/c2&gt;</ept>は冪演算です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For signed integer types, this value is <bpt i="0" x="0">&lt;c0&gt;</bpt>-(2 ** (bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Width - 1))<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, where <bpt i="2" x="2">&lt;c2&gt;</bpt>**<ept i="2">&lt;/c2&gt;</ept> is exponentiation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>符号付き整数型に対して、この値は<bpt i="0" x="0">&lt;c0&gt;</bpt>-(2 ** (bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Width - 1))<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>です、そこで<bpt i="2" x="2">&lt;c2&gt;</bpt>**<ept i="2">&lt;/c2&gt;</ept>は冪演算です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For the <bpt i="6" x="6">&lt;c6&gt;</bpt>Shipping<bpt i="7" x="7">&lt;w7&gt;</bpt>Options<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> declaration, see the <bpt i="8" x="8">&lt;c8&gt;</bpt>Option<bpt i="9" x="9">&lt;w9&gt;</bpt>Set<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> protocol discussion.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt>Shipping<bpt i="7" x="7">&lt;w7&gt;</bpt>Options<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>宣言については、<bpt i="8" x="8">&lt;c8&gt;</bpt>Option<bpt i="9" x="9">&lt;w9&gt;</bpt>Set<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>プロトコル解説を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For the inherited methods to work properly, conforming types must meet the following axioms.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>継承されたメソッドを適切に働かせるためには、準拠する型は以下の原則に応じる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For two integers <bpt i="0" x="0">&lt;e0&gt;</bpt>a<ept i="0">&lt;/e0&gt;</ept> and <bpt i="1" x="1">&lt;e1&gt;</bpt>b<ept i="1">&lt;/e1&gt;</ept>, <bpt i="2" x="2">&lt;e2&gt;</bpt>a<ept i="2">&lt;/e2&gt;</ept> is a multiple of <bpt i="3" x="3">&lt;e3&gt;</bpt>b<ept i="3">&lt;/e3&gt;</ept> if there exists a third integer <bpt i="4" x="4">&lt;e4&gt;</bpt>q<ept i="4">&lt;/e4&gt;</ept> such that <bpt i="5" x="5">&lt;e5&gt;</bpt>a = q*b<ept i="5">&lt;/e5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの整数<bpt i="0" x="0">&lt;e0&gt;</bpt>a<ept i="0">&lt;/e0&gt;</ept>と<bpt i="1" x="1">&lt;e1&gt;</bpt>b<ept i="1">&lt;/e1&gt;</ept>に対して、<bpt i="2" x="2">&lt;e2&gt;</bpt>a<ept i="2">&lt;/e2&gt;</ept>は<bpt i="3" x="3">&lt;e3&gt;</bpt>b<ept i="3">&lt;/e3&gt;</ept>の倍数です、もし第３の整数<bpt i="4" x="4">&lt;e4&gt;</bpt>q<ept i="4">&lt;/e4&gt;</ept>が存在して、<bpt i="5" x="5">&lt;e5&gt;</bpt>a = q*b<ept i="5">&lt;/e5&gt;</ept>であるようなところでは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For two values <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept>, and a distance <bpt i="2" x="2">&lt;c2&gt;</bpt>n = x<bpt i="3" x="3">&lt;w3&gt;</bpt>.distance(to: y)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>x<bpt i="5" x="5">&lt;w5&gt;</bpt>.advanced(by: n) == y<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの値<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept>、そして隔たり<bpt i="2" x="2">&lt;c2&gt;</bpt>n = x<bpt i="3" x="3">&lt;w3&gt;</bpt>.distance(to: y)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に対して、<bpt i="4" x="4">&lt;c4&gt;</bpt>x<bpt i="5" x="5">&lt;w5&gt;</bpt>.advanced(by: n) == y<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For your type to automatically receive default implementations for set-related operations, the <bpt i="2" x="2">&lt;c2&gt;</bpt>raw<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> property must be of a type that conforms to the <bpt i="4" x="4">&lt;c4&gt;</bpt>Fixed<bpt i="5" x="5">&lt;w5&gt;</bpt>Width<bpt i="6" x="6">&lt;w6&gt;</bpt>Integer<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> protocol, such as <bpt i="7" x="7">&lt;c7&gt;</bpt>Int<ept i="7">&lt;/c7&gt;</ept> or <bpt i="8" x="8">&lt;c8&gt;</bpt>UInt8<ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたの型が自動的に省略時の実装をセット関連の演算に対して受け取るようにするには、<bpt i="2" x="2">&lt;c2&gt;</bpt>raw<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロパティは、<bpt i="4" x="4">&lt;c4&gt;</bpt>Fixed<bpt i="5" x="5">&lt;w5&gt;</bpt>Width<bpt i="6" x="6">&lt;w6&gt;</bpt>Integer<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>プロトコルに準拠する型の１つでなければなりません、例えば<bpt i="7" x="7">&lt;c7&gt;</bpt>Int<ept i="7">&lt;/c7&gt;</ept>または<bpt i="8" x="8">&lt;c8&gt;</bpt>UInt8<ept i="8">&lt;/c8&gt;</ept>など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Formatting a Sequence</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスを書式設定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Foundation</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ファウンデーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Framework</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>フレームワーク</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>From Protocol</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>由来プロトコル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Generates a default mirror for all ancestor classes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>全ての先祖クラスに対して省略時のミラーを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Generates a locale-aware string representation of a sequence using the default list format style.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンスのロケールを意識した文字列表現を省略時のリスト書式形式を使って生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Generates a locale-aware string representation of a sequence using the provided list format style.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンスのロケールを意識した文字列表現をこの提供されたリスト書式形式を使って生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Generating Random Binary Data</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>無作為なバイナリデータを生成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Generic Instance Method</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>総称体インスタンスメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Generic Type Alias</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>総称体型エイリアス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Getting a dictionary’s value using a key returns an optional value, so <bpt i="0" x="0">&lt;c0&gt;</bpt>image<bpt i="1" x="1">&lt;w1&gt;</bpt>Paths["star"]<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> has type <bpt i="2" x="2">&lt;c2&gt;</bpt>Optional&lt;String&gt;<ept i="2">&lt;/c2&gt;</ept> or, written in the preferred manner, <bpt i="3" x="3">&lt;c3&gt;</bpt>String?<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書の持つ値をあるキーを使って取得することはあるオプショナル値を返します、それで<bpt i="0" x="0">&lt;c0&gt;</bpt>image<bpt i="1" x="1">&lt;w1&gt;</bpt>Paths["star"]<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は型<bpt i="2" x="2">&lt;c2&gt;</bpt>Optional&lt;String&gt;<ept i="2">&lt;/c2&gt;</ept>または、より好ましい流儀で書かれて、<bpt i="3" x="3">&lt;c3&gt;</bpt>String?<ept i="3">&lt;/c3&gt;</ept>を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Given a sequence of rectangular regions and associated colors, fills those regions in the current graphics context with the context’s fill color.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>矩形領域それらと関連色それらからなるあるシーケンスを与えられて、それらの領域を現在のグラフィクス文脈の中でその文脈のもつ塗りつぶし色で塗りつぶします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Given a sequence of rectangular regions and associated colors, fills those regions in the current graphics context.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>矩形領域それらと関連色それらからなるあるシーケンスを与えられて、それらの領域を現在のグラフィクス文脈の中で塗りつぶします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Given a sequence of rectangular regions and gray component values, fills those regions in the current graphics context.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>矩形領域それらとグレー成分値それらからなるあるシーケンスを与えられて、それらの領域を現在のグラフィクス文脈の中で塗りつぶします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Given a sequence of rectangular regions, modifies the current graphics context clipping path by intersecting it with the union of these rectangles.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>矩形領域それらからなるあるシーケンスを与えられて、現在のグラフィクス文脈クリッピングパスを、それをそれら矩形の合併と交差させることによって修正します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Grouping Related Objective-C Constants</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>関連するObjective-C定数をグループにする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Handling Dynamically Typed Methods and Objects in Swift</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>動的に型付メソッドとオブジェクトをSwiftにおいて取り扱う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Hash values are not guaranteed to be equal across different executions of your program.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ハッシュ値は、あなたのプログラムの異なる実行をまたいで等しいことを保証されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Hashes the elements of the vector using the given hasher.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ベクターの要素をこの与えられたハーシャーを使ってハッシュ化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Hashes the essential components of this value by feeding them into the given hasher.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値の本質的な構成要素を、それらをその与えられたhasherへと与えることによって、ハッシュ化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here a default path is supplied for an image that is missing from <bpt i="3" x="3">&lt;c3&gt;</bpt>image<bpt i="4" x="4">&lt;w4&gt;</bpt>Paths<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここで省略時のパスは、<bpt i="3" x="3">&lt;c3&gt;</bpt>image<bpt i="4" x="4">&lt;w4&gt;</bpt>Paths<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>から見つからない画像に対して提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here's how Swift imports the related functions above into a single type:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここに、Swiftが上での関連した関数をある単一の型へとインポートする方法があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here's how the <bpt i="0" x="0">&lt;c0&gt;</bpt>Traffic<bpt i="1" x="1">&lt;w1&gt;</bpt>Light<bpt i="2" x="2">&lt;w2&gt;</bpt>Color<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type is imported to Swift:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここに、<bpt i="0" x="0">&lt;c0&gt;</bpt>Traffic<bpt i="1" x="1">&lt;w1&gt;</bpt>Light<bpt i="2" x="2">&lt;w2&gt;</bpt>Color<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型がSwiftへとインポートされる方法があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here's how the <bpt i="0" x="0">&lt;c0&gt;</bpt>UIView<bpt i="1" x="1">&lt;w1&gt;</bpt>Autoresizing<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type is imported to Swift:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここに、<bpt i="0" x="0">&lt;c0&gt;</bpt>UIView<bpt i="1" x="1">&lt;w1&gt;</bpt>Autoresizing<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型がSwiftへとインポートされる方法があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here, a set of strings is created from an array literal holding only strings.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここでは、文字列の集合が文字列のみを保持する配列リテラルから作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here, a set of strings is created from an array literal holding only strings:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここでは、文字列の集合が文字列のみを保持する配列リテラルから作成されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here, three elements in the middle of an array of integers are replaced by the five elements of a <bpt i="3" x="3">&lt;c3&gt;</bpt>Repeated&lt;Int&gt;<ept i="3">&lt;/c3&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここでは、整数からなるある配列の真ん中の３つの要素が<bpt i="3" x="3">&lt;c3&gt;</bpt>Repeated&lt;Int&gt;<ept i="3">&lt;/c3&gt;</ept>インスタンスの５つの要素によって置き換えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here’s a definition of a <bpt i="0" x="0">&lt;c0&gt;</bpt>Countdown<ept i="0">&lt;/c0&gt;</ept> sequence that serves as its own iterator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここに<bpt i="0" x="0">&lt;c0&gt;</bpt>Countdown<ept i="0">&lt;/c0&gt;</ept>シーケンスの定義があります、それはそれ自身イテレータとしての務めを果たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here’s an example of creating an array initialized with five strings containing the letter <bpt i="0" x="0">&lt;e0&gt;</bpt>Z<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここに、字<bpt i="0" x="0">&lt;e0&gt;</bpt>Z<ept i="0">&lt;/e0&gt;</ept>を含んでいる５つの文字列で初期化される配列を作成する例があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here’s an example of inserting a range of integers into an array of the same type:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここに整数の範囲を同じ型の配列へ挿入する例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here’s an example of sorting a list of students’ names.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここに、生徒名のリストをソートする例があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here’s an example that finds a student name that begins with the letter “A”:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここに、文字「A」で始まる生徒名を見つける例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here’s an example that sorts the first half of an array of integers:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここにある例があります、それは整数からなるある配列の前半分をソートします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here’s an implementation of the <bpt i="0" x="0">&lt;c0&gt;</bpt>reduce1(_:)<ept i="0">&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここに<bpt i="0" x="0">&lt;c0&gt;</bpt>reduce1(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドの実装があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here’s how to find the longest string in a sequence, using the <bpt i="1" x="1">&lt;c1&gt;</bpt>animals<ept i="1">&lt;/c1&gt;</ept> array introduced earlier as an example:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここに最も長い文字列をあるシーケンスの中で見つける方法があります、前に導入された<bpt i="1" x="1">&lt;c1&gt;</bpt>animals<ept i="1">&lt;/c1&gt;</ept>配列を例として使っています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>However, if you pass <bpt i="0" x="0">&lt;c0&gt;</bpt>19<ept i="0">&lt;/c0&gt;</ept> as <bpt i="1" x="1">&lt;c1&gt;</bpt>rhs<ept i="1">&lt;/c1&gt;</ept>, the method first bitmasks <bpt i="2" x="2">&lt;c2&gt;</bpt>rhs<ept i="2">&lt;/c2&gt;</ept> to <bpt i="3" x="3">&lt;c3&gt;</bpt>3<ept i="3">&lt;/c3&gt;</ept>, and then uses that masked value as the number of bits to shift <bpt i="4" x="4">&lt;c4&gt;</bpt>lhs<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>しかしながら、あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>19<ept i="0">&lt;/c0&gt;</ept>を<bpt i="1" x="1">&lt;c1&gt;</bpt>rhs<ept i="1">&lt;/c1&gt;</ept>として渡すならば、このメソッドは最初に<bpt i="2" x="2">&lt;c2&gt;</bpt>rhs<ept i="2">&lt;/c2&gt;</ept>を<bpt i="3" x="3">&lt;c3&gt;</bpt>3<ept i="3">&lt;/c3&gt;</ept>にビットマスクして、それからそのマスクされた値をビット数として使うことで<bpt i="4" x="4">&lt;c4&gt;</bpt>lhs<ept i="4">&lt;/c4&gt;</ept>をシフトします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>However, if you use <bpt i="0" x="0">&lt;c0&gt;</bpt>19<ept i="0">&lt;/c0&gt;</ept> as <bpt i="1" x="1">&lt;c1&gt;</bpt>rhs<ept i="1">&lt;/c1&gt;</ept>, the operation first bitmasks <bpt i="2" x="2">&lt;c2&gt;</bpt>rhs<ept i="2">&lt;/c2&gt;</ept> to <bpt i="3" x="3">&lt;c3&gt;</bpt>3<ept i="3">&lt;/c3&gt;</ept>, and then uses that masked value as the number of bits to shift <bpt i="4" x="4">&lt;c4&gt;</bpt>lhs<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>しかしながら、あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>19<ept i="0">&lt;/c0&gt;</ept>を<bpt i="1" x="1">&lt;c1&gt;</bpt>rhs<ept i="1">&lt;/c1&gt;</ept>として使うならば、この演算は最初に<bpt i="2" x="2">&lt;c2&gt;</bpt>rhs<ept i="2">&lt;/c2&gt;</ept>を<bpt i="3" x="3">&lt;c3&gt;</bpt>3<ept i="3">&lt;/c3&gt;</ept>にビットマスクして、それからそのマスクされた値をビット数として使うことで<bpt i="4" x="4">&lt;c4&gt;</bpt>lhs<ept i="4">&lt;/c4&gt;</ept>をシフトします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>However, if you use <bpt i="0" x="0">&lt;c0&gt;</bpt>8<ept i="0">&lt;/c0&gt;</ept> as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>しかしながら、あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>8<ept i="0">&lt;/c0&gt;</ept>をシフト量として使うならば、メソッドは最初にそのシフト量をマスクしてゼロにして、それからシフトを実行して、元の値に対して変更しないという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>However, in cases where objects of various different classes must serve as storage, <bpt i="2" x="2">&lt;c2&gt;</bpt>Managed<bpt i="3" x="3">&lt;w3&gt;</bpt>Buffer<bpt i="4" x="4">&lt;w4&gt;</bpt>Pointer<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is needed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>しかしながら、種々の異なるクラスのオブジェクトがストレージとして供されなければならない場合には、<bpt i="2" x="2">&lt;c2&gt;</bpt>Managed<bpt i="3" x="3">&lt;w3&gt;</bpt>Buffer<bpt i="4" x="4">&lt;w4&gt;</bpt>Pointer<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が必要とされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>However, in optimized builds (<bpt i="3" x="3">&lt;c3&gt;</bpt>-O<ept i="3">&lt;/c3&gt;</ept>), no check is performed to ensure that the current instance actually has a value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>しかしながら、最適化ビルド（<bpt i="3" x="3">&lt;c3&gt;</bpt>-O<ept i="3">&lt;/c3&gt;</ept>）において、現在のインスタンスが実際に値を持つか確かめる確認は全く実行されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>However, in order to meet the complexity guarantees of a random-access collection, either the index for your custom type must conform to the <bpt i="8" x="8">&lt;c8&gt;</bpt>Strideable<ept i="8">&lt;/c8&gt;</ept> protocol or you must implement the <bpt i="9" x="9">&lt;c9&gt;</bpt>index(_:<bpt i="10" x="10">&lt;w10&gt;</bpt>offset<bpt i="11" x="11">&lt;w11&gt;</bpt>By:)<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> and <bpt i="12" x="12">&lt;c12&gt;</bpt>distance(from:<bpt i="13" x="13">&lt;w13&gt;</bpt>to:)<ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> methods with O(1) efficiency.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>しかしながら、無作為アクセスコレクションの計算量（複雑さ）保証を達成する手段として、あなたのあつらえの型に対するインデックスが<bpt i="8" x="8">&lt;c8&gt;</bpt>Strideable<ept i="8">&lt;/c8&gt;</ept>プロトコルに準拠する、またはあなたが<bpt i="9" x="9">&lt;c9&gt;</bpt>index(_:<bpt i="10" x="10">&lt;w10&gt;</bpt>offset<bpt i="11" x="11">&lt;w11&gt;</bpt>By:)<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>と<bpt i="12" x="12">&lt;c12&gt;</bpt>distance(from:<bpt i="13" x="13">&lt;w13&gt;</bpt>to:)<ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>メソッドをO(1)の効率で実装する、いずれかをしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>However, you can’t use the <bpt i="1" x="1">&lt;c1&gt;</bpt>throws<ept i="1">&lt;/c1&gt;</ept> keyword to model APIs that return asynchronously.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>しかしながら、あなたは<bpt i="1" x="1">&lt;c1&gt;</bpt>throws<ept i="1">&lt;/c1&gt;</ept>キーワードを使うことで、非同期に返るAPIをこしらえることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Identical to <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>と同一。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Identify a Throwing Expression to Preserve</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>スローする式を識別することで保全する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>are<bpt i="1" x="1">&lt;w1&gt;</bpt>Equivalent(a, b)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>are<bpt i="3" x="3">&lt;w3&gt;</bpt>Equivalent(b, c)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> are both <bpt i="4" x="4">&lt;c4&gt;</bpt>true<ept i="4">&lt;/c4&gt;</ept>, then <bpt i="5" x="5">&lt;c5&gt;</bpt>are<bpt i="6" x="6">&lt;w6&gt;</bpt>Equivalent(a, c)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> is also <bpt i="7" x="7">&lt;c7&gt;</bpt>true<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>are<bpt i="1" x="1">&lt;w1&gt;</bpt>Equivalent(a, b)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>are<bpt i="3" x="3">&lt;w3&gt;</bpt>Equivalent(b, c)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が両方とも<bpt i="4" x="4">&lt;c4&gt;</bpt>true<ept i="4">&lt;/c4&gt;</ept>ならば、そのとき<bpt i="5" x="5">&lt;c5&gt;</bpt>are<bpt i="6" x="6">&lt;w6&gt;</bpt>Equivalent(a, c)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>もまた<bpt i="7" x="7">&lt;c7&gt;</bpt>true<ept i="7">&lt;/c7&gt;</ept>である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>are<bpt i="1" x="1">&lt;w1&gt;</bpt>In<bpt i="2" x="2">&lt;w2&gt;</bpt>Increasing<bpt i="3" x="3">&lt;w3&gt;</bpt>Order(a, b)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>are<bpt i="5" x="5">&lt;w5&gt;</bpt>In<bpt i="6" x="6">&lt;w6&gt;</bpt>Increasing<bpt i="7" x="7">&lt;w7&gt;</bpt>Order(b, c)<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> are both <bpt i="8" x="8">&lt;c8&gt;</bpt>true<ept i="8">&lt;/c8&gt;</ept>, then <bpt i="9" x="9">&lt;c9&gt;</bpt>are<bpt i="10" x="10">&lt;w10&gt;</bpt>In<bpt i="11" x="11">&lt;w11&gt;</bpt>Increasing<bpt i="12" x="12">&lt;w12&gt;</bpt>Order(a, c)<ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> is also <bpt i="13" x="13">&lt;c13&gt;</bpt>true<ept i="13">&lt;/c13&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>are<bpt i="1" x="1">&lt;w1&gt;</bpt>In<bpt i="2" x="2">&lt;w2&gt;</bpt>Increasing<bpt i="3" x="3">&lt;w3&gt;</bpt>Order(a, b)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>are<bpt i="5" x="5">&lt;w5&gt;</bpt>In<bpt i="6" x="6">&lt;w6&gt;</bpt>Increasing<bpt i="7" x="7">&lt;w7&gt;</bpt>Order(b, c)<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>が両方とも<bpt i="8" x="8">&lt;c8&gt;</bpt>true<ept i="8">&lt;/c8&gt;</ept>ならば、そのとき<bpt i="9" x="9">&lt;c9&gt;</bpt>are<bpt i="10" x="10">&lt;w10&gt;</bpt>In<bpt i="11" x="11">&lt;w11&gt;</bpt>Increasing<bpt i="12" x="12">&lt;w12&gt;</bpt>Order(a, c)<ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>もまた<bpt i="13" x="13">&lt;c13&gt;</bpt>true<ept i="13">&lt;/c13&gt;</ept>である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>description<ept i="0">&lt;/c0&gt;</ept> is in an invalid format, or if the value it denotes in base 10 is not representable, the result is <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>description<ept i="0">&lt;/c0&gt;</ept>が無効な形式になっているならば、またはそれが底10で示す値が表現可能でないならば、結果は<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>distance &gt; 0<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>limit<ept i="1">&lt;/c1&gt;</ept> should be greater than <bpt i="2" x="2">&lt;c2&gt;</bpt>i<ept i="2">&lt;/c2&gt;</ept> to have any effect.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>distance &gt; 0<ept i="0">&lt;/c0&gt;</ept>ならば、<bpt i="1" x="1">&lt;c1&gt;</bpt>limit<ept i="1">&lt;/c1&gt;</ept>が何らかの効果を持つには<bpt i="2" x="2">&lt;c2&gt;</bpt>i<ept i="2">&lt;/c2&gt;</ept>より大きくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>distance &gt; 0<ept i="0">&lt;/c0&gt;</ept>, a limit that is less than <bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept> has no effect.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>distance &gt; 0<ept i="0">&lt;/c0&gt;</ept>ならば、<bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept>より少ない限度は効果を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>end<ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="1" x="1">&lt;c1&gt;</bpt>start<ept i="1">&lt;/c1&gt;</ept>, the result is zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>end<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>start<ept i="1">&lt;/c1&gt;</ept>に等しいならば、結果はゼロです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>, an empty subsequence is returned in the result for each consecutive pair of <bpt i="1" x="1">&lt;c1&gt;</bpt>separator<ept i="1">&lt;/c1&gt;</ept> elements in the collection and for each instance of <bpt i="2" x="2">&lt;c2&gt;</bpt>separator<ept i="2">&lt;/c2&gt;</ept> at the start or end of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>ならば、このコレクション中の連続する<bpt i="1" x="1">&lt;c1&gt;</bpt>separator<ept i="1">&lt;/c1&gt;</ept>要素の対それぞれに、そしてコレクションの始めと終わりの<bpt i="2" x="2">&lt;c2&gt;</bpt>separator<ept i="2">&lt;/c2&gt;</ept>インスタンスそれぞれに、１つの空の下位シーケンスが結果において返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>, an empty subsequence is returned in the result for each consecutive pair of <bpt i="1" x="1">&lt;c1&gt;</bpt>separator<ept i="1">&lt;/c1&gt;</ept> elements in the sequence and for each instance of <bpt i="2" x="2">&lt;c2&gt;</bpt>separator<ept i="2">&lt;/c2&gt;</ept> at the start or end of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>ならば、このシーケンス中の連続する<bpt i="1" x="1">&lt;c1&gt;</bpt>separator<ept i="1">&lt;/c1&gt;</ept>要素の対それぞれに、そしてシーケンスの始めと終わりの<bpt i="2" x="2">&lt;c2&gt;</bpt>separator<ept i="2">&lt;/c2&gt;</ept>インスタンスそれぞれに、１つの空の下位シーケンスが結果において返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the <bpt i="1" x="1">&lt;c1&gt;</bpt>is<bpt i="2" x="2">&lt;w2&gt;</bpt>Separator<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> predicate and for each element at the start or end of the collection satisfying the <bpt i="3" x="3">&lt;c3&gt;</bpt>is<bpt i="4" x="4">&lt;w4&gt;</bpt>Separator<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>ならば、結果において<bpt i="1" x="1">&lt;c1&gt;</bpt>is<bpt i="2" x="2">&lt;w2&gt;</bpt>Separator<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>述部を満たす隣接する要素のペアそれぞれに対しておよび<bpt i="3" x="3">&lt;c3&gt;</bpt>is<bpt i="4" x="4">&lt;w4&gt;</bpt>Separator<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>述部を満たすコレクションの始まりまたは終わりでの要素それぞれに対して１つの空の下位シーケンスが返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the <bpt i="1" x="1">&lt;c1&gt;</bpt>is<bpt i="2" x="2">&lt;w2&gt;</bpt>Separator<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> predicate and for each element at the start or end of the sequence satisfying the <bpt i="3" x="3">&lt;c3&gt;</bpt>is<bpt i="4" x="4">&lt;w4&gt;</bpt>Separator<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>ならば、結果において<bpt i="1" x="1">&lt;c1&gt;</bpt>is<bpt i="2" x="2">&lt;w2&gt;</bpt>Separator<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>述部を満たす隣接する要素のペアそれぞれに対しておよび<bpt i="3" x="3">&lt;c3&gt;</bpt>is<bpt i="4" x="4">&lt;w4&gt;</bpt>Separator<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>述部を満たすシーケンスの始まりまたは終わりでの要素それぞれに対して１つの空の下位シーケンスが返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Splits + 1<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> subsequences are returned, the last one is a suffix of the original collection containing the remaining elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Splits + 1<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の下位シーケンスが返されるならば、最後のものは、残りの要素を含んでいる元コレクションの後ろ部分です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Splits + 1<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Splits + 1<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の下位シーケンスが返されるならば、最後のものは、残りの要素を含んでいる元シーケンスの後ろ部分です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>new<bpt i="1" x="1">&lt;w1&gt;</bpt>Member<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is not contained in the set but subsumes current members of the set, the subsumed members are returned.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>new<bpt i="1" x="1">&lt;w1&gt;</bpt>Member<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>がこの集合の中に含まれないしかしこの集合の現在の要素を包含するならば、包含されたメンバが返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept> matches every element in the sequence, the result is an empty sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>がシーケンスの中のすべての要素に合致するならば、結果は空のシーケンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept> matches every element in the sequence, the resulting sequence contains every element of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>がシーケンスの中のすべての要素に合致するならば、結果のシーケンスはそのシーケンスのすべての要素を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>result<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>Result<bpt i="3" x="3">&lt;w3&gt;</bpt>.success(_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept>, then the publisher waits until it receives a request for at least one value, then sends the output to all subscribers and finishes normally.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>result<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>Result<bpt i="3" x="3">&lt;w3&gt;</bpt>.success(_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept>であるならば、そのときパブリッシャーは、それがリクエストを少なくとも１つの値に対して受け取るまで待機します、それから出力を全ての加入者へと送信します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>source<ept i="0">&lt;/c0&gt;</ept> is outside the bounds of this type after rounding toward zero, a runtime error may occur.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>source<ept i="0">&lt;/c0&gt;</ept>がゼロへの丸め後にこの型の境界の外側ならば、実行時エラーが起こるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>subject<ept i="0">&lt;/c0&gt;</ept> is a class instance, <bpt i="1" x="1">&lt;c1&gt;</bpt>ancestor<bpt i="2" x="2">&lt;w2&gt;</bpt>Representation<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> determines whether ancestor classes will be represented and whether their <bpt i="3" x="3">&lt;c3&gt;</bpt>custom<bpt i="4" x="4">&lt;w4&gt;</bpt>Mirror<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> implementations will be used.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>subject<ept i="0">&lt;/c0&gt;</ept>がクラスインスタンスであるならば、<bpt i="1" x="1">&lt;c1&gt;</bpt>ancestor<bpt i="2" x="2">&lt;w2&gt;</bpt>Representation<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>は、先祖クラスが表現されるかどうかをそして<bpt i="3" x="3">&lt;c3&gt;</bpt>custom<bpt i="4" x="4">&lt;w4&gt;</bpt>Mirror<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>実装が使われるかどうかを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>text<ept i="0">&lt;/c0&gt;</ept> is in an invalid format or contains characters that are out of bounds for the given <bpt i="1" x="1">&lt;c1&gt;</bpt>radix<ept i="1">&lt;/c1&gt;</ept>, or if the value it denotes in the given <bpt i="2" x="2">&lt;c2&gt;</bpt>radix<ept i="2">&lt;/c2&gt;</ept> is not representable, the result is <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>text<ept i="0">&lt;/c0&gt;</ept> が無効な形式になっているか指定<bpt i="1" x="1">&lt;c1&gt;</bpt>radix<ept i="1">&lt;/c1&gt;</ept>の領域外の文字列を含むならば、または指定<bpt i="2" x="2">&lt;c2&gt;</bpt>radix<ept i="2">&lt;/c2&gt;</ept>においてそれが意味する値が表現可能でないならば、結果は<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>, the set’s buffer capacity is preserved; if <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>, the underlying buffer is released.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>ならば、集合が持つバッファ容量を維持します；<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>ならば基盤をなすバッファは解放されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="1" x="1">&lt;c1&gt;</bpt>a<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>b<ept i="2">&lt;/c2&gt;</ept> are incomparable, and <bpt i="3" x="3">&lt;c3&gt;</bpt>b<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>c<ept i="4">&lt;/c4&gt;</ept> are incomparable, then <bpt i="5" x="5">&lt;c5&gt;</bpt>a<ept i="5">&lt;/c5&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt>c<ept i="6">&lt;/c6&gt;</ept> are also incomparable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>a<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>b<ept i="2">&lt;/c2&gt;</ept>が比較できないならば、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>b<ept i="3">&lt;/c3&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>c<ept i="4">&lt;/c4&gt;</ept>が比較できないならば、そのとき<bpt i="5" x="5">&lt;c5&gt;</bpt>a<ept i="5">&lt;/c5&gt;</ept>と<bpt i="6" x="6">&lt;c6&gt;</bpt>c<ept i="6">&lt;/c6&gt;</ept>もまた比較できない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="1" x="1">&lt;c1&gt;</bpt>element<ept i="1">&lt;/c1&gt;</ept> is not found in the collection, returns <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>element<ept i="1">&lt;/c1&gt;</ept>がコレクションの中に見つけられないならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="1" x="1">&lt;c1&gt;</bpt>element<ept i="1">&lt;/c1&gt;</ept> is not found in the collection, this method returns <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>element<ept i="1">&lt;/c1&gt;</ept>がコレクションの中に見つけられないならば、このメソッドは<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept> contains multiple instances of equivalent elements, only the first instance is kept.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>が同等の要素を複数含むならば、最初の要素だけが残されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="1" x="1">&lt;c1&gt;</bpt>rhs<ept i="1">&lt;/c1&gt;</ept> is outside the range <bpt i="2" x="2">&lt;c2&gt;</bpt>0..<it pos="begin" x="3">&lt;lhs&lt;w3&gt;</it>.bit<bpt i="4" x="4">&lt;w4&gt;</bpt>Width<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, it is masked to produce a value within that range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>rhs<ept i="1">&lt;/c1&gt;</ept>が範囲<bpt i="2" x="2">&lt;c2&gt;</bpt>0..<it pos="begin" x="3">&lt;lhs&lt;w3&gt;</it>.bit<bpt i="4" x="4">&lt;w4&gt;</bpt>Width<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の外側ならば、それはマスクされてその範囲内の値を生み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="2" x="2">&lt;c2&gt;</bpt>are<bpt i="3" x="3">&lt;w3&gt;</bpt>In<bpt i="4" x="4">&lt;w4&gt;</bpt>Increasing<bpt i="5" x="5">&lt;w5&gt;</bpt>Order<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> throws an error during the sort, the elements may be in a different order, but none will be lost.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>are<bpt i="3" x="3">&lt;w3&gt;</bpt>In<bpt i="4" x="4">&lt;w4&gt;</bpt>Increasing<bpt i="5" x="5">&lt;w5&gt;</bpt>Order<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>がエラーをソートの間にスローするならば、要素は異なる順番になるかもしれません、しかし何１つとしてなくさないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="2" x="2">&lt;c2&gt;</bpt>distance<ept i="2">&lt;/c2&gt;</ept> is positive, this is the same value as the result of <bpt i="3" x="3">&lt;c3&gt;</bpt>distance<ept i="3">&lt;/c3&gt;</ept> calls to <bpt i="4" x="4">&lt;c4&gt;</bpt>index(after:)<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>distance<ept i="2">&lt;/c2&gt;</ept>が正ならば、これは<bpt i="3" x="3">&lt;c3&gt;</bpt>distance<ept i="3">&lt;/c3&gt;</ept>で<bpt i="4" x="4">&lt;c4&gt;</bpt>index(after:)<ept i="4">&lt;/c4&gt;</ept>を呼び出す結果と同じ値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="2" x="2">&lt;c2&gt;</bpt>i == end<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, this method is equivalent to <bpt i="4" x="4">&lt;c4&gt;</bpt>append(_:)<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>i == end<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ならば、このメソッドは<bpt i="4" x="4">&lt;c4&gt;</bpt>append(_:)<ept i="4">&lt;/c4&gt;</ept>に相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="2" x="2">&lt;c2&gt;</bpt>source<ept i="2">&lt;/c2&gt;</ept> is less than the smallest representable value in this type, the result is the type’s <bpt i="3" x="3">&lt;c3&gt;</bpt>min<ept i="3">&lt;/c3&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>source<ept i="2">&lt;/c2&gt;</ept>がこの型の最も小さい表現可能な値より小さいならば、結果はこの型のもつ<bpt i="3" x="3">&lt;c3&gt;</bpt>min<ept i="3">&lt;/c3&gt;</ept>値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept>, only nonempty subsequences are returned.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept>ならば、空でない下位シーケンスだけが返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="4" x="4">&lt;c4&gt;</bpt>possible<bpt i="5" x="5">&lt;w5&gt;</bpt>Prefix<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> has no elements, the return value is <bpt i="6" x="6">&lt;c6&gt;</bpt>true<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>possible<bpt i="5" x="5">&lt;w5&gt;</bpt>Prefix<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>が１つも要素を持たないならば、戻り値は<bpt i="6" x="6">&lt;c6&gt;</bpt>true<ept i="6">&lt;/c6&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="4" x="4">&lt;c4&gt;</bpt>result<ept i="4">&lt;/c4&gt;</ept> is <bpt i="5" x="5">&lt;a5&gt;</bpt><bpt i="6" x="6">&lt;c6&gt;</bpt>Result<bpt i="7" x="7">&lt;w7&gt;</bpt>.failure(_:)<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept><ept i="5">&lt;/a5&gt;</ept>, then the publisher sends the failure immediately upon subscription.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>result<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;a5&gt;</bpt><bpt i="6" x="6">&lt;c6&gt;</bpt>Result<bpt i="7" x="7">&lt;w7&gt;</bpt>.failure(_:)<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept><ept i="5">&lt;/a5&gt;</ept>であるならば、そのときパブリッシャーは、不成功を直ぐに定期購買上で送信します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="5" x="5">&lt;c5&gt;</bpt>distance<ept i="5">&lt;/c5&gt;</ept> is negative, this is the same value as the result of <bpt i="6" x="6">&lt;c6&gt;</bpt>abs(distance)<ept i="6">&lt;/c6&gt;</ept> calls to <bpt i="7" x="7">&lt;c7&gt;</bpt>index(before:)<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>distance<ept i="5">&lt;/c5&gt;</ept>が負ならば、これは<bpt i="6" x="6">&lt;c6&gt;</bpt>abs(distance)<ept i="6">&lt;/c6&gt;</ept>で<bpt i="7" x="7">&lt;c7&gt;</bpt>index(before:)<ept i="7">&lt;/c7&gt;</ept>を呼び出す結果と同じ値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>, only nonempty subsequences are returned.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>ならば、空でない下位シーケンスだけが返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="6" x="6">&lt;c6&gt;</bpt>i == end<bpt i="7" x="7">&lt;w7&gt;</bpt>Index<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, this method is equivalent to <bpt i="8" x="8">&lt;c8&gt;</bpt>append(contents<bpt i="9" x="9">&lt;w9&gt;</bpt>Of:)<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt>i == end<bpt i="7" x="7">&lt;w7&gt;</bpt>Index<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>ならば、このメソッドは<bpt i="8" x="8">&lt;c8&gt;</bpt>append(contents<bpt i="9" x="9">&lt;w9&gt;</bpt>Of:)<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>に相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If a future change to the app requires an additional state, you need to update an additional variable at every existing change in state.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>アプリに対する将来の変更が追加の状態を要求するならば、あなたは、状態において起こっているすべての変化で、追加の変数を更新する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If a property is converted from a stored property to a computed property, the result of <bpt i="1" x="1">&lt;c1&gt;</bpt>offset(of:)<ept i="1">&lt;/c1&gt;</ept> changes to <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>プロパティが格納プロパティから計算プロパティに変換されるならば、<bpt i="1" x="1">&lt;c1&gt;</bpt>offset(of:)<ept i="1">&lt;/c1&gt;</ept>の結果は<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>に変わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If an element equal to <bpt i="0" x="0">&lt;c0&gt;</bpt>new<bpt i="1" x="1">&lt;w1&gt;</bpt>Member<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is already contained in the set, <bpt i="2" x="2">&lt;c2&gt;</bpt>new<bpt i="3" x="3">&lt;w3&gt;</bpt>Member<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> replaces the existing element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>new<bpt i="1" x="1">&lt;w1&gt;</bpt>Member<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に等しい要素が既にこの集合に含まれるならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>new<bpt i="3" x="3">&lt;w3&gt;</bpt>Member<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は既存の要素と置き換わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If an element equal to <bpt i="0" x="0">&lt;c0&gt;</bpt>new<bpt i="1" x="1">&lt;w1&gt;</bpt>Member<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is already contained in the set, this method has no effect.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>new<bpt i="1" x="1">&lt;w1&gt;</bpt>Member<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に等しい要素が既にこの集合に含まれるならば、このメソッドは効果を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If an element equal to <bpt i="4" x="4">&lt;c4&gt;</bpt>new<bpt i="5" x="5">&lt;w5&gt;</bpt>Member<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> was already contained in the set, the method returns <bpt i="6" x="6">&lt;c6&gt;</bpt>(false, old<bpt i="7" x="7">&lt;w7&gt;</bpt>Member)<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, where <bpt i="8" x="8">&lt;c8&gt;</bpt>old<bpt i="9" x="9">&lt;w9&gt;</bpt>Member<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> is the element that was equal to <bpt i="10" x="10">&lt;c10&gt;</bpt>new<bpt i="11" x="11">&lt;w11&gt;</bpt>Member<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>new<bpt i="5" x="5">&lt;w5&gt;</bpt>Member<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>に等しい要素が既に集合に含まれたならば、メソッドは<bpt i="6" x="6">&lt;c6&gt;</bpt>(false, old<bpt i="7" x="7">&lt;w7&gt;</bpt>Member)<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を返します、ここで<bpt i="8" x="8">&lt;c8&gt;</bpt>old<bpt i="9" x="9">&lt;w9&gt;</bpt>Member<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>は<bpt i="10" x="10">&lt;c10&gt;</bpt>new<bpt i="11" x="11">&lt;w11&gt;</bpt>Member<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>に等しかった要素です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If necessary, the byte order of this value is reversed from the typical byte order of this integer type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>必要ならば、この値のバイト順はこの整数型の典型的なバイト順からひっくり返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If no elements in the collection match <bpt i="4" x="4">&lt;c4&gt;</bpt>belongs<bpt i="5" x="5">&lt;w5&gt;</bpt>In<bpt i="6" x="6">&lt;w6&gt;</bpt>Second<bpt i="7" x="7">&lt;w7&gt;</bpt>Partition<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, the returned index is equal to the collection’s <bpt i="8" x="8">&lt;c8&gt;</bpt>end<bpt i="9" x="9">&lt;w9&gt;</bpt>Index<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの中の要素が１つも<bpt i="4" x="4">&lt;c4&gt;</bpt>belongs<bpt i="5" x="5">&lt;w5&gt;</bpt>In<bpt i="6" x="6">&lt;w6&gt;</bpt>Second<bpt i="7" x="7">&lt;w7&gt;</bpt>Partition<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>に一致しないならば、返されるインデックスはコレクションの<bpt i="8" x="8">&lt;c8&gt;</bpt>end<bpt i="9" x="9">&lt;w9&gt;</bpt>Index<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If no elements in the collection satisfy the given predicate, returns <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの要素が与えられた述部を満たすことがないならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If no nullability information is provided for a type, Swift doesn't distinguish between optional and nonoptional references, and imports the type as an implicitly unwrapped optional.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ヌル可能性情報がある型に提供されないならば、Swiftはオプショナルと非オプショナル参照の間の区別をしません、そしてその型をある暗黙的にアンラップされるオプショナルとしてインポートしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If no such storage exists, it is first created.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのようなストレージが存在しないならば、それが最初に作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If parts of an Objective-C API aren't suitable for Swift, you can make those parts unavailable in Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-C APIの一部がSwiftに適さないならば、あなたそれらの部分をSwiftで利用可能できなくできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the <bpt i="0" x="0">&lt;c0&gt;</bpt>Key<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<bpt i="2" x="2">&lt;w2&gt;</bpt>Pairs<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance is empty, <bpt i="3" x="3">&lt;c3&gt;</bpt>end<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is equal to <bpt i="5" x="5">&lt;c5&gt;</bpt>start<bpt i="6" x="6">&lt;w6&gt;</bpt>Index<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Key<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<bpt i="2" x="2">&lt;w2&gt;</bpt>Pairs<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスが空ならば、<bpt i="3" x="3">&lt;c3&gt;</bpt>end<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は<bpt i="5" x="5">&lt;c5&gt;</bpt>start<bpt i="6" x="6">&lt;w6&gt;</bpt>Index<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the <bpt i="0" x="0">&lt;c0&gt;</bpt>Key<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<bpt i="2" x="2">&lt;w2&gt;</bpt>Pairs<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance is empty, <bpt i="3" x="3">&lt;c3&gt;</bpt>start<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is equal to <bpt i="5" x="5">&lt;c5&gt;</bpt>end<bpt i="6" x="6">&lt;w6&gt;</bpt>Index<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Key<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<bpt i="2" x="2">&lt;w2&gt;</bpt>Pairs<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスが空ならば、<bpt i="3" x="3">&lt;c3&gt;</bpt>start<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は<bpt i="5" x="5">&lt;c5&gt;</bpt>end<bpt i="6" x="6">&lt;w6&gt;</bpt>Index<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the <bpt i="0" x="0">&lt;c0&gt;</bpt>overflow<ept i="0">&lt;/c0&gt;</ept> component is <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>, the <bpt i="2" x="2">&lt;c2&gt;</bpt>partial<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> component contains the entire difference.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>overflow<ept i="0">&lt;/c0&gt;</ept>構成部分が<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>ならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>partial<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>構成部分は差そのままを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the <bpt i="0" x="0">&lt;c0&gt;</bpt>overflow<ept i="0">&lt;/c0&gt;</ept> component is <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>, the <bpt i="2" x="2">&lt;c2&gt;</bpt>partial<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> component contains the entire product.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>overflow<ept i="0">&lt;/c0&gt;</ept>構成部分が<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>ならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>partial<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>構成部分は積そのままを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the <bpt i="0" x="0">&lt;c0&gt;</bpt>overflow<ept i="0">&lt;/c0&gt;</ept> component is <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>, the <bpt i="2" x="2">&lt;c2&gt;</bpt>partial<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> component contains the entire quotient.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>overflow<ept i="0">&lt;/c0&gt;</ept>構成部分が<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>ならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>partial<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>構成部分は全体の商を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the <bpt i="0" x="0">&lt;c0&gt;</bpt>overflow<ept i="0">&lt;/c0&gt;</ept> component is <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>, the <bpt i="2" x="2">&lt;c2&gt;</bpt>partial<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> component contains the entire remainder.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>overflow<ept i="0">&lt;/c0&gt;</ept>構成部分が<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>ならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>partial<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>構成部分は余りそのままを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the <bpt i="0" x="0">&lt;c0&gt;</bpt>overflow<ept i="0">&lt;/c0&gt;</ept> component is <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>, the <bpt i="2" x="2">&lt;c2&gt;</bpt>partial<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> component contains the entire sum.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>overflow<ept i="0">&lt;/c0&gt;</ept>構成部分が<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>ならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>partial<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>構成部分は合計そのままを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the <bpt i="4" x="4">&lt;c4&gt;</bpt>overflow<ept i="4">&lt;/c4&gt;</ept> component is <bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>, an overflow occurred and the <bpt i="6" x="6">&lt;c6&gt;</bpt>partial<bpt i="7" x="7">&lt;w7&gt;</bpt>Value<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> component contains either the truncated quotient or, if the quotient is undefined, the dividend.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>overflow<ept i="4">&lt;/c4&gt;</ept>構成部分が<bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>であるならば、オーバーフローが起こった、そして<bpt i="6" x="6">&lt;c6&gt;</bpt>partial<bpt i="7" x="7">&lt;w7&gt;</bpt>Value<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>構成部分は切り詰められた商または、商が未定義ならば、被除数のどちらかを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the <bpt i="4" x="4">&lt;c4&gt;</bpt>overflow<ept i="4">&lt;/c4&gt;</ept> component is <bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>, an overflow occurred and the <bpt i="6" x="6">&lt;c6&gt;</bpt>partial<bpt i="7" x="7">&lt;w7&gt;</bpt>Value<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> component contains the truncated product of this value and <bpt i="8" x="8">&lt;c8&gt;</bpt>rhs<ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>overflow<ept i="4">&lt;/c4&gt;</ept>構成部分が<bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>であるならば、オーバーフローが起こると<bpt i="6" x="6">&lt;c6&gt;</bpt>partial<bpt i="7" x="7">&lt;w7&gt;</bpt>Value<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>構成部分はこの値と<bpt i="8" x="8">&lt;c8&gt;</bpt>rhs<ept i="8">&lt;/c8&gt;</ept>の積の切り詰められたものを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the <bpt i="4" x="4">&lt;c4&gt;</bpt>overflow<ept i="4">&lt;/c4&gt;</ept> component is <bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>, an overflow occurred and the <bpt i="6" x="6">&lt;c6&gt;</bpt>partial<bpt i="7" x="7">&lt;w7&gt;</bpt>Value<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> component contains the truncated result of <bpt i="8" x="8">&lt;c8&gt;</bpt>rhs<ept i="8">&lt;/c8&gt;</ept> subtracted from this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>overflow<ept i="4">&lt;/c4&gt;</ept>構成部分が<bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>であるならば、オーバーフローが起こると<bpt i="6" x="6">&lt;c6&gt;</bpt>partial<bpt i="7" x="7">&lt;w7&gt;</bpt>Value<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>構成部分はこの値から<bpt i="8" x="8">&lt;c8&gt;</bpt>rhs<ept i="8">&lt;/c8&gt;</ept>を減算した結果の切り詰められたもの含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the <bpt i="4" x="4">&lt;c4&gt;</bpt>overflow<ept i="4">&lt;/c4&gt;</ept> component is <bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>, an overflow occurred and the <bpt i="6" x="6">&lt;c6&gt;</bpt>partial<bpt i="7" x="7">&lt;w7&gt;</bpt>Value<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> component contains the truncated sum of this value and <bpt i="8" x="8">&lt;c8&gt;</bpt>rhs<ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>overflow<ept i="4">&lt;/c4&gt;</ept>構成部分が<bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>であるならば、オーバーフローが起こると<bpt i="6" x="6">&lt;c6&gt;</bpt>partial<bpt i="7" x="7">&lt;w7&gt;</bpt>Value<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>構成部分はこの値と<bpt i="8" x="8">&lt;c8&gt;</bpt>rhs<ept i="8">&lt;/c8&gt;</ept>の合計の切り詰められたものを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the <bpt i="4" x="4">&lt;c4&gt;</bpt>overflow<ept i="4">&lt;/c4&gt;</ept> component is <bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>, an overflow occurred during division and the <bpt i="6" x="6">&lt;c6&gt;</bpt>partial<bpt i="7" x="7">&lt;w7&gt;</bpt>Value<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> component contains either the entire remainder or, if the remainder is undefined, the dividend.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>overflow<ept i="4">&lt;/c4&gt;</ept>構成部分が<bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>であるならば、除算の間にオーバーフローが起こった、そして<bpt i="6" x="6">&lt;c6&gt;</bpt>partial<bpt i="7" x="7">&lt;w7&gt;</bpt>Value<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>構成部分は余りそのまままたは、余りが未定義ならば、被除数のどちらかを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シフトされる整数型のビット幅が２の冪ならば、マスクはビットマスクを使って実行されます；そうでなければ、マスクはモジュロ演算を使って実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the call to this method simply appends the contents of <bpt i="6" x="6">&lt;c6&gt;</bpt>new<bpt i="7" x="7">&lt;w7&gt;</bpt>Elements<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> to the collection, the complexity is O(<bpt i="8" x="8">&lt;e8&gt;</bpt>m<ept i="8">&lt;/e8&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドへの呼び出しが単に<bpt i="6" x="6">&lt;c6&gt;</bpt>new<bpt i="7" x="7">&lt;w7&gt;</bpt>Elements<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>の内容をコレクションに追加するだけならば、計算量はO(<bpt i="8" x="8">&lt;e8&gt;</bpt>m<ept i="8">&lt;/e8&gt;</ept>)です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the call to this method simply appends the contents of <bpt i="6" x="6">&lt;c6&gt;</bpt>new<bpt i="7" x="7">&lt;w7&gt;</bpt>Elements<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> to the collection, this method is equivalent to <bpt i="8" x="8">&lt;c8&gt;</bpt>append(contents<bpt i="9" x="9">&lt;w9&gt;</bpt>Of:)<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドへの呼び出しが単に<bpt i="6" x="6">&lt;c6&gt;</bpt>new<bpt i="7" x="7">&lt;w7&gt;</bpt>Elements<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>の内容をコレクションに追加するだけならば、このメソッドは<bpt i="8" x="8">&lt;c8&gt;</bpt>append(contents<bpt i="9" x="9">&lt;w9&gt;</bpt>Of:)<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the collection does not have sufficient capacity for another element, additional storage is allocated before appending <bpt i="0" x="0">&lt;c0&gt;</bpt>new<bpt i="1" x="1">&lt;w1&gt;</bpt>Element<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションが別の要素に対して十分な容量を持たないならば、追加のストレージが<bpt i="0" x="0">&lt;c0&gt;</bpt>new<bpt i="1" x="1">&lt;w1&gt;</bpt>Element<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を追加する前に割り当てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the collection does not support an internal representation in a form of contiguous storage, <bpt i="2" x="2">&lt;c2&gt;</bpt>body<ept i="2">&lt;/c2&gt;</ept> is not called and <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept> is returned.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションがある内部表現を隣接ストレージの形式でサポートしないならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>body<ept i="2">&lt;/c2&gt;</ept>は呼び出されません、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>が返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the collection does not support an internal representation in a form of mutable contiguous storage, <bpt i="2" x="2">&lt;c2&gt;</bpt>body<ept i="2">&lt;/c2&gt;</ept> is not called and <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept> is returned.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションがある内部表現を可変の隣接ストレージの形式でサポートしないならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>body<ept i="2">&lt;/c2&gt;</ept>は呼び出されません、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>が返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the collection is empty, <bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="2" x="2">&lt;c2&gt;</bpt>start<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションが空ならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>start<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the collection is empty, <bpt i="0" x="0">&lt;c0&gt;</bpt>start<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="2" x="2">&lt;c2&gt;</bpt>end<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションが空ならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>start<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>end<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the collection is empty, <bpt i="3" x="3">&lt;c3&gt;</bpt>start<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is equal to <bpt i="5" x="5">&lt;c5&gt;</bpt>end<bpt i="6" x="6">&lt;w6&gt;</bpt>Index<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションが空ならば、<bpt i="3" x="3">&lt;c3&gt;</bpt>start<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は<bpt i="5" x="5">&lt;c5&gt;</bpt>end<bpt i="6" x="6">&lt;w6&gt;</bpt>Index<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the collection is empty, <bpt i="4" x="4">&lt;c4&gt;</bpt>end<bpt i="5" x="5">&lt;w5&gt;</bpt>Index<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is equal to <bpt i="6" x="6">&lt;c6&gt;</bpt>start<bpt i="7" x="7">&lt;w7&gt;</bpt>Index<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションが空ならば、<bpt i="4" x="4">&lt;c4&gt;</bpt>end<bpt i="5" x="5">&lt;w5&gt;</bpt>Index<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は<bpt i="6" x="6">&lt;c6&gt;</bpt>start<bpt i="7" x="7">&lt;w7&gt;</bpt>Index<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the collection is empty, the method returns <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションが空ならば、このメソッドは<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the collection is empty, the value of this property is <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションが空であるならば、このプロパティは<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the dynamic type of <bpt i="0" x="0">&lt;c0&gt;</bpt>subject<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Custom<bpt i="2" x="2">&lt;w2&gt;</bpt>Reflectable<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>, the resulting mirror is determined by its <bpt i="3" x="3">&lt;c3&gt;</bpt>custom<bpt i="4" x="4">&lt;w4&gt;</bpt>Mirror<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>subject<ept i="0">&lt;/c0&gt;</ept>の動的型が<bpt i="1" x="1">&lt;c1&gt;</bpt>Custom<bpt i="2" x="2">&lt;w2&gt;</bpt>Reflectable<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠するならば、結果として生じるミラーは、それの<bpt i="3" x="3">&lt;c3&gt;</bpt>custom<bpt i="4" x="4">&lt;w4&gt;</bpt>Mirror<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>プロパティによって決定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the dynamic type of <bpt i="0" x="0">&lt;c0&gt;</bpt>subject<ept i="0">&lt;/c0&gt;</ept> has value semantics, subsequent mutations of <bpt i="1" x="1">&lt;c1&gt;</bpt>subject<ept i="1">&lt;/c1&gt;</ept> will not observable in <bpt i="2" x="2">&lt;c2&gt;</bpt>Mirror<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>subject<ept i="0">&lt;/c0&gt;</ept>の動的な型が値意味論を持つならば、<bpt i="1" x="1">&lt;c1&gt;</bpt>subject<ept i="1">&lt;/c1&gt;</ept>の下位セグメント変異体たちは<bpt i="2" x="2">&lt;c2&gt;</bpt>Mirror<ept i="2">&lt;/c2&gt;</ept>の中で見分けがつかないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最大長がコレクションの要素の数を越えるならば、結果はコレクションの要素すべてを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the maximum length exceeds the number of elements in the collection, the result contains the entire collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最大長がコレクションの要素の数を越えるならば、結果はコレクション全体を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最大長がシーケンスの要素の数を越えるならば、結果はシーケンスの要素すべてを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省かれることになる要素の数がコレクションの要素の数を越えるならば、結果は空の下位シーケンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>取り除く要素の数がシーケンスの要素数を越えるならば、結果は空のシーケンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the quotient of dividing <bpt i="0" x="0">&lt;c0&gt;</bpt>dividend<ept i="0">&lt;/c0&gt;</ept> by this value is too large to represent in the type, a runtime error may occur.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>dividend<ept i="0">&lt;/c0&gt;</ept>をこの値で除算した商がこの型で表すのに大きすぎるならば、実行時エラーが起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the result is <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>Result<bpt i="2" x="2">&lt;w2&gt;</bpt>.success(_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>, this publisher sends the specified output to all subscribers and finishes normally.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果が<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>Result<bpt i="2" x="2">&lt;w2&gt;</bpt>.success(_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>ならば、このパブリッシャーは指定された出力をすべての加入者に送信します、そして正常に終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the result is <bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>Result<bpt i="5" x="5">&lt;w5&gt;</bpt>.failure(_:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>, then the publisher fails immediately with the specified error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果が<bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>Result<bpt i="5" x="5">&lt;w5&gt;</bpt>.failure(_:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>ならば、そのときパブリッシャーは指定されたエラーで直ちに終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the return value of this method is non-<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>, then accessing the value by key path or by an offset pointer are equivalent.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドの戻り値が非<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>ならば、その時その値にキーパスによってまたはあるオフセットポインタによってアクセスすることは、等価です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the sequence has no elements, <bpt i="0" x="0">&lt;c0&gt;</bpt>next<bpt i="1" x="1">&lt;w1&gt;</bpt>Partial<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is never executed and <bpt i="3" x="3">&lt;c3&gt;</bpt>initial<bpt i="4" x="4">&lt;w4&gt;</bpt>Result<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is the result of the call to <bpt i="5" x="5">&lt;c5&gt;</bpt>reduce(_:<bpt i="6" x="6">&lt;w6&gt;</bpt>_:)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスが１つも要素を持たないならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>next<bpt i="1" x="1">&lt;w1&gt;</bpt>Partial<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は決して実行されません、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>initial<bpt i="4" x="4">&lt;w4&gt;</bpt>Result<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は<bpt i="5" x="5">&lt;c5&gt;</bpt>reduce(_:<bpt i="6" x="6">&lt;w6&gt;</bpt>_:)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>への呼び出しの結果となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the sequence has no elements, <bpt i="0" x="0">&lt;c0&gt;</bpt>update<bpt i="1" x="1">&lt;w1&gt;</bpt>Accumulating<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is never executed and <bpt i="3" x="3">&lt;c3&gt;</bpt>initial<bpt i="4" x="4">&lt;w4&gt;</bpt>Result<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is the result of the call to <bpt i="5" x="5">&lt;c5&gt;</bpt>reduce(into:<bpt i="6" x="6">&lt;w6&gt;</bpt>_:)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスが１つも要素を持たないならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>update<bpt i="1" x="1">&lt;w1&gt;</bpt>Accumulating<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は決して実行されません、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>initial<bpt i="4" x="4">&lt;w4&gt;</bpt>Result<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は<bpt i="5" x="5">&lt;c5&gt;</bpt>reduce(into:<bpt i="6" x="6">&lt;w6&gt;</bpt>_:)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>への呼び出しの結果となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the sequence has no elements, returns <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスが要素を持たないならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the sequence has no elements, returns <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスが要素を持たないならば、<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the sequence has no elements, the result is <bpt i="0" x="0">&lt;c0&gt;</bpt>initial<bpt i="1" x="1">&lt;w1&gt;</bpt>Result<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスが１つも要素を持たないならば、結果は<bpt i="0" x="0">&lt;c0&gt;</bpt>initial<bpt i="1" x="1">&lt;w1&gt;</bpt>Result<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the sequence is empty, this method returns <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスが空ならば、このメソッドは<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the set already contains one or more elements that are also in <bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>, the existing members are kept.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>の中にもある１つ以上の要素をこの集合がすでに含むならば、既存のメンバはそのままにしておかれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the set is empty, <bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="2" x="2">&lt;c2&gt;</bpt>start<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合が空ならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>start<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the set is empty, <bpt i="0" x="0">&lt;c0&gt;</bpt>start<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="2" x="2">&lt;c2&gt;</bpt>end<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合が空ならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>start<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>end<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the set is empty, returns <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合が空ならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>が返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the set wraps a bridged <bpt i="1" x="1">&lt;c1&gt;</bpt>NSSet<ept i="1">&lt;/c1&gt;</ept>, the performance is unspecified.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合が、ブリッジされた<bpt i="1" x="1">&lt;c1&gt;</bpt>NSSet<ept i="1">&lt;/c1&gt;</ept>をラップするならば、性能は不特定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the two ranges do not overlap, the result is an empty range within the bounds of <bpt i="0" x="0">&lt;c0&gt;</bpt>limits<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの範囲が重ならないならば、結果は<bpt i="0" x="0">&lt;c0&gt;</bpt>limits<ept i="0">&lt;/c0&gt;</ept>の境界内の空の範囲です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the value fails to encode anything, <bpt i="0" x="0">&lt;c0&gt;</bpt>encoder<ept i="0">&lt;/c0&gt;</ept> will encode an empty keyed container in its place.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値が何かをエンコードに失敗するならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>encoder<ept i="0">&lt;/c0&gt;</ept>は空のキー付きコンテナをその場でエンコードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the value is <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>, it can be because <bpt i="5" x="5">&lt;c5&gt;</bpt>key<ept i="5">&lt;/c5&gt;</ept> is computed, has observers, requires reabstraction, or overlaps storage with other properties.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値が<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>の場合、それが可能なのは<bpt i="5" x="5">&lt;c5&gt;</bpt>key<ept i="5">&lt;/c5&gt;</ept>が計算される、オブザーバを持つ、再抽象化を要求する、またはストレージを他のプロパティでオーバーラップするからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the value passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>source<ept i="0">&lt;/c0&gt;</ept> is greater than the maximum representable value in this type, the result is the type’s <bpt i="1" x="1">&lt;c1&gt;</bpt>max<ept i="1">&lt;/c1&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>source<ept i="0">&lt;/c0&gt;</ept>として渡された値がこの型において最大限の表現可能な値より大きいならば、結果はこの型のもつ<bpt i="1" x="1">&lt;c1&gt;</bpt>max<ept i="1">&lt;/c1&gt;</ept>値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the value passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>source<ept i="0">&lt;/c0&gt;</ept> is not representable exactly, the result is <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>source<ept i="0">&lt;/c0&gt;</ept>として渡された値が正確に表現可能でないならば、結果は<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If there is no value of the type that corresponds with the specified raw value, this initializer returns <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された生の値に対応する型の値が１つもないならば、このイニシャライザは<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If there's a chance that a closure you pass to an API won't be called, don't put code that's critical to continuing your app in the closure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがAPIに渡すクロージャが呼び出されない可能性があるならば、あなたのアプリを継続するのに重要なコードをクロージャの中に置かないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If this instance is <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>, returns <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このインスタンスが<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>ならば、<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If this type has value semantics, the mirror should be unaffected by subsequent mutations of the instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型が値意味論を持つならば、ミラーはインスタンスのその後の変化によって影響を受けないべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you are adding a known number of elements to a collection, use this method to avoid multiple reallocations.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが数のわかった要素をコレクションに加えているならば、このメソッドを使って複数の再割り当てを避けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you are adding a known number of elements to a set, use this method to avoid multiple reallocations.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが数のわかった要素を集合に加えているならば、このメソッドを使って複数の再割り当てを避けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you are sorting strings to present to the end user, use <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> APIs that perform localized comparison instead.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが文字列をソートしてエンドユーザに提供するならば、代わりに<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> APIを使うべきです、それはローカライズされた比較を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you are sorting strings to present to the end user, use <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> APIs that perform localized comparison.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが文字列をソートしてエンドユーザに提供するならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> APIを使うべきです、それはローカライズされた比較を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you misunderstand the requirements of <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>close<bpt i="2" x="2">&lt;w2&gt;</bpt>File()<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>, you might place the call inside the closure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>close<bpt i="2" x="2">&lt;w2&gt;</bpt>File()<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>の必要条件を取り違えるならば、あなたは呼び出しをクロージャの内側に置くかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you mutate the collection while iterating over its indices, a strong reference can cause an unexpected copy of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがコレクションをそれのインデックス全体に反復している間に変化させるならば、ある強い参照はそのコレクションの予期されない複製の原因となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you mutate the collection while iterating over its indices, a strong reference can result in an unexpected copy of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがコレクションをそれのインデックス全体に反復している間に変化させるならば、ある強い参照はそのコレクションの予期しない複製という結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが同じ型での逆にされたコレクションを必要とするならば、あなたはコレクションのもつシーケンス基盤のまたはコレクション基盤のイニシャライザを使うことができるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you need an integer value within a specific range, use the static <bpt i="0" x="0">&lt;c0&gt;</bpt>random(in:<bpt i="1" x="1">&lt;w1&gt;</bpt>using:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method on that integer type instead of this method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがある整数を指定範囲内で必要とするならば、静的<bpt i="0" x="0">&lt;c0&gt;</bpt>random(in:<bpt i="1" x="1">&lt;w1&gt;</bpt>using:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドをその整数型の上で使ってください、このメソッドの代わりに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you need to infer moves, call the <bpt i="0" x="0">&lt;c0&gt;</bpt>inferring<bpt i="1" x="1">&lt;w1&gt;</bpt>Moves()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method on the resulting difference.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが移動の推論を必要とするならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>inferring<bpt i="1" x="1">&lt;w1&gt;</bpt>Moves()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを結果の差異の上で呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you need to iterate over consecutive floating-point values, see the <bpt i="3" x="3">&lt;c3&gt;</bpt>stride(from:<bpt i="4" x="4">&lt;w4&gt;</bpt>to:<bpt i="5" x="5">&lt;w5&gt;</bpt>by:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが隣接浮動小数点値のすべてにわたって反復する必要があるならば、<bpt i="3" x="3">&lt;c3&gt;</bpt>stride(from:<bpt i="4" x="4">&lt;w4&gt;</bpt>to:<bpt i="5" x="5">&lt;w5&gt;</bpt>by:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>関数を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you need to provide a customized playground representation in Swift 4.0 or Swift 3.2 or earlier, use a conditional compilation block:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがカスタマイズされたプレイグラウンド表現をSwift 4.0またはSwift 3.2以前において提供する必要があるならば、条件コンパイルブロックを使ってください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you pass a zero-length range as the <bpt i="0" x="0">&lt;c0&gt;</bpt>subrange<ept i="0">&lt;/c0&gt;</ept> parameter, this method inserts the elements of <bpt i="1" x="1">&lt;c1&gt;</bpt>new<bpt i="2" x="2">&lt;w2&gt;</bpt>Elements<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> at <bpt i="3" x="3">&lt;c3&gt;</bpt>subrange<bpt i="4" x="4">&lt;w4&gt;</bpt>.start<bpt i="5" x="5">&lt;w5&gt;</bpt>Index<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがゼロ長範囲を<bpt i="0" x="0">&lt;c0&gt;</bpt>subrange<ept i="0">&lt;/c0&gt;</ept>パラメータとして渡すならば、このメソッドは<bpt i="1" x="1">&lt;c1&gt;</bpt>new<bpt i="2" x="2">&lt;w2&gt;</bpt>Elements<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の要素を<bpt i="3" x="3">&lt;c3&gt;</bpt>subrange<bpt i="4" x="4">&lt;w4&gt;</bpt>.start<bpt i="5" x="5">&lt;w5&gt;</bpt>Index<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>で挿入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you pass strings to the <bpt i="3" x="3">&lt;c3&gt;</bpt>descendant(_:<bpt i="4" x="4">&lt;w4&gt;</bpt>_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> method, labels are used for lookup.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが幾つか文字列を<bpt i="3" x="3">&lt;c3&gt;</bpt>descendant(_:<bpt i="4" x="4">&lt;w4&gt;</bpt>_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>メソッドに渡すならば、それらラベルは検索に使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you pass the collection’s <bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property as the <bpt i="2" x="2">&lt;c2&gt;</bpt>index<ept i="2">&lt;/c2&gt;</ept> parameter, the new element is appended to the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがコレクションの<bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティを<bpt i="2" x="2">&lt;c2&gt;</bpt>index<ept i="2">&lt;/c2&gt;</ept>パラメータとして渡すならば、新しい要素がコレクションに追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you pass the collection’s <bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property as the <bpt i="2" x="2">&lt;c2&gt;</bpt>index<ept i="2">&lt;/c2&gt;</ept> parameter, the new elements are appended to the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがコレクションの<bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティを<bpt i="2" x="2">&lt;c2&gt;</bpt>index<ept i="2">&lt;/c2&gt;</ept>パラメータとして渡すならば、いくらかの新しい要素がコレクションに追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you provide your own implementation, make sure to compute the value nondestructively.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがあなた独自の実装を提供するならば、値を非破壊的に計算することを確実にしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you use <bpt i="0" x="0">&lt;c0&gt;</bpt>11<ept i="0">&lt;/c0&gt;</ept> as <bpt i="1" x="1">&lt;c1&gt;</bpt>rhs<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>x<ept i="2">&lt;/c2&gt;</ept> is overshifted such that all of its bits are set to zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>11<ept i="0">&lt;/c0&gt;</ept>を<bpt i="1" x="1">&lt;c1&gt;</bpt>rhs<ept i="1">&lt;/c1&gt;</ept>として使うならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>x<ept i="2">&lt;/c2&gt;</ept>は、それのビットのすべてがゼロに設定されるような、オーバーシフトをされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you use <bpt i="2" x="2">&lt;c2&gt;</bpt>2<ept i="2">&lt;/c2&gt;</ept> as the right-hand-side value in an operation on <bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>, the shift amount requires no masking.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが<bpt i="2" x="2">&lt;c2&gt;</bpt>2<ept i="2">&lt;/c2&gt;</ept>を右手側の値として<bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>に関する演算において使うならば、シフト量はマスクを必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you use <bpt i="2" x="2">&lt;c2&gt;</bpt>2<ept i="2">&lt;/c2&gt;</ept> as the right-hand-side value in an operation on <bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>, the value is shifted left by two bits.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが<bpt i="2" x="2">&lt;c2&gt;</bpt>2<ept i="2">&lt;/c2&gt;</ept>を<bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>上での演算の右手側の値として使うならば、値は2ビットだけ左にシフトされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you use <bpt i="2" x="2">&lt;c2&gt;</bpt>2<ept i="2">&lt;/c2&gt;</ept> as the right-hand-side value in an operation on <bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>, the value is shifted right by two bits.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが<bpt i="2" x="2">&lt;c2&gt;</bpt>2<ept i="2">&lt;/c2&gt;</ept>を<bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>上での演算の右手側の値として使うならば、値は2ビットだけ右にシフトされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you want to expose an Objective-C API to Swift with a different declaration, but a similar underlying implementation, use the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_REFINED<bpt i="2" x="2">&lt;w2&gt;</bpt>_FOR<bpt i="3" x="3">&lt;w3&gt;</bpt>_SWIFT<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> macro.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがObjective-C APIをSwiftに異なる宣言で、しかしよく似た基盤実装で公開したいならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_REFINED<bpt i="2" x="2">&lt;w2&gt;</bpt>_FOR<bpt i="3" x="3">&lt;w3&gt;</bpt>_SWIFT<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>マクロを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you want to import an Objective-C API into Swift with a different name, use the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_SWIFT<bpt i="2" x="2">&lt;w2&gt;</bpt>_NAME<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> macro.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがあるObjective-C APIをSwiftへ異なる名前でインポートしたいならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_SWIFT<bpt i="2" x="2">&lt;w2&gt;</bpt>_NAME<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>マクロを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you want to opt out of overflow checking and wrap the result in case of any overflow, use the overflow addition operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;+<ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがオーバーフロー検査を取りやめて、あらゆるオーバーフローの場合に結果をラップしたいならば、オーバーフロー加算演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;+<ept i="0">&lt;/c0&gt;</ept>）を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you want to opt out of overflow checking and wrap the result in case of any overflow, use the overflow multiplication operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;*<ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがオーバーフロー検査を取りやめて、あらゆるオーバーフローの場合に結果をラップしたいならば、オーバーフロー乗算演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;*<ept i="0">&lt;/c0&gt;</ept>）を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you want to opt out of overflow checking and wrap the result in case of any overflow, use the overflow subtraction operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;-<ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがオーバーフロー検査を取りやめてあらゆるオーバーフローの場合に結果をラップしたいならば、オーバーフロー減算演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;-<ept i="0">&lt;/c0&gt;</ept>）を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you will be adding a known number of elements to a collection, use this method to avoid multiple reallocations.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが数のわかった要素をコレクションに加えることになっているならば、このメソッドを使って複数の再割り当てを避けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you're going to pass a closure to an API that might call it multiple times, omit code that's intended to make a one-time change to external state.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがあるクロージャをそれを複数回呼び出すかもしれないAPIに渡そうとしているならば、一度限りの変更を外部状態に対してするように意図されるコードを省いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがあなたのプログラムを実行するたびごとに同じ要素からなるシーケンスという結果になる生成子を渡すならば、そのシーケンスは、あなたのプログラムが異なるSwiftバージョンを使ってコンパイルされる時に変わるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you’re passing a generator that results in the same sequence of integer values each time you run your program, that sequence may change when your program is compiled using a different version of Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがあなたのプログラムを実行するたびごとに同じ整数値からなるシーケンスという結果になる生成子を渡すならば、そのシーケンスは、あなたのプログラムが異なるSwiftバージョンを使ってコンパイルされる時に変わるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがあなたのプログラムを実行するたびごとに同じシャッフルされた順番という結果になる生成子を渡すならば、そのシーケンスは、あなたのプログラムが異なるSwiftバージョンを使ってコンパイルされる時に変わるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you’re working directly with numeric values, use the addition operator (<bpt i="1" x="1">&lt;c1&gt;</bpt>+<ept i="1">&lt;/c1&gt;</ept>) instead of this method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが直接に数値を扱っているならば、加算演算子（<bpt i="1" x="1">&lt;c1&gt;</bpt>+<ept i="1">&lt;/c1&gt;</ept>）をこのメソッドの代わりに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Implement this method to conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを実装して、<bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Implementing an iterator that conforms to <bpt i="0" x="0">&lt;c0&gt;</bpt>Iterator<bpt i="1" x="1">&lt;w1&gt;</bpt>Protocol<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is simple.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Iterator<bpt i="1" x="1">&lt;w1&gt;</bpt>Protocol<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠するイテレータを実装するのは簡単です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Implements the Publisher protocol by accepting the subscriber and immediately publishing the optional’s value if it has one, or finishing normally if it doesn’t.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Publisherプロトコルを、加入者を受け入れるそして直ちにオプショナルのもつ値を出版すること、またはそれがそうしないならば普通に終了することによって実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Implements the publisher protocol by accepting the subscriber if the result is success, or terminating with an error immediately if it’s failure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>パブリッシャープロトコルを、もし結果が成功するならば加入者を受け入れる、またはもしそれが失敗するならばエラーで直ぐに終了することによって実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Import Related Functions into Swift</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>関連する関数をSwiftにインポートする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Import relevant system frameworks.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>関連のあるシステムフレームワークをインポートしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Important</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>重要</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Imported C and Objective-C APIs</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インポートされたCおよびObjective-C API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Improving Objective-C API Declarations for Swift</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-C API宣言をSwift用に改める</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In Objective-C, you work with references to objects by using pointers that can be null, called <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> in Objective-C.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-Cでは、あなたはオブジェクトへの参照をヌル、Objective-Cにおいて<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>と呼ばれるもの、であることが可能なポインタを使用して扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In Swift, all values — including object instances — are guaranteed to be non-null.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftでは、すべての値は — オブジェクトインスタンスを含めて — 非ヌルであることが保証されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In Swift, only class instances and metatypes have unique identities.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftでは、クラスインスタンスとメタタイプだけが固有な識別子を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In Swift, the <bpt i="0" x="0">&lt;c0&gt;</bpt>UITable<bpt i="1" x="1">&lt;w1&gt;</bpt>View<bpt i="2" x="2">&lt;w2&gt;</bpt>Cell<bpt i="3" x="3">&lt;w3&gt;</bpt>Style<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> enumeration is imported like this:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftでは、<bpt i="0" x="0">&lt;c0&gt;</bpt>UITable<bpt i="1" x="1">&lt;w1&gt;</bpt>View<bpt i="2" x="2">&lt;w2&gt;</bpt>Cell<bpt i="3" x="3">&lt;w3&gt;</bpt>Style<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>列挙はこのようにインポートされます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In Swift, you use the <bpt i="0" x="0">&lt;c0&gt;</bpt>@available<ept i="0">&lt;/c0&gt;</ept> attribute to control whether a declaration is available to use when building an app for a particular target platform.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftでは、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>@available<ept i="0">&lt;/c0&gt;</ept>属性を使うことで、あるアプリを特定の対象プラットホーム用にビルドする時に、ある宣言が利用に応じられるかを制御します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In a <bpt i="0" x="0">&lt;c0&gt;</bpt>Repeated<ept i="0">&lt;/c0&gt;</ept> collection, <bpt i="1" x="1">&lt;c1&gt;</bpt>end<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is always equal to <bpt i="3" x="3">&lt;c3&gt;</bpt>count<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Repeated<ept i="0">&lt;/c0&gt;</ept>コレクションにおいて、<bpt i="1" x="1">&lt;c1&gt;</bpt>end<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>は常に<bpt i="3" x="3">&lt;c3&gt;</bpt>count<ept i="3">&lt;/c3&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In a <bpt i="0" x="0">&lt;c0&gt;</bpt>Repeated<ept i="0">&lt;/c0&gt;</ept> collection, <bpt i="1" x="1">&lt;c1&gt;</bpt>start<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is always equal to zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Repeated<ept i="0">&lt;/c0&gt;</ept>コレクションにおいて、<bpt i="1" x="1">&lt;c1&gt;</bpt>start<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>は常にゼロと等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In a collection, the subsequence should also conform to <bpt i="1" x="1">&lt;c1&gt;</bpt>Collection<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるコレクションにおいて、下位シーケンスはまた<bpt i="1" x="1">&lt;c1&gt;</bpt>Collection<ept i="1">&lt;/c1&gt;</ept>に準拠すべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In a mirror created with this ancestor representation, the <bpt i="0" x="0">&lt;c0&gt;</bpt>superclass<bpt i="1" x="1">&lt;w1&gt;</bpt>Mirror<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property is <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この先祖表現で作成されるミラーにおいて、<bpt i="0" x="0">&lt;c0&gt;</bpt>superclass<bpt i="1" x="1">&lt;w1&gt;</bpt>Mirror<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティは<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In addition to changing the value of an individual element, you can also change the values of a slice of elements in a mutable collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある一個の要素の値を変えることに加えて、あなたはまた可変コレクションの要素のスライスに属するいくらかの値を変更することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In addition to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Set<ept i="0">&lt;/c0&gt;</ept> type’s set operations, you can use any nonmutating sequence or collection methods with a set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Set<ept i="0">&lt;/c0&gt;</ept>型のもつ集合演算に加えて、あなたはあらゆる非可変のシーケンスまたはコレクションメソッドを集合で使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In addition to using an array literal, you can also create a set using these initializers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列リテラルを使うことに加えて、あなたはまた集合をこれらのイニシャライザを使って作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In addition, because <bpt i="1" x="1">&lt;c1&gt;</bpt>abs(_:)<ept i="1">&lt;/c1&gt;</ept> always returns a value of the same type, even in a generic context, using the function instead of the <bpt i="2" x="2">&lt;c2&gt;</bpt>magnitude<ept i="2">&lt;/c2&gt;</ept> property is encouraged.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>加えて、<bpt i="1" x="1">&lt;c1&gt;</bpt>abs(_:)<ept i="1">&lt;/c1&gt;</ept>は常に同じ型の値を返すことから、総称体の文脈においてさえも、この関数を<bpt i="2" x="2">&lt;c2&gt;</bpt>magnitude<ept i="2">&lt;/c2&gt;</ept>プロパティの代わりに使うことは推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In addition, because class instance properties are always stored out-of-line, their positions are not accessible using <bpt i="4" x="4">&lt;c4&gt;</bpt>offset(of:)<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その上、クラスインスタンスプロパティは常にアウトオブラインに格納されることから、それらの位置は<bpt i="4" x="4">&lt;c4&gt;</bpt>offset(of:)<ept i="4">&lt;/c4&gt;</ept>によってアクセス可能ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In an empty collection, <bpt i="0" x="0">&lt;c0&gt;</bpt>start<bpt i="1" x="1">&lt;w1&gt;</bpt>Index == end<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>空のコレクションでは、<bpt i="0" x="0">&lt;c0&gt;</bpt>start<bpt i="1" x="1">&lt;w1&gt;</bpt>Index == end<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In an empty range, <bpt i="0" x="0">&lt;c0&gt;</bpt>lower<bpt i="1" x="1">&lt;w1&gt;</bpt>Bound<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="2" x="2">&lt;c2&gt;</bpt>upper<bpt i="3" x="3">&lt;w3&gt;</bpt>Bound<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>空の範囲では、<bpt i="0" x="0">&lt;c0&gt;</bpt>lower<bpt i="1" x="1">&lt;w1&gt;</bpt>Bound<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>upper<bpt i="3" x="3">&lt;w3&gt;</bpt>Bound<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In an empty range, <bpt i="0" x="0">&lt;c0&gt;</bpt>upper<bpt i="1" x="1">&lt;w1&gt;</bpt>Bound<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="2" x="2">&lt;c2&gt;</bpt>lower<bpt i="3" x="3">&lt;w3&gt;</bpt>Bound<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>空の範囲では、<bpt i="0" x="0">&lt;c0&gt;</bpt>upper<bpt i="1" x="1">&lt;w1&gt;</bpt>Bound<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>lower<bpt i="3" x="3">&lt;w3&gt;</bpt>Bound<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In asynchronous APIs, the result won't be available until sometime later; this difference affects how you write code both <bpt i="1" x="1">&lt;e1&gt;</bpt>in<ept i="1">&lt;/e1&gt;</ept> your closure as well as the code <bpt i="2" x="2">&lt;e2&gt;</bpt>following<ept i="2">&lt;/e2&gt;</ept> your closure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>非同期APIでは、結果はいつか後まで利用可能でないでしょう；この違いは、あなたがコードを書く方法に、あなたのクロージャ<bpt i="1" x="1">&lt;e1&gt;</bpt>において<ept i="1">&lt;/e1&gt;</ept>それだけでなくあなたのクロージャ<bpt i="2" x="2">&lt;e2&gt;</bpt>の後の<ept i="2">&lt;/e2&gt;</ept>コードの両方で影響します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In code, the absence of a value is typically written using the <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> literal rather than the explicit <bpt i="1" x="1">&lt;c1&gt;</bpt>.none<ept i="1">&lt;/c1&gt;</ept> enumeration case.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コードにおいて、ある値の不在は一般的に<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>リテラルを使って書かれます、明示的な<bpt i="1" x="1">&lt;c1&gt;</bpt>.none<ept i="1">&lt;/c1&gt;</ept>列挙ケース節ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In contrast with the <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>Just<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> publisher, which always produces a single value, this publisher might not send any values and instead finish normally, if <bpt i="2" x="2">&lt;a2&gt;</bpt><bpt i="3" x="3">&lt;c3&gt;</bpt>output<ept i="3">&lt;/c3&gt;</ept><ept i="2">&lt;/a2&gt;</ept> is <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>常にある単一の値を生み出す<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>Just<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>パブリッシャーと対照的に、このパブリッシャーは全く値を送信しないで代わりに正常に終了するかもしれません、もし<bpt i="2" x="2">&lt;a2&gt;</bpt><bpt i="3" x="3">&lt;c3&gt;</bpt>output<ept i="3">&lt;/c3&gt;</ept><ept i="2">&lt;/a2&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>であるならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In contrast with the <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>Just<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> publisher, which always publishes a single value, this publisher might not send any values and instead finish normally if the optional’s <bpt i="2" x="2">&lt;a2&gt;</bpt><bpt i="3" x="3">&lt;c3&gt;</bpt>output<ept i="3">&lt;/c3&gt;</ept><ept i="2">&lt;/a2&gt;</ept> is <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>常にある単一の値を出版する<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>Just<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>パブリッシャーと対照的に、このパブリッシャーは全く値を送信しないで代わりに正常に終了するかもしれません、もし<bpt i="2" x="2">&lt;a2&gt;</bpt><bpt i="3" x="3">&lt;c3&gt;</bpt>output<ept i="3">&lt;/c3&gt;</ept><ept i="2">&lt;/a2&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>であるならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In contrast with the <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>Just<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> publisher, which always publishes a single value, this publisher might not send any values and instead terminate with an error, if the result is <bpt i="2" x="2">&lt;a2&gt;</bpt><bpt i="3" x="3">&lt;c3&gt;</bpt>Result<bpt i="4" x="4">&lt;w4&gt;</bpt>.failure(_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept><ept i="2">&lt;/a2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>常に単一の値を出版する<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>Just<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>パブリッシャーと対照的に、このパブリッシャーは全く値を送信しないで代わりにエラーで終了するかもしれません、もし結果が<bpt i="2" x="2">&lt;a2&gt;</bpt><bpt i="3" x="3">&lt;c3&gt;</bpt>Result<bpt i="4" x="4">&lt;w4&gt;</bpt>.failure(_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept><ept i="2">&lt;/a2&gt;</ept>であるならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In debug builds (<bpt i="0" x="0">&lt;c0&gt;</bpt>-Onone<ept i="0">&lt;/c0&gt;</ept>), the <bpt i="1" x="1">&lt;c1&gt;</bpt>unsafely<bpt i="2" x="2">&lt;w2&gt;</bpt>Unwrapped<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> property has the same behavior as using the postfix <bpt i="3" x="3">&lt;c3&gt;</bpt>!<ept i="3">&lt;/c3&gt;</ept> operator and triggers a runtime error if the instance is <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>デバッグビルド（<bpt i="0" x="0">&lt;c0&gt;</bpt>-Onone<ept i="0">&lt;/c0&gt;</ept>）において、<bpt i="1" x="1">&lt;c1&gt;</bpt>unsafely<bpt i="2" x="2">&lt;w2&gt;</bpt>Unwrapped<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>プロパティは後置<bpt i="3" x="3">&lt;c3&gt;</bpt>!<ept i="3">&lt;/c3&gt;</ept>演算子を使うのと同じ挙動を持ち、そしてインスタンスが<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>ならば実行時エラーの引き金となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In fact, <bpt i="0" x="0">&lt;c0&gt;</bpt>s<bpt i="1" x="1">&lt;w1&gt;</bpt>.flat<bpt i="2" x="2">&lt;w2&gt;</bpt>Map(transform)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equivalent to <bpt i="3" x="3">&lt;c3&gt;</bpt>Array(s<bpt i="4" x="4">&lt;w4&gt;</bpt>.map(transform).joined())<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>実際のところ、<bpt i="0" x="0">&lt;c0&gt;</bpt>s<bpt i="1" x="1">&lt;w1&gt;</bpt>.flat<bpt i="2" x="2">&lt;w2&gt;</bpt>Map(transform)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>Array(s<bpt i="4" x="4">&lt;w4&gt;</bpt>.map(transform).joined())<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In general, though, the observability of mutations is unspecified.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>もっとも、一般的に変異体の観察性は未規定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In many cases, only one sequence of calls is correct for your app, so it's important to think through what the state of your app will be, given the APIs you're using.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>多くの場合に、ただ１つの呼び出し順番だけがあなたのアプリにとって正しいです、それで重要なのは、あなたが使うAPIを与えられて、あなたのアプリの状態がどうなるのか考え抜くことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In most scenarios, you use the preserved result as part of broader functionality in your code.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ほとんどの状況では、あなたは保全された結果をあなたのコードにおけるより幅広い機能性の一部として使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other words, for ordinary collections <bpt i="1" x="1">&lt;c1&gt;</bpt>c<ept i="1">&lt;/c1&gt;</ept> having bidirectional indices:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>言い換えると、二方向性のインデックスを持つ通常のコレクション<bpt i="1" x="1">&lt;c1&gt;</bpt>c<ept i="1">&lt;/c1&gt;</ept>は：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In particular, <bpt i="0" x="0">&lt;c0&gt;</bpt>Memory<bpt i="1" x="1">&lt;w1&gt;</bpt>Layout&lt;T&gt;.size<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, when <bpt i="2" x="2">&lt;c2&gt;</bpt>T<ept i="2">&lt;/c2&gt;</ept> is a class type, is the same regardless of how many stored properties <bpt i="3" x="3">&lt;c3&gt;</bpt>T<ept i="3">&lt;/c3&gt;</ept> has.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>特に、<bpt i="0" x="0">&lt;c0&gt;</bpt>Memory<bpt i="1" x="1">&lt;w1&gt;</bpt>Layout&lt;T&gt;.size<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、<bpt i="2" x="2">&lt;c2&gt;</bpt>T<ept i="2">&lt;/c2&gt;</ept>がクラス型の時、<bpt i="3" x="3">&lt;c3&gt;</bpt>T<ept i="3">&lt;/c3&gt;</ept>がどのくらい多くの格納プロパティを持つかに関係なく同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In particular, negating a signed, fixed-width integer type’s minimum results in a value that cannot be represented.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>とりわけ、符号付きの、固定長整数型のもつ最小値を負にすることは、表現できない値という結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In particular, pointers and class instances all have the same contiguous memory footprint, regardless of the size of the referenced data.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>特に、ポインタおよびクラスインスタンスは、すべて同じ隣接メモリフットプリントを持ちます、参照されたデータの大きさに関係なく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In particular, the names <bpt i="2" x="2">&lt;c2&gt;</bpt>"Alicia"<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>"Chris"<ept i="3">&lt;/c3&gt;</ept>, and <bpt i="4" x="4">&lt;c4&gt;</bpt>"Diana"<ept i="4">&lt;/c4&gt;</ept> are removed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>個別的には、名前<bpt i="2" x="2">&lt;c2&gt;</bpt>"Alicia"<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>"Chris"<ept i="3">&lt;/c3&gt;</ept>、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>"Diana"<ept i="4">&lt;/c4&gt;</ept>は、削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In particular, the names <bpt i="2" x="2">&lt;c2&gt;</bpt>"Bethany"<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>"Eric"<ept i="3">&lt;/c3&gt;</ept> are removed from <bpt i="4" x="4">&lt;c4&gt;</bpt>employees<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>個別的には、<bpt i="2" x="2">&lt;c2&gt;</bpt>"Bethany"<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>"Eric"<ept i="3">&lt;/c3&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt>employees<ept i="4">&lt;/c4&gt;</ept>から削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In particular, the names <bpt i="6" x="6">&lt;c6&gt;</bpt>"Alicia"<ept i="6">&lt;/c6&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt>"Chris"<ept i="7">&lt;/c7&gt;</ept>, and <bpt i="8" x="8">&lt;c8&gt;</bpt>"Diana"<ept i="8">&lt;/c8&gt;</ept> are removed from <bpt i="9" x="9">&lt;c9&gt;</bpt>employees<ept i="9">&lt;/c9&gt;</ept> while the names <bpt i="10" x="10">&lt;c10&gt;</bpt>"Forlani"<ept i="10">&lt;/c10&gt;</ept> and <bpt i="11" x="11">&lt;c11&gt;</bpt>"Greta"<ept i="11">&lt;/c11&gt;</ept> are added.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>個別的には、名前<bpt i="6" x="6">&lt;c6&gt;</bpt>"Alicia"<ept i="6">&lt;/c6&gt;</ept>、<bpt i="7" x="7">&lt;c7&gt;</bpt>"Chris"<ept i="7">&lt;/c7&gt;</ept>、そして<bpt i="8" x="8">&lt;c8&gt;</bpt>"Diana"<ept i="8">&lt;/c8&gt;</ept>は、<bpt i="9" x="9">&lt;c9&gt;</bpt>employees<ept i="9">&lt;/c9&gt;</ept>から削除される一方で名前<bpt i="10" x="10">&lt;c10&gt;</bpt>"Forlani"<ept i="10">&lt;/c10&gt;</ept>と<bpt i="11" x="11">&lt;c11&gt;</bpt>"Greta"<ept i="11">&lt;/c11&gt;</ept>は加えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In particular, the names <bpt i="6" x="6">&lt;c6&gt;</bpt>"Bethany"<ept i="6">&lt;/c6&gt;</ept> and <bpt i="7" x="7">&lt;c7&gt;</bpt>"Eric"<ept i="7">&lt;/c7&gt;</ept> are removed from <bpt i="8" x="8">&lt;c8&gt;</bpt>employees<ept i="8">&lt;/c8&gt;</ept> while the name <bpt i="9" x="9">&lt;c9&gt;</bpt>"Forlani"<ept i="9">&lt;/c9&gt;</ept> is added.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>個別的には、名前<bpt i="6" x="6">&lt;c6&gt;</bpt>"Bethany"<ept i="6">&lt;/c6&gt;</ept>と<bpt i="7" x="7">&lt;c7&gt;</bpt>"Eric"<ept i="7">&lt;/c7&gt;</ept>は<bpt i="8" x="8">&lt;c8&gt;</bpt>employees<ept i="8">&lt;/c8&gt;</ept>から削除される一方、名前<bpt i="9" x="9">&lt;c9&gt;</bpt>"Forlani"<ept i="9">&lt;/c9&gt;</ept>は加えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In particular, the names <bpt i="9" x="9">&lt;c9&gt;</bpt>"Bethany"<ept i="9">&lt;/c9&gt;</ept> and <bpt i="10" x="10">&lt;c10&gt;</bpt>"Eric"<ept i="10">&lt;/c10&gt;</ept> do not appear in <bpt i="11" x="11">&lt;c11&gt;</bpt>either<bpt i="12" x="12">&lt;w12&gt;</bpt>Neighbors<bpt i="13" x="13">&lt;w13&gt;</bpt>Or<bpt i="14" x="14">&lt;w14&gt;</bpt>Employees<ept i="14">&lt;/w14&gt;</ept><ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>個別的には、名前<bpt i="9" x="9">&lt;c9&gt;</bpt>"Bethany"<ept i="9">&lt;/c9&gt;</ept>と<bpt i="10" x="10">&lt;c10&gt;</bpt>"Eric"<ept i="10">&lt;/c10&gt;</ept>は、<bpt i="11" x="11">&lt;c11&gt;</bpt>either<bpt i="12" x="12">&lt;w12&gt;</bpt>Neighbors<bpt i="13" x="13">&lt;w13&gt;</bpt>Or<bpt i="14" x="14">&lt;w14&gt;</bpt>Employees<ept i="14">&lt;/w14&gt;</ept><ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>の中に現れません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In particular, to find the value matching a key, you must search through every element of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>特に、あるキーに合った値を見つけるには、あなたはコレクションのすべての要素を通して検索しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In some cases, <bpt i="12" x="12">&lt;c12&gt;</bpt>old<bpt i="13" x="13">&lt;w13&gt;</bpt>Member<ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> may be distinguishable from <bpt i="14" x="14">&lt;c14&gt;</bpt>new<bpt i="15" x="15">&lt;w15&gt;</bpt>Member<ept i="15">&lt;/w15&gt;</ept><ept i="14">&lt;/c14&gt;</ept> by identity comparison or some other means.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>いくつかの場合には、<bpt i="12" x="12">&lt;c12&gt;</bpt>old<bpt i="13" x="13">&lt;w13&gt;</bpt>Member<ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>は同一性比較または何らかの他の意味で<bpt i="14" x="14">&lt;c14&gt;</bpt>new<bpt i="15" x="15">&lt;w15&gt;</bpt>Member<ept i="15">&lt;/w15&gt;</ept><ept i="14">&lt;/c14&gt;</ept>から区別可能であるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In some cases, a returned element may be distinguishable from <bpt i="3" x="3">&lt;c3&gt;</bpt>member<ept i="3">&lt;/c3&gt;</ept> by identity comparison or some other means.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>いくつかの場合には、ある返される要素は、同一性比較または何らかの他の意味で<bpt i="3" x="3">&lt;c3&gt;</bpt>member<ept i="3">&lt;/c3&gt;</ept>から区別可能であるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In some cases, the returned element may be distinguishable from <bpt i="3" x="3">&lt;c3&gt;</bpt>new<bpt i="4" x="4">&lt;w4&gt;</bpt>Member<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> by identity comparison or some other means.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>いくつかの場合には、返される要素は、同一性比較または何らかの他の意味で<bpt i="3" x="3">&lt;c3&gt;</bpt>new<bpt i="4" x="4">&lt;w4&gt;</bpt>Member<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>から区別可能であるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In synchronous APIs, the result of calling the closure will be available immediately after you pass the closure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同期APIでは、クロージャ呼び出しの結果は、あなたがクロージャを渡した直後に利用可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In that case, the method returns <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その場合には、このメソッドは<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the case of the <bpt i="0" x="0">&lt;c0&gt;</bpt>Directions<ept i="0">&lt;/c0&gt;</ept> option set, an instance can contain zero, one, or more of the four defined directions.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Directions<ept i="0">&lt;/c0&gt;</ept>オプションセットの場合では、あるインスタンスは４つ定義された方向のうちゼロ、１つ、またはそれ以上を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the example above, <bpt i="0" x="0">&lt;c0&gt;</bpt>more<bpt i="1" x="1">&lt;w1&gt;</bpt>Numbers<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> has the same type as <bpt i="2" x="2">&lt;c2&gt;</bpt>numbers<ept i="2">&lt;/c2&gt;</ept>, which is <bpt i="3" x="3">&lt;c3&gt;</bpt>[Int]<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>上の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>more<bpt i="1" x="1">&lt;w1&gt;</bpt>Numbers<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>numbers<ept i="2">&lt;/c2&gt;</ept>と同じ型を持ちます、それは<bpt i="3" x="3">&lt;c3&gt;</bpt>[Int]<ept i="3">&lt;/c3&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the example, because the <bpt i="0" x="0">&lt;c0&gt;</bpt>express<ept i="0">&lt;/c0&gt;</ept> static property is assigned an array literal with the <bpt i="1" x="1">&lt;c1&gt;</bpt>next<bpt i="2" x="2">&lt;w2&gt;</bpt>Day<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>second<bpt i="4" x="4">&lt;w4&gt;</bpt>Day<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> options, it will contain those two elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>express<ept i="0">&lt;/c0&gt;</ept>静的プロパティは<bpt i="1" x="1">&lt;c1&gt;</bpt>next<bpt i="2" x="2">&lt;w2&gt;</bpt>Day<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>second<bpt i="4" x="4">&lt;w4&gt;</bpt>Day<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>オプションを持つ配列リテラルを割り当てられるので、それはそれら２つの要素を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, <bpt i="0" x="0">&lt;c0&gt;</bpt>good<bpt i="1" x="1">&lt;w1&gt;</bpt>Result<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> provides a successful result with the integer value <bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>good<bpt i="1" x="1">&lt;w1&gt;</bpt>Result<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は成功結果を整数値の<bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>で提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, a new element is inserted into <bpt i="2" x="2">&lt;c2&gt;</bpt>class<bpt i="3" x="3">&lt;w3&gt;</bpt>Days<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, a set of days of the week.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例において、新しい要素が、一揃いの曜日<bpt i="2" x="2">&lt;c2&gt;</bpt>class<bpt i="3" x="3">&lt;w3&gt;</bpt>Days<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>へ挿入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, an array of numbers is partitioned by a predicate that matches elements greater than 30.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の例において、数からなる配列は、30より大きな要素に合致するという述部によって仕切られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, because the extension applies only to <bpt i="3" x="3">&lt;c3&gt;</bpt>Sequence<ept i="3">&lt;/c3&gt;</ept>, side-effects such as the accumulation of <bpt i="4" x="4">&lt;c4&gt;</bpt>result<ept i="4">&lt;/c4&gt;</ept> are never unexpectedly dropped or deferred:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例において、拡張は<bpt i="3" x="3">&lt;c3&gt;</bpt>Sequence<ept i="3">&lt;/c3&gt;</ept>に対してのみ適用されることから、副作用それら、たとえば<bpt i="4" x="4">&lt;c4&gt;</bpt>result<ept i="4">&lt;/c4&gt;</ept>の蓄積などは、決して不意に投下されたり延期されたりしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>.priority<ept i="0">&lt;/c0&gt;</ept> shipping option is removed from the <bpt i="1" x="1">&lt;c1&gt;</bpt>options<ept i="1">&lt;/c1&gt;</ept> option set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>.priority<ept i="0">&lt;/c0&gt;</ept>出荷オプションは、<bpt i="1" x="1">&lt;c1&gt;</bpt>options<ept i="1">&lt;/c1&gt;</ept>オプションセットから削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>.second<bpt i="1" x="1">&lt;w1&gt;</bpt>Day<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> shipping option is added to the <bpt i="2" x="2">&lt;c2&gt;</bpt>free<bpt i="3" x="3">&lt;w3&gt;</bpt>Options<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> option set if <bpt i="4" x="4">&lt;c4&gt;</bpt>purchase<bpt i="5" x="5">&lt;w5&gt;</bpt>Price<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is greater than 50.0.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>.second<bpt i="1" x="1">&lt;w1&gt;</bpt>Day<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>出荷オプションは、<bpt i="2" x="2">&lt;c2&gt;</bpt>purchase<bpt i="3" x="3">&lt;w3&gt;</bpt>Price<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が50.0より大きいならば、<bpt i="4" x="4">&lt;c4&gt;</bpt>free<bpt i="5" x="5">&lt;w5&gt;</bpt>Options<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>オプションセットを加えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>ascii<bpt i="1" x="1">&lt;w1&gt;</bpt>Table<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> sequence is made by zipping together the characters in the <bpt i="2" x="2">&lt;c2&gt;</bpt>alphabet<ept i="2">&lt;/c2&gt;</ept> string with a partial range starting at 65, the ASCII value of the capital letter A. Iterating over two zipped sequences continues only as long as the shorter of the two sequences, so the iteration stops at the end of <bpt i="3" x="3">&lt;c3&gt;</bpt>alphabet<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>ascii<bpt i="1" x="1">&lt;w1&gt;</bpt>Table<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>シーケンスは、<bpt i="2" x="2">&lt;c2&gt;</bpt>alphabet<ept i="2">&lt;/c2&gt;</ept>文字列中の文字を65で始まるある部分範囲と一緒に閉じ合わせることによって作られます。２つの閉じ合わされたシーケンスそれらに反復することは、より短いほうと同じだけ続きます、それでこの反復は<bpt i="3" x="3">&lt;c3&gt;</bpt>alphabet<ept i="3">&lt;/c3&gt;</ept>の終わりで停止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>attendees<bpt i="1" x="1">&lt;w1&gt;</bpt>And<bpt i="2" x="2">&lt;w2&gt;</bpt>Visitors<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> set is made up of the elements of the <bpt i="3" x="3">&lt;c3&gt;</bpt>attendees<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>visitors<ept i="4">&lt;/c4&gt;</ept> sets:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>attendees<bpt i="1" x="1">&lt;w1&gt;</bpt>And<bpt i="2" x="2">&lt;w2&gt;</bpt>Visitors<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>集合は<bpt i="3" x="3">&lt;c3&gt;</bpt>attendees<ept i="3">&lt;/c3&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>visitors<ept i="4">&lt;/c4&gt;</ept>集合の要素から作り上げられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>attendees<bpt i="1" x="1">&lt;w1&gt;</bpt>And<bpt i="2" x="2">&lt;w2&gt;</bpt>Visitors<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> set is made up of the elements of the <bpt i="3" x="3">&lt;c3&gt;</bpt>attendees<ept i="3">&lt;/c3&gt;</ept> set and the <bpt i="4" x="4">&lt;c4&gt;</bpt>visitors<ept i="4">&lt;/c4&gt;</ept> array:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>attendees<bpt i="1" x="1">&lt;w1&gt;</bpt>And<bpt i="2" x="2">&lt;w2&gt;</bpt>Visitors<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>集合は<bpt i="3" x="3">&lt;c3&gt;</bpt>attendees<ept i="3">&lt;/c3&gt;</ept>集合と<bpt i="4" x="4">&lt;c4&gt;</bpt>visitors<ept i="4">&lt;/c4&gt;</ept>配列の要素から作り上げられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>both<bpt i="1" x="1">&lt;w1&gt;</bpt>Neighbors<bpt i="2" x="2">&lt;w2&gt;</bpt>And<bpt i="3" x="3">&lt;w3&gt;</bpt>Employees<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> set is made up of the elements that are in <bpt i="4" x="4">&lt;e4&gt;</bpt>both<ept i="4">&lt;/e4&gt;</ept> the <bpt i="5" x="5">&lt;c5&gt;</bpt>employees<ept i="5">&lt;/c5&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt>neighbors<ept i="6">&lt;/c6&gt;</ept> sets.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>both<bpt i="1" x="1">&lt;w1&gt;</bpt>Neighbors<bpt i="2" x="2">&lt;w2&gt;</bpt>And<bpt i="3" x="3">&lt;w3&gt;</bpt>Employees<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>集合は<bpt i="5" x="5">&lt;c5&gt;</bpt>employees<ept i="5">&lt;/c5&gt;</ept>と<bpt i="6" x="6">&lt;c6&gt;</bpt>neighbors<ept i="6">&lt;/c6&gt;</ept>集合の<bpt i="4" x="4">&lt;e4&gt;</bpt>両方<ept i="4">&lt;/e4&gt;</ept>にある要素から作り上げられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>either<bpt i="1" x="1">&lt;w1&gt;</bpt>Neighbors<bpt i="2" x="2">&lt;w2&gt;</bpt>Or<bpt i="3" x="3">&lt;w3&gt;</bpt>Employees<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> set is made up of the elements of the <bpt i="4" x="4">&lt;c4&gt;</bpt>employees<ept i="4">&lt;/c4&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt>neighbors<ept i="5">&lt;/c5&gt;</ept> sets that are not in both <bpt i="6" x="6">&lt;c6&gt;</bpt>employees<ept i="6">&lt;/c6&gt;</ept> <bpt i="7" x="7">&lt;e7&gt;</bpt>and<ept i="7">&lt;/e7&gt;</ept> <bpt i="8" x="8">&lt;c8&gt;</bpt>neighbors<ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>either<bpt i="1" x="1">&lt;w1&gt;</bpt>Neighbors<bpt i="2" x="2">&lt;w2&gt;</bpt>Or<bpt i="3" x="3">&lt;w3&gt;</bpt>Employees<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>集合は<bpt i="4" x="4">&lt;c4&gt;</bpt>employees<ept i="4">&lt;/c4&gt;</ept>と<bpt i="5" x="5">&lt;c5&gt;</bpt>neighbors<ept i="5">&lt;/c5&gt;</ept>集合の要素で、<bpt i="6" x="6">&lt;c6&gt;</bpt>employees<ept i="6">&lt;/c6&gt;</ept><bpt i="7" x="7">&lt;e7&gt;</bpt>および<ept i="7">&lt;/e7&gt;</ept><bpt i="8" x="8">&lt;c8&gt;</bpt>neighbors<ept i="8">&lt;/c8&gt;</ept>の両方の中にはないものから作り上げられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>employees<ept i="0">&lt;/c0&gt;</ept> set is disjoint with the <bpt i="1" x="1">&lt;c1&gt;</bpt>visitors<ept i="1">&lt;/c1&gt;</ept> set because no name appears in both sets.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>employees<ept i="0">&lt;/c0&gt;</ept>集合は<bpt i="1" x="1">&lt;c1&gt;</bpt>visitors<ept i="1">&lt;/c1&gt;</ept>集合と交わりを持ちません、両方に現れる名前がないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>employees<ept i="0">&lt;/c0&gt;</ept> set is disjoint with the elements of the <bpt i="1" x="1">&lt;c1&gt;</bpt>visitors<ept i="1">&lt;/c1&gt;</ept> array because no name appears in both.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>employees<ept i="0">&lt;/c0&gt;</ept>集合は<bpt i="1" x="1">&lt;c1&gt;</bpt>visitors<ept i="1">&lt;/c1&gt;</ept>配列の要素と交わりを持ちません、両方に現れる名前がないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>non<bpt i="1" x="1">&lt;w1&gt;</bpt>Neighbors<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> set is made up of the elements of the <bpt i="2" x="2">&lt;c2&gt;</bpt>employees<ept i="2">&lt;/c2&gt;</ept> set that are not elements of <bpt i="3" x="3">&lt;c3&gt;</bpt>neighbors<ept i="3">&lt;/c3&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>non<bpt i="1" x="1">&lt;w1&gt;</bpt>Neighbors<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>集合は<bpt i="2" x="2">&lt;c2&gt;</bpt>employees<ept i="2">&lt;/c2&gt;</ept>集合の要素で<bpt i="3" x="3">&lt;c3&gt;</bpt>neighbors<ept i="3">&lt;/c3&gt;</ept>の要素でないものから作り上げられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>number<bpt i="1" x="1">&lt;w1&gt;</bpt>To<bpt i="2" x="2">&lt;w2&gt;</bpt>Match<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> constant is wrapped as an optional before comparing to the optional <bpt i="3" x="3">&lt;c3&gt;</bpt>number<bpt i="4" x="4">&lt;w4&gt;</bpt>From<bpt i="5" x="5">&lt;w5&gt;</bpt>String<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>続く例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>number<bpt i="1" x="1">&lt;w1&gt;</bpt>To<bpt i="2" x="2">&lt;w2&gt;</bpt>Match<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>定数は、オプショナル<bpt i="3" x="3">&lt;c3&gt;</bpt>number<bpt i="4" x="4">&lt;w4&gt;</bpt>From<bpt i="5" x="5">&lt;w5&gt;</bpt>String<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>との比較の前にオプショナル値としてラップされます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the closure provides an ordering for an array of a custom enumeration that describes an HTTP response.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例では、そのクロージャは、あるHTTP応答を記述するあつらえ列挙の配列に対してある順序付けを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the constant <bpt i="0" x="0">&lt;c0&gt;</bpt>y<ept i="0">&lt;/c0&gt;</ept> is successfully created from <bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept>, an <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept> instance with a value of <bpt i="3" x="3">&lt;c3&gt;</bpt>100<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例において、定数<bpt i="0" x="0">&lt;c0&gt;</bpt>y<ept i="0">&lt;/c0&gt;</ept>は、<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>インスタンスで<bpt i="2" x="2">&lt;c2&gt;</bpt>100<ept i="2">&lt;/c2&gt;</ept>の値を持つ<bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>からうまく作成されます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the constant <bpt i="2" x="2">&lt;c2&gt;</bpt>x<ept i="2">&lt;/c2&gt;</ept> is successfully created from a value of <bpt i="3" x="3">&lt;c3&gt;</bpt>100<ept i="3">&lt;/c3&gt;</ept>, while the attempt to initialize the constant <bpt i="4" x="4">&lt;c4&gt;</bpt>y<ept i="4">&lt;/c4&gt;</ept> from <bpt i="5" x="5">&lt;c5&gt;</bpt>1<bpt i="6" x="6">&lt;w6&gt;</bpt>_000<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> fails because the <bpt i="7" x="7">&lt;c7&gt;</bpt>Int8<ept i="7">&lt;/c7&gt;</ept> type can represent <bpt i="8" x="8">&lt;c8&gt;</bpt>127<ept i="8">&lt;/c8&gt;</ept> at maximum:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例において、定数<bpt i="2" x="2">&lt;c2&gt;</bpt>x<ept i="2">&lt;/c2&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>100<ept i="3">&lt;/c3&gt;</ept>の値から首尾よく作り上げられます、一方で定数<bpt i="4" x="4">&lt;c4&gt;</bpt>y<ept i="4">&lt;/c4&gt;</ept>を<bpt i="5" x="5">&lt;c5&gt;</bpt>1<bpt i="6" x="6">&lt;w6&gt;</bpt>_000<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>から初期化する試みは失敗します、なぜなら<bpt i="7" x="7">&lt;c7&gt;</bpt>Int8<ept i="7">&lt;/c7&gt;</ept>型は最大で<bpt i="8" x="8">&lt;c8&gt;</bpt>127<ept i="8">&lt;/c8&gt;</ept>を表現可能だからです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the constant <bpt i="2" x="2">&lt;c2&gt;</bpt>x<ept i="2">&lt;/c2&gt;</ept> is successfully created from a value of <bpt i="3" x="3">&lt;c3&gt;</bpt>21<bpt i="4" x="4">&lt;w4&gt;</bpt>.0<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, while the attempt to initialize the constant <bpt i="5" x="5">&lt;c5&gt;</bpt>y<ept i="5">&lt;/c5&gt;</ept> from <bpt i="6" x="6">&lt;c6&gt;</bpt>21<bpt i="7" x="7">&lt;w7&gt;</bpt>.5<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> fails:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>続く例において、定数<bpt i="2" x="2">&lt;c2&gt;</bpt>x<ept i="2">&lt;/c2&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>21<bpt i="4" x="4">&lt;w4&gt;</bpt>.0<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>の値から首尾よく作成されます、一方で定数<bpt i="5" x="5">&lt;c5&gt;</bpt>y<ept i="5">&lt;/c5&gt;</ept>を<bpt i="6" x="6">&lt;c6&gt;</bpt>21<bpt i="7" x="7">&lt;w7&gt;</bpt>.5<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>から初期化する試みは失敗します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the difference of <bpt i="1" x="1">&lt;c1&gt;</bpt>10<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>21<ept i="2">&lt;/c2&gt;</ept> is less than zero, the minimum representable <bpt i="3" x="3">&lt;c3&gt;</bpt>UInt<ept i="3">&lt;/c3&gt;</ept> value, so the result is the partial value after discarding the overflowing bits.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例において、<bpt i="1" x="1">&lt;c1&gt;</bpt>10<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>21<ept i="2">&lt;/c2&gt;</ept>の差はゼロ、最小限表現可能な<bpt i="3" x="3">&lt;c3&gt;</bpt>UInt<ept i="3">&lt;/c3&gt;</ept>値、よりも少ないです、それで結果はオーバーフローするビットを廃棄後の部分的な値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the difference of <bpt i="1" x="1">&lt;c1&gt;</bpt>10<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>21<ept i="2">&lt;/c2&gt;</ept> is less than zero, the minimum representable <bpt i="3" x="3">&lt;c3&gt;</bpt>UInt<ept i="3">&lt;/c3&gt;</ept> value, so the result is the result is the partial value after discarding the overflowing bits.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例において、<bpt i="1" x="1">&lt;c1&gt;</bpt>10<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>21<ept i="2">&lt;/c2&gt;</ept>の差はゼロ、最小限表現可能な<bpt i="3" x="3">&lt;c3&gt;</bpt>UInt<ept i="3">&lt;/c3&gt;</ept>値、よりも少ないです、それで結果はオーバーフローするビットを廃棄後の部分的な値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the elements of the <bpt i="0" x="0">&lt;c0&gt;</bpt>employees<ept i="0">&lt;/c0&gt;</ept> set that are also elements of the <bpt i="1" x="1">&lt;c1&gt;</bpt>neighbors<ept i="1">&lt;/c1&gt;</ept> array are removed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>employees<ept i="0">&lt;/c0&gt;</ept>集合の要素でまた<bpt i="1" x="1">&lt;c1&gt;</bpt>neighbors<ept i="1">&lt;/c1&gt;</ept>配列の要素でもあるものは削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the elements of the <bpt i="0" x="0">&lt;c0&gt;</bpt>employees<ept i="0">&lt;/c0&gt;</ept> set that are also members of <bpt i="1" x="1">&lt;c1&gt;</bpt>neighbors<ept i="1">&lt;/c1&gt;</ept> are removed from <bpt i="2" x="2">&lt;c2&gt;</bpt>employees<ept i="2">&lt;/c2&gt;</ept>, while the elements of <bpt i="3" x="3">&lt;c3&gt;</bpt>neighbors<ept i="3">&lt;/c3&gt;</ept> that are not members of <bpt i="4" x="4">&lt;c4&gt;</bpt>employees<ept i="4">&lt;/c4&gt;</ept> are added to <bpt i="5" x="5">&lt;c5&gt;</bpt>employees<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>employees<ept i="0">&lt;/c0&gt;</ept>集合の要素でまた<bpt i="1" x="1">&lt;c1&gt;</bpt>neighbors<ept i="1">&lt;/c1&gt;</ept>のメンバであるものは<bpt i="2" x="2">&lt;c2&gt;</bpt>employees<ept i="2">&lt;/c2&gt;</ept>から削除されます、一方で<bpt i="3" x="3">&lt;c3&gt;</bpt>neighbors<ept i="3">&lt;/c3&gt;</ept>の要素で<bpt i="4" x="4">&lt;c4&gt;</bpt>employees<ept i="4">&lt;/c4&gt;</ept>の要素でないものは<bpt i="5" x="5">&lt;c5&gt;</bpt>employees<ept i="5">&lt;/c5&gt;</ept>に加えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the elements of the <bpt i="0" x="0">&lt;c0&gt;</bpt>employees<ept i="0">&lt;/c0&gt;</ept> set that are also members of the <bpt i="1" x="1">&lt;c1&gt;</bpt>neighbors<ept i="1">&lt;/c1&gt;</ept> set are removed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>employees<ept i="0">&lt;/c0&gt;</ept>集合の要素でまた<bpt i="1" x="1">&lt;c1&gt;</bpt>neighbors<ept i="1">&lt;/c1&gt;</ept>集合のメンバでもあるものは削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the elements of the <bpt i="0" x="0">&lt;c0&gt;</bpt>employees<ept i="0">&lt;/c0&gt;</ept> set that are not also members of the <bpt i="1" x="1">&lt;c1&gt;</bpt>neighbors<ept i="1">&lt;/c1&gt;</ept> set are removed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>employees<ept i="0">&lt;/c0&gt;</ept>集合の要素でまた<bpt i="1" x="1">&lt;c1&gt;</bpt>neighbors<ept i="1">&lt;/c1&gt;</ept>集合のメンバではないものは削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the elements of the <bpt i="0" x="0">&lt;c0&gt;</bpt>visitors<ept i="0">&lt;/c0&gt;</ept> set are added to the <bpt i="1" x="1">&lt;c1&gt;</bpt>attendees<ept i="1">&lt;/c1&gt;</ept> set:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>visitors<ept i="0">&lt;/c0&gt;</ept>集合の要素は<bpt i="1" x="1">&lt;c1&gt;</bpt>attendees<ept i="1">&lt;/c1&gt;</ept>集合に加えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the predicate provides an ordering for an array of a custom <bpt i="0" x="0">&lt;c0&gt;</bpt>HTTPResponse<ept i="0">&lt;/c0&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例では、その述部はあつらえの<bpt i="0" x="0">&lt;c0&gt;</bpt>HTTPResponse<ept i="0">&lt;/c0&gt;</ept>型の配列に対してある順序付けを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the product of <bpt i="1" x="1">&lt;c1&gt;</bpt>10<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>50<ept i="2">&lt;/c2&gt;</ept> is greater than the maximum representable <bpt i="3" x="3">&lt;c3&gt;</bpt>Int8<ept i="3">&lt;/c3&gt;</ept> value, so the result is the partial value after discarding the overflowing bits.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例において、<bpt i="1" x="1">&lt;c1&gt;</bpt>10<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>50<ept i="2">&lt;/c2&gt;</ept>の積は、最大限表現可能な<bpt i="3" x="3">&lt;c3&gt;</bpt>Int8<ept i="3">&lt;/c3&gt;</ept>値より大きいです、それで結果はオーバーフローするビットを廃棄後の部分的な値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the publisher for an <bpt i="0" x="0">&lt;c0&gt;</bpt>Int?<ept i="0">&lt;/c0&gt;</ept> optional publishes its value once, then finishes normally:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例において、ある<bpt i="0" x="0">&lt;c0&gt;</bpt>Int?<ept i="0">&lt;/c0&gt;</ept>オプショナルに対するパブリッシャーは、それの値を一度だけ出版します、それから正常に終了します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the result of <bpt i="0" x="0">&lt;c0&gt;</bpt>21 * 21<ept i="0">&lt;/c0&gt;</ept> is greater than the maximum representable <bpt i="1" x="1">&lt;c1&gt;</bpt>Int8<ept i="1">&lt;/c1&gt;</ept> value:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>21 * 21<ept i="0">&lt;/c0&gt;</ept>の結果は、最大限表現可能な<bpt i="1" x="1">&lt;c1&gt;</bpt>Int8<ept i="1">&lt;/c1&gt;</ept>値より大きいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the result of <bpt i="0" x="0">&lt;c0&gt;</bpt>21 + 120<ept i="0">&lt;/c0&gt;</ept> is greater than the maximum representable <bpt i="1" x="1">&lt;c1&gt;</bpt>Int8<ept i="1">&lt;/c1&gt;</ept> value:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>21 + 120<ept i="0">&lt;/c0&gt;</ept>の結果は、最大限表現可能な<bpt i="1" x="1">&lt;c1&gt;</bpt>Int8<ept i="1">&lt;/c1&gt;</ept>値より大きいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the result of <bpt i="0" x="0">&lt;c0&gt;</bpt>21 - 50<ept i="0">&lt;/c0&gt;</ept> is less than zero, the minimum representable <bpt i="1" x="1">&lt;c1&gt;</bpt>UInt8<ept i="1">&lt;/c1&gt;</ept> value:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>21 - 50<ept i="0">&lt;/c0&gt;</ept>の結果は、最大限表現可能な<bpt i="1" x="1">&lt;c1&gt;</bpt>UInt8<ept i="1">&lt;/c1&gt;</ept>値より大きいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the sum of <bpt i="1" x="1">&lt;c1&gt;</bpt>100<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>121<ept i="2">&lt;/c2&gt;</ept> is greater than the maximum representable <bpt i="3" x="3">&lt;c3&gt;</bpt>Int8<ept i="3">&lt;/c3&gt;</ept> value, so the result is the partial value after discarding the overflowing bits.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例において、<bpt i="1" x="1">&lt;c1&gt;</bpt>100<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>121<ept i="2">&lt;/c2&gt;</ept>の合計は、最大限表現可能な<bpt i="3" x="3">&lt;c3&gt;</bpt>Int8<ept i="3">&lt;/c3&gt;</ept>値より大きいです、それで結果はオーバーフローするビットを廃棄後の部分的な値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the next example, <bpt i="5" x="5">&lt;c5&gt;</bpt>bad<bpt i="6" x="6">&lt;w6&gt;</bpt>Result<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> is a failure result that wraps a custom error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の例において、<bpt i="5" x="5">&lt;c5&gt;</bpt>bad<bpt i="6" x="6">&lt;w6&gt;</bpt>Result<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>はある不成功結果です、それはあるあつらえのエラーをラップするものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the next example, an <bpt i="5" x="5">&lt;c5&gt;</bpt>Int?<ept i="5">&lt;/c5&gt;</ept> optional that’s <bpt i="6" x="6">&lt;c6&gt;</bpt>nil<ept i="6">&lt;/c6&gt;</ept> immediately sends the <bpt i="7" x="7">&lt;a7&gt;</bpt><bpt i="8" x="8">&lt;c8&gt;</bpt>Subscribers<bpt i="9" x="9">&lt;w9&gt;</bpt>.Completion<bpt i="10" x="10">&lt;w10&gt;</bpt>.finished<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept><ept i="7">&lt;/a7&gt;</ept> completion, without producing any values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の例において、ある<bpt i="5" x="5">&lt;c5&gt;</bpt>Int?<ept i="5">&lt;/c5&gt;</ept>オプショナルで<bpt i="6" x="6">&lt;c6&gt;</bpt>nil<ept i="6">&lt;/c6&gt;</ept>であるものは、直接に<bpt i="7" x="7">&lt;a7&gt;</bpt><bpt i="8" x="8">&lt;c8&gt;</bpt>Subscribers<bpt i="9" x="9">&lt;w9&gt;</bpt>.Completion<bpt i="10" x="10">&lt;w10&gt;</bpt>.finished<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept><ept i="7">&lt;/a7&gt;</ept>達成状態を送信します、何ら値を生み出すことなしに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the next example, an integer literal is compared with the optional integer <bpt i="0" x="0">&lt;c0&gt;</bpt>number<bpt i="1" x="1">&lt;w1&gt;</bpt>From<bpt i="2" x="2">&lt;w2&gt;</bpt>String<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の例では、整数リテラルがオプショナル整数<bpt i="0" x="0">&lt;c0&gt;</bpt>number<bpt i="1" x="1">&lt;w1&gt;</bpt>From<bpt i="2" x="2">&lt;w2&gt;</bpt>String<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the next example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>.express<ept i="0">&lt;/c0&gt;</ept> element is passed to <bpt i="1" x="1">&lt;c1&gt;</bpt>remove(_:)<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の例では、<bpt i="0" x="0">&lt;c0&gt;</bpt>.express<ept i="0">&lt;/c0&gt;</ept>要素が<bpt i="1" x="1">&lt;c1&gt;</bpt>remove(_:)<ept i="1">&lt;/c1&gt;</ept>に渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the standard library, you can use the <bpt i="2" x="2">&lt;c2&gt;</bpt>Set<ept i="2">&lt;/c2&gt;</ept> type with elements of any hashable type, or you can easily create bit masks with <bpt i="3" x="3">&lt;c3&gt;</bpt>Set<bpt i="4" x="4">&lt;w4&gt;</bpt>Algebra<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> conformance using the <bpt i="5" x="5">&lt;c5&gt;</bpt>Option<bpt i="6" x="6">&lt;w6&gt;</bpt>Set<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>標準ライブラリにおいて、あなたは<bpt i="2" x="2">&lt;c2&gt;</bpt>Set<ept i="2">&lt;/c2&gt;</ept>型を何らかのハッシュ型の要素で使うことができます、またはあなたは<bpt i="3" x="3">&lt;c3&gt;</bpt>Set<bpt i="4" x="4">&lt;w4&gt;</bpt>Algebra<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>準拠を持つビットマスクを<bpt i="5" x="5">&lt;c5&gt;</bpt>Option<bpt i="6" x="6">&lt;w6&gt;</bpt>Set<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>プロトコルを使って簡単に作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In these cases, you need to store the whole result rather than just the success value or that the API call failed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これらの場合において、あなたは全体の結果を取っておく必要があります、成功値またはAPI呼び出しが失敗したことだけでなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In these scenarios, use the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_ENUM<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> macro instead.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それらの予想される事態には、<bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_ENUM<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>マクロを代わりに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this case, see the documentation of <bpt i="1" x="1">&lt;c1&gt;</bpt>Collection<bpt i="2" x="2">&lt;w2&gt;</bpt>.underestimated<bpt i="3" x="3">&lt;w3&gt;</bpt>Count<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この場合には、<bpt i="1" x="1">&lt;c1&gt;</bpt>Collection<bpt i="2" x="2">&lt;w2&gt;</bpt>.underestimated<bpt i="3" x="3">&lt;w3&gt;</bpt>Count<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の文書を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this case, you cannot assume either that a sequence will be consumable and will resume iteration, or that a sequence is a collection and will restart iteration from the first element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この場合、あるシーケンスが消耗可能になっているそして反復を再開することになるか、またはあるシーケンスがコレクションであるそして最初の要素から反復を再度着手することになるか、あなたはどちらか決めてかかることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, <bpt i="0" x="0">&lt;c0&gt;</bpt>filter(_:)<ept i="0">&lt;/c0&gt;</ept> is used to include only names shorter than five characters.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>filter(_:)<ept i="0">&lt;/c0&gt;</ept>は５つの文字より短い名前のみ含めるために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, <bpt i="0" x="0">&lt;c0&gt;</bpt>map<ept i="0">&lt;/c0&gt;</ept> is used first to convert the names in the array to lowercase strings and then to count their characters.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例では、<bpt i="0" x="0">&lt;c0&gt;</bpt>map<ept i="0">&lt;/c0&gt;</ept>は最初に配列中の名前を小文字文字列に変換するために、それからそれらの文字を数えるために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> is initialized as an <bpt i="1" x="1">&lt;c1&gt;</bpt>Int8<ept i="1">&lt;/c1&gt;</ept> instance by clamping <bpt i="2" x="2">&lt;c2&gt;</bpt>500<ept i="2">&lt;/c2&gt;</ept> to the range <bpt i="3" x="3">&lt;c3&gt;</bpt>-128...127<ept i="3">&lt;/c3&gt;</ept>, and <bpt i="4" x="4">&lt;c4&gt;</bpt>y<ept i="4">&lt;/c4&gt;</ept> is initialized as a <bpt i="5" x="5">&lt;c5&gt;</bpt>UInt<ept i="5">&lt;/c5&gt;</ept> instance by clamping <bpt i="6" x="6">&lt;c6&gt;</bpt>-500<ept i="6">&lt;/c6&gt;</ept> to the range <bpt i="7" x="7">&lt;c7&gt;</bpt>0...UInt<bpt i="8" x="8">&lt;w8&gt;</bpt>.max<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>Int8<ept i="1">&lt;/c1&gt;</ept>インスタンスとして、<bpt i="2" x="2">&lt;c2&gt;</bpt>500<ept i="2">&lt;/c2&gt;</ept>を範囲<bpt i="3" x="3">&lt;c3&gt;</bpt>-128...127<ept i="3">&lt;/c3&gt;</ept>に制限すること（クランピング）によって初期化されます、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>y<ept i="4">&lt;/c4&gt;</ept>は<bpt i="5" x="5">&lt;c5&gt;</bpt>UInt<ept i="5">&lt;/c5&gt;</ept>インスタンスとして、<bpt i="6" x="6">&lt;c6&gt;</bpt>-500<ept i="6">&lt;/c6&gt;</ept>を範囲<bpt i="7" x="7">&lt;c7&gt;</bpt>0...UInt<bpt i="8" x="8">&lt;w8&gt;</bpt>.max<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>に制限することによって初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, a new element is inserted into <bpt i="2" x="2">&lt;c2&gt;</bpt>class<bpt i="3" x="3">&lt;w3&gt;</bpt>Days<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, a set of days of the week.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、新しい要素が、一揃いの曜日<bpt i="2" x="2">&lt;c2&gt;</bpt>class<bpt i="3" x="3">&lt;w3&gt;</bpt>Days<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>へ挿入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, an Objective-C class that provides a convenience initializer that takes variadic arguments for key-value pairs suggests using a dictionary literal instead:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、可変長引数をキー値ペアに対して取る便宜イニシャライザを提供するあるObjective-Cクラスは、代わりに辞書リテラルを使うことを提案します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, an array of three ranges is flattened so that the elements of each range can be iterated in turn.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、３つの範囲からなる配列は平坦化されます、それで各範囲の要素は順に反復されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, an existing element is inserted into <bpt i="4" x="4">&lt;c4&gt;</bpt>class<bpt i="5" x="5">&lt;w5&gt;</bpt>Days<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, a set of days of the week.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、既存の要素が、一揃いの曜日<bpt i="4" x="4">&lt;c4&gt;</bpt>class<bpt i="5" x="5">&lt;w5&gt;</bpt>Days<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>へ挿入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, note the difference in the result of using <bpt i="0" x="0">&lt;c0&gt;</bpt>map<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>compact<bpt i="2" x="2">&lt;w2&gt;</bpt>Map<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> with a transformation that returns an optional <bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>map<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>compact<bpt i="2" x="2">&lt;w2&gt;</bpt>Map<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>を、オプショナル<bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>値を返す変換とともに使う結果の違いに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, note the difference in the result of using <bpt i="0" x="0">&lt;c0&gt;</bpt>map<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>flat<bpt i="2" x="2">&lt;w2&gt;</bpt>Map<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> with a transformation that returns an array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>map<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>flat<bpt i="2" x="2">&lt;w2&gt;</bpt>Map<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>をある配列を返す変換とともに使うことの結果における違いに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, note the difference in the result of using <bpt i="0" x="0">&lt;c0&gt;</bpt>map<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>flat<bpt i="2" x="2">&lt;w2&gt;</bpt>Map<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> with a transformation that returns an optional <bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>map<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>flat<bpt i="2" x="2">&lt;w2&gt;</bpt>Map<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>を、オプショナル<bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>値を返す変換とともに使う結果の違いに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, note the difference in the result of using <bpt i="0" x="0">&lt;c0&gt;</bpt>map<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>flat<bpt i="2" x="2">&lt;w2&gt;</bpt>Map<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> with a transformation that returns an result type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>map<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>flat<bpt i="2" x="2">&lt;w2&gt;</bpt>Map<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>をある結果型を返す変換とともに使うことの結果における違いに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, the assignment to the <bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept> variable calls this initializer behind the scenes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept>定数への代入は、このイニシャライザを舞台裏で呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, the assignment to the <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> constant calls this integer literal initializer behind the scenes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>定数への代入は、この整数リテラルイニシャライザを舞台裏で呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, three elements in the middle of an array of integers are replaced by the five elements of a <bpt i="0" x="0">&lt;c0&gt;</bpt>Repeated&lt;Int&gt;<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例では、整数からなる配列の真ん中の３つの要素が、<bpt i="0" x="0">&lt;c0&gt;</bpt>Repeated&lt;Int&gt;<ept i="0">&lt;/c0&gt;</ept>インスタンスの５つの要素によって置き換えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this model, each state is represented by a case with a matching name.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このモデルにおいて、各状態は合致する名前を持つケース節によって表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this model, the app defines two variables: an optional <bpt i="0" x="0">&lt;c0&gt;</bpt>user<ept i="0">&lt;/c0&gt;</ept> that stores user information, and a Boolean value named <bpt i="1" x="1">&lt;c1&gt;</bpt>session<bpt i="2" x="2">&lt;w2&gt;</bpt>Expired<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このモデルでは、アプリは２つの変数を定義します：ユーザ情報を格納するオプショナルの<bpt i="0" x="0">&lt;c0&gt;</bpt>user<ept i="0">&lt;/c0&gt;</ept>、そして<bpt i="1" x="1">&lt;c1&gt;</bpt>session<bpt i="2" x="2">&lt;w2&gt;</bpt>Expired<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>と名前をつけられるブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Indices and Iterators</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インデックスとイテレータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inequality is the inverse of equality.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>不等性は、同等性の裏返しです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Infrequently Used Functionality</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>滅多に使われない機能性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inherited By</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>継承される先</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inherits From</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>継承元</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Initialization with Literals</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>リテラルを使った初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Initializer methods are imported by Swift with double underscores (<bpt i="0" x="0">&lt;c0&gt;</bpt>__<ept i="0">&lt;/c0&gt;</ept>) prepended to their first argument labels.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>イニシャライザメソッドそれらは、Swiftによって、それらの最初の引数ラベルの前に付けられる二重アンダースコア（<bpt i="0" x="0">&lt;c0&gt;</bpt>__<ept i="0">&lt;/c0&gt;</ept>）を使ってインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Initializers</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>イニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inpsecting Publisher Properties</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>パブリッシャープロパティを検査する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inserts a new element into the collection at the specified position.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある新しい要素をコレクションへ指定された位置で挿入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inserts the elements of a sequence into the collection at the specified position.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンスに属する複数の要素をコレクションへ指定された位置で挿入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inserts the elements of another set into this option set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>別のセットの要素をこのオブションセットへと挿入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inserts the elements of the given sequence into the set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたシーケンスの要素を集合に挿入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inserts the given element in the set if it is not already present.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それが既に存在するのでないならば、与えられた要素を集合へと挿入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inserts the given element into the set unconditionally.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた要素を集合へと無条件に挿入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inserts the given element into the set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた要素をセットへと挿入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inspecting Publisher Properties</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>パブリッシャープロパティを検査する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inspecting a Buffer</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>バッファを調査する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inspecting a Range</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲を調査する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inspecting a Set</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合を調査する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inspecting an Optional</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オプショナルを調査する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instance Method</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インスタンスメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instance Methods</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インスタンスメソッド </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instance Properties</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>様々なインスタンスプロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instance Property</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インスタンスプロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instantiates an instance of the conforming type from a string representation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>準拠する型のインスタンスを文字列表現から初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instead, convert an instance of any type to a string by using the <bpt i="0" x="0">&lt;c0&gt;</bpt>String(describing:)<ept i="0">&lt;/c0&gt;</ept> initializer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>代わりに、どんな型のインスタンスでも文字列へと、<bpt i="0" x="0">&lt;c0&gt;</bpt>String(describing:)<ept i="0">&lt;/c0&gt;</ept>イニシャライザを使って変換してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instead, convert an instance of any type to a string by using the <bpt i="0" x="0">&lt;c0&gt;</bpt>String(reflecting:)<ept i="0">&lt;/c0&gt;</ept> initializer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>代わりに、どんな型のインスタンスでも文字列へと、<bpt i="0" x="0">&lt;c0&gt;</bpt>String(reflecting:)<ept i="0">&lt;/c0&gt;</ept>イニシャライザを使って変換してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instead, create a new set using an array literal as its value by enclosing a comma-separated list of values in square brackets.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>代わりに、新しい集合を配列リテラルをそれの値として、コンマ区切りの値のリストを角カッコで囲むことによって、作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instead, initialize a variable or constant using an integer literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>代わりに、整数リテラルを使って変数や定数を初期化してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instead, use <bpt i="1" x="1">&lt;c1&gt;</bpt>reduce<ept i="1">&lt;/c1&gt;</ept> for summing operations, or <bpt i="2" x="2">&lt;c2&gt;</bpt>for<bpt i="3" x="3">&lt;w3&gt;</bpt>Each<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> or a <bpt i="4" x="4">&lt;c4&gt;</bpt>for<ept i="4">&lt;/c4&gt;</ept>-<bpt i="5" x="5">&lt;c5&gt;</bpt>in<ept i="5">&lt;/c5&gt;</ept> loop for operations with side effects.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>代わりに、<bpt i="1" x="1">&lt;c1&gt;</bpt>reduce<ept i="1">&lt;/c1&gt;</ept>を合計演算のために、また<bpt i="2" x="2">&lt;c2&gt;</bpt>for<bpt i="3" x="3">&lt;w3&gt;</bpt>Each<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>や<bpt i="4" x="4">&lt;c4&gt;</bpt>for<ept i="4">&lt;/c4&gt;</ept>-<bpt i="5" x="5">&lt;c5&gt;</bpt>in<ept i="5">&lt;/c5&gt;</ept>ループを副作用付き演算のために、使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instead, use the <bpt i="2" x="2">&lt;a2&gt;</bpt><bpt i="3" x="3">&lt;c3&gt;</bpt>Result<ept i="3">&lt;/c3&gt;</ept><ept i="2">&lt;/a2&gt;</ept> enumeration to capture information about whether an asychronous call succeeds or fails, and use the associated values for the <bpt i="4" x="4">&lt;a4&gt;</bpt><bpt i="5" x="5">&lt;c5&gt;</bpt>Result<bpt i="6" x="6">&lt;w6&gt;</bpt>.success(_:)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept><ept i="4">&lt;/a4&gt;</ept> and <bpt i="7" x="7">&lt;a7&gt;</bpt><bpt i="8" x="8">&lt;c8&gt;</bpt>Result<bpt i="9" x="9">&lt;w9&gt;</bpt>.failure(_:)<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept><ept i="7">&lt;/a7&gt;</ept> cases to carry information about the result of the call.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>代わりに、<bpt i="2" x="2">&lt;a2&gt;</bpt><bpt i="3" x="3">&lt;c3&gt;</bpt>Result<ept i="3">&lt;/c3&gt;</ept><ept i="2">&lt;/a2&gt;</ept>列挙を使うことで、非同期の呼び出しが成功するか失敗するかについての情報をキャプチャしてください、そして<bpt i="4" x="4">&lt;a4&gt;</bpt><bpt i="5" x="5">&lt;c5&gt;</bpt>Result<bpt i="6" x="6">&lt;w6&gt;</bpt>.success(_:)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept><ept i="4">&lt;/a4&gt;</ept>と<bpt i="7" x="7">&lt;a7&gt;</bpt><bpt i="8" x="8">&lt;c8&gt;</bpt>Result<bpt i="9" x="9">&lt;w9&gt;</bpt>.failure(_:)<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept><ept i="7">&lt;/a7&gt;</ept>ケース節に対する関連値を使うことで、呼び出しの結果についての情報を運んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instead, you can perform set operations with another set, an array, or any other sequence type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それどころか、あなたは集合演算を他の集合、配列、またはあらゆる他のシーケンス型とで実行できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instead, you represent a value that could be missing as wrapped in an optional type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>代わりに、あなたは見つからないかもしれない値をオプショナル型でラップすることで表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Integer</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>整数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Interoperability makes it possible to integrate features migrated to Swift into Objective-C code with no hassle.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>相互運用性は、Swiftに移される特徴を、面倒なしでObjective-Cコードに統合することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Invoke the throwing expression inside the closure you pass to the initializer:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>スロー式をあなたがこのイニシャライザに渡すクロージャ内から発動してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is safe to use operations that put an upper limit on the number of elements they access, such as <bpt i="6" x="6">&lt;c6&gt;</bpt>prefix(_:)<ept i="6">&lt;/c6&gt;</ept> or <bpt i="7" x="7">&lt;c7&gt;</bpt>drop<bpt i="8" x="8">&lt;w8&gt;</bpt>First(_:)<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>, and operations that you can guarantee will terminate, such as passing a closure you know will eventually return <bpt i="9" x="9">&lt;c9&gt;</bpt>true<ept i="9">&lt;/c9&gt;</ept> to <bpt i="10" x="10">&lt;c10&gt;</bpt>first(where:)<ept i="10">&lt;/c10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>安全なのは、上側の限界をそれらがアクセスする要素数に置く演算、例えば<bpt i="6" x="6">&lt;c6&gt;</bpt>prefix(_:)<ept i="6">&lt;/c6&gt;</ept>または<bpt i="7" x="7">&lt;c7&gt;</bpt>drop<bpt i="8" x="8">&lt;w8&gt;</bpt>First(_:)<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>など、そしてあなたが終わらせることができる演算、例えばあなたが結局は<bpt i="9" x="9">&lt;c9&gt;</bpt>true<ept i="9">&lt;/c9&gt;</ept>を<bpt i="10" x="10">&lt;c10&gt;</bpt>first(where:)<ept i="10">&lt;/c10&gt;</ept>に返すと知っているクロージャを渡すことなどの使用です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is used by the compiler when you initialize an <bpt i="0" x="0">&lt;c0&gt;</bpt>Optional<ept i="0">&lt;/c0&gt;</ept> instance with a <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それは、あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>Optional<ept i="0">&lt;/c0&gt;</ept>インスタンスを<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>リテラルで初期化する時にコンパイラによって使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is used by the compiler when you use an array literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それは、あなたが配列リテラルを使う時にコンパイラによって使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It's also possible to model an app’s state by using individual variables in combination to hold the state and the required data, which is not recommended.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>アプリの持つ状態を、状態と必要データを保持するよう組み合わせた独立した幾つかの変数を使ってモデル化することもまた可能です、それは推奨されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Iterating Over a Range's Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある範囲の持つ要素すべてに反復していく</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Iterating Over a Sequence's Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンスの要素のすべてに反復する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Iterating over a Set</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合のすべてに反復する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Its <bpt i="1" x="1">&lt;c1&gt;</bpt>deinit<ept i="1">&lt;/c1&gt;</ept> must destroy its stored <bpt i="2" x="2">&lt;c2&gt;</bpt>Header<ept i="2">&lt;/c2&gt;</ept> and any constructed <bpt i="3" x="3">&lt;c3&gt;</bpt>Element<ept i="3">&lt;/c3&gt;</ept>s.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それの<bpt i="1" x="1">&lt;c1&gt;</bpt>deinit<ept i="1">&lt;/c1&gt;</ept>は、それの格納された<bpt i="2" x="2">&lt;c2&gt;</bpt>Header<ept i="2">&lt;/c2&gt;</ept>とあらゆる構成された<bpt i="3" x="3">&lt;c3&gt;</bpt>Element<ept i="3">&lt;/c3&gt;</ept>を破棄しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Key Paths</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キーパス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Key-Path Expressions</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キーパス式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Key-Value Pairs as a Function Parameter</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>関数パラメータとしてのキー値ペア</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Keyed<bpt i="0" x="0">&lt;w0&gt;</bpt>Decoding<bpt i="1" x="1">&lt;w1&gt;</bpt>Container<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol Implementations <ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Keyed<bpt i="0" x="0">&lt;w0&gt;</bpt>Decoding<bpt i="1" x="1">&lt;w1&gt;</bpt>Container<bpt i="2" x="2">&lt;w2&gt;</bpt>プロトコルの実装 <ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>KeyedDecodingContainerProtocol Implementations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>KeyedDecodingContainerProtocol 実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>KeyedEncodingContainerProtocol Implementations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>KeyedEncodingContainerProtocol 実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Language Interoperability</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>言語互換性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lastly, use the eponymous <bpt i="0" x="0">&lt;c0&gt;</bpt>replace<bpt i="1" x="1">&lt;w1&gt;</bpt>Subrange(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>with:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method to replace a subrange of elements with the contents of another collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最後に、名前の元となった<bpt i="0" x="0">&lt;c0&gt;</bpt>replace<bpt i="1" x="1">&lt;w1&gt;</bpt>Subrange(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>with:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使って、いくつかの要素からなる下位範囲を別のコレクションの内容で置き換えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lazy Collections</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>遅延コレクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lazy Wrappers</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>遅延ラッパー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lazy sequences can be used to avoid needless storage allocation and computation, because they use an underlying sequence for storage and compute their elements on demand.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>遅延シーケンスは、不必要なストレージの割り当てと計算を防止するために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Learn how functions and methods that take a completion handler are converted to Swift asynchronous functions.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>完了ハンドラをとる関数およびメソッドがどのようにSwift非同期関数へと変換されるかを学んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Learn the recommended steps to migrate your code.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのコードを移行するための推奨される段階を学んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Likewise, <bpt i="0" x="0">&lt;c0&gt;</bpt>Range<bpt i="1" x="1">&lt;w1&gt;</bpt>Replaceable<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> types can remove one or more elements using a single operation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同様に、<bpt i="0" x="0">&lt;c0&gt;</bpt>Range<bpt i="1" x="1">&lt;w1&gt;</bpt>Replaceable<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型は、１つ以上の要素の削除をただ１つの演算を使って行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Likewise, if <bpt i="2" x="2">&lt;c2&gt;</bpt>distance &lt; 0<ept i="2">&lt;/c2&gt;</ept>, a limit that is greater than <bpt i="3" x="3">&lt;c3&gt;</bpt>i<ept i="3">&lt;/c3&gt;</ept> has no effect.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同様に、<bpt i="2" x="2">&lt;c2&gt;</bpt>distance &lt; 0<ept i="2">&lt;/c2&gt;</ept>ならば、<bpt i="3" x="3">&lt;c3&gt;</bpt>i<ept i="3">&lt;/c3&gt;</ept>より大きい限度は効果を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Likewise, if <bpt i="3" x="3">&lt;c3&gt;</bpt>distance &lt; 0<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>limit<ept i="4">&lt;/c4&gt;</ept> should be less than <bpt i="5" x="5">&lt;c5&gt;</bpt>i<ept i="5">&lt;/c5&gt;</ept> to have any effect.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同様に、<bpt i="3" x="3">&lt;c3&gt;</bpt>distance &lt; 0<ept i="3">&lt;/c3&gt;</ept>ならば、<bpt i="4" x="4">&lt;c4&gt;</bpt>limit<ept i="4">&lt;/c4&gt;</ept>が何らかの効果を持つには<bpt i="5" x="5">&lt;c5&gt;</bpt>i<ept i="5">&lt;/c5&gt;</ept>より少なくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Likewise, if you pass a zero-length collection as the <bpt i="0" x="0">&lt;c0&gt;</bpt>new<bpt i="1" x="1">&lt;w1&gt;</bpt>Elements<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> parameter, this method removes the elements in the given subrange without replacement.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同様に、あなたがゼロ長コレクションを<bpt i="0" x="0">&lt;c0&gt;</bpt>new<bpt i="1" x="1">&lt;w1&gt;</bpt>Elements<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>パラメータとして渡すならば、このメソッドは与えられた下位範囲の中の要素を置き換えることなく削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>MLShaped<bpt i="0" x="0">&lt;w0&gt;</bpt>Array<bpt i="1" x="1">&lt;w1&gt;</bpt>Protocol Implementations <ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>MLShaped<bpt i="0" x="0">&lt;w0&gt;</bpt>Array<bpt i="1" x="1">&lt;w1&gt;</bpt>プロトコル実装<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Maintaining State in Your Apps</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのアプリの状態を保守する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Make an API Unavailable in Both Languages</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるAPIを両方の言語で利用できなくする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Make sure that your Objective-C code and Swift code have optimal compatibility by tidying up and modernizing your existing Objective-C codebase.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのObjective-CコードとSwiftコードが最善の互換性を持つことを、あなたの既存のObjective-Cコード基盤を整頓および近代化することによって確かにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Make sure your code follows modern coding practices so that it interacts more effectively with Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのコードが近代的コード慣行に従うことを確かにしてください、それでそれはより効果的にSwiftと相互作用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Making Objective-C APIs Unavailable in Swift</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-C APIをSwiftにおいて利用できなくする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Making false assumptions about when a closure is called can lead to data inconsistency and app crashes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>いつクロージャが呼び出されるかについてfalseを仮定することは、データの矛盾そしてアプリクラッシュに至る可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Making your own custom types conform to <bpt i="0" x="0">&lt;c0&gt;</bpt>Sequence<ept i="0">&lt;/c0&gt;</ept> enables many useful operations, like <bpt i="1" x="1">&lt;c1&gt;</bpt>for<ept i="1">&lt;/c1&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt>in<ept i="2">&lt;/c2&gt;</ept> looping and the <bpt i="3" x="3">&lt;c3&gt;</bpt>contains<ept i="3">&lt;/c3&gt;</ept> method, without much effort.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのあつらえの型を<bpt i="0" x="0">&lt;c0&gt;</bpt>Sequence<ept i="0">&lt;/c0&gt;</ept>に準拠させることは、多くの有用な演算能力を与えます、<bpt i="1" x="1">&lt;c1&gt;</bpt>for<ept i="1">&lt;/c1&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt>in<ept i="2">&lt;/c2&gt;</ept>ループおよび<bpt i="3" x="3">&lt;c3&gt;</bpt>contains<ept i="3">&lt;/c3&gt;</ept>メソッドのように、あまり苦労せずに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Manage the given <bpt i="0" x="0">&lt;c0&gt;</bpt>buffer<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された<bpt i="0" x="0">&lt;c0&gt;</bpt>buffer<ept i="0">&lt;/c0&gt;</ept>を管理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Managed Buffers</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>バッファ管理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Manipulating Indices</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インデックスを操る</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Manual Memory Management</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>手動メモリ管理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Many of the APIs you use in Swift take a closure—or a function passed as an instance—as a parameter.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがSwiftで使うAPIの多くは、クロージャ — またはインスタンスとして渡される関数 — をパラメータとして取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Many sequence and collection operations return an array or a type-erasing collection wrapper instead of a set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>多くのシーケンスおよびコレクション演算は、集合ではなく、ある配列またはある型消去コレクションラッパーを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Mark Availability</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>利用可能性を印する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Marking API Availability in Objective-C</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>API利用可能性をObjective-Cにおいて印する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Marking the <bpt i="0" x="0">&lt;c0&gt;</bpt>My<bpt i="1" x="1">&lt;w1&gt;</bpt>List<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> declaration as audited for nullability reduces the number of annotations that are required.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>My<bpt i="1" x="1">&lt;w1&gt;</bpt>List<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>宣言をヌル可能性について監査済みと印することは、必要とされる注釈の数を減らします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Migrate Your Code</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのコードを移行する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Migrating Your Objective-C Code to Swift</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのObjective-Cコードのスウィフトへの移行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Migration experiences differ depending on your existing codebase, but here are some general steps and tools to help you troubleshoot the process:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以降体験はあなたの既存のコード基盤に依存して異なります、しかしここにその過程の問題をあなたが解決する助けとなるいくつかの一般的な段階とツールがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Mirrors also provide a “display style” property that suggests how this mirror might be rendered.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ミラーはまた、「display style」プロパティを提供します、それはどのようにこのミラーが描画されるかを提案します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Multiplies two values and produces their product.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの値を乗算してそれらの積を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Multiplies two values and stores the result in the left-hand-side variable, wrapping any overflow.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの値を乗算して結果を左手側の変数に格納します、あらゆるオーバーフローをラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Multiplies two values and stores the result in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの値を乗算して、結果を左手側の変数に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Must be non-zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>非ゼロでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>MutableCollection Implementations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>MutableCollection 実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Negative values are returned in two’s complement representation, regardless of the type’s underlying implementation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>負の値が、２の補数表現において返されます、その型のもつ基礎となる実装に関係なく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Never call <bpt i="0" x="0">&lt;c0&gt;</bpt>finalize()<ept i="0">&lt;/c0&gt;</ept> on <bpt i="1" x="1">&lt;c1&gt;</bpt>hasher<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>finalize()<ept i="0">&lt;/c0&gt;</ept>を<bpt i="1" x="1">&lt;c1&gt;</bpt>hasher<ept i="1">&lt;/c1&gt;</ept>上で決して呼び出さないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Next, create unique options as static properties of your custom type using unique powers of two (1, 2, 4, 8, 16, and so forth) for each individual property’s raw value so that each property can be represented by a single bit of the type’s raw value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次に、それぞれが特有なオプションをあなたのあつらえの型の静的プロパティとして作成してください、特有な２の冪（1、2、4、8、16、およびそれ以降）を各個別プロパティの生の値に対して使います、それで各プロパティはその型のもつ生の値からなるある単一ビットによって表されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Next, the <bpt i="3" x="3">&lt;c3&gt;</bpt>while<ept i="3">&lt;/c3&gt;</ept> loop calls the iterator’s <bpt i="4" x="4">&lt;c4&gt;</bpt>next()<ept i="4">&lt;/c4&gt;</ept> method repeatedly, binding each element that is returned to <bpt i="5" x="5">&lt;c5&gt;</bpt>animal<ept i="5">&lt;/c5&gt;</ept> and exiting when the <bpt i="6" x="6">&lt;c6&gt;</bpt>next()<ept i="6">&lt;/c6&gt;</ept> method returns <bpt i="7" x="7">&lt;c7&gt;</bpt>nil<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次に、<bpt i="3" x="3">&lt;c3&gt;</bpt>while<ept i="3">&lt;/c3&gt;</ept>ループは、そのイテレータのもつ<bpt i="4" x="4">&lt;c4&gt;</bpt>next()<ept i="4">&lt;/c4&gt;</ept>メソッドを繰り返し呼び出して、返される各要素を<bpt i="5" x="5">&lt;c5&gt;</bpt>animal<ept i="5">&lt;/c5&gt;</ept>に束縛して、そして<bpt i="6" x="6">&lt;c6&gt;</bpt>next()<ept i="6">&lt;/c6&gt;</ept>メソッドが<bpt i="7" x="7">&lt;c7&gt;</bpt>nil<ept i="7">&lt;/c7&gt;</ept>を返すとき退出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Next, the function calls the array’s <bpt i="2" x="2">&lt;c2&gt;</bpt>index(before:)<ept i="2">&lt;/c2&gt;</ept> method to return the correct position in the passed array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次に、関数は配列の<bpt i="2" x="2">&lt;c2&gt;</bpt>index(before:)<ept i="2">&lt;/c2&gt;</ept>メソッドを呼び出すことで渡された配列での正しい位置を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>No buffering storage is allocated and each traversal step invokes <bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept> on one or more underlying elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>バッファするストレージが割り当てられること、そしてひとつひとつ見ていく各処理が１つまたはそれ以上の基盤となる要素上で<bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>を呼び出すことはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>None</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>なし</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Nonnullable—Imported as nonoptionals, whether annotated directly or by inclusion in an annotated region</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>非ヌル可能性 — 非オプショナルとしてインポートされます、直接に注釈を付けられようとまたは注釈を付けられた領域の中に包含されようと</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>注意</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that <bpt i="0" x="0">&lt;c0&gt;</bpt>typedef<ept i="0">&lt;/c0&gt;</ept> types aren't assumed to be nonnull, even within audited regions, because they aren't inherently nullable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>typedef<ept i="0">&lt;/c0&gt;</ept>型は非ヌルであると仮定されません、監査済み領域内でさえもです、なぜならそれらはそもそもヌル可能でないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that the <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> array is suitably-aligned <bpt i="1" x="1">&lt;s1&gt;</bpt>raw memory<ept i="1">&lt;/s1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>配列は、<bpt i="1" x="1">&lt;s1&gt;</bpt>生のメモリ<ept i="1">&lt;/s1&gt;</ept>に適切に並べられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note: this property need not be implemented by conforming types, it has a default implementation in a protocol extension that just returns <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>注意：このプロパティは準拠する型で実装される必要はありません、それはプロトコル拡張において初期実装、単に<bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>を返すものを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Now that the <bpt i="0" x="0">&lt;c0&gt;</bpt>shorter<bpt i="1" x="1">&lt;w1&gt;</bpt>Indices<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> array holds the indices of the shorter names in the <bpt i="2" x="2">&lt;c2&gt;</bpt>names<ept i="2">&lt;/c2&gt;</ept> set, you can use those indices to access elements in the set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>現在、<bpt i="0" x="0">&lt;c0&gt;</bpt>shorter<bpt i="1" x="1">&lt;w1&gt;</bpt>Indices<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>配列は<bpt i="2" x="2">&lt;c2&gt;</bpt>names<ept i="2">&lt;/c2&gt;</ept>集合の中のより短い名前のインデックスを保持します、あなたはそれらのインデックスを使ってこの集合の要素にアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Nullable—Imported as optionals</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ヌル可能性 — オプショナルとしてインポートされます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Numbers and Basic Values</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>数と基本的な値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Numeric Protocols</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>数に関するプロトコル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Object subscripting methods are imported by Swift as methods with double underscores (<bpt i="0" x="0">&lt;c0&gt;</bpt>__<ept i="0">&lt;/c0&gt;</ept>) prepended to their base names, rather than as a Swift subscript, if either the getter or setter method is marked as <bpt i="1" x="1">&lt;c1&gt;</bpt>NS<bpt i="2" x="2">&lt;w2&gt;</bpt>_REFINED<bpt i="3" x="3">&lt;w3&gt;</bpt>_FOR<bpt i="4" x="4">&lt;w4&gt;</bpt>_SWIFT<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オブジェクト添え字メソッドは、スウィフトによってメソッドとして二重アンダースコア（<bpt i="0" x="0">&lt;c0&gt;</bpt>__<ept i="0">&lt;/c0&gt;</ept>）をそれのベース名の前に付けられてインポートされます、スウィフト添え字としてではなく、もしゲッターとセッターメソッドの両方が<bpt i="1" x="1">&lt;c1&gt;</bpt>NS<bpt i="2" x="2">&lt;w2&gt;</bpt>_REFINED<bpt i="3" x="3">&lt;w3&gt;</bpt>_FOR<bpt i="4" x="4">&lt;w4&gt;</bpt>_SWIFT<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>と印付けされるならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Objective-C and C Code Customization</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-CとCコードのカスタム化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Obtain each separate iterator from separate calls to the sequence’s <bpt i="0" x="0">&lt;c0&gt;</bpt>make<bpt i="1" x="1">&lt;w1&gt;</bpt>Iterator()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method rather than by copying.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのシーケンスのもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>make<bpt i="1" x="1">&lt;w1&gt;</bpt>Iterator()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドへの独立した呼び出しから独立したイテレータを取得してください、コピーによってではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Offsets the given index by the specified distance, or so that it equals the given limiting index.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたインデックスをこの指定された隔たりで補います、またはそれでそれは与えられた限界インデックスと等しくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Offsets the given index by the specified distance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたインデックスを指定された間隔で補います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Often, the optimizer can eliminate bounds- and uniqueness-checks within an algorithm, but when that fails, invoking the same algorithm on <bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept>\ ’s argument lets you trade safety for speed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>しばしば、最適化機能はアルゴリズム内部で境界および固有さ検査を省くことができます、しかしそれが失敗する時、同じアルゴリズムを<bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept>の引数上で発動することは、あなたに安全をスピードと交換させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>On This Page</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この項には</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>On a big-endian platform, for any integer <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>x == x<bpt i="2" x="2">&lt;w2&gt;</bpt>.big<bpt i="3" x="3">&lt;w3&gt;</bpt>Endian<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ビッグエンディアンプラットホーム上で、何らかの整数<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="1" x="1">&lt;c1&gt;</bpt>x == x<bpt i="2" x="2">&lt;w2&gt;</bpt>.big<bpt i="3" x="3">&lt;w3&gt;</bpt>Endian<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>On a little-endian platform, for any integer <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>x == x<bpt i="2" x="2">&lt;w2&gt;</bpt>.little<bpt i="3" x="3">&lt;w3&gt;</bpt>Endian<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>リトルエンディアンプラットホーム上で、何らかの整数<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="1" x="1">&lt;c1&gt;</bpt>x == x<bpt i="2" x="2">&lt;w2&gt;</bpt>.little<bpt i="3" x="3">&lt;w3&gt;</bpt>Endian<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Once <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> has been returned, all subsequent calls return <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>一旦<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>が返されるならば、すべての続いて起こる呼び出しは<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Once <bpt i="2" x="2">&lt;c2&gt;</bpt>predicate<ept i="2">&lt;/c2&gt;</ept> returns <bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept> it will not be called again.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>いったん<bpt i="2" x="2">&lt;c2&gt;</bpt>predicate<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>を返すならそれは再び呼び出されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Once the predicate returns <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept> it will not be called again.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>いったん述部が<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>を返すならそれは再び呼び出されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Once you migrate a class to Swift, you must remove the corresponding <bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept> file from the target before building to avoid a duplicate symbol error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>一旦あなたがあるクラスをスウィフトに移行したならば、あなたは、ビルドの前にそのターゲットから対応する<bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept>ファイルを取り除いて重複シンボル・エラーを避けなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>One example is the <bpt i="0" x="0">&lt;c0&gt;</bpt>reduce1(_:)<ept i="0">&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>１つの例は<bpt i="0" x="0">&lt;c0&gt;</bpt>reduce1(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Opaque pointers are used to represent C pointers to types that cannot be represented in Swift, such as incomplete struct types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>不透明ポインタは、Swiftでは表されることができない型、例えば不完全なstruct型などへのCポインタを表すために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Operator</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Operator Functions</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>演算子関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Option Sets</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オプションセット</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Option set values have a one-to-one correspondence with their associated raw values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オプションセット値それらは、それらの関連する生の値と一対一の対応を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Option sets all conform to <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Representable<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> by inheritance using the <bpt i="2" x="2">&lt;c2&gt;</bpt>Option<bpt i="3" x="3">&lt;w3&gt;</bpt>Set<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オプションセットすべては、<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Representable<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>への準拠を<bpt i="2" x="2">&lt;c2&gt;</bpt>Option<bpt i="3" x="3">&lt;w3&gt;</bpt>Set<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルを使って継承することによって行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Option sets use bitwise operations on their associated raw values to implement their mathematical set operations.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オプションセットは、ビット単位演算をそれらの関連する生の値上で使うことで、それらの数学的集合演算を実施します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Option-click a symbol to see implicit information about it, like its type, attributes, and documentation comments.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シンボルをオプション-クリックして、それに関する暗黙表示の情報、その型、属性、そして注釈文書などを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Optional Binding</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オプショナル束縛</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Optional Chaining</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オプショナル連鎖</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Order Dependent Operations on Set</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合での順序依存演算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Other classes derived from such an ancestor are given a default mirror.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのような先祖から派生する別のクラスは、省略時のミラーを与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Other methods are imported with double underscores (<bpt i="0" x="0">&lt;c0&gt;</bpt>__<ept i="0">&lt;/c0&gt;</ept>) prepended to their base names.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>他のメソッドは、二重アンダースコア（<bpt i="0" x="0">&lt;c0&gt;</bpt>__<ept i="0">&lt;/c0&gt;</ept>）をそれのベース名の前に付けられてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Otherwise, returns <bpt i="5" x="5">&lt;c5&gt;</bpt>(false, old<bpt i="6" x="6">&lt;w6&gt;</bpt>Member)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, where <bpt i="7" x="7">&lt;c7&gt;</bpt>old<bpt i="8" x="8">&lt;w8&gt;</bpt>Member<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> is the member of the set equal to <bpt i="9" x="9">&lt;c9&gt;</bpt>new<bpt i="10" x="10">&lt;w10&gt;</bpt>Member<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そうでなければ、<bpt i="5" x="5">&lt;c5&gt;</bpt>(false, old<bpt i="6" x="6">&lt;w6&gt;</bpt>Member)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>を返します、そこで<bpt i="7" x="7">&lt;c7&gt;</bpt>old<bpt i="8" x="8">&lt;w8&gt;</bpt>Member<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>は<bpt i="9" x="9">&lt;c9&gt;</bpt>new<bpt i="10" x="10">&lt;w10&gt;</bpt>Member<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>に等しいこの集合のメンバです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Otherwise, the result is generated by the language.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そうでなければ、結果は言語によって生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Overflow checking is not performed in <bpt i="0" x="0">&lt;c0&gt;</bpt>-Ounchecked<ept i="0">&lt;/c0&gt;</ept> builds.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オーバーフロー検査は、<bpt i="0" x="0">&lt;c0&gt;</bpt>-Ounchecked<ept i="0">&lt;/c0&gt;</ept>ビルドでは実行されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Overview</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>概要</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Parameter: A metatype.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>パラメータ：あるメタタイプ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Parameters</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>パラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Parsing of the string is case insensitive.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文字列の構文解析は、大文字小文字に影響されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Pass <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> to request that the collection avoid releasing its storage.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>を渡して、コレクションがそのストレージを解放するのを回避するよう要求してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Pass a dictionary literal with string keys as <bpt i="2" x="2">&lt;c2&gt;</bpt>children<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>文字列キーを持つ辞書リテラルを<bpt i="2" x="2">&lt;c2&gt;</bpt>children<ept i="2">&lt;/c2&gt;</ept>として渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Pass a variadic list of string and integer arguments.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>文字列および整数の引数からなる可変長リストを渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Pass an instance to these static methods to acess the layout for that instance's type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるインスタンスをこれら静的メソッドに渡すことで、そのインスタンスの持つ型に対するレイアウトにアクセスしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Pass the greater-than operator (<bpt i="1" x="1">&lt;c1&gt;</bpt>&gt;<ept i="1">&lt;/c1&gt;</ept>) operator as the predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>より大きい（<bpt i="1" x="1">&lt;c1&gt;</bpt>&gt;<ept i="1">&lt;/c1&gt;</ept>）演算子を述部として渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Passing a sequence with no elements or an empty collection as <bpt i="0" x="0">&lt;c0&gt;</bpt>possible<bpt i="1" x="1">&lt;w1&gt;</bpt>Prefix<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> always results in <bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>１つの要素もないシーケンスまたは空のコレクションを<bpt i="0" x="0">&lt;c0&gt;</bpt>possible<bpt i="1" x="1">&lt;w1&gt;</bpt>Prefix<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として渡すことは、常に<bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>という結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Passing a value that can’t be represented in this type results in a runtime error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型において表せない値を渡すことは、実行時エラーという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Passing the collection’s <bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> as the <bpt i="2" x="2">&lt;c2&gt;</bpt>start<ept i="2">&lt;/c2&gt;</ept> parameter results in an empty subsequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの<bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を<bpt i="2" x="2">&lt;c2&gt;</bpt>start<ept i="2">&lt;/c2&gt;</ept>パラメータとして渡すことは、空のシーケンスという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Passing the collection’s starting index as the <bpt i="0" x="0">&lt;c0&gt;</bpt>end<ept i="0">&lt;/c0&gt;</ept> parameter results in an empty subsequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの開始インデックスを<bpt i="0" x="0">&lt;c0&gt;</bpt>end<ept i="0">&lt;/c0&gt;</ept>パラメータとして渡すことは、空のシーケンスという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Passing the same index as both <bpt i="2" x="2">&lt;c2&gt;</bpt>i<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>j<ept i="3">&lt;/c3&gt;</ept> has no effect.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>i<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>j<ept i="3">&lt;/c3&gt;</ept>の両方と同じアンデックスを渡すことは、効果を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Perform order-dependent operations common to all collections, as implemented for <bpt i="0" x="0">&lt;c0&gt;</bpt>Set<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>すべてのコレクションに共通の順序依存演算を、<bpt i="0" x="0">&lt;c0&gt;</bpt>Set<ept i="0">&lt;/c0&gt;</ept>に対して実装されたように実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Performing Collection Operations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクション演算の実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Performing a bitwise NOT operation on 0 returns a value with every bit set to <bpt i="0" x="0">&lt;c0&gt;</bpt>1<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ビット単位のNOT演算を0に関して実行することは、すべてのビットが<bpt i="0" x="0">&lt;c0&gt;</bpt>1<ept i="0">&lt;/c0&gt;</ept>に設定された値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Performs a nil-coalescing operation, returning the wrapped value of an <bpt i="0" x="0">&lt;c0&gt;</bpt>Optional<ept i="0">&lt;/c0&gt;</ept> instance or a default <bpt i="1" x="1">&lt;c1&gt;</bpt>Optional<ept i="1">&lt;/c1&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>nil合体演算を実行します、ラップされた値の<bpt i="0" x="0">&lt;c0&gt;</bpt>Optional<ept i="0">&lt;/c0&gt;</ept>インスタンスまたは省略時の<bpt i="1" x="1">&lt;c1&gt;</bpt>Optional<ept i="1">&lt;/c1&gt;</ept>値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Performs a nil-coalescing operation, returning the wrapped value of an <bpt i="0" x="0">&lt;c0&gt;</bpt>Optional<ept i="0">&lt;/c0&gt;</ept> instance or a default value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>nil合体演算を実行します、ラップされた値の<bpt i="0" x="0">&lt;c0&gt;</bpt>Optional<ept i="0">&lt;/c0&gt;</ept>インスタンスまたは省略時の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Playgrounds and the debugger use the <bpt i="0" x="0">&lt;c0&gt;</bpt>Mirror<ept i="0">&lt;/c0&gt;</ept> type to display representations of values of any type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>プレイグラウンド及びデバッガは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Mirror<ept i="0">&lt;/c0&gt;</ept>型を使ってあらゆる型の値の表現を表示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Playgrounds and the debugger will show a representation similar to the one used for instances of the kind indicated by the <bpt i="0" x="0">&lt;c0&gt;</bpt>Display<bpt i="1" x="1">&lt;w1&gt;</bpt>Style<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> case name when the mirror is used for display.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>プレイグラウンドとデバッガは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Display<bpt i="1" x="1">&lt;w1&gt;</bpt>Style<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ケース節名によって指し示される種類のインスタンスに対して使われるものに似た表現をミラーが表示用に使われる時に示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Please see <bpt i="0" x="0">&lt;c0&gt;</bpt>Lazy<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> for background; <bpt i="3" x="3">&lt;c3&gt;</bpt>Lazy<bpt i="4" x="4">&lt;w4&gt;</bpt>Collection<bpt i="5" x="5">&lt;w5&gt;</bpt>Protocol<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is an analogous component, but for collections.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>予備知識として<bpt i="0" x="0">&lt;c0&gt;</bpt>Lazy<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をぜひ見てください；<bpt i="3" x="3">&lt;c3&gt;</bpt>Lazy<bpt i="4" x="4">&lt;w4&gt;</bpt>Collection<bpt i="5" x="5">&lt;w5&gt;</bpt>Protocol<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は、類似した、しかしコレクションのためのコンポーネントです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Precondition: <bpt i="0" x="0">&lt;c0&gt;</bpt>buffer<ept i="0">&lt;/c0&gt;</ept> is an instance of a non-<bpt i="1" x="1">&lt;c1&gt;</bpt>@objc<ept i="1">&lt;/c1&gt;</ept> class whose <bpt i="2" x="2">&lt;c2&gt;</bpt>deinit<ept i="2">&lt;/c2&gt;</ept> destroys its stored <bpt i="3" x="3">&lt;c3&gt;</bpt>Header<ept i="3">&lt;/c3&gt;</ept> and any constructed <bpt i="4" x="4">&lt;c4&gt;</bpt>Element<ept i="4">&lt;/c4&gt;</ept>s.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>前提条件：<bpt i="0" x="0">&lt;c0&gt;</bpt>buffer<ept i="0">&lt;/c0&gt;</ept>は非<bpt i="1" x="1">&lt;c1&gt;</bpt>@objc<ept i="1">&lt;/c1&gt;</ept>クラスのインスタンスです、それの<bpt i="2" x="2">&lt;c2&gt;</bpt>deinit<ept i="2">&lt;/c2&gt;</ept>はそれの格納された<bpt i="3" x="3">&lt;c3&gt;</bpt>Header<ept i="3">&lt;/c3&gt;</ept>とあらゆる構成された<bpt i="4" x="4">&lt;c4&gt;</bpt>Element<ept i="4">&lt;/c4&gt;</ept>を破棄します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Precondition: <bpt i="0" x="0">&lt;c0&gt;</bpt>maximum<ept i="0">&lt;/c0&gt;</ept> must compare equal to itself (i.e. cannot be NaN).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>前提条件：<bpt i="0" x="0">&lt;c0&gt;</bpt>maximum<ept i="0">&lt;/c0&gt;</ept>はそれ自身と等しいと比較されなければなりません（すなわちNaNであることはできません）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Precondition: <bpt i="0" x="0">&lt;c0&gt;</bpt>minimum<ept i="0">&lt;/c0&gt;</ept> must compare equal to itself (i.e. cannot be NaN).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>前提条件：<bpt i="0" x="0">&lt;c0&gt;</bpt>minimum<ept i="0">&lt;/c0&gt;</ept>はそれ自身と等しいと比較されなければなりません（すなわちNaNであることはできません）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Precondition: <bpt i="0" x="0">&lt;c0&gt;</bpt>minimum<bpt i="1" x="1">&lt;w1&gt;</bpt>Capacity &gt;= 0<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, and the type indicated by <bpt i="2" x="2">&lt;c2&gt;</bpt>buffer<bpt i="3" x="3">&lt;w3&gt;</bpt>Class<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is a non-<bpt i="4" x="4">&lt;c4&gt;</bpt>@objc<ept i="4">&lt;/c4&gt;</ept> class with no declared stored properties.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>前提条件：<bpt i="0" x="0">&lt;c0&gt;</bpt>minimum<bpt i="1" x="1">&lt;w1&gt;</bpt>Capacity &gt;= 0<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>buffer<bpt i="3" x="3">&lt;w3&gt;</bpt>Class<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>によって示される型が非<bpt i="4" x="4">&lt;c4&gt;</bpt>@objc<ept i="4">&lt;/c4&gt;</ept>クラスで宣言された格納プロパティを持たないこと。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Precondition: <bpt i="0" x="0">&lt;c0&gt;</bpt>next()<ept i="0">&lt;/c0&gt;</ept> has not been applied to a copy of <bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept> since the copy was made.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>前提条件：<bpt i="0" x="0">&lt;c0&gt;</bpt>next()<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept>のコピーに、そのコピーが作成されて以来まったく適用されていないこと。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Precondition: <bpt i="0" x="0">&lt;c0&gt;</bpt>position<ept i="0">&lt;/c0&gt;</ept> is a valid position in <bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>position != end<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>前提条件：<bpt i="0" x="0">&lt;c0&gt;</bpt>position<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept>の中の有効な位置であり<bpt i="2" x="2">&lt;c2&gt;</bpt>position != end<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>であること。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Precondition: <bpt i="0" x="0">&lt;c0&gt;</bpt>scalars<ept i="0">&lt;/c0&gt;</ept> must have the same number of elements as the vector type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>前提条件：<bpt i="0" x="0">&lt;c0&gt;</bpt>scalars<ept i="0">&lt;/c0&gt;</ept>は、ベクター型と同じ数の要素を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Prepares the collection to store the specified number of elements, when doing so is appropriate for the underlying type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された数の要素を格納するようにコレクションを準備します、そうすることが基礎をなす型に対して適切である場合には。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Preserving the Results of a Throwing Expression</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>スローする式の結果を保全する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Prevent an Objective-C API from Being Imported</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるObjective-C APIがインポートされるのを妨げる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Preventing Timing Problems When Using Closures</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>クロージャを使う場合のタイミング問題を防ぐ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Properties are not directly accessible if they trigger any <bpt i="0" x="0">&lt;c0&gt;</bpt>did<bpt i="1" x="1">&lt;w1&gt;</bpt>Set<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt>will<bpt i="3" x="3">&lt;w3&gt;</bpt>Set<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> accessors, perform any representation changes such as bridging or closure reabstraction, or mask the value out of overlapping storage as for packed bitfields.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>プロパティは直接にアクセス可能ではありません、もしそれらが何らかの<bpt i="0" x="0">&lt;c0&gt;</bpt>did<bpt i="1" x="1">&lt;w1&gt;</bpt>Set<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>または<bpt i="2" x="2">&lt;c2&gt;</bpt>will<bpt i="3" x="3">&lt;w3&gt;</bpt>Set<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>アクセッサの引き金になる、何らかの表現変更の実行たとえばブリッジまたはクロージャ再抽象化など、またはオーバーラップしているストレージの外の値をパックされたビットフィールドとしてマスクするならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Publishing a Result</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果の発行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Publishing a Sequence</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンスを発行する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Publishing an Optional</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オプショナルを発行する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Querying Descendants</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>子孫について問い合わせる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Querying Runtime Values</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>実行時値の問い合わせ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Querying Type Properties</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型プロパティに問い合わせる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Random Number Generators</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>無作為数生成子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Random-access collections can move indices any distance and measure the distance between indices in O(1) time.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>無作為アクセスのコレクションは、任意の隔たりのインデックスを移動できます、そしてインデックス間の隔たりの測定をO(1)時間で行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Range Expressions</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Range-replaceable collections provide operations that insert and remove elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲交換可能なコレクションは、いくつかの要素の挿入や削除を行う演算を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>RangeReplaceableCollection Implementations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>RangeReplaceableCollection 実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Ranges</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>さまざまな範囲</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Raw Representation</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>生の表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Reference Types</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>参照型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Relationships</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>関係</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Remember that you can't subclass a Swift class in Objective-C.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがObjective-CにおいてSwiftクラスをサブクラス化できないことを忘れないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Remove the original Objective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept> file from the target by deselecting the target membership checkbox.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ターゲットから本来のObjective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept>ファイルを、ターゲットメンバーシップ・チェックボックスの選択を外すことによって取り除いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes all elements from the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>全ての要素をコレクションから削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes all elements of this option set that are not also present in the given set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このオプションセットに属し、また与えられたセットの中に含まれない、すべての要素を削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes all members from the set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合からすべてのメンバを削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes all the elements that satisfy the given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた述部を満たす要素すべてを除去します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes and returns the element at the specified position.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された位置での要素を削除して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes and returns the first element of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの最初の要素を削除して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes and returns the first element of the set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合の最初の要素を削除して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes and returns the last element of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの最後の要素を削除して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes the element at the given index of the set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたインデックスでの集合の要素を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes the elements in the specified subrange from the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された下位範囲の中の要素をコレクションから削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes the elements of the given sequence from the set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたシーケンスの要素を集合から削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes the elements of the given set from this set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた集合の要素をこの集合から削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes the elements of the set that are also in the given sequence and adds the members of the sequence that are not already in the set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合の要素で与えられたシーケンスの中にもあるものを削除します、そしてシーケンスのメンバで集合の中にはまだないものを加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes the elements of the set that are also in the given set and adds the members of the given set that are not already in the set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた集合の中にもあるこの集合の要素を削除します、そして与えられた集合のメンバでこの集合の中にはまだないものを加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes the elements of the set that aren’t also in the given sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたシーケンスの中にはない、この集合の要素を削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes the elements of this set that aren’t also in the given set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた集合の中にはない、この集合の要素を削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes the first element of the set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合の最初の要素を削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes the given element and all elements subsumed by it.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた要素とそれによって包括されるすべての要素を削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes the given element and any elements subsumed by the given element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた要素と、与えられた要素によって包括されるあらゆる要素を削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes the given number of elements from the end of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた数の要素をコレクションの終わりから削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes the specified element from the set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された要素を集合から削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes the specified number of elements from the beginning of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された数の要素をコレクションの始まりから削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes the specified number of elements from the end of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された数の要素をコレクションの終わりから削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes the specified subrange of elements from the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>いくらかの要素からなる指定された下位範囲をコレクションから削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removing Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要素の削除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Rename APIs</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>APIを改名する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Renaming Objective-C APIs for Swift</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-C APIをSwift用に改名する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Reordering Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要素を再配列する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Reordering a Sequence’s Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンスのもつ要素を再配列する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Reorders the elements of the collection such that all the elements that match the given predicate are after all the elements that don’t match.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの要素を再配列します、例えば、与えられた述部にマッチする要素すべてが、合致しない要素すべての後になるなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Repeated Access</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>繰り返してアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Repeatedly calling this method returns, in order, all the elements of the underlying sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>繰り返しこのメソッドを呼び出すことは、基礎をなすシーケンスのすべての要素を、順番に返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Replace this set with the elements contained in this set or the given set, but not both.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合を、この集合または与えられた集合の中に含まれる、しかし両方にではない要素で置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Replaces elements of this vector with <bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept> in the lanes where <bpt i="1" x="1">&lt;c1&gt;</bpt>mask<ept i="1">&lt;/c1&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このベクターの要素を、<bpt i="0" x="0">&lt;c0&gt;</bpt>mask<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>であるところの、レーンの中の<bpt i="2" x="2">&lt;c2&gt;</bpt>other<ept i="2">&lt;/c2&gt;</ept>で置き換えます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Replaces elements of this vector with elements of <bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept> in the lanes where <bpt i="1" x="1">&lt;c1&gt;</bpt>mask<ept i="1">&lt;/c1&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このベクターの要素を、<bpt i="0" x="0">&lt;c0&gt;</bpt>mask<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>であるところの、レーンの中の<bpt i="2" x="2">&lt;c2&gt;</bpt>other<ept i="2">&lt;/c2&gt;</ept>の要素で置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Replaces the given index with its predecessor.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたインデックスをそれの前のものと取り替えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Replaces the given index with its successor.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたインデックスをそれの後に続くものと取り替えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Replaces the specified subrange of elements with the given collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>いくらかの要素からなる指定された下位範囲を与えられたコレクションで置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Replaces this set with a new set containing all elements contained in either this set or the given set, but not in both.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このセットを、このセットか与えられたセットのどちらかの中に、しかし両方ではなく、含まれるすべての要素を含んでいる新しいセットで置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Replaces this value with its additive inverse.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値をそれの加法の逆元で置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Representing a Result</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果の表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Required Initializer</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>必須イニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Required.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>必須。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Reserves enough space to store the specified number of elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された数の要素を格納するのに十分な空間を確保します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Resources</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>リソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Retaining the collection’s storage can be a useful optimization when you’re planning to grow the collection again.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションのストレージを保持することは、あなたがコレクションをもう一度増大しようと計画している時に、ひとつの有益な最適化であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Retrieve the executor for this actor as an optimized, unowned reference.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>エグゼキュータ（遂行者）をこのアクターのためにある最適化された、非所有参照として取って来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Return Result Instances Asynchronously</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果インスタンスを非同期に返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Return Value</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>戻り値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Return an iterator over the elements of this sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスの要素すべてに対するあるイテレータを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns <bpt i="0" x="0">&lt;c0&gt;</bpt>-1<ept i="0">&lt;/c0&gt;</ept> if this value is negative and <bpt i="1" x="1">&lt;c1&gt;</bpt>1<ept i="1">&lt;/c1&gt;</ept> if it’s positive; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt>0<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値が負ならば<bpt i="0" x="0">&lt;c0&gt;</bpt>-1<ept i="0">&lt;/c0&gt;</ept>そしてそれが正ならば<bpt i="1" x="1">&lt;c1&gt;</bpt>1<ept i="1">&lt;/c1&gt;</ept>；それ以外では<bpt i="2" x="2">&lt;c2&gt;</bpt>0<ept i="2">&lt;/c2&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if <bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept> holds the only strong reference to its buffer; otherwise, returns <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>を返します、もし<bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept>がそれのバッファに対する強い参照のみを保持するならば；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if this value is a multiple of the given value, and <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept> otherwise.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>をもしこの値がその与えられた値の倍数ならば、そして<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>をそうでないならば返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a <bpt i="0" x="0">&lt;c0&gt;</bpt>Decoder<ept i="0">&lt;/c0&gt;</ept> instance for decoding <bpt i="1" x="1">&lt;c1&gt;</bpt>super<ept i="1">&lt;/c1&gt;</ept> from the container associated with the default <bpt i="2" x="2">&lt;c2&gt;</bpt>super<ept i="2">&lt;/c2&gt;</ept> key.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Decoder<ept i="0">&lt;/c0&gt;</ept>インスタンスを、<bpt i="1" x="1">&lt;c1&gt;</bpt>super<ept i="1">&lt;/c1&gt;</ept>をデコードするために、省略時<bpt i="2" x="2">&lt;c2&gt;</bpt>super<ept i="2">&lt;/c2&gt;</ept>キーと結び付けられるコンテナから返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a <bpt i="0" x="0">&lt;c0&gt;</bpt>Decoder<ept i="0">&lt;/c0&gt;</ept> instance for decoding <bpt i="1" x="1">&lt;c1&gt;</bpt>super<ept i="1">&lt;/c1&gt;</ept> from the container associated with the given key.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>super<ept i="0">&lt;/c0&gt;</ept>をデコードするための<bpt i="1" x="1">&lt;c1&gt;</bpt>Decoder<ept i="1">&lt;/c1&gt;</ept>インスタンスを、指定のキーと結び付けられるコンテナから返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a <bpt i="0" x="0">&lt;c0&gt;</bpt>Lazy<bpt i="1" x="1">&lt;w1&gt;</bpt>Map<bpt i="2" x="2">&lt;w2&gt;</bpt>Sequence<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> over this <bpt i="3" x="3">&lt;c3&gt;</bpt>Sequence<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この<bpt i="3" x="3">&lt;c3&gt;</bpt>Sequence<ept i="3">&lt;/c3&gt;</ept>を覆う<bpt i="0" x="0">&lt;c0&gt;</bpt>Lazy<bpt i="1" x="1">&lt;w1&gt;</bpt>Map<bpt i="2" x="2">&lt;w2&gt;</bpt>Sequence<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether a value is included in a range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値が範囲に含まれるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether every element of a sequence satisfies a given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスのすべての要素がある与えられた述部を満たすかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the decoder contains a value associated with the given key.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたキーと結び付けられた値をデコーダが含むかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the given element is contained within the range expression.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた要素がこの範囲式内に含まれるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the given element is contained within the range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた要素がこの範囲内に含まれるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスの最初の要素らが別のシーケンスの中の要素らと同等かどうかを、与えられた述部を同等性テストとして使って指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the initial elements of the sequence are the same as the elements in another sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスの最初の要素らが別のシーケンスの中の要素らと同じかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された述部を満足させるある要素をシーケンスが含むかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the sequence contains the given element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された要素をシーケンスが含むかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスが別のシーケンスの前に来るかどうかをある語彙筆記的順序（字典）順序において、与えられた述部を使って要素を比較して、指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the less-than operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;<ept i="0">&lt;/c0&gt;</ept>) to compare elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのシーケンスが別のシーケンスの前に来るかどうかを、ある語彙筆記的順序（字典）順序において、より小さい演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;<ept i="0">&lt;/c0&gt;</ept>）を使って要素を比較して、指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the two arguments are equal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの引数が等しいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the two arguments are not equal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの引数が等しくないかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the two given values are equal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの与えられた値が等しいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the two given values are not equal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの与えられた値が等しくないかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the value of the first argument is greater than or equal to that of the second argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最初の引数の値が２番目の引数のそれより大きいまたは等しいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the value of the first argument is greater than that of the second argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最初の引数の値が２番目の引数のそれより大きいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the value of the first argument is less than or equal to that of the second argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最初の引数の値が２番目の引数のそれより少ないまたは等しいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the value of the first argument is less than that of the second argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最初の引数の値が２番目の引数のそれより少ないかどうかを指し示しているブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether this range and the given range contain an element in common.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この範囲と与えられた範囲がある要素を共通に含むかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスともう一方のシーケンスが同等の要素を同じ順序で含むかどうかを、与えられた述部を同等テストとして使って、指し示しているブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether this sequence and another sequence contain the same elements in the same order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスともう一方のシーケンスが同じ要素を同じ順序で含むかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether two optional instances are equal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つのオプショナルインスタンスが等しいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether two ranges are equal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの範囲が等しいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether two sets have equal elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの集合がまったく等しい要素らを持つかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether two types are identical.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの型が同一かどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether two types are not identical.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの型が同一でないかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether two values are equal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの値が等しいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether two values are not equal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの値が等しくないかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether two vectors are equal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つのベクターが等しいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value that indicates whether a given element is a member of the option set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた要素がオプションセットのメンバであるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value that indicates whether the given element exists in the set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた要素が集合の中の存在するかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value that indicates whether the set has no members in common with the given sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合は与えられたシーケンスと共通のメンバを１つも持たないかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value that indicates whether the set has no members in common with the given set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合が、与えられた集合と共通のメンバを１つも持たないかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value that indicates whether the set is a strict subset of the given sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合は与えられたシーケンスの狭義の下位集合であるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value that indicates whether the set is a strict superset of the given sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合は与えられたシーケンスの狭義の上位集合であるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value that indicates whether the set is a subset of another set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合は別の集合の下位集合であるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value that indicates whether the set is a subset of the given sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合は与えられたシーケンスの下位集合であるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value that indicates whether the set is a superset of the given sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合は与えられたシーケンスの上位集合であるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value that indicates whether the set is a superset of the given set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合が、与えられた集合の上位集合であるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value that indicates whether this set has no members in common with the given set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合は与えられた集合と共通のメンバを１つも持たないかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value that indicates whether this set is a strict subset of the given set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合は与えられた集合の狭義の下位集合であるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value that indicates whether this set is a strict superset of the given set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合は与えられた集合の狭義の上位集合であるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value that indicates whether this set is a subset of the given set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合は与えられた集合の下位集合であるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value that indicates whether this set is a superset of the given set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合は与えられた集合の上位集合であるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a closed range that contains both of its bounds.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それの境界の両方を含む完結範囲を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a copy of this range clamped to the given limiting range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた限界範囲に締め金具で留められる（制限を課される）、この範囲のコピーを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a copy of this vector, with elements <bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept> in the lanes where <bpt i="1" x="1">&lt;c1&gt;</bpt>mask<ept i="1">&lt;/c1&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このベクターのコピーを返します、<bpt i="0" x="0">&lt;c0&gt;</bpt>mask<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>であるところの、レーンの中の要素<bpt i="2" x="2">&lt;c2&gt;</bpt>other<ept i="2">&lt;/c2&gt;</ept>を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a copy of this vector, with elements replaced by elements of <bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept> in the lanes where <bpt i="1" x="1">&lt;c1&gt;</bpt>mask<ept i="1">&lt;/c1&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このベクターのコピーを返します、<bpt i="0" x="0">&lt;c0&gt;</bpt>mask<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>であるところの、レーンの中の要素<bpt i="2" x="2">&lt;c2&gt;</bpt>other<ept i="2">&lt;/c2&gt;</ept>を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a half-open range that contains its lower bound but not its upper bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それの下側の境界は含むがそれの上側の境界はそうしない半開範囲を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a lazy sequence of the initial consecutive elements that satisfy <bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>を満足させる、冒頭の隣接要素からなるある遅延シーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a lazy sequence that concatenates the elements of this sequence of sequences.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスに属する複数のシーケンスの要素を鎖状に連結する遅延シーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a lazy sequence that skips any initial elements that satisfy <bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>を満足させる、あらゆる冒頭の要素を省くある遅延シーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a new collection of the same type containing, in order, the elements of the original collection that satisfy the given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オリジナルのコレクションの要素で与えられた述部を満たすものを、順序正しく、含んでいる同じ型の新しいコレクションを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a new option set of the elements contained in this set, in the given set, or in both.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このセットの中に、与えられたセットの中に、または両方の中に、含まれる要素からなる新しいオプションセットを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a new option set with only the elements contained in both this set and the given set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このセットと与えられたセットの両方の中に含まれる要素だけを持つ新しいオプションセットを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a new option set with the elements contained in this set or in the given set, but not in both.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このセットの中にまたは与えられたセットの中に、しかし両方の中にではなく、含まれる要素からなる新しいオプションセットを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a new result, mapping any failure value using the given transformation and unwrapping the produced result.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい結果を返します、あらゆる失敗値をこの与えられた変換を使ってマッピングします、そして生成された結果をアンラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a new result, mapping any failure value using the given transformation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい結果を返します、あらゆる失敗値をこの与えられた変換を使ってマッピングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a new result, mapping any success value using the given transformation and unwrapping the produced result.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい結果を返します、あらゆる成功値をこの与えられた変換を使ってマッピングしています、そして生成された結果をアンラップしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a new result, mapping any success value using the given transformation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい結果を返します、あらゆる成功値をこの与えられた変換を使ってマッピングします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a new set containing the elements of the set that satisfy the given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合の要素で与えられた述部を満たすものを含んでいる新しい集合を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a new set containing the elements of this set that do not occur in the given sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたシーケンスの中の現れないこの集合の要素を含んでいる新しい集合を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a new set containing the elements of this set that do not occur in the given set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた集合の中の現れないこの集合の要素を含んでいる新しい集合を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a new set with the elements of both this and the given set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これと与えられた集合の両方の要素を持つ新しい集合を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a new set with the elements of both this set and the given sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合と与えられたシーケンスの両方の要素を持つ新しい集合を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a new set with the elements that are common to both this set and the given sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合と与えられたシーケンスの両方に共通である要素を持つ新しい集合を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a new set with the elements that are common to both this set and the given set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合と与えられた集合の両方に共通である要素を持つ新しい集合を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a new set with the elements that are either in this set or in the given sequence, but not in both.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合の中か与えられたシーケンスの中かどちらかの、しかし両方の中にではない要素を持つ新しい集合を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a new set with the elements that are either in this set or in the given set, but not in both.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合の中か与えられた集合の中かどちらかの、しかし両方の中にではない要素を持つ新しい集合を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a new string by concatenating the elements of the sequence, adding the given separator between each element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>各要素の間に与えられた分離子を加えて、シーケンスの要素を連結することによる新しい文字列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a partial range extending upward from a lower bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下側の境界から上方に拡張している部分的な範囲を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a partial range up to, and including, its upper bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それの上側の境界までの、そしてそれを含む部分的な範囲を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a partial range up to, but not including, its upper bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それの上側の境界までの、しかしそれを含んでいない、部分的な範囲を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a random element of the collection, using the given generator as a source for randomness.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションのある無作為な要素を返します、与えられた生成子を無作為さの出典として使って使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a random element of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションのある無作為の要素を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a random value that is less than the given upper bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた上側の境界より小さい無作為の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a random value within the specified range, using the given generator as a source for randomness.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された範囲内のある無作為な値を返します、与えられた生成子を無作為さの出典として使って使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a random value within the specified range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された範囲内のある無作為の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a sequence by skipping the initial, consecutive elements that satisfy the given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた述部を満たす、冒頭の、隣接する要素を飛ばすことによるあるシーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a sequence containing all but the given number of final elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた数の末尾要素以外すべてを含んでいるあるシーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a sequence containing all but the given number of initial elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された数の冒頭要素以外すべてを含んでいるあるシーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a sequence containing the initial, consecutive elements that satisfy the given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた述部を満たす、冒頭の、隣接する要素を含んでいるあるシーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a sequence of pairs (<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>, <bpt i="1" x="1">&lt;e1&gt;</bpt>x<ept i="1">&lt;/e1&gt;</ept>), where <bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept> represents a consecutive integer starting at zero and <bpt i="3" x="3">&lt;e3&gt;</bpt>x<ept i="3">&lt;/e3&gt;</ept> represents an element of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ペア (<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>, <bpt i="1" x="1">&lt;e1&gt;</bpt>x<ept i="1">&lt;/e1&gt;</ept>) のシーケンスを返します、そこで<bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept>はゼロで開始する連続した数を表して、<bpt i="3" x="3">&lt;e3&gt;</bpt>x<ept i="3">&lt;/e3&gt;</ept>はシーケンスの要素を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a sequence, up to the specified maximum length, containing the initial elements of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された最大長まで、そのシーケンスの冒頭の要素を含んでいる、あるシーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a specific descendant of the reflected subject, or <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> if no such descendant exists.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>リフレクションされている主題の特定の子孫を返します、またはそのような子孫が存在しないならば<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a subsequence by skipping elements while <bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept> returns <bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept> and returning the remaining elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>を返す間は要素を飛ばして残りの要素を返すことによって、ある下位シーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a subsequence containing all but the given number of initial elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された数の冒頭要素以外すべてを含んでいる下位シーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a subsequence containing all but the specified number of final elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された数の末尾要素以外すべてを含んでいる下位シーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a subsequence containing the initial elements until <bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept> returns <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept> and skipping the remaining elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>を返すまで冒頭の要素を含んでいて残りの要素を飛ばしている、ある下位シーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a subsequence from the specified position to the end of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された位置からコレクションの終わりまでの下位シーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a subsequence from the start of the collection through the specified position.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの始まりから指定された位置までも含む下位シーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a subsequence from the start of the collection up to, but not including, the specified position.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの始まりから指定された位置まで、しかしそれは含めない下位シーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a subsequence, up to the given maximum length, containing the final elements of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下位シーケンスを、指定された最大長まで、コレクションの末尾の要素を含めて返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a subsequence, up to the given maximum length, containing the final elements of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下位シーケンスを、指定された最大長まで、シーケンスの末尾の要素を含めて返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a subsequence, up to the specified maximum length, containing the initial elements of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下位シーケンスを、指定された最大長まで、コレクションの冒頭の要素を含めて返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a tuple containing the high and low parts of the result of multiplying this value by the given value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値を指定の値で掛ける結果の高および低部分を含んでいるタプルを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a tuple containing the quotient and remainder of dividing the given value by this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた値をこの値で除算した商と余りを含んでいるタプルを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a value from a uniform, independent distribution of binary data.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>バイナリデータの一様な、独立分布からの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a value that is offset the specified distance from this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定の隔たりをこの値からオフセットされたある値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a vector mask with the result of a pointwise equality comparison.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ポイント単位同等比較の結果を持つベクターマスクを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a vector mask with the result of a pointwise greater than comparison.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ポイント単位大なり比較の結果を持つベクターマスクを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a vector mask with the result of a pointwise greater than or equal comparison.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ポイント単位大なり同等比較の結果を持つベクターマスクを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a vector mask with the result of a pointwise inequality comparison.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ポイント単位不等比較の結果を持つベクターマスクを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a vector mask with the result of a pointwise less than comparison.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ポイント単位小なり比較の結果を持つベクターマスクを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a vector mask with the result of a pointwise less than or equal comparison.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ポイント単位小なり同等比較の結果を持つベクターマスクを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a vector with random values from within the specified range in all lanes, using the given generator as a source for randomness.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>全てのレーンにおいてこの指定された範囲内から無作為な値を持つベクターを返します、与えられた生成子を無作為さの出典として使って使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a vector with random values from within the specified range in all lanes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>全てのレーンにおいてこの指定された範囲内から無作為な値を持つベクターを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a view presenting the elements of the collection in reverse order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの要素を逆順に表しているある見方を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns an array containing the concatenated results of calling the given transformation with each element of this sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された変換をこのシーケンスの各要素で呼び出す結果を連結したものを含んでいる配列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns an array containing the elements of this sequence in reverse order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスの要素を逆順に含んでいる配列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns an array containing the non-<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> results of calling the given transformation with each element of this sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された変換をこのシーケンスの各要素で呼び出す結果で非-<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>のものを含んでいる配列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns an array containing the results of mapping the given closure over the sequence’s elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたクロージャをシーケンスのもつ要素全体にわたってマップする結果を含んでいる配列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns an array containing, in order, the elements of the sequence that satisfy the given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された述部を満足させるものであるシーケンスの要素を、順序通りに、含んでいる配列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたインデックスから指定された隔たりのインデックスを返します、その隔たりが与えられた限界インデックスを越えない限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns an index that is the specified distance from the given index.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたインデックスから指定された隔たりのインデックスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns an iterator for this sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスに対するイテレータを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns an iterator over the elements of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの要素すべてを対象としたイテレータを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns an iterator over the elements of this sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスの要素すべてを対象としたあるイテレータを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns an iterator over the members of the set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合のメンバすべてを対象とするイテレータを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the additive inverse of the specified value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された値の加法の逆元を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the concatenated elements of this sequence of sequences, inserting the given separator between each element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>各要素の間に与えられた分離子を挿入して、このシーケンスに属する複数のシーケンスの要素を鎖状に連結して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the concatenated results of mapping the given transformation over this sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた変換をこのシーケンス全体にわたってマッピングする結果を鎖状に連結して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the contiguous memory footprint of the given instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたインスタンスの隣接メモリフットプリントを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the data stored for the given key as represented in a container keyed by the given key type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたキーに対して格納されるデータを、与えられたキー型によってキー付けされるコンテナの中に表される通りに返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the data stored for the given key as represented in an unkeyed container.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたキーに対して格納されるデータを、キー無しコンテナにおいて表現される通りに返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the default memory alignment of <bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept>の省略時のメモリアライメントを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the difference needed to produce this collection’s ordered elements from the given collection, using the given predicate as an equivalence test.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このコレクションのもつ順番付けられた要素をこの与えられたコレクションから生成するのに必要とされる差異を返します、与えられた述部を同等性テストとして使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the difference needed to produce this collection’s ordered elements from the given collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このコレクションのもつ順番付けられた要素をこの与えられたコレクションから生成するのに必要とされる差異を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the difference obtained by subtracting the given value from this value, along with a Boolean value indicating whether overflow occurred in the operation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた値をこの値から減じることで入手される差、それに加えてオーバーフローがその演算において起こったかどうかを示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the difference of the two given values, wrapping the result in case of any overflow.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの与えられた値の差を返します、何らかのオーバーフローの場合には結果をラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the distance between two indices.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つのインデックス間の隔たりを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the distance from this value to the given value, expressed as a stride.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値から特定の値までの隔たりを返します、ストライドとして表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the dynamic type of a value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値の動的型を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the elements of <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept> that satisfy <bpt i="1" x="1">&lt;c1&gt;</bpt>is<bpt i="2" x="2">&lt;w2&gt;</bpt>Included<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>の要素で<bpt i="1" x="1">&lt;c1&gt;</bpt>is<bpt i="2" x="2">&lt;w2&gt;</bpt>Included<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>を満足させるものを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the elements of the sequence, shuffled using the given generator as a source for randomness.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスの要素を返します、与えられた生成子を無作為さの出典として使って混ぜ合わされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the elements of the sequence, shuffled.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>入れ替えた、シーケンスの要素を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the elements of the sequence, sorted using the given predicate as the comparison between elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた述部を要素間の比較として使ってソートされた、シーケンスの要素を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the elements of the sequence, sorted.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスに属する要素を、ソートして返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the elements of this sequence of sequences, concatenated.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスに属する複数のシーケンスの要素を、鎖状に連結して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the first element of the sequence that satisfies the given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた述部を満たすこのシーケンスの最初の要素を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the first index in which an element of the collection satisfies the given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最初のインデックスで、それにおけるコレクションの要素が与えられた述部を満足させるものを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the first index where the specified value appears in the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された値がコレクションにおいて現れるところの最初のインデックスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the given number unchanged.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた数を変更せずに返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the index of the given element in the set, or <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> if the element is not a member of the set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた要素の集合の中のインデックス、またはその要素が集合のメンバでないならば<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the index of the last element in the collection that matches the given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた述部に合致する、コレクションの中の最後の要素のインデックスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the inverse of the bits set in the argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>引数におけるビットの逆順を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the last element of the sequence that satisfies the given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた述部を満たす、シーケンスの最後の要素を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the last index where the specified value appears in the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された値がコレクションにおいて現れるところの最後のインデックスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the longest possible subsequences of the collection, in order, around elements equal to the given element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた要素と等しい要素を避けるようにして、このコレクションの最も長くなりうる下位シーケンスを、順番に返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the longest possible subsequences of the collection, in order, that don’t contain elements satisfying the given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた述部を満たす要素を含んでいない、このコレクションの最も長くなりうる下位シーケンスそれらを順序どおりに返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the longest possible subsequences of the sequence, in order, around elements equal to the given element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた要素と等しい要素を避けるようにして、このシーケンスの最も長くなりうる下位シーケンスを、順番に返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the longest possible subsequences of the sequence, in order, that don’t contain elements satisfying the given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた述部を満たす要素を含んでいない、このシーケンスの最も長くなりうる下位シーケンスそれらを順序どおりに返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the maximum element in the sequence, using the given predicate as the comparison between elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスの中の最大の要素を返します、与えられた述部を要素間の比較として使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the maximum element in the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスの中の最大の要素を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the minimum element in the sequence, using the given predicate as the comparison between elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスの中の最小の要素を返します、与えられた述部を要素間の比較として使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the minimum element in the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスの中の最小の要素を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the non-<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> results of mapping the given transformation over this sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた変換をこのシーケンス全体にわたってマッピングする非<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>の結果を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the number of bytes from the start of one instance of <bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept> to the start of the next when stored in contiguous memory or in an <bpt i="1" x="1">&lt;c1&gt;</bpt>Array&lt;T&gt;<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept>の１つのインスタンスの始まりから次のものの始まりまでのバイト数を返します、隣接メモリの中にまたは<bpt i="1" x="1">&lt;c1&gt;</bpt>Array&lt;T&gt;<ept i="1">&lt;/c1&gt;</ept>の中に格納される場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the number of elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要素の数を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the object instance being used for storage.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ストレージのために使われているオブジェクトインスタンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the offset of an inline stored property within a type’s in-memory representation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インライン格納プロパティの、ある型のもつインメモリ表現内部でのオフセットを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the position immediately after the given index.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたインデックスの直後の位置を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the position immediately before the given index.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたインデックスの直前の位置を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the product of the two given values, wrapping the result in case of any overflow.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの与えられた値の積を返します、何らかのオーバーフローの場合には結果をラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the product of this value and the given value, along with a Boolean value indicating whether overflow occurred in the operation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値と与えられた値の積、それに加えてオーバーフローがその演算において起こったかどうかを示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the quotient and remainder of this value divided by the given value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた値で除算されたこの値の商と余りを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the quotient obtained by dividing this value by the given value, along with a Boolean value indicating whether overflow occurred in the operation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値を指定の値で割ることで入手される商、それに加えてオーバーフローがその演算において起こったかどうかを示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the quotient of dividing the first value by the second.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最初の値を２番目の値で除算した商を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the range of indices described by this range expression within the given collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたコレクション内の、この範囲式によって記述されるインデックスの範囲を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the remainder after dividing this value by the given value, along with a Boolean value indicating whether overflow occurred during division.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値を指定の値によって除算する後の余り、それに加えてオーバーフローが除算の間に起こったかどうかを示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the remainder of dividing the first value by the second.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最初の値を２番目の値で除算した余りを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the result of combining the elements of the sequence using the given closure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたクロージャを使って、このシーケンスの要素それらを結合する結果を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the result of performing a bitwise AND operation on the two given values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ビット単位AND演算を２つの与えられた値に関して実行する結果を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the result of performing a bitwise OR operation on the two given values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ビット単位OR演算を２つの与えられた値に関して実行する結果を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the result of performing a bitwise XOR operation on the two given values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ビット単位XOR演算を２つの与えられた値に関して実行する結果を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the result of shifting a value’s binary representation the specified number of digits to the left, masking the shift amount to the type’s bit width, and stores the result in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値のバイナリ表現を指定された桁数だけ左にシフトする結果を返します、シフト量をその型のもつビット幅にマスクしています、そして結果を左手側の変数に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the result of shifting a value’s binary representation the specified number of digits to the left, masking the shift amount to the type’s bit width.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値のバイナリ表現を指定された桁数だけ左にシフトする結果を返します、シフト量をマスクしてその型のもつビット幅にしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the result of shifting a value’s binary representation the specified number of digits to the left.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値のバイナリ表現を指定された桁数だけ左にシフトする結果を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the result of shifting a value’s binary representation the specified number of digits to the right, masking the shift amount to the type’s bit width.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値のバイナリ表現を指定された桁数だけ右にシフトする結果を返します、シフト量をその型のもつビット幅にマスクしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the result of shifting a value’s binary representation the specified number of digits to the right.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値のバイナリ表現を指定された桁数だけ右にシフトする結果を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the success value as a throwing expression.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>成功値をスローする式として返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the sum of the scalars in the vector, computed with wrapping addition.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ベクターの中のスカラーそれらの合計を返します、加算をラップすることで計算されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the sum of the two given values, wrapping the result in case of any overflow.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの与えられた値の合計を返します、何らかのオーバーフローの場合には結果をラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the sum of this value and the given value, along with a Boolean value indicating whether overflow occurred in the operation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値と与えられた値の合計、それに加えてオーバーフローがその演算において起こったかどうかを示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Reuse the Existing Implementation</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>既存の実装を再利用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Reverses the elements of the collection in place.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの要素をその場で逆順にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Reversing a Set's Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合の要素を逆順にする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Reversing a reversed collection returns the original collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>逆にされたコレクションを逆にすることは、元のコレクションを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Right shift operations on negative values “fill in” the high bits with ones instead of zeros.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>負値上での右シフト演算は、高ビットを１で「満たします」、ゼロではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Running the analysis on a sufficiently large sample generates an average number near 50 and a failure rate near 50%:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>十分に大きなサンプル上での分析の実行は、50に近い平均数と50%に近い失敗割合を生成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Running the code in the example above usually prints the letters in the order <bpt i="0" x="0">&lt;c0&gt;</bpt>B<ept i="0">&lt;/c0&gt;</ept> → <bpt i="1" x="1">&lt;c1&gt;</bpt>C<ept i="1">&lt;/c1&gt;</ept> → <bpt i="2" x="2">&lt;c2&gt;</bpt>D<ept i="2">&lt;/c2&gt;</ept> → <bpt i="3" x="3">&lt;c3&gt;</bpt>A<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>上の例のコードを実行することは、通常は文字をこの順番で出力します、<bpt i="0" x="0">&lt;c0&gt;</bpt>B<ept i="0">&lt;/c0&gt;</ept> → <bpt i="1" x="1">&lt;c1&gt;</bpt>C<ept i="1">&lt;/c1&gt;</ept> → <bpt i="2" x="2">&lt;c2&gt;</bpt>D<ept i="2">&lt;/c2&gt;</ept> → <bpt i="3" x="3">&lt;c3&gt;</bpt>A<ept i="3">&lt;/c3&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>S() == []</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>S() == [] （空の集合は空の配列リテラルと同等です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>SIMD Implementations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>SIMD実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>SIMD Vector Types</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>SIMDベクター型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>SIMD Vectors</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>SIMDベクター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>See <bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Known<bpt i="2" x="2">&lt;w2&gt;</bpt>Uniquely<bpt i="3" x="3">&lt;w3&gt;</bpt>Referenced<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> for details.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Known<bpt i="2" x="2">&lt;w2&gt;</bpt>Uniquely<bpt i="3" x="3">&lt;w3&gt;</bpt>Referenced<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を詳細として見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>See Also</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>参照</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>See also: <bpt i="0" x="0">&lt;c0&gt;</bpt>Lazy<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>参照：<bpt i="0" x="0">&lt;c0&gt;</bpt>Lazy<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>See also: <bpt i="0" x="0">&lt;c0&gt;</bpt>Lazy<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>Lazy<bpt i="4" x="4">&lt;w4&gt;</bpt>Collection<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>参照：<bpt i="0" x="0">&lt;c0&gt;</bpt>Lazy<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>Lazy<bpt i="4" x="4">&lt;w4&gt;</bpt>Collection<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>See also: <bpt i="0" x="0">&lt;c0&gt;</bpt>elements<ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>参照：<bpt i="0" x="0">&lt;c0&gt;</bpt>elements<ept i="0">&lt;/c0&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>See the <bpt i="1" x="1">&lt;c1&gt;</bpt>children<ept i="1">&lt;/c1&gt;</ept> property for details.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>children<ept i="1">&lt;/c1&gt;</ept>プロパティを詳細として見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>See the <bpt i="2" x="2">&lt;c2&gt;</bpt>children<ept i="2">&lt;/c2&gt;</ept> property for details.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>children<ept i="2">&lt;/c2&gt;</ept>プロパティを詳細として見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>See those types for more information.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>さらなる情報としてそれらの型を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Selecting Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要素の選択</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Sequence Implementations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Sequence 実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Sequence and Collection Operations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスおよびコレクション演算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Sequence and Collection Protocols</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスおよびコレクションプロトコル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Sequence operations that take closure arguments, such as <bpt i="0" x="0">&lt;c0&gt;</bpt>map(_:)<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>filter(_:)<ept i="1">&lt;/c1&gt;</ept>, are normally eager: They use the closure immediately and return a new array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>クロージャ引数をとるシーケンス演算、たとえば<bpt i="0" x="0">&lt;c0&gt;</bpt>map(_:)<ept i="0">&lt;/c0&gt;</ept>および<bpt i="1" x="1">&lt;c1&gt;</bpt>filter(_:)<ept i="1">&lt;/c1&gt;</ept>は、通常は先行です；それらはクロージャを直ちに使います、そして新しい配列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Sequences provide access to their elements by creating an iterator, which keeps track of its iteration process and returns one element at a time as it advances through the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>さまざまなシーケンスは、あるイテレータを作成することによってそれらの要素に対するアクセスを提供します、それはそれの反復処理を追跡し続けてそれがそのシーケンスを始めから終わりへと前進するごとに一度に１つ要素を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Set <bpt i="0" x="0">&lt;e0&gt;</bpt>A<ept i="0">&lt;/e0&gt;</ept> is a strict subset of another set <bpt i="1" x="1">&lt;e1&gt;</bpt>B<ept i="1">&lt;/e1&gt;</ept> if every member of <bpt i="2" x="2">&lt;e2&gt;</bpt>A<ept i="2">&lt;/e2&gt;</ept> is also a member of <bpt i="3" x="3">&lt;e3&gt;</bpt>B<ept i="3">&lt;/e3&gt;</ept> and <bpt i="4" x="4">&lt;e4&gt;</bpt>B<ept i="4">&lt;/e4&gt;</ept> contains at least one element that is not a member of <bpt i="5" x="5">&lt;e5&gt;</bpt>A<ept i="5">&lt;/e5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合<bpt i="0" x="0">&lt;e0&gt;</bpt>A<ept i="0">&lt;/e0&gt;</ept>がもう１つの集合<bpt i="1" x="1">&lt;e1&gt;</bpt>B<ept i="1">&lt;/e1&gt;</ept>の狭義の部分集合であるのは、<bpt i="2" x="2">&lt;e2&gt;</bpt>A<ept i="2">&lt;/e2&gt;</ept>のすべてのメンバがまた<bpt i="3" x="3">&lt;e3&gt;</bpt>B<ept i="3">&lt;/e3&gt;</ept>のメンバであり、<bpt i="4" x="4">&lt;e4&gt;</bpt>B<ept i="4">&lt;/e4&gt;</ept>が少なくとも１つの<bpt i="5" x="5">&lt;e5&gt;</bpt>A<ept i="5">&lt;/e5&gt;</ept>のメンバではない要素を含む場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Set <bpt i="0" x="0">&lt;e0&gt;</bpt>A<ept i="0">&lt;/e0&gt;</ept> is a strict superset of another set <bpt i="1" x="1">&lt;e1&gt;</bpt>B<ept i="1">&lt;/e1&gt;</ept> if every member of <bpt i="2" x="2">&lt;e2&gt;</bpt>B<ept i="2">&lt;/e2&gt;</ept> is also a member of <bpt i="3" x="3">&lt;e3&gt;</bpt>A<ept i="3">&lt;/e3&gt;</ept> and <bpt i="4" x="4">&lt;e4&gt;</bpt>A<ept i="4">&lt;/e4&gt;</ept> contains at least one element that is <bpt i="5" x="5">&lt;e5&gt;</bpt>not<ept i="5">&lt;/e5&gt;</ept> a member of <bpt i="6" x="6">&lt;e6&gt;</bpt>B<ept i="6">&lt;/e6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合<bpt i="0" x="0">&lt;e0&gt;</bpt>A<ept i="0">&lt;/e0&gt;</ept>がもう１つの集合<bpt i="1" x="1">&lt;e1&gt;</bpt>B<ept i="1">&lt;/e1&gt;</ept>の狭義の上位集合であるのは、<bpt i="2" x="2">&lt;e2&gt;</bpt>B<ept i="2">&lt;/e2&gt;</ept>のすべてのメンバがまた<bpt i="3" x="3">&lt;e3&gt;</bpt>A<ept i="3">&lt;/e3&gt;</ept>のメンバであり、<bpt i="4" x="4">&lt;e4&gt;</bpt>A<ept i="4">&lt;/e4&gt;</ept>が少なくとも１つの<bpt i="6" x="6">&lt;e6&gt;</bpt>B<ept i="6">&lt;/e6&gt;</ept>のメンバでは<bpt i="5" x="5">&lt;e5&gt;</bpt>ない<ept i="5">&lt;/e5&gt;</ept>要素を含む場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Set <bpt i="0" x="0">&lt;e0&gt;</bpt>A<ept i="0">&lt;/e0&gt;</ept> is a subset of another set <bpt i="1" x="1">&lt;e1&gt;</bpt>B<ept i="1">&lt;/e1&gt;</ept> if every member of <bpt i="2" x="2">&lt;e2&gt;</bpt>A<ept i="2">&lt;/e2&gt;</ept> is also a member of <bpt i="3" x="3">&lt;e3&gt;</bpt>B<ept i="3">&lt;/e3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合<bpt i="0" x="0">&lt;e0&gt;</bpt>A<ept i="0">&lt;/e0&gt;</ept>がもう１つの集合<bpt i="1" x="1">&lt;e1&gt;</bpt>B<ept i="1">&lt;/e1&gt;</ept>の狭義の部分集合であるのは、<bpt i="2" x="2">&lt;e2&gt;</bpt>A<ept i="2">&lt;/e2&gt;</ept>のすべてのメンバがまた<bpt i="3" x="3">&lt;e3&gt;</bpt>B<ept i="3">&lt;/e3&gt;</ept>のメンバである場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Set <bpt i="0" x="0">&lt;e0&gt;</bpt>A<ept i="0">&lt;/e0&gt;</ept> is a superset of another set <bpt i="1" x="1">&lt;e1&gt;</bpt>B<ept i="1">&lt;/e1&gt;</ept> if every member of <bpt i="2" x="2">&lt;e2&gt;</bpt>B<ept i="2">&lt;/e2&gt;</ept> is also a member of <bpt i="3" x="3">&lt;e3&gt;</bpt>A<ept i="3">&lt;/e3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合<bpt i="0" x="0">&lt;e0&gt;</bpt>A<ept i="0">&lt;/e0&gt;</ept>がもう１つの集合<bpt i="1" x="1">&lt;e1&gt;</bpt>B<ept i="1">&lt;/e1&gt;</ept>の狭義の上位集合であるのは、<bpt i="2" x="2">&lt;e2&gt;</bpt>B<ept i="2">&lt;/e2&gt;</ept>のすべてのメンバがまた<bpt i="3" x="3">&lt;e3&gt;</bpt>A<ept i="3">&lt;/e3&gt;</ept>のメンバである場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Set Operations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合演算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Set operations are not limited to use with other sets.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合演算は、他の集合との使用に制限されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Set<bpt i="0" x="0">&lt;w0&gt;</bpt>Algebra Implementations <ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合<bpt i="0" x="0">&lt;w0&gt;</bpt>代数実装<ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Sets</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Sets provide a suite of mathematical set operations.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合は、数学的な集合演算のひとそろいを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Shuffles the collection in place, using the given generator as a source for randomness.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションをその場で混ぜ合わせます、与えられた生成子を無作為さの出典として使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Shuffles the collection in place.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションをその場で混ぜ合わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Signed Integers</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>符号付き整数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Similar to the <bpt i="1" x="1">&lt;c1&gt;</bpt>reduce(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> method defined in the standard library, which takes an initial value and a combining closure, <bpt i="3" x="3">&lt;c3&gt;</bpt>reduce1(_:)<ept i="3">&lt;/c3&gt;</ept> uses the first element of the sequence as the initial value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>初期値と結合クロージャをとる、標準ライブラリ定義の<bpt i="1" x="1">&lt;c1&gt;</bpt>reduce(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>メソッドとよく似て、 <bpt i="3" x="3">&lt;c3&gt;</bpt>reduce1(_:)<ept i="3">&lt;/c3&gt;</ept>はシーケンスの最初の要素を初期値として使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Similarly, you use the availability condition <bpt i="1" x="1">&lt;c1&gt;</bpt>#available<ept i="1">&lt;/c1&gt;</ept> to execute code conditionally based on required platform and version conditions.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同様に、あなたは利用可能性条件<bpt i="1" x="1">&lt;c1&gt;</bpt>#available<ept i="1">&lt;/c1&gt;</ept>を使うことで、必要なプラットホームおよびバージョン条件に基づいて、条件付きでコードを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Simply assign an array literal to a variable or constant with the <bpt i="0" x="0">&lt;c0&gt;</bpt>Set<ept i="0">&lt;/c0&gt;</ept> type specified.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>単にある配列リテラルを<bpt i="0" x="0">&lt;c0&gt;</bpt>Set<ept i="0">&lt;/c0&gt;</ept>型指定子を持つ変数または定数に代入してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Some algorithms, however, may call for direct iterator use.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>幾つかのアルゴリズムは、しかしながら、直にイテレータを使うために呼び出すかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Some operations that are efficient on a dictionary are slower when using <bpt i="0" x="0">&lt;c0&gt;</bpt>Key<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<bpt i="2" x="2">&lt;w2&gt;</bpt>Pairs<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書に効率の良いいくつかの演算は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Key<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<bpt i="2" x="2">&lt;w2&gt;</bpt>Pairs<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使う場合により遅くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Sometimes you need to preserve the entire result of a function call or other expression that can either throw or return a value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>時々あなたはスローするまたは値を返すどちらかが可能な関数呼び出しや他の式の結果の全体を保全する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Sorting Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要素のソート（並べ換え）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Sorts the collection in place, using the given predicate as the comparison between elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションをその場でソートします、与えられた述部を要素間の比較として使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Sorts the collection in place.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションをその場でソートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Special-Use Collections</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>特殊用途のコレクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Special-Use Numeric Types</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>特殊用途の数値型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Splitting and Joining Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要素の分割と連結</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Storage for a vector of 16 integers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>16整数のベクターに対するストレージ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Storage for a vector of 32 integers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>32整数のベクターに対するストレージ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Storage for a vector of 64 integers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>64整数のベクターに対するストレージ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Storage for a vector of eight integers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>８整数のベクターに対するストレージ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Storage for a vector of four integers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>4整数のベクターに対するストレージ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Storage for a vector of two integers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２整数のベクターに対するストレージ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Stores a keyed encoding container for the given key and returns it.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キー付けされたエンコーディングコンテナを指定キーに対して供給して、それを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Stores a new nested container for the default <bpt i="0" x="0">&lt;c0&gt;</bpt>super<ept i="0">&lt;/c0&gt;</ept> key and returns a new encoder instance for encoding <bpt i="1" x="1">&lt;c1&gt;</bpt>super<ept i="1">&lt;/c1&gt;</ept> into that container.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい入れ子コンテナを省略時の<bpt i="0" x="0">&lt;c0&gt;</bpt>super<ept i="0">&lt;/c0&gt;</ept>キーに対して格納します、そして<bpt i="1" x="1">&lt;c1&gt;</bpt>super<ept i="1">&lt;/c1&gt;</ept>をそのコンテナへとエンコードするための新しいエンコーダインスタンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Stores a new nested container for the given key and returns a new encoder instance for encoding <bpt i="0" x="0">&lt;c0&gt;</bpt>super<ept i="0">&lt;/c0&gt;</ept> into that container.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい入れ子のコンテナをこの与えられたキーに対して格納します、そして<bpt i="0" x="0">&lt;c0&gt;</bpt>super<ept i="0">&lt;/c0&gt;</ept>そのコンテナへとエンコードするための新しいエンコーダインスタンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Stores an unkeyed encoding container for the given key and returns it.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キー付けされないエンコーディングコンテナを指定キーに対して供給して、それを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Stores the result of performing a bitwise AND operation on the two given values in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ビット単位AND演算を２つの与えられた値に関して実行する結果を左手側の変数に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Stores the result of performing a bitwise OR operation on the two given values in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ビット単位OR演算を２つの与えられた値に関して実行する結果を左手側の変数に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Stores the result of performing a bitwise XOR operation on the two given values in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ビット単位XOR演算を２つの与えられた値に関して実行する結果を左手側の変数に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Stores the result of shifting a value’s binary representation the specified number of digits to the left in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値のバイナリ表現を指定された桁数だけ左にシフトする結果を左手側の変数に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Stores the result of shifting a value’s binary representation the specified number of digits to the right in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値のバイナリ表現を指定された桁数だけ右にシフトする結果を左手側の変数に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>String Representation</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>文字列表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Strings in Swift conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept> protocol, so the names are sorted in ascending order according to the less-than operator (<bpt i="1" x="1">&lt;c1&gt;</bpt>&lt;<ept i="1">&lt;/c1&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>文字列はSwift では<bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠します、それでこれらの名前はより小さい演算子（<bpt i="1" x="1">&lt;c1&gt;</bpt>&lt;<ept i="1">&lt;/c1&gt;</ept>）によって昇順にソートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Structures</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>構造体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Structures in Swift can declare methods, property accessors, and initializers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftでの構造体は、メソッド、プロパティアクセッサ、そしてイニシャライザを宣言できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Subclasses must not have any stored properties; any storage needed should be included in <bpt i="0" x="0">&lt;c0&gt;</bpt>Header<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>サブクラスは、どんな保存プロパティも持つ必要はありません；必要とされるあらゆるストレージは<bpt i="0" x="0">&lt;c0&gt;</bpt>Header<ept i="0">&lt;/c0&gt;</ept>の中に含められるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Subscripts</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>添え字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Subtracts one value from another and produces their difference.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値をもう一方から減じて、それらの差を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Subtracts the second value from the first and stores the difference in the left-hand-side variable, wrapping any overflow.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２番目の値を最初のものから減じてその差を左手側の変数の中に格納します、あらゆるオーバーフローをラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Subtracts the second value from the first and stores the difference in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２番目の値を最初のものから減じて、その差を左手側の変数の中に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Supporting Types</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>支援を行う型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Suppresses the representation of all ancestor classes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>全ての先祖クラスの表現を抑制します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift Standard Library</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swift標準ライブラリ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift imports each object instance parameter, return value, and property as an implicitly wrapped optional:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftは、オブジェクトインスタンスパラメータ、戻り値、そしてプロパティそれぞれを暗黙的にラップされたオプショナルとしてインポートします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift imports the type the same way as in the previous section.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftは、その型を以前の節と同じ方法でインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift makes it as easy to create a new set as to create a new array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftは、新しい集合を作成することを新しい配列を作成するのと同じくらい簡単にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift uses a sequence’s or collection’s iterator internally to enable the <bpt i="2" x="2">&lt;c2&gt;</bpt>for<ept i="2">&lt;/c2&gt;</ept>-<bpt i="3" x="3">&lt;c3&gt;</bpt>in<ept i="3">&lt;/c3&gt;</ept> loop language construct.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftは、あるシーケンスのもつまたはコレクションのもつイテレータを内部的に使うことで、<bpt i="2" x="2">&lt;c2&gt;</bpt>for<ept i="2">&lt;/c2&gt;</ept>-<bpt i="3" x="3">&lt;c3&gt;</bpt>in<ept i="3">&lt;/c3&gt;</ept>ループ言語構成体を可能にしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift’s type system usually shows the wrapped type’s name with a trailing question mark (<bpt i="2" x="2">&lt;c2&gt;</bpt>?<ept i="2">&lt;/c2&gt;</ept>) instead of showing the full type name.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftのもつ型システムは通常、ラップされた型のもつ名前を後に続く疑問符（<bpt i="2" x="2">&lt;c2&gt;</bpt>?<ept i="2">&lt;/c2&gt;</ept>）で示します、完全な型の名前を示す代わりに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Testing for Membership</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>帰属をテストする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>That is, for a mutable collection instance <bpt i="2" x="2">&lt;c2&gt;</bpt>a<ept i="2">&lt;/c2&gt;</ept>, index <bpt i="3" x="3">&lt;c3&gt;</bpt>i<ept i="3">&lt;/c3&gt;</ept>, and value <bpt i="4" x="4">&lt;c4&gt;</bpt>x<ept i="4">&lt;/c4&gt;</ept>, the two sets of assignments in the following code sample must be equivalent:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>すなわち、ある可変コレクションインスタンス<bpt i="2" x="2">&lt;c2&gt;</bpt>a<ept i="2">&lt;/c2&gt;</ept>、インデックス<bpt i="3" x="3">&lt;c3&gt;</bpt>i<ept i="3">&lt;/c3&gt;</ept>、そして値<bpt i="4" x="4">&lt;c4&gt;</bpt>x<ept i="4">&lt;/c4&gt;</ept>に対して、以下のコード見本における２組の代入は同等なものでなければなりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>That is, for any elements <bpt i="1" x="1">&lt;c1&gt;</bpt>a<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>b<ept i="2">&lt;/c2&gt;</ept>, and <bpt i="3" x="3">&lt;c3&gt;</bpt>c<ept i="3">&lt;/c3&gt;</ept>, the following conditions must hold:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>すなわち、何らかの要素<bpt i="1" x="1">&lt;c1&gt;</bpt>a<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>b<ept i="2">&lt;/c2&gt;</ept>、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>c<ept i="3">&lt;/c3&gt;</ept>に対して、以下の条件が保持されなければなりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>That is, for any elements <bpt i="5" x="5">&lt;c5&gt;</bpt>a<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>b<ept i="6">&lt;/c6&gt;</ept>, and <bpt i="7" x="7">&lt;c7&gt;</bpt>c<ept i="7">&lt;/c7&gt;</ept>, the following conditions must hold:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>すなわち、何らかの要素<bpt i="5" x="5">&lt;c5&gt;</bpt>a<ept i="5">&lt;/c5&gt;</ept>、<bpt i="6" x="6">&lt;c6&gt;</bpt>b<ept i="6">&lt;/c6&gt;</ept>、そして<bpt i="7" x="7">&lt;c7&gt;</bpt>c<ept i="7">&lt;/c7&gt;</ept>に対して、以下の条件が保持されなければなりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>That is, if <bpt i="2" x="2">&lt;c2&gt;</bpt>source<ept i="2">&lt;/c2&gt;</ept> is negative, the result is padded with ones; otherwise, the result is padded with zeros.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>すなわち、<bpt i="2" x="2">&lt;c2&gt;</bpt>source<ept i="2">&lt;/c2&gt;</ept>が負ならば、結果は１で詰め物をされます；そうでなければ、結果はゼロで詰め物をされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>That kind of conversion is nonbreaking in other contexts, but would trigger a runtime error if the result of <bpt i="3" x="3">&lt;c3&gt;</bpt>offset(of:)<ept i="3">&lt;/c3&gt;</ept> is force-unwrapped.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その種の変換は、他の文脈においては非破壊です、しかし<bpt i="3" x="3">&lt;c3&gt;</bpt>offset(of:)<ept i="3">&lt;/c3&gt;</ept>の結果が強制アンラップされるならば実行時エラーの引き金となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>That requirement holds even for empty ranges.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その要件は空の範囲に対しても適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The 64-bit integer wrapped in a data value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるデータ値の中にラップされる64ビット整数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;&lt;&lt;=<ept i="0">&lt;/c0&gt;</ept> operator performs a <bpt i="1" x="1">&lt;e1&gt;</bpt>masking shift<ept i="1">&lt;/e1&gt;</ept>, where the value used as <bpt i="2" x="2">&lt;c2&gt;</bpt>rhs<ept i="2">&lt;/c2&gt;</ept> is masked to produce a value in the range <bpt i="3" x="3">&lt;c3&gt;</bpt>0..<it pos="begin" x="4">&lt;lhs&lt;w4&gt;</it>.bit<bpt i="5" x="5">&lt;w5&gt;</bpt>Width<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;&lt;&lt;=<ept i="0">&lt;/c0&gt;</ept>演算子は、<bpt i="1" x="1">&lt;e1&gt;</bpt>マスクするシフト<ept i="1">&lt;/e1&gt;</ept>を実行します、そこにおいて<bpt i="2" x="2">&lt;c2&gt;</bpt>rhs<ept i="2">&lt;/c2&gt;</ept>として使われる値はマスクされることで範囲<bpt i="3" x="3">&lt;c3&gt;</bpt>0..<it pos="begin" x="4">&lt;lhs&lt;w4&gt;</it>.bit<bpt i="5" x="5">&lt;w5&gt;</bpt>Width<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>の中の値を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;&gt;&gt;=<ept i="0">&lt;/c0&gt;</ept> operator performs a <bpt i="1" x="1">&lt;e1&gt;</bpt>masking shift<ept i="1">&lt;/e1&gt;</ept>, where the value passed as <bpt i="2" x="2">&lt;c2&gt;</bpt>rhs<ept i="2">&lt;/c2&gt;</ept> is masked to produce a value in the range <bpt i="3" x="3">&lt;c3&gt;</bpt>0..<it pos="begin" x="4">&lt;lhs&lt;w4&gt;</it>.bit<bpt i="5" x="5">&lt;w5&gt;</bpt>Width<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;&gt;&gt;=<ept i="0">&lt;/c0&gt;</ept>演算子は、<bpt i="1" x="1">&lt;e1&gt;</bpt>マスクするシフト<ept i="1">&lt;/e1&gt;</ept>を実行します、そこにおいて<bpt i="2" x="2">&lt;c2&gt;</bpt>rhs<ept i="2">&lt;/c2&gt;</ept>として渡される値はマスクされることで範囲<bpt i="3" x="3">&lt;c3&gt;</bpt>0..<it pos="begin" x="4">&lt;lhs&lt;w4&gt;</it>.bit<bpt i="5" x="5">&lt;w5&gt;</bpt>Width<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>の中の値を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;&lt;<ept i="0">&lt;/c0&gt;</ept> operator performs a <bpt i="1" x="1">&lt;e1&gt;</bpt>smart shift<ept i="1">&lt;/e1&gt;</ept>, which defines a result for a shift of any value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;&lt;<ept i="0">&lt;/c0&gt;</ept>演算子は、ある<bpt i="1" x="1">&lt;e1&gt;</bpt>賢いシフト<ept i="1">&lt;/e1&gt;</ept>を実行します、それは何らかの値のシフトに対する結果を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>&gt;&gt;<ept i="0">&lt;/c0&gt;</ept> operator performs a <bpt i="1" x="1">&lt;e1&gt;</bpt>smart shift<ept i="1">&lt;/e1&gt;</ept>, which defines a result for a shift of any value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>&gt;&gt;<ept i="0">&lt;/c0&gt;</ept>演算子は、ある<bpt i="1" x="1">&lt;e1&gt;</bpt>賢いシフト<ept i="1">&lt;/e1&gt;</ept>を実行します、それは何らかの値のシフトに対する結果を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>&gt;&gt;=<ept i="0">&lt;/c0&gt;</ept> operator performs a <bpt i="1" x="1">&lt;e1&gt;</bpt>smart shift<ept i="1">&lt;/e1&gt;</ept>, which defines a result for a shift of any value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>&gt;&gt;=<ept i="0">&lt;/c0&gt;</ept>演算子は、ある<bpt i="1" x="1">&lt;e1&gt;</bpt>賢いシフト<ept i="1">&lt;/e1&gt;</ept>を実行します、それは何らかの値のシフトに対する結果を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>??<ept i="0">&lt;/c0&gt;</ept> operator also works with another <bpt i="1" x="1">&lt;c1&gt;</bpt>Optional<ept i="1">&lt;/c1&gt;</ept> instance on the right-hand side.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>??<ept i="0">&lt;/c0&gt;</ept>演算子はまた、別の<bpt i="1" x="1">&lt;c1&gt;</bpt>Optional<ept i="1">&lt;/c1&gt;</ept>インスタンスを右手側でも扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept> (presumably non-lazy) sequence from which <bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept> was created.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それから<bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>が作成された<bpt i="1" x="1">&lt;c1&gt;</bpt>Base<ept i="1">&lt;/c1&gt;</ept>（おそらく非遅延の）シーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Iterator<bpt i="1" x="1">&lt;w1&gt;</bpt>Protocol<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol is tightly linked with the <bpt i="2" x="2">&lt;c2&gt;</bpt>Sequence<ept i="2">&lt;/c2&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Iterator<bpt i="1" x="1">&lt;w1&gt;</bpt>Protocol<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルは、<bpt i="2" x="2">&lt;c2&gt;</bpt>Sequence<ept i="2">&lt;/c2&gt;</ept>プロトコルときつく結び付けられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Mutable<bpt i="1" x="1">&lt;w1&gt;</bpt>Collection<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol allows changing the values of a collection’s elements but not the length of the collection itself.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Mutable<bpt i="1" x="1">&lt;w1&gt;</bpt>Collection<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルは、コレクションのもつ要素の値の変更を可能にします、しかしコレクション自体の長さはそうではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_ENUM<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> macro is the only enumeration macro that results in an actual enumeration type when imported to Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_ENUM<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>マクロは、Swiftにインポートされる場合に実際の列挙型という結果になるただ１つの列挙マクロです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Numeric<ept i="0">&lt;/c0&gt;</ept> protocol provides a suitable basis for arithmetic on scalar values, such as integers and floating-point numbers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Numeric<ept i="0">&lt;/c0&gt;</ept>プロトコルは、例えば整数および浮動小数点数など、スカラー値に関する算術にふさわしい基礎を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Optional<ept i="0">&lt;/c0&gt;</ept> type is an enumeration with two cases.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Optional<ept i="0">&lt;/c0&gt;</ept>型は、２つのケース節を持つ列挙です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Playground<bpt i="1" x="1">&lt;w1&gt;</bpt>Quick<bpt i="2" x="2">&lt;w2&gt;</bpt>Look<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol is deprecated, and will be removed from the standard library in a future Swift release.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Playground<bpt i="1" x="1">&lt;w1&gt;</bpt>Quick<bpt i="2" x="2">&lt;w2&gt;</bpt>Look<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルは推奨されません、そして将来のSwiftリリースで標準ライブラリから取り除かれるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol adds further constraints on the associated <bpt i="3" x="3">&lt;c3&gt;</bpt>Indices<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>Sub<bpt i="5" x="5">&lt;w5&gt;</bpt>Sequence<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> types, but otherwise imposes no additional requirements over the <bpt i="6" x="6">&lt;c6&gt;</bpt>Bidirectional<bpt i="7" x="7">&lt;w7&gt;</bpt>Collection<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルは、一層の制約を関連<bpt i="3" x="3">&lt;c3&gt;</bpt>Indices<ept i="3">&lt;/c3&gt;</ept>および<bpt i="4" x="4">&lt;c4&gt;</bpt>Sub<bpt i="5" x="5">&lt;w5&gt;</bpt>Sequence<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>型に加えます、しかしそれ以外では<bpt i="6" x="6">&lt;c6&gt;</bpt>Bidirectional<bpt i="7" x="7">&lt;w7&gt;</bpt>Collection<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>プロトコルを越える追加要件は課されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Representable<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol is seen mainly in two categories of types: enumerations with raw value types and option sets.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Representable<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルが主に見られるのは、２つの部類の型：列挙で生の値型を持つものとオプションセットにおいてです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Sandwich<bpt i="1" x="1">&lt;w1&gt;</bpt>Preferences<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> class and its <bpt i="2" x="2">&lt;c2&gt;</bpt>includes<bpt i="3" x="3">&lt;w3&gt;</bpt>Crust<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> property are renamed to <bpt i="4" x="4">&lt;c4&gt;</bpt>Sandwich<bpt i="5" x="5">&lt;w5&gt;</bpt>.Preferences<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt>is<bpt i="7" x="7">&lt;w7&gt;</bpt>Crusty<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> for Swift:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Sandwich<bpt i="1" x="1">&lt;w1&gt;</bpt>Preferences<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>クラスとそれの<bpt i="2" x="2">&lt;c2&gt;</bpt>includes<bpt i="3" x="3">&lt;w3&gt;</bpt>Crust<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロパティは、<bpt i="4" x="4">&lt;c4&gt;</bpt>Sandwich<bpt i="5" x="5">&lt;w5&gt;</bpt>.Preferences<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>と<bpt i="6" x="6">&lt;c6&gt;</bpt>is<bpt i="7" x="7">&lt;w7&gt;</bpt>Crusty<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>へとSwiftのために改名されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Sequence<ept i="0">&lt;/c0&gt;</ept> protocol makes no other requirements about element access, so routines that traverse a sequence should be considered O(<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>) unless documented otherwise.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Sequence<ept i="0">&lt;/c0&gt;</ept>プロトコルは要素アクセスについて他の要件を設けません、それでシーケンスを辿っていくおきまりの仕事はO(<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>)と考えるべきです、そうでないと文書化されるのでない限り。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Sequence<ept i="0">&lt;/c0&gt;</ept> protocol makes no requirement on conforming types regarding whether they will be destructively consumed by iteration.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Sequence<ept i="0">&lt;/c0&gt;</ept>プロトコルは、準拠する型に関して、それらが反復によって破壊的に消費されることになるかについて要件を設けません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Sequence<ept i="0">&lt;/c0&gt;</ept> protocol provides default implementations for many common operations that depend on sequential access to a sequence’s values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Sequence<ept i="0">&lt;/c0&gt;</ept>プロトコルは、シーケンスのもつ値への順次的なアクセスを頼りにするような多くの一般的な演算に対して省略時の実装を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Signed<bpt i="1" x="1">&lt;w1&gt;</bpt>Numeric<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol extends the operations defined by the <bpt i="2" x="2">&lt;c2&gt;</bpt>Numeric<ept i="2">&lt;/c2&gt;</ept> protocol to include a value’s additive inverse.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Signed<bpt i="1" x="1">&lt;w1&gt;</bpt>Numeric<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルは、<bpt i="2" x="2">&lt;c2&gt;</bpt>Numeric<ept i="2">&lt;/c2&gt;</ept>プロトコルによって定義される演算を拡張して、値の加法の逆元を含めるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>children<ept i="0">&lt;/c0&gt;</ept> collection of the resulting mirror may be upgraded to a random access collection later.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果となるミラーの<bpt i="0" x="0">&lt;c0&gt;</bpt>children<ept i="0">&lt;/c0&gt;</ept>コレクションは、後にランダムアクセスコレクションにアップグレードされるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>fetch<bpt i="1" x="1">&lt;w1&gt;</bpt>Remote<bpt i="2" x="2">&lt;w2&gt;</bpt>Random<bpt i="3" x="3">&lt;w3&gt;</bpt>Number(completion:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method returns <bpt i="4" x="4">&lt;c4&gt;</bpt>Void<ept i="4">&lt;/c4&gt;</ept> synchronously, and asynchronously calls a completion handler with a <bpt i="5" x="5">&lt;c5&gt;</bpt>Result&lt;Int, Entropy<bpt i="6" x="6">&lt;w6&gt;</bpt>Error&gt;<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> instance that contains either a random result or information about the failure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>fetch<bpt i="1" x="1">&lt;w1&gt;</bpt>Remote<bpt i="2" x="2">&lt;w2&gt;</bpt>Random<bpt i="3" x="3">&lt;w3&gt;</bpt>Number(completion:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドは、<bpt i="4" x="4">&lt;c4&gt;</bpt>Void<ept i="4">&lt;/c4&gt;</ept>を同期的に返します、そして非同期に完了ハンドラを<bpt i="5" x="5">&lt;c5&gt;</bpt>Result&lt;Int, Entropy<bpt i="6" x="6">&lt;w6&gt;</bpt>Error&gt;<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>インスタンスとともに呼び出します、それはある無作為な結果またはその失敗についての情報のどちらかを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>high<ept i="0">&lt;/c0&gt;</ept> component of the value carries the sign, if the type is signed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値の<bpt i="0" x="0">&lt;c0&gt;</bpt>high<ept i="0">&lt;/c0&gt;</ept>構成部分は符号を運びます、その型が符号付きならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>logged<bpt i="1" x="1">&lt;w1&gt;</bpt>In<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>session<bpt i="3" x="3">&lt;w3&gt;</bpt>Expired<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> cases include the user as an associated value, while the <bpt i="4" x="4">&lt;c4&gt;</bpt>unregistered<ept i="4">&lt;/c4&gt;</ept> case doesn't include an associated value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>logged<bpt i="1" x="1">&lt;w1&gt;</bpt>In<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>session<bpt i="3" x="3">&lt;w3&gt;</bpt>Expired<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ケース節はユーザを関連値として含みます、一方で<bpt i="4" x="4">&lt;c4&gt;</bpt>unregistered<ept i="4">&lt;/c4&gt;</ept>ケース節は関連値を含みません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>make<bpt i="1" x="1">&lt;w1&gt;</bpt>Iterator()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method returns another custom type, an iterator named <bpt i="2" x="2">&lt;c2&gt;</bpt>Countdown<bpt i="3" x="3">&lt;w3&gt;</bpt>Iterator<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>make<bpt i="1" x="1">&lt;w1&gt;</bpt>Iterator()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドは、別のあつらえの型、<bpt i="2" x="2">&lt;c2&gt;</bpt>Countdown<bpt i="3" x="3">&lt;w3&gt;</bpt>Iterator<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と名前をつけられるイテレータを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>next<bpt i="1" x="1">&lt;w1&gt;</bpt>Partial<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> closure is called sequentially with an accumulating value initialized to <bpt i="3" x="3">&lt;c3&gt;</bpt>initial<bpt i="4" x="4">&lt;w4&gt;</bpt>Result<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> and each element of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>next<bpt i="1" x="1">&lt;w1&gt;</bpt>Partial<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>クロージャは、<bpt i="3" x="3">&lt;c3&gt;</bpt>initial<bpt i="4" x="4">&lt;w4&gt;</bpt>Result<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>へと初期化された蓄積値とシーケンスの各要素とともに連続して呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>next<bpt i="1" x="1">&lt;w1&gt;</bpt>Partial<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> closure is called with <bpt i="3" x="3">&lt;c3&gt;</bpt>initial<bpt i="4" x="4">&lt;w4&gt;</bpt>Result<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>—<bpt i="5" x="5">&lt;c5&gt;</bpt>0<ept i="5">&lt;/c5&gt;</ept> in this case—and the first element of <bpt i="6" x="6">&lt;c6&gt;</bpt>numbers<ept i="6">&lt;/c6&gt;</ept>, returning the sum: <bpt i="7" x="7">&lt;c7&gt;</bpt>1<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>next<bpt i="1" x="1">&lt;w1&gt;</bpt>Partial<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>クロージャが、<bpt i="3" x="3">&lt;c3&gt;</bpt>initial<bpt i="4" x="4">&lt;w4&gt;</bpt>Result<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>—この場合では<bpt i="5" x="5">&lt;c5&gt;</bpt>0<ept i="5">&lt;/c5&gt;</ept>—そして<bpt i="6" x="6">&lt;c6&gt;</bpt>numbers<ept i="6">&lt;/c6&gt;</ept>の最初の要素とともに呼び出されて、その合計：<bpt i="7" x="7">&lt;c7&gt;</bpt>1<ept i="7">&lt;/c7&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>now(_:)<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>later(_:)<ept i="1">&lt;/c1&gt;</ept> functions represent the two most common categories of APIs you'll encounter in methods from app frameworks that take closures: synchronous APIs like <bpt i="2" x="2">&lt;c2&gt;</bpt>now(_:)<ept i="2">&lt;/c2&gt;</ept>, and asynchronous APIs like <bpt i="3" x="3">&lt;c3&gt;</bpt>later(_:)<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>now(_:)<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>later(_:)<ept i="1">&lt;/c1&gt;</ept>関数は、クロージャを取るアプリフレームワーク由来のメソッドにおいてあなたが出くわす、２つの最も一般的なAPIのカテゴリを表します：<bpt i="2" x="2">&lt;c2&gt;</bpt>now(_:)<ept i="2">&lt;/c2&gt;</ept>のような同期的API、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>later(_:)<ept i="3">&lt;/c3&gt;</ept>のような非同期的API。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>nullable<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>nonnull<ept i="1">&lt;/c1&gt;</ept> annotations are simplified forms of the <bpt i="2" x="2">&lt;c2&gt;</bpt>_Nullable<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>_Nonnull<ept i="3">&lt;/c3&gt;</ept> annotations, which you can use in almost any context that you would use the <bpt i="4" x="4">&lt;c4&gt;</bpt>const<ept i="4">&lt;/c4&gt;</ept> keyword with a pointer type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>nullable<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>nonnull<ept i="1">&lt;/c1&gt;</ept>注釈は、<bpt i="2" x="2">&lt;c2&gt;</bpt>_Nullable<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>_Nonnull<ept i="3">&lt;/c3&gt;</ept>注釈の簡素化された形式です、それはあなたが<bpt i="4" x="4">&lt;c4&gt;</bpt>const<ept i="4">&lt;/c4&gt;</ept>キーワードをポインタ型とともに使うであろう、ほとんどあらゆる文脈で使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>numbers<ept i="0">&lt;/c0&gt;</ept> array is now arranged in two partitions.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>numbers<ept i="0">&lt;/c0&gt;</ept>配列は今や２つの区分に整頓されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>r1<ept i="0">&lt;/c0&gt;</ept> range is bounded on the lower end by <bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept> because that is the starting index of the <bpt i="2" x="2">&lt;c2&gt;</bpt>numbers<ept i="2">&lt;/c2&gt;</ept> array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>r1<ept i="0">&lt;/c0&gt;</ept>範囲は、<bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept>によって下端に境界をつけられます、なぜならそれが<bpt i="2" x="2">&lt;c2&gt;</bpt>numbers<ept i="2">&lt;/c2&gt;</ept>配列の開始インデックスだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>reduce1(_:)<ept i="0">&lt;/c0&gt;</ept> method makes certain kinds of sequence operations simpler.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>reduce1(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドは、特定の種類のシーケンス演算をより簡単にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>reversed()<ept i="0">&lt;/c0&gt;</ept> method is always lazy when applied to a collection with bidirectional indices, but does not implicitly confer laziness on algorithms applied to its result.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x.reversed()<ept i="0">&lt;/c0&gt;</ept>メソッドは、双方向性のインデックスを持つコレクションに適用される時は常に遅延です、しかしそれの結果に適用されるアルゴリズムに暗黙的に遅延性を授けることはしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>unsafely<bpt i="1" x="1">&lt;w1&gt;</bpt>Unwrapped<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property is recommended over calling the <bpt i="2" x="2">&lt;c2&gt;</bpt>unsafe<bpt i="3" x="3">&lt;w3&gt;</bpt>Bit<bpt i="4" x="4">&lt;w4&gt;</bpt>Cast(_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> function because the property is more restrictive and because accessing the property still performs checking in debug builds.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>unsafely<bpt i="1" x="1">&lt;w1&gt;</bpt>Unwrapped<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティは、<bpt i="2" x="2">&lt;c2&gt;</bpt>unsafe<bpt i="3" x="3">&lt;w3&gt;</bpt>Bit<bpt i="4" x="4">&lt;w4&gt;</bpt>Cast(_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>関数呼び出し全般で推奨されます、なぜならこのプロパティはより制限的であるから、そしてこのプロパティにアクセスすることはデバッグビルドにおいて依然として確認を実行するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>unsafely<bpt i="1" x="1">&lt;w1&gt;</bpt>Unwrapped<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property provides the same value as the forced unwrap operator (postfix <bpt i="2" x="2">&lt;c2&gt;</bpt>!<ept i="2">&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>unsafely<bpt i="1" x="1">&lt;w1&gt;</bpt>Unwrapped<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティは、強制アンラップ演算子（後置<bpt i="2" x="2">&lt;c2&gt;</bpt>!<ept i="2">&lt;/c2&gt;</ept>）と同じ値を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>update<bpt i="1" x="1">&lt;w1&gt;</bpt>Accumulating<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> closure is called sequentially with a mutable accumulating value initialized to <bpt i="3" x="3">&lt;c3&gt;</bpt>initial<bpt i="4" x="4">&lt;w4&gt;</bpt>Result<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> and each element of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>update<bpt i="1" x="1">&lt;w1&gt;</bpt>Accumulating<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>クロージャは、<bpt i="3" x="3">&lt;c3&gt;</bpt>initial<bpt i="4" x="4">&lt;w4&gt;</bpt>Result<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>へと初期化された可変の蓄積値とシーケンスの各要素とともに連続して呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>update<bpt i="1" x="1">&lt;w1&gt;</bpt>Accumulating<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> closure is called with the initial accumulating value—<bpt i="3" x="3">&lt;c3&gt;</bpt>[:]<ept i="3">&lt;/c3&gt;</ept> in this case—and the first character of <bpt i="4" x="4">&lt;c4&gt;</bpt>letters<ept i="4">&lt;/c4&gt;</ept>, modifying the accumulating value by setting <bpt i="5" x="5">&lt;c5&gt;</bpt>1<ept i="5">&lt;/c5&gt;</ept> for the key <bpt i="6" x="6">&lt;c6&gt;</bpt>"a"<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>update<bpt i="1" x="1">&lt;w1&gt;</bpt>Accumulating<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>クロージャが、初期蓄積値—この場合では<bpt i="3" x="3">&lt;c3&gt;</bpt>[:]<ept i="3">&lt;/c3&gt;</ept>—そして<bpt i="4" x="4">&lt;c4&gt;</bpt>letters<ept i="4">&lt;/c4&gt;</ept>の最初の文字とともに呼び出されて、<bpt i="5" x="5">&lt;c5&gt;</bpt>1<ept i="5">&lt;/c5&gt;</ept>をキー<bpt i="6" x="6">&lt;c6&gt;</bpt>"a"<ept i="6">&lt;/c6&gt;</ept>に対して設定することで蓄積値を修正します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;c1&gt;</bpt>CF<bpt i="2" x="2">&lt;w2&gt;</bpt>_SWIFT<bpt i="3" x="3">&lt;w3&gt;</bpt>_NAME<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> macro is applied to each function, giving each one a new name for Swift that's nested together under the <bpt i="4" x="4">&lt;c4&gt;</bpt>Color<ept i="4">&lt;/c4&gt;</ept> type:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>CF<bpt i="2" x="2">&lt;w2&gt;</bpt>_SWIFT<bpt i="3" x="3">&lt;w3&gt;</bpt>_NAME<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>マクロは各関数に適用されます、それぞれのものに<bpt i="4" x="4">&lt;c4&gt;</bpt>Color<ept i="4">&lt;/c4&gt;</ept>型の下に一緒に入れ子にされるSwift用の新しい名前を与えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;c1&gt;</bpt>make<bpt i="2" x="2">&lt;w2&gt;</bpt>Iterator()<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> method is provided as a default implementation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>make<bpt i="2" x="2">&lt;w2&gt;</bpt>Iterator()<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>メソッドは、省略時の実装として提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>Countdown<ept i="2">&lt;/c2&gt;</ept> structure’s definition is short: It contains only the starting count and the <bpt i="3" x="3">&lt;c3&gt;</bpt>make<bpt i="4" x="4">&lt;w4&gt;</bpt>Iterator()<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> method required by the <bpt i="5" x="5">&lt;c5&gt;</bpt>Sequence<ept i="5">&lt;/c5&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Countdown<ept i="2">&lt;/c2&gt;</ept>構造体の定義は短いです：それはただ数え始めと<bpt i="5" x="5">&lt;c5&gt;</bpt>Sequence<ept i="5">&lt;/c5&gt;</ept>プロトコルによって要求される<bpt i="3" x="3">&lt;c3&gt;</bpt>make<bpt i="4" x="4">&lt;w4&gt;</bpt>Iterator()<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>メソッドだけを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>remove<bpt i="3" x="3">&lt;w3&gt;</bpt>Last()<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method must be used only on a nonempty collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>remove<bpt i="3" x="3">&lt;w3&gt;</bpt>Last()<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドは、空でないコレクションでのみ使われるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="3" x="3">&lt;c3&gt;</bpt>..&lt;<ept i="3">&lt;/c3&gt;</ept> operator creates a range that doesn’t include the upper bound, so it’s always safe to use with <bpt i="4" x="4">&lt;c4&gt;</bpt>end<bpt i="5" x="5">&lt;w5&gt;</bpt>Index<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>..&lt;<ept i="3">&lt;/c3&gt;</ept>演算子は上方の境界を含まないある範囲を作成します、それでそれは常に<bpt i="4" x="4">&lt;c4&gt;</bpt>end<bpt i="5" x="5">&lt;w5&gt;</bpt>Index<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>と使うのに安全です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="3" x="3">&lt;c3&gt;</bpt>high<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>low<ept i="4">&lt;/c4&gt;</ept> properties of the <bpt i="5" x="5">&lt;c5&gt;</bpt>result<ept i="5">&lt;/c5&gt;</ept> value represent 2000 when concatenated to form a double-width integer; that is, using <bpt i="6" x="6">&lt;c6&gt;</bpt>result<bpt i="7" x="7">&lt;w7&gt;</bpt>.high<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> as the high byte and <bpt i="8" x="8">&lt;c8&gt;</bpt>result<bpt i="9" x="9">&lt;w9&gt;</bpt>.low<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> as the low byte of a <bpt i="10" x="10">&lt;c10&gt;</bpt>UInt16<ept i="10">&lt;/c10&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>result<ept i="5">&lt;/c5&gt;</ept>値の<bpt i="3" x="3">&lt;c3&gt;</bpt>high<ept i="3">&lt;/c3&gt;</ept>および<bpt i="4" x="4">&lt;c4&gt;</bpt>low<ept i="4">&lt;/c4&gt;</ept>プロパティは、二倍幅整数に成形するために連結される時2000を表します；すなわち、<bpt i="10" x="10">&lt;c10&gt;</bpt>UInt16<ept i="10">&lt;/c10&gt;</ept>インスタンスの高バイトとして<bpt i="6" x="6">&lt;c6&gt;</bpt>result<bpt i="7" x="7">&lt;w7&gt;</bpt>.high<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>をそして低バイトとして<bpt i="8" x="8">&lt;c8&gt;</bpt>result<bpt i="9" x="9">&lt;w9&gt;</bpt>.low<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>を使って。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="3" x="3">&lt;c3&gt;</bpt>user<ept i="3">&lt;/c3&gt;</ept> variable is <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept> when the user not logged in and has a value once the user logs in.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>user<ept i="3">&lt;/c3&gt;</ept>変数は、ユーザがログインしていない場合<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>です、そして一旦ユーザがログインするならばある値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt>Countdown<bpt i="5" x="5">&lt;w5&gt;</bpt>Iterator<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> type keeps track of both the <bpt i="6" x="6">&lt;c6&gt;</bpt>Countdown<ept i="6">&lt;/c6&gt;</ept> sequence that it’s iterating and the number of times it has returned a value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>Countdown<bpt i="5" x="5">&lt;w5&gt;</bpt>Iterator<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>型は、それが反復している<bpt i="6" x="6">&lt;c6&gt;</bpt>Countdown<ept i="6">&lt;/c6&gt;</ept>シーケンスそしてそれが値を返した回数の両方の情報を得続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt>Key<bpt i="5" x="5">&lt;w5&gt;</bpt>Value<bpt i="6" x="6">&lt;w6&gt;</bpt>Pairs<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> instance preserves the order of the elements as passed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>Key<bpt i="5" x="5">&lt;w5&gt;</bpt>Value<bpt i="6" x="6">&lt;w6&gt;</bpt>Pairs<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>インスタンスは、要素の順番を渡された通りに保全します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt>high<ept i="4">&lt;/c4&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt>low<ept i="5">&lt;/c5&gt;</ept> compnents of the <bpt i="6" x="6">&lt;c6&gt;</bpt>result<ept i="6">&lt;/c6&gt;</ept> value represent <bpt i="7" x="7">&lt;c7&gt;</bpt>-1920<ept i="7">&lt;/c7&gt;</ept> when concatenated to form a double-width integer; that is, using <bpt i="8" x="8">&lt;c8&gt;</bpt>result<bpt i="9" x="9">&lt;w9&gt;</bpt>.high<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> as the high byte and <bpt i="10" x="10">&lt;c10&gt;</bpt>result<bpt i="11" x="11">&lt;w11&gt;</bpt>.low<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> as the low byte of an <bpt i="12" x="12">&lt;c12&gt;</bpt>Int16<ept i="12">&lt;/c12&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>result<ept i="4">&lt;/c4&gt;</ept>値の<bpt i="5" x="5">&lt;c5&gt;</bpt>high<ept i="5">&lt;/c5&gt;</ept>と<bpt i="6" x="6">&lt;c6&gt;</bpt>low<ept i="6">&lt;/c6&gt;</ept>構成要素は、２倍幅整数に成形するために連結される場合<bpt i="7" x="7">&lt;c7&gt;</bpt>-1920<ept i="7">&lt;/c7&gt;</ept>を表します；すなわち、<bpt i="8" x="8">&lt;c8&gt;</bpt>result<bpt i="9" x="9">&lt;w9&gt;</bpt>.high<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>を高バイトとして<bpt i="10" x="10">&lt;c10&gt;</bpt>result<bpt i="11" x="11">&lt;w11&gt;</bpt>.low<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>を低バイトとして<bpt i="12" x="12">&lt;c12&gt;</bpt>Int16<ept i="12">&lt;/c12&gt;</ept>インスタンスに使って。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="5" x="5">&lt;c5&gt;</bpt>Set<bpt i="6" x="6">&lt;w6&gt;</bpt>Algebra<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> protocol is specifically designed to accommodate both kinds of set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>Set<bpt i="6" x="6">&lt;w6&gt;</bpt>Algebra<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>プロトコルは、とりわけ両方の種類の集合に配慮するように設計されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="5" x="5">&lt;c5&gt;</bpt>deinit<ept i="5">&lt;/c5&gt;</ept> of <bpt i="6" x="6">&lt;c6&gt;</bpt>buffer<bpt i="7" x="7">&lt;w7&gt;</bpt>Class<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> must destroy its stored <bpt i="8" x="8">&lt;c8&gt;</bpt>Header<ept i="8">&lt;/c8&gt;</ept> and any constructed <bpt i="9" x="9">&lt;c9&gt;</bpt>Element<ept i="9">&lt;/c9&gt;</ept>s.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt>buffer<bpt i="7" x="7">&lt;w7&gt;</bpt>Class<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>の<bpt i="5" x="5">&lt;c5&gt;</bpt>deinit<ept i="5">&lt;/c5&gt;</ept>は、それの格納した<bpt i="8" x="8">&lt;c8&gt;</bpt>Header<ept i="8">&lt;/c8&gt;</ept>とあらゆる構成した<bpt i="9" x="9">&lt;c9&gt;</bpt>Element<ept i="9">&lt;/c9&gt;</ept>それらを破棄しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="5" x="5">&lt;c5&gt;</bpt>session<bpt i="6" x="6">&lt;w6&gt;</bpt>Expired<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> variable begins as <bpt i="7" x="7">&lt;c7&gt;</bpt>false<ept i="7">&lt;/c7&gt;</ept> and is set to <bpt i="8" x="8">&lt;c8&gt;</bpt>true<ept i="8">&lt;/c8&gt;</ept> if the session expires.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>session<bpt i="6" x="6">&lt;w6&gt;</bpt>Expired<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>変数は、<bpt i="7" x="7">&lt;c7&gt;</bpt>false<ept i="7">&lt;/c7&gt;</ept>で始まります、そしてセッションが期限切れになるならば<bpt i="8" x="8">&lt;c8&gt;</bpt>true<ept i="8">&lt;/c8&gt;</ept>に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The ASCII representation of a number in the radix passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>radix<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>radix<ept i="0">&lt;/c0&gt;</ept>として渡される基数におけるある数のASCII表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The ASCII representation of a number.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある数のASCII表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The Sendable protocol indicates that value of the given type can be safely used in concurrent code.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Sendableプロトコルは、与えられた型の値が並行性コードにおいて安全に使用できることを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The UnsafeSendable protocol indicates that value of the given type can be safely used in concurrent code, but disables some safety checking at the conformance site.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>UnsafeSendableプロトコルは、与えられた型の値が並行性コードにおいて安全に使用できる、しかしいくつかの安全検査を適応場所で作動しなくすることを指し示します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The absence of a value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値の不在。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The accessed slice uses the same indices for the same elements as the original collection uses.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>アクセスされるスライス（切り取り）は、同じ要素に対して元のコレクションが使うのと同じインデックスを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The accessed slice uses the same indices for the same elements as the original collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>アクセスされるスライス（切り取り）は、同じ要素に対して元のコレクションと同じインデックスを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The actual number of elements that can be stored in this object.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このオブジェクトに格納できる要素の実際の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The addition operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>+<ept i="0">&lt;/c0&gt;</ept>) calculates the sum of its two arguments.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>加算演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>+<ept i="0">&lt;/c0&gt;</ept>）は、それの２つの引数の合計を計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The additional initializer omits the label requirement for its first parameter:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>追加的なイニシャライザは、それの最初のパラメータに対するラベル要件を省略します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The additive inverse of the argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この引数の加法の逆元。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The additive inverse of this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値の加法の逆元。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The algorithm used to create random values may change in a future version of Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>無作為値を作成するために使われるアルゴリズムは、将来のSwiftバージョンで変わるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The algorithm used to select a random element may change in a future version of Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある無作為な要素を選択するために使われるアルゴリズムは、将来のSwiftバージョンで変わるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The algorithm used to shuffle a collection may change in a future version of Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるコレクションをシャッフルするために使われるアルゴリズムは、将来のSwiftバージョンで変わるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The algorithm used to shuffle a sequence may change in a future version of Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンスをシャッフルするために使われるアルゴリズムは、将来のSwiftバージョンで変更するかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The argument you pass to the <bpt i="0" x="0">&lt;c0&gt;</bpt>CF<bpt i="1" x="1">&lt;w1&gt;</bpt>_SWIFT<bpt i="2" x="2">&lt;w2&gt;</bpt>_NAME<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> macro uses the same syntax as the <bpt i="3" x="3">&lt;c3&gt;</bpt>#selector<ept i="3">&lt;/c3&gt;</ept> expression.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>CF<bpt i="1" x="1">&lt;w1&gt;</bpt>_SWIFT<bpt i="2" x="2">&lt;w2&gt;</bpt>_NAME<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>マクロに渡す引数は、<bpt i="3" x="3">&lt;c3&gt;</bpt>#selector<ept i="3">&lt;/c3&gt;</ept>式と同じ構文を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The array to append to.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>追加先の配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The base state.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>基底状態。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The behavior of incrementing indefinitely is determined by the type of <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>無限に漸増する挙動は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>の型によって決定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The big-endian representation of this integer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この整数のビッグエンディアン表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The bit width of a <bpt i="0" x="0">&lt;c0&gt;</bpt>Int64<ept i="0">&lt;/c0&gt;</ept> instance is 64.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Int64<ept i="0">&lt;/c0&gt;</ept>インスタンスのビット幅は64です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The bit width of an <bpt i="0" x="0">&lt;c0&gt;</bpt>Int8<ept i="0">&lt;/c0&gt;</ept> instance is 8.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Int8<ept i="0">&lt;/c0&gt;</ept>インスタンスのビット幅は８です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The bitwise NOT operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>~<ept i="0">&lt;/c0&gt;</ept>) is a prefix operator that returns a value in which all the bits of its argument are flipped: Bits that are <bpt i="1" x="1">&lt;c1&gt;</bpt>1<ept i="1">&lt;/c1&gt;</ept> in the argument are <bpt i="2" x="2">&lt;c2&gt;</bpt>0<ept i="2">&lt;/c2&gt;</ept> in the result, and bits that are <bpt i="3" x="3">&lt;c3&gt;</bpt>0<ept i="3">&lt;/c3&gt;</ept> in the argument are <bpt i="4" x="4">&lt;c4&gt;</bpt>1<ept i="4">&lt;/c4&gt;</ept> in the result.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ビット単位のNOT演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>~<ept i="0">&lt;/c0&gt;</ept>）は前置演算子で、それの引数のビットすべてがひっくり返されるある値を返します：引数において<bpt i="1" x="1">&lt;c1&gt;</bpt>1<ept i="1">&lt;/c1&gt;</ept>であるビットは結果において<bpt i="2" x="2">&lt;c2&gt;</bpt>0<ept i="2">&lt;/c2&gt;</ept>になります、そして引数において<bpt i="3" x="3">&lt;c3&gt;</bpt>0<ept i="3">&lt;/c3&gt;</ept>であるビットは結果において<bpt i="4" x="4">&lt;c4&gt;</bpt>1<ept i="4">&lt;/c4&gt;</ept>になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The bounds of the range must be valid indices of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この範囲の境界は、コレクションの有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The bounds of the result are always limited to the bounds of <bpt i="0" x="0">&lt;c0&gt;</bpt>limits<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果の領域は、常に<bpt i="0" x="0">&lt;c0&gt;</bpt>limits<ept i="0">&lt;/c0&gt;</ept>の領域に制限されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The call to <bpt i="0" x="0">&lt;c0&gt;</bpt>animals<bpt i="1" x="1">&lt;w1&gt;</bpt>.make<bpt i="2" x="2">&lt;w2&gt;</bpt>Iterator()<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> returns an instance of the array’s iterator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>animals<bpt i="1" x="1">&lt;w1&gt;</bpt>.make<bpt i="2" x="2">&lt;w2&gt;</bpt>Iterator()<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>への呼び出しは、配列のもつイテレータの１つのインスタンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The call to <bpt i="3" x="3">&lt;c3&gt;</bpt>first<bpt i="4" x="4">&lt;w4&gt;</bpt>Index(where:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> in the following example must traverse the whole collection to find the element that matches the predicate:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>first<bpt i="4" x="4">&lt;w4&gt;</bpt>Index(where:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>への呼び出しは以下の例において、コレクション全体を横断していき、述部に合致する要素を見つけます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The children to use for the mirror.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ミラーのために使う幾らかの子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The class of the object used for storage.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ストレージのために使われるオブジェクトのクラス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The closure is called again repeatedly with the previous call’s return value and each element of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>クロージャは、前の呼び出しの戻り値とシーケンスの各要素とともに繰り返して再び呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The closure is called again repeatedly with the updated accumulating value and each element of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>クロージャは、更新された蓄積値とシーケンスの各要素とともに繰り返して再び呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The collection being appended to allocates any additional necessary storage to hold the new elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションは追加されることによって、新しい要素を保有するために何らかの追加的に必要なストレージを割り当てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The collection must not be empty.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションは空であってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The collection to evaluate this range expression in relation to.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このコレクションに関して、この範囲式を評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The collection traversal modeled by <bpt i="0" x="0">&lt;c0&gt;</bpt>children<ept i="0">&lt;/c0&gt;</ept> is captured so that the resulting mirror’s children may be upgraded to a bidirectional or random access collection later.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>children<ept i="0">&lt;/c0&gt;</ept>による走査型のコレクションはキャプチャされます、それで結果となるミラーのもつ子らは、双方向または無作為アクセスのコレクションに後でアップグレードできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The collection traversal modeled by <bpt i="0" x="0">&lt;c0&gt;</bpt>unlabeled<bpt i="1" x="1">&lt;w1&gt;</bpt>Children<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is captured so that the resulting mirror’s children may be upgraded to a bidirectional or random access collection later.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>unlabeled<bpt i="1" x="1">&lt;w1&gt;</bpt>Children<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>による走査型のコレクションはキャプチャされます、それで結果となるミラーのもつ子らは、双方向または無作為アクセスのコレクションに後でアップグレードできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The collection’s “past the end” position—that is, the position one greater than the last valid subscript argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの「終わりを過ぎた」位置—すなわち、最後の有効な添え字引数より１つ大きい位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The comparison returns <bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept> if both arguments are <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept> or if the two arguments wrap values that are equal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この比較が<bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>を返すのは、両方の引数が<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>である場合か、２つの引数が同等な値らをラップする場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The components used for hashing must be the same as the components compared in your type’s <bpt i="1" x="1">&lt;c1&gt;</bpt>==<ept i="1">&lt;/c1&gt;</ept> operator implementation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ハッシュ化に使用される構成要素は、あなたの型のもつ<bpt i="1" x="1">&lt;c1&gt;</bpt>==<ept i="1">&lt;/c1&gt;</ept>演算子実装において比較される構成要素と同じでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The compositing operation of the fill defaults to the context’s compositing operation, not necessarily using <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>NSCompositing<bpt i="2" x="2">&lt;w2&gt;</bpt>Operation<bpt i="3" x="3">&lt;w3&gt;</bpt>.copy<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> like <bpt i="4" x="4">&lt;a4&gt;</bpt><bpt i="5" x="5">&lt;c5&gt;</bpt>NSRect<bpt i="6" x="6">&lt;w6&gt;</bpt>Fill(_:)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept><ept i="4">&lt;/a4&gt;</ept> does.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>塗りつぶしの合成演算は、初期状態ではその文脈のもつ合成演算になります、必ずしも<bpt i="4" x="4">&lt;a4&gt;</bpt><bpt i="5" x="5">&lt;c5&gt;</bpt>NSRect<bpt i="6" x="6">&lt;w6&gt;</bpt>Fill(_:)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept><ept i="4">&lt;/a4&gt;</ept>がするように<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>NSCompositing<bpt i="2" x="2">&lt;w2&gt;</bpt>Operation<bpt i="3" x="3">&lt;w3&gt;</bpt>.copy<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>を使いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The compositing operation of the fill defaults to the context’s compositing operation, not necessarily using <bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>NSCompositing<bpt i="5" x="5">&lt;w5&gt;</bpt>Operation<bpt i="6" x="6">&lt;w6&gt;</bpt>.copy<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept> like <bpt i="7" x="7">&lt;a7&gt;</bpt><bpt i="8" x="8">&lt;c8&gt;</bpt>NSRect<bpt i="9" x="9">&lt;w9&gt;</bpt>Fill(_:)<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept><ept i="7">&lt;/a7&gt;</ept> does.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>塗りつぶしの合成演算は、初期状態ではその文脈のもつ合成演算になります、必ずしも<bpt i="7" x="7">&lt;a7&gt;</bpt><bpt i="8" x="8">&lt;c8&gt;</bpt>NSRect<bpt i="9" x="9">&lt;w9&gt;</bpt>Fill(_:)<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept><ept i="7">&lt;/a7&gt;</ept>がするように<bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>NSCompositing<bpt i="5" x="5">&lt;w5&gt;</bpt>Operation<bpt i="6" x="6">&lt;w6&gt;</bpt>.copy<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>を使いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The compositing operation to use when filling the rects.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>矩形それらを塗りつぶす時に使う合成演算。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The container to hold.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>収容するためのコンテナ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The contiguous memory footprint of <bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept>, in bytes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept>の隣接メモリフットプリント、バイトで。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The conversion of <bpt i="0" x="0">&lt;c0&gt;</bpt>p<ept i="0">&lt;/c0&gt;</ept> to a string in the assignment to <bpt i="1" x="1">&lt;c1&gt;</bpt>s<ept i="1">&lt;/c1&gt;</ept> uses the <bpt i="2" x="2">&lt;c2&gt;</bpt>Point<ept i="2">&lt;/c2&gt;</ept> type’s <bpt i="3" x="3">&lt;c3&gt;</bpt>debug<bpt i="4" x="4">&lt;w4&gt;</bpt>Description<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>p<ept i="0">&lt;/c0&gt;</ept>の文字列への変換は<bpt i="1" x="1">&lt;c1&gt;</bpt>s<ept i="1">&lt;/c1&gt;</ept>への代入において、<bpt i="2" x="2">&lt;c2&gt;</bpt>Point<ept i="2">&lt;/c2&gt;</ept>型のもつ<bpt i="3" x="3">&lt;c3&gt;</bpt>debug<bpt i="4" x="4">&lt;w4&gt;</bpt>Description<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>プロパティを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The conversion of <bpt i="0" x="0">&lt;c0&gt;</bpt>p<ept i="0">&lt;/c0&gt;</ept> to a string in the assignment to <bpt i="1" x="1">&lt;c1&gt;</bpt>s<ept i="1">&lt;/c1&gt;</ept> uses the <bpt i="2" x="2">&lt;c2&gt;</bpt>Point<ept i="2">&lt;/c2&gt;</ept> type’s <bpt i="3" x="3">&lt;c3&gt;</bpt>description<ept i="3">&lt;/c3&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>s<ept i="1">&lt;/c1&gt;</ept>への代入における<bpt i="0" x="0">&lt;c0&gt;</bpt>p<ept i="0">&lt;/c0&gt;</ept>の文字列への変換は、<bpt i="2" x="2">&lt;c2&gt;</bpt>Point<ept i="2">&lt;/c2&gt;</ept>型のもつ<bpt i="3" x="3">&lt;c3&gt;</bpt>description<ept i="3">&lt;/c3&gt;</ept>プロパティを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The correct placement of the call to <bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;c7&gt;</bpt>close<bpt i="8" x="8">&lt;w8&gt;</bpt>File()<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept><ept i="6">&lt;/s6&gt;</ept> is outside of the closure:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="6" x="6">&lt;s6&gt;</bpt><bpt i="7" x="7">&lt;c7&gt;</bpt>close<bpt i="8" x="8">&lt;w8&gt;</bpt>File()<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept><ept i="6">&lt;/s6&gt;</ept>への呼び出しの正しい配置は、クロージャの外側です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The corresponding value of the raw type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この生の型の対応している値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The custom mirror for this instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このインスタンスのためのあつらえのミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The decoder to read data from.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それからデータを読み出すデコーダ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default implementation returns 0.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時の実装は、０を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default is 10.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時は10。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default is <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時には<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default is <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>初期状態は<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default is <bpt i="3" x="3">&lt;c3&gt;</bpt>.generated<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時は<bpt i="3" x="3">&lt;c3&gt;</bpt>.generated<ept i="3">&lt;/c3&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default memory alignment of <bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept>, in bytes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept>の省略時のメモリアライメント、バイトで。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default memory alignment, in bytes, of the given value’s type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた値の型の、バイトでの、省略時のメモリアライメント。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default separator is an empty string.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時の分離子は空の文字列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default type for an otherwise-unconstrained Boolean literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ブールリテラルである他は別途制約されない省略時用の型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default type for an otherwise-unconstrained floating-point literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>別途制約されない浮動小数点リテラルのための省略時型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default type for an otherwise-unconstrained integer literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>別途制約されない整数リテラルのための省略時型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default value is <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時の値は<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default value is <bpt i="4" x="4">&lt;c4&gt;</bpt>Int<bpt i="5" x="5">&lt;w5&gt;</bpt>.max<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時の値は<bpt i="4" x="4">&lt;c4&gt;</bpt>Int<bpt i="5" x="5">&lt;w5&gt;</bpt>.max<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default value is <bpt i="4" x="4">&lt;c4&gt;</bpt>true<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時の値は、<bpt i="4" x="4">&lt;c4&gt;</bpt>true<ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default value is <bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時の値は、<bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default value is <bpt i="6" x="6">&lt;c6&gt;</bpt>true<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時の値は、<bpt i="6" x="6">&lt;c6&gt;</bpt>true<ept i="6">&lt;/c6&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The descendant of this mirror specified by the given mirror path components if such a descendant exists; otherwise, <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたミラーパス構成要素によって指定されるこのミラーの子孫、もしそのような子孫が存在するならば；そうでなければ、<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The description property of a conforming type must be a value-preserving representation of the original value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>準拠する型の説明プロパティは、元の値の値保全表現でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The difference between these states can be distinguished with a <bpt i="2" x="2">&lt;c2&gt;</bpt>contains(_:)<ept i="2">&lt;/c2&gt;</ept> call.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これらの状態の相違は、<bpt i="2" x="2">&lt;c2&gt;</bpt>contains(_:)<ept i="2">&lt;/c2&gt;</ept>呼び出しで見分けることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The difference needed to produce the receiver’s state from the parameter’s state.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>レシーバのもつ状態をパラメータのもつ状態から生成するのに必要とされる差異。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The difference needed to produce this collection’s ordered elements from the given collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このコレクションのもつ順番付けられた要素をこの与えられたコレクションから生成するのに必要とされる差異。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The difference of the two arguments must be representable in the arguments’ type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの引数の差は、引数の持つ型において表現可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The difference to be applied.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>適用されることになる差異。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The distance between <bpt i="0" x="0">&lt;c0&gt;</bpt>start<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>end<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>start<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>end<ept i="1">&lt;/c1&gt;</ept>の隔たり。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The distance from this value to <bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値から<bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>までの隔たり。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The distance to advance this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値を前進させる距離。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The distance to offset <bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept>を補う間隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The efficiency of finding each element in the argument list depends on the argument type and the capabilities of the each level of the mirror’s <bpt i="0" x="0">&lt;c0&gt;</bpt>children<ept i="0">&lt;/c0&gt;</ept> collections.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>各要素を引数リストにおいて見つけることの効率は、引数型と、ミラーのもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>children<ept i="0">&lt;/c0&gt;</ept>コレクションそれらの各水準の能力に依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The element at the position created using <bpt i="0" x="0">&lt;c0&gt;</bpt>Reversed<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<it pos="begin" x="2">&lt;...&gt;(a&lt;w2&gt;</it>Index)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="3" x="3">&lt;c3&gt;</bpt>"r"<ept i="3">&lt;/c3&gt;</ept>, the character before <bpt i="4" x="4">&lt;c4&gt;</bpt>"a"<ept i="4">&lt;/c4&gt;</ept> in the <bpt i="5" x="5">&lt;c5&gt;</bpt>name<ept i="5">&lt;/c5&gt;</ept> string.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Reversed<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<it pos="begin" x="2">&lt;...&gt;(a&lt;w2&gt;</it>Index)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使って作成された位置での要素は、<bpt i="3" x="3">&lt;c3&gt;</bpt>"r"<ept i="3">&lt;/c3&gt;</ept>、<bpt i="5" x="5">&lt;c5&gt;</bpt>name<ept i="5">&lt;/c5&gt;</ept>文字列の中の<bpt i="4" x="4">&lt;c4&gt;</bpt>"a"<ept i="4">&lt;/c4&gt;</ept>の前の文字です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The element of the set to remove.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>削除されることになる集合の要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The element that should be split upon.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それで分離されることになる要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The element that was removed from the set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合から削除された要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The element to append to the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この要素をコレクションへ追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The element to check for containment.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この要素が含まれるかを調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The element to find in the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスにおいて見つける要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The element to insert.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>挿入される要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The element to look for in the option set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オプションセットにおいて捜される要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The element to remove from the set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合から削除されることになる要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The element to repeat.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>繰り返される要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The element type of a <bpt i="0" x="0">&lt;c0&gt;</bpt>Key<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<bpt i="2" x="2">&lt;w2&gt;</bpt>Pairs<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>: a tuple containing an individual key-value pair.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Key<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<bpt i="2" x="2">&lt;w2&gt;</bpt>Pairs<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の要素型：個々のキー値ペアを含んでいるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The element type of the option set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オプションセットの要素型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The elements of a partial range are the consecutive values from its lower bound continuing upward indefinitely.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>部分範囲の要素は、それの下側の境界から無限に上方に続いている隣接範囲です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The elements of the index vector are wrapped modulo the count of elements in this vector.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インデックスベクターの要素は、このベクターの中の要素の数によるモジュロでラップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The elements of the range are the consecutive values from its lower bound up to, but not including, its upper bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲の要素は、それの下側の境界から、それの上側の境界までしかしそれを含まない、隣接値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The elements of the result are computed lazily, each time they are read, by calling <bpt i="4" x="4">&lt;c4&gt;</bpt>transform<ept i="4">&lt;/c4&gt;</ept> function on a base element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果のそれぞれの要素は遅延に計算されます、毎回それらは、基盤となる要素上で<bpt i="4" x="4">&lt;c4&gt;</bpt>transform<ept i="4">&lt;/c4&gt;</ept>関数を呼び出すことによって読み出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The elements of the result are computed on-demand, as the result is used.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果の要素は、要求に応じて、結果が使われるときに計算されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The elements of the resulting array are ordered according to the given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果の配列の要素は、与えられた述部にしたがって並べられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The elements to append to the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これらの要素をコレクションへ追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The elements to use as members of the new set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい集合の要素として使うための要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The elements to use in the vector.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このベクターにおいて使うことになる要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The encoder to write data to.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>データを書き込むエンコーダ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The end index refers to the position one past the last element of a collection, so it doesn’t correspond with an element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>末尾インデックスは、あるコレクションの最後の要素を１つ過ぎた位置を参照します、それでそれはある要素に対応しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The enumeration has any private cases</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>列挙が何らかのプライベートなケース節を持つならば</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The example below adds another favorite color:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下の例は、別のお気に入りの色を加えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The example below adds the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_REFINED<bpt i="2" x="2">&lt;w2&gt;</bpt>_FOR<bpt i="3" x="3">&lt;w3&gt;</bpt>_SWIFT<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> macro to the <bpt i="4" x="4">&lt;c4&gt;</bpt>get<bpt i="5" x="5">&lt;w5&gt;</bpt>Red(red:<bpt i="6" x="6">&lt;w6&gt;</bpt>green:<bpt i="7" x="7">&lt;w7&gt;</bpt>blue:<bpt i="8" x="8">&lt;w8&gt;</bpt>alpha:)<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> method:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_REFINED<bpt i="2" x="2">&lt;w2&gt;</bpt>_FOR<bpt i="3" x="3">&lt;w3&gt;</bpt>_SWIFT<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>マクロを<bpt i="4" x="4">&lt;c4&gt;</bpt>get<bpt i="5" x="5">&lt;w5&gt;</bpt>Red(red:<bpt i="6" x="6">&lt;w6&gt;</bpt>green:<bpt i="7" x="7">&lt;w7&gt;</bpt>blue:<bpt i="8" x="8">&lt;w8&gt;</bpt>alpha:)<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>メソッドに加えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The example below creates a <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>File<bpt i="2" x="2">&lt;w2&gt;</bpt>Handle<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> and an array of data lines to write to the file that the handle refers to:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下の例は、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>File<bpt i="2" x="2">&lt;w2&gt;</bpt>Handle<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>と、データ行からなる配列を作成して、そのハンドルが参照するファイルに書き出します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The example below defines a <bpt i="0" x="0">&lt;c0&gt;</bpt>Lottery<ept i="0">&lt;/c0&gt;</ept> enumeration that randomly picks a winning number and calls a completion handler if the right number is guessed:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Lottery<ept i="0">&lt;/c0&gt;</ept>列挙を定義します、それはランダムに当選番号を選んで、正しい数が推測されるならば完了ハンドラを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The example below defines two functions, <bpt i="0" x="0">&lt;c0&gt;</bpt>now(_:)<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>later(_:)<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下の例は、２つの関数、<bpt i="0" x="0">&lt;c0&gt;</bpt>now(_:)<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>later(_:)<ept i="1">&lt;/c1&gt;</ept>を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The example below renames a class and one of its properties:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下の例は、クラスとそれのプロパティの１つを改名します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The example below shows an Objective-C API that can be expressed more succinctly once it's imported into Swift:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下の例は、あるObjective-C APIを示します、それはいったんそれがSwiftにインポートされるならばより簡潔に表現可能なものです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The example below shows how to apply the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_OPTIONS<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> macro and assign raw values that are mutually exclusive:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_OPTIONS<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>マクロを適用する、そして互いに排他的である生の値を割り当てる方法を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The example below shows several functions that are all related to a <bpt i="0" x="0">&lt;c0&gt;</bpt>Color<ept i="0">&lt;/c0&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下の例は、すべて<bpt i="0" x="0">&lt;c0&gt;</bpt>Color<ept i="0">&lt;/c0&gt;</ept>型に関係するいくつかの関数を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The example below uses the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_TYPED<bpt i="2" x="2">&lt;w2&gt;</bpt>_ENUM<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> macro to declare the different colors used by a traffic light:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_TYPED<bpt i="2" x="2">&lt;w2&gt;</bpt>_ENUM<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>マクロを使って、信号機によって使われる異なる色を宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The example below uses the macro to declare a <bpt i="0" x="0">&lt;c0&gt;</bpt>UITable<bpt i="1" x="1">&lt;w1&gt;</bpt>View<bpt i="2" x="2">&lt;w2&gt;</bpt>Cell<bpt i="3" x="3">&lt;w3&gt;</bpt>Style<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> enumeration that groups several different view styles for table views:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下の例は、このマクロを使って、<bpt i="0" x="0">&lt;c0&gt;</bpt>UITable<bpt i="1" x="1">&lt;w1&gt;</bpt>View<bpt i="2" x="2">&lt;w2&gt;</bpt>Cell<bpt i="3" x="3">&lt;w3&gt;</bpt>Style<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>列挙を宣言します、それはテーブルビューに対する幾つかの異なるビュースタイルをグループにまとめます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The examples below show how a <bpt i="0" x="0">&lt;c0&gt;</bpt>Favorite<bpt i="1" x="1">&lt;w1&gt;</bpt>Color<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type is declared, imported, and extended.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Favorite<bpt i="1" x="1">&lt;w1&gt;</bpt>Color<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型が宣言、インポート、そして拡張される方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The existing API is renamed with double underscores (<bpt i="4" x="4">&lt;c4&gt;</bpt>__<ept i="4">&lt;/c4&gt;</ept>) when it's imported, to help prevent you from accidentally using the existing API elsewhere.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>既存のAPIは、それがインポートされる時に二重アンダースコア（<bpt i="4" x="4">&lt;c4&gt;</bpt>__<ept i="4">&lt;/c4&gt;</ept>）で改名され、あなたが誤って既存のAPIをどこか他で使うことを防ぐ助けとなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The explicit permission to implement operations lazily applies only in contexts where the sequence is statically known to conform to <bpt i="0" x="0">&lt;c0&gt;</bpt>Lazy<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>遅延に演算を実施するための明示的な許可は、そこにおいてシーケンスが<bpt i="0" x="0">&lt;c0&gt;</bpt>Lazy<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠することを静的に見分けられる文脈においてのみ適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The failure to send when terminating.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>終了する時に送られることになる失敗。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The fill operation uses the <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>device<bpt i="2" x="2">&lt;w2&gt;</bpt>Gray<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> color space.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>塗りつぶし演算は、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>device<bpt i="2" x="2">&lt;w2&gt;</bpt>Gray<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>色空間を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The final accumulated value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最終的に蓄積された値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The final example passes <bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept> for the <bpt i="1" x="1">&lt;c1&gt;</bpt>omitting<bpt i="2" x="2">&lt;w2&gt;</bpt>Empty<bpt i="3" x="3">&lt;w3&gt;</bpt>Subsequences<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> parameter, so the returned array contains empty strings where spaces were repeated.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最後の例は<bpt i="0" x="0">&lt;c0&gt;</bpt>falseを<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>omitting<bpt i="2" x="2">&lt;w2&gt;</bpt>Empty<bpt i="3" x="3">&lt;w3&gt;</bpt>Subsequences<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>パラメータに渡します、なので返される配列は空白が繰り返されたところで空の文字列を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The final example passes <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> for the <bpt i="1" x="1">&lt;c1&gt;</bpt>allow<bpt i="2" x="2">&lt;w2&gt;</bpt>Empty<bpt i="3" x="3">&lt;w3&gt;</bpt>Slices<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> parameter, so the returned array contains empty strings where spaces were repeated.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最後の例は<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>を<bpt i="1" x="1">&lt;c1&gt;</bpt>allow<bpt i="2" x="2">&lt;w2&gt;</bpt>Empty<bpt i="3" x="3">&lt;w3&gt;</bpt>Slices<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>パラメータに渡します、なので返される配列は空白が繰り返されたところで空の文字列を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first element of the collection if the collection is not empty; otherwise, <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションが空でないならばコレクションの最初の要素；そうでなければ<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first element of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの最初の要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first element of the sequence that satisfies <bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>, or <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> if there is no element that satisfies <bpt i="2" x="2">&lt;c2&gt;</bpt>predicate<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>満たすシーケンスの最初の要素、または<bpt i="1" x="1">&lt;c1&gt;</bpt>predicate<ept i="1">&lt;/c1&gt;</ept>を満たす要素が無いならば<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first element of the vector.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ベクターの最初の要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first index where <bpt i="0" x="0">&lt;c0&gt;</bpt>element<ept i="0">&lt;/c0&gt;</ept> is found.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>element<ept i="0">&lt;/c0&gt;</ept>が見つけられたところの最初のインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first mirror path component to access.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>アクセスすることになる最初のミラーパス構成要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first one declares the <bpt i="2" x="2">&lt;c2&gt;</bpt>Favorite<bpt i="3" x="3">&lt;w3&gt;</bpt>Color<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type and adds a single enumeration case for the color blue:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最初のものは、<bpt i="2" x="2">&lt;c2&gt;</bpt>Favorite<bpt i="3" x="3">&lt;w3&gt;</bpt>Color<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型を宣言して、単一の列挙ケース節を青色に対して加えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first partition, <bpt i="1" x="1">&lt;c1&gt;</bpt>numbers[..&lt;p]<ept i="1">&lt;/c1&gt;</ept>, is made up of the elements that are not greater than 30.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最初の区画、<bpt i="1" x="1">&lt;c1&gt;</bpt>numbers[..&lt;p]<ept i="1">&lt;/c1&gt;</ept>は、30より大きくない要素から構成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first use of <bpt i="5" x="5">&lt;c5&gt;</bpt>split<ept i="5">&lt;/c5&gt;</ept> returns each word that was originally separated by one or more spaces.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>split<ept i="5">&lt;/c5&gt;</ept>の最初の利用は、各単語を返します、それはもともと１つ以上の空白で隔てられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first value to add.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>加算する第１の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first value to multiply.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>掛け合わされる第１の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following code shows the <bpt i="0" x="0">&lt;c0&gt;</bpt>My<bpt i="1" x="1">&lt;w1&gt;</bpt>List<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type after annotation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下のコードは、注釈の後の<bpt i="0" x="0">&lt;c0&gt;</bpt>My<bpt i="1" x="1">&lt;w1&gt;</bpt>List<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following code uses this method to test whether all the names in an array have at least five characters:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下のコードは、このメソッドを使って、配列の中の全ての名前が少なくとも５つの文字を含むかどうかを試験します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example accesses an element of an array through its subscript to print its value:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、配列のある要素にそれの添え字によってアクセスしてそれの値を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example adds a new number to an array of integers:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の例は、ある新しい要素を整数からなる配列へ加えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example appends the elements of a <bpt i="0" x="0">&lt;c0&gt;</bpt>Range&lt;Int&gt;<ept i="0">&lt;/c0&gt;</ept> instance to an array of integers:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Range&lt;Int&gt;<ept i="0">&lt;/c0&gt;</ept>インスタンスからなるいくらかの要素を整数からなる配列に追加します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example creates a collection containing the name “Humperdinck” repeated five times:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、５回繰り返した名前「Humperdinck」を含んでいるコレクションを作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example creates a new <bpt i="3" x="3">&lt;c3&gt;</bpt>Reversed<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> from the index of the <bpt i="5" x="5">&lt;c5&gt;</bpt>"a"<ept i="5">&lt;/c5&gt;</ept> character in a string’s character view.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、新しい<bpt i="3" x="3">&lt;c3&gt;</bpt>Reversed<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>を、文字列の文字ビューの中の<bpt i="5" x="5">&lt;c5&gt;</bpt>"a"<ept i="5">&lt;/c5&gt;</ept>文字のインデックスから作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example creates a user-readable list from an array of integers by providing a member style format, list width, and list type:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、ユーザに読みやすいリストを整数いくつかからなるある配列から項目形式書式、リスト幅、そしてリスト型を提供することによって作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example creates an array initialized with five strings containing the letter <bpt i="0" x="0">&lt;e0&gt;</bpt>Z<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、字<bpt i="0" x="0">&lt;e0&gt;</bpt>Z<ept i="0">&lt;/e0&gt;</ept>を含んでいる５つの文字列で初期化される配列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example creates an example class <bpt i="0" x="0">&lt;c0&gt;</bpt>Integer<bpt i="1" x="1">&lt;w1&gt;</bpt>Ref<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and compares instances of the class using their object identifiers and the identical-to operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>===<ept i="2">&lt;/c2&gt;</ept>):</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の例は、ある見本クラス<bpt i="0" x="0">&lt;c0&gt;</bpt>Integer<bpt i="1" x="1">&lt;w1&gt;</bpt>Ref<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を作成して、そのクラスのインスタンスをそれらのオブジェクト識別子と同一演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>===<ept i="2">&lt;/c2&gt;</ept>）を使って比較します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example declares a <bpt i="2" x="2">&lt;c2&gt;</bpt>Point<ept i="2">&lt;/c2&gt;</ept> type with <bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>y<ept i="4">&lt;/c4&gt;</ept> coordinates and a Boolean <bpt i="5" x="5">&lt;c5&gt;</bpt>is<bpt i="6" x="6">&lt;w6&gt;</bpt>Filled<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、<bpt i="2" x="2">&lt;c2&gt;</bpt>Point<ept i="2">&lt;/c2&gt;</ept>型を<bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>および<bpt i="4" x="4">&lt;c4&gt;</bpt>y<ept i="4">&lt;/c4&gt;</ept>座標、そしてブールの<bpt i="5" x="5">&lt;c5&gt;</bpt>is<bpt i="6" x="6">&lt;w6&gt;</bpt>Filled<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>プロパティで宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example declares a function that returns the index of the last even number in the passed array, if one is found.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、ある関数を宣言します、それは渡された配列の中の最後の偶数のインデックスを返します、それが見つけられるならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example defines <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> as an instance of <bpt i="1" x="1">&lt;c1&gt;</bpt>UInt8<ept i="1">&lt;/c1&gt;</ept>, an 8-bit, unsigned integer type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>を<bpt i="1" x="1">&lt;c1&gt;</bpt>UInt8<ept i="1">&lt;/c1&gt;</ept>のインスタンス、ある８ビットの、符号なし整数型として定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example extends <bpt i="0" x="0">&lt;c0&gt;</bpt>Sequence<ept i="0">&lt;/c0&gt;</ept> with a method that returns an array with the sequence’s values multiplied by two.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Sequence<ept i="0">&lt;/c0&gt;</ept>をあるメソッドで拡張します、それはそのシーケンスの２を掛けた値を持つ配列を返すものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example introduces an API that generates random numbers, but that fails approximately half of the time.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、無作為な数を生成するあるAPIを導入します、しかしそれはおおよそ半分は失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example models an asynchronous source of random numbers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、無作為数の非同期ソースをこしらえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、文字列の開始インデックスから４位置進んだインデックスを取得して、それからその位置の文字を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example obtains an index advanced four positions from an array’s starting index and then prints the element at that position.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、配列の始まりから４位置進んだインデックスを入手して、それからその位置での要素を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example reverses the elements of an array of characters:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、文字列からなる配列の要素を逆順にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example searches for the index of the number <bpt i="0" x="0">&lt;c0&gt;</bpt>40<ept i="0">&lt;/c0&gt;</ept> in an array of integers, and then prints the suffix of the array starting at that index:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、整数からなる配列において数<bpt i="0" x="0">&lt;c0&gt;</bpt>40<ept i="0">&lt;/c0&gt;</ept>のインデックスを捜して、それからそのインデックスで始まる配列の末尾を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example searches for the index of the number <bpt i="2" x="2">&lt;c2&gt;</bpt>40<ept i="2">&lt;/c2&gt;</ept> in an array of integers, and then prints the prefix of the array up to, and including, that index:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、整数からなる配列において数<bpt i="2" x="2">&lt;c2&gt;</bpt>40<ept i="2">&lt;/c2&gt;</ept>のインデックスを捜して、それからそのインデックスに至るまでの、そしてそれを含めて、配列の冒頭を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example searches for the index of the number <bpt i="2" x="2">&lt;c2&gt;</bpt>40<ept i="2">&lt;/c2&gt;</ept> in an array of integers, and then prints the prefix of the array up to, but not including, that index:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、整数からなる配列において数<bpt i="2" x="2">&lt;c2&gt;</bpt>40<ept i="2">&lt;/c2&gt;</ept>のインデックスを捜して、それからそのインデックスに至るまでの、しかしそれを含めずに、配列の冒頭を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example shows how an array of strings can be joined to a single, comma-separated string:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、どのように文字列からなる配列が単一の、コンマ区切りの文字列へと連結できるかを示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example shows how an iterator can be used explicitly to emulate a <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> loop.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の例は、イテレータが明示的に使われて<bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>ループの機能を真似る方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example shows how you can determine free shipping options based on a customer’s purchase price:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、どうやってあなたが顧客の購入品価格を基に無償出荷オプションを判定できるかを示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example transforms the error value of a result by wrapping it in a custom <bpt i="1" x="1">&lt;c1&gt;</bpt>Error<ept i="1">&lt;/c1&gt;</ept> type:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、ある結果のエラー値を、それをあるあつらえの<bpt i="1" x="1">&lt;c1&gt;</bpt>Error<ept i="1">&lt;/c1&gt;</ept>型の中のラップすることによって変換します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example transforms the integer success value of a result into a string:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、ある結果の整数成功値を文字列へ変換します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example uses optional chaining to access the <bpt i="1" x="1">&lt;c1&gt;</bpt>has<bpt i="2" x="2">&lt;w2&gt;</bpt>Suffix(_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> method on a <bpt i="3" x="3">&lt;c3&gt;</bpt>String?<ept i="3">&lt;/c3&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、オプショナル連鎖を使って、<bpt i="1" x="1">&lt;c1&gt;</bpt>has<bpt i="2" x="2">&lt;w2&gt;</bpt>Suffix(_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>メソッドに<bpt i="3" x="3">&lt;c3&gt;</bpt>String?<ept i="3">&lt;/c3&gt;</ept>インスタンス上でアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example uses the <bpt i="0" x="0">&lt;c0&gt;</bpt>drop(while:)<ept i="0">&lt;/c0&gt;</ept> method to skip over the positive numbers at the beginning of the <bpt i="1" x="1">&lt;c1&gt;</bpt>numbers<ept i="1">&lt;/c1&gt;</ept> array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>drop(while:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使って、正の数を<bpt i="1" x="1">&lt;c1&gt;</bpt>numbers<ept i="1">&lt;/c1&gt;</ept>配列の始まりで省きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example uses the <bpt i="0" x="0">&lt;c0&gt;</bpt>first(where:)<ept i="0">&lt;/c0&gt;</ept> method to find the first negative number in an array of integers:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>first(where:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使って、整数の配列において最初の負数を見つけます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example uses the <bpt i="0" x="0">&lt;c0&gt;</bpt>negate()<ept i="0">&lt;/c0&gt;</ept> method to negate the value of an integer <bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は<bpt i="0" x="0">&lt;c0&gt;</bpt>negate()<ept i="0">&lt;/c0&gt;</ept>メソッドを使って、整数<bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept>の値を負にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example uses the <bpt i="0" x="0">&lt;c0&gt;</bpt>prefix(while:)<ept i="0">&lt;/c0&gt;</ept> method to find the positive numbers at the beginning of the <bpt i="1" x="1">&lt;c1&gt;</bpt>numbers<ept i="1">&lt;/c1&gt;</ept> array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>prefix(while:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使って、正の数を<bpt i="1" x="1">&lt;c1&gt;</bpt>numbers<ept i="1">&lt;/c1&gt;</ept>配列の始まりで見つけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example uses the <bpt i="2" x="2">&lt;c2&gt;</bpt>~=<ept i="2">&lt;/c2&gt;</ept> operator to test whether an integer is included in a range of single-digit numbers:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、<bpt i="2" x="2">&lt;c2&gt;</bpt>~=<ept i="2">&lt;/c2&gt;</ept>演算子を使って、ある整数が一桁の数いくつかからなるある範囲に含まれるかどうか調べます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example uses the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>init(catching:)<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> initializer in the broader context of saving a series of calls for later statistical analysis:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>init(catching:)<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>イニシャライザを、後で統計学的に分析するために一連の呼び出しを保存する、より幅広い文脈において使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example uses the macro as a suffix to rename an enumeration:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、マクロを接尾辞として使って列挙を改名します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example uses this method to convert a partial range up to <bpt i="1" x="1">&lt;c1&gt;</bpt>4<ept i="1">&lt;/c1&gt;</ept> into a half-open range, using an array instance to add the range’s lower bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、このメソッドを使って、<bpt i="1" x="1">&lt;c1&gt;</bpt>4<ept i="1">&lt;/c1&gt;</ept>までの不完全な範囲を半開範囲へと変換します、配列インスタンスを使って範囲の下側の境界を追加しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example uses this method to multiply two <bpt i="6" x="6">&lt;c6&gt;</bpt>Int8<ept i="6">&lt;/c6&gt;</ept> values that normally overflow when multiplied:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、このメソッドを使って、通常は乗算した時オーバーフローする２つの<bpt i="6" x="6">&lt;c6&gt;</bpt>Int8<ept i="6">&lt;/c6&gt;</ept>値を乗算します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example uses this method to multiply two <bpt i="6" x="6">&lt;c6&gt;</bpt>UInt8<ept i="6">&lt;/c6&gt;</ept> values that normally overflow when multiplied:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、このメソッドを使って、通常は乗算した時オーバーフローする２つの<bpt i="6" x="6">&lt;c6&gt;</bpt>UInt8<ept i="6">&lt;/c6&gt;</ept>値を乗算します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following examples show the effects of the <bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Splits<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>omitting<bpt i="3" x="3">&lt;w3&gt;</bpt>Empty<bpt i="4" x="4">&lt;w4&gt;</bpt>Subsequences<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> parameters when splitting a string at each space character (” “).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Splits<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>omitting<bpt i="3" x="3">&lt;w3&gt;</bpt>Empty<bpt i="4" x="4">&lt;w4&gt;</bpt>Subsequences<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>パラメータの効果を、各空白文字（” “）で文字列を分割する場合で示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following examples show the effects of the <bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Splits<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>omitting<bpt i="3" x="3">&lt;w3&gt;</bpt>Empty<bpt i="4" x="4">&lt;w4&gt;</bpt>Subsequences<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> parameters when splitting a string using a closure that matches spaces.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Splits<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>omitting<bpt i="3" x="3">&lt;w3&gt;</bpt>Empty<bpt i="4" x="4">&lt;w4&gt;</bpt>Subsequences<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>パラメータの効果を、空白にマッチするクロージャを使って文字列を分割する場合で示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following examples use this dictionary of image names and file paths:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以降の例は、この画像名とファイルパスの辞書を使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following rules determine how an API's existing interface is imported:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の規則は、APIの持つ既存のインターフェイスがインポートされる方法を決定します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The fourth element of the vector.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ベクターの４番目の要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The given argument without any changes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>何ら変更のない、与えられた引数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The global <bpt i="0" x="0">&lt;c0&gt;</bpt>abs(_:)<ept i="0">&lt;/c0&gt;</ept> function provides more familiar syntax when you need to find an absolute value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>グローバル<bpt i="0" x="0">&lt;c0&gt;</bpt>abs(_:)<ept i="0">&lt;/c0&gt;</ept>関数は、あなたが絶対値を見つける必要がある時により親しみやすい構文を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The greatest element in the vector.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このベクターの中の最大の要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The greatest scalar in the vector.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ベクターの中の最も大きいスカラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The hash value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ハッシュ値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The hasher to use when combining the components of this instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このインスタンスの構成要素を結合する場合に使うハーシャー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The implementation of the new <bpt i="0" x="0">&lt;c0&gt;</bpt>rgba<ept i="0">&lt;/c0&gt;</ept> property reuses the existing <bpt i="1" x="1">&lt;c1&gt;</bpt>_<bpt i="2" x="2">&lt;w2&gt;</bpt>_get<bpt i="3" x="3">&lt;w3&gt;</bpt>Red(red:<bpt i="4" x="4">&lt;w4&gt;</bpt>green:<bpt i="5" x="5">&lt;w5&gt;</bpt>blue:<bpt i="6" x="6">&lt;w6&gt;</bpt>alpha:)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> method to ensure that functionality remains the same between Swift and Objective-C:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>rgba<ept i="0">&lt;/c0&gt;</ept>プロパティの実装は、既存の<bpt i="1" x="1">&lt;c1&gt;</bpt>_<bpt i="2" x="2">&lt;w2&gt;</bpt>_get<bpt i="3" x="3">&lt;w3&gt;</bpt>Red(red:<bpt i="4" x="4">&lt;w4&gt;</bpt>green:<bpt i="5" x="5">&lt;w5&gt;</bpt>blue:<bpt i="6" x="6">&lt;w6&gt;</bpt>alpha:)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>メソッドを再利用して、SwiftとObjective-Cの間で機能性が同じままであることを確かにします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The increasing sequence of nonnegative integers used along with the bitwise left shift operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;&lt;<ept i="0">&lt;/c0&gt;</ept>) ensures that each option in the option set takes up a unique bit in the binary representation of the raw value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>非負整数からなるシーケンスの漸増、それだけでなくビット単位左シフト演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;&lt;<ept i="0">&lt;/c0&gt;</ept>）は、オプションセットの中の各オプションが、生の値のバイナリ表現においてある特有なビットを取ることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The index at which to start the resulting subsequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それで結果の下位シーケンスが始まるインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The index of <bpt i="0" x="0">&lt;c0&gt;</bpt>member<ept i="0">&lt;/c0&gt;</ept> if it exists in the set; otherwise, <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それがこの集合に含まれるならば<bpt i="0" x="0">&lt;c0&gt;</bpt>member<ept i="0">&lt;/c0&gt;</ept>のインデックス；そうでなければ、<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The index of the element to access.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>アクセスする要素のインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The index of the first element for which <bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept> returns <bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それに対して<bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>を返す最初の要素のインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The index of the first element in the reordered collection that matches <bpt i="0" x="0">&lt;c0&gt;</bpt>belongs<bpt i="1" x="1">&lt;w1&gt;</bpt>In<bpt i="2" x="2">&lt;w2&gt;</bpt>Second<bpt i="3" x="3">&lt;w3&gt;</bpt>Partition<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>並べ直されたコレクションの中の最初の要素のインデックス、それは<bpt i="0" x="0">&lt;c0&gt;</bpt>belongs<bpt i="1" x="1">&lt;w1&gt;</bpt>In<bpt i="2" x="2">&lt;w2&gt;</bpt>Second<bpt i="3" x="3">&lt;w3&gt;</bpt>Partition<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に合致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The index of the first value to swap.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>交換する１つ目の値のインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The index of the last element in the collection that matches <bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>, or <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> if no elements match.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>に合致する、コレクションの中の最後の要素のインデックス、または合致する要素がないならば<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The index of the last element to include in the resulting subsequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果の下位シーケンスの中に含まれることになる最後の要素のインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The index of the member to remove.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>削除するメンバのインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The index of the second value to swap.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>交換する２つ目の値のインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The index value immediately after <bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept>の直後のインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The index value immediately before <bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept>の直前のインデックス値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The indices that are valid for subscripting the collection, in ascending order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの添え字に使うのに有効である、昇順でのインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The indices that are valid for subscripting the range, in ascending order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>昇順で、範囲の添え字として有効なインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The instance for which to create a mirror.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それに対してミラーを作成するインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The instance to represent in the new mirror.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいミラーの中で表現するインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The instances of <bpt i="8" x="8">&lt;c8&gt;</bpt>NSSet<ept i="8">&lt;/c8&gt;</ept> and <bpt i="9" x="9">&lt;c9&gt;</bpt>Set<ept i="9">&lt;/c9&gt;</ept> share buffer using the same copy-on-write optimization that is used when two instances of <bpt i="10" x="10">&lt;c10&gt;</bpt>Set<ept i="10">&lt;/c10&gt;</ept> share buffer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="8" x="8">&lt;c8&gt;</bpt>NSSet<ept i="8">&lt;/c8&gt;</ept>と<bpt i="9" x="9">&lt;c9&gt;</bpt>Set<ept i="9">&lt;/c9&gt;</ept>のインスタンスは、<bpt i="10" x="10">&lt;c10&gt;</bpt>Set<ept i="10">&lt;/c10&gt;</ept>の２つのインスタンスがバッファを共有するとき使われるのと、同じコピーオンライト最適化を使ってバッファを共有します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The intersection of <bpt i="0" x="0">&lt;c0&gt;</bpt>[member]<ept i="0">&lt;/c0&gt;</ept> and the set, if the intersection was nonempty; otherwise, <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>[member]<ept i="0">&lt;/c0&gt;</ept>とこの集合の交叉、その交叉が空でなかったならば；そうでなければ、<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The intersection of <bpt i="0" x="0">&lt;c0&gt;</bpt>[new<bpt i="1" x="1">&lt;w1&gt;</bpt>Member]<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and the set if the intersection was nonempty; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>[new<bpt i="1" x="1">&lt;w1&gt;</bpt>Member]<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>とこの集合の交叉、その交叉が空でなかったならば；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The iterator for a <bpt i="0" x="0">&lt;c0&gt;</bpt>Partial<bpt i="1" x="1">&lt;w1&gt;</bpt>Range<bpt i="2" x="2">&lt;w2&gt;</bpt>From<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Partial<bpt i="1" x="1">&lt;w1&gt;</bpt>Range<bpt i="2" x="2">&lt;w2&gt;</bpt>From<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスに対するイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The joined sequence of elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>つなぎ合わされたシーケンス要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The key that the decoded value is associated with.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>デコードされた値が関連付けられるキー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The key that the nested container is associated with.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>入れ子にされたコンテナが関連付けられるキー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The key to associate the object with.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オブジェクトと関連付けられるキー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The key to associate the value with.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値と関連付けられるキー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The key to decode <bpt i="0" x="0">&lt;c0&gt;</bpt>super<ept i="0">&lt;/c0&gt;</ept> for.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>super<ept i="0">&lt;/c0&gt;</ept>をデコードするためのキー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The key to encode <bpt i="0" x="0">&lt;c0&gt;</bpt>super<ept i="0">&lt;/c0&gt;</ept> for.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それに対して<bpt i="0" x="0">&lt;c0&gt;</bpt>super<ept i="0">&lt;/c0&gt;</ept>をエンコードすることになるキー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The key to encode the container for.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それに対してコンテナをエンコードすることになるキー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The key to search for.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このキーについて調査します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The key type to use for the container.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コンテナに対して使うためのキー型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The key-value pair at position <bpt i="0" x="0">&lt;c0&gt;</bpt>position<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>位置<bpt i="0" x="0">&lt;c0&gt;</bpt>position<ept i="0">&lt;/c0&gt;</ept>でのキー値ペア。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The kind of error this publisher might publish.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このパブリッシャーが発行するかもしれないエラーの種類。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The kind of value published by this publisher.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このパブリッシャーによって発行された値の種類。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The kind of values published by this publisher.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このパブリッシャーによって発行される値の種類。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The labels of the resulting mirror’s <bpt i="2" x="2">&lt;c2&gt;</bpt>children<ept i="2">&lt;/c2&gt;</ept> collection are all <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果のミラーのもつ<bpt i="2" x="2">&lt;c2&gt;</bpt>children<ept i="2">&lt;/c2&gt;</ept>コレクションのラベルは、すべて<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The last element of the collection if the collection has one or more elements; otherwise, <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションが１つ以上の要素を持つならばコレクションの最後の要素；そうでなければ<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The last element of the collection if the collection is not empty; otherwise, <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションが空でないならばコレクションの最後の要素；そうでなければ<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The last element of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの最後の要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The last element of the sequence that satisfies <bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>, or <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> if there is no element that satisfies <bpt i="2" x="2">&lt;c2&gt;</bpt>predicate<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>満たすシーケンスの最後の要素、または<bpt i="1" x="1">&lt;c1&gt;</bpt>predicate<ept i="1">&lt;/c1&gt;</ept>を満たす要素が無いならば<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The last index where <bpt i="0" x="0">&lt;c0&gt;</bpt>element<ept i="0">&lt;/c0&gt;</ept> is found.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そこで<bpt i="0" x="0">&lt;c0&gt;</bpt>element<ept i="0">&lt;/c0&gt;</ept>が見つけられた最後のインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The least element in the vector.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このベクターの中の最小の要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The least scalar in the vector.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ベクターの中の最小のスカラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The list format style.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>リスト書式形式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The literal <bpt i="3" x="3">&lt;c3&gt;</bpt>23<ept i="3">&lt;/c3&gt;</ept> is inferred as an <bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept> instance and then wrapped as an optional before the comparison is performed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>リテラル<bpt i="3" x="3">&lt;c3&gt;</bpt>23<ept i="3">&lt;/c3&gt;</ept>は、<bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept>インスタンスと推論され、それから比較が実行される前にオプショナルとしてラップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The little-endian representation of this integer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この整数のリトルエンディアン表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The lower bound for the range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲の下側の境界。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The macro behaves just like the <bpt i="2" x="2">&lt;c2&gt;</bpt>NS<bpt i="3" x="3">&lt;w3&gt;</bpt>_SWIFT<bpt i="4" x="4">&lt;w4&gt;</bpt>_UNAVAILABLE<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> macro except that it doesn't support the customizable error message and it restricts compile-time access to the declaration in Objective-C code.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このマクロはちょうど<bpt i="2" x="2">&lt;c2&gt;</bpt>NS<bpt i="3" x="3">&lt;w3&gt;</bpt>_SWIFT<bpt i="4" x="4">&lt;w4&gt;</bpt>_UNAVAILABLE<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>マクロのように振舞います、しかしそれがカスタマイズ可能なエラーメッセージをサポートしないことと、それがコンパイル時アクセスをObjective-Cコードの中の宣言に制限することを除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The macro preserves the Objective-C name for use with Objective-C code, so the API has appropriate names in each language.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このマクロは、Objective-C名をObjective-Cコードで使うために保護します、それでそのAPIは適切な名前を各言語において持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The magnitude of this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値の規模。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The mask type resulting from pointwise comparisons of this vector type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このベクター型のポイント単位比較からの結果のマスク型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The masking addition assignment operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;+=<ept i="0">&lt;/c0&gt;</ept>) silently wraps any overflow that occurs during the operation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>マスク加算代入演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;+=<ept i="0">&lt;/c0&gt;</ept>）は、演算の間に起こるあらゆるオーバーフローを黙ってラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The masking multiplication assignment operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;*=<ept i="0">&lt;/c0&gt;</ept>) silently wraps any overflow that occurs during the operation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>マスク乗算代入演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;*=<ept i="0">&lt;/c0&gt;</ept>）は、演算の間に起こるあらゆるオーバーフローを黙ってラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The masking subtraction assignment operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;-=<ept i="0">&lt;/c0&gt;</ept>) silently wraps any overflow that occurs during the operation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>マスク減算代入演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;-=<ept i="0">&lt;/c0&gt;</ept>）は、演算の間に起こるあらゆるオーバーフローを黙ってラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The maximum number of elements to return.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>返される要素の最大限の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The maximum number of times to split the collection, or one less than the number of subsequences to return.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションを分割する回数の最大限度、または返される下位シーケンスの数より１つ少ないもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The maximum number of times to split the sequence, or one less than the number of subsequences to return.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスを分割する回数の最大限度、または返される下位シーケンスの数より１つ少ないもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The maximum representable integer in this type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型における最大の表現可能な整数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The means of generating the subject’s ancestor representation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>主題のもつ先祖表現を生み出す手段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The memory layout of a type, describing its size, stride, and alignment.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある型のメモリレイアウト、それはそれのサイズ、ストライド、およびアライメントを記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The minimum number of <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>s that must be able to be stored in the new buffer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいバッファに格納されることが可能でなければならない<bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>の最小限の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The minimum number of elements that the newly created set should be able to store without reallocating its storage buffer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しく作成された集合がそれのストレージバッファをアロケートし直すことなしに格納できるであろう要素の最小の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The minimum representable integer in this type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型における最小の表現可能な整数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The most common way to iterate over the elements of a sequence is to use a <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> loop:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスの要素のすべてにわたって反復するための最も一般的な方法は、<bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>ループを使うことです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The most effective approach for migrating code to Swift is on a per-file basis—that is, one class at a time.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>スウィフトへの移っているコードのために最も効果的なアプローチは、ファイル毎原則の上にあります ― すなわち、一度にひとつのクラス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The multiplication operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>*<ept i="0">&lt;/c0&gt;</ept>) calculates the product of its two arguments.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>乗算演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>*<ept i="0">&lt;/c0&gt;</ept>）は、それの２つの引数の積を計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The negation operator (prefix <bpt i="0" x="0">&lt;c0&gt;</bpt>-<ept i="0">&lt;/c0&gt;</ept>) returns the additive inverse of its argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>負にする演算子（前置<bpt i="0" x="0">&lt;c0&gt;</bpt>-<ept i="0">&lt;/c0&gt;</ept>）は、この引数の加法の逆元を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The new element is inserted before the element currently at the specified index.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい要素は、指定されたインデックスでの現在の要素の前に挿入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The new element to insert into the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションに挿入されることになる新しい要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The new elements are inserted before the element currently at the specified index.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいいくらかの要素が、指定されたインデックスでの現在の要素の前に挿入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The new elements to add to the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションに加える新しいいくらかの要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The new elements to insert into the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションへ挿入される新しいいくらかの要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The new name is shorter, but still understandable because it uses an industry-standard initialism for color components: RGBA.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい名前はより短いです、しかしまだ理解可能です、なぜならそれは色構成要素のための業界標準頭文字語：RGBAを使うからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The next element in the underlying sequence, if a next element exists; otherwise, <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の要素が存在するならば、基礎をなすシーケンス中の次の要素；そうでなければ、<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The next example attempts to retrieve an index six positions from <bpt i="0" x="0">&lt;c0&gt;</bpt>s<bpt i="1" x="1">&lt;w1&gt;</bpt>.start<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> but fails, because that distance is beyond the index passed as <bpt i="3" x="3">&lt;c3&gt;</bpt>limit<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の例は<bpt i="0" x="0">&lt;c0&gt;</bpt>s<bpt i="1" x="1">&lt;w1&gt;</bpt>.start<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から６位置のインデックスをとりだすことを試みます、しかし失敗します、なぜならその間隔は<bpt i="3" x="3">&lt;c3&gt;</bpt>limit<ept i="3">&lt;/c3&gt;</ept>として渡されるインデックスを越えるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The next example attempts to retrieve an index ten positions from <bpt i="0" x="0">&lt;c0&gt;</bpt>numbers<bpt i="1" x="1">&lt;w1&gt;</bpt>.start<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, but fails, because that distance is beyond the index passed as <bpt i="3" x="3">&lt;c3&gt;</bpt>limit<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の例は<bpt i="0" x="0">&lt;c0&gt;</bpt>numbers<bpt i="1" x="1">&lt;w1&gt;</bpt>.start<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から10位置のインデックスをとりだすことを試みます、しかし失敗します、なぜならその間隔は<bpt i="3" x="3">&lt;c3&gt;</bpt>limit<ept i="3">&lt;/c3&gt;</ept>として渡されるインデックスを越えるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The next example creates a slice of <bpt i="4" x="4">&lt;c4&gt;</bpt>numbers<ept i="4">&lt;/c4&gt;</ept> starting at index <bpt i="5" x="5">&lt;c5&gt;</bpt>2<ept i="5">&lt;/c5&gt;</ept>, and then uses the slice with <bpt i="6" x="6">&lt;c6&gt;</bpt>relative(to:)<ept i="6">&lt;/c6&gt;</ept> to convert <bpt i="7" x="7">&lt;c7&gt;</bpt>up<bpt i="8" x="8">&lt;w8&gt;</bpt>To<bpt i="9" x="9">&lt;w9&gt;</bpt>Four<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> to a concrete range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の例は、<bpt i="4" x="4">&lt;c4&gt;</bpt>numbers<ept i="4">&lt;/c4&gt;</ept>のスライスをインデックス<bpt i="5" x="5">&lt;c5&gt;</bpt>2<ept i="5">&lt;/c5&gt;</ept>で開始して作成して、それからそのスライスを<bpt i="6" x="6">&lt;c6&gt;</bpt>relative(to:)<ept i="6">&lt;/c6&gt;</ept>と使うことで<bpt i="7" x="7">&lt;c7&gt;</bpt>up<bpt i="8" x="8">&lt;w8&gt;</bpt>To<bpt i="9" x="9">&lt;w9&gt;</bpt>Four<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>を具体的な範囲へ変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The non-optional value is wrapped as an optional before the comparison is made.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>非オプショナル値は、比較がなされる前にオプショナル値としてラップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of bits equal to 1 in this value’s binary representation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値のバイナリ表現の中の１に等しいビットの数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of bits in the binary representation of this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値のバイナリ表現でのビット数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of bits to shift <bpt i="0" x="0">&lt;c0&gt;</bpt>lhs<ept i="0">&lt;/c0&gt;</ept> to the left.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このビット数を<bpt i="0" x="0">&lt;c0&gt;</bpt>lhs<ept i="0">&lt;/c0&gt;</ept>から左へとシフトします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of bits to shift <bpt i="0" x="0">&lt;c0&gt;</bpt>lhs<ept i="0">&lt;/c0&gt;</ept> to the right.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このビット数を<bpt i="0" x="0">&lt;c0&gt;</bpt>lhs<ept i="0">&lt;/c0&gt;</ept>から右へとシフトします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of bits used for the underlying binary representation of values of this type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型の値の基礎をなすバイナリ表現に対して使われるビットの数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of bytes from the start of one instance of <bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept> to the start of the next when stored in contiguous memory or in an <bpt i="1" x="1">&lt;c1&gt;</bpt>Array&lt;T&gt;<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept>の１つのインスタンスの始まりから次のものの始まりまでのバイト数、隣接メモリの中にまたは<bpt i="1" x="1">&lt;c1&gt;</bpt>Array&lt;T&gt;<ept i="1">&lt;/c1&gt;</ept>の中に格納される場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of colors that a traffic light uses isn't expected to grow, so it's not declared to be extensible.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>信号機が使う色の数は増大は想定されません、それでそれは拡張可能に宣言されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of elements in the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの中の要素の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of elements in the set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合中の要素の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of elements in this collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このコレクションの要素の数を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of elements to drop from the beginning of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの始まりから省く要素の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of elements to drop from the beginning of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスの初めの部分から落とす要素の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of elements to drop off the end of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの終わりで省く要素の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of elements to drop off the end of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスの末尾から取り除く要素の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of elements to remove from the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションから削除される要素の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of elements to remove.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>削除する要素の数を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of leading zeros in this value’s binary representation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値のバイナリ表現における先頭のゼロの数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of new elements need not match the number of elements being removed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい要素の数は、削除される要素の数と一致する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of scalars in the vector.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ベクターの中のスカラーの数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of scalars, or elements, in a vector of this type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型のあるベクターの中のスカラーそれら、または要素それらの数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of scalars, or elements, in the vector.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ベクターの中のスカラー、または要素、の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of times to repeat the value passed in the <bpt i="0" x="0">&lt;c0&gt;</bpt>repeating<ept i="0">&lt;/c0&gt;</ept> parameter.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>repeating<ept i="0">&lt;/c0&gt;</ept>パラメータで渡された値を繰り返す回数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of trailing zeros in this value’s binary representation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値のバイナリ表現において後に続くゼロの数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The object to encode.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>エンコードするオブジェクト。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The offset in bytes from a pointer to a value of type <bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept> to a pointer to the storage referenced by <bpt i="1" x="1">&lt;c1&gt;</bpt>key<ept i="1">&lt;/c1&gt;</ept>, or <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept> if no such offset is available for the storage referenced by <bpt i="3" x="3">&lt;c3&gt;</bpt>key<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型<bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept>の値へのポインタから、<bpt i="1" x="1">&lt;c1&gt;</bpt>key<ept i="1">&lt;/c1&gt;</ept>によって参照されるストレージへのポインタまでのバイトでのオフセット、または<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>、もしそのようなオフセットが<bpt i="3" x="3">&lt;c3&gt;</bpt>key<ept i="3">&lt;/c3&gt;</ept>によって参照されるストレージに利用可能でないならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The offset is available only if the given key refers to inline, directly addressable storage within the in-memory representation of <bpt i="2" x="2">&lt;c2&gt;</bpt>T<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このオフセットは与えられたキーがインラインの、直接にアドレス指定可能なストレージを<bpt i="2" x="2">&lt;c2&gt;</bpt>T<ept i="2">&lt;/c2&gt;</ept>のインメモリ表現内で参照する場合にのみ利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The operation doesn’t require going beyond the limiting <bpt i="0" x="0">&lt;c0&gt;</bpt>numbers<bpt i="1" x="1">&lt;w1&gt;</bpt>.end<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> value, so it succeeds.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この操作は、限度である<bpt i="0" x="0">&lt;c0&gt;</bpt>numbers<bpt i="1" x="1">&lt;w1&gt;</bpt>.end<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>値を越えることを要求しません、それでそれは成功します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The operation doesn’t require going beyond the limiting <bpt i="0" x="0">&lt;c0&gt;</bpt>s<bpt i="1" x="1">&lt;w1&gt;</bpt>.end<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> value, so it succeeds.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>演算は、限界である<bpt i="0" x="0">&lt;c0&gt;</bpt>s<bpt i="1" x="1">&lt;w1&gt;</bpt>.end<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>値を越えていく必要はありません、それでそれは成功します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The optional publisher never produces errors.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オプショナルパブリッシャーは、決してエラーを生み出しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The order in which <bpt i="0" x="0">&lt;c0&gt;</bpt>A<ept i="0">&lt;/c0&gt;</ept> is printed relative to the other letters isn't guaranteed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>A<ept i="0">&lt;/c0&gt;</ept>が他の文字に関連して印字される順番は、保証されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The order of the key-value pairs is kept intact in the resulting <bpt i="0" x="0">&lt;c0&gt;</bpt>Key<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<bpt i="2" x="2">&lt;w2&gt;</bpt>Pairs<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キー値ペアの順序は、結果の<bpt i="0" x="0">&lt;c0&gt;</bpt>Key<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<bpt i="2" x="2">&lt;w2&gt;</bpt>Pairs<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスにおいて損なわれず保たれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The order of the remaining elements is preserved.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>残っている要素の順番は保全されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The ordering difference happens due to the way the <bpt i="5" x="5">&lt;c5&gt;</bpt>now(_:)<ept i="5">&lt;/c5&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt>later(_:)<ept i="6">&lt;/c6&gt;</ept> functions are defined.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>順番の違いは、<bpt i="5" x="5">&lt;c5&gt;</bpt>now(_:)<ept i="5">&lt;/c5&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt>later(_:)<ept i="6">&lt;/c6&gt;</ept>関数が定義される方法のために起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The other enumeration macros generate structures.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>他の列挙マクロは、構造体を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The output to deliver to each subscriber.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>各加入者に配達することになる出力。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The overflow addition operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;+<ept i="0">&lt;/c0&gt;</ept>) discards any bits that overflow the fixed width of the integer type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オーバーフロー加算演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;+<ept i="0">&lt;/c0&gt;</ept>）は、固定幅の整数型からオーバーフローするあらゆるビットを廃棄します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The overflow multiplication operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;*<ept i="0">&lt;/c0&gt;</ept>) discards any bits that overflow the fixed width of the integer type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オーバーフロー乗算演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;*<ept i="0">&lt;/c0&gt;</ept>）は、固定幅の整数型からオーバーフローするあらゆるビットを廃棄します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The overflow subtraction operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;-<ept i="0">&lt;/c0&gt;</ept>) discards any bits that overflow the fixed width of the integer type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オーバーフロー減算演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;-<ept i="0">&lt;/c0&gt;</ept>）は、固定幅の整数型からオーバーフローするあらゆるビットを廃棄します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The parameter indicates what a developer using Swift should do instead of using the part of the API you're making unavailable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのパラメータは、あなたが利用できなくしているAPIの部分を使う代わりにSwiftを使う開発者がすべきは何かを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The path of coding keys taken to get to this point in decoding.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>デコーディングのこの時点を得るために取られるコーディングキーのパス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The path of coding keys taken to get to this point in encoding.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>エンコーディングのこの時点を得るために取られるコーディングキーのパス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The pattern-matching operator is used internally in <bpt i="1" x="1">&lt;c1&gt;</bpt>case<ept i="1">&lt;/c1&gt;</ept> statements for pattern matching.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>パターンマッチング演算子は、内部的に<bpt i="1" x="1">&lt;c1&gt;</bpt>case<ept i="1">&lt;/c1&gt;</ept>文の中でパターンマッチングのために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The payload for this option should always be <bpt i="0" x="0">&lt;c0&gt;</bpt>{ super<bpt i="1" x="1">&lt;w1&gt;</bpt>.custom<bpt i="2" x="2">&lt;w2&gt;</bpt>Mirror }<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このオプションに対する積荷は、常に<bpt i="0" x="0">&lt;c0&gt;</bpt>{ super<bpt i="1" x="1">&lt;w1&gt;</bpt>.custom<bpt i="2" x="2">&lt;w2&gt;</bpt>Mirror }<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>であるべきです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The performance of accessing <bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> depends on how many elements satisfy the predicate at the start of the collection, and might not offer the usual performance given by the <bpt i="2" x="2">&lt;c2&gt;</bpt>Collection<ept i="2">&lt;/c2&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>にアクセスする性能は、どのくらい多くの要素がこの述部をコレクションの始まりで満たすかに依存します、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>Collection<ept i="2">&lt;/c2&gt;</ept>プロトコルによって与えられる通常の性能を呈さないかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The performance of accessing <bpt i="0" x="0">&lt;c0&gt;</bpt>start<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>first<ept i="2">&lt;/c2&gt;</ept>, any methods that depend on <bpt i="3" x="3">&lt;c3&gt;</bpt>start<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, or of advancing an index depends on how sparsely the filtering predicate is satisfied, and may not offer the usual performance given by <bpt i="5" x="5">&lt;c5&gt;</bpt>Collection<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>start<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>first<ept i="2">&lt;/c2&gt;</ept>、あらゆる<bpt i="3" x="3">&lt;c3&gt;</bpt>start<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>依存のメソッドでのアクセスにおける、またはあるインデックスを進んでいくことにおける性能は、どのくらいフィルタ述部が満たされるのがまばらかに依存します、そして<bpt i="5" x="5">&lt;c5&gt;</bpt>Collection<ept i="5">&lt;/c5&gt;</ept>によって与えられる通常の性能を呈さないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The performance of accessing <bpt i="0" x="0">&lt;c0&gt;</bpt>start<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>first<ept i="2">&lt;/c2&gt;</ept>, or any methods that depend on <bpt i="3" x="3">&lt;c3&gt;</bpt>start<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> depends on how many elements satisfy the predicate at the start of the collection, and may not offer the usual performance given by the <bpt i="5" x="5">&lt;c5&gt;</bpt>Collection<ept i="5">&lt;/c5&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>start<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>first<ept i="2">&lt;/c2&gt;</ept>、または<bpt i="3" x="3">&lt;c3&gt;</bpt>start<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に依存するあらゆるメソッドにアクセスする性能は、どのくらい多くの要素がその述部をコレクションの始まりで満たすかに依存します、そして<bpt i="5" x="5">&lt;c5&gt;</bpt>Collection<ept i="5">&lt;/c5&gt;</ept>プロトコルによって与えられる通常の性能を呈さないかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The pointwise wrapping product of two vectors.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ポイント単位ラップの、２つのベクターの積。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The position after the element to create an index for.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それに対するインデックスを作成する要素の後の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The position after this position in the underlying collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>基盤コレクションでのこの位置の後の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The position at which to insert the new element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そこで新しい要素が挿入されることになる位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The position at which to insert the new elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そこで新しいいくらかの要素が挿入されるところの位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The position of an element in a set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合の中でのある要素の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The position of the element to access.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>アクセスする要素の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The position of the element to remove.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>削除する要素の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The position of the first element in a non-empty collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>空でないコレクションにおける最初の要素の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The position of the first element in a nonempty collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>空でないコレクションの中の最初の要素の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The predicate must be a <bpt i="0" x="0">&lt;e0&gt;</bpt>equivalence relation<ept i="0">&lt;/e0&gt;</ept> over the elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>述部は要素に対して<bpt i="0" x="0">&lt;e0&gt;</bpt>同値関係<ept i="0">&lt;/e0&gt;</ept>でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The predicate must be a <bpt i="0" x="0">&lt;e0&gt;</bpt>strict weak ordering<ept i="0">&lt;/e0&gt;</ept> over the elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>述部は、それら要素に対して<bpt i="0" x="0">&lt;e0&gt;</bpt>厳密弱順序<ept i="0">&lt;/e0&gt;</ept>でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The predicate orders errors before successes and sorts the error responses by their error code.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この述部はエラーを成功の前に並べて、そしてそれらエラー応答をそのエラーコードによってソートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The preferred display style for the mirror when presented in the debugger or in a playground.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>デバッガにまたはプレイグラウンドに含まれる時のミラーのための優先表示形式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The presence of a value, stored as <bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値の存在、<bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept>として格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The product of <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept> is 2000, which is too large to represent in a <bpt i="2" x="2">&lt;c2&gt;</bpt>UInt8<ept i="2">&lt;/c2&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept>の積は2000です、それは<bpt i="2" x="2">&lt;c2&gt;</bpt>UInt8<ept i="2">&lt;/c2&gt;</ept>インスタンスにおいて表すには大きすぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The product of <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>-1920<ept i="2">&lt;/c2&gt;</ept>, which is too large to represent in an <bpt i="3" x="3">&lt;c3&gt;</bpt>Int8<ept i="3">&lt;/c3&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept>の積は<bpt i="2" x="2">&lt;c2&gt;</bpt>-1920<ept i="2">&lt;/c2&gt;</ept>です、それは<bpt i="3" x="3">&lt;c3&gt;</bpt>Int8<ept i="3">&lt;/c3&gt;</ept>インスタンスにおいて表すには大きすぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The product of the two arguments must be representable in the arguments’ type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの引数の積は、引数の持つ型において表現可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The property defined by the new declaration is easier to use in Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい宣言によって宣言されるこのプロパティは、Swiftで使うのがより簡単です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The radix, or base, to use for converting <bpt i="0" x="0">&lt;c0&gt;</bpt>text<ept i="0">&lt;/c0&gt;</ept> to an integer value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>text<ept i="0">&lt;/c0&gt;</ept>を整数値に変換するのに使うための基数、または底。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The random number generator to use when choosing a random element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある無作為な要素を選ぶときに使う無作為数生成子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The random number generator to use when creating the new random value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい無作為値を作成するときに使う無作為数生成子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The random number generator to use when shuffling the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションをシャッフルするときに使う無作為数生成子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The random number generator to use when shuffling the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスをシャッフルするときに使う無作為数生成子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The range expression is converted to a concrete subrange relative to this collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲式は、このコレクションに関連するある具体的な下位範囲へ変換されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The range in which to create a random value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その中においてある無作為な値が作成される範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The range of the collection to be removed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>削除されることになるコレクションの範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The range to clamp the bounds of this range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この範囲に制限を課すための範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The range’s lower bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その範囲の下方の境界。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The range’s upper bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その範囲の上方の境界。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The raw type that can be used to represent all values of the conforming type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>準拠している型のすべての値を表すために使われる生の型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The raw value must therefore be of a type that conforms to the <bpt i="4" x="4">&lt;c4&gt;</bpt>Fixed<bpt i="5" x="5">&lt;w5&gt;</bpt>Width<bpt i="6" x="6">&lt;w6&gt;</bpt>Integer<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> protocol, such as <bpt i="7" x="7">&lt;c7&gt;</bpt>UInt8<ept i="7">&lt;/c7&gt;</ept> or <bpt i="8" x="8">&lt;c8&gt;</bpt>Int<ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>生の値はしたがって、<bpt i="4" x="4">&lt;c4&gt;</bpt>Fixed<bpt i="5" x="5">&lt;w5&gt;</bpt>Width<bpt i="6" x="6">&lt;w6&gt;</bpt>Integer<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>プロトコルに準拠する型、例えば<bpt i="7" x="7">&lt;c7&gt;</bpt>UInt8<ept i="7">&lt;/c7&gt;</ept>または<bpt i="8" x="8">&lt;c8&gt;</bpt>Int<ept i="8">&lt;/c8&gt;</ept>などのものでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The raw value of the <bpt i="1" x="1">&lt;c1&gt;</bpt>allowed<bpt i="2" x="2">&lt;w2&gt;</bpt>Moves<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> instance is the result of the bitwise OR of its three members’ raw values:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>allowed<bpt i="2" x="2">&lt;w2&gt;</bpt>Moves<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>インスタンスの生の値は、それの３つのメンバの持つ生の値のビット単位ORの結果です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The raw value of the option set to create.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>作成されるオプションセットの生の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The raw value to use for the new instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいインスタンスのために使う生の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The remainder of the relational operator functions are implemented by the standard library for any type that conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>残りの関係演算子関数は、<bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>に準拠するあらゆる型に対して標準ライブラリによって実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The removed element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>削除された要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The representation to use for ancestor classes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>先祖クラスに対して使う表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The requested number of elements to store.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>依頼された格納される要素数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The result begins with the first element of <bpt i="2" x="2">&lt;c2&gt;</bpt>numbers<ept i="2">&lt;/c2&gt;</ept> that does not satisfy <bpt i="3" x="3">&lt;c3&gt;</bpt>predicate<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果は、<bpt i="2" x="2">&lt;c2&gt;</bpt>predicate<ept i="2">&lt;/c2&gt;</ept>を満たさない、<bpt i="3" x="3">&lt;c3&gt;</bpt>numbers<ept i="3">&lt;/c3&gt;</ept>の最初の要素で始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The result can be negative only if the collection conforms to the <bpt i="2" x="2">&lt;c2&gt;</bpt>Bidirectional<bpt i="3" x="3">&lt;w3&gt;</bpt>Collection<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果は、そのコレクションが<bpt i="2" x="2">&lt;c2&gt;</bpt>Bidirectional<bpt i="3" x="3">&lt;w3&gt;</bpt>Collection<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルに準拠する場合に限り、負であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The result does not include any dynamically allocated or out of line storage.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果は、あらゆる動的にアロケートされるおよびアウトオブラインのストレージを含みません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The result has the same sign as <bpt i="0" x="0">&lt;c0&gt;</bpt>lhs<ept i="0">&lt;/c0&gt;</ept> and has a magnitude less than <bpt i="1" x="1">&lt;c1&gt;</bpt>rhs<bpt i="2" x="2">&lt;w2&gt;</bpt>.magnitude<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果は、<bpt i="0" x="0">&lt;c0&gt;</bpt>lhs<ept i="0">&lt;/c0&gt;</ept>と同じ符号を持ち、<bpt i="1" x="1">&lt;c1&gt;</bpt>rhs<bpt i="2" x="2">&lt;w2&gt;</bpt>.magnitude<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>より小さい規模を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The result is <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> if <bpt i="1" x="1">&lt;c1&gt;</bpt>from<ept i="1">&lt;/c1&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果は、<bpt i="1" x="1">&lt;c1&gt;</bpt>from<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>ならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The result is always positive.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果は常に正です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The result of the given closure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたクロージャの結果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The result of the remainder operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>%<ept i="0">&lt;/c0&gt;</ept>) has the same sign as <bpt i="1" x="1">&lt;c1&gt;</bpt>lhs<ept i="1">&lt;/c1&gt;</ept> and has a magnitude less than <bpt i="2" x="2">&lt;c2&gt;</bpt>rhs<bpt i="3" x="3">&lt;w3&gt;</bpt>.magnitude<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>剰余演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>%<ept i="0">&lt;/c0&gt;</ept>）の結果は、<bpt i="1" x="1">&lt;c1&gt;</bpt>lhs<ept i="1">&lt;/c1&gt;</ept>と同じ符号を持ち、<bpt i="2" x="2">&lt;c2&gt;</bpt>rhs<bpt i="3" x="3">&lt;w3&gt;</bpt>.magnitude<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>より小さい規模を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The result to deliver to each subscriber.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>各加入者に配達する結果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The resulting <bpt i="3" x="3">&lt;c3&gt;</bpt>Lazy<bpt i="4" x="4">&lt;w4&gt;</bpt>Scan<bpt i="5" x="5">&lt;w5&gt;</bpt>Sequence<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is itself lazy, too, so further sequence operations also defer computation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果の<bpt i="3" x="3">&lt;c3&gt;</bpt>Lazy<bpt i="4" x="4">&lt;w4&gt;</bpt>Scan<bpt i="5" x="5">&lt;w5&gt;</bpt>Sequence<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>はそれ自体また遅延です、なのでその先のシーケンス演算もまた計算を延期します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The resulting array consists of at most <bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Splits + 1<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> subsequences.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果の配列は、多くとも<bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Splits + 1<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の下位シーケンスから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The resulting collection has the type of argument on the right-hand side.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果となるコレクションは、右手側の引数の型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The resulting collection has the type of the argument on the left-hand side.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果となるコレクションは、左手側の引数の型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The resulting flattened array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果として生じる平たくされた配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The resulting instance may not have the same numeric value as <bpt i="0" x="0">&lt;c0&gt;</bpt>bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Pattern<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>—it is only guaranteed to use the same pattern of bits in its binary representation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果のインスタンスは、<bpt i="0" x="0">&lt;c0&gt;</bpt>bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Pattern<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と同じ数値を持たないかもしれません — それは、同じパターンのビットをそれのバイナリ表現において使うことを保証されるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The resulting quotient must be representable within the bounds of the type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果の商は、この型の境界の内に表現可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The resulting subsequence <bpt i="0" x="0">&lt;e0&gt;</bpt>does not include<ept i="0">&lt;/e0&gt;</ept> the element at the position <bpt i="1" x="1">&lt;c1&gt;</bpt>end<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果となるシーケンスは、位置<bpt i="1" x="1">&lt;c1&gt;</bpt>end<ept i="1">&lt;/c1&gt;</ept>での要素を<bpt i="0" x="0">&lt;e0&gt;</bpt>含みません<ept i="0">&lt;/e0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The resulting subsequence <bpt i="0" x="0">&lt;e0&gt;</bpt>includes<ept i="0">&lt;/e0&gt;</ept> the element at the position <bpt i="1" x="1">&lt;c1&gt;</bpt>end<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果となるシーケンスは、位置<bpt i="1" x="1">&lt;c1&gt;</bpt>end<ept i="1">&lt;/c1&gt;</ept>での要素を<bpt i="0" x="0">&lt;e0&gt;</bpt>含みます<ept i="0">&lt;/e0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The resulting value must be representable in the same type as the argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果の値は、引数と同じ型で表現可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The resulting value must be representable within the value’s type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果の値は、その値の持つ型の内部に表現可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The return type of functions that do not return normally, that is, a type with no values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>普通に戻らない関数の戻り型、すなわち、値なしでの型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The return types of the two methods are annotated as <bpt i="2" x="2">&lt;c2&gt;</bpt>nullable<ept i="2">&lt;/c2&gt;</ept>, because the methods return <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept> if the list doesn't contain the given list item or name.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つのメソッドの戻り型は<bpt i="2" x="2">&lt;c2&gt;</bpt>nullable<ept i="2">&lt;/c2&gt;</ept>として注釈を付けられます、なぜならこれらメソッドは<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>を、そのリストが与えられたリスト項目または名前を含まないならば返すからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The returned range is <bpt i="1" x="1">&lt;e1&gt;</bpt>not<ept i="1">&lt;/e1&gt;</ept> guaranteed to be inside the bounds of <bpt i="2" x="2">&lt;c2&gt;</bpt>collection<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>返される範囲は、<bpt i="2" x="2">&lt;c2&gt;</bpt>collection<ept i="2">&lt;/c2&gt;</ept>の境界内であると保証され<bpt i="1" x="1">&lt;e1&gt;</bpt>ません<ept i="1">&lt;/e1&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The round rule to use when converting elements of <bpt i="0" x="0">&lt;c0&gt;</bpt>other.<ept i="0">&lt;/c0&gt;</ept> The default is <bpt i="1" x="1">&lt;c1&gt;</bpt>.toward<bpt i="2" x="2">&lt;w2&gt;</bpt>Zero<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>の要素を変換する時に使う丸め規則。省略時は<bpt i="1" x="1">&lt;c1&gt;</bpt>.toward<bpt i="2" x="2">&lt;w2&gt;</bpt>Zero<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The second element of the vector.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ベクターの２番目の要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The second example passes <bpt i="0" x="0">&lt;c0&gt;</bpt>1<ept i="0">&lt;/c0&gt;</ept> for the <bpt i="1" x="1">&lt;c1&gt;</bpt>max<bpt i="2" x="2">&lt;w2&gt;</bpt>Splits<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> parameter, so the original string is split just once, into two new strings.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２番目の例は<bpt i="0" x="0">&lt;c0&gt;</bpt>1<ept i="0">&lt;/c0&gt;</ept>を<bpt i="1" x="1">&lt;c1&gt;</bpt>max<bpt i="2" x="2">&lt;w2&gt;</bpt>Splits<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>パラメータに渡します、それで元の文字列は一度だけ分割されて、２つの新しい文字列になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The second partition, <bpt i="2" x="2">&lt;c2&gt;</bpt>numbers[p...]<ept i="2">&lt;/c2&gt;</ept>, is made up of the elements that <bpt i="3" x="3">&lt;e3&gt;</bpt>are<ept i="3">&lt;/e3&gt;</ept> greater than 30.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２番目の区画、<bpt i="2" x="2">&lt;c2&gt;</bpt>numbers[p...]<ept i="2">&lt;/c2&gt;</ept>は、30より大きなもの<bpt i="3" x="3">&lt;e3&gt;</bpt>である<ept i="3">&lt;/e3&gt;</ept>要素から構成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The second value to add.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>加算する第２の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The second value to multiply.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>掛け合わされる第２の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The sequence must be finite.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスは有限でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The sequence of elements for the new collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいコレクションのための要素からなるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The sequence’s iterator is used directly to retrieve the initial value before looping over the rest of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスのもつイテレータが直に使われて、残りのシーケンスにループする前に初期値をとってきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The sequence’s maximum element if the sequence is not empty; otherwise, <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスが空でないならばシーケンスの最大の要素；そうでなければ<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The sequence’s maximum element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスの最大の要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The sequence’s minimum element, according to <bpt i="0" x="0">&lt;c0&gt;</bpt>are<bpt i="1" x="1">&lt;w1&gt;</bpt>In<bpt i="2" x="2">&lt;w2&gt;</bpt>Increasing<bpt i="3" x="3">&lt;w3&gt;</bpt>Order<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスの最小の要素、<bpt i="0" x="0">&lt;c0&gt;</bpt>are<bpt i="1" x="1">&lt;w1&gt;</bpt>In<bpt i="2" x="2">&lt;w2&gt;</bpt>Increasing<bpt i="3" x="3">&lt;w3&gt;</bpt>Order<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>による。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The sequence’s minimum element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスの最小の要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The set must not be empty.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合は空であってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The shared actor instance that will be used to provide mutually-exclusive access to declarations annotated with the given global actor type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>共有アクターインスタンス、それは与えられたグローバルアクター型で注釈を付けられた宣言への相互排他アクセスを提供するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The shared executor instance that will be used to provide mutually-exclusive access for the global actor.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>共有エグゼキュータ（遂行者）インスタンス、それはグローバルアクターに対する相互排他アクセスを提供するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The shift is performed using this masked value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シフトは、このマスクされた値を使って実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The shortened form is preferred for ease of reading and writing code.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この短縮された形式は、コードの読み書きの容易さのためにより好ましいものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The sign of this number, expressed as an integer of the same type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この数の符号、同じ型の整数として表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The size, in bytes, of the given value’s type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた値の持つ型の、バイトでの、大きさ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The size, stride, and alignment of the <bpt i="0" x="0">&lt;c0&gt;</bpt>Point<ept i="0">&lt;/c0&gt;</ept> type are accessible as static properties of <bpt i="1" x="1">&lt;c1&gt;</bpt>Memory<bpt i="2" x="2">&lt;w2&gt;</bpt>Layout&lt;Point&gt;<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Point<ept i="0">&lt;/c0&gt;</ept>型のサイズ、ストライド、そしてアライメントは、<bpt i="1" x="1">&lt;c1&gt;</bpt>Memory<bpt i="2" x="2">&lt;w2&gt;</bpt>Layout&lt;Point&gt;<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の静的プロパティとしてアクセス可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The sorting algorithm is not guaranteed to be stable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このソートアルゴリズムは、安定であることを保証されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The stable identity of the entity associated with this instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このインスタンスと結び付けられた登録項目の安定した同一性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The starting position for iterating members of the set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合のメンバを反復するための開始位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The static members <bpt i="7" x="7">&lt;c7&gt;</bpt>next<bpt i="8" x="8">&lt;w8&gt;</bpt>Day<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>, <bpt i="9" x="9">&lt;c9&gt;</bpt>second<bpt i="10" x="10">&lt;w10&gt;</bpt>Day<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>, <bpt i="11" x="11">&lt;c11&gt;</bpt>priority<ept i="11">&lt;/c11&gt;</ept>, and <bpt i="12" x="12">&lt;c12&gt;</bpt>standard<ept i="12">&lt;/c12&gt;</ept> are unique, individual options.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>静的メンバ<bpt i="7" x="7">&lt;c7&gt;</bpt>next<bpt i="8" x="8">&lt;w8&gt;</bpt>Day<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>, <bpt i="9" x="9">&lt;c9&gt;</bpt>second<bpt i="10" x="10">&lt;w10&gt;</bpt>Day<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>、<bpt i="11" x="11">&lt;c11&gt;</bpt>priority<ept i="11">&lt;/c11&gt;</ept>、そして<bpt i="12" x="12">&lt;c12&gt;</bpt>standard<ept i="12">&lt;/c12&gt;</ept>は特有で、別個のオプションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The static type of the subject being reflected.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>リフレクションされている主題の静的型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The stored <bpt i="0" x="0">&lt;c0&gt;</bpt>Header<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>格納された<bpt i="0" x="0">&lt;c0&gt;</bpt>Header<ept i="0">&lt;/c0&gt;</ept>インスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The stride, in bytes, of the given value’s type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた値の持つ型の、バイトでの、ストライド。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The string passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>description<ept i="0">&lt;/c0&gt;</ept> may begin with a plus or minus sign character (<bpt i="1" x="1">&lt;c1&gt;</bpt>+<ept i="1">&lt;/c1&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt>-<ept i="2">&lt;/c2&gt;</ept>), followed by one or more numeric digits (<bpt i="3" x="3">&lt;c3&gt;</bpt>0-9<ept i="3">&lt;/c3&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>description<ept i="0">&lt;/c0&gt;</ept>として渡される文字列は、プラスまたはマイナス符号文字（<bpt i="1" x="1">&lt;c1&gt;</bpt>+<ept i="1">&lt;/c1&gt;</ept>または<bpt i="2" x="2">&lt;c2&gt;</bpt>-<ept i="2">&lt;/c2&gt;</ept>）で始まり、１つ以上の数値のアラビア数字（<bpt i="3" x="3">&lt;c3&gt;</bpt>0-9<ept i="3">&lt;/c3&gt;</ept>）が続くことがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The string passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>text<ept i="0">&lt;/c0&gt;</ept> may begin with a plus or minus sign character (<bpt i="1" x="1">&lt;c1&gt;</bpt>+<ept i="1">&lt;/c1&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt>-<ept i="2">&lt;/c2&gt;</ept>), followed by one or more numeric digits (<bpt i="3" x="3">&lt;c3&gt;</bpt>0-9<ept i="3">&lt;/c3&gt;</ept>) or letters (<bpt i="4" x="4">&lt;c4&gt;</bpt>a-z<ept i="4">&lt;/c4&gt;</ept> or <bpt i="5" x="5">&lt;c5&gt;</bpt>A-Z<ept i="5">&lt;/c5&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>text<ept i="0">&lt;/c0&gt;</ept>として渡される文字列は、プラスまたはマイナス符号文字（<bpt i="1" x="1">&lt;c1&gt;</bpt>+<ept i="1">&lt;/c1&gt;</ept>または<bpt i="2" x="2">&lt;c2&gt;</bpt>-<ept i="2">&lt;/c2&gt;</ept>）で始まり、１つ以上の数値のアラビア数字（<bpt i="3" x="3">&lt;c3&gt;</bpt>0-9<ept i="3">&lt;/c3&gt;</ept>）または文字（<bpt i="4" x="4">&lt;c4&gt;</bpt>a-z<ept i="4">&lt;/c4&gt;</ept> or <bpt i="5" x="5">&lt;c5&gt;</bpt>A-Z<ept i="5">&lt;/c5&gt;</ept>）が続くことがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The structure to use for the mirror.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ミラーのために使う構造体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The subrange of the collection to remove.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>削除することになるコレクションの下位範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The subrange of the collection to replace.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>置き換えることになるコレクションの下位範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The subscriber to add.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>加えることになる加入者。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The subscriber to attach to this Publisher, after which it can receive values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このPublisherに添付することになる加入者、それの後にそれは値を受け取ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The subscript notation is preferred over <bpt i="1" x="1">&lt;c1&gt;</bpt>prefix(through:)<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>添え字表記法は、<bpt i="1" x="1">&lt;c1&gt;</bpt>prefix(through:)<ept i="1">&lt;/c1&gt;</ept>よりも好まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The subscript notation is preferred over <bpt i="1" x="1">&lt;c1&gt;</bpt>suffix(from:)<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>添え字表記法は、<bpt i="1" x="1">&lt;c1&gt;</bpt>suffix(from:)<ept i="1">&lt;/c1&gt;</ept>よりも好まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The subscript notation is preferred over <bpt i="2" x="2">&lt;c2&gt;</bpt>prefix(up<bpt i="3" x="3">&lt;w3&gt;</bpt>To:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>添え字表記法は、<bpt i="2" x="2">&lt;c2&gt;</bpt>prefix(up<bpt i="3" x="3">&lt;w3&gt;</bpt>To:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>よりも好まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The subtraction operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>-<ept i="0">&lt;/c0&gt;</ept>) calculates the difference of its two arguments.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>減算演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>-<ept i="0">&lt;/c0&gt;</ept>）は、それの２つの引数の差を計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The success value, if the instance represents a success.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>成功値、もしインスタンスが成功を表すならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The successor of an index must be well defined.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるインデックスの後に続くものは、よく定義されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The sum of the scalars in the vector.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ベクターの中のスカラーそれらの合計。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The sum of the two arguments must be representable in the arguments’ type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの引数の合計は、引数の持つ型において表現可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The sum of types that can be used as a Quick Look representation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>「クイックルック」表現として使われることのできる型の総和。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The system’s default source of random data.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>システムの持つ省略時の無作為データのソース。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The third element of the vector.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ベクターの３番目の要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The three cases of <bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>Comparison<bpt i="5" x="5">&lt;w5&gt;</bpt>Result<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>—<bpt i="6" x="6">&lt;a6&gt;</bpt><bpt i="7" x="7">&lt;c7&gt;</bpt>Comparison<bpt i="8" x="8">&lt;w8&gt;</bpt>Result<bpt i="9" x="9">&lt;w9&gt;</bpt>.ordered<bpt i="10" x="10">&lt;w10&gt;</bpt>Ascending<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept><ept i="6">&lt;/a6&gt;</ept>, <bpt i="11" x="11">&lt;a11&gt;</bpt><bpt i="12" x="12">&lt;c12&gt;</bpt>Comparison<bpt i="13" x="13">&lt;w13&gt;</bpt>Result<bpt i="14" x="14">&lt;w14&gt;</bpt>.ordered<bpt i="15" x="15">&lt;w15&gt;</bpt>Same<ept i="15">&lt;/w15&gt;</ept><ept i="14">&lt;/w14&gt;</ept><ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/c12&gt;</ept><ept i="11">&lt;/a11&gt;</ept>, and <bpt i="16" x="16">&lt;a16&gt;</bpt><bpt i="17" x="17">&lt;c17&gt;</bpt>Comparison<bpt i="18" x="18">&lt;w18&gt;</bpt>Result<bpt i="19" x="19">&lt;w19&gt;</bpt>.ordered<bpt i="20" x="20">&lt;w20&gt;</bpt>Descending<ept i="20">&lt;/w20&gt;</ept><ept i="19">&lt;/w19&gt;</ept><ept i="18">&lt;/w18&gt;</ept><ept i="17">&lt;/c17&gt;</ept><ept i="16">&lt;/a16&gt;</ept>—are an example of a finite set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>Comparison<bpt i="5" x="5">&lt;w5&gt;</bpt>Result<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>の３つのケース節 —<bpt i="6" x="6">&lt;a6&gt;</bpt><bpt i="7" x="7">&lt;c7&gt;</bpt>Comparison<bpt i="8" x="8">&lt;w8&gt;</bpt>Result<bpt i="9" x="9">&lt;w9&gt;</bpt>.ordered<bpt i="10" x="10">&lt;w10&gt;</bpt>Ascending<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept><ept i="6">&lt;/a6&gt;</ept>、<bpt i="11" x="11">&lt;a11&gt;</bpt><bpt i="12" x="12">&lt;c12&gt;</bpt>Comparison<bpt i="13" x="13">&lt;w13&gt;</bpt>Result<bpt i="14" x="14">&lt;w14&gt;</bpt>.ordered<bpt i="15" x="15">&lt;w15&gt;</bpt>Same<ept i="15">&lt;/w15&gt;</ept><ept i="14">&lt;/w14&gt;</ept><ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/c12&gt;</ept><ept i="11">&lt;/a11&gt;</ept>、そして<bpt i="16" x="16">&lt;a16&gt;</bpt><bpt i="17" x="17">&lt;c17&gt;</bpt>Comparison<bpt i="18" x="18">&lt;w18&gt;</bpt>Result<bpt i="19" x="19">&lt;w19&gt;</bpt>.ordered<bpt i="20" x="20">&lt;w20&gt;</bpt>Descending<ept i="20">&lt;/w20&gt;</ept><ept i="19">&lt;/w19&gt;</ept><ept i="18">&lt;/w18&gt;</ept><ept i="17">&lt;/c17&gt;</ept><ept i="16">&lt;/a16&gt;</ept>— はある有限な集合の一例です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The three states are captured by different combinations of the two variables.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>３つの状態は、２つの変数の異なる組み合わせによって捕えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The total number of elements that the set can contain without allocating new storage.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その集合が新しいストレージを割り当てることなく含むことができる要素の総数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The two arguments must have the same <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの引数は、同じ<bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>型を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The two loops in the following example produce the same output:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例における２つのループは、同じ出力を生み出します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The two variables have an unused combination—it’s possible to set the <bpt i="0" x="0">&lt;c0&gt;</bpt>user<ept i="0">&lt;/c0&gt;</ept> to <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>session<bpt i="3" x="3">&lt;w3&gt;</bpt>Expired<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> to <bpt i="4" x="4">&lt;c4&gt;</bpt>true<ept i="4">&lt;/c4&gt;</ept>, even though that doesn’t have a corresponding state.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの変数は使われない組み合わせを持ちます — <bpt i="0" x="0">&lt;c0&gt;</bpt>user<ept i="0">&lt;/c0&gt;</ept>を<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>にそして<bpt i="2" x="2">&lt;c2&gt;</bpt>session<bpt i="3" x="3">&lt;w3&gt;</bpt>Expired<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を<bpt i="4" x="4">&lt;c4&gt;</bpt>true<ept i="4">&lt;/c4&gt;</ept>に設定することは可能です、たとえそれが対応する状態を持たないとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The type for which the expression describes a range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それに対してこの式が範囲を記述する型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The type of a Combine publisher that publishes the value of a Swift optional instance to each subscriber exactly once, if the instance has any value at all.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるCombineパブリッシャーの型、それはあるSwiftオプショナルインスタンスの値を各加入者に正確に一度だけ発行するものです、とにかくそのインスタンスが値を何らかの持つならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The type of a Combine publisher that publishes this instance’s result to each subscriber exactly once, or fails immediately if the result indicates failure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるCombineパブリッシャーの型、それはこのインスタンスのもつ結果を各加入者に正確に一度だけ発行する、または結果が不成功を指し示すならば直ぐに失敗するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The type of element traversed by the iterator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイテレータによって辿っていかれる要素の型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The type of scalars in the vector space.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このベクタースペースの中のスカラーそれらの型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The type of the elements of an array literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列リテラルの要素の型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The type of the shared actor instance that will be used to provide mutually-exclusive access to declarations annotated with the given global actor type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>共有アクターインスタンスの型、それは与えられたグローバルアクター型で注釈を付けられた宣言への相互排他アクセスを提供するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The type of value to decode.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型の値にデコードする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The type used to represent substructure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下位構造体を表すために使われる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The types of <bpt i="0" x="0">&lt;c0&gt;</bpt>short<bpt i="1" x="1">&lt;w1&gt;</bpt>Form<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>long<bpt i="3" x="3">&lt;w3&gt;</bpt>Form<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> in the following code sample are the same:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下のコード例における<bpt i="0" x="0">&lt;c0&gt;</bpt>short<bpt i="1" x="1">&lt;w1&gt;</bpt>Form<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>long<bpt i="3" x="3">&lt;w3&gt;</bpt>Form<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の型は、同じです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The underlying iterator whose elements are being filtered.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>基礎をなすイテレータ、それの要素がフィルタされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The underlying iterator’s sequence may be infinite.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>基礎をなすイテレータのもつシーケンスは、無限であるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The underlying type a 64-bit integer uses when it wraps itself in a data value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>64ビット整数が、それがそれ自身をあるデータ値の中にラップする時に使う、基礎をなす型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The upper and lower bounds of the <bpt i="0" x="0">&lt;c0&gt;</bpt>bounds<ept i="0">&lt;/c0&gt;</ept> range must be valid indices of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>bounds<ept i="0">&lt;/c0&gt;</ept>範囲の上方および下方の境界は、このコレクションの有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The upper bound for the randomly generated value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この無作為に生成される値に対する上方の境界。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The upper bound for the range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲の上側の境界。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The valid indices for subscripting the vector.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ベクターに添え字での指定をするための有効なインデックスそれら。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value associated with <bpt i="0" x="0">&lt;c0&gt;</bpt>key<ept i="0">&lt;/c0&gt;</ept> may be a null value as appropriate for the data format.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>key<ept i="0">&lt;/c0&gt;</ept>と結び付けられる値は、null値かもしれません、データ形式として適切であるので。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value associated with the given key may be a null value as appropriate for the data format.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたキーと結び付けられる値は、そのデータ形式に適切であるnull値であるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value of <bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Length<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be greater than or equal to zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Length<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の値は、ゼロより大きいか等しくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value of every element in this collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このコレクションのすべての要素の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value of the <bpt i="0" x="0">&lt;c0&gt;</bpt>member<ept i="0">&lt;/c0&gt;</ept> parameter if it was a member of the set; otherwise, <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>member<ept i="0">&lt;/c0&gt;</ept>パラメータの値、それが集合のメンバであったならば；そうでなければ、<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value of this property must always evaluate to the same actor instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このプロパティの値は、同じアクターインスタンスと常に等しくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value of this property must be equivalent to <bpt i="0" x="0">&lt;c0&gt;</bpt>shared<bpt i="1" x="1">&lt;w1&gt;</bpt>.unowned<bpt i="2" x="2">&lt;w2&gt;</bpt>Executor<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このプロパティの値は、<bpt i="0" x="0">&lt;c0&gt;</bpt>shared<bpt i="1" x="1">&lt;w1&gt;</bpt>.unowned<bpt i="2" x="2">&lt;w2&gt;</bpt>Executor<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と等しくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>distance<ept i="0">&lt;/c0&gt;</ept> must not offset <bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept> beyond the bounds of the collection, unless the index passed as <bpt i="2" x="2">&lt;c2&gt;</bpt>limit<ept i="2">&lt;/c2&gt;</ept> prevents offsetting beyond those bounds.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>distance<ept i="0">&lt;/c0&gt;</ept>として渡される値は、このコレクションの境界を越えて<bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept>を補ってはなりません、<bpt i="2" x="2">&lt;c2&gt;</bpt>limit<ept i="2">&lt;/c2&gt;</ept>として渡されるインデックスがそれら境界を越えて補うのを防止するのでない限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>distance<ept i="0">&lt;/c0&gt;</ept> must not offset <bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept> beyond the bounds of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>distance<ept i="0">&lt;/c0&gt;</ept>として渡される値は、このコレクションの境界を越えて<bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept>を補ってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>source<ept i="0">&lt;/c0&gt;</ept> must be representable in this type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>source<ept i="0">&lt;/c0&gt;</ept>として渡される値は、この型において表現可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to add to this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値に加える値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to calculate the distance to.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それへの隔たりを計算される値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to create.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>作成されることになる値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to divide <bpt i="0" x="0">&lt;c0&gt;</bpt>lhs<ept i="0">&lt;/c0&gt;</ept> by.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値で<bpt i="0" x="0">&lt;c0&gt;</bpt>lhs<ept i="0">&lt;/c0&gt;</ept>を除算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to divide this value by.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値を除算するための値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to divide.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>除算することになる値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to encode.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>エンコードする値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to multiply by this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値と掛け合わせられることになる値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to multiply this value by.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値に掛ける値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to shift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シフトする値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to subtract from <bpt i="0" x="0">&lt;c0&gt;</bpt>lhs<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>lhs<ept i="0">&lt;/c0&gt;</ept>から減じる値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to subtract from this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値から減じる値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to test.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>テストする値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to use as the initial accumulating value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最初から蓄積されている値として使われる値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The vector to convert.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>変換するベクター。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The wrapped value of this instance, unwrapped without checking whether the instance is <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インスタンスのラップされた値、そのインスタンスが<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>かどうか確認せずにアンラップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The wrapping difference of two vectors.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ラップしている、２つのベクターの差。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The wrapping sum of two vectors.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ラップしている、２つのベクターの和。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The zero value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ゼロ値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The “past the end” index of the resulting subsequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果のシーケンスの「終わりを過ぎた」インデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The “past the end” position for the set—that is, the position one greater than the last valid subscript argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合に対する「終わりを過ぎた」位置—すなわち、最後の有効な添え字引数より１つ大きい位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>There is no notion of identity for structs, enums, functions, or tuples.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>構造体、列挙、関数、またはタプルに対して識別の観念はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>There's no guarantee that the random guess will be correct, so important actions like paying bills—scheduled for after you win the lottery—might never happen.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ランダムな推測が正しくなる保証はありません、それで請求書を払うような — あなたが宝くじに当たった後に予定される — 重要な行為は決して起こらないかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Therefore, <bpt i="7" x="7">&lt;c7&gt;</bpt>options<ept i="7">&lt;/c7&gt;</ept> is emptied and the intersection between <bpt i="8" x="8">&lt;c8&gt;</bpt>.express<ept i="8">&lt;/c8&gt;</ept> and <bpt i="9" x="9">&lt;c9&gt;</bpt>options<ept i="9">&lt;/c9&gt;</ept> is returned.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>したがって、<bpt i="7" x="7">&lt;c7&gt;</bpt>options<ept i="7">&lt;/c7&gt;</ept>は空にされて<bpt i="8" x="8">&lt;c8&gt;</bpt>.express<ept i="8">&lt;/c8&gt;</ept>と<bpt i="9" x="9">&lt;c9&gt;</bpt>options<ept i="9">&lt;/c9&gt;</ept>の間の交叉が返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Therefore, the class you migrate can't have any Objective-C subclasses.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>したがって、あなたが移行するクラスは、いかなるObjective-Cサブクラスも持つことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Therefore, the fundamental difference between random-access and bidirectional collections is that operations that depend on index movement or distance measurement offer significantly improved efficiency.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それゆえに、無作為アクセスと二方向性のコレクションの根本的な違いは、インデックス移動や間隔測定に依存する演算が、著しく改善される効率を提示することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These accesses may be merged, eliminated, and rearranged with other work, and they may even be introduced when not strictly required.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これらのアクセスは、他の仕事によって合併、排除、そして再配列されるかもしれません、そしてそれらは厳密には必要とされない時に始められさえするかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as <bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Contiguous<bpt i="2" x="2">&lt;w2&gt;</bpt>Array<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これらのカウンタはインデックスとして使われることが、ゼロ基盤の、整数インデックスでのコレクション、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept>そして<bpt i="1" x="1">&lt;c1&gt;</bpt>Contiguous<bpt i="2" x="2">&lt;w2&gt;</bpt>Array<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>などのインスタンスにおいてのみ可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These elements are computed lazily, each time they’re read, by calling the transform function on a base element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これらの要素は、それらが読み出されるたびに、基盤要素上で変換関数を呼び出すことによって遅延計算されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These initializer overloads are available for any conforming type with a <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> that is a <bpt i="2" x="2">&lt;c2&gt;</bpt>Decodable<ept i="2">&lt;/c2&gt;</ept> standard library type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これらのイニシャライザオーバーロードは、<bpt i="2" x="2">&lt;c2&gt;</bpt>Decodable<ept i="2">&lt;/c2&gt;</ept>標準ライブラリ型である<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を持つどんな準拠する型でも利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These overloads are available for any conforming type with a <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> that is an <bpt i="2" x="2">&lt;c2&gt;</bpt>Encodable<ept i="2">&lt;/c2&gt;</ept> standard library type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これらのイニシャライザオーバーロードは、<bpt i="2" x="2">&lt;c2&gt;</bpt>Encodable<ept i="2">&lt;/c2&gt;</ept>標準ライブラリ型である<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を持つどんな準拠する型でも利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These pointers are valid only for the duration of the call to <bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これらのポインタは、ただ<bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept>への呼び出しの間にのみ有効とされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>They may be called once, many times, or never.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それらが呼び出されるのは、一度だけ、何度も、または決してないかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>They're the only logical cases for performing an ordered comparison during tasks like sorting.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それらは、ソートのようなタスクの間に順序あり比較を実行するための論理的な場合にのみのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This approach defines an <bpt i="0" x="0">&lt;c0&gt;</bpt>App<ept i="0">&lt;/c0&gt;</ept> class with a nested <bpt i="1" x="1">&lt;c1&gt;</bpt>State<ept i="1">&lt;/c1&gt;</ept> enumeration that includes only the specific states you need:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この取り組みは、<bpt i="0" x="0">&lt;c0&gt;</bpt>App<ept i="0">&lt;/c0&gt;</ept>クラスを、あなたが必要とする特定の状態のみを含む<bpt i="1" x="1">&lt;c1&gt;</bpt>State<ept i="1">&lt;/c1&gt;</ept>列挙とともに定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This associated type appears as a requirement in the <bpt i="0" x="0">&lt;c0&gt;</bpt>Sequence<ept i="0">&lt;/c0&gt;</ept> protocol, but it is restated here with stricter constraints.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この関連型は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Sequence<ept i="0">&lt;/c0&gt;</ept>プロトコルの中のある要件として現れます、しかしここでより厳格な制約で言い直されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This capability can be especially important when the order of elements in the literal is significant.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この能力は、そのリテラル中の要素の順序が意味を持つ場合に特に重要となりえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This case is the default when initializing a <bpt i="0" x="0">&lt;c0&gt;</bpt>Mirror<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この場合が、<bpt i="0" x="0">&lt;c0&gt;</bpt>Mirror<ept i="0">&lt;/c0&gt;</ept>インスタンスを初期化する時の省略時の方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This characteristic facilitates compatibility with C, which allows any value to be stored in an enumeration, including values used internally but not exposed in headers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この特徴は、Cとの互換性を容易にします、それはどんな値も列挙に格納されることを許します、内部的に使われるがヘッダに暴露されない値も含めて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Actor<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Actor<ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Bidirectional<bpt i="1" x="1">&lt;w1&gt;</bpt>Collection<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Bidirectional<bpt i="1" x="1">&lt;w1&gt;</bpt>Collection<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Integer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Integer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Custom<bpt i="1" x="1">&lt;w1&gt;</bpt>Debug<bpt i="2" x="2">&lt;w2&gt;</bpt>String<bpt i="3" x="3">&lt;w3&gt;</bpt>Convertible<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Custom<bpt i="1" x="1">&lt;w1&gt;</bpt>Debug<bpt i="2" x="2">&lt;w2&gt;</bpt>String<bpt i="3" x="3">&lt;w3&gt;</bpt>Convertible<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Custom<bpt i="1" x="1">&lt;w1&gt;</bpt>Reflectable<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Custom<bpt i="1" x="1">&lt;w1&gt;</bpt>Reflectable<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Custom<bpt i="1" x="1">&lt;w1&gt;</bpt>String<bpt i="2" x="2">&lt;w2&gt;</bpt>Convertible<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Custom<bpt i="1" x="1">&lt;w1&gt;</bpt>String<bpt i="2" x="2">&lt;w2&gt;</bpt>Convertible<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Decodable<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Decodable<ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Encodable<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Encodable<ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>Array<bpt i="3" x="3">&lt;w3&gt;</bpt>Literal<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>Array<bpt i="3" x="3">&lt;w3&gt;</bpt>Literal<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>Integer<bpt i="3" x="3">&lt;w3&gt;</bpt>Literal<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>Integer<bpt i="3" x="3">&lt;w3&gt;</bpt>Literal<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Fixed<bpt i="1" x="1">&lt;w1&gt;</bpt>Width<bpt i="2" x="2">&lt;w2&gt;</bpt>Integer<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Fixed<bpt i="1" x="1">&lt;w1&gt;</bpt>Width<bpt i="2" x="2">&lt;w2&gt;</bpt>Integer<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Global<bpt i="1" x="1">&lt;w1&gt;</bpt>Actor<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Global<bpt i="1" x="1">&lt;w1&gt;</bpt>Actor<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Identifiable<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Identifiable<ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Iterator<bpt i="1" x="1">&lt;w1&gt;</bpt>Protocol<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Iterator<bpt i="1" x="1">&lt;w1&gt;</bpt>Protocol<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Keyed<bpt i="1" x="1">&lt;w1&gt;</bpt>Encoding<bpt i="2" x="2">&lt;w2&gt;</bpt>Container<bpt i="3" x="3">&lt;w3&gt;</bpt>Protocol<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Keyed<bpt i="1" x="1">&lt;w1&gt;</bpt>Encoding<bpt i="2" x="2">&lt;w2&gt;</bpt>Container<bpt i="3" x="3">&lt;w3&gt;</bpt>Protocol<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Lazy<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Lazy<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Mutable<bpt i="1" x="1">&lt;w1&gt;</bpt>Collection<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Mutable<bpt i="1" x="1">&lt;w1&gt;</bpt>Collection<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Range<bpt i="1" x="1">&lt;w1&gt;</bpt>Expression<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Range<bpt i="1" x="1">&lt;w1&gt;</bpt>Expression<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>SIMD<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>SIMD<ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>SIMDStorage<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>SIMDStorage<ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Sequence<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Sequence<ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Strideable<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Strideable<ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation contains preliminary information about an API or technology in development.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書は、開発でのテクノロジーまたはAPIのための事前の情報を含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example allocates uninitialized raw memory with space for four instances of <bpt i="2" x="2">&lt;c2&gt;</bpt>Point<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、未初期化の生のメモリを<bpt i="2" x="2">&lt;c2&gt;</bpt>Point<ept i="2">&lt;/c2&gt;</ept>の４つのインスタンス用の空間でアロケートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example appends the elements of a <bpt i="1" x="1">&lt;c1&gt;</bpt>Range&lt;Int&gt;<ept i="1">&lt;/c1&gt;</ept> instance to an array of integers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたはある<bpt i="1" x="1">&lt;c1&gt;</bpt>Range&lt;Int&gt;<ept i="1">&lt;/c1&gt;</ept>インスタンスに属する複数要素を整数の配列に追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example checks to see whether a favorite actor is in an array storing a movie’s cast.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、映画出演者を格納する配列の中にお気に入りの俳優がいるかどうか確認するために調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example checks to see whether a particular insect is in an array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、ある特定の昆虫が配列の中にあるかどうか見るために調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example creates a <bpt i="2" x="2">&lt;c2&gt;</bpt>Closed<bpt i="3" x="3">&lt;w3&gt;</bpt>Range&lt;Character&gt;<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> from “a” up to, and including, “z”.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、「a」から「z」までの、そしてそれを含む<bpt i="2" x="2">&lt;c2&gt;</bpt>Closed<bpt i="3" x="3">&lt;w3&gt;</bpt>Range&lt;Character&gt;<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example creates a <bpt i="2" x="2">&lt;c2&gt;</bpt>Partial<bpt i="3" x="3">&lt;w3&gt;</bpt>Range<bpt i="4" x="4">&lt;w4&gt;</bpt>From&lt;Double&gt;<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance that includes any value greater than or equal to <bpt i="5" x="5">&lt;c5&gt;</bpt>5<bpt i="6" x="6">&lt;w6&gt;</bpt>.0<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、<bpt i="2" x="2">&lt;c2&gt;</bpt>Partial<bpt i="3" x="3">&lt;w3&gt;</bpt>Range<bpt i="4" x="4">&lt;w4&gt;</bpt>From&lt;Double&gt;<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスで<bpt i="5" x="5">&lt;c5&gt;</bpt>5<bpt i="6" x="6">&lt;w6&gt;</bpt>.0<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>より大きいか等しい何らかの値を含むものを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example creates a <bpt i="2" x="2">&lt;c2&gt;</bpt>Partial<bpt i="3" x="3">&lt;w3&gt;</bpt>Range<bpt i="4" x="4">&lt;w4&gt;</bpt>Through&lt;Double&gt;<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance that includes any value less than or equal to <bpt i="5" x="5">&lt;c5&gt;</bpt>5<bpt i="6" x="6">&lt;w6&gt;</bpt>.0<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、<bpt i="2" x="2">&lt;c2&gt;</bpt>Partial<bpt i="3" x="3">&lt;w3&gt;</bpt>Range<bpt i="4" x="4">&lt;w4&gt;</bpt>Through&lt;Double&gt;<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスで<bpt i="5" x="5">&lt;c5&gt;</bpt>5<bpt i="6" x="6">&lt;w6&gt;</bpt>.0<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>より少ないか等しい何らかの値を含むものを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example creates a <bpt i="2" x="2">&lt;c2&gt;</bpt>Partial<bpt i="3" x="3">&lt;w3&gt;</bpt>Range<bpt i="4" x="4">&lt;w4&gt;</bpt>Up<bpt i="5" x="5">&lt;w5&gt;</bpt>To&lt;Double&gt;<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance that includes any value less than <bpt i="6" x="6">&lt;c6&gt;</bpt>5<bpt i="7" x="7">&lt;w7&gt;</bpt>.0<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、<bpt i="2" x="2">&lt;c2&gt;</bpt>Partial<bpt i="3" x="3">&lt;w3&gt;</bpt>Range<bpt i="4" x="4">&lt;w4&gt;</bpt>Up<bpt i="5" x="5">&lt;w5&gt;</bpt>To&lt;Double&gt;<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスで<bpt i="6" x="6">&lt;c6&gt;</bpt>5<bpt i="7" x="7">&lt;w7&gt;</bpt>.0<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>より少ない何らかの値を含むものを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example creates a <bpt i="2" x="2">&lt;c2&gt;</bpt>Range&lt;Double&gt;<ept i="2">&lt;/c2&gt;</ept> from zero up to, but not including, 5.0.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、ゼロから5.0までの、しかしそれを含めない<bpt i="2" x="2">&lt;c2&gt;</bpt>Range&lt;Double&gt;<ept i="2">&lt;/c2&gt;</ept>を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example creates an instance of <bpt i="2" x="2">&lt;c2&gt;</bpt>Shipping<bpt i="3" x="3">&lt;w3&gt;</bpt>Options<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> with a raw value beyond the highest element, with a bit mask that effectively contains all the declared static members.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、<bpt i="2" x="2">&lt;c2&gt;</bpt>Shipping<bpt i="3" x="3">&lt;w3&gt;</bpt>Options<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>のインスタンスを最も高い要素を越える生の値で、全ての宣言済み静的メンバを実質的に含むあるビットマスクで、作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example creates three new values in the range <bpt i="0" x="0">&lt;c0&gt;</bpt>1...100<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、３つの新しい値を範囲<bpt i="0" x="0">&lt;c0&gt;</bpt>1...100<ept i="0">&lt;/c0&gt;</ept>において作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example creates three new values in the range <bpt i="0" x="0">&lt;c0&gt;</bpt>1..&lt;100<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、３つの新しい値を範囲<bpt i="0" x="0">&lt;c0&gt;</bpt>1..&lt;100<ept i="0">&lt;/c0&gt;</ept>において作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example declares a constant with three currently allowed moves.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は３つの現在許される動きを持つある定数を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は文字列からなる配列のあるスライスの取得を実演します、スライスの中の文字列の１つのインデックスを見つけて、それからそのインデックスを元の配列において使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example enumerates the characters of the string “Swift” and prints each character along with its place in the string.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は文字列「Swift」の文字を列挙します、そして各文字をその文字列でのそれの場所とともに出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example finds the index of the last name that begins with the letter <bpt i="1" x="1">&lt;e1&gt;</bpt>A:<ept i="1">&lt;/e1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、文字<bpt i="1" x="1">&lt;e1&gt;</bpt>A:<ept i="1">&lt;/e1&gt;</ept>で始まる、最後の名前のインデックスを見つけます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example finds the largest value in an array of height measurements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、身長計測の配列の中で最も大きな値を見つけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example finds the smallest value in an array of height measurements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、身長計測の配列の中で最も小さな値を見つけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、ある集合のインデックスと要素のすべてにわたって反復します、５つまたはより少ない文字を持つ名前のインデックスから成るリストを作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example performs an arithmetic operation on an optional integer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、算術演算をあるオプショナル整数上で実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example performs an arithmetic operation with an optional result on an optional integer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、オプショナル結果をもつ算術演算をあるオプショナル整数上で実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example picks a name at random from an array:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、ある名前を無作為に配列から選出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example prints the characters of a string in reverse order:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、ある文字列に属する文字を逆順で出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example removes all the odd values from an array of numbers:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、数値からなる配列から全ての奇数値を除去します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example removes all the vowels from a string:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、全ての母音を文字列から除去します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example removes the element <bpt i="0" x="0">&lt;c0&gt;</bpt>"sugar"<ept i="0">&lt;/c0&gt;</ept> from a set of ingredients.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、要素<bpt i="0" x="0">&lt;c0&gt;</bpt>"sugar"<ept i="0">&lt;/c0&gt;</ept>を一揃いの材料から削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example removes the middle element from an array of measurements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、測定結果からなる配列から真ん中の要素を削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example removes three elements from the middle of an array of measurements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、測定結果からなる配列の真ん中から３つの要素を削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example searches <bpt i="0" x="0">&lt;c0&gt;</bpt>streets<bpt i="1" x="1">&lt;w1&gt;</bpt>Slice<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> for one of the strings in the slice, and then uses that index in the original array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>streets<bpt i="1" x="1">&lt;w1&gt;</bpt>Slice<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をスライスの中の文字列の１つについて検索して、それからそのインデックスを元々の配列において使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example shows how an array of <bpt i="0" x="0">&lt;c0&gt;</bpt>[Int]<ept i="0">&lt;/c0&gt;</ept> instances can be joined, using another <bpt i="1" x="1">&lt;c1&gt;</bpt>[Int]<ept i="1">&lt;/c1&gt;</ept> instance as the separator:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、どのようにいくつかの<bpt i="0" x="0">&lt;c0&gt;</bpt>[Int]<ept i="0">&lt;/c0&gt;</ept>インスタンスからなる配列が別の<bpt i="1" x="1">&lt;c1&gt;</bpt>[Int]<ept i="1">&lt;/c1&gt;</ept>インスタンスを分離子として使ってつなぎ合わされるかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example shows how to build a dictionary of letter frequencies of a string.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、ある文字列の文字頻度の辞書を作り上げる方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example shows how to find the sum of an array of numbers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、どのように数からなる配列の合計を見出すかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example shows how to use the <bpt i="0" x="0">&lt;c0&gt;</bpt>max(by:)<ept i="0">&lt;/c0&gt;</ept> method on a dictionary to find the key-value pair with the highest value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>max(by:)<ept i="0">&lt;/c0&gt;</ept>メソッドを辞書上で使って、最も高い値を持つキー値ペアを見つける方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example shows how to use the <bpt i="0" x="0">&lt;c0&gt;</bpt>min(by:)<ept i="0">&lt;/c0&gt;</ept> method on a dictionary to find the key-value pair with the lowest value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>min(by:)<ept i="0">&lt;/c0&gt;</ept>メソッドを辞書上で使って、最も低い値を持つキー値ペアを見つける方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example shows how you can check an array for an expense greater than $100.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、どのようにあなたが$100より大きい出費についてある配列を調べるかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example shows how you can modify one of the names in an array of students.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例が示すのは、どうやってあなたが学生らの配列の中の名前の１つを修正できるかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example shows two overlapping ranges:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は２つの重なった範囲を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example tests whether one countable range begins with the elements of another countable range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、ある可付番範囲が別の可付番範囲の要素で始まるかどうかテストします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example tests whether one countable range shares the same elements as another countable range and an array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、ある可付番範囲が同じ要素を別の可付番範囲とそしてある配列と共有するかどうかをテストします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example uses the <bpt i="0" x="0">&lt;c0&gt;</bpt>contains(_:)<ept i="0">&lt;/c0&gt;</ept> method to check whether next-day shipping is in the <bpt i="1" x="1">&lt;c1&gt;</bpt>available<bpt i="2" x="2">&lt;w2&gt;</bpt>Options<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>contains(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使って翌日出荷が<bpt i="1" x="1">&lt;c1&gt;</bpt>available<bpt i="2" x="2">&lt;w2&gt;</bpt>Options<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>インスタンスの中のあるかどうか確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example uses the <bpt i="0" x="0">&lt;c0&gt;</bpt>contains(_:)<ept i="0">&lt;/c0&gt;</ept> method to test whether an integer is a member of a set of prime numbers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>contains(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使ってある整数がある一揃いの素数のメンバであるかどうかをテストします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example uses the <bpt i="0" x="0">&lt;c0&gt;</bpt>intersection(_:)<ept i="0">&lt;/c0&gt;</ept> method to limit the available shipping options to what can be used with a PO Box destination.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>intersection(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使って、利用可能な出荷オプションを私書箱宛先で使われるものに制限します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example uses the <bpt i="0" x="0">&lt;c0&gt;</bpt>last(where:)<ept i="0">&lt;/c0&gt;</ept> method to find the last negative number in an array of integers:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>last(where:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使って、整数の配列において最後の負数を見つけます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example uses the <bpt i="0" x="0">&lt;c0&gt;</bpt>lexicographically<bpt i="1" x="1">&lt;w1&gt;</bpt>Precedes<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method to test which array of integers comes first in a lexicographical ordering.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は<bpt i="0" x="0">&lt;c0&gt;</bpt>lexicographically<bpt i="1" x="1">&lt;w1&gt;</bpt>Precedes<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使って、どの整数配列がある語彙筆記的順序において最初に来るかをテストします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example uses the <bpt i="0" x="0">&lt;c0&gt;</bpt>union(_:)<ept i="0">&lt;/c0&gt;</ept> method to add two more shipping options to the default set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>union(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使って２つのさらなる出荷オプションを省略時のセットに加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This function does not infer element moves.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この関数は、要素が移動することを推測しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This function is suitable for exploring the structure of a mirror in a REPL or playground, but is not intended to be efficient.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この関数は、REPLまたはプレイグラウンドにおいてミラーの構造体を探索するのに適します、しかし効率を考慮されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This function is the only requirement of the <bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この関数は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept>プロトコルのただ１つの要件です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This function throws an error if any values are invalid for the given encoder’s format.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この関数は、与えられたエンコーダの形式に対して何らかの値が無効であるならばエラーをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This header may be nontrivial to compute; it is usually a good idea to store this information in the “header” area when an instance is created.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このヘッダを計算するのは、些細なことではありません；通常良い考えであるのは、この情報をインスタンスが作成されるときに「ヘッダ」領域に格納することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This information is subject to change, and software implemented according to this documentation should be tested with final operating system software.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この情報は変更される場合があり、この文書に沿って実装されるソフトウェアは最終的なオペレーティングシステム・ソフトウェアでテストされなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This initializer always succeeds, even if the value passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> exceeds the static properties declared as part of the option set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザは常に成功します、<bpt i="0" x="0">&lt;c0&gt;</bpt>raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として渡される値がオプションセットの部分として宣言される静的プロパティを上回るとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This initializer can also be used to restore set methods after performing sequence operations such as <bpt i="0" x="0">&lt;c0&gt;</bpt>filter(_:)<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>map(_:)<ept i="1">&lt;/c1&gt;</ept> on a set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザはまた、シーケンス演算、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>filter(_:)<ept i="0">&lt;/c0&gt;</ept>や<bpt i="1" x="1">&lt;c1&gt;</bpt>map(_:)<ept i="1">&lt;/c1&gt;</ept>などをある集合上で実行した後で集合に戻す手法として使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This initializer creates an option set with a raw value of zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザは、０個の生の値を持つオプションセットを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This initializer does not perform any range or overflow checking.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザは、全く範囲またはオーバーフロー検査を実行しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This initializer is equivalent to initializing with an empty array literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザは空の配列リテラルで初期化するのと等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This initializer is failable because although every case of the <bpt i="5" x="5">&lt;c5&gt;</bpt>Counter<ept i="5">&lt;/c5&gt;</ept> type has a corresponding <bpt i="6" x="6">&lt;c6&gt;</bpt>Int<ept i="6">&lt;/c6&gt;</ept> value, there are many <bpt i="7" x="7">&lt;c7&gt;</bpt>Int<ept i="7">&lt;/c7&gt;</ept> values that <bpt i="8" x="8">&lt;e8&gt;</bpt>don’t<ept i="8">&lt;/e8&gt;</ept> correspond to a case of <bpt i="9" x="9">&lt;c9&gt;</bpt>Counter<ept i="9">&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザは失敗可能です、なぜならすべての<bpt i="5" x="5">&lt;c5&gt;</bpt>Counter<ept i="5">&lt;/c5&gt;</ept>型のケース節は対応する<bpt i="6" x="6">&lt;c6&gt;</bpt>Int<ept i="6">&lt;/c6&gt;</ept>値を持つけれども、<bpt i="7" x="7">&lt;c7&gt;</bpt>Counter<ept i="7">&lt;/c7&gt;</ept>のケース節に対応<bpt i="8" x="8">&lt;e8&gt;</bpt>しない<ept i="8">&lt;/e8&gt;</ept>多くの<bpt i="9" x="9">&lt;c9&gt;</bpt>Int<ept i="9">&lt;/c9&gt;</ept>値が存在するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザは、デコーダからの読み出しが失敗するならば、または読み込んだデータが不正またはそうでなくとも無効ならば、エラーをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This initializer works with any type, and uses the custom <bpt i="1" x="1">&lt;c1&gt;</bpt>debug<bpt i="2" x="2">&lt;w2&gt;</bpt>Description<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> property for types that conform to <bpt i="3" x="3">&lt;c3&gt;</bpt>Custom<bpt i="4" x="4">&lt;w4&gt;</bpt>Debug<bpt i="5" x="5">&lt;w5&gt;</bpt>String<bpt i="6" x="6">&lt;w6&gt;</bpt>Convertible<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザはどんな型とでも働きます、そしてあつらえの<bpt i="1" x="1">&lt;c1&gt;</bpt>debug<bpt i="2" x="2">&lt;w2&gt;</bpt>Description<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>プロパティを<bpt i="3" x="3">&lt;c3&gt;</bpt>Custom<bpt i="4" x="4">&lt;w4&gt;</bpt>Debug<bpt i="5" x="5">&lt;w5&gt;</bpt>String<bpt i="6" x="6">&lt;w6&gt;</bpt>Convertible<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に準拠する型に対して使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This initializer works with any type, and uses the custom <bpt i="1" x="1">&lt;c1&gt;</bpt>description<ept i="1">&lt;/c1&gt;</ept> property for types that conform to <bpt i="2" x="2">&lt;c2&gt;</bpt>Custom<bpt i="3" x="3">&lt;w3&gt;</bpt>String<bpt i="4" x="4">&lt;w4&gt;</bpt>Convertible<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザはどんな型とでも働きます、そしてあつらえの<bpt i="1" x="1">&lt;c1&gt;</bpt>description<ept i="1">&lt;/c1&gt;</ept>プロパティを<bpt i="2" x="2">&lt;c2&gt;</bpt>Custom<bpt i="3" x="3">&lt;w3&gt;</bpt>String<bpt i="4" x="4">&lt;w4&gt;</bpt>Convertible<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に準拠する型に対して使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is equivalent to initializing with an empty array literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これは空の配列リテラルで初期化するのに等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is equivalent to the following conditional in Swift:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これは、Swiftでの以下の条件文に相当します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is equivalent to the inverse of a set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これはある集合の逆と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is equivalent to using the <bpt i="0" x="0">&lt;c0&gt;</bpt>@available<ept i="0">&lt;/c0&gt;</ept> attribute on a declaration in Swift:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これは、<bpt i="0" x="0">&lt;c0&gt;</bpt>@available<ept i="0">&lt;/c0&gt;</ept>をSwiftにおける宣言上で使うことに相当します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is the associated <bpt i="0" x="0">&lt;c0&gt;</bpt>Iterator<ept i="0">&lt;/c0&gt;</ept> of <bpt i="1" x="1">&lt;c1&gt;</bpt>Lazy<bpt i="2" x="2">&lt;w2&gt;</bpt>Filter<bpt i="3" x="3">&lt;w3&gt;</bpt>Sequence<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>Lazy<bpt i="5" x="5">&lt;w5&gt;</bpt>Filter<bpt i="6" x="6">&lt;w6&gt;</bpt>Collection<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これは<bpt i="1" x="1">&lt;c1&gt;</bpt>Lazy<bpt i="2" x="2">&lt;w2&gt;</bpt>Filter<bpt i="3" x="3">&lt;w3&gt;</bpt>Sequence<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>Lazy<bpt i="5" x="5">&lt;w5&gt;</bpt>Filter<bpt i="6" x="6">&lt;w6&gt;</bpt>Collection<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>に関連する<bpt i="0" x="0">&lt;c0&gt;</bpt>Iterator<ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is the associated iterator for the <bpt i="0" x="0">&lt;c0&gt;</bpt>Lazy<bpt i="1" x="1">&lt;w1&gt;</bpt>Drop<bpt i="2" x="2">&lt;w2&gt;</bpt>While<bpt i="3" x="3">&lt;w3&gt;</bpt>Sequence<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>Lazy<bpt i="5" x="5">&lt;w5&gt;</bpt>Drop<bpt i="6" x="6">&lt;w6&gt;</bpt>While<bpt i="7" x="7">&lt;w7&gt;</bpt>Collection<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, and <bpt i="8" x="8">&lt;c8&gt;</bpt>Lazy<bpt i="9" x="9">&lt;w9&gt;</bpt>Drop<bpt i="10" x="10">&lt;w10&gt;</bpt>While<bpt i="11" x="11">&lt;w11&gt;</bpt>Bidirectional<bpt i="12" x="12">&lt;w12&gt;</bpt>Collection<ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Lazy<bpt i="1" x="1">&lt;w1&gt;</bpt>Drop<bpt i="2" x="2">&lt;w2&gt;</bpt>While<bpt i="3" x="3">&lt;w3&gt;</bpt>Sequence<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、<bpt i="4" x="4">&lt;c4&gt;</bpt>Lazy<bpt i="5" x="5">&lt;w5&gt;</bpt>Drop<bpt i="6" x="6">&lt;w6&gt;</bpt>While<bpt i="7" x="7">&lt;w7&gt;</bpt>Collection<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>、そして<bpt i="8" x="8">&lt;c8&gt;</bpt>Lazy<bpt i="9" x="9">&lt;w9&gt;</bpt>Drop<bpt i="10" x="10">&lt;w10&gt;</bpt>While<bpt i="11" x="11">&lt;w11&gt;</bpt>Bidirectional<bpt i="12" x="12">&lt;w12&gt;</bpt>Collection<ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>型に対する関連イテレータです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is the associated iterator for the <bpt i="0" x="0">&lt;c0&gt;</bpt>Lazy<bpt i="1" x="1">&lt;w1&gt;</bpt>Prefix<bpt i="2" x="2">&lt;w2&gt;</bpt>While<bpt i="3" x="3">&lt;w3&gt;</bpt>Sequence<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>Lazy<bpt i="5" x="5">&lt;w5&gt;</bpt>Prefix<bpt i="6" x="6">&lt;w6&gt;</bpt>While<bpt i="7" x="7">&lt;w7&gt;</bpt>Collection<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, and <bpt i="8" x="8">&lt;c8&gt;</bpt>Lazy<bpt i="9" x="9">&lt;w9&gt;</bpt>Prefix<bpt i="10" x="10">&lt;w10&gt;</bpt>While<bpt i="11" x="11">&lt;w11&gt;</bpt>Bidirectional<bpt i="12" x="12">&lt;w12&gt;</bpt>Collection<ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Lazy<bpt i="1" x="1">&lt;w1&gt;</bpt>Prefix<bpt i="2" x="2">&lt;w2&gt;</bpt>While<bpt i="3" x="3">&lt;w3&gt;</bpt>Sequence<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、<bpt i="4" x="4">&lt;c4&gt;</bpt>Lazy<bpt i="5" x="5">&lt;w5&gt;</bpt>Prefix<bpt i="6" x="6">&lt;w6&gt;</bpt>While<bpt i="7" x="7">&lt;w7&gt;</bpt>Collection<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>、そして<bpt i="8" x="8">&lt;c8&gt;</bpt>Lazy<bpt i="9" x="9">&lt;w9&gt;</bpt>Prefix<bpt i="10" x="10">&lt;w10&gt;</bpt>While<bpt i="11" x="11">&lt;w11&gt;</bpt>Bidirectional<bpt i="12" x="12">&lt;w12&gt;</bpt>Collection<ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>型に対する関連イテレータです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is the default implementation of the greater-than operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&gt;<ept i="0">&lt;/c0&gt;</ept>) for any type that conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>に準拠するあらゆる型に対して、より大きい演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&gt;<ept i="0">&lt;/c0&gt;</ept>）の初期状態の実装です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is the default implementation of the greater-than-or-equal-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&gt;=<ept i="0">&lt;/c0&gt;</ept>) for any type that conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>に準拠するあらゆる型に対して、より大きいか等しい演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&gt;=<ept i="0">&lt;/c0&gt;</ept>）の初期状態の実装です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is the default implementation of the less-than-or-equal-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;=<ept i="0">&lt;/c0&gt;</ept>) for any type that conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>に準拠するあらゆる型に対して、より少ないか等しい演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;=<ept i="0">&lt;/c0&gt;</ept>）の初期状態の実装です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is the default implementation of the not-equal-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>!=<ept i="0">&lt;/c0&gt;</ept>) for any type that conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠するあらゆる型に対して、不等演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>!=<ept i="0">&lt;/c0&gt;</ept>）の初期状態の実装です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is the same as the number of bytes moved when an <bpt i="0" x="0">&lt;c0&gt;</bpt>Unsafe<bpt i="1" x="1">&lt;w1&gt;</bpt>Pointer&lt;T&gt;<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance is incremented.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Unsafe<bpt i="1" x="1">&lt;w1&gt;</bpt>Pointer&lt;T&gt;<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が増大させられる時に動かされるバイト数と同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This latter behavior is a contrast with <bpt i="8" x="8">&lt;a8&gt;</bpt><bpt i="9" x="9">&lt;c9&gt;</bpt>Just<ept i="9">&lt;/c9&gt;</ept><ept i="8">&lt;/a8&gt;</ept>, which always publishes a single value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この後者の挙動は、<bpt i="8" x="8">&lt;a8&gt;</bpt><bpt i="9" x="9">&lt;c9&gt;</bpt>Just<ept i="9">&lt;/c9&gt;</ept><ept i="8">&lt;/a8&gt;</ept>と対照的です。それは常にある単一の値を出版します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This list describes how Swift imports types with different nullability annotations:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このリストは、どのようにSwiftが異なるヌル可能性注釈で型をインポートするかを記述します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method ensures that the set has unique, mutable, contiguous storage, with space allocated for at least the requested number of elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、集合が、少なくとも要請された数の要素に割り当てられた空間とともに、固有な、可変の、隣接するストレージを持つことを保証します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method has the effect of removing the specified range of elements from the collection and inserting the new elements at the same location.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、指定された範囲の要素をコレクションから取り除き、そして新しい要素を同じ場所に挿入する効果を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、語彙筆記的順序の数学的概念を実装します、それはユニコードに関係はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method is available when the sequence’s iterator element type is the tuple type <bpt i="0" x="0">&lt;c0&gt;</bpt>(CGRect, NSColor)<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドが利用可能なのは、シーケンスのもつイテレータ要素型がタプル型<bpt i="0" x="0">&lt;c0&gt;</bpt>(CGRect, NSColor)<ept i="0">&lt;/c0&gt;</ept>である時です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method is available when the sequence’s iterator element type is the tuple type <bpt i="0" x="0">&lt;c0&gt;</bpt>(CGRect, gray: CGFloat)<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドが利用可能なのは、シーケンスのもつイテレータ要素型がタプル型<bpt i="0" x="0">&lt;c0&gt;</bpt>(CGRect, gray: CGFloat)<ept i="0">&lt;/c0&gt;</ept>である時です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method is available when the sequence’s iterator element type is<bpt i="0" x="0">&lt;c0&gt;</bpt> NSRect<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドが利用可能なのは、シーケンスのもつイテレータ要素型が<bpt i="0" x="0">&lt;c0&gt;</bpt> NSRect<ept i="0">&lt;/c0&gt;</ept>である時です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method is equivalent to calling <bpt i="0" x="0">&lt;c0&gt;</bpt>random(in:<bpt i="1" x="1">&lt;w1&gt;</bpt>using:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, passing in the system’s default random generator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、<bpt i="0" x="0">&lt;c0&gt;</bpt>random(in:<bpt i="1" x="1">&lt;w1&gt;</bpt>using:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を、システムの持つ省略時の無作為生成子を渡して呼び出すことに相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method is equivalent to calling <bpt i="0" x="0">&lt;c0&gt;</bpt>random<bpt i="1" x="1">&lt;w1&gt;</bpt>Element(using:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, passing in the system’s default random generator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、<bpt i="0" x="0">&lt;c0&gt;</bpt>random<bpt i="1" x="1">&lt;w1&gt;</bpt>Element(using:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を、システムの持つ省略時の無作為生成子を渡して呼び出すことに相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method is equivalent to calling <bpt i="0" x="0">&lt;c0&gt;</bpt>shuffle(using:)<ept i="0">&lt;/c0&gt;</ept>, passing in the system’s default random generator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、<bpt i="0" x="0">&lt;c0&gt;</bpt>shuffle(using:)<ept i="0">&lt;/c0&gt;</ept>を、システムの持つ省略時の無作為生成子を渡して呼び出すことに相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method is equivalent to calling <bpt i="0" x="0">&lt;c0&gt;</bpt>shuffled(using:)<ept i="0">&lt;/c0&gt;</ept>, passing in the system’s default random generator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、<bpt i="0" x="0">&lt;c0&gt;</bpt>shuffled(using:)<ept i="0">&lt;/c0&gt;</ept>を、システムの持つ省略時の無作為生成子を渡して呼び出すことに相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method is equivalent to calling the version that takes a generator, passing in the system’s default random generator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、ある生成子をとるバージョンを、システムの持つ省略時の無作為生成子を渡して呼び出すことに相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method is implemented as a <bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;<ept i="0">&lt;/c0&gt;</ept> (bitwise AND) operation on the two sets’ raw values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、２つの集合の持つ生の値に関する<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;<ept i="0">&lt;/c0&gt;</ept>（ビット単位AND）演算として実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method is implemented as a <bpt i="0" x="0">&lt;c0&gt;</bpt>^<ept i="0">&lt;/c0&gt;</ept> (bitwise XOR) operation on the two sets’ raw values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、２つの集合の持つ生の値に関する<bpt i="0" x="0">&lt;c0&gt;</bpt>^<ept i="0">&lt;/c0&gt;</ept>（ビット単位XOR）演算として実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method is implemented as a <bpt i="0" x="0">&lt;c0&gt;</bpt>|<ept i="0">&lt;/c0&gt;</ept> (bitwise OR) operation on the two sets’ raw values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、２つの集合の持つ生の値に関する<bpt i="0" x="0">&lt;c0&gt;</bpt>|<ept i="0">&lt;/c0&gt;</ept>（ビット単位OR）演算として実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method is preferred over <bpt i="0" x="0">&lt;c0&gt;</bpt>reduce(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、効率のために<bpt i="0" x="0">&lt;c0&gt;</bpt>reduce(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>より好まれます、その結果がコピーオンライト型である場合、例えばArrayまたは辞書に対しては。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method returns <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> if the container does not have a value associated with <bpt i="1" x="1">&lt;c1&gt;</bpt>key<ept i="1">&lt;/c1&gt;</ept>, or if the value is null.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>を、そのコンテナが<bpt i="1" x="1">&lt;c1&gt;</bpt>key<ept i="1">&lt;/c1&gt;</ept>と関連付けられる値を持たないならば、またはその値がnullならば、返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This operation requires that the current <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>NSGraphics<bpt i="2" x="2">&lt;w2&gt;</bpt>Context<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> is non-<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この演算は、現在の<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>NSGraphics<bpt i="2" x="2">&lt;w2&gt;</bpt>Context<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>が非<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>であることが必須です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This permanently modifies the graphics state, so save the current state beforehand and restore it afterwards.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これは、永続的にグラフィックス状態を修正します、なので現在の状態をあらかじめ保存して、後でそれを復元してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This pointer is valid only for the duration of the call to <bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このポインタは、ただ<bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept>への呼び出しの間にのみ有効とされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This property is always <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> for signed integer types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このプロパティは、符号付き整数型に対して常に<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This property must always evaluate to the same executor for a given actor instance, and holding on to the actor must keep the executor alive.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このプロパティは、与えられたアクターインスタンスに対して常に同じエグゼキュータに評価されなければなりません、そしてアクターを手放さないことはエグゼキュータを存続させる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This property trades safety for performance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このプロパティは性能と安全を交換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This property will be implicitly accessed when work needs to be scheduled onto this actor.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このプロパティは、仕事がこのアクター上に予定を組まれる必要がある時に、暗黙的にアクセスされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This publisher produces the type wrapped by the optional.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このパブリッシャーは、オプショナルによってラップされた型を生み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This setting has no effect on mirrors reflecting value type instances.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この設定は、値型インスタンスをリフレクションするミラー上では効果を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This should report all keys present which are convertible to the requested type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これは、要請された型に変換可能である、存在する全てのキーを報告するべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This type is the result of <bpt i="0" x="0">&lt;c0&gt;</bpt>x<bpt i="1" x="1">&lt;w1&gt;</bpt>.reversed()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> where <bpt i="2" x="2">&lt;c2&gt;</bpt>x<ept i="2">&lt;/c2&gt;</ept> is a collection having bidirectional indices.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型は、<bpt i="0" x="0">&lt;c0&gt;</bpt>x<bpt i="1" x="1">&lt;w1&gt;</bpt>.reversed()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の結果です、ここで<bpt i="2" x="2">&lt;c2&gt;</bpt>x<ept i="2">&lt;/c2&gt;</ept>は双方向性のインデックスを持つコレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This type may differ from the subject’s dynamic type when this mirror is the <bpt i="0" x="0">&lt;c0&gt;</bpt>superclass<bpt i="1" x="1">&lt;w1&gt;</bpt>Mirror<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> of another mirror.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型は、このミラーが別のミラーの<bpt i="0" x="0">&lt;c0&gt;</bpt>superclass<bpt i="1" x="1">&lt;w1&gt;</bpt>Mirror<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>である時は、この主題のもつ動的型と異なるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This unique identifier is only valid for comparisons during the lifetime of the instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この固有識別子は、インスタンスのライフタイムの間での比較に対してだけ有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This value is always positive.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この結果は常に正です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This value may be nontrivial to compute; it is usually a good idea to store this information in the “header” area when an instance is created.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値を計算するのは、些細なことではありません；通常良い考えであるのは、この情報をインスタンスが作成されるときに「ヘッダ」領域に格納することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Those annotations change how Swift imports your declarations.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それら注釈は、どのようにSwiftがあなたの宣言をインポートするかを変更します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To access a slice of a collection using a range expression, use the collection’s generic subscript that uses a range expression as its parameter.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲式を使ってコレクションのスライスにアクセスするには、そのコレクションの持つ総称体添え字で、範囲式をそれのパラメータとして使うものを使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To add <bpt i="0" x="0">&lt;c0&gt;</bpt>Numeric<ept i="0">&lt;/c0&gt;</ept> protocol conformance to your own custom type, implement the required initializer and operators, and provide a <bpt i="1" x="1">&lt;c1&gt;</bpt>magnitude<ept i="1">&lt;/c1&gt;</ept> property using a type that can represent the magnitude of any value of your custom type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Numeric<ept i="0">&lt;/c0&gt;</ept>プロトコル準拠をあなた独自のカスタム型に加えるには、必須イニシャライザおよび演算子を実装してください、そしてあなたのあつらえの型のあらゆる値の規模を表現できる型を使って<bpt i="1" x="1">&lt;c1&gt;</bpt>magnitude<ept i="1">&lt;/c1&gt;</ept>プロパティを提供してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To add <bpt i="0" x="0">&lt;c0&gt;</bpt>Range<bpt i="1" x="1">&lt;w1&gt;</bpt>Replaceable<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance to your custom collection, add an empty initializer and the <bpt i="3" x="3">&lt;c3&gt;</bpt>replace<bpt i="4" x="4">&lt;w4&gt;</bpt>Subrange(_:<bpt i="5" x="5">&lt;w5&gt;</bpt>with:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> method to your custom type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Range<bpt i="1" x="1">&lt;w1&gt;</bpt>Replaceable<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠をあなたのあつらえのコレクションに加えるには、ひとつの空のイニシャライザおよび<bpt i="3" x="3">&lt;c3&gt;</bpt>replace<bpt i="4" x="4">&lt;w4&gt;</bpt>Subrange(_:<bpt i="5" x="5">&lt;w5&gt;</bpt>with:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>メソッドをあなたのあつらえの型に加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To add <bpt i="4" x="4">&lt;c4&gt;</bpt>Sequence<ept i="4">&lt;/c4&gt;</ept> conformance to your own custom type, add a <bpt i="5" x="5">&lt;c5&gt;</bpt>make<bpt i="6" x="6">&lt;w6&gt;</bpt>Iterator()<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> method that returns an iterator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>Sequence<ept i="4">&lt;/c4&gt;</ept>準拠をあなた独自のあつらえの型に加えるには、あるイテレータを返す<bpt i="5" x="5">&lt;c5&gt;</bpt>make<bpt i="6" x="6">&lt;w6&gt;</bpt>Iterator()<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>メソッドを加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To add a new lazy sequence operation, extend this protocol with a method that returns a lazy wrapper that itself conforms to <bpt i="0" x="0">&lt;c0&gt;</bpt>Lazy<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい遅延シーケンス演算を加えるには、このプロトコルをあるメソッドで拡張してください、それはそれ自身<bpt i="0" x="0">&lt;c0&gt;</bpt>Lazy<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠するある遅延ラッパーを返すものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To add conformance to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Mutable<bpt i="1" x="1">&lt;w1&gt;</bpt>Collection<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol to your own custom collection, upgrade your type’s subscript to support both read and write access.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Mutable<bpt i="1" x="1">&lt;w1&gt;</bpt>Collection<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルへの準拠をあなた独自のあつらえのコレクションに加えるには、あなたの型のもつ添え字を更新して読み書きアクセス両方をサポートするようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To add new lazy collection operations, extend this protocol with methods that return lazy wrappers that are themselves <bpt i="0" x="0">&lt;c0&gt;</bpt>Lazy<bpt i="1" x="1">&lt;w1&gt;</bpt>Collection<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>s.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい遅延コレクション操作を加えるために、このプロトコルを、それら自身が<bpt i="0" x="0">&lt;c0&gt;</bpt>Lazy<bpt i="1" x="1">&lt;w1&gt;</bpt>Collection<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>である遅延ラッパーを返すメソッドで拡張してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To add values of different types, convert one of the values to the other value’s type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>異なる型の値を加算するには、それらの値の一方を、他方の値の型へと変換してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To avoid dropping the customization provided by ancestor classes, an override of <bpt i="2" x="2">&lt;c2&gt;</bpt>custom<bpt i="3" x="3">&lt;w3&gt;</bpt>Mirror<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> should pass <bpt i="4" x="4">&lt;c4&gt;</bpt>.customized({ super<bpt i="5" x="5">&lt;w5&gt;</bpt>.custom<bpt i="6" x="6">&lt;w6&gt;</bpt>Mirror })<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> as <bpt i="7" x="7">&lt;c7&gt;</bpt>ancestor<bpt i="8" x="8">&lt;w8&gt;</bpt>Representation<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> when initializing its mirror.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>先祖クラスのカスタマイズを失くすのを防ぐために、<bpt i="2" x="2">&lt;c2&gt;</bpt>custom<bpt i="3" x="3">&lt;w3&gt;</bpt>Mirror<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>のオーバーライドは<bpt i="4" x="4">&lt;c4&gt;</bpt>.customized({ super<bpt i="5" x="5">&lt;w5&gt;</bpt>.custom<bpt i="6" x="6">&lt;w6&gt;</bpt>Mirror })<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を<bpt i="7" x="7">&lt;c7&gt;</bpt>ancestor<bpt i="8" x="8">&lt;w8&gt;</bpt>Representation<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>としてそれのミラーを初期化する時に渡さなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To avoid the unexpected copy, use the <bpt i="1" x="1">&lt;c1&gt;</bpt>index(after:)<ept i="1">&lt;/c1&gt;</ept> method starting with <bpt i="2" x="2">&lt;c2&gt;</bpt>start<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> to produce indices instead.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>予期されないコピーを避けるために、代わりに<bpt i="1" x="1">&lt;c1&gt;</bpt>index(after:)<ept i="1">&lt;/c1&gt;</ept>メソッドを使って<bpt i="2" x="2">&lt;c2&gt;</bpt>start<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>で始めることで、インデックスを生成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To check whether a collection is empty, use its <bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Empty<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property instead of comparing <bpt i="2" x="2">&lt;c2&gt;</bpt>count<ept i="2">&lt;/c2&gt;</ept> to zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるコレクションが空かどうか調べるには、それの<bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Empty<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティを使ってください、<bpt i="2" x="2">&lt;c2&gt;</bpt>count<ept i="2">&lt;/c2&gt;</ept>をゼロと比較するのでなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To check whether the collection is empty, use its <bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Empty<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property instead of comparing <bpt i="2" x="2">&lt;c2&gt;</bpt>count<ept i="2">&lt;/c2&gt;</ept> to zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションが空かどうか調べるには、それの<bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Empty<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティを使ってください、<bpt i="2" x="2">&lt;c2&gt;</bpt>count<ept i="2">&lt;/c2&gt;</ept>をゼロと比較するのでなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To conditionally bind the wrapped value of an <bpt i="0" x="0">&lt;c0&gt;</bpt>Optional<ept i="0">&lt;/c0&gt;</ept> instance to a new variable, use one of the optional binding control structures, including <bpt i="1" x="1">&lt;c1&gt;</bpt>if let<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>guard let<ept i="2">&lt;/c2&gt;</ept>, and <bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Optional<ept i="0">&lt;/c0&gt;</ept>インスタンスのラップされた値を新しい変数へ条件付きの束縛を行うには、<bpt i="1" x="1">&lt;c1&gt;</bpt>if let<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>guard let<ept i="2">&lt;/c2&gt;</ept>、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>switch<ept i="3">&lt;/c3&gt;</ept>を含む、オプショナル束縛制御構造の１つを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To conform to <bpt i="3" x="3">&lt;c3&gt;</bpt>Hashable<ept i="3">&lt;/c3&gt;</ept>, implement the <bpt i="4" x="4">&lt;c4&gt;</bpt>hash(into:)<ept i="4">&lt;/c4&gt;</ept> requirement instead.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>Hashable<ept i="3">&lt;/c3&gt;</ept>に準拠するには、<bpt i="4" x="4">&lt;c4&gt;</bpt>hash(into:)<ept i="4">&lt;/c4&gt;</ept>要件を代わりに実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To create an empty instance, assign an empty array literal to your variable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>空のインスタンスを作成するには、空の配列リテラルをあなたの変数に割り当ててください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To customize the logging of your type in a playground, conform to the <bpt i="3" x="3">&lt;c3&gt;</bpt>Custom<bpt i="4" x="4">&lt;w4&gt;</bpt>Playground<bpt i="5" x="5">&lt;w5&gt;</bpt>Display<bpt i="6" x="6">&lt;w6&gt;</bpt>Convertible<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> protocol, which does not use the <bpt i="7" x="7">&lt;c7&gt;</bpt>Playground<bpt i="8" x="8">&lt;w8&gt;</bpt>Quick<bpt i="9" x="9">&lt;w9&gt;</bpt>Look<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> enum.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたの型のログ取りをプレイグラウンドにおいてカスタマイズするには、<bpt i="3" x="3">&lt;c3&gt;</bpt>Custom<bpt i="4" x="4">&lt;w4&gt;</bpt>Playground<bpt i="5" x="5">&lt;w5&gt;</bpt>Display<bpt i="6" x="6">&lt;w6&gt;</bpt>Convertible<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>プロトコルに準拠してください、それは<bpt i="7" x="7">&lt;c7&gt;</bpt>Playground<bpt i="8" x="8">&lt;w8&gt;</bpt>Quick<bpt i="9" x="9">&lt;w9&gt;</bpt>Look<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> enumを使いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To customize the mirror representation of a custom type, add conformance to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Custom<bpt i="1" x="1">&lt;w1&gt;</bpt>Reflectable<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あつらえの型のミラー表現をカスタマイズするには、<bpt i="0" x="0">&lt;c0&gt;</bpt>Custom<bpt i="1" x="1">&lt;w1&gt;</bpt>Reflectable<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルへの準拠を加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To customize your type’s implementation, provide your own mutating <bpt i="2" x="2">&lt;c2&gt;</bpt>negate()<ept i="2">&lt;/c2&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたの型のもつ実装をカスタマイズするには、あなた自身の変更<bpt i="2" x="2">&lt;c2&gt;</bpt>negate()<ept i="2">&lt;/c2&gt;</ept>メソッドを提供してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To establish that a type you’ve created supports nondestructive iteration, add conformance to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<ept i="0">&lt;/c0&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが作成した型が非破壊反復をサポートすることを確立するには、<bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<ept i="0">&lt;/c0&gt;</ept>プロトコルに対する準拠を加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To find the position that corresponds with this index in the original, underlying collection, use that collection’s <bpt i="0" x="0">&lt;c0&gt;</bpt>index(before:)<ept i="0">&lt;/c0&gt;</ept> method with the <bpt i="1" x="1">&lt;c1&gt;</bpt>base<ept i="1">&lt;/c1&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オリジナル、基盤コレクションでのこのインデックスに相当する位置を見つけるには、そのコレクションの<bpt i="0" x="0">&lt;c0&gt;</bpt>index(before:)<ept i="0">&lt;/c0&gt;</ept>メソッドを<bpt i="1" x="1">&lt;c1&gt;</bpt>base<ept i="1">&lt;/c1&gt;</ept>プロパティとともに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To inherit all the default implementations from the <bpt i="0" x="0">&lt;c0&gt;</bpt>Option<bpt i="1" x="1">&lt;w1&gt;</bpt>Set<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol, the <bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept> type must be <bpt i="3" x="3">&lt;c3&gt;</bpt>Self<ept i="3">&lt;/c3&gt;</ept>, the default.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Option<bpt i="1" x="1">&lt;w1&gt;</bpt>Set<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコル由来のすべての省略時実装を継承するには、<bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept>型は<bpt i="3" x="3">&lt;c3&gt;</bpt>Self<ept i="3">&lt;/c3&gt;</ept>、初期状態、でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To iterate over the elements of a collection with its indices, use the <bpt i="3" x="3">&lt;c3&gt;</bpt>zip(_:<bpt i="4" x="4">&lt;w4&gt;</bpt>_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるコレクションの要素すべてにわたってそれのインデックスで反復するには、<bpt i="3" x="3">&lt;c3&gt;</bpt>zip(_:<bpt i="4" x="4">&lt;w4&gt;</bpt>_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>関数を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To make a Swift class available in Objective-C, make it a descendant of an Objective-C class.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>SwiftクラスをObjective-Cで利用可能にするには、それをObjective-Cクラスの子孫にしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To make a custom type conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Number<bpt i="2" x="2">&lt;w2&gt;</bpt>Generator<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol, implement the required <bpt i="3" x="3">&lt;c3&gt;</bpt>next()<ept i="3">&lt;/c3&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのあつらえのクラスを<bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Number<bpt i="2" x="2">&lt;w2&gt;</bpt>Generator<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠させるには、必須<bpt i="3" x="3">&lt;c3&gt;</bpt>next()<ept i="3">&lt;/c3&gt;</ept>メソッドを実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To make an Objective-C declaration unavailable at compile time in both Swift and Objective-C, use the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_UNAVAILABLE<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> macro.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるObjective-C宣言をSwiftとObjective-Cの両方で利用できなくするには、<bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_UNAVAILABLE<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>マクロを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To make your Swift class accessible and usable back in Objective-C, make it a descendant of an Objective-C class.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのSwiftクラスを逆にObjective-Cにおいてアクセス可能および利用可能にするには、それをObjective-Cクラスの子孫にしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To multiply values of different types, convert one of the values to the other value’s type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>異なる型の値を乗算するには、それらの値の一方を、他方の値の型へと変換してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To prevent a declaration in an Objective-C API from being imported, pass a single parameter to the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_SWIFT<bpt i="2" x="2">&lt;w2&gt;</bpt>_UNAVAILABLE<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> macro.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-C APIの中のある宣言がインポートされるのを防ぐには、ある単一のパラメータを<bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_SWIFT<bpt i="2" x="2">&lt;w2&gt;</bpt>_UNAVAILABLE<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>マクロに渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To prevent bypassing customized ancestors, pass <bpt i="7" x="7">&lt;c7&gt;</bpt>.customized({ super<bpt i="8" x="8">&lt;w8&gt;</bpt>.custom<bpt i="9" x="9">&lt;w9&gt;</bpt>Mirror })<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> as the <bpt i="10" x="10">&lt;c10&gt;</bpt>ancestor<bpt i="11" x="11">&lt;w11&gt;</bpt>Representation<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> parameter when implementing your type’s <bpt i="12" x="12">&lt;c12&gt;</bpt>custom<bpt i="13" x="13">&lt;w13&gt;</bpt>Mirror<ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あつらえの先祖を迂回することを防ぐには、<bpt i="7" x="7">&lt;c7&gt;</bpt>.customized({ super<bpt i="8" x="8">&lt;w8&gt;</bpt>.custom<bpt i="9" x="9">&lt;w9&gt;</bpt>Mirror })<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>を<bpt i="10" x="10">&lt;c10&gt;</bpt>ancestor<bpt i="11" x="11">&lt;w11&gt;</bpt>Representation<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>パラメータとして、あなたの型のもつ<bpt i="12" x="12">&lt;c12&gt;</bpt>custom<bpt i="13" x="13">&lt;w13&gt;</bpt>Mirror<ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>プロパティを実装する時に渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To remove the last element of a collection that might be empty, use the <bpt i="0" x="0">&lt;c0&gt;</bpt>pop<bpt i="1" x="1">&lt;w1&gt;</bpt>Last()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method instead.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>空であるかもしれないあるコレクションの最後の要素を削除するには、<bpt i="0" x="0">&lt;c0&gt;</bpt>pop<bpt i="1" x="1">&lt;w1&gt;</bpt>Last()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To restore efficient set operations, create a new set from the result.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>能率的な集合演算を取り戻すには、新しい集合を結果から作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To safely access the properties and methods of a wrapped instance, use the postfix optional chaining operator (postfix <bpt i="0" x="0">&lt;c0&gt;</bpt>?<ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ラップされたインスタンスの持つプロパティおよびメソッドに安全にアクセスするには、後置オプショナル連鎖演算子（後置<bpt i="0" x="0">&lt;c0&gt;</bpt>?<ept i="0">&lt;/c0&gt;</ept>）を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To sort the elements of your collection in descending order, pass the greater-than operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&gt;<ept i="0">&lt;/c0&gt;</ept>) to the <bpt i="1" x="1">&lt;c1&gt;</bpt>sort(by:)<ept i="1">&lt;/c1&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのコレクションの要素を降順にソートするには、より大きい演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&gt;<ept i="0">&lt;/c0&gt;</ept>）を<bpt i="1" x="1">&lt;c1&gt;</bpt>sort(by:)<ept i="1">&lt;/c1&gt;</ept>メソッドに渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To sort the elements of your sequence in descending order, pass the greater-than operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&gt;<ept i="0">&lt;/c0&gt;</ept>) to the <bpt i="1" x="1">&lt;c1&gt;</bpt>sorted(by:)<ept i="1">&lt;/c1&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのシーケンスの要素を降順にソートするには、より大きい演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&gt;<ept i="0">&lt;/c0&gt;</ept>）を<bpt i="1" x="1">&lt;c1&gt;</bpt>sorted(by:)<ept i="1">&lt;/c1&gt;</ept>メソッドに渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To sort your sequence in descending order, pass the greater-than operator (<bpt i="1" x="1">&lt;c1&gt;</bpt>&gt;<ept i="1">&lt;/c1&gt;</ept>) as the <bpt i="2" x="2">&lt;c2&gt;</bpt>are<bpt i="3" x="3">&lt;w3&gt;</bpt>In<bpt i="4" x="4">&lt;w4&gt;</bpt>Increasing<bpt i="5" x="5">&lt;w5&gt;</bpt>Order<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> parameter.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのシーケンスを降順にソートするには、より大きい演算子（<bpt i="1" x="1">&lt;c1&gt;</bpt>&gt;<ept i="1">&lt;/c1&gt;</ept>）を<bpt i="2" x="2">&lt;c2&gt;</bpt>are<bpt i="3" x="3">&lt;w3&gt;</bpt>In<bpt i="4" x="4">&lt;w4&gt;</bpt>Increasing<bpt i="5" x="5">&lt;w5&gt;</bpt>Order<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>パラメータとして渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To specify a particular name for the class to use in Objective-C, mark it with <bpt i="0" x="0">&lt;c0&gt;</bpt>@objc(<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;e1&gt;</bpt>name<ept i="1">&lt;/e1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>)<ept i="2">&lt;/c2&gt;</ept>, where name is the name that your Objective-C code uses to reference the Swift class.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>特定の名前をクラスに対して指定してObjective-Cで使うには、それを<bpt i="0" x="0">&lt;c0&gt;</bpt>@objc(<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;e1&gt;</bpt>name<ept i="1">&lt;/e1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>)<ept i="2">&lt;/c2&gt;</ept>で印してください、ここでnameはあなたのObjective-CコードがSwiftクラスを参照するのに使う名前です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To subtract values of different types, convert one of the values to the other value’s type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>異なる型の値を減算するには、それらの値の一方を、他方の値の型へと変換してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To write each line to the file, pass a closure to the <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>for<bpt i="2" x="2">&lt;w2&gt;</bpt>Each(_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> method:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>各行をファイルに書き出すには、クロージャを<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>for<bpt i="2" x="2">&lt;w2&gt;</bpt>Each(_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>メソッドに渡してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Topics</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>話題</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Transforming a Range's Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある範囲の持つ要素を変換する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Transforming a Result</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果を変換する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Transforming a Sequence</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスを変形する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Transforming a Set</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合を変形する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Transforming an Optional Value</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オプショナル値の変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Troubleshooting Tips and Reminders</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>問題解決の秘訣と注意</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Two edge cases are worth particular attention:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの境界事例は特別な注意を払う価値があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Two elements are <bpt i="0" x="0">&lt;e0&gt;</bpt>incomparable<ept i="0">&lt;/e0&gt;</ept> if neither is ordered before the other according to the predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの要素は、述部によるとどちらもが他の前に並べられるならば<bpt i="0" x="0">&lt;e0&gt;</bpt>比較できない<ept i="0">&lt;/e0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Two ranges are equal when they have the same lower and upper bounds.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの範囲は、それらが同じ下方および上方境界を持つとき等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Type Aliases</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型エイリアス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Type Method</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Type Methods</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Type Properties</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型プロパティ </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Type Property</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Types that conform to <bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Number<bpt i="2" x="2">&lt;w2&gt;</bpt>Generator<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> should specifically document the thread safety and quality of the generator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Number<bpt i="2" x="2">&lt;w2&gt;</bpt>Generator<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠する型は、とりわけ生成子のスレッド安全と品質を文書化すべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Typical usage stores a count and capacity in <bpt i="5" x="5">&lt;c5&gt;</bpt>Header<ept i="5">&lt;/c5&gt;</ept> and destroys any live elements in the <bpt i="6" x="6">&lt;c6&gt;</bpt>deinit<ept i="6">&lt;/c6&gt;</ept> of a subclass.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>典型的なやり方は、総数と容量を<bpt i="5" x="5">&lt;c5&gt;</bpt>Header<ept i="5">&lt;/c5&gt;</ept>に格納して、サブクラスの<bpt i="6" x="6">&lt;c6&gt;</bpt>deinit<ept i="6">&lt;/c6&gt;</ept>の中のあらゆる生きている要素を破壊します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Typically, you use <bpt i="0" x="0">&lt;c0&gt;</bpt>do-catch<ept i="0">&lt;/c0&gt;</ept> statements to handle throwing expressions immediately, but sometimes you need to store the whole result of the operation for later processing during tasks like analyzing a batch of calls.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>概して、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>do-catch<ept i="0">&lt;/c0&gt;</ept>文を使うことでスロー式を直接に取り扱います、しかし時にはあなたは演算の結果全体を保管しておく必要があります、もっと後で、一群の呼び出しを分析することのような作業の間に処理するために。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Unannotated declarations within the audited region are treated as nonnullable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>監査された領域内部の注釈を付けられない宣言は、非ヌル可能性として取り扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Unconditional Unwrapping</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>無条件にアンラップする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Unconditionally prints a given message and stops execution.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>無条件に与えられたメッセージを出力して実行を停止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Unconditionally unwrapping a <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> instance with <bpt i="1" x="1">&lt;c1&gt;</bpt>!<ept i="1">&lt;/c1&gt;</ept> triggers a runtime error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>インスタンスを<bpt i="1" x="1">&lt;c1&gt;</bpt>!<ept i="1">&lt;/c1&gt;</ept>で無条件にアンラップすることは、実行時エラーの引き金となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Under typical system conditions, it's usually printed last, but you shouldn't write code that relies on the order of an asychronous call relative to synchronous code without performing more careful synchronization between threads.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>典型的なシステム条件の下、それはふつうは最後に印字されます、しかしあなたは、スレッド間でより注意深い同期を実行することなく、同期コードに関連して非同期呼び出しの順番を頼るコードを書くべきではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Understand how different API calls to your closures can affect your app.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのクロージャに対する異なるAPI呼び出しがどのようにあなたのアプリに影響を与えられるかを理解します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Understand the Results of Synchronous and Asynchronous Calls</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同期および非同期呼び出しの結果を理解する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Unless the collection conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Bidirectional<bpt i="1" x="1">&lt;w1&gt;</bpt>Collection<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol, <bpt i="2" x="2">&lt;c2&gt;</bpt>start<ept i="2">&lt;/c2&gt;</ept> must be less than or equal to <bpt i="3" x="3">&lt;c3&gt;</bpt>end<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションが<bpt i="0" x="0">&lt;c0&gt;</bpt>Bidirectional<bpt i="1" x="1">&lt;w1&gt;</bpt>Collection<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠しない場合は、<bpt i="2" x="2">&lt;c2&gt;</bpt>start<ept i="2">&lt;/c2&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>end<ept i="3">&lt;/c3&gt;</ept>より少ないか等しくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Unless the collection guarantees random-access performance, calculating <bpt i="3" x="3">&lt;c3&gt;</bpt>count<ept i="3">&lt;/c3&gt;</ept> can be an O(<bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept>) operation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのコレクションが無作為アクセス性能を保証しない限り、<bpt i="3" x="3">&lt;c3&gt;</bpt>count<ept i="3">&lt;/c3&gt;</ept>の算出は、O(<bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept>)演算であるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Unless you’re implementing a scheduler, you don’t generally interact with partial tasks directly.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがあるスケジューラを実装しているのでない限り、あなたは一般的に部分的タスクそれらと直接に相互作用しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Unlike enumerations, option sets provide a nonfailable <bpt i="0" x="0">&lt;c0&gt;</bpt>init(raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initializer to convert from a raw value, because option sets don’t have an enumerated list of all possible cases.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>列挙と異なり、オプションセットは生の値から変換するために失敗できない<bpt i="0" x="0">&lt;c0&gt;</bpt>init(raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>イニシャライザを提供します、なぜならオプションセットは可能な場合全てを列挙したリストを持たないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Unlike key-value pairs in a true dictionary, neither the key nor the value of a <bpt i="4" x="4">&lt;c4&gt;</bpt>Key<bpt i="5" x="5">&lt;w5&gt;</bpt>Value<bpt i="6" x="6">&lt;w6&gt;</bpt>Pairs<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> instance must conform to the <bpt i="7" x="7">&lt;c7&gt;</bpt>Hashable<ept i="7">&lt;/c7&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>本当の辞書におけるキー値ペアとは違い、<bpt i="4" x="4">&lt;c4&gt;</bpt>Key<bpt i="5" x="5">&lt;w5&gt;</bpt>Value<bpt i="6" x="6">&lt;w6&gt;</bpt>Pairs<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>インスタンスのキーも値も<bpt i="7" x="7">&lt;c7&gt;</bpt>Hashable<ept i="7">&lt;/c7&gt;</ept>プロトコルに準拠する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Unlike ordinary set types, the <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> type of an <bpt i="1" x="1">&lt;c1&gt;</bpt>Option<bpt i="2" x="2">&lt;w2&gt;</bpt>Set<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is identical to the <bpt i="3" x="3">&lt;c3&gt;</bpt>Option<bpt i="4" x="4">&lt;w4&gt;</bpt>Set<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> type itself.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>普通の集合型とは違い、ある<bpt i="1" x="1">&lt;c1&gt;</bpt>Option<bpt i="2" x="2">&lt;w2&gt;</bpt>Set<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の<bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>型は、<bpt i="3" x="3">&lt;c3&gt;</bpt>Option<bpt i="4" x="4">&lt;w4&gt;</bpt>Set<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>型自体と全く同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Unlike traditional truncating multiplication, the <bpt i="0" x="0">&lt;c0&gt;</bpt>multiplied<bpt i="1" x="1">&lt;w1&gt;</bpt>Full<bpt i="2" x="2">&lt;w2&gt;</bpt>Width(by:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method returns a tuple containing both the <bpt i="3" x="3">&lt;c3&gt;</bpt>high<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>low<ept i="4">&lt;/c4&gt;</ept> parts of the product of this value and <bpt i="5" x="5">&lt;c5&gt;</bpt>other<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>従来的な切り詰め乗算と違って、<bpt i="0" x="0">&lt;c0&gt;</bpt>multiplied<bpt i="1" x="1">&lt;w1&gt;</bpt>Full<bpt i="2" x="2">&lt;w2&gt;</bpt>Width(by:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドは、この値と<bpt i="3" x="3">&lt;c3&gt;</bpt>other<ept i="3">&lt;/c3&gt;</ept>の積の<bpt i="4" x="4">&lt;c4&gt;</bpt>high<ept i="4">&lt;/c4&gt;</ept>および<bpt i="5" x="5">&lt;c5&gt;</bpt>low<ept i="5">&lt;/c5&gt;</ept>部分の両方を含んでいるタプルを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Update import statements in your Objective-C code (to <bpt i="0" x="0">&lt;c0&gt;</bpt>#import "Product<bpt i="1" x="1">&lt;w1&gt;</bpt>Module<bpt i="2" x="2">&lt;w2&gt;</bpt>Name-Swift<bpt i="3" x="3">&lt;w3&gt;</bpt>.h"<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>) to refer to your new Swift code.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのObjective-Cコードにおいてインポート文を更新して（<bpt i="0" x="0">&lt;c0&gt;</bpt>#import "Product<bpt i="1" x="1">&lt;w1&gt;</bpt>Module<bpt i="2" x="2">&lt;w2&gt;</bpt>Name-Swift<bpt i="3" x="3">&lt;w3&gt;</bpt>.h"<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>へと）、あなたの新しいSwiftコードを参照するようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Update your code to use the Swift class name instead of the Objective-C name if you gave the Swift class a different name.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがスウィフトクラスに異なる名前を与えるならば、Objective-C名でなくてスウィフトクラス名を使用するようにあなたのコードを更新してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Updates the left hand side with the pointwise wrapping product of two vectors.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ポイント単位ラップの、２つのベクターの積で左手側を更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Updates the left hand side with the wrapping difference of the two vectors.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ラップしている、２つのベクターの差で左手側を更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Updates the left hand side with the wrapping sum of the two vectors.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ラップしている、２つのベクターの和で左手側を更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use <bpt i="0" x="0">&lt;c0&gt;</bpt>Never<ept i="0">&lt;/c0&gt;</ept> as the return type when declaring a closure, function, or method that unconditionally throws an error, traps, or otherwise does not terminate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>無条件にエラーをスローする、トラップする、またはそうする以外終了しない、クロージャ、関数、またはメソッドを定義するときに、<bpt i="0" x="0">&lt;c0&gt;</bpt>Never<ept i="0">&lt;/c0&gt;</ept>を戻り型として使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use <bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept> macro to denote the availability of an Objective-C API.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept>マクロを使って、Objective-C APIの利用可能性を示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use <bpt i="0" x="0">&lt;c0&gt;</bpt>unsafely<bpt i="1" x="1">&lt;w1&gt;</bpt>Unwrapped<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> only when you are confident that this instance will never be equal to <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept> and only after you’ve tried using the postfix <bpt i="3" x="3">&lt;c3&gt;</bpt>!<ept i="3">&lt;/c3&gt;</ept> operator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>unsafely<bpt i="1" x="1">&lt;w1&gt;</bpt>Unwrapped<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、あなたがこのインスタンスは決して<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>と等しくないことを確信している場合にのみ、そしてあなたが前置<bpt i="3" x="3">&lt;c3&gt;</bpt>!<ept i="3">&lt;/c3&gt;</ept>演算子を使うことを試みた後にのみ使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use <bpt i="3" x="3">&lt;c3&gt;</bpt>NS<bpt i="4" x="4">&lt;w4&gt;</bpt>_TYPED<bpt i="5" x="5">&lt;w5&gt;</bpt>_ENUM<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> for sets of constants that <bpt i="6" x="6">&lt;e6&gt;</bpt>can't<ept i="6">&lt;/e6&gt;</ept> logically have values added in a Swift extension, and use <bpt i="7" x="7">&lt;c7&gt;</bpt>NS<bpt i="8" x="8">&lt;w8&gt;</bpt>_TYPED<bpt i="9" x="9">&lt;w9&gt;</bpt>_EXTENSIBLE<bpt i="10" x="10">&lt;w10&gt;</bpt>_ENUM<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> for sets of constants that <bpt i="11" x="11">&lt;e11&gt;</bpt>can<ept i="11">&lt;/e11&gt;</ept> be expanded in an extension.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>NS<bpt i="4" x="4">&lt;w4&gt;</bpt>_TYPED<bpt i="5" x="5">&lt;w5&gt;</bpt>_ENUM<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>を、論理的にSwift拡張に加えられた値を持つことが<bpt i="6" x="6">&lt;e6&gt;</bpt>できない<ept i="6">&lt;/e6&gt;</ept>定数のセットに対して使ってください、そして<bpt i="7" x="7">&lt;c7&gt;</bpt>NS<bpt i="8" x="8">&lt;w8&gt;</bpt>_TYPED<bpt i="9" x="9">&lt;w9&gt;</bpt>_EXTENSIBLE<bpt i="10" x="10">&lt;w10&gt;</bpt>_ENUM<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>を、ある拡張において拡張されることが<bpt i="11" x="11">&lt;e11&gt;</bpt>できる<ept i="11">&lt;/e11&gt;</ept>定数のセットに対して使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use <bpt i="7" x="7">&lt;c7&gt;</bpt>NS<bpt i="8" x="8">&lt;w8&gt;</bpt>_TYPED<bpt i="9" x="9">&lt;w9&gt;</bpt>_ENUM<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> and <bpt i="10" x="10">&lt;c10&gt;</bpt>NS<bpt i="11" x="11">&lt;w11&gt;</bpt>_TYPED<bpt i="12" x="12">&lt;w12&gt;</bpt>_EXTENSIBLE<bpt i="13" x="13">&lt;w13&gt;</bpt>_ENUM<ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> when grouping related constants of any type, including string constants.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="7" x="7">&lt;c7&gt;</bpt>NS<bpt i="8" x="8">&lt;w8&gt;</bpt>_TYPED<bpt i="9" x="9">&lt;w9&gt;</bpt>_ENUM<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>および<bpt i="10" x="10">&lt;c10&gt;</bpt>NS<bpt i="11" x="11">&lt;w11&gt;</bpt>_TYPED<bpt i="12" x="12">&lt;w12&gt;</bpt>_EXTENSIBLE<bpt i="13" x="13">&lt;w13&gt;</bpt>_ENUM<ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>を、文字列定数を含む、任意の型の関連する定数をグループにする場合に使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use API names and parameter names along with documentation to determine whether an API is synchronous or asynchronous.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>API名とパラメータ名を、加えてAPIが同期的または非同期的かを明らかにする文書とともに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use a <bpt i="0" x="0">&lt;c0&gt;</bpt>Key<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<bpt i="2" x="2">&lt;w2&gt;</bpt>Pairs<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance when you need an ordered collection of key-value pairs and don’t require the fast key lookup that the <bpt i="3" x="3">&lt;c3&gt;</bpt>Dictionary<ept i="3">&lt;/c3&gt;</ept> type provides.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Key<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<bpt i="2" x="2">&lt;w2&gt;</bpt>Pairs<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを使うのは、あなたがキー値ペアの順序付きコレクションを必要とするそして<bpt i="3" x="3">&lt;c3&gt;</bpt>Dictionary<ept i="3">&lt;/c3&gt;</ept>型が提供する高速キー検索を要求しない場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use a sequence of rectangles and other types to perform operations on an AppKit graphic context.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>矩形それらと他の型それらからなるあるシーケンスを使って、いくつかの演算をAppKitのグラフィック的な文脈で実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use a type’s alignment when allocating memory using an unsafe pointer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型のもつアライメントを使うのは、安全でないポインタを使うメモリアロケートの場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use an Enumeration to Capture State</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>列挙を使って状態をキャプチャしてください</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use bridged reference types when you need reference semantics or Foundation-specific behavior.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ブリッジされた参照型を、あなたが参照意味論またはFoundation特有の挙動を必要とする場合に使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use enumerations to capture and track the state of your app.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>列挙を使ってあなたのアプリの状態をキャプチャおよび追跡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use native Swift syntax to interoperate with types and functions in C and Objective-C.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>本来のSwift構文を使ってCおよびObjective-Cでの型および関数と相互作用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use nullability annotations or mark regions as annotated to control how Objective-C declarations are imported into Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ヌル可能性注釈を使うかまたは領域が注釈されると印することで、どのようにObjective-C宣言がSwiftへとインポートされるかを制御してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use selectors and key paths to interact with dynamic Objective-C APIs.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>セレクタとキーパスを使って動的Objective-C APIと相互作用してます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use set-related operations to check for membership and to add or remove members from an instance of your custom option set type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>セット関連演算を使って、帰属を確認したり、あなたのあつらえのオプションセット型のインスタンス由来のメンバの追加や削除を行ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>@available()<ept i="0">&lt;/c0&gt;</ept> keyword to check availability information in a conditional statement in Objective-C:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>@available()<ept i="0">&lt;/c0&gt;</ept>キーワードを使って、利用可能性情報をObjective-Cの条件文で確認してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>@objc(<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;e1&gt;</bpt>name<ept i="1">&lt;/e1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>)<ept i="2">&lt;/c2&gt;</ept> attribute to provide Objective-C names for properties and methods when necessary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>@objc(<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;e1&gt;</bpt>name<ept i="1">&lt;/e1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>)<ept i="2">&lt;/c2&gt;</ept>属性をObjective-C名をプロパティとメソッドに必要に応じて用意するために使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>API<bpt i="1" x="1">&lt;w1&gt;</bpt>_AVAILABLE<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> macro to add availability information in Objective-C:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>API<bpt i="1" x="1">&lt;w1&gt;</bpt>_AVAILABLE<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>マクロを使って、利用可能性情報をObjective-Cにおいて加えてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>CF<bpt i="1" x="1">&lt;w1&gt;</bpt>_SWIFT<bpt i="2" x="2">&lt;w2&gt;</bpt>_NAME<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> macro to group functions that have related behavior.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>CF<bpt i="1" x="1">&lt;w1&gt;</bpt>_SWIFT<bpt i="2" x="2">&lt;w2&gt;</bpt>_NAME<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使って、関連する挙動を持つ関数をグループにまとめてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_CLOSED<bpt i="2" x="2">&lt;w2&gt;</bpt>_ENUM<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> macro for a simple group of constants that you can never add new cases to.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_CLOSED<bpt i="2" x="2">&lt;w2&gt;</bpt>_ENUM<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>マクロを、あなたが決してそれに新しいケース節を加えることが出来ない、ある単純な定数グループに対して使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_ENUM<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> macro for simple groups of constants.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_ENUM<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>マクロを、単純な定数のグループに対して使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_REFINED<bpt i="2" x="2">&lt;w2&gt;</bpt>_FOR<bpt i="3" x="3">&lt;w3&gt;</bpt>_SWIFT<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> macro to change how an API is imported into Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_REFINED<bpt i="2" x="2">&lt;w2&gt;</bpt>_FOR<bpt i="3" x="3">&lt;w3&gt;</bpt>_SWIFT<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>マクロを使って、あるAPIがSwiftへとインポートされる方法を変更してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_SWIFT<bpt i="2" x="2">&lt;w2&gt;</bpt>_NAME<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> macro to customize API names for Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_SWIFT<bpt i="2" x="2">&lt;w2&gt;</bpt>_NAME<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使って、API名をSwift用にカスタマイズしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_SWIFT<bpt i="2" x="2">&lt;w2&gt;</bpt>_UNAVAILABLE<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> macro to prevent an API from being used in Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_SWIFT<bpt i="2" x="2">&lt;w2&gt;</bpt>_UNAVAILABLE<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使って、あるAPIがSwiftにおいて使われることを妨げてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>advanced(by:)<ept i="0">&lt;/c0&gt;</ept> method in generic code to offset a value by a specified distance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>advanced(by:)<ept i="0">&lt;/c0&gt;</ept>メソッドを総称体コードにおいて使用して、ある値を指定された隔たりだけオフセットしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>alignment<ept i="0">&lt;/c0&gt;</ept> property for a type when allocating memory using an unsafe pointer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある型に対して<bpt i="0" x="0">&lt;c0&gt;</bpt>alignment<ept i="0">&lt;/c0&gt;</ept>プロパティを使うのは、安全でないポインタを使うメモリアロケートの場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>contains(_:)<ept i="0">&lt;/c0&gt;</ept> method to test whether a set contains a specific element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>contains(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使って、ある集合が特定の要素を含むかどうかテストしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>flat<bpt i="1" x="1">&lt;w1&gt;</bpt>Map<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method with a closure that returns an optional value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>flat<bpt i="1" x="1">&lt;w1&gt;</bpt>Map<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドをオプショナル値を返すクロージャとともに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>intersection(_:)<ept i="0">&lt;/c0&gt;</ept> method to create a new set with only the elements common to a set and another set or sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>intersection(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使って、ある集合と別の集合またはシーケンスに共通の要素だけで新しい集合を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Disjoint(with:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method to test whether a set has any elements in common with another set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Disjoint(with:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使って、ある集合が別の集合と共通の何らかの要素を持つかどうかテストしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Strict<bpt i="2" x="2">&lt;w2&gt;</bpt>Subset(of:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>is<bpt i="4" x="4">&lt;w4&gt;</bpt>Strict<bpt i="5" x="5">&lt;w5&gt;</bpt>Superset(of:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> methods to test whether a set is a subset or superset of, but not equal to, another set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Strict<bpt i="2" x="2">&lt;w2&gt;</bpt>Subset(of:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>および<bpt i="3" x="3">&lt;c3&gt;</bpt>is<bpt i="4" x="4">&lt;w4&gt;</bpt>Strict<bpt i="5" x="5">&lt;w5&gt;</bpt>Superset(of:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>メソッドを使って、ある集合が別の集合の下位集合または上位集合である、しかし等しくはないものであるかどうかテストしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Subset(of:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method to test whether a set contains all the elements of another set or sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Subset(of:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使って、ある集合が別の集合またはシーケンスに属する要素すべてを含むかどうかテストしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Superset(of:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method to test whether all elements of a set are contained in another set or sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Superset(of:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使って、ある集合のすべての要素が別の集合またはシーケンスの中に含まれるかどうかテストしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>map<ept i="0">&lt;/c0&gt;</ept> method with a closure that returns a non-optional value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この<bpt i="0" x="0">&lt;c0&gt;</bpt>map<ept i="0">&lt;/c0&gt;</ept>メソッドを、非オプショナル値を返すクロージャとともに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>reduce(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method to produce a single value from the elements of an entire sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>reduce(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使って、あるシーケンス全体の要素それらからある単一の値を生成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>reduce(into:<bpt i="1" x="1">&lt;w1&gt;</bpt>_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method to produce a single value from the elements of an entire sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>reduce(into:<bpt i="1" x="1">&lt;w1&gt;</bpt>_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使って、あるシーケンス全体の要素それらからある単一の値を生成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>shuffle()<ept i="0">&lt;/c0&gt;</ept> method to randomly reorder the elements of an array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>shuffle()<ept i="0">&lt;/c0&gt;</ept>メソッドを使って、配列の要素を無作為に再配列してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>subtracting(_:)<ept i="0">&lt;/c0&gt;</ept> method to create a new set with the elements of a set that are not also in another set or sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>subtracting(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使って、別の集合またはシーケンスにはないある集合の要素で新しい集合を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>symmetric<bpt i="1" x="1">&lt;w1&gt;</bpt>Difference(_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method to create a new set with the elements that are in either a set or another set or sequence, but not in both.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>symmetric<bpt i="1" x="1">&lt;w1&gt;</bpt>Difference(_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使って、ある集合または別の集合かシーケンスのどちらかにある、しかし両方にではない要素で新しい集合を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>union(_:)<ept i="0">&lt;/c0&gt;</ept> method to create a new set with the elements of a set and another set or sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>union(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使って、ある集合と別の集合またはシーケンスに属する要素で新しい集合を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>Result<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> type in these scenarios to capture the result of a potentially failing operation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>Result<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>型をそれらの状況において使用して、失敗する可能性のある演算の結果をキャプチャしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>formatted()<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> method to apply the default list format style to a sequence of strings.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>formatted()<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>メソッドを使って、省略時のリスト書式形式を文字列いくつからなるあるシーケンスに適用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>formatted(_:)<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> method to apply a custom list format style.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>formatted(_:)<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>メソッドを使ってあつらえのリスト書式形式を適用しください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the closed range operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>...<ept i="0">&lt;/c0&gt;</ept>) to create a closed range of any type that conforms to the <bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>完結範囲演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>...<ept i="0">&lt;/c0&gt;</ept>）を使って<bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>プロトコルに準拠する何らかの型の配列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the half-open range operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>..&lt;<ept i="0">&lt;/c0&gt;</ept>) to create a range of any type that conforms to the <bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>半開範囲演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>..&lt;<ept i="0">&lt;/c0&gt;</ept>）を使って<bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>プロトコルに準拠する何らかの型の配列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the masking left shift operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;&lt;&lt;<ept i="0">&lt;/c0&gt;</ept>) when you need to perform a shift and are sure that the shift amount is in the range <bpt i="1" x="1">&lt;c1&gt;</bpt>0..<it pos="begin" x="2">&lt;lhs&lt;w2&gt;</it>.bit<bpt i="3" x="3">&lt;w3&gt;</bpt>Width<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>マスク左シフト演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;&lt;&lt;<ept i="0">&lt;/c0&gt;</ept>）を、あなたがあるシフトを実行する、そしてシフト量が範囲<bpt i="1" x="1">&lt;c1&gt;</bpt>0..<it pos="begin" x="2">&lt;lhs&lt;w2&gt;</it>.bit<bpt i="3" x="3">&lt;w3&gt;</bpt>Width<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の中であるのを確実にする必要がある場合に使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the masking right shift operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;&gt;&gt;<ept i="0">&lt;/c0&gt;</ept>) when you need to perform a shift and are sure that the shift amount is in the range <bpt i="1" x="1">&lt;c1&gt;</bpt>0..<it pos="begin" x="2">&lt;lhs&lt;w2&gt;</it>.bit<bpt i="3" x="3">&lt;w3&gt;</bpt>Width<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>マスク右シフト演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;&gt;&gt;<ept i="0">&lt;/c0&gt;</ept>）を、あなたがあるシフトを実行する、そしてシフト量が範囲<bpt i="1" x="1">&lt;c1&gt;</bpt>0..<it pos="begin" x="2">&lt;lhs&lt;w2&gt;</it>.bit<bpt i="3" x="3">&lt;w3&gt;</bpt>Width<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の中であるのを確実にする必要がある場合に使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the nil-coalescing operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>??<ept i="0">&lt;/c0&gt;</ept>) to supply a default value in case the <bpt i="1" x="1">&lt;c1&gt;</bpt>Optional<ept i="1">&lt;/c1&gt;</ept> instance is <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>nil合体演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>??<ept i="0">&lt;/c0&gt;</ept>）を使って、省略時の値を<bpt i="1" x="1">&lt;c1&gt;</bpt>Optional<ept i="1">&lt;/c1&gt;</ept>インスタンスが<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>の場合に提供してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the postfix range operator (postfix <bpt i="0" x="0">&lt;c0&gt;</bpt>...<ept i="0">&lt;/c0&gt;</ept>) to create a partial range of any type that conforms to the <bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>後置完結範囲演算子（後置<bpt i="0" x="0">&lt;c0&gt;</bpt>...<ept i="0">&lt;/c0&gt;</ept>）を使うことで何らかの型の部分的な範囲で<bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>プロトコルに準拠するものを作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the prefix closed range operator (prefix <bpt i="0" x="0">&lt;c0&gt;</bpt>...<ept i="0">&lt;/c0&gt;</ept>) to create a partial range of any type that conforms to the <bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>前置完結範囲演算子（前置<bpt i="0" x="0">&lt;c0&gt;</bpt>...<ept i="0">&lt;/c0&gt;</ept>）を使うことで何らかの型の部分的な範囲で<bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>プロトコルに準拠するものを作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the prefix half-open range operator (prefix <bpt i="0" x="0">&lt;c0&gt;</bpt>..&lt;<ept i="0">&lt;/c0&gt;</ept>) to create a partial range of any type that conforms to the <bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>前置半開範囲演算子（前置<bpt i="0" x="0">&lt;c0&gt;</bpt>..&lt;<ept i="0">&lt;/c0&gt;</ept>）を使うことで何らかの型の部分的な範囲で<bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>プロトコルに準拠するものを作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the “equal to” operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept>) to test whether two sets contain the same elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>「同等」演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept>）を使って、２つの集合が同じ要素らを含むかどうかテストしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use these static properties to access a type's layout.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これらの静的プロパティを使ってある型の持つレイアウトにアクセスしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this equal-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept>) to compare any two optional instances of a type that conforms to the <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この同等演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept>）を使って、<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>プロトコルに準拠するある型の何らかの２つのオプショナルインスタンスを比較してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this initializer to avoid intermediate reallocations of a set’s storage buffer when you know how many elements you’ll insert into the set after creation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがどのくらい多くの要素を作成後の集合に挿入するか知っているならば、このイニシャライザを使って集合の持つストレージバッファの中間的な再割り当てを回避してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this initializer to convert from another integer type when you know the value is within the bounds of this type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザを使って別の整数型から変換してください、値がこの型の境界の内部であるのをあなたが知っている場合は。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this initializer to create a 64-bit integer by converting an <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> with an underlying type of <bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザを使って64ビット整数を作成してください、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>をある基礎をなす型の<bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>で変換することによって</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this initializer to create a new set from an existing sequence, for example, an array or a range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザを使って、新しい集合を既存のシーケンス、例えば、配列またはある範囲から作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this initializer to create a new set from an existing sequence, like an array or a range:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザを使って、新しい集合を既存のシーケンス、配列またはある範囲などから作成してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method only if you need the concrete range it produces.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それが生成する具体的な範囲をあなたが必要とする場合にのみ、このメソッドを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method to avoid a nested result when your transformation produces another <bpt i="0" x="0">&lt;c0&gt;</bpt>Result<ept i="0">&lt;/c0&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたの変換が別の<bpt i="0" x="0">&lt;c0&gt;</bpt>Result<ept i="0">&lt;/c0&gt;</ept>型を生み出す時に、入れ子にされた結果を避けるためにこのメソッドを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method to calculate the full result of a product that would otherwise overflow.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを使うことで、そうしなければオーバーフローするであろう積の完全な結果を計算してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method to calculate the quotient and remainder of a division at the same time.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを使って、除算の商と余りを同時に計算してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method to generate an integer within a specific range when you are using a custom random number generator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを使って、あなたがあつらえの無作為数生成子を使っている場合に、特定の範囲の内のある整数を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method to generate an integer within a specific range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを使って、特定の範囲の内のある整数を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method to receive a sequence of non-optional values when your transformation produces an optional value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを使うことで非オプショナル値のシーケンスを受け取ってください、あなたの変換がオプショナル値を生成する時に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method to receive a single-level collection when your transformation produces a sequence or collection for each element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたの変換が各要素に対してひとつのシーケンスまたはコレクションを生成する場合に、このメソッドを使って単一水準コレクションを受け取ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method to receive a single-level sequence when your transformation produces a sequence or collection for each element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたの変換が各要素に対してひとつのシーケンスまたはコレクションを生成する場合に、このメソッドを使って単一水準シーケンスを受け取ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method to receive an array of non-optional values when your transformation produces an optional value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを使うことで非オプショナル値の配列を受け取ってください、あなたの変換がオプショナル値を生成する時に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method to receive an array of nonoptional values when your transformation produces an optional value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたの変換がオプショナル値を生成する場合に、このメソッドを使って非オプショナル値からなる配列を受け取ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method to remove every element in a collection that meets particular criteria.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを使って、コレクションの中の、特定の基準に合うすべての要素を除去してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method to retrieve the value of this result if it represents a success, or to catch the value if it represents a failure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを使うことで、この結果の値を回収してください、もしそれが成功を表すならば、またはそれが失敗を表すならばその値をキャッチしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method when you need random binary data to generate another value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを、あなたが無作為バイナリデータを別の値を生成するために必要とする場合に使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method when you need to transform the value of a <bpt i="0" x="0">&lt;c0&gt;</bpt>Result<ept i="0">&lt;/c0&gt;</ept> instance when it represents a failure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを使ってください、あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>Result<ept i="0">&lt;/c0&gt;</ept>インスタンスの値をそれが失敗を表す場合に変換する必要がある時に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method when you need to transform the value of a <bpt i="0" x="0">&lt;c0&gt;</bpt>Result<ept i="0">&lt;/c0&gt;</ept> instance when it represents a success.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを使ってください、あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>Result<ept i="0">&lt;/c0&gt;</ept>インスタンスの値をそれが成功を表す場合に変換する必要がある時に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this operator to append the elements of a sequence to the end of range-replaceable collection with same <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この演算子を使って、あるシーケンスに属するいくらかの要素を同じ<bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>型を持つ範囲置換可能なコレクションの終わりに加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Useful mostly to recover the ability to use <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>…<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>, given just an iterator <bpt i="2" x="2">&lt;c2&gt;</bpt>i<ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>主として有用なのは<bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>…<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>を使う能力を、ただイテレータ<bpt i="2" x="2">&lt;c2&gt;</bpt>i<ept i="2">&lt;/c2&gt;</ept>を与えるだけで獲得することです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Users of your remote random number generator can decide how to handle both the success and failure cases:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたの遠隔無作為数生成子のユーザは、成功および失敗の場合の両方をどのように取り扱うか決定できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Uses the nearest ancestor’s implementation of <bpt i="0" x="0">&lt;c0&gt;</bpt>custom<bpt i="1" x="1">&lt;w1&gt;</bpt>Mirror<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to create a mirror for that ancestor.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最も近い先祖のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>custom<bpt i="1" x="1">&lt;w1&gt;</bpt>Mirror<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の実装を使って、その先祖に対するミラーを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using Iterators Directly</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>イテレータを直に使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using Multiple Iterators</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>複数のイテレータを使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using Objective-C Runtime Features in Swift</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-Cランタイム機能をSwiftで使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using a Partial Range as a Sequence</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>部分範囲をシーケンスとして使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using a Range as a Collection of Consecutive Values</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲を隣接値のコレクションとして使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using a negative value as <bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept> is the same as performing a left shift using <bpt i="1" x="1">&lt;c1&gt;</bpt>abs(rhs)<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept>として負の値を使うことは、<bpt i="1" x="1">&lt;c1&gt;</bpt>abs(rhs)<ept i="1">&lt;/c1&gt;</ept>を使って左シフトを実行するのと同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using a negative value as <bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept> is the same as performing a right shift with <bpt i="1" x="1">&lt;c1&gt;</bpt>abs(rhs)<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>負の値を<bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept>として使うことは、<bpt i="1" x="1">&lt;c1&gt;</bpt>abs(rhs)<ept i="1">&lt;/c1&gt;</ept>を使って右シフトを実行するのと同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using a negative value for <bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept> performs a left shift using <bpt i="1" x="1">&lt;c1&gt;</bpt>abs(rhs)<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept>に負の値を使うことは、<bpt i="1" x="1">&lt;c1&gt;</bpt>abs(rhs)<ept i="1">&lt;/c1&gt;</ept>を使って左シフトを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using a negative value for <bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept> performs a right shift using <bpt i="1" x="1">&lt;c1&gt;</bpt>abs(rhs)<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept>に負の値を使うことは、<bpt i="1" x="1">&lt;c1&gt;</bpt>abs(rhs)<ept i="1">&lt;/c1&gt;</ept>を使って右シフトを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using a sequence’s iterator directly gives you access to the same elements in the same order as iterating over that sequence using a <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> loop.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンスのもつイテレータを直に使うことは、あなたに<bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>ループを使ってそのシーケンスに反復するのと同じ要素に同じ順序でアクセスすることを与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using a value for <bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept> that is greater than or equal to the bit width of <bpt i="1" x="1">&lt;c1&gt;</bpt>lhs<ept i="1">&lt;/c1&gt;</ept> is an <bpt i="2" x="2">&lt;e2&gt;</bpt>overshift<ept i="2">&lt;/e2&gt;</ept>, resulting in zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept>に<bpt i="1" x="1">&lt;c1&gt;</bpt>lhs<ept i="1">&lt;/c1&gt;</ept>のビット幅より大きいか等しい値を使うことは、<bpt i="2" x="2">&lt;e2&gt;</bpt>オーバーシフト<ept i="2">&lt;/e2&gt;</ept>、ゼロという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using a value for <bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept> that is greater than or equal to the bit width of <bpt i="1" x="1">&lt;c1&gt;</bpt>lhs<ept i="1">&lt;/c1&gt;</ept> is an <bpt i="2" x="2">&lt;e2&gt;</bpt>overshift<ept i="2">&lt;/e2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept>に<bpt i="1" x="1">&lt;c1&gt;</bpt>lhs<ept i="1">&lt;/c1&gt;</ept>のビット幅より大きいか等しい値を使うことは、<bpt i="2" x="2">&lt;e2&gt;</bpt>オーバーシフト<ept i="2">&lt;/e2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using an Option Set Type</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オプションセット型を使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using any other value for <bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept> performs a left shift on <bpt i="1" x="1">&lt;c1&gt;</bpt>lhs<ept i="1">&lt;/c1&gt;</ept> by that amount.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept>に何か他の値を使うことは、左シフトを<bpt i="1" x="1">&lt;c1&gt;</bpt>lhs<ept i="1">&lt;/c1&gt;</ept>上でその量だけ行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using any other value for <bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept> performs a right shift on <bpt i="1" x="1">&lt;c1&gt;</bpt>lhs<ept i="1">&lt;/c1&gt;</ept> by that amount.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept>に何か他の値を使うことは、右シフトを<bpt i="1" x="1">&lt;c1&gt;</bpt>lhs<ept i="1">&lt;/c1&gt;</ept>上でその量だけ行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using the <bpt i="0" x="0">&lt;c0&gt;</bpt>for<bpt i="1" x="1">&lt;w1&gt;</bpt>Each<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method is distinct from a <bpt i="2" x="2">&lt;c2&gt;</bpt>for<ept i="2">&lt;/c2&gt;</ept>-<bpt i="3" x="3">&lt;c3&gt;</bpt>in<ept i="3">&lt;/c3&gt;</ept> loop in two important ways:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>for<bpt i="1" x="1">&lt;w1&gt;</bpt>Each<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使うことは、<bpt i="2" x="2">&lt;c2&gt;</bpt>for<ept i="2">&lt;/c2&gt;</ept>-<bpt i="3" x="3">&lt;c3&gt;</bpt>in<ept i="3">&lt;/c3&gt;</ept>ループとは２つの重要なやり方においてまったく異なります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using the <bpt i="0" x="0">&lt;c0&gt;</bpt>prefix(through:)<ept i="0">&lt;/c0&gt;</ept> method is equivalent to using a partial closed range as the collection’s subscript.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>prefix(through:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使うことは、部分的な完結範囲をコレクションのもつ添え字として使うことと同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using the <bpt i="0" x="0">&lt;c0&gt;</bpt>prefix(up<bpt i="1" x="1">&lt;w1&gt;</bpt>To:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method is equivalent to using a partial half-open range as the collection’s subscript.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>prefix(up<bpt i="1" x="1">&lt;w1&gt;</bpt>To:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使うことは、部分的な半開範囲をコレクションのもつ添え字として使うことと同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using the <bpt i="0" x="0">&lt;c0&gt;</bpt>return<ept i="0">&lt;/c0&gt;</ept> statement in the <bpt i="1" x="1">&lt;c1&gt;</bpt>body<ept i="1">&lt;/c1&gt;</ept> closure will exit only from the current call to <bpt i="2" x="2">&lt;c2&gt;</bpt>body<ept i="2">&lt;/c2&gt;</ept>, not from any outer scope, and won’t skip subsequent calls.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>return<ept i="0">&lt;/c0&gt;</ept>文を<bpt i="1" x="1">&lt;c1&gt;</bpt>body<ept i="1">&lt;/c1&gt;</ept>クロージャにおいて使うことは、ただ現在の<bpt i="2" x="2">&lt;c2&gt;</bpt>body<ept i="2">&lt;/c2&gt;</ept>への呼び出しから抜け出すだけです、全く外側のスコープからではなくて、そして続いて起こる呼び出しを飛ばしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using the <bpt i="0" x="0">&lt;c0&gt;</bpt>suffix(from:)<ept i="0">&lt;/c0&gt;</ept> method is equivalent to using a partial range from the index as the collection’s subscript.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>suffix(from:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使うことは、インデックスからの部分的範囲をコレクションのもつ添え字として使うことと同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using the Nil-Coalescing Operator</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>nil合体演算子を使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using the half-open range operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>..&lt;<ept i="2">&lt;/c2&gt;</ept>) to form <bpt i="3" x="3">&lt;c3&gt;</bpt>Range<ept i="3">&lt;/c3&gt;</ept> instances is preferred.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>半開範囲演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>..&lt;<ept i="2">&lt;/c2&gt;</ept>）を使って<bpt i="3" x="3">&lt;c3&gt;</bpt>Range<ept i="3">&lt;/c3&gt;</ept>インスタンスを形成することが推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using the raw value of a conforming type streamlines interoperation with Objective-C and legacy APIs and simplifies conformance to other protocols, such as <bpt i="6" x="6">&lt;c6&gt;</bpt>Equatable<ept i="6">&lt;/c6&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt>Comparable<ept i="7">&lt;/c7&gt;</ept>, and <bpt i="8" x="8">&lt;c8&gt;</bpt>Hashable<ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>準拠する型の生の値を使うことは、Objective-CおよびレガシーAPIとの相互運用を能率的にします、そして他のプロトコル、例えば<bpt i="6" x="6">&lt;c6&gt;</bpt>Equatable<ept i="6">&lt;/c6&gt;</ept>、<bpt i="7" x="7">&lt;c7&gt;</bpt>Comparable<ept i="7">&lt;/c7&gt;</ept>、および<bpt i="8" x="8">&lt;c8&gt;</bpt>Hashable<ept i="8">&lt;/c8&gt;</ept>などへの準拠を簡単にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using this approach is prone to mistakes for a few reasons, in ways that can lead to bugs and make it harder to reason about your code:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この取り組みを使うことは、2、3の理由から間違いを起こす傾向があります、バグに至りうるそしてあなたのコードについて論じることをより困難にするやり方で：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Valid indices consist of the position of every element and a “past the end” position that’s not valid for use as a subscript argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>有効なインデックスは、各要素の位置、および添え字引数として使うのに有効でない“終わりを過ぎた”位置から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Valid indices consist of the position of every element and a “past the end” position that’s not valid for use as a subscript.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>有効なインデックスは、各要素の位置、および添え字として使うのに有効でない“終わりを過ぎた”位置から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Vend results as part of an API when you can’t return errors synchronously.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果をAPIの一部として提供します、あなたがエラーを同期的に返すことができない場合に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Visible side effects are therefore strongly discouraged within this property.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>目に見える副作用は、それゆえにこのプロパティ内では強く反対されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Warning</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>警告</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>What’s more, when implemented using specific criteria, adoption of this protocol requires no extra work on your part.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>おまけに、特定の基準を使って実装される時、このプロトコルの採用はあなたの方での余分な作業を必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When <bpt i="0" x="0">&lt;c0&gt;</bpt>Lazy<bpt i="1" x="1">&lt;w1&gt;</bpt>Prefix<bpt i="2" x="2">&lt;w2&gt;</bpt>While<bpt i="3" x="3">&lt;w3&gt;</bpt>Sequence<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> wraps a collection type, the performance of accessing <bpt i="4" x="4">&lt;c4&gt;</bpt>end<bpt i="5" x="5">&lt;w5&gt;</bpt>Index<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> depends on how many elements satisfy the predicate at the start of the collection, and might not offer the usual performance given by the <bpt i="6" x="6">&lt;c6&gt;</bpt>Collection<ept i="6">&lt;/c6&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Lazy<bpt i="1" x="1">&lt;w1&gt;</bpt>Prefix<bpt i="2" x="2">&lt;w2&gt;</bpt>While<bpt i="3" x="3">&lt;w3&gt;</bpt>Sequence<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>がコレクション型をラップする場合、<bpt i="4" x="4">&lt;c4&gt;</bpt>end<bpt i="5" x="5">&lt;w5&gt;</bpt>Index<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>にアクセスする性能はどのくらい多くの要素がこの述部をコレクションの始まりで満たすかに依存します、そして<bpt i="6" x="6">&lt;c6&gt;</bpt>Collection<ept i="6">&lt;/c6&gt;</ept>プロトコルによって与えられる通常の性能を呈さないかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When <bpt i="0" x="0">&lt;c0&gt;</bpt>letters<bpt i="1" x="1">&lt;w1&gt;</bpt>.reduce(into:<bpt i="2" x="2">&lt;w2&gt;</bpt>_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is called, the following steps occur:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>letters<bpt i="1" x="1">&lt;w1&gt;</bpt>.reduce(into:<bpt i="2" x="2">&lt;w2&gt;</bpt>_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が呼び出される時、以下の段階が生じます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When <bpt i="0" x="0">&lt;c0&gt;</bpt>numbers<bpt i="1" x="1">&lt;w1&gt;</bpt>.reduce(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is called, the following steps occur:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>numbers<bpt i="1" x="1">&lt;w1&gt;</bpt>.reduce(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が呼び出される時、以下の段階が生じます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When a partial range uses integers as its lower and upper bounds, or any other type that conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Strideable<ept i="0">&lt;/c0&gt;</ept> protocol with an integer stride, you can use that range in a <bpt i="1" x="1">&lt;c1&gt;</bpt>for<ept i="1">&lt;/c1&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt>in<ept i="2">&lt;/c2&gt;</ept> loop or with any sequence method that doesn’t require that the sequence is finite.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある範囲がそれの下側および上側の境界として整数を使う、または整数歩幅を使う<bpt i="0" x="0">&lt;c0&gt;</bpt>Strideable<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する何らかの他の型を使う場合、あなたはその範囲を<bpt i="1" x="1">&lt;c1&gt;</bpt>for<ept i="1">&lt;/c1&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt>in<ept i="2">&lt;/c2&gt;</ept>ループにおいて、またはシーケンスが有限であることを必要としない何らかのシーケンスのメソッドで使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When a range uses integers as its lower and upper bounds, or any other type that conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Strideable<ept i="0">&lt;/c0&gt;</ept> protocol with an integer stride, you can use that range in a <bpt i="1" x="1">&lt;c1&gt;</bpt>for<ept i="1">&lt;/c1&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt>in<ept i="2">&lt;/c2&gt;</ept> loop or with any sequence or collection method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある範囲がそれの下側および上側の境界として整数を使う、または整数歩幅を使う<bpt i="0" x="0">&lt;c0&gt;</bpt>Strideable<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する何らかの他の型を使う場合、あなたはその範囲を<bpt i="1" x="1">&lt;c1&gt;</bpt>for<ept i="1">&lt;/c1&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt>in<ept i="2">&lt;/c2&gt;</ept>ループにおいて、または何らかのシーケンスまたはコレクションのメソッドで使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When allocating memory for multiple instances of <bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept> using an unsafe pointer, use a multiple of the type’s stride instead of its size.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept>の複数のインスタンスに対して安全でないポインタを使ってメモリをアロケートする場合、それの大きさではなく、その型のもつストライドの倍数を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When an existing element is inserted, the <bpt i="4" x="4">&lt;c4&gt;</bpt>class<bpt i="5" x="5">&lt;w5&gt;</bpt>Days<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> set does not change.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>既存の要素が挿入される時、<bpt i="4" x="4">&lt;c4&gt;</bpt>class<bpt i="5" x="5">&lt;w5&gt;</bpt>Days<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>集合は変化しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When calling a function with a <bpt i="0" x="0">&lt;c0&gt;</bpt>Key<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<bpt i="2" x="2">&lt;w2&gt;</bpt>Pairs<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> parameter, you can pass a Swift dictionary literal without causing a <bpt i="3" x="3">&lt;c3&gt;</bpt>Dictionary<ept i="3">&lt;/c3&gt;</ept> to be created.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>関数を<bpt i="0" x="0">&lt;c0&gt;</bpt>Key<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<bpt i="2" x="2">&lt;w2&gt;</bpt>Pairs<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>パラメータで呼び出す場合、あなたはSwift辞書リテラルを、ある<bpt i="3" x="3">&lt;c3&gt;</bpt>Dictionary<ept i="3">&lt;/c3&gt;</ept>が作成されることを生じさせないで渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When creating an option set, include a <bpt i="0" x="0">&lt;c0&gt;</bpt>raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property in your type declaration.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるオプションセットを作成する場合は、<bpt i="0" x="0">&lt;c0&gt;</bpt>raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティをあなたの型宣言に加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When creating your own option set, implement this initializer with a fixed-width integer, like <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>, as the <bpt i="1" x="1">&lt;c1&gt;</bpt>Raw<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなた独自のオプションセットを作成する時、このイニシャライザを固定長整数、<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>などを<bpt i="1" x="1">&lt;c1&gt;</bpt>Raw<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>型として使って実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When defining your own custom enumeration, you give it a raw type by specifying the raw type as the first item in the enumeration’s type inheritance list.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなた独自のあつらえの列挙を定義している場合、あなたはそれに生の型を与えることを、その生の型を列挙の型継承リストの最初の項目として指定することによって行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When implementing a custom type that conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Set<bpt i="1" x="1">&lt;w1&gt;</bpt>Algebra<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol, you must implement the required initializers and methods.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Set<bpt i="1" x="1">&lt;w1&gt;</bpt>Algebra<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠するあつらえの型を実装する場合、あなたは必須イニシャライザとメソッドを実装する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When implementing lazy operations, wrapping <bpt i="0" x="0">&lt;c0&gt;</bpt>elements<ept i="0">&lt;/c0&gt;</ept> instead of <bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept> can prevent result types from growing an extra <bpt i="2" x="2">&lt;c2&gt;</bpt>Lazy<bpt i="3" x="3">&lt;w3&gt;</bpt>Sequence<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> layer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>遅延に演算を実装するとき、<bpt i="0" x="0">&lt;c0&gt;</bpt>elements<ept i="0">&lt;/c0&gt;</ept>を<bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept>の代わりにラップすることは、結果の型を余分の<bpt i="2" x="2">&lt;c2&gt;</bpt>Lazy<bpt i="3" x="3">&lt;w3&gt;</bpt>Sequence<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>レイヤが増大することを防ぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When providing new APIs that use randomness, provide a version that accepts a generator conforming to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Number<bpt i="2" x="2">&lt;w2&gt;</bpt>Generator<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol as well as a version that uses the default system generator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>無作為さを使う新しいAPIを提供する場合、<bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Number<bpt i="2" x="2">&lt;w2&gt;</bpt>Generator<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する生成子を受け取るバージョンを、それだけでなく省略時のシステム生成子を使うバージョンも提供してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the <bpt i="0" x="0">&lt;c0&gt;</bpt>label<ept i="0">&lt;/c0&gt;</ept> component in not <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>, it may represent the name of a stored property or an active <bpt i="2" x="2">&lt;c2&gt;</bpt>enum<ept i="2">&lt;/c2&gt;</ept> case.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>label<ept i="0">&lt;/c0&gt;</ept>コンポーネントが<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>でない場合、それは格納プロパティの名前またはアクティブな<bpt i="2" x="2">&lt;c2&gt;</bpt>enum<ept i="2">&lt;/c2&gt;</ept>ケース節の名前を表すかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the additive inverse of a value is unrepresentable in a conforming type, the operation should either trap or return an exceptional value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値の加法の逆元が準拠する型において表現可能でない場合、演算は例外値をトラップまたは返すべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the app is first opened, the user is unknown, so the state of the app could be called <bpt i="0" x="0">&lt;e0&gt;</bpt>unregistered<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>アプリが最初に開かれた時、ユーザは誰か分かりません、それでアプリの状態は<bpt i="0" x="0">&lt;e0&gt;</bpt>無登録<ept i="0">&lt;/e0&gt;</ept>と呼ぶことができるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the bit width of <bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept> (the type of <bpt i="1" x="1">&lt;c1&gt;</bpt>source<ept i="1">&lt;/c1&gt;</ept>) is equal to or greater than this type’s bit width, the result is the truncated least-significant bits of <bpt i="2" x="2">&lt;c2&gt;</bpt>source<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept>（<bpt i="1" x="1">&lt;c1&gt;</bpt>source<ept i="1">&lt;/c1&gt;</ept>の型）のビット幅がこの型のもつビット幅と等しいかより大きいならば、結果は<bpt i="2" x="2">&lt;c2&gt;</bpt>source<ept i="2">&lt;/c2&gt;</ept>の先端を切った最下位ビットです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the bit width of <bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept> is less than this type’s bit width, the result is <bpt i="1" x="1">&lt;e1&gt;</bpt>sign-extended<ept i="1">&lt;/e1&gt;</ept> to fill the remaining bits.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept>のビット幅がこの型のもつビット幅より小さいならば、結果は残りのビットを満たすように<bpt i="1" x="1">&lt;e1&gt;</bpt>符号拡張<ept i="1">&lt;/e1&gt;</ept>されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the collection passed to <bpt i="3" x="3">&lt;c3&gt;</bpt>relative(to:)<ept i="3">&lt;/c3&gt;</ept> starts with a different index, that index is used as the lower bound instead.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>relative(to:)<ept i="3">&lt;/c3&gt;</ept>に渡されるコレクションが異なるインデックスで始まる場合、そのインデックスは代わりに下側の境界として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the publisher exhausts the elements in the sequence, the next request causes the publisher to finish.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>パブリッシャーがシーケンスの中の要素を使い尽くす場合、次の要請はパブリッシャーを終了させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the return value is <bpt i="5" x="5">&lt;c5&gt;</bpt>false<ept i="5">&lt;/c5&gt;</ept>, the value of <bpt i="6" x="6">&lt;c6&gt;</bpt>i<ept i="6">&lt;/c6&gt;</ept> is equal to <bpt i="7" x="7">&lt;c7&gt;</bpt>limit<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>戻り値が<bpt i="5" x="5">&lt;c5&gt;</bpt>false<ept i="5">&lt;/c5&gt;</ept>の場合、<bpt i="6" x="6">&lt;c6&gt;</bpt>i<ept i="6">&lt;/c6&gt;</ept>の値は<bpt i="7" x="7">&lt;c7&gt;</bpt>limit<ept i="7">&lt;/c7&gt;</ept>に等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the sequence has been exhausted, the <bpt i="3" x="3">&lt;c3&gt;</bpt>next()<ept i="3">&lt;/c3&gt;</ept> method returns <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのシーケンスが使い尽くされたならば、<bpt i="3" x="3">&lt;c3&gt;</bpt>next()<ept i="3">&lt;/c3&gt;</ept>メソッドは<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the sequence is exhausted, the accumulating value is returned to the caller.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスが使い尽くされる時、蓄積値が呼び出し側へ返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the sequence is exhausted, the last value returned from the closure is returned to the caller.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスが使い尽くされる時、クロージャから返される最後の値が呼び出し側へ返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the set’s <bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept> type is neither a class nor an <bpt i="3" x="3">&lt;c3&gt;</bpt>@objc<ept i="3">&lt;/c3&gt;</ept> protocol, any required bridging of elements occurs at the first access of each element, so the first operation that uses the contents of the set (for example, a membership test) can take O(<bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合の持つ<bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept>型がクラスでも<bpt i="3" x="3">&lt;c3&gt;</bpt>@objc<ept i="3">&lt;/c3&gt;</ept>プロトコルでもない場合、要素のブリッジに必要なあらゆることが要素それぞれの最初のアクセスで起こります、それで集合の内容を使う最初の演算（例えば、帰属テスト）は、O(<bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept>)をとります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When using <bpt i="0" x="0">&lt;c0&gt;</bpt>offset(of:)<ept i="0">&lt;/c0&gt;</ept> with a type imported from a library, don’t assume that future versions of the library will have the same behavior.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>offset(of:)<ept i="0">&lt;/c0&gt;</ept>をあるライブラリからインポートされる型で使う場合、そのライブラリの将来のバージョンが同じ挙動を持つと決めてかからないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When working with a mirror that reflects a bidirectional or random access collection, you may find it useful to “upgrade” instances of this type to <bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Bidirectional<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt>Any<bpt i="4" x="4">&lt;w4&gt;</bpt>Random<bpt i="5" x="5">&lt;w5&gt;</bpt>Access<bpt i="6" x="6">&lt;w6&gt;</bpt>Collection<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>双方向性のまたはランダムなアクセスのコレクションをリフレクとするミラーを扱う場合、あなたはこの型のインスタンスを<bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Bidirectional<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>または<bpt i="3" x="3">&lt;c3&gt;</bpt>Any<bpt i="4" x="4">&lt;w4&gt;</bpt>Random<bpt i="5" x="5">&lt;w5&gt;</bpt>Access<bpt i="6" x="6">&lt;w6&gt;</bpt>Collection<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に「アップグレード」することが役立つのを発見するかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When writing a function, method, or other API that might fail, you use the <bpt i="0" x="0">&lt;c0&gt;</bpt>throws<ept i="0">&lt;/c0&gt;</ept> keyword on the declaration to indicate that the API call can throw an error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>失敗するかもしれない関数、メソッド、または他のAPIを書いている時、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>throws<ept i="0">&lt;/c0&gt;</ept>キーワードをその宣言上で使うことで、そのAPI呼び出しがエラーをスローできることを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you call methods that use random data, such as creating new random values or shuffling a collection, you can pass a <bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Number<bpt i="2" x="2">&lt;w2&gt;</bpt>Generator<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type to be used as the source for randomness.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが無作為データを使うメソッドを呼び出す場合、例えば新しい無作為値を作成するまたはコレクションをシャッフルするなど、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Number<bpt i="2" x="2">&lt;w2&gt;</bpt>Generator<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型を渡して、無作為さの出典として使われるようにできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you create an index into a reversed collection using <bpt i="0" x="0">&lt;c0&gt;</bpt>base<ept i="0">&lt;/c0&gt;</ept>, an index from the underlying collection, the resulting index is the position of the element <bpt i="1" x="1">&lt;e1&gt;</bpt>before<ept i="1">&lt;/e1&gt;</ept> the element referenced by <bpt i="2" x="2">&lt;c2&gt;</bpt>base<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが逆にされたコレクションへのインデックスを、基礎をなすコレクションからのインデックス<bpt i="0" x="0">&lt;c0&gt;</bpt>base<ept i="0">&lt;/c0&gt;</ept>を使って作成する時、結果のインデックスは<bpt i="2" x="2">&lt;c2&gt;</bpt>base<ept i="2">&lt;/c2&gt;</ept>によって参照される要素の<bpt i="1" x="1">&lt;e1&gt;</bpt>前<ept i="1">&lt;/e1&gt;</ept>の要素の位置です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you don’t pass a generator, the default <bpt i="3" x="3">&lt;c3&gt;</bpt>System<bpt i="4" x="4">&lt;w4&gt;</bpt>Random<bpt i="5" x="5">&lt;w5&gt;</bpt>Number<bpt i="6" x="6">&lt;w6&gt;</bpt>Generator<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> type is used.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが生成子を渡さない場合、省略時の<bpt i="3" x="3">&lt;c3&gt;</bpt>System<bpt i="4" x="4">&lt;w4&gt;</bpt>Random<bpt i="5" x="5">&lt;w5&gt;</bpt>Number<bpt i="6" x="6">&lt;w6&gt;</bpt>Generator<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>型が使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがあるコレクションを列挙するとき、各ペアの整数部分は列挙のためのカウンタです、しかし必ずしもペアにされた値のインデックスではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you have a type instead of an instance, use the <bpt i="0" x="0">&lt;c0&gt;</bpt>Memory<bpt i="1" x="1">&lt;w1&gt;</bpt>Layout&lt;T&gt;.size<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> static property instead.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがインスタンスではなくある型を持つ場合、代わりに<bpt i="0" x="0">&lt;c0&gt;</bpt>Memory<bpt i="1" x="1">&lt;w1&gt;</bpt>Layout&lt;T&gt;.size<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>静的プロパティを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you have a type instead of an instance, use the <bpt i="0" x="0">&lt;c0&gt;</bpt>Memory<bpt i="1" x="1">&lt;w1&gt;</bpt>Layout&lt;T&gt;.stride<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> static property instead.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがインスタンスではなくある型を持つ場合、代わりに<bpt i="0" x="0">&lt;c0&gt;</bpt>Memory<bpt i="1" x="1">&lt;w1&gt;</bpt>Layout&lt;T&gt;.stride<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>静的プロパティを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you import an Objective-C API into Swift, you can adopt Swift-only types such as tuples.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがObjective-C APIをSwiftへとインポートする場合、あなたはSwift専用の型、例えばタプルなどを採用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you need a range that includes the last element of a collection, use the half-open range operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>..&lt;<ept i="0">&lt;/c0&gt;</ept>) with <bpt i="1" x="1">&lt;c1&gt;</bpt>end<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがコレクションの最後の要素を含むある範囲を必要とする時は、半開範囲演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>..&lt;<ept i="0">&lt;/c0&gt;</ept>）を<bpt i="1" x="1">&lt;c1&gt;</bpt>end<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>とともに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you need to check whether your collection is empty, use the <bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Empty<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property instead of checking that the <bpt i="2" x="2">&lt;c2&gt;</bpt>count<ept i="2">&lt;/c2&gt;</ept> property is equal to zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのコレクションが空かどうか確認する必要がある場合、<bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Empty<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティを使ってください、<bpt i="2" x="2">&lt;c2&gt;</bpt>count<ept i="2">&lt;/c2&gt;</ept>プロパティがゼロと等しいのを調べるのではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you need to create an instance of an option set, assign one of the type’s static members to your variable or constant.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがあるオプションセットのインスタンスを作成する必要がある場合は、その型のもつ静的メンバの１つをあなたの変数または定数に割り当ててください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you need to indicate that a value is missing, you use the value <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはその値が見つからないことを指し示す必要がある場合、値<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you pass a closure to an API, consider <bpt i="0" x="0">&lt;e0&gt;</bpt>when<ept i="0">&lt;/e0&gt;</ept> that closure will be called relative to the other code in your app.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがクロージャをAPIに渡す場合、クロージャが呼び出されるのはあなたのアプリの他のコードと比較して<bpt i="0" x="0">&lt;e0&gt;</bpt>いつか<ept i="0">&lt;/e0&gt;</ept>を考えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you update your app's state, there's a single variable, <bpt i="5" x="5">&lt;c5&gt;</bpt>state<ept i="5">&lt;/c5&gt;</ept>, to modify, no matter what the transition.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのアプリの持つ状態をあなたが更新する場合、修正するただ１つの変数、<bpt i="5" x="5">&lt;c5&gt;</bpt>state<ept i="5">&lt;/c5&gt;</ept>があるだけです、推移が何であろうと。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you use the <bpt i="2" x="2">&lt;c2&gt;</bpt>lazy<ept i="2">&lt;/c2&gt;</ept> property, you give the standard library explicit permission to store the closure and the sequence in the result, and defer computation until it is needed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが<bpt i="2" x="2">&lt;c2&gt;</bpt>lazy<ept i="2">&lt;/c2&gt;</ept>プロパティを使う場合、あなたは標準ライブラリに明示的な権限を与えて、クロージャとシーケンスを結果に格納します、そして計算をそれが必要とされるまで延期します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you use this option, a subclass’s mirror generates default mirrors even for ancestor classes that conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Custom<bpt i="1" x="1">&lt;w1&gt;</bpt>Reflectable<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがこのオプションを使う場合、下位クラスの持つミラーは省略時のミラーを<bpt i="0" x="0">&lt;c0&gt;</bpt>Custom<bpt i="1" x="1">&lt;w1&gt;</bpt>Reflectable<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する先祖クラスにさえも生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you want to sort a collection of elements that don’t conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept> protocol, pass a closure to this method that returns <bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept> when the first element should be ordered before the second.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠しない要素からなるコレクションをソートしたい場合、最初の要素が２番目の前に並べられるべき場合は<bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>を返すクロージャをこのメソッドに渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you want to sort a sequence of elements that don’t conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept> protocol, pass a predicate to this method that returns <bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept> when the first element should be ordered before the second.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠しない要素からなるシーケンスをソートしたい場合、最初の要素が２番目の前に並べられるべき時は<bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>を返す述部をこのメソッドに渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you're finished using a <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>File<bpt i="2" x="2">&lt;w2&gt;</bpt>Handle<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>, close it using <bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>close<bpt i="5" x="5">&lt;w5&gt;</bpt>File()<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが<bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>File<bpt i="2" x="2">&lt;w2&gt;</bpt>Handle<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>の使用を完了した場合、それを<bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>close<bpt i="5" x="5">&lt;w5&gt;</bpt>File()<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>を使って閉じてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you’re certain that an instance of <bpt i="0" x="0">&lt;c0&gt;</bpt>Optional<ept i="0">&lt;/c0&gt;</ept> contains a value, you can unconditionally unwrap the value by using the forced unwrap operator (postfix <bpt i="1" x="1">&lt;c1&gt;</bpt>!<ept i="1">&lt;/c1&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがある<bpt i="0" x="0">&lt;c0&gt;</bpt>Optional<ept i="0">&lt;/c0&gt;</ept>のインスタンスが値を含むことを確信している場合、あなたはその値を無条件にアンラップすることが強制アンラップ演算子（後置<bpt i="1" x="1">&lt;c1&gt;</bpt>!<ept i="1">&lt;/c1&gt;</ept>）を使って行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you’re ready to create a new <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<bpt i="1" x="1">&lt;w1&gt;</bpt>Pairs<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance, use a dictionary literal as the parameter to the <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<bpt i="3" x="3">&lt;w3&gt;</bpt>Pairs<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> initializer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<bpt i="1" x="1">&lt;w1&gt;</bpt>Pairs<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを作成する準備ができたら、辞書リテラルをパラメータとして<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<bpt i="3" x="3">&lt;w3&gt;</bpt>Pairs<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>イニシャライザに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Whenever you use a <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> loop with an array, set, or any other collection or sequence, you’re using that type’s iterator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>ループを配列、集合、または何らかの他のコレクションやシーケンスとともに使うときはいつでも、あなたはこの型のもつイテレータを使っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Whenever you use multiple iterators (or <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> loops) over a single sequence, be sure you know that the specific sequence supports repeated iteration, either because you know its concrete type or because the sequence is also constrained to the <bpt i="2" x="2">&lt;c2&gt;</bpt>Collection<ept i="2">&lt;/c2&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが複数のイテレータ（または<bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>ループ）をある単一のシーケンスに対して使うときはいつでも、その特定のシーケンスが繰り返される反復をサポートすると確実にあなたが知っているようにしてください、あなたがそれの具体的な型を知っているからかもしくはそのシーケンスもまた<bpt i="2" x="2">&lt;c2&gt;</bpt>Collection<ept i="2">&lt;/c2&gt;</ept>プロトコルに制約されるからかのどちらかで。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Whether the <bpt i="0" x="0">&lt;c0&gt;</bpt>Decoder<ept i="0">&lt;/c0&gt;</ept> has an entry for the given key.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Decoder<ept i="0">&lt;/c0&gt;</ept>が与えられたキーに対して登録項目を持つかどうか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Whether the encountered value was null.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>出くわした値がnullだったかどうか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Whether using an option set or creating your own, you use the raw value of an option set instance to store the instance’s bitfield.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるオプションセットを使用するかあなた自身で作成する場合、あなたはオプションセットインスタンスの生の値を使って、そのインスタンスの持つビットフィールドを格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>While seemingly simple, this capability gives you access to a large number of operations that you can perform on any sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>外見上は単純である一方、この能力はあなたにたくさんの演算へのアクセスを与え、それはあなたがあらゆるシーケンス上で実行可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>With a <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Representable<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type, you can switch back and forth between a custom type and an associated <bpt i="2" x="2">&lt;c2&gt;</bpt>Raw<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type without losing the value of the original <bpt i="4" x="4">&lt;c4&gt;</bpt>Raw<bpt i="5" x="5">&lt;w5&gt;</bpt>Representable<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Representable<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型で、あなたはあつらえの型と関連<bpt i="2" x="2">&lt;c2&gt;</bpt>Raw<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型との間を行ったり戻ったり切り替えることが元の<bpt i="4" x="4">&lt;c4&gt;</bpt>Raw<bpt i="5" x="5">&lt;w5&gt;</bpt>Representable<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>型の値の損失なしに可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>With these annotations, Swift imports the <bpt i="0" x="0">&lt;c0&gt;</bpt>My<bpt i="1" x="1">&lt;w1&gt;</bpt>List<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type without using any implicitly wrapped optionals:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これら注釈で、Swiftは<bpt i="0" x="0">&lt;c0&gt;</bpt>My<bpt i="1" x="1">&lt;w1&gt;</bpt>List<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型を何らかの暗黙的にラップされるオプショナルを使うことなしにインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>With this extension, any sequence with elements that conform to <bpt i="0" x="0">&lt;c0&gt;</bpt>Numeric<ept i="0">&lt;/c0&gt;</ept> has the <bpt i="1" x="1">&lt;c1&gt;</bpt>doubling<bpt i="2" x="2">&lt;w2&gt;</bpt>All()<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この拡張で、<bpt i="0" x="0">&lt;c0&gt;</bpt>Numeric<ept i="0">&lt;/c0&gt;</ept>に準拠する要素をもつあらゆるシーケンスは、<bpt i="1" x="1">&lt;c1&gt;</bpt>doubling<bpt i="2" x="2">&lt;w2&gt;</bpt>All()<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>メソッドを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>With this type and extension method, you can call <bpt i="0" x="0">&lt;c0&gt;</bpt>.lazy<bpt i="1" x="1">&lt;w1&gt;</bpt>.scan(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> on any sequence to create a lazily computed scan.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型と拡張メソッドで、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>.lazy<bpt i="1" x="1">&lt;w1&gt;</bpt>.scan(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をあらゆるシーケンス上で呼び出して、遅延に計算される走査を作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Within a section of code demarcated by the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_ASSUME<bpt i="2" x="2">&lt;w2&gt;</bpt>_NONNULL<bpt i="3" x="3">&lt;w3&gt;</bpt>_BEGIN<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>NS<bpt i="5" x="5">&lt;w5&gt;</bpt>_ASSUME<bpt i="6" x="6">&lt;w6&gt;</bpt>_NONNULL<bpt i="7" x="7">&lt;w7&gt;</bpt>_END<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> macros, you only need to annotate the nullable type declarations.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_ASSUME<bpt i="2" x="2">&lt;w2&gt;</bpt>_NONNULL<bpt i="3" x="3">&lt;w3&gt;</bpt>_BEGIN<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>NS<bpt i="5" x="5">&lt;w5&gt;</bpt>_ASSUME<bpt i="6" x="6">&lt;w6&gt;</bpt>_NONNULL<bpt i="7" x="7">&lt;w7&gt;</bpt>_END<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>マクロによって境界線を引かれるコード区画内で、あなたはヌル可能性宣言に注釈を付ける必要だけがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Without a nullability annotation or with a null_resettable annotation—Imported as implicitly unwrapped optionals</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ヌル可能性注釈なしまたはnull_resettable注釈あり — 暗黙的にアンラップされるオプショナルとしてインポートされます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Working with Foundation Ranges</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Foundation Rangeを扱う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Working with Subscribers</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>加入者を扱う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Wrappers for Algorithms</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>アルゴリズムに対するラッパー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Writable Key Paths</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>書き込み可能なキーパス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Writing Failable Asynchronous APIs</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>失敗できる非同期APIを記述する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Writing code that depends on the completion handler being called is dangerous.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>呼び出される完了ハンドラに頼るコードを書くことは危険です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You also use this method to sort elements that conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept> protocol in descending order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはまた、このメソッドを使って<bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する要素を降順でソートすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You apply the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_SWIFT<bpt i="2" x="2">&lt;w2&gt;</bpt>_NAME<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> macro to an individual type, method, or function declaration in Objective-C.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_SWIFT<bpt i="2" x="2">&lt;w2&gt;</bpt>_NAME<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>マクロを個別の型、メソッド、または関数宣言にObjective-Cにおいて適用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You are expected to construct and—if necessary—destroy objects there yourself, using the APIs on <bpt i="2" x="2">&lt;c2&gt;</bpt>Unsafe<bpt i="3" x="3">&lt;w3&gt;</bpt>Mutable<bpt i="4" x="4">&lt;w4&gt;</bpt>Pointer&lt;Element&gt;<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、オブジェクトの組み立てと—必要ならば—破壊をそこであなた自身で、<bpt i="2" x="2">&lt;c2&gt;</bpt>Unsafe<bpt i="3" x="3">&lt;w3&gt;</bpt>Mutable<bpt i="4" x="4">&lt;w4&gt;</bpt>Pointer&lt;Element&gt;<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>上でAPIを使って行うことを当然期待されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can add extensions to extensible enumerations later in your Swift code.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは拡張をいくつか加えて、Swiftコードにおいて後で列挙を拡張できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also combine, exclude, or subtract the elements of two sets:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはまた、結合、排他、または差引を行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also perform unconditional optional chaining by using the postfix <bpt i="0" x="0">&lt;c0&gt;</bpt>!<ept i="0">&lt;/c0&gt;</ept> operator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはまた、無条件のオプショナル連鎖を実行することが、後置<bpt i="0" x="0">&lt;c0&gt;</bpt>!<ept i="0">&lt;/c0&gt;</ept>演算子を使って行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also reorder, combine, and rename parameters so the API matches other Swift APIs.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはまた、パラメータを再配列、結合、そして改名できます、それでそのAPIは他のSwift APIと調和します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also use literals to specify values for one or more cases.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはまた、リテラルを使うことで値を１つ以上のケース節に指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also use this operator to compare a non-optional value to an optional that wraps the same type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはまた、この演算子を使って非オプショナル値を、同じ型をラップするオプショナル値と比較することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can annotate declarations in your Objective-C code to indicate whether an instance can have a null or <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、あなたのObjective-Cコードの中の宣言に注釈をつけることで、あるインスタンスがヌルまたは<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>値を持つことが可能かどうかを指し示せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can bridge between <bpt i="0" x="0">&lt;c0&gt;</bpt>Set<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>NSSet<ept i="1">&lt;/c1&gt;</ept> using the <bpt i="2" x="2">&lt;c2&gt;</bpt>as<ept i="2">&lt;/c2&gt;</ept> operator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>Set<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>NSSet<ept i="1">&lt;/c1&gt;</ept>の間を<bpt i="2" x="2">&lt;c2&gt;</bpt>as<ept i="2">&lt;/c2&gt;</ept>演算子を使ってブリッジできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can build a sequence type that lazily computes the elements in the result of a scan:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、ある走査の結果の中の要素それらを遅延に計算するシーケンス型を構築できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can call both functions the same way: with a trailing closure and no other arguments.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、両方の関数を同じ方法で呼び出せます：後付クロージャとともにそして他の引数なしで。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can check the equality of instances of any <bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Integer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> types using the equal-to operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>==<ept i="2">&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、何らかの<bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Integer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のインスタンスの同等性を同等演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>==<ept i="2">&lt;/c2&gt;</ept>）使って確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can check the inequality of instances of any <bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Integer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> types using the not-equal-to operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>!=<ept i="2">&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、何らかの<bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Integer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のインスタンスの不等性を不等演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>!=<ept i="2">&lt;/c2&gt;</ept>）使って確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can compare instances of any <bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Integer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> types using the greater-than operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>&gt;<ept i="2">&lt;/c2&gt;</ept>), even if the two instances are of different types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、何らかの<bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Integer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のインスタンスをより大きい演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>&gt;<ept i="2">&lt;/c2&gt;</ept>）を使って比較できます、２つのインスタンスが異なる型であるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can compare instances of any <bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Integer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> types using the greater-than-or-equal-to operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>&gt;=<ept i="2">&lt;/c2&gt;</ept>), even if the two instances are of different types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、何らかの<bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Integer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のインスタンスをより大きいか等しい演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>&gt;=<ept i="2">&lt;/c2&gt;</ept>）使って比較できます、２つのインスタンスが異なる型であるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can compare instances of any <bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Integer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> types using the less-than operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>&lt;<ept i="2">&lt;/c2&gt;</ept>), even if the two instances are of different types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、何らかの<bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Integer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のインスタンスをより小さい演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>&lt;<ept i="2">&lt;/c2&gt;</ept>）を使って比較できます、２つのインスタンスが異なる型であるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can compare instances of any <bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Integer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> types using the less-than-or-equal-to operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>&lt;=<ept i="2">&lt;/c2&gt;</ept>), even if the two instances are of different types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、何らかの<bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Integer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のインスタンスをより小さいか等しい演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>&lt;=<ept i="2">&lt;/c2&gt;</ept>）使って比較できます、２つのインスタンスが異なる型であるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can confirm the data value’s underlying type by retrieving a non-<bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept> value from <bpt i="6" x="6">&lt;a6&gt;</bpt><bpt i="7" x="7">&lt;c7&gt;</bpt>int<bpt i="8" x="8">&lt;w8&gt;</bpt>Value<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept><ept i="6">&lt;/a6&gt;</ept> or by inspecting the <bpt i="9" x="9">&lt;a9&gt;</bpt><bpt i="10" x="10">&lt;c10&gt;</bpt>type<ept i="10">&lt;/c10&gt;</ept><ept i="9">&lt;/a9&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、データ値のもつ基礎をなす型を確認することが、非<bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept>値を<bpt i="6" x="6">&lt;a6&gt;</bpt><bpt i="7" x="7">&lt;c7&gt;</bpt>int<bpt i="8" x="8">&lt;w8&gt;</bpt>Value<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept><ept i="6">&lt;/a6&gt;</ept>から回収することによって、または<bpt i="9" x="9">&lt;a9&gt;</bpt><bpt i="10" x="10">&lt;c10&gt;</bpt>type<ept i="10">&lt;/c10&gt;</ept><ept i="9">&lt;/a9&gt;</ept>プロパティを調査することによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can create a <bpt i="0" x="0">&lt;c0&gt;</bpt>Counter<ept i="0">&lt;/c0&gt;</ept> instance from an integer value between 1 and 5 by using the <bpt i="1" x="1">&lt;c1&gt;</bpt>init?(raw<bpt i="2" x="2">&lt;w2&gt;</bpt>Value:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> initializer declared in the <bpt i="3" x="3">&lt;c3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Representable<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>Counter<ept i="0">&lt;/c0&gt;</ept>インスタンスを１と５の間の整数値から作成することが、<bpt i="1" x="1">&lt;c1&gt;</bpt>Raw<bpt i="2" x="2">&lt;w2&gt;</bpt>Representable<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>プロトコルにおいて宣言される<bpt i="3" x="3">&lt;c3&gt;</bpt>init?(raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Value:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>イニシャライザを使うことによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can create a set with any element type that conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠するあらゆる要素型を使って集合を作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can expect faster execution when the collections share many common elements, or if <bpt i="6" x="6">&lt;c6&gt;</bpt>Element<ept i="6">&lt;/c6&gt;</ept> conforms to <bpt i="7" x="7">&lt;c7&gt;</bpt>Hashable<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはより速い遂行を予想できます、コレクションそれらが多くの普通の要素を共有する場合は、またはもし<bpt i="6" x="6">&lt;c6&gt;</bpt>Element<ept i="6">&lt;/c6&gt;</ept>が<bpt i="7" x="7">&lt;c7&gt;</bpt>Hashable<ept i="7">&lt;/c7&gt;</ept>に準拠するならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can expect faster execution when the collections share many common elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはより速い遂行を予想できます、コレクションそれらが多くの普通の要素を共有する場合は。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can improve the architecture, logic, and performance of one of your Objective-C apps by replacing pieces of it in Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、あなたのObjective-Cアプリのうちの１つのアーキテクチャ、論理、そして性能を、それの幾つかの区画を置き換えることによって改善できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can initialize the <bpt i="1" x="1">&lt;c1&gt;</bpt>Countdown<ept i="1">&lt;/c1&gt;</ept> sequence with a starting integer and then iterate over the count down to zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="1" x="1">&lt;c1&gt;</bpt>Countdown<ept i="1">&lt;/c1&gt;</ept>シーケンスをある開始点整数で初期化してそれからカウントダウンをゼロまでずっと反復することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can iterate through a set’s unordered elements with a <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> loop.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、集合の持つ順序付けられない要素を始めから終わりまで反復することが<bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>で可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can modify a set in place by using these methods’ mutating counterparts: <bpt i="0" x="0">&lt;c0&gt;</bpt>form<bpt i="1" x="1">&lt;w1&gt;</bpt>Union(_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>form<bpt i="3" x="3">&lt;w3&gt;</bpt>Intersection(_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>form<bpt i="5" x="5">&lt;w5&gt;</bpt>Symmetric<bpt i="6" x="6">&lt;w6&gt;</bpt>Difference(_:)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, and <bpt i="7" x="7">&lt;c7&gt;</bpt>subtract(_:)<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはある集合をその場で修正することがこれらのメソッドの変更を行う相当物：<bpt i="0" x="0">&lt;c0&gt;</bpt>form<bpt i="1" x="1">&lt;w1&gt;</bpt>Union(_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>form<bpt i="3" x="3">&lt;w3&gt;</bpt>Intersection(_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>、<bpt i="4" x="4">&lt;c4&gt;</bpt>form<bpt i="5" x="5">&lt;w5&gt;</bpt>Symmetric<bpt i="6" x="6">&lt;w6&gt;</bpt>Difference(_:)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>、そして<bpt i="7" x="7">&lt;c7&gt;</bpt>subtract(_:)<ept i="7">&lt;/c7&gt;</ept>を使うことで可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can override any of the protocol’s required methods to provide your own custom implementation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、何らかのこのプロトコルの持つ必須メソッドをオーバーライドして、あなた独自のあつらえの実装を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can reverse a collection without allocating new space for its elements by calling this <bpt i="0" x="0">&lt;c0&gt;</bpt>reversed()<ept i="0">&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、あるコレクションを逆順にすることがそれの要素に対して新しい空間を割り当てることなく<bpt i="0" x="0">&lt;c0&gt;</bpt>reversed()<ept i="0">&lt;/c0&gt;</ept>メソッドによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can set up your Swift class to integrate Objective-C behavior by subclassing Objective-C classes, adopting Objective-C protocols, and more.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、あなたのスウィフトクラスをObjective-Cクラスのサブクラスにすること、Objective-Cプロトコルを採用すること、そしてもっと多くのことによって、Objective-C挙動に溶け込むように準備することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can simplify the process of annotating your Objective-C code by marking entire regions as audited for nullability.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、あなたのObjective-Cコードに注釈を付ける行程を領域全体をヌル可能性について監査されると印することによって簡素化できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can sort any mutable collection of elements that conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept> protocol by calling this method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する要素からなるあらゆる可変の配列をこのメソッドを呼び出すことによってソートできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can sort any sequence of elements that conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept> protocol by calling this method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはいくらかの要素からなる何らかのシーケンスで<bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠するものをこのメソッドを呼び出すことによってソートする（並び替える）ことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can subscript a collection with any valid index other than the collection’s end index.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、そのコレクションの末尾インデックスの以外のあらゆる有効なインデックスで、コレクションに対して添え字を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can think of additional cases you might add later</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが後で加えるかもしれない追加のケース節を考える可能性があるならば</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use <bpt i="0" x="0">&lt;c0&gt;</bpt>Memory<bpt i="1" x="1">&lt;w1&gt;</bpt>Layout<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> as a source of information about a type when allocating or binding memory using raw pointers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Memory<bpt i="1" x="1">&lt;w1&gt;</bpt>Layout<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をある型についての情報源として使うことが、生のポインタを使ってメモリをアロケートまたはバインドする時に可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use <bpt i="0" x="0">&lt;c0&gt;</bpt>pop<bpt i="1" x="1">&lt;w1&gt;</bpt>Last()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to remove the last element of a collection that might be empty.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>pop<bpt i="1" x="1">&lt;w1&gt;</bpt>Last()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使って、空であるかもしれないコレクションの最後の要素を削除できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use a <bpt i="0" x="0">&lt;c0&gt;</bpt>Partial<bpt i="1" x="1">&lt;w1&gt;</bpt>Range<bpt i="2" x="2">&lt;w2&gt;</bpt>Through<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、あるコレクションのインデックスからなる、<bpt i="0" x="0">&lt;c0&gt;</bpt>Partial<bpt i="1" x="1">&lt;w1&gt;</bpt>Range<bpt i="2" x="2">&lt;w2&gt;</bpt>Through<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを使うことで、コレクションの始まりからこの部分範囲の上側の境界までの、そしてそれを含んでいる範囲を表すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use a <bpt i="0" x="0">&lt;c0&gt;</bpt>Partial<bpt i="1" x="1">&lt;w1&gt;</bpt>Range<bpt i="2" x="2">&lt;w2&gt;</bpt>Through<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance to quickly check if a value is contained in a particular range of values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>Partial<bpt i="1" x="1">&lt;w1&gt;</bpt>Range<bpt i="2" x="2">&lt;w2&gt;</bpt>Through<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを使うことで、ある値が特定の範囲に属するいくつかの値の中に含まれているかどうか素早く調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use a <bpt i="0" x="0">&lt;c0&gt;</bpt>Partial<bpt i="1" x="1">&lt;w1&gt;</bpt>Range<bpt i="2" x="2">&lt;w2&gt;</bpt>Up<bpt i="3" x="3">&lt;w3&gt;</bpt>To<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、あるコレクションのインデックスからなる、<bpt i="0" x="0">&lt;c0&gt;</bpt>Partial<bpt i="1" x="1">&lt;w1&gt;</bpt>Range<bpt i="2" x="2">&lt;w2&gt;</bpt>Up<bpt i="3" x="3">&lt;w3&gt;</bpt>To<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを使うことで、コレクションの始まりからこの部分範囲の上側の境界までの、そしてそれを含んでいる範囲を表すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use a <bpt i="0" x="0">&lt;c0&gt;</bpt>Partial<bpt i="1" x="1">&lt;w1&gt;</bpt>Range<bpt i="2" x="2">&lt;w2&gt;</bpt>Up<bpt i="3" x="3">&lt;w3&gt;</bpt>To<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance to quickly check if a value is contained in a particular range of values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>Partial<bpt i="1" x="1">&lt;w1&gt;</bpt>Range<bpt i="2" x="2">&lt;w2&gt;</bpt>Up<bpt i="3" x="3">&lt;w3&gt;</bpt>To<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを使うことで、ある値が特定の範囲に属するいくつかの値の中に含まれているかどうか素早く調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use a <bpt i="0" x="0">&lt;c0&gt;</bpt>Range<ept i="0">&lt;/c0&gt;</ept> instance to quickly check if a value is contained in a particular range of values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>Range<ept i="0">&lt;/c0&gt;</ept>インスタンスを使うことで、ある値が特定の範囲に属するいくつかの値の中に含まれているかどうか素早く調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use a partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、あるコレクションのもつインデックスからなる部分範囲を使うことで、その部分範囲の下側の境界からそのコレクションの終わりまでの範囲を表すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use a partial range to quickly check if a value is contained in a particular range of values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、部分範囲を使って、ある値がいくつの値からなる部分範囲に含まれるかどうかを素早く調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use an array literal anywhere a set is expected by the type context.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、型コンテキストによって集合が予期される何処ででも配列リテラルを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use an enumeration to specify the exact states needed for your app.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは列挙を使って、あなたのアプリに必要とされる正確な状態を指定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use nullability annotations in your Objective-C code to designate whether a parameter type, property type, or return type is nullable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、ヌル可能性注釈をあなたのObjective-Cコードにおいて使用して、パラメータ型、プロパティ型、または戻り値がヌル可能性であるかどうかを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use one of the <bpt i="2" x="2">&lt;a2&gt;</bpt><bpt i="3" x="3">&lt;c3&gt;</bpt>List<bpt i="4" x="4">&lt;w4&gt;</bpt>Format<bpt i="5" x="5">&lt;w5&gt;</bpt>Style<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept><ept i="2">&lt;/a2&gt;</ept> static factory methods to create a custom list format style as a parameter to the method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="2" x="2">&lt;a2&gt;</bpt><bpt i="3" x="3">&lt;c3&gt;</bpt>List<bpt i="4" x="4">&lt;w4&gt;</bpt>Format<bpt i="5" x="5">&lt;w5&gt;</bpt>Style<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept><ept i="2">&lt;/a2&gt;</ept>静的ファクトリメソッドの１つを使って、あつらえのリスト書式形式をこのメソッドへのパラメータとして作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use the <bpt i="0" x="0">&lt;c0&gt;</bpt>relative(to:)<ept i="0">&lt;/c0&gt;</ept> method to convert a range expression, which could be missing one or both of its endpoints, into a concrete range that is bounded on both sides.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>relative(to:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使うことによって、それの端点の両方または１つを抜かすことができる範囲式を、両方の側で閉ざされた具体的な範囲へと変換できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use the <bpt i="4" x="4">&lt;c4&gt;</bpt>magnitude<ept i="4">&lt;/c4&gt;</ept> property in operations that are simpler to implement in terms of unsigned values, such as printing the value of an integer, which is just printing a ‘-’ character in front of an absolute value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="4" x="4">&lt;c4&gt;</bpt>magnitude<ept i="4">&lt;/c4&gt;</ept>プロパティを、ずっと単純に符号なしの値に関して実装する演算において使用できます、例えば整数の値を印字することなど、それはちょっと「-」文字を絶対値の前に印字しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use the pattern-matching operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>~=<ept i="0">&lt;/c0&gt;</ept>) to test whether a value is included in a range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、このパターンマッチング演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>~=<ept i="0">&lt;/c0&gt;</ept>）を使うことで、ある値がある範囲に含まれるかどうか検査できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use the predicate to check for an element of a type that doesn’t conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept> protocol, such as the <bpt i="1" x="1">&lt;c1&gt;</bpt>HTTPResponse<ept i="1">&lt;/c1&gt;</ept> enumeration in this example.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは述部を使って、<bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠しない型、例えばこの例での<bpt i="1" x="1">&lt;c1&gt;</bpt>HTTPResponse<ept i="1">&lt;/c1&gt;</ept>列挙などの要素に対して調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use the predicate to find an element of a type that doesn’t conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept> protocol or to find an element that matches particular criteria.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは述部を使って、<bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠しない型の要素を見つける、または特定の基準に合致する要素を見つけることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use the same or a different name than your Objective-C class.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、あなたのObjective-Cクラスと同じまたは異なる名前を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use the unary plus operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>+<ept i="0">&lt;/c0&gt;</ept>) to provide symmetry in your code for positive numbers when also using the unary minus operator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、単行プラス演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>+<ept i="0">&lt;/c0&gt;</ept>）を使うことで、均整美をあなたのコードにおいて正の数に対して単行マイナス演算子もまた使う場合に提供できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use this method to find the distance in bytes that can be added to a pointer of type <bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept> to get a pointer to the property referenced by <bpt i="1" x="1">&lt;c1&gt;</bpt>key<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはこのメソッドを使ってバイトでの隔たりを見つけることができます、それは型<bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept>のポインタに加えることで、<bpt i="1" x="1">&lt;c1&gt;</bpt>key<ept i="1">&lt;/c1&gt;</ept>によって参照されるプロパティへのポインタを得ることができるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、あるコレクションのインデックスからなる、この型の部分的範囲を使うことで、その部分的な範囲の下側の境界からそのコレクションの終わりまでの範囲を表すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、あるコレクションのインデックスからなる、この型の部分的範囲を使うことで、コレクションの始まりからその部分的な範囲の上側の境界までの、そしてそれを含んでいる範囲を表すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、あるコレクションのインデックスからなる、この型の部分的範囲を使うことで、コレクションの始まりからその部分的な範囲の上側の境界までの、しかしそれを含んでいない範囲を表すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can write generic methods that operate on any numeric type in the standard library by using the <bpt i="1" x="1">&lt;c1&gt;</bpt>Numeric<ept i="1">&lt;/c1&gt;</ept> protocol as a generic constraint.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="1" x="1">&lt;c1&gt;</bpt>Numeric<ept i="1">&lt;/c1&gt;</ept>プロトコルを総称体制約として使うことで、標準ライブラリのあらゆる数値型上で作用する総称体メソッドを書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can't reorder or change the number of arguments for type members imported using the <bpt i="0" x="0">&lt;c0&gt;</bpt>CF<bpt i="1" x="1">&lt;w1&gt;</bpt>_SWIFT<bpt i="2" x="2">&lt;w2&gt;</bpt>_NAME<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> macro.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>CF<bpt i="1" x="1">&lt;w1&gt;</bpt>_SWIFT<bpt i="2" x="2">&lt;w2&gt;</bpt>_NAME<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>マクロを使ってインポートされる型メンバーに対する引数の数を再配列または変更できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You cannot use <bpt i="0" x="0">&lt;c0&gt;</bpt>*<ept i="0">&lt;/c0&gt;</ept> with arguments of different types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>*<ept i="0">&lt;/c0&gt;</ept>をそれぞれが異なる型である引数で使うことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You cannot use <bpt i="0" x="0">&lt;c0&gt;</bpt>+<ept i="0">&lt;/c0&gt;</ept> with arguments of different types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>+<ept i="0">&lt;/c0&gt;</ept>をそれぞれが異なる型である引数で使うことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You cannot use <bpt i="0" x="0">&lt;c0&gt;</bpt>-<ept i="0">&lt;/c0&gt;</ept> with arguments of different types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>-<ept i="0">&lt;/c0&gt;</ept>をそれぞれが異なる型である引数で使うことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You cannot use a <bpt i="0" x="0">&lt;c0&gt;</bpt>break<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>continue<ept i="1">&lt;/c1&gt;</ept> statement to exit the current call of the <bpt i="2" x="2">&lt;c2&gt;</bpt>body<ept i="2">&lt;/c2&gt;</ept> closure or skip subsequent calls.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>break<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>continue<ept i="1">&lt;/c1&gt;</ept>文を使って、<bpt i="2" x="2">&lt;c2&gt;</bpt>body<ept i="2">&lt;/c2&gt;</ept>クロージャの現在の呼び出しを抜け出したり、または続いて起こる呼び出しを飛ばしたりできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You create <bpt i="0" x="0">&lt;c0&gt;</bpt>Partial<bpt i="1" x="1">&lt;w1&gt;</bpt>Range<bpt i="2" x="2">&lt;w2&gt;</bpt>From<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instances by using the postfix range operator (postfix <bpt i="3" x="3">&lt;c3&gt;</bpt>...<ept i="3">&lt;/c3&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Partial<bpt i="1" x="1">&lt;w1&gt;</bpt>Range<bpt i="2" x="2">&lt;w2&gt;</bpt>From<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを後置範囲演算子（<bpt i="3" x="3">&lt;c3&gt;</bpt>...<ept i="3">&lt;/c3&gt;</ept>）を使って作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You create <bpt i="0" x="0">&lt;c0&gt;</bpt>Partial<bpt i="1" x="1">&lt;w1&gt;</bpt>Range<bpt i="2" x="2">&lt;w2&gt;</bpt>Through<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instances by using the prefix closed range operator (prefix <bpt i="3" x="3">&lt;c3&gt;</bpt>...<ept i="3">&lt;/c3&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Partial<bpt i="1" x="1">&lt;w1&gt;</bpt>Range<bpt i="2" x="2">&lt;w2&gt;</bpt>Through<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを後置範囲演算子（<bpt i="3" x="3">&lt;c3&gt;</bpt>...<ept i="3">&lt;/c3&gt;</ept>）を使って作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You create <bpt i="0" x="0">&lt;c0&gt;</bpt>Partial<bpt i="1" x="1">&lt;w1&gt;</bpt>Range<bpt i="2" x="2">&lt;w2&gt;</bpt>Up<bpt i="3" x="3">&lt;w3&gt;</bpt>To<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instances by using the prefix half-open range operator (prefix <bpt i="4" x="4">&lt;c4&gt;</bpt>..&lt;<ept i="4">&lt;/c4&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Partial<bpt i="1" x="1">&lt;w1&gt;</bpt>Range<bpt i="2" x="2">&lt;w2&gt;</bpt>Up<bpt i="3" x="3">&lt;w3&gt;</bpt>To<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを後置範囲演算子（<bpt i="4" x="4">&lt;c4&gt;</bpt>..&lt;<ept i="4">&lt;/c4&gt;</ept>）を使って作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You create a <bpt i="0" x="0">&lt;c0&gt;</bpt>Range<ept i="0">&lt;/c0&gt;</ept> instance by using the half-open range operator (<bpt i="1" x="1">&lt;c1&gt;</bpt>..&lt;<ept i="1">&lt;/c1&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Range<ept i="0">&lt;/c0&gt;</ept>インスタンスを、半開範囲演算子（<bpt i="1" x="1">&lt;c1&gt;</bpt>..&lt;<ept i="1">&lt;/c1&gt;</ept>）を使うことで作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You create an instance of the <bpt i="0" x="0">&lt;c0&gt;</bpt>Repeated<ept i="0">&lt;/c0&gt;</ept> collection by calling the <bpt i="1" x="1">&lt;c1&gt;</bpt>repeat<bpt i="2" x="2">&lt;w2&gt;</bpt>Element(_:<bpt i="3" x="3">&lt;w3&gt;</bpt>count:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Repeated<ept i="0">&lt;/c0&gt;</ept>コレクションのインスタンスを<bpt i="1" x="1">&lt;c1&gt;</bpt>repeat<bpt i="2" x="2">&lt;w2&gt;</bpt>Element(_:<bpt i="3" x="3">&lt;w3&gt;</bpt>count:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>関数を呼び出すことによって作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You don't need to rewrite your entire app in Swift at once.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、あなたのアプリ全体を一度にSwiftに書き直す必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You initialize a <bpt i="0" x="0">&lt;c0&gt;</bpt>Key<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<bpt i="2" x="2">&lt;w2&gt;</bpt>Pairs<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance using a Swift dictionary literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Key<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<bpt i="2" x="2">&lt;w2&gt;</bpt>Pairs<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスをSwift辞書リテラルを使って初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You make part of an API unavailable in Swift as part of introducing new Swift APIs that supersede parts of the existing Objective-C API.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、Swiftで利用可能でないAPIの部分を、既存のObjective-C APIの部分に取って代わる新しいSwift APIを導入する部分とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You might encounter Objective-C code that uses the older <bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_STRING<bpt i="2" x="2">&lt;w2&gt;</bpt>_ENUM<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>NS<bpt i="4" x="4">&lt;w4&gt;</bpt>_EXTENSIBLE<bpt i="5" x="5">&lt;w5&gt;</bpt>_STRING<bpt i="6" x="6">&lt;w6&gt;</bpt>_ENUM<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> macros, which were used to group string constants.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、より古い<bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_STRING<bpt i="2" x="2">&lt;w2&gt;</bpt>_ENUM<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>および<bpt i="3" x="3">&lt;c3&gt;</bpt>NS<bpt i="4" x="4">&lt;w4&gt;</bpt>_EXTENSIBLE<bpt i="5" x="5">&lt;w5&gt;</bpt>_STRING<bpt i="6" x="6">&lt;w6&gt;</bpt>_ENUM<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>マクロを使うObjective-Cコードに直面するかもしれません、それは文字列定数をグループにするために使われました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You must not call this method if any other copy of this iterator has been advanced with a call to its <bpt i="0" x="0">&lt;c0&gt;</bpt>next()<ept i="0">&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、このイテレータの何か他のコピーがそれの<bpt i="0" x="0">&lt;c0&gt;</bpt>next()<ept i="0">&lt;/c0&gt;</ept>メソッドを呼び出すことで前に進められるならば、このメソッドを呼び出す必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You must unwrap the value of an <bpt i="0" x="0">&lt;c0&gt;</bpt>Optional<ept i="0">&lt;/c0&gt;</ept> instance before you can use it in many contexts.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、あなたがそれを多くの文脈において使う前に、<bpt i="0" x="0">&lt;c0&gt;</bpt>Optional<ept i="0">&lt;/c0&gt;</ept>インスタンスの値をアンラップしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You need to know how each function calls its closure if you write code that relies on a specific execution order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、各関数がそれのクロージャを呼び出す方法を知る必要があります、もしあなたがある明確な実行順序を当てにするコードを書くならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You preserve the return value or thrown error from a throwing expression using the <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>Result<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> enumeration’s <bpt i="2" x="2">&lt;a2&gt;</bpt><bpt i="3" x="3">&lt;c3&gt;</bpt>init(catching:)<ept i="3">&lt;/c3&gt;</ept><ept i="2">&lt;/a2&gt;</ept> initializer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはスローする式から戻り値またはスローされたエラーを、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>Result<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>列挙の持つ<bpt i="2" x="2">&lt;a2&gt;</bpt><bpt i="3" x="3">&lt;c3&gt;</bpt>init(catching:)<ept i="3">&lt;/c3&gt;</ept><ept i="2">&lt;/a2&gt;</ept>イニシャライザを使って保全します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You rarely need to use iterators directly, because a <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> loop is the more idiomatic approach to traversing a sequence in Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは滅多にイテレータを直に使う必要はありません、なぜなら<bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>ループはSwiftにおいてシーケンスを辿っていくずっと慣用語法にかなった取り組みだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You reuse an API by using its new name to call it in the implementation of a new API in Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはあるAPIを、それの新しい名前を使ってそれをSwiftでの新しいAPIの実装において呼び出すことによって再利用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You use <bpt i="4" x="4">&lt;c4&gt;</bpt>self<ept i="4">&lt;/c4&gt;</ept> in a <bpt i="5" x="5">&lt;c5&gt;</bpt>CF<bpt i="6" x="6">&lt;w6&gt;</bpt>_SWIFT<bpt i="7" x="7">&lt;w7&gt;</bpt>_NAME<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> argument to refer to the instance that the method belongs to.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="4" x="4">&lt;c4&gt;</bpt>self<ept i="4">&lt;/c4&gt;</ept>を<bpt i="5" x="5">&lt;c5&gt;</bpt>CF<bpt i="6" x="6">&lt;w6&gt;</bpt>_SWIFT<bpt i="7" x="7">&lt;w7&gt;</bpt>_NAME<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>引数において使って、メソッドが属するインスタンスを参照します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You use a set instead of an array when you need to test efficiently for membership and you aren’t concerned with the order of the elements in the collection, or when you need to ensure that each element appears only once in a collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが集合を配列の代わりに使うのは、あなたが帰属について能率的にテストする必要がありそしてあなたがコレクションの要素の順番に関心がない場合、または各要素がただ一度だけコレクション中に現れることをあなたが確実にする必要がある場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You use one of the following macros to declare that several Objective-C constants are related to each other:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、以下のマクロの１つを使って、いくつかのObjective-C定数が互いに関連することを宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You use the <bpt i="0" x="0">&lt;c0&gt;</bpt>CF<bpt i="1" x="1">&lt;w1&gt;</bpt>_SWIFT<bpt i="2" x="2">&lt;w2&gt;</bpt>_NAME<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> macro to group together related global functions into a single structure type that's imported into Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>CF<bpt i="1" x="1">&lt;w1&gt;</bpt>_SWIFT<bpt i="2" x="2">&lt;w2&gt;</bpt>_NAME<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>マクロを使って、関連するグローバル関数を一緒にして、Swiftにインポートされるある単一の構造体型へとグループにまとめます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You use the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_OPTIONS<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> macro when two or more constants in a grouping of constants can be combined.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_OPTIONS<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>マクロを、ある定数グループの中の２つ以上の定数が結合可能である場合に使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You use the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_SWIFT<bpt i="2" x="2">&lt;w2&gt;</bpt>_NAME<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> macro as a prefix for classes and protocols.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_SWIFT<bpt i="2" x="2">&lt;w2&gt;</bpt>_NAME<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>マクロをクラスとプロパティのための接頭辞として使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You use the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_TYPED<bpt i="2" x="2">&lt;w2&gt;</bpt>_ENUM<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to group constants with a raw value type that you specify.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_TYPED<bpt i="2" x="2">&lt;w2&gt;</bpt>_ENUM<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使って、あなたが指定する生の値型を持つ定数をグループにまとめます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You use the <bpt i="0" x="0">&lt;c0&gt;</bpt>Option<bpt i="1" x="1">&lt;w1&gt;</bpt>Set<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol to represent bitset types, where individual bits represent members of a set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Option<bpt i="1" x="1">&lt;w1&gt;</bpt>Set<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルを使ってビットセット型を表すことができます、そこにおいて個々のビットはセットのメンバを表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You use the <bpt i="0" x="0">&lt;c0&gt;</bpt>Optional<ept i="0">&lt;/c0&gt;</ept> type whenever you use optional values, even if you never type the word <bpt i="1" x="1">&lt;c1&gt;</bpt>Optional<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>Optional<ept i="0">&lt;/c0&gt;</ept>型を、あなたがオプショナル値を使う時はいつでも使います、たとえあなたが単語<bpt i="1" x="1">&lt;c1&gt;</bpt>Optional<ept i="1">&lt;/c1&gt;</ept>を決してタイプしないとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You use this initializer from within your type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>custom<bpt i="1" x="1">&lt;w1&gt;</bpt>Mirror<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> implementation to create a customized mirror, particularly for custom types that are collections.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、このイニシャライザをあなたの型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>custom<bpt i="1" x="1">&lt;w1&gt;</bpt>Mirror<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>実装内部から使うことで、あつらえのミラーを作成できます、とりわけコレクションであるあつらえの型に対して。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You use this initializer from within your type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>custom<bpt i="1" x="1">&lt;w1&gt;</bpt>Mirror<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> implementation to create a customized mirror.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、このイニシャライザをあなたの型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>custom<bpt i="1" x="1">&lt;w1&gt;</bpt>Mirror<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>実装内部から使うことで、あつらえのミラーを作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You use this method to randomize the elements of a collection when you are using a custom random number generator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはこのメソッドを使って、あなたがあつらえの無作為数生成子を使っている場合に、あるコレクションの要素を無作為化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You use this method to randomize the elements of a sequence when you are using a custom random number generator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはこのメソッドを使って、あなたがあつらえの無作為数生成子を使っている場合に、あるシーケンスの要素を無作為化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You use types that conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Set<bpt i="1" x="1">&lt;w1&gt;</bpt>Algebra<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol when you need efficient membership tests or mathematical set operations such as intersection, union, and subtraction.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>Set<bpt i="1" x="1">&lt;w1&gt;</bpt>Algebra<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する型を使うのは、あなたが帰属について能率的にテストするか、数学的集合演算たとえば交叉、合併、そして差分を必要とする場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You won’t create a header file; Xcode generates a header automatically in case you need to reference it.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはヘッダ・ファイルを作成しません；あなたがそれに参照をつける必要がある場合に備えて、Xcodeが自動的にヘッダを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You'll need to consider this kind of time-based execution problem frequently when using APIs that take closures.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、クロージャを取るAPIを使う場合に、この種の時間基盤の実行問題をしばしば考える必要があるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You've ever added cases to an enumeration after its initial declaration</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが決してケース節を、ある列挙に対してそれの最初の宣言の後に加えないならば</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You’ll replace the <bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>.h<ept i="1">&lt;/c1&gt;</ept> files for that class with a single <bpt i="2" x="2">&lt;c2&gt;</bpt>.swift<ept i="2">&lt;/c2&gt;</ept> file.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、そのクラスのための<bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>.h<ept i="1">&lt;/c1&gt;</ept>ファイルを単一の<bpt i="2" x="2">&lt;c2&gt;</bpt>.swift<ept i="2">&lt;/c2&gt;</ept>ファイルで置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Zero is a multiple of everything because <bpt i="9" x="9">&lt;e9&gt;</bpt>0 = 0*x<ept i="9">&lt;/e9&gt;</ept> for any integer <bpt i="10" x="10">&lt;e10&gt;</bpt>x<ept i="10">&lt;/e10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ゼロはあらゆるものの倍数です、なぜなら<bpt i="9" x="9">&lt;e9&gt;</bpt>0 = 0*x<ept i="9">&lt;/e9&gt;</ept>なので、どんな整数<bpt i="10" x="10">&lt;e10&gt;</bpt>x<ept i="10">&lt;/e10&gt;</ept>に対してもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Zero is the identity element for addition.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ゼロは加算に対する単位元です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>if this set and <bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept> contain elements that are equal but distinguishable (e.g. via <bpt i="1" x="1">&lt;c1&gt;</bpt>===<ept i="1">&lt;/c1&gt;</ept>), which of these elements is present in the result is unspecified.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この集合と<bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>が等しいけれども区別可能な要素を含むならば（たとえば<bpt i="1" x="1">&lt;c1&gt;</bpt>===<ept i="1">&lt;/c1&gt;</ept>によって）、それらの要素のどれが結果の存在するのかは不特定です。</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
