<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="5.3.0_0_2fd7a9ecc" segtype="sentence" srclang="en-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv xml:lang="en-US">
        <seg>(An <bpt i="2" x="2">&lt;c2&gt;</bpt>enum<ept i="2">&lt;/c2&gt;</ept> without associated values has <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept> conformance even without the declaration.)</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>（関連値なしでの<bpt i="2" x="2">&lt;c2&gt;</bpt>enum<ept i="2">&lt;/c2&gt;</ept>は、<bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>準拠をたとえ宣言なしでも持ちます。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>(An <bpt i="2" x="2">&lt;c2&gt;</bpt>enum<ept i="2">&lt;/c2&gt;</ept> without associated values has <bpt i="3" x="3">&lt;c3&gt;</bpt>Hashable<ept i="3">&lt;/c3&gt;</ept> conformance even without the declaration.)</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>（関連値なしでの<bpt i="2" x="2">&lt;c2&gt;</bpt>enum<ept i="2">&lt;/c2&gt;</ept>は、<bpt i="3" x="3">&lt;c3&gt;</bpt>Hashable<ept i="3">&lt;/c3&gt;</ept>準拠をたとえ宣言なしでも持ちます。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>(Enumerations without associated values have <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>Hashable<ept i="4">&lt;/c4&gt;</ept> conformance even without declaring adoption.)</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>（関連値なしの列挙は、<bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>および<bpt i="4" x="4">&lt;c4&gt;</bpt>Hashable<ept i="4">&lt;/c4&gt;</ept>準拠を持ちます、たとえ採用を宣言することなしでも。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>(In Swift 5.1 and earlier, <bpt i="2" x="2">&lt;c2&gt;</bpt>is<bpt i="3" x="3">&lt;w3&gt;</bpt>Canonical<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is <bpt i="4" x="4">&lt;c4&gt;</bpt>true<ept i="4">&lt;/c4&gt;</ept> for these values, which is the incorrect value.)</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>（Swift 5.1およびそれより前では、<bpt i="2" x="2">&lt;c2&gt;</bpt>is<bpt i="3" x="3">&lt;w3&gt;</bpt>Canonical<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>はこれらの値に対して<bpt i="4" x="4">&lt;c4&gt;</bpt>true<ept i="4">&lt;/c4&gt;</ept>です、それは不正確な値です。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>(Irreflexivity)</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>（非反射）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>(Reflexivity)</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>（反射性）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>(Symmetry)</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>（対称性）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>(These may become compile-time errors in the future.)</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>（それらはコンパイル時エラーに将来はなるかもしれません。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>(Transitive comparability)</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>（推移的比較性）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>(Transitive incomparability)</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>（推移的比較不能性）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>(Transitivity)</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>（推移性）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>/ A genuinely asychronous implementation uses the `Task`<it pos="end" x="49">&lt;/s49&gt;</it><it pos="end" x="48">&lt;/s48&gt;</it><it pos="end" x="46">&lt;/s46&gt;</it><it pos="begin" x="50">&lt;s50&gt;</it><bpt i="51" x="51">&lt;s51&gt;</bpt><ept i="51">&lt;/s51&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>/ 真に非同期の実装は `Task`<it pos="end" x="49">&lt;/s49&gt;</it><it pos="end" x="48">&lt;/s48&gt;</it><it pos="end" x="46">&lt;/s46&gt;</it><it pos="begin" x="50">&lt;s50&gt;</it><bpt i="51" x="51">&lt;s51&gt;</bpt><ept i="51">&lt;/s51&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>/ API to check for cancellation here and return early.<it pos="end" x="53">&lt;/s53&gt;</it><it pos="end" x="52">&lt;/s52&gt;</it><it pos="end" x="50">&lt;/s50&gt;</it><it pos="begin" x="54">&lt;s54&gt;</it><bpt i="55" x="55">&lt;s55&gt;</bpt><ept i="55">&lt;/s55&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>/ API を使用して取り消しをここで調べて、より早くに復帰します。<it pos="end" x="53">&lt;/s53&gt;</it><it pos="end" x="52">&lt;/s52&gt;</it><it pos="end" x="50">&lt;/s50&gt;</it><it pos="begin" x="54">&lt;s54&gt;</it><bpt i="55" x="55">&lt;s55&gt;</bpt><ept i="55">&lt;/s55&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>-infinity<ept i="0">&lt;/c0&gt;</ept> compares less than all values except for itself and NaN.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>-infinity<ept i="0">&lt;/c0&gt;</ept>は、それ自身とNaNを除くすべての値より少ないと比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>-infinity<ept i="0">&lt;/c0&gt;</ept> compares less than or equal to all values except NaN.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>-infinity<ept i="0">&lt;/c0&gt;</ept>は、NaNを除くすべての値より少ないか等しいと比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Hashable<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> considers bridged counterparts (such as a <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept> and an <bpt i="3" x="3">&lt;c3&gt;</bpt>NSString<ept i="3">&lt;/c3&gt;</ept>) of the same value to be equivalent when type-erased.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Hashable<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、同じ値のブリッジされた相当物（たとえば<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>NSString<ept i="3">&lt;/c3&gt;</ept>）を同等であると、型消去される場合にはみなします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Object<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> can also be used as the concrete type for an instance of a type that bridges to an Objective-C class.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Object<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>はまた、Objective-Cクラスへとブリッジするある型のインスタンスに対する具象型として使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Array<bpt i="1" x="1">&lt;w1&gt;</bpt>Slice<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instances are not always indexed from zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Array<bpt i="1" x="1">&lt;w1&gt;</bpt>Slice<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスは、常にゼロからインデックスをつけられるわけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Async<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> also defines methods for processing the elements you receive, modeled on the operations provided by the basic <bpt i="2" x="2">&lt;c2&gt;</bpt>Sequence<ept i="2">&lt;/c2&gt;</ept> in the standard library.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Async<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>はまた、あなたが受け取る要素を処理するために、標準ライブラリの基本の<bpt i="2" x="2">&lt;c2&gt;</bpt>Sequence<ept i="2">&lt;/c2&gt;</ept>によって提供される演算を手本にしてメソッドいくつかを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Autoreleasing<bpt i="1" x="1">&lt;w1&gt;</bpt>Unsafe<bpt i="2" x="2">&lt;w2&gt;</bpt>Mutable<bpt i="3" x="3">&lt;w3&gt;</bpt>Pointer<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is assumed to reference a value with <bpt i="4" x="4">&lt;c4&gt;</bpt>_<bpt i="5" x="5">&lt;w5&gt;</bpt>_autoreleasing<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> ownership semantics, like <bpt i="6" x="6">&lt;c6&gt;</bpt>NSFoo **<ept i="6">&lt;/c6&gt;</ept> declarations in ARC.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Autoreleasing<bpt i="1" x="1">&lt;w1&gt;</bpt>Unsafe<bpt i="2" x="2">&lt;w2&gt;</bpt>Mutable<bpt i="3" x="3">&lt;w3&gt;</bpt>Pointer<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、<bpt i="4" x="4">&lt;c4&gt;</bpt>_<bpt i="5" x="5">&lt;w5&gt;</bpt>_autoreleasing<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>所有権意味論をもつ値を参照すると仮定されます、ARCにおける<bpt i="6" x="6">&lt;c6&gt;</bpt>NSFoo **<ept i="6">&lt;/c6&gt;</ept>宣言のような。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bool<ept i="0">&lt;/c0&gt;</ept> represents Boolean values in Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bool<ept i="0">&lt;/c0&gt;</ept>はブール値をSwiftにおいて表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bool<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>Darwin<bpt i="2" x="2">&lt;w2&gt;</bpt>Boolean<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>Obj<bpt i="4" x="4">&lt;w4&gt;</bpt>CBool<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, and <bpt i="5" x="5">&lt;c5&gt;</bpt>Windows<bpt i="6" x="6">&lt;w6&gt;</bpt>Bool<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> are treated as Boolean values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bool<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>Darwin<bpt i="2" x="2">&lt;w2&gt;</bpt>Boolean<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>Obj<bpt i="4" x="4">&lt;w4&gt;</bpt>CBool<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>、そして<bpt i="5" x="5">&lt;c5&gt;</bpt>Windows<bpt i="6" x="6">&lt;w6&gt;</bpt>Bool<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>は、ブール値として扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>CGPoint<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>CGSize<ept i="1">&lt;/c1&gt;</ept>, and <bpt i="2" x="2">&lt;c2&gt;</bpt>CGRect<ept i="2">&lt;/c2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>CGPoint<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>CGSize<ept i="1">&lt;/c1&gt;</ept>、および<bpt i="2" x="2">&lt;c2&gt;</bpt>CGRect<ept i="2">&lt;/c2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Checked<bpt i="1" x="1">&lt;w1&gt;</bpt>Continuation<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> logs a message if either of these invariants is violated.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Checked<bpt i="1" x="1">&lt;w1&gt;</bpt>Continuation<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、これら不変式のどれかが侵害されるならばメッセージを記録します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Checked<bpt i="1" x="1">&lt;w1&gt;</bpt>Continuation<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> performs runtime checks for missing or multiple resume operations.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Checked<bpt i="1" x="1">&lt;w1&gt;</bpt>Continuation<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、見つからないまたは複数の再開操作に対する実行時検査を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Codable<ept i="0">&lt;/c0&gt;</ept> is a type alias for the <bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Decodable<ept i="2">&lt;/c2&gt;</ept> protocols.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Codable<ept i="0">&lt;/c0&gt;</ept>は、<bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>Decodable<ept i="2">&lt;/c2&gt;</ept>プロトコルに対する型エイリアスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Date<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>NSDate<ept i="1">&lt;/c1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Date<ept i="0">&lt;/c0&gt;</ept>および<bpt i="1" x="1">&lt;c1&gt;</bpt>NSDate<ept i="1">&lt;/c1&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Default<bpt i="1" x="1">&lt;w1&gt;</bpt>String<bpt i="2" x="2">&lt;w2&gt;</bpt>Interpolation<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> extensions should add only <bpt i="3" x="3">&lt;c3&gt;</bpt>mutating<ept i="3">&lt;/c3&gt;</ept> members and should not copy <bpt i="4" x="4">&lt;c4&gt;</bpt>self<ept i="4">&lt;/c4&gt;</ept> or capture it in an escaping closure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Default<bpt i="1" x="1">&lt;w1&gt;</bpt>String<bpt i="2" x="2">&lt;w2&gt;</bpt>Interpolation<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>拡張は、<bpt i="3" x="3">&lt;c3&gt;</bpt>mutating<ept i="3">&lt;/c3&gt;</ept>メンバだけを加えるべきです、そして脱出クロージャにおいて<bpt i="4" x="4">&lt;c4&gt;</bpt>self<ept i="4">&lt;/c4&gt;</ept>をコピーまたはそれをキャプチャすべきではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Empty<bpt i="1" x="1">&lt;w1&gt;</bpt>Collection<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> does not have any element indices, so it is not possible to advance indices.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Empty<bpt i="1" x="1">&lt;w1&gt;</bpt>Collection<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、全く要素インデックスを持ちません、それでインデックスを進めることは可能ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Enumerated<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is a sequence of pairs (<bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept>, <bpt i="3" x="3">&lt;e3&gt;</bpt>x<ept i="3">&lt;/e3&gt;</ept>), where <bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept>s are consecutive <bpt i="5" x="5">&lt;c5&gt;</bpt>Int<ept i="5">&lt;/c5&gt;</ept> values starting at zero, and <bpt i="6" x="6">&lt;e6&gt;</bpt>x<ept i="6">&lt;/e6&gt;</ept>s are the elements of a base sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Enumerated<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、ペア (<bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept>, <bpt i="3" x="3">&lt;e3&gt;</bpt>x<ept i="3">&lt;/e3&gt;</ept>) からなるシーケンスです、ここで<bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept>はゼロで始まる連続した<bpt i="5" x="5">&lt;c5&gt;</bpt>Int<ept i="5">&lt;/c5&gt;</ept>です、そして<bpt i="6" x="6">&lt;e6&gt;</bpt>x<ept i="6">&lt;/e6&gt;</ept>は基盤シーケンスの要素です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Float<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Float<ept i="0">&lt;/c0&gt;</ept>および<bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept> conformance means that you can store positions in a set and quickly check whether you've visited a position before, as shown in the following example:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept>準拠は、あなたが集合の中の位置を格納して前にあなたが訪れた位置かどうかを素早く確認できることを意味します、以下の例で示すように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Hasher<ept i="0">&lt;/c0&gt;</ept> can be used to map an arbitrary sequence of bytes to an integer hash value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Hasher<ept i="0">&lt;/c0&gt;</ept>は、随意のバイト列を整数ハッシュ値へとマップするのに使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Hasher<ept i="0">&lt;/c0&gt;</ept> is usually randomly seeded, which means it will return different values on every new execution of your program.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Hasher<ept i="0">&lt;/c0&gt;</ept>は、ふつうは無作為にシードを決められます、それはあなたのプログラムの新規の実行ごとに異なる値が返されることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Identifiable<ept i="0">&lt;/c0&gt;</ept> leaves the duration and scope of the identity unspecified.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Identifiable<ept i="0">&lt;/c0&gt;</ept>は、同一性の期間とスコープを特定されないようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Identifiable<ept i="0">&lt;/c0&gt;</ept> provides a default implementation for class types (using <bpt i="1" x="1">&lt;c1&gt;</bpt>Object<bpt i="2" x="2">&lt;w2&gt;</bpt>Identifier<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>), which is only guaranteed to remain unique for the lifetime of an object.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Identifiable<ept i="0">&lt;/c0&gt;</ept>は、省略時の実装をクラス型に対して提供します（<bpt i="1" x="1">&lt;c1&gt;</bpt>Object<bpt i="2" x="2">&lt;w2&gt;</bpt>Identifier<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>を使って）、それはあるオブジェクトの存続期間に対して特有のままであることだけを保証されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>UInt<ept i="1">&lt;/c1&gt;</ept>, and the other standard library integer types</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>UInt<ept i="1">&lt;/c1&gt;</ept>、そして他の標準ライブラリの整数型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Iterator<bpt i="1" x="1">&lt;w1&gt;</bpt>Over<bpt i="2" x="2">&lt;w2&gt;</bpt>One<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is the iterator for the <bpt i="3" x="3">&lt;c3&gt;</bpt>Collection<bpt i="4" x="4">&lt;w4&gt;</bpt>Of<bpt i="5" x="5">&lt;w5&gt;</bpt>One<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Iterator<bpt i="1" x="1">&lt;w1&gt;</bpt>Over<bpt i="2" x="2">&lt;w2&gt;</bpt>One<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、<bpt i="3" x="3">&lt;c3&gt;</bpt>Collection<bpt i="4" x="4">&lt;w4&gt;</bpt>Of<bpt i="5" x="5">&lt;w5&gt;</bpt>One<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>型のためのイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NSBezier<bpt i="1" x="1">&lt;w1&gt;</bpt>Path<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>UIBezier<bpt i="3" x="3">&lt;w3&gt;</bpt>Path<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NSBezier<bpt i="1" x="1">&lt;w1&gt;</bpt>Path<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>および<bpt i="2" x="2">&lt;c2&gt;</bpt>UIBezier<bpt i="3" x="3">&lt;w3&gt;</bpt>Path<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NSColor<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>UIColor<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>CGColor<ept i="2">&lt;/c2&gt;</ept>, and <bpt i="3" x="3">&lt;c3&gt;</bpt>CIColor<ept i="3">&lt;/c3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NSColor<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>UIColor<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>CGColor<ept i="2">&lt;/c2&gt;</ept>、および<bpt i="3" x="3">&lt;c3&gt;</bpt>CIColor<ept i="3">&lt;/c3&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NSImage<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>UIImage<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>CGImage<ept i="2">&lt;/c2&gt;</ept>, and <bpt i="3" x="3">&lt;c3&gt;</bpt>CIImage<ept i="3">&lt;/c3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NSImage<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>UIImage<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>CGImage<ept i="2">&lt;/c2&gt;</ept>、および<bpt i="3" x="3">&lt;c3&gt;</bpt>CIImage<ept i="3">&lt;/c3&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NSObject<ept i="0">&lt;/c0&gt;</ept> subclasses inherit conformance to the <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Hashable<ept i="2">&lt;/c2&gt;</ept> protocols, with equality based on instance identity.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NSObject<ept i="0">&lt;/c0&gt;</ept>サブクラスは、<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>Hashable<ept i="2">&lt;/c2&gt;</ept>プロトコルへの準拠を継承します、インスタンス同一性に基づく同等性を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NSView<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>UIView<ept i="1">&lt;/c1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NSView<ept i="0">&lt;/c0&gt;</ept>および<bpt i="1" x="1">&lt;c1&gt;</bpt>UIView<ept i="1">&lt;/c1&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Pointee<ept i="0">&lt;/c0&gt;</ept> must be a class type or <bpt i="1" x="1">&lt;c1&gt;</bpt>Optional&lt;C&gt;<ept i="1">&lt;/c1&gt;</ept> where <bpt i="2" x="2">&lt;c2&gt;</bpt>C<ept i="2">&lt;/c2&gt;</ept> is a class.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Pointee<ept i="0">&lt;/c0&gt;</ept>は、クラス型または<bpt i="1" x="1">&lt;c1&gt;</bpt>Optional&lt;C&gt;<ept i="1">&lt;/c1&gt;</ept>でなければなりません、そこで<bpt i="2" x="2">&lt;c2&gt;</bpt>C<ept i="2">&lt;/c2&gt;</ept>はクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>NSString<ept i="1">&lt;/c1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>および<bpt i="1" x="1">&lt;c1&gt;</bpt>NSString<ept i="1">&lt;/c1&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>T<bpt i="1" x="1">&lt;w1&gt;</bpt>.min<bpt i="2" x="2">&lt;w2&gt;</bpt>.is<bpt i="3" x="3">&lt;w3&gt;</bpt>Multiple(of: -1)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="4" x="4">&lt;c4&gt;</bpt>true<ept i="4">&lt;/c4&gt;</ept> for signed integer <bpt i="5" x="5">&lt;c5&gt;</bpt>T<ept i="5">&lt;/c5&gt;</ept>, even though the quotient <bpt i="6" x="6">&lt;c6&gt;</bpt>T<bpt i="7" x="7">&lt;w7&gt;</bpt>.min / -1<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> isn’t representable in type <bpt i="8" x="8">&lt;c8&gt;</bpt>T<ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>T<bpt i="1" x="1">&lt;w1&gt;</bpt>.min<bpt i="2" x="2">&lt;w2&gt;</bpt>.is<bpt i="3" x="3">&lt;w3&gt;</bpt>Multiple(of: -1)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="4" x="4">&lt;c4&gt;</bpt>true<ept i="4">&lt;/c4&gt;</ept>です、符号付き整数<bpt i="5" x="5">&lt;c5&gt;</bpt>T<ept i="5">&lt;/c5&gt;</ept>に対して、たとえ商<bpt i="6" x="6">&lt;c6&gt;</bpt>T<bpt i="7" x="7">&lt;w7&gt;</bpt>.min / -1<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>が型<bpt i="8" x="8">&lt;c8&gt;</bpt>T<ept i="8">&lt;/c8&gt;</ept>で表現可能でなくてさえ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>URL<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>NSURL<ept i="1">&lt;/c1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>URL<ept i="0">&lt;/c0&gt;</ept>および<bpt i="1" x="1">&lt;c1&gt;</bpt>NSURL<ept i="1">&lt;/c1&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>a &lt; a<ept i="0">&lt;/c0&gt;</ept> is always <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept> (Irreflexivity)</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>a &lt; a<ept i="0">&lt;/c0&gt;</ept>は常に<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>（非反射）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>a &lt; b<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>b &lt; c<ept i="1">&lt;/c1&gt;</ept> implies <bpt i="2" x="2">&lt;c2&gt;</bpt>a &lt; c<ept i="2">&lt;/c2&gt;</ept> (Transitivity)</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>a &lt; b<ept i="0">&lt;/c0&gt;</ept>かつ<bpt i="1" x="1">&lt;c1&gt;</bpt>b &lt; c<ept i="1">&lt;/c1&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>a &lt; c<ept i="2">&lt;/c2&gt;</ept>を意味する（推移）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>a &lt; b<ept i="0">&lt;/c0&gt;</ept> implies <bpt i="1" x="1">&lt;c1&gt;</bpt>!(b &lt; a)<ept i="1">&lt;/c1&gt;</ept> (Asymmetry)</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>a &lt; b<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>!(b &lt; a)<ept i="1">&lt;/c1&gt;</ept>を意味する（非対称）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>a == a<ept i="0">&lt;/c0&gt;</ept> is always <bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept> (Reflexivity)</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>a == a<ept i="0">&lt;/c0&gt;</ept>は、常に<bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>（反射）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>a == b<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>b == c<ept i="1">&lt;/c1&gt;</ept> implies <bpt i="2" x="2">&lt;c2&gt;</bpt>a == c<ept i="2">&lt;/c2&gt;</ept> (Transitivity)</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>a == b<ept i="0">&lt;/c0&gt;</ept>かつ<bpt i="1" x="1">&lt;c1&gt;</bpt>b == c<ept i="1">&lt;/c1&gt;</ept>は、<bpt i="2" x="2">&lt;c2&gt;</bpt>a == c<ept i="2">&lt;/c2&gt;</ept>を意味する（推移）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>a == b<ept i="0">&lt;/c0&gt;</ept> implies <bpt i="1" x="1">&lt;c1&gt;</bpt>b == a<ept i="1">&lt;/c1&gt;</ept> (Symmetry)</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>a == b<ept i="0">&lt;/c0&gt;</ept>は、<bpt i="1" x="1">&lt;c1&gt;</bpt>b == a<ept i="1">&lt;/c1&gt;</ept>を意味する（対称）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>are<bpt i="1" x="1">&lt;w1&gt;</bpt>Equivalent(a, a)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is always <bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>are<bpt i="1" x="1">&lt;w1&gt;</bpt>Equivalent(a, a)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は常に<bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>are<bpt i="1" x="1">&lt;w1&gt;</bpt>Equivalent(a, b)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> implies <bpt i="2" x="2">&lt;c2&gt;</bpt>are<bpt i="3" x="3">&lt;w3&gt;</bpt>Equivalent(b, a)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>are<bpt i="1" x="1">&lt;w1&gt;</bpt>Equivalent(a, b)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>are<bpt i="3" x="3">&lt;w3&gt;</bpt>Equivalent(b, a)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を意味する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>are<bpt i="1" x="1">&lt;w1&gt;</bpt>In<bpt i="2" x="2">&lt;w2&gt;</bpt>Increasing<bpt i="3" x="3">&lt;w3&gt;</bpt>Order(a, a)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is always <bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>are<bpt i="1" x="1">&lt;w1&gt;</bpt>In<bpt i="2" x="2">&lt;w2&gt;</bpt>Increasing<bpt i="3" x="3">&lt;w3&gt;</bpt>Order(a, a)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は常に<bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>are<bpt i="1" x="1">&lt;w1&gt;</bpt>In<bpt i="2" x="2">&lt;w2&gt;</bpt>Increasing<bpt i="3" x="3">&lt;w3&gt;</bpt>Order<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be a <bpt i="4" x="4">&lt;e4&gt;</bpt>strict weak ordering<ept i="4">&lt;/e4&gt;</ept> over the elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>are<bpt i="1" x="1">&lt;w1&gt;</bpt>In<bpt i="2" x="2">&lt;w2&gt;</bpt>Increasing<bpt i="3" x="3">&lt;w3&gt;</bpt>Order<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、それら要素に対して<bpt i="4" x="4">&lt;e4&gt;</bpt>厳密弱順序<ept i="4">&lt;/e4&gt;</ept>でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept> is executed each time the <bpt i="1" x="1">&lt;c1&gt;</bpt>next()<ept i="1">&lt;/c1&gt;</ept> method is called on the resulting iterator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept>は、結果として生じるイテレータで<bpt i="1" x="1">&lt;c1&gt;</bpt>next()<ept i="1">&lt;/c1&gt;</ept>メソッドが呼び出されるたびに実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>condition<ept i="0">&lt;/c0&gt;</ept> is not evaluated in <bpt i="1" x="1">&lt;c1&gt;</bpt>-Ounchecked<ept i="1">&lt;/c1&gt;</ept> builds.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>condition<ept i="0">&lt;/c0&gt;</ept>は、<bpt i="1" x="1">&lt;c1&gt;</bpt>-Ounchecked<ept i="1">&lt;/c1&gt;</ept>ビルドにおいては評価されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>condition<ept i="0">&lt;/c0&gt;</ept> is only evaluated in playgrounds and <bpt i="1" x="1">&lt;c1&gt;</bpt>-Onone<ept i="1">&lt;/c1&gt;</ept> builds.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>condition<ept i="0">&lt;/c0&gt;</ept>はただプレイグラウンドと<bpt i="1" x="1">&lt;c1&gt;</bpt>-Onone<ept i="1">&lt;/c1&gt;</ept>において評価されるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>count<ept i="0">&lt;/c0&gt;</ept> must be greater than or equal to zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>count<ept i="0">&lt;/c0&gt;</ept>は、ゼロより大きいか等しくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>default<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>optional<ept i="2">&lt;/c2&gt;</ept> have the same type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>default<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>optional<ept i="2">&lt;/c2&gt;</ept>は同じ型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>default<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is the same type as the <bpt i="2" x="2">&lt;c2&gt;</bpt>Wrapped<ept i="2">&lt;/c2&gt;</ept> type of <bpt i="3" x="3">&lt;c3&gt;</bpt>optional<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>default<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、<bpt i="2" x="2">&lt;c2&gt;</bpt>optional<ept i="2">&lt;/c2&gt;</ept>の<bpt i="3" x="3">&lt;c3&gt;</bpt>Wrapped<ept i="3">&lt;/c3&gt;</ept>型と同じ型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>end<ept i="0">&lt;/c0&gt;</ept> is an element of the resulting sequence if and only if it can be produced from <bpt i="1" x="1">&lt;c1&gt;</bpt>start<ept i="1">&lt;/c1&gt;</ept> using steps of <bpt i="2" x="2">&lt;c2&gt;</bpt>stride<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>end<ept i="0">&lt;/c0&gt;</ept>は、それが<bpt i="1" x="1">&lt;c1&gt;</bpt>start<ept i="1">&lt;/c1&gt;</ept>から<bpt i="2" x="2">&lt;c2&gt;</bpt>stride<ept i="2">&lt;/c2&gt;</ept>の間隔を使って生成可能であるときかつその場合に限り、結果のシーケンスの要素です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>end<ept i="0">&lt;/c0&gt;</ept> is never an element of the resulting sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>end<ept i="0">&lt;/c0&gt;</ept>は、決して結果シーケンスの要素ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>end<ept i="0">&lt;/c0&gt;</ept> must be a valid index of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>end<ept i="0">&lt;/c0&gt;</ept>はコレクションのひとつの有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is always reachable from <bpt i="2" x="2">&lt;c2&gt;</bpt>start<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> by zero or more applications of <bpt i="4" x="4">&lt;c4&gt;</bpt>index(after:)<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、常に<bpt i="2" x="2">&lt;c2&gt;</bpt>start<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>から<bpt i="4" x="4">&lt;c4&gt;</bpt>index(after:)<ept i="4">&lt;/c4&gt;</ept>のゼロまたはそれ以上の適用によって到達可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is not a valid argument to <bpt i="2" x="2">&lt;c2&gt;</bpt>subscript<ept i="2">&lt;/c2&gt;</ept>, and is always reachable from <bpt i="3" x="3">&lt;c3&gt;</bpt>start<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> by zero or more applications of <bpt i="5" x="5">&lt;c5&gt;</bpt>index(after:)<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>subscript<ept i="2">&lt;/c2&gt;</ept>に対する有効な引数ではありません、そして常に<bpt i="3" x="3">&lt;c3&gt;</bpt>start<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>からゼロまたはそれ以上の<bpt i="5" x="5">&lt;c5&gt;</bpt>index(after:)<ept i="5">&lt;/c5&gt;</ept>の適用によって到達可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>greatest<bpt i="1" x="1">&lt;w1&gt;</bpt>Finite<bpt i="2" x="2">&lt;w2&gt;</bpt>Magnitude<bpt i="3" x="3">&lt;w3&gt;</bpt>.ulp<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is a finite number, even though the next greater representable value is <bpt i="4" x="4">&lt;c4&gt;</bpt>infinity<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>greatest<bpt i="1" x="1">&lt;w1&gt;</bpt>Finite<bpt i="2" x="2">&lt;w2&gt;</bpt>Magnitude<bpt i="3" x="3">&lt;w3&gt;</bpt>.ulp<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は有限数です、たとえ次のより大きい表現可能な値が<bpt i="4" x="4">&lt;c4&gt;</bpt>infinity<ept i="4">&lt;/c4&gt;</ept>であるとしても。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>hash<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is deprecated as a <bpt i="2" x="2">&lt;c2&gt;</bpt>Hashable<ept i="2">&lt;/c2&gt;</ept> requirement.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>hash<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、<bpt i="2" x="2">&lt;c2&gt;</bpt>Hashable<ept i="2">&lt;/c2&gt;</ept>要件として非推奨にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept> must be <bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept>でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept> must be <bpt i="1" x="1">&lt;c1&gt;</bpt>1<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>1<ept i="1">&lt;/c1&gt;</ept>でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept> must be greater than <bpt i="1" x="1">&lt;c1&gt;</bpt>start<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>start<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>より大きくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept> must be less than <bpt i="1" x="1">&lt;c1&gt;</bpt>end<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>end<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>より少なくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>index<ept i="0">&lt;/c0&gt;</ept> must be a valid index of the array or equal to its <bpt i="1" x="1">&lt;c1&gt;</bpt>end<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>index<ept i="0">&lt;/c0&gt;</ept>は、配列の有効なインデックスまたはそれの<bpt i="1" x="1">&lt;c1&gt;</bpt>end<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>プロパティでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>index<ept i="0">&lt;/c0&gt;</ept> must be a valid index of the array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>index<ept i="0">&lt;/c0&gt;</ept>は配列の有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>index<ept i="0">&lt;/c0&gt;</ept> must be a valid index of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>index<ept i="0">&lt;/c0&gt;</ept>はコレクションの有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>index<ept i="0">&lt;/c0&gt;</ept> must be a valid index of the dictionary, and must not equal the dictionary’s end index.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>index<ept i="0">&lt;/c0&gt;</ept>は辞書の有効なインデックスでなければなりません、そして辞書の末尾インデックスと同じではなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>index<ept i="0">&lt;/c0&gt;</ept> must be greater than or equal to <bpt i="1" x="1">&lt;c1&gt;</bpt>start<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> and less than <bpt i="3" x="3">&lt;c3&gt;</bpt>end<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>index<ept i="0">&lt;/c0&gt;</ept>は、<bpt i="1" x="1">&lt;c1&gt;</bpt>start<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>より大きいか等しくそして<bpt i="3" x="3">&lt;c3&gt;</bpt>end<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>より小さくなくてはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>index<ept i="0">&lt;/c0&gt;</ept> must be in the range <bpt i="1" x="1">&lt;c1&gt;</bpt>0..<it pos="begin" x="2">&lt;scalar&lt;w2&gt;</it>Count<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>index<ept i="0">&lt;/c0&gt;</ept>は、範囲<bpt i="1" x="1">&lt;c1&gt;</bpt>0..<it pos="begin" x="2">&lt;scalar&lt;w2&gt;</it>Count<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の中になければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>initial<bpt i="1" x="1">&lt;w1&gt;</bpt>Result<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is passed to <bpt i="2" x="2">&lt;c2&gt;</bpt>next<bpt i="3" x="3">&lt;w3&gt;</bpt>Partial<bpt i="4" x="4">&lt;w4&gt;</bpt>Result<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> the first time the closure is executed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>initial<bpt i="1" x="1">&lt;w1&gt;</bpt>Result<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>next<bpt i="3" x="3">&lt;w3&gt;</bpt>Partial<bpt i="4" x="4">&lt;w4&gt;</bpt>Result<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に、クロージャが実行される最初の時に渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Known<bpt i="2" x="2">&lt;w2&gt;</bpt>Uniquely<bpt i="3" x="3">&lt;w3&gt;</bpt>Referenced(_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> checks only for strong references to the given object—if <bpt i="4" x="4">&lt;c4&gt;</bpt>object<ept i="4">&lt;/c4&gt;</ept> has additional weak or unowned references, the result may still be <bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Known<bpt i="2" x="2">&lt;w2&gt;</bpt>Uniquely<bpt i="3" x="3">&lt;w3&gt;</bpt>Referenced(_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は与えられたオブジェクトに対する強い参照に対してのみ確認します — <bpt i="4" x="4">&lt;c4&gt;</bpt>object<ept i="4">&lt;/c4&gt;</ept>がさらに弱いまたは非所有参照を持つ場合、結果は依然として<bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>k<ept i="0">&lt;/c0&gt;</ept> must be greater than or equal to zero and must not exceed the number of elements in the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>k<ept i="0">&lt;/c0&gt;</ept>は、ゼロより大きいか等しくなければなりません、そしてコレクションの中の要素の数を越えてはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>k<ept i="0">&lt;/c0&gt;</ept> must be greater than or equal to zero, and must be less than or equal to the number of elements in the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>k<ept i="0">&lt;/c0&gt;</ept>は、ゼロより大きいか等しくなければなりません、そしてコレクションの要素数より少ないか等しくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>k<ept i="0">&lt;/c0&gt;</ept> must be greater than or equal to zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>k<ept i="0">&lt;/c0&gt;</ept>は、ゼロより大きいか等しくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Length<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be greater than or equal to zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Length<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、ゼロより大きいか等しくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>n<ept i="0">&lt;/c0&gt;</ept> must be greater than or equal to zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>n<ept i="0">&lt;/c0&gt;</ept>は、ゼロより大きいか等しくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> has a specific meaning in Swift—the absence of a value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>はSwiftでは特別な意味を持ちます—値の不在。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>, which gets passed as a null pointer,</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>、それはヌルポインターとして渡されます、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>position<ept i="0">&lt;/c0&gt;</ept> must be a valid index of the collection that is not equal to the <bpt i="1" x="1">&lt;c1&gt;</bpt>end<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>position<ept i="0">&lt;/c0&gt;</ept>はコレクションの有効なインデックスで、<bpt i="1" x="1">&lt;c1&gt;</bpt>end<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>プロパティと等しくないものでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>position<ept i="0">&lt;/c0&gt;</ept> must be a valid index of the dictionary and not equal to <bpt i="1" x="1">&lt;c1&gt;</bpt>end<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>position<ept i="0">&lt;/c0&gt;</ept>は、この辞書の有効なインデックスで、<bpt i="1" x="1">&lt;c1&gt;</bpt>end<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>と等しくない必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>position<ept i="0">&lt;/c0&gt;</ept> must be a valid index of the range, and must not equal the range’s end index.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>position<ept i="0">&lt;/c0&gt;</ept>は、この範囲の有効なインデックスでなければなりません、そしてこの範囲の持つ末尾インデックスと等しくてはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>range<ept i="0">&lt;/c0&gt;</ept> must be finite and non-empty.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>range<ept i="0">&lt;/c0&gt;</ept>は有限でそして空でない必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>range<ept i="0">&lt;/c0&gt;</ept> must not be empty.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>range<ept i="0">&lt;/c0&gt;</ept>は空であってはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>s<bpt i="1" x="1">&lt;w1&gt;</bpt>.joined().map(f)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> maps eagerly and returns a new array</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>s<bpt i="1" x="1">&lt;w1&gt;</bpt>.joined().map(f)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は先行にマップを行い、新しい配列を返します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>s<bpt i="1" x="1">&lt;w1&gt;</bpt>.joined()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> does not create new storage</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>s<bpt i="1" x="1">&lt;w1&gt;</bpt>.joined()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は新しいストレージを作りません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>s<bpt i="1" x="1">&lt;w1&gt;</bpt>.lazy<bpt i="2" x="2">&lt;w2&gt;</bpt>.joined().map(f)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> maps lazily and returns a <bpt i="3" x="3">&lt;c3&gt;</bpt>Lazy<bpt i="4" x="4">&lt;w4&gt;</bpt>Map<bpt i="5" x="5">&lt;w5&gt;</bpt>Sequence<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>s<bpt i="1" x="1">&lt;w1&gt;</bpt>.lazy<bpt i="2" x="2">&lt;w2&gt;</bpt>.joined().map(f)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は遅延にマップして、<bpt i="3" x="3">&lt;c3&gt;</bpt>Lazy<bpt i="4" x="4">&lt;w4&gt;</bpt>Map<bpt i="5" x="5">&lt;w5&gt;</bpt>Sequence<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>を返します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>source<ept i="0">&lt;/c0&gt;</ept> must be representable in this type after rounding toward zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>source<ept i="0">&lt;/c0&gt;</ept>は、ゼロへの丸め後にこの型において表現可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>source<ept i="0">&lt;/c0&gt;</ept> must be representable in this type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>source<ept i="0">&lt;/c0&gt;</ept>は、この型で表現可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>start<ept i="0">&lt;/c0&gt;</ept> must be a valid index of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>start<ept i="0">&lt;/c0&gt;</ept>はコレクションのひとつの有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>transform<ept i="0">&lt;/c0&gt;</ept> accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>transform<ept i="0">&lt;/c0&gt;</ept>はこのシーケンスのひとつの要素をそれのパラメータとして受け取り、同じもしくは異なる型の変換された値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>transform<ept i="0">&lt;/c0&gt;</ept> accepts an element of this sequence as its parameter and returns an <bpt i="1" x="1">&lt;c1&gt;</bpt>Async<bpt i="2" x="2">&lt;w2&gt;</bpt>Sequence<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>transform<ept i="0">&lt;/c0&gt;</ept>はこのシーケンスのある要素をそれのパラメータとして受け取り、そして<bpt i="1" x="1">&lt;c1&gt;</bpt>Async<bpt i="2" x="2">&lt;w2&gt;</bpt>Sequence<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>transform<ept i="0">&lt;/c0&gt;</ept> accepts each value of the dictionary as its parameter and returns a transformed value of the same or of a different type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>transform<ept i="0">&lt;/c0&gt;</ept>は、辞書の各値をそれのパラメータとして受け取って、同じまたは異なる型の変換した値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>transform<ept i="0">&lt;/c0&gt;</ept> accepts each value of the dictionary as its parameter and returns an optional transformed value of the same or of a different type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>transform<ept i="0">&lt;/c0&gt;</ept>は辞書の各値をそれのパラメータとして受け取ります、そして同じまたは異なる型のあるオプショナルの変換済みの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if <bpt i="1" x="1">&lt;c1&gt;</bpt>element<ept i="1">&lt;/c1&gt;</ept> is contained in the range; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>element<ept i="1">&lt;/c1&gt;</ept>がこの範囲に含まれるならば<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if <bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept> has been offset by exactly <bpt i="2" x="2">&lt;c2&gt;</bpt>distance<ept i="2">&lt;/c2&gt;</ept> steps without going beyond <bpt i="3" x="3">&lt;c3&gt;</bpt>limit<ept i="3">&lt;/c3&gt;</ept>; otherwise, <bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>、もし<bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept>が正確に<bpt i="2" x="2">&lt;c2&gt;</bpt>distance<ept i="2">&lt;/c2&gt;</ept>幅だけ<bpt i="3" x="3">&lt;c3&gt;</bpt>limit<ept i="3">&lt;/c3&gt;</ept>を越えていくことなく補われたならば；そうでなければ、<bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if <bpt i="1" x="1">&lt;c1&gt;</bpt>lhs<ept i="1">&lt;/c1&gt;</ept> is greater than or equal to <bpt i="2" x="2">&lt;c2&gt;</bpt>rhs<ept i="2">&lt;/c2&gt;</ept>; otherwise, <bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>を、<bpt i="1" x="1">&lt;c1&gt;</bpt>lhs<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>rhs<ept i="2">&lt;/c2&gt;</ept>より大きいか等しいならば返します；そうでなければ、<bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if <bpt i="1" x="1">&lt;c1&gt;</bpt>object<ept i="1">&lt;/c1&gt;</ept> is known to have a single strong reference; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>object<ept i="0">&lt;/c0&gt;</ept>が強い参照をただ１つだけ持つものと知られているならば<bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if <bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept> has the same value as this instance; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>がこのインスタンスと同じ値を持つならば<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if <bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept> is greater than this value; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>、もし<bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>がこの値より大きいならば；そうでなければ<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if both <bpt i="1" x="1">&lt;c1&gt;</bpt>t0<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>t1<ept i="2">&lt;/c2&gt;</ept> are <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept> or if they represent the same type; otherwise, <bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>、もし<bpt i="1" x="1">&lt;c1&gt;</bpt>t0<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>t1<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>ならば、またはそれらが同じ型を表すならば；そうでなければ、<bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if one, but not both, of <bpt i="1" x="1">&lt;c1&gt;</bpt>t0<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>t1<ept i="2">&lt;/c2&gt;</ept> are <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>, or if they represent different types; otherwise, <bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>、もし<bpt i="1" x="1">&lt;c1&gt;</bpt>t0<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>t1<ept i="2">&lt;/c2&gt;</ept>の１つが、しかし両方でなく<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>ならば、またそれらが異なる型を表すならば；そうでなければ、<bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if the element was found in the sequence; otherwise, <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要素がシーケンスにおいて見つけられなかったならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>；そうでなければ、<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if the initial elements of the sequence are equivalent to the elements of <bpt i="1" x="1">&lt;c1&gt;</bpt>possible<bpt i="2" x="2">&lt;w2&gt;</bpt>Prefix<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>; otherwise, <bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>、もしシーケンスの冒頭の要素が<bpt i="1" x="1">&lt;c1&gt;</bpt>possible<bpt i="2" x="2">&lt;w2&gt;</bpt>Prefix<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の要素と等しいならば；そうでなければ<bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if the initial elements of the sequence are the same as the elements of <bpt i="1" x="1">&lt;c1&gt;</bpt>possible<bpt i="2" x="2">&lt;w2&gt;</bpt>Prefix<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>; otherwise, <bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>、もしシーケンスの冒頭の要素が<bpt i="1" x="1">&lt;c1&gt;</bpt>possible<bpt i="2" x="2">&lt;w2&gt;</bpt>Prefix<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の要素と同じならば；そうでなければ<bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if the method found the element in the asynchronous sequence; otherwise, <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>、もしメソッドがその要素をこの非同期シーケンスの中で見つけたならば；そうでなければ、<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if the sequence contains an element that satisfies <bpt i="1" x="1">&lt;c1&gt;</bpt>predicate<ept i="1">&lt;/c1&gt;</ept>; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスが<bpt i="1" x="1">&lt;c1&gt;</bpt>predicate<ept i="1">&lt;/c1&gt;</ept>を満たす要素を含むならば<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if the sequence contains an element that satisfies predicate; otherwise, <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>、もしシーケンスが述部を満足させる要素を含むならば；そうでなければ、<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if the sequence contains only elements that satisfy <bpt i="1" x="1">&lt;c1&gt;</bpt>predicate<ept i="1">&lt;/c1&gt;</ept>; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>、もしシーケンスが<bpt i="1" x="1">&lt;c1&gt;</bpt>predicate<ept i="1">&lt;/c1&gt;</ept>を満たす要素のみを含むならば；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if the translation detected encoding errors in <bpt i="1" x="1">&lt;c1&gt;</bpt>input<ept i="1">&lt;/c1&gt;</ept>; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>翻訳が<bpt i="1" x="1">&lt;c1&gt;</bpt>input<ept i="1">&lt;/c1&gt;</ept>においてエンコーディングエラーを検出したならば<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>；そうでなければ<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if this range and <bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept> have at least one element in common; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この範囲と<bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>が少なくとも１つの共通の要素を持つならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if this sequence and <bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept> contain equivalent items, using <bpt i="2" x="2">&lt;c2&gt;</bpt>are<bpt i="3" x="3">&lt;w3&gt;</bpt>Equivalent<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> as the equivalence test; otherwise, <bpt i="4" x="4">&lt;c4&gt;</bpt>false.<ept i="4">&lt;/c4&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>、このシーケンスと<bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>are<bpt i="3" x="3">&lt;w3&gt;</bpt>Equivalent<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を同等性テストとして使って同じ要素らを含むならば；そうでなければ、<bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if this sequence and <bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept> contain the same elements in the same order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスと<bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>が同じ要素を同じ順序で含んでいるならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if this sequence precedes <bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept> in a dictionary ordering as ordered by <bpt i="2" x="2">&lt;c2&gt;</bpt>are<bpt i="3" x="3">&lt;w3&gt;</bpt>In<bpt i="4" x="4">&lt;w4&gt;</bpt>Increasing<bpt i="5" x="5">&lt;w5&gt;</bpt>Order<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>; otherwise, <bpt i="6" x="6">&lt;c6&gt;</bpt>false<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>、もしこのシーケンスが<bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>に、<bpt i="2" x="2">&lt;c2&gt;</bpt>are<bpt i="3" x="3">&lt;w3&gt;</bpt>In<bpt i="4" x="4">&lt;w4&gt;</bpt>Increasing<bpt i="5" x="5">&lt;w5&gt;</bpt>Order<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>によって並べられる通りの字典順序において先行するならば；そうでなければ、<bpt i="6" x="6">&lt;c6&gt;</bpt>false<ept i="6">&lt;/c6&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if this sequence precedes <bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept> in a dictionary ordering; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスが<bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>に、ある字典順序において先行するならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if this value is less than <bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>、もしこの値が<bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>より少ないならば；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if this value is ordered below or the same as <bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept> in a total ordering of the floating-point type; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>、この値が浮動小数点型の全順序において<bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>と同じまたは下に順序付けられるならば；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>ulp<bpt i="1" x="1">&lt;w1&gt;</bpt>Of<bpt i="2" x="2">&lt;w2&gt;</bpt>One<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> corresponds to the value represented by the C macros <bpt i="3" x="3">&lt;c3&gt;</bpt>FLT<bpt i="4" x="4">&lt;w4&gt;</bpt>_EPSILON<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>DBL<bpt i="6" x="6">&lt;w6&gt;</bpt>_EPSILON<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, etc, and is sometimes called <bpt i="7" x="7">&lt;e7&gt;</bpt>epsilon<ept i="7">&lt;/e7&gt;</ept> or <bpt i="8" x="8">&lt;e8&gt;</bpt>machine epsilon<ept i="8">&lt;/e8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>ulp<bpt i="1" x="1">&lt;w1&gt;</bpt>Of<bpt i="2" x="2">&lt;w2&gt;</bpt>One<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、Cマクロ<bpt i="3" x="3">&lt;c3&gt;</bpt>FLT<bpt i="4" x="4">&lt;w4&gt;</bpt>_EPSILON<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>、<bpt i="5" x="5">&lt;c5&gt;</bpt>DBL<bpt i="6" x="6">&lt;w6&gt;</bpt>_EPSILON<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>、などによって表される値に対応します、そして時々は<bpt i="7" x="7">&lt;e7&gt;</bpt>イプシロン<ept i="7">&lt;/e7&gt;</ept>または<bpt i="8" x="8">&lt;e8&gt;</bpt>計算機イプシロン<ept i="8">&lt;/e8&gt;</ept>と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept> must be representable in this type after rounding toward zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept>は、ゼロへの丸め後にこの型において表現可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>without<bpt i="1" x="1">&lt;w1&gt;</bpt>Actually<bpt i="2" x="2">&lt;w2&gt;</bpt>Escaping(_:<bpt i="3" x="3">&lt;w3&gt;</bpt>do:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> provides a temporarily escapable copy of <bpt i="4" x="4">&lt;c4&gt;</bpt>predicate<ept i="4">&lt;/c4&gt;</ept> that <bpt i="5" x="5">&lt;e5&gt;</bpt>can<ept i="5">&lt;/e5&gt;</ept> be used in a call to the lazy view’s <bpt i="6" x="6">&lt;c6&gt;</bpt>filter(_:)<ept i="6">&lt;/c6&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>without<bpt i="1" x="1">&lt;w1&gt;</bpt>Actually<bpt i="2" x="2">&lt;w2&gt;</bpt>Escaping(_:<bpt i="3" x="3">&lt;w3&gt;</bpt>do:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、<bpt i="4" x="4">&lt;c4&gt;</bpt>predicate<ept i="4">&lt;/c4&gt;</ept>の一時的な脱出可能コピーを提供します、それは遅延ビューのもつ<bpt i="6" x="6">&lt;c6&gt;</bpt>filter(_:)<ept i="6">&lt;/c6&gt;</ept>メソッドに対する呼び出しにおいて使用<bpt i="5" x="5">&lt;e5&gt;</bpt>できます<ept i="5">&lt;/e5&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<bpt i="1" x="1">&lt;w1&gt;</bpt>.is<bpt i="2" x="2">&lt;w2&gt;</bpt>Multiple(of: 0)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept> if <bpt i="4" x="4">&lt;c4&gt;</bpt>x<ept i="4">&lt;/c4&gt;</ept> is zero and <bpt i="5" x="5">&lt;c5&gt;</bpt>false<ept i="5">&lt;/c5&gt;</ept> otherwise.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<bpt i="1" x="1">&lt;w1&gt;</bpt>.is<bpt i="2" x="2">&lt;w2&gt;</bpt>Multiple(of: 0)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept>です、もし<bpt i="4" x="4">&lt;c4&gt;</bpt>x<ept i="4">&lt;/c4&gt;</ept>がゼロであるならば、そしてそうでなければ<bpt i="5" x="5">&lt;c5&gt;</bpt>false<ept i="5">&lt;/c5&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept> is a binary floating-point type that has a radix of <bpt i="2" x="2">&lt;c2&gt;</bpt>2<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept>はバイナリ浮動小数点型で<bpt i="2" x="2">&lt;c2&gt;</bpt>2<ept i="2">&lt;/c2&gt;</ept>の基数を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept> is also the base protocol for the <bpt i="2" x="2">&lt;c2&gt;</bpt>Hashable<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>Comparable<ept i="3">&lt;/c3&gt;</ept> protocols, which allow more uses of your custom type, such as constructing sets or sorting the elements of a collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>はまた、<bpt i="2" x="2">&lt;c2&gt;</bpt>Hashable<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>Comparable<ept i="3">&lt;/c3&gt;</ept>プロトコルのための基盤プロトコルです、それらはあなたのあつらえの型のさらなる利用を可能します、例えば集合の組み立てやコレクション要素のソートなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>count<ept i="1">&lt;/c1&gt;</ept> must be zero or greater.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>count<ept i="1">&lt;/c1&gt;</ept>は、ゼロまたはより大きくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>distance<ept i="1">&lt;/c1&gt;</ept> must not be negative unless the collection conforms to the <bpt i="2" x="2">&lt;c2&gt;</bpt>Bidirectional<bpt i="3" x="3">&lt;w3&gt;</bpt>Collection<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>distance<ept i="1">&lt;/c1&gt;</ept>は、そのコレクションが<bpt i="2" x="2">&lt;c2&gt;</bpt>Bidirectional<bpt i="3" x="3">&lt;w3&gt;</bpt>Collection<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルに準拠するのでない限り、負であってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>n<ept i="1">&lt;/c1&gt;</ept> must not be negative unless the collection conforms to the <bpt i="2" x="2">&lt;c2&gt;</bpt>Bidirectional<bpt i="3" x="3">&lt;w3&gt;</bpt>Collection<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>n<ept i="1">&lt;/c1&gt;</ept>は、そのコレクションが<bpt i="2" x="2">&lt;c2&gt;</bpt>Bidirectional<bpt i="3" x="3">&lt;w3&gt;</bpt>Collection<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルに準拠するのでない限り、負であってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>radix<ept i="1">&lt;/c1&gt;</ept> must be in the range <bpt i="2" x="2">&lt;c2&gt;</bpt>2...36<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>radix<ept i="1">&lt;/c1&gt;</ept>は、範囲<bpt i="2" x="2">&lt;c2&gt;</bpt>2...36<ept i="2">&lt;/c2&gt;</ept>の中でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>rhs<ept i="1">&lt;/c1&gt;</ept> must not be zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>rhs<ept i="1">&lt;/c1&gt;</ept>は、ゼロではなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>s<ept i="1">&lt;/c1&gt;</ept> must contain exactly one extended grapheme cluster.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>s<ept i="1">&lt;/c1&gt;</ept>は、厳密に１つの拡張書記素クラスタを含んでいなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>transform<ept i="1">&lt;/c1&gt;</ept> can also throw an error, which ends the transformed sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>transform<ept i="1">&lt;/c1&gt;</ept>はまたエラーをスローできます、それは変換されたシーケンスを終わらせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>type<ept i="1">&lt;/c1&gt;</ept> and the type of <bpt i="2" x="2">&lt;c2&gt;</bpt>x<ept i="2">&lt;/c2&gt;</ept> must have the same size of memory representation and compatible memory layout.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>type<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>x<ept i="2">&lt;/c2&gt;</ept>の型は、同じ大きさのメモリ表現を持ち、互換メモリレイアウトを持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Any<bpt i="3" x="3">&lt;w3&gt;</bpt>Object<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> can be used as the concrete type for an instance of any class, class type, or class-only protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Any<bpt i="3" x="3">&lt;w3&gt;</bpt>Object<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は、あらゆるクラス、クラス型、またはクラス専用プロパティのインスタンスに対する具象型として使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Unsafe<bpt i="3" x="3">&lt;w3&gt;</bpt>Continuation<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> avoids enforcing these invariants at runtime because it aims to be a low-overhead mechanism for interfacing Swift tasks with event loops, delegate methods, callbacks, and other non-<bpt i="4" x="4">&lt;c4&gt;</bpt>async<ept i="4">&lt;/c4&gt;</ept> scheduling mechanisms.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Unsafe<bpt i="3" x="3">&lt;w3&gt;</bpt>Continuation<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は、それら不変式を実行時に遵守させることを避けます、なぜならそれはイベントループを備えるSwiftタスク、委任メソッド、コールバック、そして他の非<bpt i="4" x="4">&lt;c4&gt;</bpt>async<ept i="4">&lt;/c4&gt;</ept>スケジューリング機構を取り持つことに対して低オーバーヘッド機構であるように努力するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>element<ept i="2">&lt;/c2&gt;</ept> is contained in the range if it is between the two bounds or equal to either bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>element<ept i="2">&lt;/c2&gt;</ept>は、それが２つの境界の間またはどちらかの境界と等しいならば、その範囲に含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>init(string<bpt i="3" x="3">&lt;w3&gt;</bpt>Interpolation:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> should use these properties to initialize the instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>init(string<bpt i="3" x="3">&lt;w3&gt;</bpt>Interpolation:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は、それらのプロパティを使ってインスタンスを初期化すべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>max<bpt i="3" x="3">&lt;w3&gt;</bpt>Splits<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> must be greater than or equal to zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>max<bpt i="3" x="3">&lt;w3&gt;</bpt>Splits<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は、ゼロより大きいか等しくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>numeric<bpt i="3" x="3">&lt;w3&gt;</bpt>Cast(_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> traps on overflow in <bpt i="4" x="4">&lt;c4&gt;</bpt>-O<ept i="4">&lt;/c4&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt>-Onone<ept i="5">&lt;/c5&gt;</ept> builds.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>numeric<bpt i="3" x="3">&lt;w3&gt;</bpt>Cast(_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は、<bpt i="4" x="4">&lt;c4&gt;</bpt>-O<ept i="4">&lt;/c4&gt;</ept>および<bpt i="5" x="5">&lt;c5&gt;</bpt>-Onone<ept i="5">&lt;/c5&gt;</ept>ビルドにおいてオーバーフローでトラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>n<ept i="3">&lt;/c3&gt;</ept> may be positive, negative, or zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>n<ept i="3">&lt;/c3&gt;</ept>は、正、負、またはゼロが許されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>128<bpt i="5" x="5">&lt;w5&gt;</bpt>.25<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is rounded to <bpt i="6" x="6">&lt;c6&gt;</bpt>128<ept i="6">&lt;/c6&gt;</ept>, which is not representable as an <bpt i="7" x="7">&lt;c7&gt;</bpt>Int8<ept i="7">&lt;/c7&gt;</ept> instance, triggering a runtime error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>128<bpt i="5" x="5">&lt;w5&gt;</bpt>.25<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は、<bpt i="6" x="6">&lt;c6&gt;</bpt>128<ept i="6">&lt;/c6&gt;</ept>へ丸められます、それは<bpt i="7" x="7">&lt;c7&gt;</bpt>Int8<ept i="7">&lt;/c7&gt;</ept>インスタンスによって表現可能ではなく、実行時エラーを引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>next()<ept i="5">&lt;/c5&gt;</ept> then consumes values from this iterator until it terminates.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>next()<ept i="5">&lt;/c5&gt;</ept>はそれから、このイテレータから値を消費します、それが終端するまで。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt>Binary<bpt i="7" x="7">&lt;w7&gt;</bpt>Floating<bpt i="8" x="8">&lt;w8&gt;</bpt>Point<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> is implemented in the standard library by <bpt i="9" x="9">&lt;c9&gt;</bpt>Float<ept i="9">&lt;/c9&gt;</ept>, <bpt i="10" x="10">&lt;c10&gt;</bpt>Double<ept i="10">&lt;/c10&gt;</ept>, and <bpt i="11" x="11">&lt;c11&gt;</bpt>Float80<ept i="11">&lt;/c11&gt;</ept> where available.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt>Binary<bpt i="7" x="7">&lt;w7&gt;</bpt>Floating<bpt i="8" x="8">&lt;w8&gt;</bpt>Point<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>は、標準ライブラリにおいて<bpt i="9" x="9">&lt;c9&gt;</bpt>Float<ept i="9">&lt;/c9&gt;</ept>、<bpt i="10" x="10">&lt;c10&gt;</bpt>Double<ept i="10">&lt;/c10&gt;</ept>、そして利用可能なところでは<bpt i="11" x="11">&lt;c11&gt;</bpt>Float80<ept i="11">&lt;/c11&gt;</ept>によって実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt>Expressible<bpt i="7" x="7">&lt;w7&gt;</bpt>By<bpt i="8" x="8">&lt;w8&gt;</bpt>Nil<bpt i="9" x="9">&lt;w9&gt;</bpt>Literal<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> conformance for types that use <bpt i="10" x="10">&lt;c10&gt;</bpt>nil<ept i="10">&lt;/c10&gt;</ept> for other purposes is discouraged.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="10" x="10">&lt;c10&gt;</bpt>nil<ept i="10">&lt;/c10&gt;</ept>を他の目的に使う型のための<bpt i="6" x="6">&lt;c6&gt;</bpt>Expressible<bpt i="7" x="7">&lt;w7&gt;</bpt>By<bpt i="8" x="8">&lt;w8&gt;</bpt>Nil<bpt i="9" x="9">&lt;w9&gt;</bpt>Literal<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>準拠は、 推奨されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="9" x="9">&lt;c9&gt;</bpt>x<bpt i="10" x="10">&lt;w10&gt;</bpt>.is<bpt i="11" x="11">&lt;w11&gt;</bpt>Zero<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> is equivalent to the following comparison: <bpt i="12" x="12">&lt;c12&gt;</bpt>x == 0<bpt i="13" x="13">&lt;w13&gt;</bpt>.0<ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="9" x="9">&lt;c9&gt;</bpt>x<bpt i="10" x="10">&lt;w10&gt;</bpt>.is<bpt i="11" x="11">&lt;w11&gt;</bpt>Zero<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>は次の比較に相当するものです：<bpt i="12" x="12">&lt;c12&gt;</bpt>x == 0<bpt i="13" x="13">&lt;w13&gt;</bpt>.0<ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>Signed<ept i="0">&lt;/e0&gt;</ept> integer types can represent both positive and negative values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>符号付き<ept i="0">&lt;/e0&gt;</ept>整数型は、正および負の値の両方を表すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;e1&gt;</bpt>Unsigned<ept i="1">&lt;/e1&gt;</ept> integer types can represent only nonnegative values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;e1&gt;</bpt>符号なし<ept i="1">&lt;/e1&gt;</ept>整数型は、非負数のみ表すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>Required.<ept i="0">&lt;/s0&gt;</ept> Default implementation provided.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>必須。<ept i="0">&lt;/s0&gt;</ept> 省略時の実装の提供。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>Required.<ept i="0">&lt;/s0&gt;</ept> Default implementations provided.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>必須。<ept i="0">&lt;/s0&gt;</ept> いくつかの省略時の実装の提供。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>See Also<ept i="0">&lt;/s0&gt;</ept><bpt i="1" x="1">&lt;s1&gt;</bpt> <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;p3&gt;</bpt><ept i="3">&lt;/p3&gt;</ept><ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/s1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt>参照<ept i="0">&lt;/s0&gt;</ept><bpt i="1" x="1">&lt;s1&gt;</bpt> <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;p3&gt;</bpt><ept i="3">&lt;/p3&gt;</ept><ept i="2">&lt;/s2&gt;</ept><ept i="1">&lt;/s1&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A 16-bit signed integer value type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>16ビット符号つき整数値型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A 32-bit floating point type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>32ビット浮動小数点型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A 32-bit signed integer value type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>32ビット符号つき整数値型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A 64-bit floating point type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>64ビット浮動小数点型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A 64-bit signed integer value type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>64ビット符号付き整数値型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>Closed<bpt i="1" x="1">&lt;w1&gt;</bpt>Range<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance contains both its lower and upper bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Closed<bpt i="1" x="1">&lt;w1&gt;</bpt>Range<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスは、それの下方および上方境界の両方を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>Closed<bpt i="1" x="1">&lt;w1&gt;</bpt>Range<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance contains both its lower bound and its upper bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Closed<bpt i="1" x="1">&lt;w1&gt;</bpt>Range<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスは、それの下側の境界とそれの上側の境界の両方を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<ept i="0">&lt;/c0&gt;</ept> that provides its own implementation of this method must also guarantee that an equivalent buffer of its <bpt i="1" x="1">&lt;c1&gt;</bpt>Sub<bpt i="2" x="2">&lt;w2&gt;</bpt>Sequence<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> can be generated by advancing the pointer by the distance to the slice’s <bpt i="3" x="3">&lt;c3&gt;</bpt>start<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドのそれ独自の実装を提供する<bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<ept i="0">&lt;/c0&gt;</ept>はまた、それの<bpt i="1" x="1">&lt;c1&gt;</bpt>Sub<bpt i="2" x="2">&lt;w2&gt;</bpt>Sequence<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の同等のバッファが、スライスのもつ<bpt i="3" x="3">&lt;c3&gt;</bpt>start<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>への隔たりだけポインタを前進することによって生成されることを保証しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A <bpt i="0" x="0">&lt;c0&gt;</bpt>Range<ept i="0">&lt;/c0&gt;</ept> to convert to a <bpt i="1" x="1">&lt;c1&gt;</bpt>Closed<bpt i="2" x="2">&lt;w2&gt;</bpt>Range<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある<bpt i="0" x="0">&lt;c0&gt;</bpt>Range<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>Closed<bpt i="2" x="2">&lt;w2&gt;</bpt>Range<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>インスタンスへと変換することになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A <bpt i="1" x="1">&lt;c1&gt;</bpt>Reversed<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> instance wraps an underlying collection and provides access to its elements in reverse order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Reversed<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>インスタンスは、基礎をなすコレクションをラップして、それの要素へのアクセスを逆順で提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>binade<ept i="0">&lt;/e0&gt;</ept> is a set of binary floating-point values that all have the same sign and exponent.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>binade<ept i="0">&lt;/e0&gt;</ept>は、バイナリ浮動小数点値の一揃いです、それは全てが同じ符号と指数を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>continuation<ept i="0">&lt;/e0&gt;</ept> is an opaque representation of program state.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある<bpt i="0" x="0">&lt;e0&gt;</bpt>継続<ept i="0">&lt;/e0&gt;</ept>は、プログラム状態の不透明表現です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>decimal value<ept i="0">&lt;/e0&gt;</ept> contains the significand, a sequence of decimal digits that may include a decimal point.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>10進の値<ept i="0">&lt;/e0&gt;</ept>は仮数、小数点を含んでも良い一連の10進の桁を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>hexadecimal value<ept i="0">&lt;/e0&gt;</ept> contains the significand, either <bpt i="1" x="1">&lt;c1&gt;</bpt>0X<ept i="1">&lt;/c1&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt>0x<ept i="2">&lt;/c2&gt;</ept>, followed by a sequence of hexadecimal digits.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>16進数値<ept i="0">&lt;/e0&gt;</ept>は、仮数、<bpt i="1" x="1">&lt;c1&gt;</bpt>0X<ept i="1">&lt;/c1&gt;</ept>または<bpt i="2" x="2">&lt;c2&gt;</bpt>0x<ept i="2">&lt;/c2&gt;</ept>のどちらかに続く16進の桁を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>normal<ept i="0">&lt;/e0&gt;</ept> value is a finite number that uses the full precision available to values of a type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>ノーマル<ept i="0">&lt;/e0&gt;</ept>値は、有限数で、ある型の値に利用可能な完全な精度を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A <bpt i="0" x="0">&lt;e0&gt;</bpt>subnormal<ept i="0">&lt;/e0&gt;</ept> value is a nonzero number that has a lesser magnitude than the smallest normal number.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>サブノーマル<ept i="0">&lt;/e0&gt;</ept>値は、非ゼロ数で、最も小さいノーマル数よりも少ない規模を持つものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Boolean value converts to an <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<bpt i="3" x="3">&lt;w3&gt;</bpt>.Value<bpt i="4" x="4">&lt;w4&gt;</bpt>Type<bpt i="5" x="5">&lt;w5&gt;</bpt>.int<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ブール値は、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<bpt i="3" x="3">&lt;w3&gt;</bpt>.Value<bpt i="4" x="4">&lt;w4&gt;</bpt>Type<bpt i="5" x="5">&lt;w5&gt;</bpt>.int<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>に変わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Boolean value indicating whether the collection is empty.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションが空かどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Boolean value indicating whether the instance is NaN (“not a number”).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このインスタンスがNaN（非数）であるかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Boolean value indicating whether the instance is a signaling NaN.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このインスタンスがsignaling NaNであるかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Boolean value indicating whether the instance is equal to zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このインスタンスがゼロと等しいかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Boolean value indicating whether the instance is infinite.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このインスタンスが無限大であるかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Boolean value indicating whether the instance is subnormal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このインスタンスがサブノーマルであるかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Boolean value indicating whether the instance’s representation is in its canonical form.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このインスタンスの表現がそれの正準形式であるかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Boolean value indicating whether the range contains no elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲が何の要素も含まないかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Boolean value indicating whether this character changes under any form of case conversion.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文字がケース変換の何らかの形式の下で変化するかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Boolean value indicating whether this character is a letter.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この表意文字が表音文字であるかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Boolean value indicating whether this character is considered lowercase.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文字がローワーケースであると考えられるかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Boolean value indicating whether this character is considered uppercase.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文字がアッパーケースと考えられるかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Boolean value indicating whether this character represents a currency symbol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文字が通貨記号を表すかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Boolean value indicating whether this character represents a hexadecimal digit.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文字が16進法桁を表しているかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Boolean value indicating whether this character represents a newline.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文字がニューラインを表すかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Boolean value indicating whether this character represents a number.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文字がある数を表しているかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Boolean value indicating whether this character represents a symbol that naturally appears in mathematical contexts.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文字が数学的文脈において自然に現れるシンボルを表すかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Boolean value indicating whether this character represents a symbol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文字がシンボルを表すかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Boolean value indicating whether this character represents a whole number.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文字が整数を表しているかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Boolean value indicating whether this character represents punctuation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文字が句読点を表すかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Boolean value indicating whether this character represents whitespace, including newlines.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文字が空白を、ニューラインを含めて、表すかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Boolean value indicating whether this instance is finite.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このインスタンスが有限であるかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Boolean value indicating whether this instance is normal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このインスタンスがノーマルであるかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Boolean value indicating whether this is an ASCII character.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それがASCII文字かどうかを指し示しているブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Boolean value indicating whether this type is a signed integer type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型が符号付き整数型であるかどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Boolean value that indicates whether the dictionary is empty.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書が空かどうかを指し示すブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A NaN compares not equal, not greater than, and not less than every value, including itself.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>NaNは、それ自身を含めてあらゆる値に対して等しくない、大きくない、少なくないと比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A NaN passed as <bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept> results in another NaN, with a signaling NaN value converted to quiet NaN.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>として渡されるNaNは、シグナルNaN値はクワイエットNaNに変換されて、別のNaNという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A NaN passed as <bpt i="1" x="1">&lt;c1&gt;</bpt>value<ept i="1">&lt;/c1&gt;</ept> results in another NaN, with a signaling NaN value converted to quiet NaN.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>value<ept i="1">&lt;/c1&gt;</ept>として渡されるNaNは、シグナルNaN値はクワイエットNaNに変換されて、別のNaNという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A NaN value may also include a payload in parentheses following the <bpt i="0" x="0">&lt;c0&gt;</bpt>"nan"<ept i="0">&lt;/c0&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるNaN値はまた、<bpt i="0" x="0">&lt;c0&gt;</bpt>"nan"<ept i="0">&lt;/c0&gt;</ept>キーワードに続けて丸括弧の中にペイロードを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A UTF-16 encoding of <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>のUTF-16符号化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A UTF-8 encoding of <bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>のUTF-8符号化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A Unicode string value that is a collection of characters.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるユニコード文字列値、それは、いくらかの文字からなる１つのコレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A binary floating-point type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>exponent<bpt i="1" x="1">&lt;w1&gt;</bpt>Bit<bpt i="2" x="2">&lt;w2&gt;</bpt>Count<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> imposes a limit on the range of the exponent for normal, finite values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>バイナリ浮動小数点型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>exponent<bpt i="1" x="1">&lt;w1&gt;</bpt>Bit<bpt i="2" x="2">&lt;w2&gt;</bpt>Count<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、正規化数の、有限の値に対する指数の範囲に限界を課します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A bit pattern to use for the address of the new pointer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいポインタのアドレスのために使われるビットパターン。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A bitwise AND operation results in a value that has each bit set to <bpt i="0" x="0">&lt;c0&gt;</bpt>1<ept i="0">&lt;/c0&gt;</ept> where <bpt i="1" x="1">&lt;e1&gt;</bpt>both<ept i="1">&lt;/e1&gt;</ept> of its arguments have that bit set to <bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ビット単位AND演算は、ある値という結果になります、それが各ビットを<bpt i="0" x="0">&lt;c0&gt;</bpt>1<ept i="0">&lt;/c0&gt;</ept>に設定するのは、<bpt i="1" x="1">&lt;e1&gt;</bpt>両方<ept i="1">&lt;/e1&gt;</ept>のそれの引数が、そのビットを<bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>に設定するところです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A bitwise OR operation results in a value that has each bit set to <bpt i="0" x="0">&lt;c0&gt;</bpt>1<ept i="0">&lt;/c0&gt;</ept> where <bpt i="1" x="1">&lt;e1&gt;</bpt>one or both<ept i="1">&lt;/e1&gt;</ept> of its arguments have that bit set to <bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ビット単位OR演算は、ある値という結果になります、それが各ビットを<bpt i="0" x="0">&lt;c0&gt;</bpt>1<ept i="0">&lt;/c0&gt;</ept>に設定するのは、<bpt i="1" x="1">&lt;e1&gt;</bpt>一方または両方<ept i="1">&lt;/e1&gt;</ept>のそれの引数が、そのビットを<bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>に設定するところです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A bitwise XOR operation, also known as an exclusive OR operation, results in a value that has each bit set to <bpt i="0" x="0">&lt;c0&gt;</bpt>1<ept i="0">&lt;/c0&gt;</ept> where <bpt i="1" x="1">&lt;e1&gt;</bpt>one or the other but not both<ept i="1">&lt;/e1&gt;</ept> of its arguments had that bit set to <bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ビット単位XOR演算、または排他的OR演算として知られるものは、１つの値という結果になり、それは各ビットが<bpt i="0" x="0">&lt;c0&gt;</bpt>1<ept i="0">&lt;/c0&gt;</ept>に設定されます、そこにおいて<bpt i="1" x="1">&lt;e1&gt;</bpt>一方または他方しかし両方でなく<ept i="1">&lt;/e1&gt;</ept>それの引数がそのビットを<bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A callback to invoke when iteration of a AsyncStream is cancelled.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>AsyncStreamの反復が取り消される時に発動するコールバック。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A callback to invoke when iteration of a AsyncThrowingStream is cancelled.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>AsyncThrowingStreamの反復が取り消される時に発動するコールバック。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A character with the value “\r\n” (CR-LF) is normalized to “\n” (LF) and has an <bpt i="0" x="0">&lt;c0&gt;</bpt>ascii<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property equal to 10.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値 “\r\n” (CR-LF) を持つある文字は、“\n” (LF) に正規化されます、そして10に等しい<bpt i="0" x="0">&lt;c0&gt;</bpt>ascii<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A class of types whose instances hold the value of an entity with stable identity.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それらのインスタンスはある登録項目の値を安定した同一性で保持するところの型それらのクラス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that accepts an <bpt i="0" x="0">&lt;c0&gt;</bpt>inout<ept i="0">&lt;/c0&gt;</ept> state and returns the next element of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>inout<ept i="0">&lt;/c0&gt;</ept>状態を受け取り、そしてそのシーケンスの次の要素を返すクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that accepts an element of this sequence as its argument and returns a sequence or collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それはこのシーケンスのひとつの要素をそれの引数として受け取って、あるシーケンスまたはコレクションを返すものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that accepts an element of this sequence as its argument and returns an optional value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それはこのシーケンスのひとつの要素をそれの引数として受け取って、ひとつのオプショナルの値を返すものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that accepts the previous sequence element and returns the next element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それは前のシーケンス要素を受け取り、次の要素を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that combines an accumulating value and an element of the asynchronous sequence into a new accumulating value, for use in the next call of the <bpt i="0" x="0">&lt;c0&gt;</bpt>next<bpt i="1" x="1">&lt;w1&gt;</bpt>Partial<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> closure or returned to the caller.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それは蓄積値と非同期シーケンスのいち要素を新しい蓄積値へと結合します、<bpt i="0" x="0">&lt;c0&gt;</bpt>next<bpt i="1" x="1">&lt;w1&gt;</bpt>Partial<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>クロージャの次の呼び出しにおいて使うためにまたは呼び出し側に返されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the <bpt i="0" x="0">&lt;c0&gt;</bpt>next<bpt i="1" x="1">&lt;w1&gt;</bpt>Partial<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> closure or returned to the caller.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それは蓄積値をシーケンスのいち要素と結合して新しい蓄積値とし、<bpt i="0" x="0">&lt;c0&gt;</bpt>next<bpt i="1" x="1">&lt;w1&gt;</bpt>Partial<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>クロージャの次の呼び出しにおいて使われるか、呼び出し側に返されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that is called with the values for any duplicate keys that are encountered.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャで、出くわす何らかの重複キーに対するそれら値とともに呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that is executed immediately with an escapable copy of <bpt i="0" x="0">&lt;c0&gt;</bpt>closure<ept i="0">&lt;/c0&gt;</ept> as its argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>closure<ept i="0">&lt;/c0&gt;</ept>の脱出可能コピーをそれの引数として使い直ちに実行されるクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that processes one <bpt i="0" x="0">&lt;c0&gt;</bpt>output<bpt i="1" x="1">&lt;w1&gt;</bpt>Encoding<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> code unit at a time.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それは一度に１つの<bpt i="0" x="0">&lt;c0&gt;</bpt>output<bpt i="1" x="1">&lt;w1&gt;</bpt>Encoding<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>コードユニットを処理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that returns <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if its argument should be used to split the sequence; otherwise, <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>１つのクロージャ、それはそれの引数が使われてシーケンスを分割するならば<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>を；そうでなければ、<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that returns a Boolean value indicating whether two elements are equivalent.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの要素が等しいかどうかを指し示しているブール値を返すクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that returns a key for each element in <bpt i="0" x="0">&lt;c0&gt;</bpt>values<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>values<ept i="0">&lt;/c0&gt;</ept>の中の各要素に対するキーを返すクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that returns an optional element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それはあるオプショナルの要素を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes a <bpt i="0" x="0">&lt;c0&gt;</bpt>Checked<bpt i="1" x="1">&lt;w1&gt;</bpt>Continuation<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> parameter.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それは<bpt i="0" x="0">&lt;c0&gt;</bpt>Checked<bpt i="1" x="1">&lt;w1&gt;</bpt>Continuation<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>バラメータを取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes a key-value pair as its argument and returns a Boolean value indicating whether the pair should be included in the returned dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キー値ペアをそれの引数として取り、返される辞書にそのペアが含まれるべきかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes a mutable pointer to <bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept> as its sole argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept>への可変ポインタをそれの唯一の引数として取るクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes a pointer to <bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept> as its sole argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept>へのポインタをそれの唯一の引数として取るクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes a raw buffer pointer to the bytes of <bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept> as its sole argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept>のバイトへの生のバッファポインタをそれの唯一の引数として取るクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an <bpt i="0" x="0">&lt;c0&gt;</bpt>Unsafe<bpt i="1" x="1">&lt;w1&gt;</bpt>Continuation<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> parameter.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それは<bpt i="0" x="0">&lt;c0&gt;</bpt>Unsafe<bpt i="1" x="1">&lt;w1&gt;</bpt>Continuation<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>バラメータを取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an <bpt i="0" x="0">&lt;c0&gt;</bpt>Unsafe<bpt i="1" x="1">&lt;w1&gt;</bpt>Current<bpt i="2" x="2">&lt;w2&gt;</bpt>Task<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> parameter.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それは<bpt i="0" x="0">&lt;c0&gt;</bpt>Unsafe<bpt i="1" x="1">&lt;w1&gt;</bpt>Current<bpt i="2" x="2">&lt;w2&gt;</bpt>Task<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>バラメータを取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an element as a parameter and returns a Boolean value indicating whether the element should be included in the modified sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それはある要素をパラメータとして取り、その要素がこの修正後のシーケンスに含まれるべきかどうかを指し示すブール値を返すものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それはある要素をパラメータとして取り、その要素をこの修正後のシーケンスから抜かすことになるかどうかを指し示すブール値を返すものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an element as an argument and returns a Boolean value indicating whether the collection should be split at that element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それは１つの要素を引数として取り、コレクションがその要素で分割されるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an element as its argument and returns a Boolean value that indicates whether the passed element represents a match.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それは１つの要素をそれの引数として取り、渡された要素が合致するものであるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the element is a match.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それは非同期シーケンスの１つの要素をそれの引数として取り、その要素があるマッチであるかどうかを指し示しているブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それはこの非同期シーケンスの１つの要素をそれの引数として取り、渡された要素があるマッチを表すかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それはこの非同期シーケンスの１つの要素をそれの引数として取り、渡された要素がある条件を満たすかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それは非同期シーケンスの１つの要素をそれの引数として取り、その要素をこの平坦化されたシーケンスに含むことになるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an element of the sequence as a parameter.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それはシーケンスの１要素を引数として取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an element of the sequence as its argument and returns <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if the element should be included or <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept> if it should be excluded.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それはシーケンスの１つの要素をそれの引数として取り、その要素が含まれるべきならば<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>をまたはそれが除外されるべきならば<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an element of the sequence as its argument and returns <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if the element should be skipped or <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept> if it should be included.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それはシーケンスの１つの要素をそれの引数として取り、その要素が省かれるべきならば<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>をまたはそれが含まれるべきならば<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element is a match.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それはシーケンスの１つの要素をそれの引数として取り、その要素が合致するものかどうかを指し示しているブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the result.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それはシーケンスの１つの要素をそれの引数として取り、その要素が結果に含まれるべきかどうかを指し示しているブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それはシーケンスの１つの要素をそれの引数として取り、その要素が返される配列に含まれるべきかどうかを指し示しているブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be removed from the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それはシーケンスの１つの要素をそれの引数として取り、その要素がコレクションから除去されるべきかどうかを指し示しているブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element represents a match.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それはこのシーケンスの１つの要素をそれの引数として取り、渡された要素が合致するものであるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes an element of the sequence as its argument and returns a Boolean value that indicates whether the passed element satisfies a condition.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャ、それはこのシーケンスの１つの要素をそれの引数として取り、渡された要素がある条件を満たすかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that takes the current and new values for any duplicate keys.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャで、何らかの重複キーに対する現在および新しい値それぞれをとるもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that transforms a value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値を変換するクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure that updates the accumulating value with an element of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>蓄積される値をこのシーケンスのある要素を使って更新するクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure to execute that depends on the lifetime of <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> being extended.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>延長されている<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>の生涯に依存して実行するクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure with a <bpt i="0" x="0">&lt;c0&gt;</bpt>CVa<bpt i="1" x="1">&lt;w1&gt;</bpt>List<bpt i="2" x="2">&lt;w2&gt;</bpt>Pointer<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> parameter that references the arguments passed as <bpt i="3" x="3">&lt;c3&gt;</bpt>args<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>args<ept i="3">&lt;/c3&gt;</ept>として渡される引数を参照する<bpt i="0" x="0">&lt;c0&gt;</bpt>CVa<bpt i="1" x="1">&lt;w1&gt;</bpt>List<bpt i="2" x="2">&lt;w2&gt;</bpt>Pointer<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>パラメータを持つクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure with an <bpt i="0" x="0">&lt;c0&gt;</bpt>Unsafe<bpt i="1" x="1">&lt;w1&gt;</bpt>Buffer<bpt i="2" x="2">&lt;w2&gt;</bpt>Pointer<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> parameter that points to the contiguous storage for the array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャで<bpt i="0" x="0">&lt;c0&gt;</bpt>Unsafe<bpt i="1" x="1">&lt;w1&gt;</bpt>Buffer<bpt i="2" x="2">&lt;w2&gt;</bpt>Pointer<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>パラメータを持ち、それはその配列のための隣接ストレージを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure with an <bpt i="0" x="0">&lt;c0&gt;</bpt>Unsafe<bpt i="1" x="1">&lt;w1&gt;</bpt>Mutable<bpt i="2" x="2">&lt;w2&gt;</bpt>Buffer<bpt i="3" x="3">&lt;w3&gt;</bpt>Pointer<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> parameter that points to the contiguous storage for the array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャで<bpt i="0" x="0">&lt;c0&gt;</bpt>Unsafe<bpt i="1" x="1">&lt;w1&gt;</bpt>Mutable<bpt i="2" x="2">&lt;w2&gt;</bpt>Buffer<bpt i="3" x="3">&lt;w3&gt;</bpt>Pointer<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>パラメータを持ち、それはその配列のための隣接ストレージを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure with an <bpt i="0" x="0">&lt;c0&gt;</bpt>Unsafe<bpt i="1" x="1">&lt;w1&gt;</bpt>Mutable<bpt i="2" x="2">&lt;w2&gt;</bpt>Raw<bpt i="3" x="3">&lt;w3&gt;</bpt>Buffer<bpt i="4" x="4">&lt;w4&gt;</bpt>Pointer<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> parameter that points to the contiguous storage for the array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャで<bpt i="0" x="0">&lt;c0&gt;</bpt>Unsafe<bpt i="1" x="1">&lt;w1&gt;</bpt>Mutable<bpt i="2" x="2">&lt;w2&gt;</bpt>Raw<bpt i="3" x="3">&lt;w3&gt;</bpt>Buffer<bpt i="4" x="4">&lt;w4&gt;</bpt>Pointer<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>パラメータを持ち、それはその配列のための隣接ストレージを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A closure with an <bpt i="0" x="0">&lt;c0&gt;</bpt>Unsafe<bpt i="1" x="1">&lt;w1&gt;</bpt>Raw<bpt i="2" x="2">&lt;w2&gt;</bpt>Buffer<bpt i="3" x="3">&lt;w3&gt;</bpt>Pointer<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> parameter that points to the contiguous storage for the array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャで<bpt i="0" x="0">&lt;c0&gt;</bpt>Unsafe<bpt i="1" x="1">&lt;w1&gt;</bpt>Raw<bpt i="2" x="2">&lt;w2&gt;</bpt>Buffer<bpt i="3" x="3">&lt;w3&gt;</bpt>Pointer<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>パラメータを持ち、それはその配列のための隣接ストレージを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection and its slices share the same indices.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションとそれのスイラスは同じインデックスを共有します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection containing a single element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>単一の要素を含んでいるコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection containing just the keys of the dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書のキーだけを含んでいるコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection containing just the values of the dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書の値だけを含んでいるコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection containing the words of this value’s binary representation, in order from the least significant to most significant.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値の持つバイナリ表現の単語いくらかを含んでいるコレクション、最下位から最上位への順番で。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection difference with all possible moves inferred.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>可能な限り移動それらが推測された状態でのあるコレクション差異。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection of all values of this type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型の全ての値からなるコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection of changes that represent a transition between two states.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの状態の間の推移を表す変更いくつからなるあるコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection of indices for an arbitrary collection</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>不定なコレクションのためのインデックスのコレクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection of insertions and removals that describe the difference between two ordered collection states.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの順序付きコレクション状態の間の差異を記述するいくらかの挿入と除去からなるあるコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection or finite sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションまたは有限のシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection that contains <bpt i="0" x="0">&lt;c0&gt;</bpt>count<ept i="0">&lt;/c0&gt;</ept> elements that are all <bpt i="1" x="1">&lt;c1&gt;</bpt>element<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>count<ept i="0">&lt;/c0&gt;</ept>個の要素を含んでいるコレクション、それはすべてが<bpt i="1" x="1">&lt;c1&gt;</bpt>element<ept i="1">&lt;/c1&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection that presents the elements of its base collection in reverse order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるコレクション、それは、それの基盤コレクションの要素を逆順で提示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection that supports backward as well as forward traversal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>前方にだけでなく後方へ辿っていくこともサポートするコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection that supports efficient random-access index traversal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>効率のよい無作為アクセスのインデックス探査をサポートするコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection whose element type is <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> but that is always empty.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それの要素型は<bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>である、しかし常に空であるコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection whose elements are all identical.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるコレクション、その要素は全て同一です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection whose elements are key-value pairs.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それの要素がキー値ペアであるコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection’s <bpt i="0" x="0">&lt;c0&gt;</bpt>indices<ept i="0">&lt;/c0&gt;</ept> property can hold a strong reference to the collection itself, causing the collection to be non-uniquely referenced.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるコレクションの<bpt i="0" x="0">&lt;c0&gt;</bpt>indices<ept i="0">&lt;/c0&gt;</ept>プロパティは、そのコレクション自身に対する強い参照を保持でき、そのコレクションが特有にでなくとも参照されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A collection’s <bpt i="0" x="0">&lt;c0&gt;</bpt>indices<ept i="0">&lt;/c0&gt;</ept> property can hold a strong reference to the collection itself, causing the collection to be nonuniquely referenced.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるコレクションの<bpt i="0" x="0">&lt;c0&gt;</bpt>indices<ept i="0">&lt;/c0&gt;</ept>プロパティは、そのコレクション自身に対する強い参照を保持でき、そのコレクションが非特有に参照されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A conforming type may contain a subset of values which are treated as exceptional—that is, values that are outside the domain of meaningful arguments for the purposes of the <bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>準拠している型は、普通でないものとして扱われる値の下位集合を含むでしょう — すなわち、<bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept>プロトコルの用途のための意味のある引数の領域の外側である値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A conforming type may use any integer radix, but values other than 2 (for binary floating-point types) or 10 (for decimal floating-point types) are extraordinarily rare in practice.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>準拠する型は、あらゆる整数基数を使うことができます、しかし２（バイナリ浮動小数点型に対して）または10（10進浮動小数点型に対して）より他の値は、実際には非常に稀です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A contiguously stored array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>隣接保管の配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A continuation must be resumed exactly once.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>継続は、厳密に一度だけ再開されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A custom playground Quick Look for the <bpt i="0" x="0">&lt;c0&gt;</bpt>Bool<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bool<ept i="0">&lt;/c0&gt;</ept>インスタンスのためのあつらえのプレイグラウンドクイックルック。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A custom playground Quick Look for the <bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept>インスタンスのためのあつらえのプレイグラウンド「クイックルック」。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A custom playground Quick Look for the <bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept>インスタンスのためのあつらえのプレイグラウンド「クイックルック」。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A custom playground Quick Look for the <bpt i="0" x="0">&lt;c0&gt;</bpt>Float<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Float<ept i="0">&lt;/c0&gt;</ept>インスタンスのためのあつらえのプレイグラウンド「クイックルック」。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A custom playground Quick Look for the <bpt i="0" x="0">&lt;c0&gt;</bpt>Int16<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Int16<ept i="0">&lt;/c0&gt;</ept>インスタンスのためのあつらえのプレイグラウンド「クイックルック」。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A custom playground Quick Look for the <bpt i="0" x="0">&lt;c0&gt;</bpt>Int32<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Int32<ept i="0">&lt;/c0&gt;</ept>インスタンスのためのあつらえのプレイグラウンド「クイックルック」。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A custom playground Quick Look for the <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>インスタンスのためのあつらえのプレイグラウンド「クイックルック」。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A custom playground description for this instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このインスタンスに対するあつらえのplayground記述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A decimal value may also include an exponent following the significand, indicating the power of 10 by which the significand should be multiplied.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>10進の値はまた、それによって仮数が乗算されるべき10の冪を指し示す指数を、仮数に続けて含んでも構いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A description of what went wrong, for debugging purposes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>何がうまくいかなかったかの記述、デバッグ目的のため。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A dictionary containing the keys and non-<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> transformed values of this dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この辞書のキーと非<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>の変換済値を含んでいるある辞書。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A dictionary containing the keys and transformed values of this dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この辞書のキーと変換された値を含んでいる辞書。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A dictionary is a type of hash table, providing fast access to the entries it contains.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書はある種のハッシュテーブルであり、それが含んでいる登録項目への高速なアクセスを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A dictionary literal is <bpt i="0" x="0">&lt;e0&gt;</bpt>not<ept i="0">&lt;/e0&gt;</ept> the same as an instance of <bpt i="1" x="1">&lt;c1&gt;</bpt>Dictionary<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書リテラルは、<bpt i="1" x="1">&lt;c1&gt;</bpt>Dictionary<ept i="1">&lt;/c1&gt;</ept>のインスタンスと同じ<bpt i="0" x="0">&lt;e0&gt;</bpt>ではありません<ept i="0">&lt;/e0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A dictionary literal is a comma-separated list of key-value pairs, in which a colon separates each key from its associated value, surrounded by square brackets.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書リテラルは、「キーと値」の組（キー値ペア）のコンマ区切りのリストで角括弧で囲まれています、このキー値ペアではコロンが各キーをそれの関連値から切り離します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A dictionary literal is a simple way of writing a list of key-value pairs.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書リテラルは、「キー値」ペアのリストを書く簡単な方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A dictionary of the key-value pairs that <bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Included<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> allows.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Included<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が認めるキー値ペアからなる辞書。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A dictionary to merge.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結合することになる辞書。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A dictionary value converts to an <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<bpt i="3" x="3">&lt;w3&gt;</bpt>.Value<bpt i="4" x="4">&lt;w4&gt;</bpt>Type<bpt i="5" x="5">&lt;w5&gt;</bpt>.dictionary<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書値は、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<bpt i="3" x="3">&lt;w3&gt;</bpt>.Value<bpt i="4" x="4">&lt;w4&gt;</bpt>Type<bpt i="5" x="5">&lt;w5&gt;</bpt>.dictionary<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>に変わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A dictionary’s indices stay valid across additions to the dictionary as long as the dictionary has enough capacity to store the added values without allocating more buffer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書のインデックスは、その辞書への追加をまたいで有効なままです、加えられた値をもっとバッファを割り当てることなく格納するために辞書が十分な容量を持つ限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A double value converts to an <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<bpt i="3" x="3">&lt;w3&gt;</bpt>.Value<bpt i="4" x="4">&lt;w4&gt;</bpt>Type<bpt i="5" x="5">&lt;w5&gt;</bpt>.double<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>double値は、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<bpt i="3" x="3">&lt;w3&gt;</bpt>.Value<bpt i="4" x="4">&lt;w4&gt;</bpt>Type<bpt i="5" x="5">&lt;w5&gt;</bpt>.double<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>に変わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A double-precision, floating-point value type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>倍精度、浮動小数点値型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A error-throwing closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the modified sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるエラースロークロージャ、それは非同期シーケンスの１つの要素をそれの引数として取り、その要素をこの修正されたシーケンスに含むことになるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A false value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるfalse値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A flattened view of the elements of this sequence of sequences.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>複数のシーケンスからなるこのシーケンスの要素のある平坦なビュー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A floating-point numeric type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>浮動小数点数値型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A floating-point value to be converted.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>変換されることになる浮動小数点値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A floating-point value to compare to this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値と比較される浮動小数点値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A floating-point value to convert to an integer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>整数へと変換する浮動小数点値．</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A floating-point value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある浮動小数点値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A half-open interval from a lower bound up to, but not including, an upper bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下側の境界から、上側の境界まで、しかしそれを含んでいない、半開間隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A half-precision (16b), floating-point value type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>半精度（16b）、浮動小数点値型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A hashable value to wrap.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ラップすることになるハッシュ可能値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A hexadecimal value may also include an exponent following the significand, indicating the power of 2 by which the significand should be multiplied.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>16進数値はまた、それによって仮数が乗算されるべき２の冪を指し示す指数を、仮数に続けて含んでも構いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A key path from a specific root type to a specific resulting value type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>特定の根本の型から特定の結果値の型へのキーパス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A key path from the root of this key path and the value type of <bpt i="0" x="0">&lt;c0&gt;</bpt>path<ept i="0">&lt;/c0&gt;</ept>, if <bpt i="1" x="1">&lt;c1&gt;</bpt>path<ept i="1">&lt;/c1&gt;</ept> can be appended.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このキーパスのルートからのキーパスと<bpt i="0" x="0">&lt;c0&gt;</bpt>path<ept i="0">&lt;/c0&gt;</ept>の値型、もし<bpt i="1" x="1">&lt;c1&gt;</bpt>path<ept i="1">&lt;/c1&gt;</ept>が追加されるならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A key path from the root of this key path to the value type of <bpt i="0" x="0">&lt;c0&gt;</bpt>path<ept i="0">&lt;/c0&gt;</ept>, if <bpt i="1" x="1">&lt;c1&gt;</bpt>path<ept i="1">&lt;/c1&gt;</ept> can be appended.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このキーパスのルートから<bpt i="0" x="0">&lt;c0&gt;</bpt>path<ept i="0">&lt;/c0&gt;</ept>の値型へのキーパス、もし<bpt i="1" x="1">&lt;c1&gt;</bpt>path<ept i="1">&lt;/c1&gt;</ept>が追加できるならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A key path from the root of this key path to the value type of <bpt i="0" x="0">&lt;c0&gt;</bpt>path<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このキーパスのルートから、<bpt i="0" x="0">&lt;c0&gt;</bpt>path<ept i="0">&lt;/c0&gt;</ept>の値型へのキーパス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A keyed decoding container view into this decoder.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このデコーダへのキー付きデコーディングコンテナビュー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A label to use when writing the contents of <bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept>の内容を書き込むときに使うラベル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A lightweight collection of key-value pairs.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キー値ペアの軽量コレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A mapping closure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>マップを行うクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A mechanism to interface between synchronous and asynchronous code, logging correctness violations.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同期と非同期のコードの間を取り持つためのある仕組み、それは正確さ侵害を記録します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A mechanism to interface between synchronous and asynchronous code, without correctness checking.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同期と非同期のコードの間を取り持つための仕組み、正確さ検査なしで。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A mirror that reflects the <bpt i="0" x="0">&lt;c0&gt;</bpt>Bool<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bool<ept i="0">&lt;/c0&gt;</ept>インスタンスを反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A mirror that reflects the <bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept>インスタンスを反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A mirror that reflects the <bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept>インスタンスを反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A mirror that reflects the <bpt i="0" x="0">&lt;c0&gt;</bpt>Float<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Float<ept i="0">&lt;/c0&gt;</ept>インスタンスを反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A mirror that reflects the <bpt i="0" x="0">&lt;c0&gt;</bpt>Int16<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Int16<ept i="0">&lt;/c0&gt;</ept>インスタンスを反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A mirror that reflects the <bpt i="0" x="0">&lt;c0&gt;</bpt>Int32<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Int32<ept i="0">&lt;/c0&gt;</ept>インスタンスを反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A mirror that reflects the <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>インスタンスを反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A mirror that reflects the Float80 instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Float80インスタンスを反映するあるミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A mirror that reflects the array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その配列を反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A mirror that reflects the dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その辞書を反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A mirror that reflects the iterator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのイテレータを反映するミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A mutable pointer addressing an Objective-C reference that doesn’t own its target.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それのターゲットを所有しないObjective-C参照をアドレス指定している可変ポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A negative value that uses the full precision of the floating-point type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>負の値、それは浮動小数点型の最大精度を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A negative, nonzero number that does not use the full precision of the floating-point type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>負の、非ゼロの数、それは浮動小数点型の最大精度を使いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A new <bpt i="0" x="0">&lt;c0&gt;</bpt>.data<bpt i="1" x="1">&lt;w1&gt;</bpt>Corrupted<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> error with the given information.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>を与えられた情報を持つ新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>.data<bpt i="1" x="1">&lt;w1&gt;</bpt>Corrupted<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>エラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A new dictionary initialized with the elements of <bpt i="0" x="0">&lt;c0&gt;</bpt>keys<bpt i="1" x="1">&lt;w1&gt;</bpt>And<bpt i="2" x="2">&lt;w2&gt;</bpt>Values<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>keys<bpt i="1" x="1">&lt;w1&gt;</bpt>And<bpt i="2" x="2">&lt;w2&gt;</bpt>Values<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の要素で初期化された新しい辞書。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A new dictionary with the combined keys and values of this dictionary and <bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この辞書と<bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>のキーと値を組み合わせた新しい辞書。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A new empty single value container.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい空の単一値コンテナ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A new empty unkeyed container.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい空のキー付けされないコンテナ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A new instance initialized with <bpt i="0" x="0">&lt;c0&gt;</bpt>raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> will be equivalent to this instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>で初期化された新しいインスタンスは、このインスタンスに相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A new instance of type <bpt i="0" x="0">&lt;c0&gt;</bpt>U<ept i="0">&lt;/c0&gt;</ept>, cast from <bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型<bpt i="0" x="0">&lt;c0&gt;</bpt>U<ept i="0">&lt;/c0&gt;</ept>の新しいインスタンス、<bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept>からキャストされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A new keyed encoding container.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいキー付けされるエンコーディングコンテナ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A new range clamped to the bounds of <bpt i="0" x="0">&lt;c0&gt;</bpt>limits<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>limits<ept i="0">&lt;/c0&gt;</ept>の境界内に制限された、新しい範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A nil-coalescing operation unwraps the left-hand side if it has a value, or it returns the right-hand side as a default.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>nil合体演算は、左手側をそれが値を持つならばアンラップします、またはそれは右手側を省略時のものとして返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A nil-coalescing operation unwraps the left-hand side if it has a value, or returns the right-hand side as a default.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>nil合体演算は、左手側をそれが値を持つならばアンラップします、または右手側を省略時のものとして返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A non-<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> <bpt i="2" x="2">&lt;c2&gt;</bpt>associated<bpt i="3" x="3">&lt;w3&gt;</bpt>With<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> value is the offset of the complementary change.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>非<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>の<bpt i="2" x="2">&lt;c2&gt;</bpt>associated<bpt i="3" x="3">&lt;w3&gt;</bpt>With<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>値は、補足的変更のオフセットです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A nonescaping closure value that is made escapable for the duration of the execution of the <bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept> closure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>非脱出クロージャ値で、<bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept>クロージャの実行の間に脱出可能にされるもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A numeric value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある数値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A parameterized class written in Objective-C is imported into Swift as a generic class with the same number of type parameters.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-Cにおいて書かれたパラメータ化されたクラスは、同じ数の型パラメータを持つ総称体クラスとしスウィフトにインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A partially type-erased key path, from a concrete root type to any resulting value type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある部分的な型消去キーパス、具体的な根本の型から何らかの結果値の型への。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A pointer advanced from this pointer by <bpt i="0" x="0">&lt;c0&gt;</bpt>Memory<bpt i="1" x="1">&lt;w1&gt;</bpt>Layout&lt;Pointee&gt;.stride<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> bytes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このポインタから<bpt i="0" x="0">&lt;c0&gt;</bpt>Memory<bpt i="1" x="1">&lt;w1&gt;</bpt>Layout&lt;Pointee&gt;.stride<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>バイトだけ繰り上げられるポインタを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A pointer offset from this pointer by <bpt i="0" x="0">&lt;c0&gt;</bpt>n<ept i="0">&lt;/c0&gt;</ept> instances of the <bpt i="1" x="1">&lt;c1&gt;</bpt>Pointee<ept i="1">&lt;/c1&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このポインタから<bpt i="0" x="0">&lt;c0&gt;</bpt>n<ept i="0">&lt;/c0&gt;</ept>個の<bpt i="1" x="1">&lt;c1&gt;</bpt>Pointee<ept i="1">&lt;/c1&gt;</ept>型のインスタンス分だけ補われたポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A pointer shifted backward from this pointer by <bpt i="0" x="0">&lt;c0&gt;</bpt>Memory<bpt i="1" x="1">&lt;w1&gt;</bpt>Layout&lt;Pointee&gt;.stride<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> bytes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このポインタから後ろへ<bpt i="0" x="0">&lt;c0&gt;</bpt>Memory<bpt i="1" x="1">&lt;w1&gt;</bpt>Layout&lt;Pointee&gt;.stride<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>バイトだけずらされるポインタを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A pointer that can be used with C functions that take a <bpt i="0" x="0">&lt;c0&gt;</bpt>va<bpt i="1" x="1">&lt;w1&gt;</bpt>_list<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>va<bpt i="1" x="1">&lt;w1&gt;</bpt>_list<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>引数を取るC関数で使用できるポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A position in a FlattenCollection</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>FlattenCollectionの中のある位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A positive <bpt i="0" x="0">&lt;c0&gt;</bpt>stride<ept i="0">&lt;/c0&gt;</ept> iterates upward; a negative <bpt i="1" x="1">&lt;c1&gt;</bpt>stride<ept i="1">&lt;/c1&gt;</ept> iterates downward.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>正の<bpt i="0" x="0">&lt;c0&gt;</bpt>stride<ept i="0">&lt;/c0&gt;</ept>は上向きに反復していきます；負の<bpt i="1" x="1">&lt;c1&gt;</bpt>stride<ept i="1">&lt;/c1&gt;</ept>は下向きに反復していきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A positive value that uses the full precision of the floating-point type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>正の値、それは浮動小数点型の最大精度を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A positive, nonzero number that does not use the full precision of the floating-point type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>正の、非ゼロの数、それは浮動小数点型の最大精度を使いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A predicate that returns <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if its first argument should be ordered before its second argument; otherwise, <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある述部、それはそれの最初の引数がそれの２番目の引数の前に並べられるべきならば<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>を返します；そうでなければ、<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A predicate that returns <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if its two arguments are equivalent; otherwise, <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある述部、それはそれの２つの引数が等しいならば<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>を返します；そうでなければ、<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A predicate that throws an error also never executes again.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>エラーをスローする述部は、同様に決して再び遂行しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A predicate used to partition the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションに仕切りをするのに使われる述部。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A protocol that enables an object to be encoded and decoded for archiving and distribution.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるオブジェクトにアーカイブと配布のためにエンコードおよびデコードされることを可能にするプロトコル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A protocol that enables encoding and decoding in a manner that is robust against object substitution attacks.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>エンコーディングとデコーディングを、オブジェクト置き換え攻撃に対して強固であるある流儀で可能にするプロトコル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A quiet NaN (“not a number”).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>クワイエットNaN（非数）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A radix-2 (binary) floating-point type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるradix-2（バイナリ）浮動小数点型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A random element from the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このコレクションからのある無作為の要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A random value within the bounds of <bpt i="0" x="0">&lt;c0&gt;</bpt>range<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>range<ept i="0">&lt;/c0&gt;</ept>の境界内のある無作為な値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A range of integers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>整数からなる範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A range of the collection’s indices.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションのもつインデックスのある範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A range suitable for slicing <bpt i="0" x="0">&lt;c0&gt;</bpt>collection<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>スライスする<bpt i="0" x="0">&lt;c0&gt;</bpt>collection<ept i="0">&lt;/c0&gt;</ept>に対して適している範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A range to check for elements in common.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>共通の要素を調べる範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A range to compare.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>比較する範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A range-replaceable collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲置換可能なコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A raw memory buffer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>生のメモリバッファ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A raw-representable instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>生の表現が可能なインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A reference to compare.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>比較する参照。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A removal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある削除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A representation of the substructure and display style of an instance of any type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下位構造体の表現と何らかの型のインスタンスの表示形式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A representation of this integer with the byte order swapped.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この整数のバイト順交換した表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A result of yielding values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値を生み出すことの結果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A result to yield from the continuation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その継続から生まれた結果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A rule for rounding a floating-point number.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>浮動小数点数を丸める為のある規則。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A second raw-representable instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>第２の生の表現が可能なインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence built around an iterator of type <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型<bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept>のイテレータに基づいて構築されるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence consisting of all the elements contained in each segment contained in some <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept> sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>何らかの<bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept>シーケンスに含まれる各断片の中に含まれるいくらかの要素から成るシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence containing the same elements as this sequence, but on which some operations, such as <bpt i="0" x="0">&lt;c0&gt;</bpt>map<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>filter<ept i="1">&lt;/c1&gt;</ept>, are implemented lazily.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスと同じ要素を含んでいるシーケンス、しかしそれの上で何らかの演算、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>map<ept i="0">&lt;/c0&gt;</ept>や<bpt i="1" x="1">&lt;c1&gt;</bpt>filter<ept i="1">&lt;/c1&gt;</ept>が遅延に実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence from <bpt i="0" x="0">&lt;c0&gt;</bpt>start<ept i="0">&lt;/c0&gt;</ept> toward, and possibly including, <bpt i="1" x="1">&lt;c1&gt;</bpt>end<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>start<ept i="0">&lt;/c0&gt;</ept>から、そして可能なら含めて、<bpt i="1" x="1">&lt;c1&gt;</bpt>end<ept i="1">&lt;/c1&gt;</ept>へ向かってのシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence from <bpt i="0" x="0">&lt;c0&gt;</bpt>start<ept i="0">&lt;/c0&gt;</ept> toward, but not including, <bpt i="1" x="1">&lt;c1&gt;</bpt>end<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>start<ept i="0">&lt;/c0&gt;</ept>から、そして含めずに、<bpt i="1" x="1">&lt;c1&gt;</bpt>end<ept i="1">&lt;/c1&gt;</ept>へ向かってのシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence leaving off the specified number of elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された数の要素を取り除いたあるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence of key-value pairs to use for the new dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キー値ペアからなるシーケンス、新しい辞書に使うためのもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence of key-value pairs.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>いくらかのキー値ペアからなるシーケンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence of pairs built out of two underlying sequences.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの根底にあるシーケンスから組み立てられるペアからなるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence of pairs enumerating the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスを列挙している、ペアからなるあるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence of the initial, consecutive elements that satisfy <bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>を満たす冒頭の、隣接する要素からなるあるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence of tuple pairs, where the elements of each pair are corresponding elements of <bpt i="0" x="0">&lt;c0&gt;</bpt>sequence1<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>sequence2<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>対のタプルからなるシーケンス、そこにおいて各対の要素らは、<bpt i="0" x="0">&lt;c0&gt;</bpt>sequence1<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>sequence2<ept i="1">&lt;/c1&gt;</ept>の要素に相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence of values formed by striding over a closed interval.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある完結間隔の全体をまたぐことで形成されるいくつかの値からなるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence of values formed by striding over a half-open interval.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある半開間隔の全体をまたぐことで形成されるいくつかの値からなるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence of values to group into a dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書へとグループにする幾つかの値からなるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence starting after the initial, consecutive elements that satisfy <bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>を満たす冒頭の、隣接する要素の後で始まるあるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence starting after the specified number of elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された数の要素の後で始まるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence starting at the beginning of this sequence with at most <bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Length<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスの先端で始まる多くとも<bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Length<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>要素のあるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence that can represent a contiguous subrange of the collection’s elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの要素の隣接下位範囲を表すことのできるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence that lazily consumes and drops <bpt i="0" x="0">&lt;c0&gt;</bpt>n<ept i="0">&lt;/c0&gt;</ept> elements from an underlying <bpt i="1" x="1">&lt;c1&gt;</bpt>Base<ept i="1">&lt;/c1&gt;</ept> iterator before possibly returning the first available element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>おそらくは最初の利用可能な要素が返る前に<bpt i="0" x="0">&lt;c0&gt;</bpt>n<ept i="0">&lt;/c0&gt;</ept>個の要素をある基礎をなす<bpt i="1" x="1">&lt;c1&gt;</bpt>Base<ept i="1">&lt;/c1&gt;</ept>イテレータから遅延に消費して落とすあるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence that only consumes up to <bpt i="0" x="0">&lt;c0&gt;</bpt>n<ept i="0">&lt;/c0&gt;</ept> elements from an underlying <bpt i="1" x="1">&lt;c1&gt;</bpt>Base<ept i="1">&lt;/c1&gt;</ept> iterator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最大で<bpt i="0" x="0">&lt;c0&gt;</bpt>n<ept i="0">&lt;/c0&gt;</ept>個の要素まで基礎をなす<bpt i="1" x="1">&lt;c1&gt;</bpt>Base<ept i="1">&lt;/c1&gt;</ept>イテレータからただ消費しきるあるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence that presents the elements of a base sequence of sequences concatenated using a given separator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンス、それはいくらかのシーケンスからなるある基盤となるシーケンスの要素らを、与えられた分離子を使って連結して提示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence that represents a contiguous subrange of the collection’s elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの要素の隣接下位範囲を表すシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence that starts with <bpt i="0" x="0">&lt;c0&gt;</bpt>first<ept i="0">&lt;/c0&gt;</ept> and continues with every value returned by passing the previous element to <bpt i="1" x="1">&lt;c1&gt;</bpt>next<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンス、それは<bpt i="0" x="0">&lt;c0&gt;</bpt>first<ept i="0">&lt;/c0&gt;</ept>で始まり、そして前の要素を<bpt i="1" x="1">&lt;c1&gt;</bpt>next<ept i="1">&lt;/c1&gt;</ept>に渡すことによって返される値どれもが続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence that yields each successive value from <bpt i="0" x="0">&lt;c0&gt;</bpt>next<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンス、それは<bpt i="0" x="0">&lt;c0&gt;</bpt>next<ept i="0">&lt;/c0&gt;</ept>から連続した値各々をもたらします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence to compare to this sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンス、このシーケンスと比べることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence to insert between each of this sequence’s elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスの要素それぞれの間に挿入されるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence whose elements are produced via repeated applications of a closure to some mutable state.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャをある何らかの可変の状態へ繰り返し適用することでその要素が生み出されるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequence whose elements can be traversed multiple times, nondestructively, and accessed by an indexed subscript.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンス、それの要素は複数回探査されることが非破壊的に可能です、そしてある添え字で指し示すことによってアクセスされることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A service which can execute jobs.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ジョブを遂行できるあるサービス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A shuffled array of this sequence’s elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスの持つ要素からなる、あるシャッフルされた配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A signaling NaN (“not a number”).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シグナルNaN（非数）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A signaling NaN sets the floating-point exception status when used in many floating-point operations.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シグナルNaNは、多くの浮動小数点演算において使われる時に、浮動小数点例外状態を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A signed integer value type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>符号付き整数値型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A signed number.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>符号付きの数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A signed, fixed-width integer type can represent values from <bpt i="3" x="3">&lt;c3&gt;</bpt>-(2 ** (bit<bpt i="4" x="4">&lt;w4&gt;</bpt>Width - 1))<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> through <bpt i="5" x="5">&lt;c5&gt;</bpt>(2 ** (bit<bpt i="6" x="6">&lt;w6&gt;</bpt>Width - 1)) - 1<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>符号付きの、固定長整数型は、<bpt i="3" x="3">&lt;c3&gt;</bpt>-(2 ** (bit<bpt i="4" x="4">&lt;w4&gt;</bpt>Width - 1))<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>から<bpt i="5" x="5">&lt;c5&gt;</bpt>(2 ** (bit<bpt i="6" x="6">&lt;w6&gt;</bpt>Width - 1)) - 1<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>までの値を表せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A silent NaN (“not a number”) value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>silent NaN（非数）値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A single change to a collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるコレクションに対するある単一の変更。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A single extended grapheme cluster that approximates a user-perceived character.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある単一の拡張書記素クラスタで、１つのユーザ知覚文字におおよそ相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A single value container view into this decoder.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このデコーダへの単一コンテナビュー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A single, concatenated string.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>単一の、連結された文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A single, flattened asynchronous sequence that contains all elements in all the asychronous sequences produced by <bpt i="0" x="0">&lt;c0&gt;</bpt>transform<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある単一の、平坦にされた非同期シーケンス、それは<bpt i="0" x="0">&lt;c0&gt;</bpt>transform<ept i="0">&lt;/c0&gt;</ept>によって生み出される全ての非同期シーケンスの中の全ての要素を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A single-precision, floating-point value type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>単精度、浮動小数点値型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A singleton actor whose executor is equivalent to the main dispatch queue.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシングルトンアクター、それのエグゼキュータはメインディスパッチキューと同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A slice holds a reference to the entire storage of a larger array, not just to the portion it presents, even after the original array’s lifetime ends.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるスライスは、単にそれが提示する一部分に対してではなく、より大きな配列のストレージ全体への参照を保持します、元の配列の寿命が終わった後でさえも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A slice inherits the value or reference semantics of its base collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>スライスは、それの基盤コレクションのもつ値意味論もしくは参照意味論を継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A slice of a collection can contain zero or more of the original collection’s elements and shares the original collection’s semantics.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションのスライスは、ゼロまたはそれ以上の元のコレクションの要素を含み、元のコレクションのもつ意味論を共有できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A slice of an <bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>Contiguous<bpt i="2" x="2">&lt;w2&gt;</bpt>Array<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>, or <bpt i="3" x="3">&lt;c3&gt;</bpt>Array<bpt i="4" x="4">&lt;w4&gt;</bpt>Slice<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある<bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>Contiguous<bpt i="2" x="2">&lt;w2&gt;</bpt>Array<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>、または<bpt i="3" x="3">&lt;c3&gt;</bpt>Array<bpt i="4" x="4">&lt;w4&gt;</bpt>Slice<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>インスタンスの断片。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sorted array of the sequence’s elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンス要素のソート済み配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A specialized error that may be recoverable by presenting several potential recovery options to the user.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>いくつかの可能性のある回復選択肢をユーザに提示することによって回復されるかもしれないある特殊化されたエラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A specialized error that provides a domain, error code, and user-info dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある領域、エラーコード、そしてユーザ情報辞書を提供する特殊化されたエラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A specialized error that provides localized messages describing the error and why it occurred.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>エラーとなぜそれが起こったかを記述しているローカライズされたメッセージを提供する特殊化されたエラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A stable sort preserves the relative order of elements for which <bpt i="0" x="0">&lt;c0&gt;</bpt>are<bpt i="1" x="1">&lt;w1&gt;</bpt>In<bpt i="2" x="2">&lt;w2&gt;</bpt>Increasing<bpt i="3" x="3">&lt;w3&gt;</bpt>Order<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> does not establish an order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>安定ソートは、それに対して<bpt i="0" x="0">&lt;c0&gt;</bpt>are<bpt i="1" x="1">&lt;w1&gt;</bpt>In<bpt i="2" x="2">&lt;w2&gt;</bpt>Increasing<bpt i="3" x="3">&lt;w3&gt;</bpt>Order<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が順序を確立しない要素らの相対順序を保存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A stable sort preserves the relative order of elements that compare equal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>安定ソートは、等しいと比較される要素それらの相対順序を保存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A strategy that handles exhaustion of a buffer’s capacity.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある戦略、それはあるバッファのもつ容量の枯渇を取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A string identifying the declaration that is the notional source for the continuation, used to identify the continuation in runtime diagnostics related to misuse of this continuation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>継続に対する概念的ソースであるところの宣言を識別しているある文字列、この継続の誤用に関する実行時診断において継続を識別するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A string representation of the Boolean value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ブール値の文字列表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A string that represents the contents of the dictionary, suitable for debugging.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書の内容を表す文字列、デバッグに適するもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A string that represents the contents of the dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書の内容を表す文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A string to insert between each of the elements in this sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスの要素のそれぞれの間に挿入されることになる文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A string to print between each item.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>各項目の間に出力する文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A string to print if <bpt i="0" x="0">&lt;c0&gt;</bpt>condition<ept i="0">&lt;/c0&gt;</ept> is evaluated to <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept> in a playground or <bpt i="2" x="2">&lt;c2&gt;</bpt>-Onone<ept i="2">&lt;/c2&gt;</ept> build.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>プレイグラウンドまたは<bpt i="2" x="2">&lt;c2&gt;</bpt>-Onone<ept i="2">&lt;/c2&gt;</ept>ビルドにおいて<bpt i="0" x="0">&lt;c0&gt;</bpt>condition<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>に評価されるならば出力する文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A string to print if <bpt i="0" x="0">&lt;c0&gt;</bpt>condition<ept i="0">&lt;/c0&gt;</ept> is evaluated to <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>condition<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>に評価されるならば出力する文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A string to print in a playground or <bpt i="0" x="0">&lt;c0&gt;</bpt>-Onone<ept i="0">&lt;/c0&gt;</ept> build.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>プレイグラウンドまたは<bpt i="0" x="0">&lt;c0&gt;</bpt>-Onone<ept i="0">&lt;/c0&gt;</ept>ビルドにおいて出力される文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A subscript that provides at least read-only access to your type’s elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>少なくとも読み出し専用のアクセスをあなたの型のもつ要素に提供する添え字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A subsequence starting after the specified number of elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された数の要素の後から始まる下位シーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A subsequence starting at the <bpt i="0" x="0">&lt;c0&gt;</bpt>start<ept i="0">&lt;/c0&gt;</ept> position.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>start<ept i="0">&lt;/c0&gt;</ept>位置から始まる下位シーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A subsequence starting at the beginning of this collection with at most <bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Length<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このコレクションの先端で始まる多くとも<bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Length<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>要素の下位シーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A subsequence terminating at the end of the collection with at most <bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Length<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの末端で終わっていて多くとも<bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Length<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の要素を持つ下位シーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A subsequence that leaves off <bpt i="0" x="0">&lt;c0&gt;</bpt>k<ept i="0">&lt;/c0&gt;</ept> elements from the end.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>k<ept i="0">&lt;/c0&gt;</ept>個の要素を終わりから取り除いた下位シーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A subsequence that leaves off the specified number of elements at the end.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された数の要素が末尾から無くなっているシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A subsequence up to, and including, the <bpt i="0" x="0">&lt;c0&gt;</bpt>end<ept i="0">&lt;/c0&gt;</ept> position.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>end<ept i="0">&lt;/c0&gt;</ept>位置に至るまでの、そしてそれを含む、下位シーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A subsequence up to, but not including, the <bpt i="0" x="0">&lt;c0&gt;</bpt>end<ept i="0">&lt;/c0&gt;</ept> position.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>end<ept i="0">&lt;/c0&gt;</ept>位置に至るまでの、しかしそれを含まないシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A textual description of the vector.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ベクターのテキスト記述。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A textual representation of the Boolean value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ブール値のテキスト表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A textual representation of the array and its elements, suitable for debugging.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列とそれの要素のテキスト表現、デバッグに適するもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A textual representation of the array and its elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列とそれの要素のテキスト表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A textual representation of the character, suitable for debugging.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その文字のテキスト表現、デバッグに適するもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A textual representation of the collection, suitable for debugging.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションのテキスト表現、デバッグに適するもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A textual representation of the pointer, suitable for debugging.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのポインタのテキスト表現、デバッグに適するもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A textual representation of the range, suitable for debugging.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲のテキスト表現、デバッグに適するもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A textual representation of the range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲のテキスト表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A textual representation of the value, suitable for debugging.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その値のテキスト表現、デバッグに適するもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A textual representation of the value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その値のテキスト表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A textual representation of this instance, suitable for debugging.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのインスタンスのテキスト表現、デバッグに適するもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A textual representation of this instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このインスタンスのテキスト表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A textual representation of this key, suitable for debugging.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このキーのテキスト表現、デバッグに適するもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A textual representation of this key.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このキーのテキスト表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A textual representation of this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値のテキスト表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A third value to compare.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>比較する３番目の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A trivial use case producing values from a detached task would work as such:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値それらをある分離されたタスクから生み出す平凡な使用実例は、このように働くでしょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A tuple containing the high and low parts of a double-width integer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２倍幅整数の高および低部分を含んでいるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A tuple containing the high and low parts of the result of multiplying this value and <bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値と<bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>を乗算する結果の高および低部分を含んでいるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A tuple containing the quotient and remainder obtained by dividing <bpt i="0" x="0">&lt;c0&gt;</bpt>dividend<ept i="0">&lt;/c0&gt;</ept> by this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>dividend<ept i="0">&lt;/c0&gt;</ept>をこの値で除算することによって入手される商と余りを含んでいるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A tuple containing the quotient and remainder of <bpt i="0" x="0">&lt;c0&gt;</bpt>dividend<ept i="0">&lt;/c0&gt;</ept> divided by this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>dividend<ept i="0">&lt;/c0&gt;</ept>をこの値で除算した商と余りを含んでいるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A tuple containing the quotient and remainder of this value divided by <bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept>によって除算されたこの値の商と余りを含んでいるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A tuple containing the result of the addition along with a Boolean value indicating whether overflow occurred.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>加算の結果とそれだけでなくオーバーフローがその演算において起こったかどうかを示すブール値を含んでいるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A tuple containing the result of the division along with a Boolean value indicating whether overflow occurred.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>除算の結果とそれだけでなくオーバーフローがその演算において起こったかどうかを示すブール値を含んでいるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A tuple containing the result of the multiplication along with a Boolean value indicating whether overflow occurred.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>乗算の結果とそれだけでなくオーバーフローが起こったかどうかを示すブール値を含んでいるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A tuple containing the result of the operation along with a Boolean value indicating whether overflow occurred.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>演算の結果とそれだけでなくオーバーフローが起こったかどうかを示すブール値を含んでいるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A tuple containing the result of the subtraction along with a Boolean value indicating whether overflow occurred.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>減算の結果とそれだけでなくオーバーフローが起こったかどうかを示すブール値を含んでいるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A tuple of <bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept> elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept>要素からなるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A tuple of <bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept> elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept>要素のタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A tuple of the lower and upper bounds of the range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この範囲の下方および上方境界からなるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A two-element tuple with the key and value corresponding to <bpt i="0" x="0">&lt;c0&gt;</bpt>position<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>position<ept i="0">&lt;/c0&gt;</ept>に該当するキーと値を持つ２要素タプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type for propagating an unmanaged object reference.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある管理されないオブジェクト参照を伝達するための型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type is eligible for automatic conformance to <bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept> when it's a structure or an enumeration that meets these criteria:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある型が<bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept>および<bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>への自動式準拠に適格であるのは、それが構造体または列挙であり、これらの基準に合う場合です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type representing an error value that can be thrown.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>スローされることが可能なあるエラー値を表している型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type representing continuous, one-dimensional values that can be offset and measured.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オフセットできて計測できる、連続的な、一次元の値を表している型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type representing the sequence’s elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスの持つ要素を表している型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type representing the stable identity of the entity associated with an instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるインスタンスと結び付けられた登録項目の安定した同一性を表しているある型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that asynchronously supplies the values of a sequence one at a time.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある型、それはあるシーケンスの値それらを非同期に一度に１つ提供するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can be compared for value equality.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値の同等性について比較されることができる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can be compared using the relational operators <bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>&lt;=<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>&gt;=<ept i="2">&lt;/c2&gt;</ept>, and <bpt i="3" x="3">&lt;c3&gt;</bpt>&gt;<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>関係演算子<bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>&lt;=<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>&gt;=<ept i="2">&lt;/c2&gt;</ept>、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>&gt;<ept i="3">&lt;/c3&gt;</ept>を使って比較されるある型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can be converted to and from an associated raw value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある結び付けられた生の値へおよびそれから変換できる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can be hashed into a <bpt i="0" x="0">&lt;c0&gt;</bpt>Hasher<ept i="0">&lt;/c0&gt;</ept> to produce an integer hash value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Hasher<ept i="0">&lt;/c0&gt;</ept>へとハッシュ化されることで整数ハッシュ値を生成することが可能な型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can be initialized by string interpolation with a string literal that includes expressions.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>いくらかの式を含むある文字列リテラルを使う文字列補間によって初期化できる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can be initialized using a dictionary literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある辞書リテラルを使って初期化できる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can be initialized using an array literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列リテラルを使って初期化できる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can be initialized using the nil literal, <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>nilリテラル、<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>を使って初期化できる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can be initialized with a floating-point literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある浮動小数点リテラルを使って初期化できる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can be initialized with a string literal containing a single Unicode scalar value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>単一のユニコードスカラー値を含んでいるある文字列リテラルで初期化できる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can be initialized with a string literal containing a single extended grapheme cluster.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ただ１つの拡張書記素クラスタを含んでいるある文字列リテラルを使って初期化できる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can be initialized with a string literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある文字列リテラルを使って初期化できる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can be initialized with an integer literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>整数リテラルで初期化できるある型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can be initialized with the Boolean literals <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ブールリテラルの<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>を使って初期化できる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can be represented as a string in a lossless, unambiguous way.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるロスレスの、曖昧さのない方法で、文字列として表現できる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can be used as a key for encoding and decoding.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>エンコーディングとデコーディングのためのキーとして使われる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can convert itself into and out of an external representation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それ自身を外部表現へとそしてそれをもとに変換できる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can decode itself from an external representation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それ自身が外部表現からデコードできる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can decode values from a native format into in-memory representations.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値をネイティブ形式からインメモリ表現へとデコードできる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can encode itself to an external representation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それ自身を外部表現へとエンコードできる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can encode values into a native format for external representation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値を外部表現のためにネイティブ形式へとエンコードできる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can represent a collection of all values of this type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型の全ての値からなるコレクションを表すことができる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can represent any written exponent.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>何らかの書かれた指数を表すことができる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can represent both positive and negative values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>正と負の値の両方を表せる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can represent the absolute value of any possible value of the conforming type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>準拠する型の何らかの可能な値の絶対値を表すことのできる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that can represent the absolute value of any possible value of this type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型の何らかの可能な値の絶対値を表すことのできる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Floating<bpt i="1" x="1">&lt;w1&gt;</bpt>Point<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol provides the value for <bpt i="2" x="2">&lt;c2&gt;</bpt>pi<ept i="2">&lt;/c2&gt;</ept> at its best possible precision.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Floating<bpt i="1" x="1">&lt;w1&gt;</bpt>Point<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する型は、<bpt i="2" x="2">&lt;c2&gt;</bpt>pi<ept i="2">&lt;/c2&gt;</ept>に対する値をそれの最もよい可能な精度で提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Global<bpt i="1" x="1">&lt;w1&gt;</bpt>Actor<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol and is marked with the the <bpt i="2" x="2">&lt;c2&gt;</bpt>@global<bpt i="3" x="3">&lt;w3&gt;</bpt>Actor<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> attribute can be used as a custom attribute.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Global<bpt i="1" x="1">&lt;w1&gt;</bpt>Actor<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠して、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>@global<bpt i="3" x="3">&lt;w3&gt;</bpt>Actor<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>属性で印される型は、あるあつらえの属性として使われることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that explicitly supplies its own mirror, but whose descendant classes are not represented in the mirror unless they also override <bpt i="0" x="0">&lt;c0&gt;</bpt>custom<bpt i="1" x="1">&lt;w1&gt;</bpt>Mirror<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>明示的にそれ独自のMirrorを提供するある型、しかしそれの子孫クラスはそれらがまた<bpt i="0" x="0">&lt;c0&gt;</bpt>custom<bpt i="1" x="1">&lt;w1&gt;</bpt>Mirror<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をオーバーライドしない限りはMirrorで表現されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that explicitly supplies its own mirror.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>明示的にそれ自身のMirrorを提供する型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that iterates over a collection using its indices.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるコレクション全体に渡ってそれのインデックスを使って繰り返し処理する型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that provides a collection of all of its values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それの値の全てからなるコレクションを提供する型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that provides asynchronous, sequential, iterated access to its elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある型、それはそれの要素それらに対して非同期の、順次的な、反復したアクセスを提供するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that provides sequential, iterated access to its elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>順次的な、繰り返されるアクセスをそれの要素に提供するある型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that provides the collection’s iteration interface and encapsulates its iteration state.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのコレクションの持つ反復インターフェイスを提供してそれの反復状態をカプセル化するある型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that provides the sequence’s iteration interface and encapsulates its iteration state.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのシーケンスの持つ反復インターフェイスを提供してそれの反復状態をカプセル化するある型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that represents a Boolean literal, such as <bpt i="0" x="0">&lt;c0&gt;</bpt>Bool<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ブールリテラルを表すある型、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>Bool<ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that represents a Unicode scalar literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ユニコードスカラーリテラルを表すある型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that represents a floating-point literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>浮動小数点リテラルを表すある型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that represents a globally-unique actor that can be used to isolate various declarations anywhere in the program.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある型、それはあるグローバルに特有なアクターを表します、それはさまざまな宣言をどこでもプログラムの中で分離するために使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that represents a position in the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの中のある位置を表す型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that represents a string literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある文字列リテラルを表す型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that represents a valid position in the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>有効な位置をそのコレクションにおいて表している型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that represents an extended grapheme cluster literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>拡張書記素クラスタリテラルを表すある型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that represents an integer literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある整数リテラルを表す型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that represents the distance between two values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの値の間の隔たりを表す型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that represents the encoded exponent of a value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値のエンコードされた指数を表す型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that represents the encoded significand of a value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値のエンコードされた仮数を表す型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that represents the indices that are valid for subscripting the collection, in ascending order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>昇順での、コレクションの添え字として有効なインデックスを表す型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that represents the words of a binary integer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるバイナリ整数の単語を表す型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that represents the words of this integer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この整数のワードを表す型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type that supplies a custom description for playground logging.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>プレイグラウンドログのためにあつらえの記述を提供する型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type to compare.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>比較する型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type whose instances can be encoded, and appropriately passed, as elements of a C <bpt i="0" x="0">&lt;c0&gt;</bpt>va<bpt i="1" x="1">&lt;w1&gt;</bpt>_list<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それのインスタンスが、符号化されること、そして適切に渡されることが、C <bpt i="0" x="0">&lt;c0&gt;</bpt>va<bpt i="1" x="1">&lt;w1&gt;</bpt>_list<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の要素として可能である型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type with a customized textual representation suitable for debugging purposes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>デバッグ目的に都合がよいようにカスタマイズされた原文の表現を持つ型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type with a customized textual representation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>カスタマイズされた原文の表現を持つ型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type with values that support addition and subtraction.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>加算と減算をサポートする値を持つ型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type with values that support multiplication.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>乗算をサポートする値をもつ型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type-erased hashable value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型消去ハッシュ可能値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type-erased iterator of <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>の型消去イテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type-erased key path, from any root type to any resulting value type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型消去キーパス、何らかの根本の型から何らかの結果値の型への。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type-erased sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型消去シーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type-erased wrapper over any collection with indices that support bidirectional traversal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２方向に辿っていくことをサポートするインデックスを持つあらゆるコレクションを覆う型消去ラッパー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type-erased wrapper over any collection with indices that support forward traversal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>前へ辿っていくことをサポートするインデックスを持つあらゆるコレクションを覆う型消去ラッパー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type-erased wrapper over any collection with indices that support random access traversal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>無作為アクセスで辿っていくことをサポートするインデックスを持つあらゆるコレクションを覆う型消去ラッパー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A unique identifier for a class instance or metatype.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクラスインスタンスまたはメタタイプのための固有な識別子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A unit of scheduleable work.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>予定可能な仕事の単位。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A user-defined key for providing context during encoding and decoding.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>エンコーディングおよびデコーディングの間にコンテキストを提供するためのユーザ定義のキー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A valid index of the array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この配列の有効なインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A valid index of the collection to use as a limit.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>限度として使うためのそのコレクションの有効なインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A valid index of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのコレクションの有効なインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value equal to <bpt i="0" x="0">&lt;c0&gt;</bpt>+infinity<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>+infinity<ept i="0">&lt;/c0&gt;</ept>に等しい値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value equal to <bpt i="0" x="0">&lt;c0&gt;</bpt>-infinity<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>-infinity<ept i="0">&lt;/c0&gt;</ept>に等しい値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value equal to zero with a negative sign.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>負の符号を持つゼロに等しい値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value equal to zero with a positive sign.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>正の符号を持つゼロに等しい値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value from which to use the magnitude.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そこからの値が規模に使われることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value from which to use the sign.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それからの値が符号に使われることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value less than or equal to the number of elements in the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このコレクションの中の要素の数より少ないか等しい値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value less than or equal to the number of elements in the sequence, calculated nondestructively.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスの要素数より少ないか等しい値、非破壊的に計算されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value of <bpt i="0" x="0">&lt;e0&gt;</bpt>NaN<ept i="0">&lt;/e0&gt;</ept> contains the string <bpt i="1" x="1">&lt;c1&gt;</bpt>"nan"<ept i="1">&lt;/c1&gt;</ept>, case insensitive.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>NaN<ept i="0">&lt;/e0&gt;</ept>の値は、文字列<bpt i="1" x="1">&lt;c1&gt;</bpt>"nan"<ept i="1">&lt;/c1&gt;</ept>を含みます、大文字小文字に影響されずに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value of <bpt i="0" x="0">&lt;e0&gt;</bpt>infinity<ept i="0">&lt;/e0&gt;</ept> contains one of the strings <bpt i="1" x="1">&lt;c1&gt;</bpt>"inf"<ept i="1">&lt;/c1&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt>"infinity"<ept i="2">&lt;/c2&gt;</ept>, case insensitive.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>無限大<ept i="0">&lt;/e0&gt;</ept>の値は、文字列<bpt i="1" x="1">&lt;c1&gt;</bpt>"inf"<ept i="1">&lt;/c1&gt;</ept>または<bpt i="2" x="2">&lt;c2&gt;</bpt>"infinity"<ept i="2">&lt;/c2&gt;</ept>のうちの１つを含みます、大文字小文字に影響されずに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value that is NaN (“not a number”) cannot be represented exactly if its payload cannot be encoded exactly.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>NaN（非数）である値は、それのペイロードが正確にエンコードされないならば、正確に表現できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value that is offset from this value by <bpt i="0" x="0">&lt;c0&gt;</bpt>n<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値から<bpt i="0" x="0">&lt;c0&gt;</bpt>n<ept i="0">&lt;/c0&gt;</ept>をオフセットされる値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value to add to the hasher.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ハーシャーに加える値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value to compare.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>比較する値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value to convert to this type of integer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型の整数へと変換される値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value to either return or throw from the continuation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その継続から返すまたはスローするどちらかの値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value to match against <bpt i="0" x="0">&lt;c0&gt;</bpt>pattern<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>pattern<ept i="0">&lt;/c0&gt;</ept>と照合することになるある値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value to use as a default.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時のものとして使うための値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value to use as the big-endian representation of the new integer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい整数のビッグエンディアン表現として使う値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value to use as the little-endian representation of the new integer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい整数のリトルエンディアン表現として使う値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value to use as the source of the new instance’s binary representation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいインスタンスの持つバイナリ表現のソースとして使うための値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value type whose instances are either <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値型、そのインスタンスは<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>か<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A value’s <bpt i="0" x="0">&lt;c0&gt;</bpt>floating<bpt i="1" x="1">&lt;w1&gt;</bpt>Point<bpt i="2" x="2">&lt;w2&gt;</bpt>Class<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property describes its “class” as described by the <bpt i="3" x="3">&lt;a3&gt;</bpt>IEEE 754 specification<ept i="3">&lt;/a3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値の<bpt i="0" x="0">&lt;c0&gt;</bpt>floating<bpt i="1" x="1">&lt;w1&gt;</bpt>Point<bpt i="2" x="2">&lt;w2&gt;</bpt>Class<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティは、それの“class”を<bpt i="3" x="3">&lt;a3&gt;</bpt>IEEE 754仕様<ept i="3">&lt;/a3&gt;</ept>で記述される通りに記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A variadic list of elements of the new array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい配列の要素からなる可変長引数リスト。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A view of a character’s contents as a collection of UTF-16 code units.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある文字のもつ内容のひとつの見方、いくらかのUTF-16コード単位のコレクションとして。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A view of a character’s contents as a collection of UTF-8 code units.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある文字のもつ内容のひとつの見方、いくらかのUTF-8コード単位のコレクションとして。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A view of a dictionary’s keys.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書のもつキーのあるビュー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A view of a dictionary’s values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書のもつ値のあるビュー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A wrapper around a C <bpt i="0" x="0">&lt;c0&gt;</bpt>va<bpt i="1" x="1">&lt;w1&gt;</bpt>_list<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> pointer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>C <bpt i="0" x="0">&lt;c0&gt;</bpt>va<bpt i="1" x="1">&lt;w1&gt;</bpt>_list<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ポインタの周りのラッパー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A wrapper around an opaque C pointer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>不透明Cポインターの周りのラッパー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A wrapper over an underlying index that hides the specific underlying type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>根底にあるインデックスを覆うラッパー、根底にある特定の型を隠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>About Imported Cocoa Error Parameters</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インポートされるCocoaエラーパラメータについて</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Access Swift types and declarations from within your Objective-C codebase.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swift型と宣言にあなたのObjective-Cコードベース内からアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Access classes and other declarations from your Objective-C code in Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>SwiftにおいてあなたのObjective-Cコード由来のクラスおよび他の宣言にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Access must only occur through the pointer argument to <bpt i="4" x="4">&lt;c4&gt;</bpt>body<ept i="4">&lt;/c4&gt;</ept> until <bpt i="5" x="5">&lt;c5&gt;</bpt>body<ept i="5">&lt;/c5&gt;</ept> returns.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>アクセスは、<bpt i="4" x="4">&lt;c4&gt;</bpt>body<ept i="4">&lt;/c4&gt;</ept>に対するポインタ引数を通して、<bpt i="5" x="5">&lt;c5&gt;</bpt>body<ept i="5">&lt;/c5&gt;</ept>が返るまでに、発生するだけでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Access the <bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept>th element of the raw array pointed to by <bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>によって指し示される生の配列の<bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept>番目の要素にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Access to the raw argc value from C.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Cからの生のargc値にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Access to the raw argv value from C. Accessing the argument vector through this pointer is unsafe.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>生のargv値にCからアクセスします。引数ベクトルにこのポインタを通してアクセスすることは安全ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Access to the swift arguments, also use lazy initialization of static properties to safely initialize the swift arguments.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>swift引数にアクセスします、また静的プロパティの遅延初期化を使って安全にswift引数を初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Access your Swift code from within your Objective-C codebase, and your Objective-C code from Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのSwiftコードにあなたのObjective-Cコードベース内からアクセスします、そしてあなたのObjective-CコードにSwiftからアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accesses a contiguous subrange of the array’s elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列のもつ要素らの中のある連続した下位範囲にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accesses a contiguous subrange of the collection’s elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションのもついくらかの要素からなるある連続した下位範囲にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accesses the contiguous subrange of the collection’s elements specified by a range expression.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲式によって指定される、コレクションの要素からなる連続した下位範囲にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accesses the element at <bpt i="0" x="0">&lt;c0&gt;</bpt>position<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>position<ept i="0">&lt;/c0&gt;</ept>での要素にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accesses the element at specified position.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された位置で要素にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accesses the element at the given position.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた位置での要素にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accesses the element at the specified index.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定されたインデックスでの要素にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accesses the element at the specified position.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された位置で要素にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accesses the element indicated by <bpt i="0" x="0">&lt;c0&gt;</bpt>position<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>position<ept i="0">&lt;/c0&gt;</ept>によって指し示される要素にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accesses the key-value pair at the specified position.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された位置でキー値ペアにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accesses the value associated with the given key for reading and writing.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたキーに結び付けられる値に読出しと書き込みのためにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accesses the value with the given key, falling back to the given default value if the key isn’t found.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値にこの与えられたキーでアクセスします、キーが見つけられないならばその与えられた省略時の値まで後退します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accessing <bpt i="0" x="0">&lt;c0&gt;</bpt>pointee<ept i="0">&lt;/c0&gt;</ept> as a type that is unrelated to the underlying memory’s bound type is undefined.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>基礎をなすメモリの境界型と関係のない型として<bpt i="0" x="0">&lt;c0&gt;</bpt>pointee<ept i="0">&lt;/c0&gt;</ept>にアクセスすることは、未定義です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accessing Arguments</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>引数にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accessing Array Values</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列の値にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accessing Cases</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ケース節にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accessing Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要素にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accessing Individual Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>個々の要素にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accessing Keys and Values</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キーと値にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accessing Numeric Constants</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>数に関する定数にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accessing Objective-C Methods and Properties</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-Cのメソッドやプロパティへのアクセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accessing Raw Argument Data</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>生の引数データにアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accessing Slices of a Collection</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるコレクションのスライスにアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accessing Underlying Storage</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>基礎をなすストレージにアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accessing a Collection's Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションのもつ要素にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accessing a Pointer's Memory</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ポインタの持つメモリにアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Accessing a type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>description<ept i="0">&lt;/c0&gt;</ept> property directly or using <bpt i="1" x="1">&lt;c1&gt;</bpt>Custom<bpt i="2" x="2">&lt;w2&gt;</bpt>String<bpt i="3" x="3">&lt;w3&gt;</bpt>Convertible<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> as a generic constraint is discouraged.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>description<ept i="0">&lt;/c0&gt;</ept>プロパティに直にアクセスすることや<bpt i="1" x="1">&lt;c1&gt;</bpt>Custom<bpt i="2" x="2">&lt;w2&gt;</bpt>String<bpt i="3" x="3">&lt;w3&gt;</bpt>Convertible<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>を総称体制約として使うことは推奨されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Actor types implicitly conform to this protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>アクター型それらは、暗黙的にこのプロトコルに準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adapting Textual Sequences</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>テキストシーケンスに適応する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Add <bpt i="0" x="0">&lt;c0&gt;</bpt>Custom<bpt i="1" x="1">&lt;w1&gt;</bpt>Debug<bpt i="2" x="2">&lt;w2&gt;</bpt>String<bpt i="3" x="3">&lt;w3&gt;</bpt>Convertible<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance to your custom types by defining a <bpt i="4" x="4">&lt;c4&gt;</bpt>debug<bpt i="5" x="5">&lt;w5&gt;</bpt>Description<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Custom<bpt i="1" x="1">&lt;w1&gt;</bpt>Debug<bpt i="2" x="2">&lt;w2&gt;</bpt>String<bpt i="3" x="3">&lt;w3&gt;</bpt>Convertible<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠をあなたのあつらえの型に<bpt i="4" x="4">&lt;c4&gt;</bpt>debug<bpt i="5" x="5">&lt;w5&gt;</bpt>Description<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>プロパティを定義することによって加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Add <bpt i="0" x="0">&lt;c0&gt;</bpt>Custom<bpt i="1" x="1">&lt;w1&gt;</bpt>String<bpt i="2" x="2">&lt;w2&gt;</bpt>Convertible<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance to your custom types by defining a <bpt i="3" x="3">&lt;c3&gt;</bpt>description<ept i="3">&lt;/c3&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Custom<bpt i="1" x="1">&lt;w1&gt;</bpt>String<bpt i="2" x="2">&lt;w2&gt;</bpt>Convertible<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠をあなたのあつらえの型に<bpt i="3" x="3">&lt;c3&gt;</bpt>description<ept i="3">&lt;/c3&gt;</ept>プロパティを定義することによって加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Add <bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept> to the list of adopted protocols when declaring the type, and the compiler automatically fills in the requirements for the two protocols:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept>および<bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>を型を宣言する時に採用するプロトコルのリストに加えてください、するとコンパイラは自動的に２つのプロトコルに対する要件を満たします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Add <bpt i="2" x="2">&lt;c2&gt;</bpt>Comparable<ept i="2">&lt;/c2&gt;</ept> conformance to your own custom types when you want to be able to compare instances using relational operators or use standard library methods that are designed for <bpt i="3" x="3">&lt;c3&gt;</bpt>Comparable<ept i="3">&lt;/c3&gt;</ept> types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが関係演算子を使ってインスタンスの比較ができること、または <bpt i="3" x="3">&lt;c3&gt;</bpt>Comparable<ept i="3">&lt;/c3&gt;</ept>型のために設計される標準ライブラリメソッドを使うことを望む場合は、<bpt i="2" x="2">&lt;c2&gt;</bpt>Comparable<ept i="2">&lt;/c2&gt;</ept>準拠をあなた独自のあつらえの型に加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Add multiple elements at the same time by passing another array or a sequence of any kind to the <bpt i="1" x="1">&lt;c1&gt;</bpt>append(contents<bpt i="2" x="2">&lt;w2&gt;</bpt>Of:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>append(contents<bpt i="2" x="2">&lt;w2&gt;</bpt>Of:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>メソッドに別の配列や何らかの種類のシーケンスを渡すことによって、複数の要素を同時に加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Add new interpolation behavior to existing types by extending <bpt i="0" x="0">&lt;c0&gt;</bpt>Default<bpt i="1" x="1">&lt;w1&gt;</bpt>String<bpt i="2" x="2">&lt;w2&gt;</bpt>Interpolation<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, the type that implements interpolation for types like <bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>Substring<ept i="4">&lt;/c4&gt;</ept>, to add an overload of <bpt i="5" x="5">&lt;c5&gt;</bpt>append<bpt i="6" x="6">&lt;w6&gt;</bpt>Interpolation(_:)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> with their new behavior.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい補間挙動を既存の型それらに追加することを<bpt i="0" x="0">&lt;c0&gt;</bpt>Default<bpt i="1" x="1">&lt;w1&gt;</bpt>String<bpt i="2" x="2">&lt;w2&gt;</bpt>Interpolation<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>および<bpt i="4" x="4">&lt;c4&gt;</bpt>Substring<ept i="4">&lt;/c4&gt;</ept>のような型に補間を実装する型、を拡張してそれらの新しい挙動をもつ<bpt i="5" x="5">&lt;c5&gt;</bpt>append<bpt i="6" x="6">&lt;w6&gt;</bpt>Interpolation(_:)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>のオーバーロードを加えることで行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Add the capability to be initialized with an array literal to your own custom types by declaring an <bpt i="0" x="0">&lt;c0&gt;</bpt>init(array<bpt i="1" x="1">&lt;w1&gt;</bpt>Literal:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initializer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>init(array<bpt i="1" x="1">&lt;w1&gt;</bpt>Literal:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>イニシャライザを宣言することによって、配列リテラルで初期化される能力をあなた独自のあつらえの型に加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adding <bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept> conformance to your custom types means that you can use more convenient APIs when searching for particular instances in a collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept>準拠をあなたのあつらえの型に追加することが意味するのは、あなたがより便利なAPIを特定のインスタンスをあるコレクションの中で探す時に使用できるということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adding Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要素の追加</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adding Keys and Values</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キーと値を追加する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adding Values</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値を加える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adding and Removing Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要素の追加と削除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Additional Considerations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>追加の考慮すべきこと</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Additive<bpt i="0" x="0">&lt;w0&gt;</bpt>Arithmetic Implementations <ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>加法<bpt i="0" x="0">&lt;w0&gt;</bpt>算術の実装<ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adds a new element at the end of the array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい要素を配列の終わりに加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adds the contents of the given buffer to this hasher, mixing it into the hasher state.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたバッファの内容をこのハーシャーに加えます、それをハーシャー状態へと混ぜ入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adds the elements of a sequence or collection to the end of this collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンスまたコレクションに属するいくつかの要素をこのコレクションの終わりに加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adds the elements of a sequence to the end of the array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンスに属する要素を配列の終わりに加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adds the given value to this hasher, mixing its essential parts into the hasher state.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた値をこのハーシャーに加えます、それの本質的部分それらをハーシャー状態に混ぜ合わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adds the product of the two given values to this value in place, computed without intermediate rounding.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの与えられた値の積をこの値にその場で加えます、中間の丸めなしで計算されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adds two values and produces their sum, rounded to a representable value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの値を加算してそれらの合計を生成します、表現可能な値へ丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adds two values and produces their sum.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの値を加算してそれらの合計を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adds two values and stores the result in the left-hand-side variable, rounded to a representable value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの値を加算して、結果を左手側の変数に格納します、表現可能な値へ丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adds two values and stores the result in the left-hand-side variable, wrapping any overflow.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの値を加算して結果を左手側の変数に格納します、あらゆるオーバーフローをラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adds two values and stores the result in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの値を加算して、結果を左手側の変数に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adopt a Delegate Protocol</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>委任先プロトコルを採用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adopt and interoperate with Cocoa design patterns in your Swift apps.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>CocoaデザインパターンをあなたのSwiftアプリにおいて採用および相互運用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adopting Common Protocols</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>一般的なプロトコルを採用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Advances to the next element and returns it, or <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> if no next element exists.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の要素へ進んでそれを返します、または次の要素が存在しないならば<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>After <bpt i="0" x="0">&lt;c0&gt;</bpt>resume<ept i="0">&lt;/c0&gt;</ept> enqueues the task, control immediately returns to the caller.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>resume<ept i="0">&lt;/c0&gt;</ept>がタスクを待ち行列に入れた後、制御はすぐに呼び出し側へと返ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>After adding <bpt i="0" x="0">&lt;c0&gt;</bpt>Custom<bpt i="1" x="1">&lt;w1&gt;</bpt>Debug<bpt i="2" x="2">&lt;w2&gt;</bpt>String<bpt i="3" x="3">&lt;w3&gt;</bpt>Convertible<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance by implementing the <bpt i="4" x="4">&lt;c4&gt;</bpt>debug<bpt i="5" x="5">&lt;w5&gt;</bpt>Description<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> property, <bpt i="6" x="6">&lt;c6&gt;</bpt>Point<ept i="6">&lt;/c6&gt;</ept> provides its own custom debugging representation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Custom<bpt i="1" x="1">&lt;w1&gt;</bpt>Debug<bpt i="2" x="2">&lt;w2&gt;</bpt>String<bpt i="3" x="3">&lt;w3&gt;</bpt>Convertible<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠を<bpt i="4" x="4">&lt;c4&gt;</bpt>debug<bpt i="5" x="5">&lt;w5&gt;</bpt>Description<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>プロパティを実装することによって追加後は、<bpt i="6" x="6">&lt;c6&gt;</bpt>Point<ept i="6">&lt;/c6&gt;</ept>はそれ独自のあつらえのデバッグ表現を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>After assigning the new value (<bpt i="0" x="0">&lt;c0&gt;</bpt>"Butler"<ept i="0">&lt;/c0&gt;</ept>) at a specific position, that value is immediately available at that same position.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい値（<bpt i="0" x="0">&lt;c0&gt;</bpt>"Butler"<ept i="0">&lt;/c0&gt;</ept>）を指定された位置で割り当てた後、その値はすぐにその同じ位置で利用可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>After implementing the <bpt i="0" x="0">&lt;c0&gt;</bpt>description<ept i="0">&lt;/c0&gt;</ept> property and declaring <bpt i="1" x="1">&lt;c1&gt;</bpt>Custom<bpt i="2" x="2">&lt;w2&gt;</bpt>String<bpt i="3" x="3">&lt;w3&gt;</bpt>Convertible<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> conformance, the <bpt i="4" x="4">&lt;c4&gt;</bpt>Point<ept i="4">&lt;/c4&gt;</ept> type provides its own custom representation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>description<ept i="0">&lt;/c0&gt;</ept>プロパティの実装と<bpt i="1" x="1">&lt;c1&gt;</bpt>Custom<bpt i="2" x="2">&lt;w2&gt;</bpt>String<bpt i="3" x="3">&lt;w3&gt;</bpt>Convertible<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>準拠の宣言の後は、<bpt i="4" x="4">&lt;c4&gt;</bpt>Point<ept i="4">&lt;/c4&gt;</ept>型はそれ自身のあつらえの表現を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>After partitioning a collection, there is a pivot index <bpt i="0" x="0">&lt;c0&gt;</bpt>p<ept i="0">&lt;/c0&gt;</ept> where no element before <bpt i="1" x="1">&lt;c1&gt;</bpt>p<ept i="1">&lt;/c1&gt;</ept> satisfies the <bpt i="2" x="2">&lt;c2&gt;</bpt>belongs<bpt i="3" x="3">&lt;w3&gt;</bpt>In<bpt i="4" x="4">&lt;w4&gt;</bpt>Second<bpt i="5" x="5">&lt;w5&gt;</bpt>Partition<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> predicate and every element at or after <bpt i="6" x="6">&lt;c6&gt;</bpt>p<ept i="6">&lt;/c6&gt;</ept> satisfies <bpt i="7" x="7">&lt;c7&gt;</bpt>belongs<bpt i="8" x="8">&lt;w8&gt;</bpt>In<bpt i="9" x="9">&lt;w9&gt;</bpt>Second<bpt i="10" x="10">&lt;w10&gt;</bpt>Partition<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションを仕切った後、あるピボットインデックス<bpt i="0" x="0">&lt;c0&gt;</bpt>p<ept i="0">&lt;/c0&gt;</ept>があります、そこで<bpt i="1" x="1">&lt;c1&gt;</bpt>p<ept i="1">&lt;/c1&gt;</ept>の前の要素は１つも<bpt i="2" x="2">&lt;c2&gt;</bpt>belongs<bpt i="3" x="3">&lt;w3&gt;</bpt>In<bpt i="4" x="4">&lt;w4&gt;</bpt>Second<bpt i="5" x="5">&lt;w5&gt;</bpt>Partition<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>述部を満たさず、そして<bpt i="6" x="6">&lt;c6&gt;</bpt>p<ept i="6">&lt;/c6&gt;</ept>でのまたは後のあらゆる要素は<bpt i="7" x="7">&lt;c7&gt;</bpt>belongs<bpt i="8" x="8">&lt;w8&gt;</bpt>In<bpt i="9" x="9">&lt;w9&gt;</bpt>Second<bpt i="10" x="10">&lt;w10&gt;</bpt>Partition<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>を満たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>After passing the unsafe continuation to this initializer, don’t use it outside of this object.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その非安全継続をこのイニシャライザに渡した後、それをこのオブジェクトの外側で使わないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>After reaching the maximum number of elements, subsequent calls to <bpt i="1" x="1">&lt;c1&gt;</bpt>next()<ept i="1">&lt;/c1&gt;</ept> return <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要素の最大数に到達した後、<bpt i="1" x="1">&lt;c1&gt;</bpt>next()<ept i="1">&lt;/c1&gt;</ept>へのその後の呼び出しは<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>After reaching the number of elements to drop, this iterator passes along the result of calling <bpt i="3" x="3">&lt;c3&gt;</bpt>next()<ept i="3">&lt;/c3&gt;</ept> on the base iterator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>抜かす要素の数に到達した後、このイテレータは<bpt i="3" x="3">&lt;c3&gt;</bpt>next()<ept i="3">&lt;/c3&gt;</ept>を基底イテレータ上で呼び出す結果をずっと渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>After returning <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> (or throwing an error) from <bpt i="2" x="2">&lt;c2&gt;</bpt>next()<ept i="2">&lt;/c2&gt;</ept>, the iterator enters a terminal state, and all future calls to <bpt i="3" x="3">&lt;c3&gt;</bpt>next()<ept i="3">&lt;/c3&gt;</ept> must return <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>next()<ept i="2">&lt;/c2&gt;</ept>から<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>を返す（またはエラーをスローする）後、イテレータはある終端状態に入ります、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>next()<ept i="3">&lt;/c3&gt;</ept>への全ての未来の呼び出しは、<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>を返さなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>After that, the iterator returns values received from its base iterator as-is, and never executes the predicate closure again.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その後、イテレータはそれの基底イテレータから受け取った値をそのまま返します、そして決して述部クロージャを再び遂行しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>After the <bpt i="0" x="0">&lt;c0&gt;</bpt>Cake<ept i="0">&lt;/c0&gt;</ept> structure has been imported, you can use the default initializer to create an instance and use it as follows:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Cake<ept i="0">&lt;/c0&gt;</ept>構造体がインポートされた後、あなたは省略時のイニシャライザを使うことでインスタンスを作成してそれを以下のように使用できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>After the predicate returns <bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence as-is.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>述部が<bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>を返した後、シーケンスはそれを決して再び遂行しません、そしてそれからシーケンス上では、要素それらをそれの基礎をなすシーケンスからそのままでずっと渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>After the predicate returns <bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>, the sequence never executes it again, and from then on the sequence passes through elements from its underlying sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>述部が<bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>を返した後、シーケンスはそれを決して再び遂行しません、そしてその時からシーケンスは要素それらをそれの基礎をなすシーケンスからずっと渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>After the predicate returns <bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>, for a value received from the base iterator, this method returns that value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>述部が<bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>を返した後、基底イテレータから受け取った値に対して、このメソッドはその値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>After this method returns, the task group is guaranteed to be empty.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドが復帰した後、タスクグループは空であることを保証されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>After using <bpt i="0" x="0">&lt;c0&gt;</bpt>first<bpt i="1" x="1">&lt;w1&gt;</bpt>Index(of:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to find the position of a particular element in a collection, you can use it to access the element by subscripting.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>first<bpt i="1" x="1">&lt;w1&gt;</bpt>Index(of:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使って特定の要素の位置をあるコレクションの中で見つけた後、あなたは添え字によって要素にアクセスするのにそれを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>After using <bpt i="0" x="0">&lt;c0&gt;</bpt>last<bpt i="1" x="1">&lt;w1&gt;</bpt>Index(of:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to find the position of the last instance of a particular element in a collection, you can use it to access the element by subscripting.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>last<bpt i="1" x="1">&lt;w1&gt;</bpt>Index(of:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使って特定の要素の最後のインスタンスの位置をあるコレクションの中で見つけた後、あなたは添え字によって要素にアクセスするのにそれを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>After you import an Objective-C framework, a C library, or a header file, you can work with Objective-C classes and protocols, as well as common C constructs, functions, and patterns.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがObjective-Cフレームワーク、Cライブラリ、またはあるヘッダファイルをインポートした後、あなたはObjective-Cのクラスとプロトコル、それだけでなく一般的なC構造体、関数、そしてパターンを扱うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Aliases for Imported C Types</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インポートされたC型に対するエイリアス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>All Objective-C generic type parameters imported by Swift have a type constraint that requires that type to be a class (<bpt i="0" x="0">&lt;c0&gt;</bpt>T: Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Object<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>スウィフトによってインポートされる全てのObjective-C総称体型パラメータは、ある型制約を持ちます、それはあるクラス（<bpt i="0" x="0">&lt;c0&gt;</bpt>T: Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Object<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>）であることをその型に要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>All arity zero tuples are equal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>項数ゼロのタプルはすべて等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>All associations between insertions and removals are symmetric</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>挿入それらと除去それらの間の全ての関係は、対照的である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>All elements satisfying this predicate are ordered after all elements not satisfying it.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この述部を満たす全ての要素は、それを満たさない全ての要素の後に並べられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>All indirectly returned Core Foundation objects are unmanaged as well.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>全ての間接的に返されたコアファウンデーション・オブジェクトは、同様に管理されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>All insertion offsets are unique</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>全ての挿入オフセットは、特有である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>All of the standard library’s integer types, such as <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>UInt32<ept i="3">&lt;/c3&gt;</ept>, conform to <bpt i="4" x="4">&lt;c4&gt;</bpt>Binary<bpt i="5" x="5">&lt;w5&gt;</bpt>Integer<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>標準ライブラリの持つ整数型の全て、例えば<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>UInt32<ept i="3">&lt;/c3&gt;</ept>などは、<bpt i="4" x="4">&lt;c4&gt;</bpt>Binary<bpt i="5" x="5">&lt;w5&gt;</bpt>Integer<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>All other values of the <bpt i="4" x="4">&lt;c4&gt;</bpt>Index<ept i="4">&lt;/c4&gt;</ept> type, such as the <bpt i="5" x="5">&lt;c5&gt;</bpt>start<bpt i="6" x="6">&lt;w6&gt;</bpt>Index<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> property of a different collection, are invalid indices for this collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>Index<ept i="4">&lt;/c4&gt;</ept>型の他の値すべて、例えば異なるコレクションの<bpt i="5" x="5">&lt;c5&gt;</bpt>start<bpt i="6" x="6">&lt;w6&gt;</bpt>Index<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>プロパティなどは、このコレクションに対する無効なインデックスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>All removal offsets are unique</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>全ての除去オフセットは、特有である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>All the elements following the specified position are moved to close the gap.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された位置に続く要素すべては、隙間を埋めるように移動されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>All the elements following the specified position are moved up to close the gap.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された位置に続く要素すべては、隔たりを埋めるように繰り上げられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>All values other than NaN and infinity are considered finite, whether normal or subnormal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>NaNと無限大の他の全ての値は、ノーマルまたはサブノーマルかにかかわらず、有限と見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Allows a nonescaping closure to temporarily be used as if it were allowed to escape.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>非脱出クロージャに、一時的にそれが脱出することを許可されたかのように使われることを許可します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Along with defining the type of values as an associated type called <bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept>, the <bpt i="3" x="3">&lt;c3&gt;</bpt>Async<bpt i="4" x="4">&lt;w4&gt;</bpt>Sequence<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> defines a <bpt i="5" x="5">&lt;c5&gt;</bpt>make<bpt i="6" x="6">&lt;w6&gt;</bpt>Async<bpt i="7" x="7">&lt;w7&gt;</bpt>Iterator()<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値それらの型を<bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept>と呼ばれる関連型として定義することに加えて、<bpt i="3" x="3">&lt;c3&gt;</bpt>Async<bpt i="4" x="4">&lt;w4&gt;</bpt>Sequence<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は<bpt i="5" x="5">&lt;c5&gt;</bpt>make<bpt i="6" x="6">&lt;w6&gt;</bpt>Async<bpt i="7" x="7">&lt;w7&gt;</bpt>Iterator()<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>メソッドを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Also, the dictionary doesn’t provide a key for <bpt i="14" x="14">&lt;c14&gt;</bpt>4<ept i="14">&lt;/c14&gt;</ept>, and the closure throws an error for any key it can’t look up, so receiving this value from <bpt i="15" x="15">&lt;c15&gt;</bpt>Counter<ept i="15">&lt;/c15&gt;</ept> ends the modified sequence with an error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>また、辞書は<bpt i="14" x="14">&lt;c14&gt;</bpt>4<ept i="14">&lt;/c14&gt;</ept>に対するキーを提供しません、そしてクロージャはそれが見つけることが出来ない何らかのキーに対してエラーをスローします、それでこの値を<bpt i="15" x="15">&lt;c15&gt;</bpt>Counter<ept i="15">&lt;/c15&gt;</ept>から受け取ることはこの修正されたシーケンスをエラーで終わらせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Alternatively, a predicate can be satisfied by a range of <bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept> elements or a general condition.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるいは、述部は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept>要素のある範囲またはある一般的条件によって満たされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Alternatively, if you need to test whether <bpt i="0" x="0">&lt;c0&gt;</bpt>obj<bpt i="1" x="1">&lt;w1&gt;</bpt>.get<bpt i="2" x="2">&lt;w2&gt;</bpt>Integer<bpt i="3" x="3">&lt;w3&gt;</bpt>Value()<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> exists, use optional binding before calling the method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるいは、あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>obj<bpt i="1" x="1">&lt;w1&gt;</bpt>.get<bpt i="2" x="2">&lt;w2&gt;</bpt>Integer<bpt i="3" x="3">&lt;w3&gt;</bpt>Value()<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が存在するかテストする必要があるならば、オプショナル束縛をそのメソッドを呼び出す前に使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Alternatively, use this method to sort a collection of elements that do conform to <bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept> when you want the sort to be descending instead of ascending.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そうではなくて、あなたが昇順ではなく降順でソートしたい場合は、このメソッドを使って<bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept>に準拠する要素からなるコレクションをソートしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Alternatively, you can call <bpt i="2" x="2">&lt;c2&gt;</bpt>async<bpt i="3" x="3">&lt;w3&gt;</bpt>Unless<bpt i="4" x="4">&lt;w4&gt;</bpt>Cancelled(priority:<bpt i="5" x="5">&lt;w5&gt;</bpt>operation:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, which doesn’t create the task if the group has already been canceled Choosing between these two functions lets you control how to react to cancellation within a group: some child tasks need to run regardless of cancellation and others are better not even being created knowing they can’t produce useful results.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その代わりに、あなたは<bpt i="2" x="2">&lt;c2&gt;</bpt>async<bpt i="3" x="3">&lt;w3&gt;</bpt>Unless<bpt i="4" x="4">&lt;w4&gt;</bpt>Cancelled(priority:<bpt i="5" x="5">&lt;w5&gt;</bpt>operation:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を呼び出せます、それはグループが既に取り消されてしまっているならばタスクを作成しません。これら２つの関数の間から選ぶことは、あなたにグループ内の取り消しにどのように反応するかを制御させます：いくつかの子タスクは取り消しにかかわらず動作する必要があります、そして他のものは、それらが有用な結果を生み出せないのがわかっていて、作成すらされない方が良いです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Alternatively, you can create a bridging header yourself by choosing File &gt; New &gt; File &gt; [<bpt i="2" x="2">&lt;e2&gt;</bpt>operating system<ept i="2">&lt;/e2&gt;</ept>] &gt; Source &gt; Header File.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるいはまた、あなたはブリッジヘッダを、File &gt; New &gt; File &gt; [<bpt i="2" x="2">&lt;e2&gt;</bpt>オペレーションシステム<ept i="2">&lt;/e2&gt;</ept>] &gt; Source &gt; Header File を選択することであなた自身で作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Although Swift doesn’t support natively declared unions, a C union imported as a Swift structure still behaves like a C union.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftは生得的に宣言された共用体をサポートしないにもかかわらず、Swift構造体としてインポートされたC共用体は依然としてC共用体のように振る舞います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Although a sequence can be consumed as it is traversed, a collection is guaranteed to be <bpt i="0" x="0">&lt;e0&gt;</bpt>multipass<ept i="0">&lt;/e0&gt;</ept>: Any element can be repeatedly accessed by saving its index.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスはそれが辿って行かれるとき消費されることが可能な一方、コレクションは<bpt i="0" x="0">&lt;e0&gt;</bpt>マルチパス<ept i="0">&lt;/e0&gt;</ept>であることを保証されます：どんな要素もそれのインデックスを保存することによって繰り返しアクセスされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Always traps.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>常にトラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Always use the same properties in both your <bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>hash(into:)<ept i="1">&lt;/c1&gt;</ept> methods.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>常に同じプロパティをあなたの<bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept>および<bpt i="1" x="1">&lt;c1&gt;</bpt>hash(into:)<ept i="1">&lt;/c1&gt;</ept>メソッドの両方において使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Always use the slice’s <bpt i="0" x="0">&lt;c0&gt;</bpt>start<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property instead of assuming that its indices start at a particular value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>常にスライスの<bpt i="0" x="0">&lt;c0&gt;</bpt>start<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティを使ってください、それのインデックスが特定の値で始まると決めてかかるのではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Always use the slice’s <bpt i="7" x="7">&lt;c7&gt;</bpt>start<bpt i="8" x="8">&lt;w8&gt;</bpt>Index<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> and <bpt i="9" x="9">&lt;c9&gt;</bpt>end<bpt i="10" x="10">&lt;w10&gt;</bpt>Index<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> properties instead of assuming that its indices start or end at a particular value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>常にスライスの<bpt i="7" x="7">&lt;c7&gt;</bpt>start<bpt i="8" x="8">&lt;w8&gt;</bpt>Index<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>と<bpt i="9" x="9">&lt;c9&gt;</bpt>end<bpt i="10" x="10">&lt;w10&gt;</bpt>Index<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>プロパティを使ってください、それのインデックスが特定の値で始まると決めてかかるのではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Always zero, just like <bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>常にゼロ、ちょうど<bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Always zero, just like <bpt i="0" x="0">&lt;c0&gt;</bpt>start<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>常にゼロ、ちょうど<bpt i="0" x="0">&lt;c0&gt;</bpt>start<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An 8-bit signed integer value type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>8ビット符号つき整数値型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An <bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Bidirectional<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance forwards its operations to a base collection having the same <bpt i="3" x="3">&lt;c3&gt;</bpt>Element<ept i="3">&lt;/c3&gt;</ept> type, hiding the specifics of the underlying collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Bidirectional<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスは、それの操作を同じ<bpt i="3" x="3">&lt;c3&gt;</bpt>Element<ept i="3">&lt;/c3&gt;</ept>型を持っている基盤コレクションへと転送して、基礎をなすコレクションの特殊化を隠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An <bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Collection<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance forwards its operations to a base collection having the same <bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept> type, hiding the specifics of the underlying collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Collection<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスは、それの操作を同じ<bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept>型を持っている基盤コレクションへと転送して、基礎をなすコレクションの特殊化を隠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An <bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Random<bpt i="2" x="2">&lt;w2&gt;</bpt>Access<bpt i="3" x="3">&lt;w3&gt;</bpt>Collection<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance forwards its operations to a base collection having the same <bpt i="4" x="4">&lt;c4&gt;</bpt>Element<ept i="4">&lt;/c4&gt;</ept> type, hiding the specifics of the underlying collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Random<bpt i="2" x="2">&lt;w2&gt;</bpt>Access<bpt i="3" x="3">&lt;w3&gt;</bpt>Collection<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスは、それの操作を同じ<bpt i="4" x="4">&lt;c4&gt;</bpt>Element<ept i="4">&lt;/c4&gt;</ept>型を持っている基盤コレクションへと転送して、基礎をなすコレクションの特殊化を隠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An <bpt i="0" x="0">&lt;c0&gt;</bpt>Async<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> doesn’t generate or contain the values; it just defines how you access them.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Async<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、値それらを生成または含みません；それはただどのようにあなたがそれらにアクセスするかを定義するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An <bpt i="0" x="0">&lt;c0&gt;</bpt>Async<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> resembles the <bpt i="2" x="2">&lt;c2&gt;</bpt>Sequence<ept i="2">&lt;/c2&gt;</ept> type — offering a list of values you can step through one at a time — and adds asynchroncity.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Async<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、<bpt i="2" x="2">&lt;c2&gt;</bpt>Sequence<ept i="2">&lt;/c2&gt;</ept>型に類似して — あなたが一度に１つずつ段階処理していくことができるいくつかの値からなるあるリストを提供します — そして非同期性をつけ加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An <bpt i="3" x="3">&lt;c3&gt;</bpt>Async<bpt i="4" x="4">&lt;w4&gt;</bpt>Sequence<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> may have all, some, or none of its values available when you first use it.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある<bpt i="3" x="3">&lt;c3&gt;</bpt>Async<bpt i="4" x="4">&lt;w4&gt;</bpt>Sequence<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は、それの値の全て、いくつか、または０個を、あなたがそれを最初に使う時に利用可能とするかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An <bpt i="0" x="0">&lt;e0&gt;</bpt>extended grapheme cluster<ept i="0">&lt;/e0&gt;</ept> is a group of one or more Unicode scalar values that approximates a single user-perceived character.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>拡張書記素クラスタ<ept i="0">&lt;/e0&gt;</ept>は、ひとまとめにした１つ以上のユニコードスカラー値です、それは単一のユーザ知覚文字におおよそ相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An Objective-C protocol-qualified metaclass is imported by Swift as a protocol metatype, which is a type that represents the type of a protocol itself.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-Cプロトコル適格メタクラスは、Swiftによってプロトコルメタタイプとしてインポートされます、それはプロトコルそれ自体の型を表す型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An all-zeros exponent is reserved for subnormals and zeros, and an all-ones exponent is reserved for infinity and NaN.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>全てゼロの指数は非正規化数とゼロのために予約されます、そして全て１の指数は無限大とNaNのために予約されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An arity zero tuple is always after or the same as another arity zero tuple in a lexicographical ordering.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>項数ゼロのタプルは、常に語彙筆記的順序において別の項数ゼロのタプルの後またはそれと同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An arity zero tuple is always before or the same as another arity zero tuple in a lexicographical ordering.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>項数ゼロのタプルは、常に語彙筆記的順序において別の項数ゼロのタプルの前またはそれと同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An arity zero tuple is never strictly after another arity zero tuple in a lexicographical ordering.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>項数ゼロのタプルは、厳密に決して語彙筆記的順序において別の項数ゼロのタプルの後ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An arity zero tuple is never strictly before another arity zero tuple in a lexicographical ordering.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>項数ゼロのタプルは、厳密に決して語彙筆記的順序において別の項数ゼロのタプルの前ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An array can store any kind of elements—from integers to strings to classes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある配列は、整数から文字列まで、あるクラスであるどんなものであることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An array containing the elements of this sequence in reverse order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスの要素を逆順に含んでいる配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An array containing the transformed elements of this sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスの変換済み要素を含んでいる配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An array literal is a simple way of expressing a list of values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列リテラルは、値のリストを表す簡単な方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An array literal is not the same as an <bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列リテラルは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept>インスタンスと同じではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An array of arguments to convert to a C <bpt i="0" x="0">&lt;c0&gt;</bpt>va<bpt i="1" x="1">&lt;w1&gt;</bpt>_list<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> pointer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるC <bpt i="0" x="0">&lt;c0&gt;</bpt>va<bpt i="1" x="1">&lt;w1&gt;</bpt>_list<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ポインタに変換することになる、いくつかの引数からなる配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An array of subsequences, split from this collection’s elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このコレクションの要素を分割した、下位シーケンスいくらかからなる配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An array of subsequences, split from this sequence’s elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスの要素を分割した、下位シーケンスいくらかからなる配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An array of the elements that <bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Included<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> allowed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Included<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が許可する要素からなる配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An array of the non-<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> results of calling <bpt i="1" x="1">&lt;c1&gt;</bpt>transform<ept i="1">&lt;/c1&gt;</ept> with each element of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスの各要素で<bpt i="1" x="1">&lt;c1&gt;</bpt>transform<ept i="1">&lt;/c1&gt;</ept>を呼ぶことの非<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>の結果の配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An array of this sequence’s elements in a shuffled order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスの持つ要素からなる配列、シャッフルされた順番で。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An array that is the sole owner of its storage can perform mutating operations in place.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それのストレージのただ一人のオーナーである配列は、変化を伴う操作をそこで実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An array to compare.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>比較する配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An array value converts to an <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<bpt i="3" x="3">&lt;w3&gt;</bpt>.Value<bpt i="4" x="4">&lt;w4&gt;</bpt>Type<bpt i="5" x="5">&lt;w5&gt;</bpt>.sequence<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列値は、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<bpt i="3" x="3">&lt;w3&gt;</bpt>.Value<bpt i="4" x="4">&lt;w4&gt;</bpt>Type<bpt i="5" x="5">&lt;w5&gt;</bpt>.sequence<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>に変わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An asychronous sequence of Unicode scalar values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ユニコードスカラー値それらからなるある非同期シーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An asychronous sequence of characters.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>文字列いくつかからなるある非同期シーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An asychronous sequence of lines of text.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>テキスト行それらからなる非同期シーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An asynchronous sequence called <bpt i="3" x="3">&lt;c3&gt;</bpt>Rank<bpt i="4" x="4">&lt;w4&gt;</bpt>Counter<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> produces all elements of the array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>Rank<bpt i="4" x="4">&lt;w4&gt;</bpt>Counter<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>と呼ばれる非同期シーケンスは、その配列のすべての要素を取り出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An asynchronous sequence of the initial, consecutive elements that satisfy <bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>冒頭の、<bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>を満たす連続した要素それらからなるある非同期シーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An asynchronous sequence starting at the beginning of the base sequence with at most <bpt i="0" x="0">&lt;c0&gt;</bpt>count<ept i="0">&lt;/c0&gt;</ept> elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>基底シーケンスの先端で始まる多くとも<bpt i="0" x="0">&lt;c0&gt;</bpt>count<ept i="0">&lt;/c0&gt;</ept>要素の非同期シーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An asynchronous sequence that concatenates the results of calling a given error-throwing transformation with each element of this sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある非同期シーケンス、それは与えられたエラースロー変換をこのシーケンスの各要素で呼び出すことの結果を連結します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An asynchronous sequence that concatenates the results of calling a given transformation with each element of this sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある非同期シーケンス、それは与えられた変換をこのシーケンスの各要素で呼び出すことの結果を連結します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An asynchronous sequence that contains, in order, the elements of the base sequence that satisfy a given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある非同期シーケンス、それは基底シーケンスの要素それらを、順番に含みます、それらは与えられた述部を満たすものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given error-throwing predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある非同期シーケンス、それは基底シーケンスの要素それらを、順番に含みます、それらは与えられたエラースロー述部を満たすものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある非同期シーケンス、それは基底シーケンスの要素それらを、順番に含みます、それらは与えられた述部を満たすものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An asynchronous sequence that contains, in order, the elements produced by the <bpt i="0" x="0">&lt;c0&gt;</bpt>transform<ept i="0">&lt;/c0&gt;</ept> closure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある非同期シーケンス、それは<bpt i="0" x="0">&lt;c0&gt;</bpt>transform<ept i="0">&lt;/c0&gt;</ept>クロージャによって生み出された要素それらを、順番に含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An asynchronous sequence that contains, in order, the non-<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> elements produced by the <bpt i="1" x="1">&lt;c1&gt;</bpt>transform<ept i="1">&lt;/c1&gt;</ept> closure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある非同期シーケンス、それは<bpt i="1" x="1">&lt;c1&gt;</bpt>transform<ept i="1">&lt;/c1&gt;</ept>クロージャによって生み出された非<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>要素それらを、順番に含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An asynchronous sequence that drops the first <bpt i="0" x="0">&lt;c0&gt;</bpt>count<ept i="0">&lt;/c0&gt;</ept> elements from the base sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある非同期シーケンス、それは最初の<bpt i="0" x="0">&lt;c0&gt;</bpt>count<ept i="0">&lt;/c0&gt;</ept>要素を基底シーケンスから抜かします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An asynchronous sequence that maps a given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある非同期シーケンス、それは与えられたクロージャを非同期シーケンスのもつ要素のすべてにわたってマップします、値を返さない結果を省きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある非同期シーケンス、それはあるエラースロークロージャを基底シーケンスのもつ要素のすべてにわたってマップします、値を返さない結果を省きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある非同期シーケンス、それは与えられたクロージャを非同期シーケンスのもつ要素のすべてにわたってマップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある非同期シーケンス、それは与えられたエラースロークロージャを非同期シーケンスのもつ要素のすべてにわたってマップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An asynchronous sequence that skips over values from the base sequence until the provided closure returns <bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある非同期シーケンス、それは基底シーケンスから値それらを、この提供されたクロージャが<bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>を返すまで飛び越えるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An asynchronous sequence that skips over values until the provided closure returns <bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept> or throws an error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある非同期シーケンス、それは値それらを、この提供されたクロージャが<bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>を返すかエラーをスローするまで飛び越えるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An asynchronous sequence which omits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある非同期シーケンス、それは指定された数の要素を基底非同期シーケンスから省きます、それから全ての残りの要素をずっと渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An asynchronous sequence which omits elements from the base sequence until a given closure returns false, after which it passes through all remaining elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある非同期シーケンス、それは要素を基底シーケンスから、ある与えられたクロージャがfalseを返すまで省きます、それの後それは全ての残りの要素をずっと渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An asynchronous sequence which omits elements from the base sequence until a given error-throwing closure returns false, after which it passes through all remaining elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある非同期シーケンス、それは要素を基底シーケンスから、ある与えられたエラースロークロージャがfalseを返すまで省きます、それの後それは全ての残りの要素をずっと渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy a given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある非同期シーケンス、それは基底シーケンスの冒頭の、連続する要素いくつかを含んでいます、それらは与えられた述部を満たすものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given error-throwing predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある非同期シーケンス、それは基底シーケンスの冒頭の、連続する要素いくつかを含んでいます、それらは与えられたエラースロー述部を満たすものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An asynchronous sequence, up to a specified maximum length, containing the initial elements of a base asynchronous sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された最大長まで、その基盤非同期シーケンスの冒頭の要素を含んでいる、ある非同期シーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An element of a collection is located under the same index in a slice as in the base collection, as long as neither the collection nor the slice has been mutated since the slice was created.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションのある要素は、基盤となるコレクションの中と同じスライスの中のインデックスのもとに位置を突き止められます、コレクションもスライスもスライスが作成された時からずっと変化していない限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An element to search for in the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このコレクションにおいて捜される要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An empty array literal alone doesn’t provide enough information for the compiler to infer the intended type of the <bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>空の配列リテラルそれだけでは、コンパイラが<bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept>インスタンスの意図される型を推論するのに十分な情報を提供していません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An empty tuple.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>空のタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An end value to limit the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスに限界を設けるための終了値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An enumeration of the elements of a sequence or collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスまたはコレクションの要素の列挙。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An equivalent range must be representable as a closed range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同等の範囲が、完結範囲として表現可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An error that occurs during the decoding of a value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値のデコーディングの間に起こるエラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An error that occurs during the encoding of a value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値のエンコーディングの間に起こるエラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An error-throwing closure that takes an element as a parameter and returns a Boolean value indicating whether to drop the element from the modified sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるエラースロークロージャ、それはある要素をパラメータとして取り、その要素をこの修正後のシーケンスから抜かすことになるかどうかを指し示すブール値を返すものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An error-throwing closure that takes an element of the asynchronous sequence as its argument and returns a Boolean value that indicates whether to include the element in the filtered sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるエラースロークロージャ、それは非同期シーケンスの１つの要素をそれの引数として取り、その要素をこの平坦化されたシーケンスに含むことになるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An error-throwing mapping closure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるエラースローマッピングクロージャ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An extended-precision, floating-point value type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>拡張倍精度、浮動小数点値型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An implementation detail of key path expressions; do not use this protocol directly.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キーパス式の実装詳細；このプロトコルを直接に使わないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An index offset by <bpt i="0" x="0">&lt;c0&gt;</bpt>distance<ept i="0">&lt;/c0&gt;</ept> from the index <bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept>, unless that index would be beyond <bpt i="2" x="2">&lt;c2&gt;</bpt>limit<ept i="2">&lt;/c2&gt;</ept> in the direction of movement.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>distance<ept i="0">&lt;/c0&gt;</ept>だけインデックス<bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept>から補われたインデックス、そのインデックスが<bpt i="2" x="2">&lt;c2&gt;</bpt>limit<ept i="2">&lt;/c2&gt;</ept>を移動方向において越える場合を除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An index offset by <bpt i="0" x="0">&lt;c0&gt;</bpt>distance<ept i="0">&lt;/c0&gt;</ept> from the index <bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>distance<ept i="0">&lt;/c0&gt;</ept>だけインデックス<bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept>から補われるインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An index offset by <bpt i="0" x="0">&lt;c0&gt;</bpt>n<ept i="0">&lt;/c0&gt;</ept> from the index <bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept>, unless that index would be beyond <bpt i="2" x="2">&lt;c2&gt;</bpt>limit<ept i="2">&lt;/c2&gt;</ept> in the direction of movement.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インデックス<bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept>から<bpt i="0" x="0">&lt;c0&gt;</bpt>n<ept i="0">&lt;/c0&gt;</ept>だけ補われたインデックス、そのインデックスが<bpt i="2" x="2">&lt;c2&gt;</bpt>limit<ept i="2">&lt;/c2&gt;</ept>を移動方向において越えない限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An index offset by <bpt i="0" x="0">&lt;c0&gt;</bpt>n<ept i="0">&lt;/c0&gt;</ept> from the index <bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インデックス<bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept>から<bpt i="0" x="0">&lt;c0&gt;</bpt>n<ept i="0">&lt;/c0&gt;</ept>だけ補われるインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An index to compare.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>比較するインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An indication that a keyed decoding container was asked for an entry for the given key, but did not contain one.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キー付きデコーディングコンテナが与えられたキーに対する登録項目について尋ねられた、しかし含んでいるものがなかったことを指し示すもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An indication that a non-optional value of the given type was expected, but a null value was found.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた型のある非オプショナル値が期待された、しかしnull値が見つけられたことを指し示すもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An indication that a value of the given type could not be decoded because it did not match the type of what was found in the encoded payload.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた型の値がデコードできなかった、なぜならエンコードされたペイロードの中に見つけられた何かの型とそれが合致しなかったことを指し示すもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An indication that an encoder or its containers could not encode the given value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>エンコーダまたはそれのコンテナが与えられた値をエンコードできなかったことを指し示すもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An indication that the data is corrupted or otherwise invalid.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>データが不正またはそうでなくとも無効であることを指し示すもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An individual task throws its error in the corresponding call to <bpt i="0" x="0">&lt;c0&gt;</bpt>Group<bpt i="1" x="1">&lt;w1&gt;</bpt>.next()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, which gives you a chance to handle individual error or to let the error be rethrown by the group.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>個々のタスクはそれのエラーをその対応する<bpt i="0" x="0">&lt;c0&gt;</bpt>Group<bpt i="1" x="1">&lt;w1&gt;</bpt>.next()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>への呼び出しの中でスローします、それはあなたに個々のエラーを取り扱うためのまたはそのエラーをグループによって再スローさせるための機会を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An insertion.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある挿入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An instance of <bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> forwards its operations to an underlying base sequence having the same <bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept> type, hiding the specifics of the underlying sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のインスタンスは、同じ<bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept>型を持つある基礎をなす基盤シーケンスへと操作を転送します、基礎をなすシーケンスの特殊化を隠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An instance of <bpt i="0" x="0">&lt;c0&gt;</bpt>String<bpt i="1" x="1">&lt;w1&gt;</bpt>Interpolation<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> which has had each segment of the string literal appended to it.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>String<bpt i="1" x="1">&lt;w1&gt;</bpt>Interpolation<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のインスタンス、それはそれへと加えられた文字列リテラルの各文節を持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An instance of <bpt i="0" x="0">&lt;c0&gt;</bpt>Unsafe<bpt i="1" x="1">&lt;w1&gt;</bpt>Continuation<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> that hasn’t yet been resumed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Unsafe<bpt i="1" x="1">&lt;w1&gt;</bpt>Continuation<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のあるインスタンスで、まだ再開されていないもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An instance of a <bpt i="0" x="0">&lt;e0&gt;</bpt>hashable<ept i="0">&lt;/e0&gt;</ept> type can reduce its value mathematically to a single integer, which is used internally by sets and dictionaries to make lookups consistently fast.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;e0&gt;</bpt>hashable<ept i="0">&lt;/e0&gt;</ept>型のインスタンスは、それの値を単一の整数へと数学的に還元できます、それは検索を常に高速なものにするために集合と辞書によって内部的に使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An instance of a class.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクラスのインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An instance of an observer class manages information about changes made to one or more properties.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オブザーバクラスのあるインスタンスは、ひとつ以上のプロパティに対してなされる変更についての情報を管理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An instance of the <bpt i="0" x="0">&lt;c0&gt;</bpt>Async<bpt i="1" x="1">&lt;w1&gt;</bpt>Iterator<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type used to produce elements of the asynchronous sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>非同期シーケンスの要素それらを生み出すために使われる<bpt i="0" x="0">&lt;c0&gt;</bpt>Async<bpt i="1" x="1">&lt;w1&gt;</bpt>Iterator<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An instance of this iterator wraps a base iterator and yields successive <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept> values, starting at zero, along with the elements of the underlying base iterator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイテレータのインスタンスは、基盤イテレータをラップして、連続する<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>値を、ゼロで開始して、基礎をなす基盤イテレータの要素と一緒に生じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An instance representing the state of the receiver with the difference applied, or <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> if the difference is incompatible with the receiver’s state.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>適用された差異をもつレシーバの状態を表しているインスタンス、または<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>、もし差異がレシーバのもつ状態と相容れないならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An instance to cast to type <bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept>にキャストすることになるインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An instance to preserve until the execution of <bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept> is completed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept>の実行が完了するまで保護するインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An instance to temporarily access through a mutable raw buffer pointer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>可変の生のバッファポインタを通して一時的にアクセスされることになるインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An instance to temporarily access through a raw buffer pointer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>生のバッファポインタを通して一時的にアクセスされることになるインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An instance to temporarily use via pointer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ポインタ経由で一時的に使われることになるインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An integer to compare.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>比較する整数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An integer to convert to this type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型へと変換する整数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An integer to convert.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>変換する整数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An integer type that can represent both positive and negative values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>正および負の値の両方を表すことができる整数型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An integer type that can represent only nonnegative values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>非負値だけを表すことができる整数型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An integer type that uses a fixed size for every instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あらゆるインスタンスに対して固定された大きさを使う整数型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An integer type with a binary representation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>バイナリ表現での整数型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An integer value converts to an <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<bpt i="3" x="3">&lt;w3&gt;</bpt>.Value<bpt i="4" x="4">&lt;w4&gt;</bpt>Type<bpt i="5" x="5">&lt;w5&gt;</bpt>.int<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>整数値は、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<bpt i="3" x="3">&lt;w3&gt;</bpt>.Value<bpt i="4" x="4">&lt;w4&gt;</bpt>Type<bpt i="5" x="5">&lt;w5&gt;</bpt>.int<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>に変わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An integer value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある整数値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An interval from a lower bound up to, and including, an upper bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下側の境界から、上側の境界までの、そしてそれを含む、間隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An iterator for a <bpt i="0" x="0">&lt;c0&gt;</bpt>Stride<bpt i="1" x="1">&lt;w1&gt;</bpt>Through<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Stride<bpt i="1" x="1">&lt;w1&gt;</bpt>Through<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスのためのイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An iterator for a <bpt i="0" x="0">&lt;c0&gt;</bpt>Stride<bpt i="1" x="1">&lt;w1&gt;</bpt>To<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Stride<bpt i="1" x="1">&lt;w1&gt;</bpt>To<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスのためのイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An iterator of code units to be translated, encoded as <bpt i="0" x="0">&lt;c0&gt;</bpt>input<bpt i="1" x="1">&lt;w1&gt;</bpt>Encoding<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>翻訳されることになるいくらかのコードユニットからなるあるイテレータ、<bpt i="0" x="0">&lt;c0&gt;</bpt>input<bpt i="1" x="1">&lt;w1&gt;</bpt>Encoding<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>としてエンコードされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An iterator over the dictionary with elements of type <bpt i="0" x="0">&lt;c0&gt;</bpt>(key: Key, value: Value)<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型<bpt i="0" x="0">&lt;c0&gt;</bpt>(key: Key, value: Value)<ept i="0">&lt;/c0&gt;</ept>の要素を持つ辞書のすべてを対象とするイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An iterator over the members of a <bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary&lt;Key, Value&gt;<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary&lt;Key, Value&gt;<ept i="0">&lt;/c0&gt;</ept>のメンバーすべてを対象とするイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An iterator that never produces an element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>決して要素を生成しないイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An iterator that produces one or zero instances of an element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある要素のインスタンスを１つまたは０個生み出すイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An iterator to type-erase.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型消去することになるイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An object representing a dynamic collection of key-value pairs, for use instead of a <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>Dictionary<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> variable in cases that require reference semantics.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キー値ペアからなる動的なコレクションを表しているオブジェクト、参照意味論を必要とする場合に<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>Dictionary<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>変数の代わりに使うため。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An object representing a dynamic ordered collection, for use instead of an <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>Array<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> variable in cases that require reference semantics.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>静的な順序付きコレクションを表しているオブジェクト、参照意味論を必要とする場合に<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>Array<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>変数の代わりに使うため。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An object representing a static collection of key-value pairs, for use instead of a <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>Dictionary<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> constant in cases that require reference semantics.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キー値ペアからなる静的なコレクションを表しているオブジェクト、参照意味論を必要とする場合に<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>Dictionary<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>定数の代わりに使うため。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An object representing a static ordered collection, for use instead of an <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>Array<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> constant in cases that require reference semantics.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>静的な順序付きコレクションを表しているオブジェクト、参照意味論を必要とする場合に<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>Array<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>定数の代わりに使うため。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An optional value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オプショナル値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An ordered, asynchronously generated sequence of elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>いくつかの要素からなる、順番をつけられた、非同期に生成されたシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An ordered, random-access collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>順序付けられた、無作為アクセスのコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An output stream to receive the text representation of each item.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>各項目のテキスト表現を受け取る出力ストリーム。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An output stream.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある出力ストリーム。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An overshift results in <bpt i="3" x="3">&lt;c3&gt;</bpt>-1<ept i="3">&lt;/c3&gt;</ept> for a negative value of <bpt i="4" x="4">&lt;c4&gt;</bpt>lhs<ept i="4">&lt;/c4&gt;</ept> or <bpt i="5" x="5">&lt;c5&gt;</bpt>0<ept i="5">&lt;/c5&gt;</ept> for a nonnegative value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オーバーシフトは、負の値の<bpt i="3" x="3">&lt;c3&gt;</bpt>lhs<ept i="3">&lt;/c3&gt;</ept>に対して<bpt i="4" x="4">&lt;c4&gt;</bpt>-1<ept i="4">&lt;/c4&gt;</ept>または非負値に対して<bpt i="5" x="5">&lt;c5&gt;</bpt>0<ept i="5">&lt;/c5&gt;</ept>という結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An unkeyed container view into this decoder.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このデコーダへのキー無しコンテナビュー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An unowned reference to a serial executor (a <bpt i="0" x="0">&lt;c0&gt;</bpt>Serial<bpt i="1" x="1">&lt;w1&gt;</bpt>Executor<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> value).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある直列遂行者（シリアルエグゼキュータ）への非所有参照（<bpt i="0" x="0">&lt;c0&gt;</bpt>Serial<bpt i="1" x="1">&lt;w1&gt;</bpt>Executor<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>値）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An unsigned, fixed-width integer type can represent values from 0 through <bpt i="0" x="0">&lt;c0&gt;</bpt>(2 ** bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Width) - 1<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, where <bpt i="2" x="2">&lt;c2&gt;</bpt>**<ept i="2">&lt;/c2&gt;</ept> is exponentiation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>符号なしの、固定長整数型は、０から<bpt i="0" x="0">&lt;c0&gt;</bpt>(2 ** bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Width) - 1<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>までの値を表せます、そこで<bpt i="2" x="2">&lt;c2&gt;</bpt>**<ept i="2">&lt;/c2&gt;</ept>は冪演算です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>And because <bpt i="4" x="4">&lt;c4&gt;</bpt>Array<bpt i="5" x="5">&lt;w5&gt;</bpt>Slice<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> presents the same interface as <bpt i="6" x="6">&lt;c6&gt;</bpt>Array<ept i="6">&lt;/c6&gt;</ept>, you can generally perform the same operations on a slice as you could on the original array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そして<bpt i="4" x="4">&lt;c4&gt;</bpt>Array<bpt i="5" x="5">&lt;w5&gt;</bpt>Slice<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は<bpt i="6" x="6">&lt;c6&gt;</bpt>Array<ept i="6">&lt;/c6&gt;</ept>と同じインターフェイスを提供するので、あなたは一般的にあなたが元の配列上でできるのと同じ操作をスライス上で実行できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>And here’s how Swift imports it:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そしてここにスウィフトがそれをインポートする方法があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Annotate a Property for Key-Value Observing</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キー値監視のためのプロパティに注釈をつける</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Another array to compare.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>比較するもう一方の配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Another floating-point value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>もう１つの浮動小数点値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Another index to compare.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>もう一方の比較するインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Another integer to compare.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>比較するもう一方の整数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Another integer value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>もう１つの整数値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Another range to compare.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>もう一方の比較する範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Another range-replaceable collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>もう一方の範囲置換可能なコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Another reference to compare.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>もう一方の比較する参照。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Another tuple of elements of the same type as <bpt i="0" x="0">&lt;c0&gt;</bpt>lhs<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>lhs<ept i="0">&lt;/c0&gt;</ept>と同じ型の要素からなる別のタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Another type to compare.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>比較するもう一方の型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Another type-erased hashable value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>もう一方の型消去ハッシュ可能値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Another valid index of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの別の有効なインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Another value to compare.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>もう一方の比較する値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Any contextual information set by the user for decoding.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>デコーディングに対するユーザによって設定される何らかの前後関係情報。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Any contextual information set by the user for encoding.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>エンコーディングのためのユーザによって設定される何らかの前後関係情報。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Any fractional part of <bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept> is removed, rounding the resulting value toward zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept>の小数部分は何であれ取り除かれます、結果となる値はゼロへと丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Any fractional part of the value passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>source<ept i="0">&lt;/c0&gt;</ept> is removed, rounding the value toward zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>source<ept i="0">&lt;/c0&gt;</ept>として渡される値の小数部分は何であれ取り除かれます、値はゼロへと丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Any fractional part of the value passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>source<ept i="0">&lt;/c0&gt;</ept> is removed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>source<ept i="0">&lt;/c0&gt;</ept>として渡される値の小数部分は何であれ取り除かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Any padding is performed by <bpt i="0" x="0">&lt;e0&gt;</bpt>sign-extending<ept i="0">&lt;/e0&gt;</ept> the passed value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あらゆる詰め物は、渡された値を<bpt i="0" x="0">&lt;e0&gt;</bpt>符号拡張<ept i="0">&lt;/e0&gt;</ept>することによって実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Any public Objective-C headers listed in the bridging header are visible to Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ブリッジヘッダにおいて列記されるあらゆるパブリックObjective-Cヘッダは、Swiftにとって見ることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Any such case that next is invoked concurrently and contends with another call to next is a programmer error and will fatalError.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>nextが並行的に発動されるそしてnextへの別の呼び出しと争うようなどんな場合も、プログラマの誤りです、そしてfatalErrorでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Any type that conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept> protocol can be used as a dictionary’s <bpt i="1" x="1">&lt;c1&gt;</bpt>Key<ept i="1">&lt;/c1&gt;</ept> type, including all of Swift’s basic types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftの基本的な型のすべてを含めて、<bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠するあらゆる型は、辞書の<bpt i="1" x="1">&lt;c1&gt;</bpt>Key<ept i="1">&lt;/c1&gt;</ept>型として使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Any type that declares conformance to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Error<ept i="0">&lt;/c0&gt;</ept> protocol can be used to represent an error in Swift’s error handling system.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Error<ept i="0">&lt;/c0&gt;</ept>プロトコルへの準拠を宣言するあらゆる型は、エラーをSwiftのエラー処理システムにおいて表すために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Any value whose magnitude is so great that it would round to a value outside the range of representable numbers is rounded to <bpt i="0" x="0">&lt;e0&gt;</bpt>infinity<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それの規模が大きすぎるので表現可能な数の範囲外の値に丸められるであろう何らかの値は、<bpt i="0" x="0">&lt;e0&gt;</bpt>無限大<ept i="0">&lt;/e0&gt;</ept>に丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Append operations that trigger reallocation have a performance cost, but they occur less and less often as the array grows larger.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>再割り当ての引き金となる追加操作はある性能コストを持ちます、しかしそれらは配列がより大きく成長するにつれて大抵ますます少ない頻度でしか生じません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Appending the key path passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>path<ept i="0">&lt;/c0&gt;</ept> is successful only if the root type for <bpt i="1" x="1">&lt;c1&gt;</bpt>path<ept i="1">&lt;/c1&gt;</ept> matches this key path’s value type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>path<ept i="0">&lt;/c0&gt;</ept>として渡されるキーパスの追加は、<bpt i="1" x="1">&lt;c1&gt;</bpt>path<ept i="1">&lt;/c1&gt;</ept>のルート型がこのキーパスの持つ値型と合致する場合にのみ成功します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Appends a literal segment of a string interpolation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある文字列補間のリテラル断片を加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Appends the elements of a sequence to a range-replaceable collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンスの要素を範囲置換コレクションに加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Appends the given string to the stream.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた文字列をストリームへ追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Applies the given difference to this collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた差異をこのコレクションに適用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Apply macros to your Objective-C APIs to customize how they're imported into Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>マクロをあなたのObjective-C APIに適用して、それらがSwiftにインポートされる方法をカスタマイズします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Archives and Serialization</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>アーカイブとシリアライゼーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Arithmetic</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>算術</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Arithmetic with Assignment</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>代入での算術</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Arrays are one of the most commonly used data types in an app.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列は、アプリにおいて最も一般的に使われるデータ型の１つです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Arrays need to follow a geometric allocation pattern for appending elements to achieve amortized constant-time performance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ならし定数時間性能を達成するために、配列は要素を追加するのにある幾何数級的なアロケートパターンに従う必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Arrays, like all variable-size collections in the standard library, use copy-on-write optimization.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列は、標準ライブラリにおける可変サイズコレクションのすべてと同じく、コピーオンライト最適化を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Arrays, sets, and option sets all conform to <bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>Array<bpt i="3" x="3">&lt;w3&gt;</bpt>Literal<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, and your own custom types can as well.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列、集合、またはオプションセットは、すべて<bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>Array<bpt i="3" x="3">&lt;w3&gt;</bpt>Literal<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠します、そしてあなた独自のあつらえの型もまたそうできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As a result, <bpt i="3" x="3">&lt;c3&gt;</bpt>type(of:)<ept i="3">&lt;/c3&gt;</ept> can only produce the concrete metatype <bpt i="4" x="4">&lt;c4&gt;</bpt>P<bpt i="5" x="5">&lt;w5&gt;</bpt>.Protocol<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果として、<bpt i="3" x="3">&lt;c3&gt;</bpt>type(of:)<ept i="3">&lt;/c3&gt;</ept>は具象メタタイプ<bpt i="4" x="4">&lt;c4&gt;</bpt>P<bpt i="5" x="5">&lt;w5&gt;</bpt>.Protocol<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を生成することだけが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As a result, changing the value of a property on an instance of the imported structure changes the value of all other properties defined by that structure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果として、インポートされた構造体上でプロパティを変更することは、その構造体によって定義される全ての他のプロパティの値を変更します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As a result, requests to the database won't accidentally change the wrong record.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果として、データベースに対する要請は誤って相応しくないレコードを変更することはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As a result, you can look at a section of code and be more confident that changes to instances in that section will be made explicitly, rather than being made invisibly from a tangentially related function call.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果として、あなたはコードのある区画を調べて、その区画のインスタンスに対する変更が明確だということを、ほとんど無関係な関連する関数呼び出しから不可視に行われるよりむしろずっと自信を持てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As an associated value, this case contains the context for debugging.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある関連値として、この場合はデバッグのための前後関係を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As an example, consider a <bpt i="0" x="0">&lt;c0&gt;</bpt>Grid<bpt i="1" x="1">&lt;w1&gt;</bpt>Point<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type that describes a location in a grid of buttons.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>１つの例として、<bpt i="0" x="0">&lt;c0&gt;</bpt>Grid<bpt i="1" x="1">&lt;w1&gt;</bpt>Point<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型を考えてみてください、それはある格子状配列のボタンにおけるある場所を記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As an example, consider a <bpt i="0" x="0">&lt;c0&gt;</bpt>Street<bpt i="1" x="1">&lt;w1&gt;</bpt>Address<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> class that holds the parts of a street address: a house or building number, the street name, and an optional unit number.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例として、<bpt i="0" x="0">&lt;c0&gt;</bpt>Street<bpt i="1" x="1">&lt;w1&gt;</bpt>Address<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>クラスを考えてください、それは通り住所の部分；家またはビル番地、通りの名、そして随意に戸番号を保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As an example, here’s an implementation of a <bpt i="0" x="0">&lt;c0&gt;</bpt>Date<ept i="0">&lt;/c0&gt;</ept> structure that stores the year, month, and day of a date:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例として、ある日付の年、月、そして日を格納するある<bpt i="0" x="0">&lt;c0&gt;</bpt>Date<ept i="0">&lt;/c0&gt;</ept>構造体の実装がここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As associated values, this case contains the attempted key and context for debugging.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>関連値いくつかとして、この場合は試みられたキーとデバッグのための前後関係を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As associated values, this case contains the attempted type and context for debugging.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>関連値いくつかとして、この場合は試みられた型とデバッグのための前後関係を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As associated values, this case contains the attempted value and context for debugging.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>関連値いくつかとして、この場合は試みられた値とデバッグのための前後関係を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As in the previous example, Swift imports this Objective-C method as two methods: an asynchronous method that takes a closure, and an asynchronous throwing method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>前の例でのように、SwiftはこのObjective-Cメソッドを２つのメソッドとしてインポートします：クロージャを取る非同期メソッド、そして非同期スローメソッド。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As long as the predicate returns <bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>, this method returns <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>述部が<bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>を返す限り、このメソッドは<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As noted in the previous section, two instances that are considered equal must have the same hash value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>前の節で注記されるように、等しいとみなされる２つのインスタンスは、同じハッシュ値を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As soon as the sequence has run out of elements, all subsequent calls return <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスが要素を使い果たすやいなや、全てのその後の呼び出しは<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As the dictionary is built, the initializer calls the <bpt i="0" x="0">&lt;c0&gt;</bpt>combine<ept i="0">&lt;/c0&gt;</ept> closure with the current and new values for any duplicate keys.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書が組み立てられるとき、このイニシャライザは<bpt i="0" x="0">&lt;c0&gt;</bpt>combine<ept i="0">&lt;/c0&gt;</ept>クロージャを何らかの重複キーに対してその現在および新規の値とともに呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As the key-value pairs are merged with the dictionary, the <bpt i="1" x="1">&lt;c1&gt;</bpt>combine<ept i="1">&lt;/c1&gt;</ept> closure is called with the current and new values for any duplicate keys that are encountered.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それらキー値ペアが辞書に結合されるときに、出くわした全ての重複キーに対してその現在および新規の値とともに<bpt i="1" x="1">&lt;c1&gt;</bpt>combine<ept i="1">&lt;/c1&gt;</ept>クロージャが呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As the key-value pairs in <bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept> are merged with this dictionary, the <bpt i="2" x="2">&lt;c2&gt;</bpt>combine<ept i="2">&lt;/c2&gt;</ept> closure is called with the current and new values for any duplicate keys that are encountered.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>の中のキー値ペアがこの辞書と結合される時、<bpt i="2" x="2">&lt;c2&gt;</bpt>combine<ept i="2">&lt;/c2&gt;</ept>クロージャは、遭遇される何らかの重複キーに対して現在および新規の値とともに呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As the key-values pairs in <bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept> are merged with this dictionary, the <bpt i="2" x="2">&lt;c2&gt;</bpt>combine<ept i="2">&lt;/c2&gt;</ept> closure is called with the current and new values for any duplicate keys that are encountered.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>の中のキー値ペアがこの辞書と結合されるとき、<bpt i="2" x="2">&lt;c2&gt;</bpt>combine<ept i="2">&lt;/c2&gt;</ept>クロージャは、遭遇される何らかの重複キーに対して現在および新規の値とともに呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As with <bpt i="0" x="0">&lt;c0&gt;</bpt>Sequence<ept i="0">&lt;/c0&gt;</ept>, you typically iterate through an <bpt i="1" x="1">&lt;c1&gt;</bpt>Async<bpt i="2" x="2">&lt;w2&gt;</bpt>Sequence<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> with a <bpt i="3" x="3">&lt;c3&gt;</bpt>for await<ept i="3">&lt;/c3&gt;</ept>-<bpt i="4" x="4">&lt;c4&gt;</bpt>in<ept i="4">&lt;/c4&gt;</ept> loop.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Sequence<ept i="0">&lt;/c0&gt;</ept>でのように、あなたは概して<bpt i="1" x="1">&lt;c1&gt;</bpt>Async<bpt i="2" x="2">&lt;w2&gt;</bpt>Sequence<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>を<bpt i="3" x="3">&lt;c3&gt;</bpt>for await<ept i="3">&lt;/c3&gt;</ept>-<bpt i="4" x="4">&lt;c4&gt;</bpt>in<ept i="4">&lt;/c4&gt;</ept>ループで始めから終わりまで反復処理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As with any basic operation, if this value is outside the representable range of the type, overflow or underflow occurs, and zero, a subnormal value, or infinity may result.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あらゆる基本的演算でのように、この値がその型の表現可能な範囲の外側ならば、オーバーフローまたはアンダーフローが起こります、そしてゼロ、サブノーマル値、または無限大が結果となるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Associate the Observer with the Property to Observe</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>監視するプロパティとオブザーバを結びつける</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Associated Types</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>さまざまな関連型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>AsyncStream can be initialized with the option to buffer to a given limit.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>AsyncStreamは、あるオプションで初期化されることで、ある与えられた限界までバッファすることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>AsyncStream is an interface type to adapt from code producing values to an asynchronous context iterating them.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>AsyncStreamは、値それらを生み出しているコードから、それらを反復処理している非同期な文脈へと適合させるあるインターフェイス型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>AsyncStream offers a initialization strategy that provides a method of yielding values into iteration.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>AsyncStreamは、ある初期化戦略を申し出ます、それは反復へと値を生み出す手法を提供するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Asynchronous calls are another type of API that typically escape their closure arguments.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>非同期呼び出しは別の種類のAPIで、それは一般的にそれらのクロージャ引数を脱出させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Asynchronously advances to the next element and returns it, or ends the sequence if there is no next element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>非同期に次の要素に前進して、それを返します、または次の要素がないならばそのシーケンスを終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>At least one of the sequences must be finite.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>少なくともシーケンスのうちの一方は有限でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>At the call site, this looks like:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>呼び出し場所で、これは次のように見えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>At this point, <bpt i="6" x="6">&lt;c6&gt;</bpt>next()<ept i="6">&lt;/c6&gt;</ept> is ready to receive the next value from the base sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この時点で、<bpt i="6" x="6">&lt;c6&gt;</bpt>next()<ept i="6">&lt;/c6&gt;</ept>は次の要素を基底シーケンスから受け取る準備ができています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Attempt to cancel the task.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>タスクの取り消しを試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Attempting to access an element by using an index outside the bounds of the slice may result in a runtime error, even if that index is valid for the original collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある要素にスライスの境界外のインデックスを使ってアクセスを試みることは、実行時エラーという結果になるでしょう、たとえそのインデックスが元々のコレクションに対して有効であるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Attempting to access an element by using an index outside the bounds of the slice’s indices may result in a runtime error, even if that index is valid for the original collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある要素にスライスのもつインデックスの境界外のインデックスを使ってアクセスを試みることは、実行時エラーという結果になるでしょう、たとえそのインデックスが元々のコレクションに対して有効であるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Attempting to remove more elements than exist in the collection triggers a runtime error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの中に存在するより多くの要素の削除を試みることは実行時エラーの引き金となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Array<bpt i="2" x="2">&lt;w2&gt;</bpt>Literal<bpt i="3" x="3">&lt;w3&gt;</bpt>Element<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is <bpt i="4" x="4">&lt;c4&gt;</bpt><ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>Element<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Array<bpt i="2" x="2">&lt;w2&gt;</bpt>Literal<bpt i="3" x="3">&lt;w3&gt;</bpt>Element<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt><ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>Element<ept i="5">&lt;/c5&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept> conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt>Comparable<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Comparable<ept i="2">&lt;/c2&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept> conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt>Equatable<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Equatable<ept i="2">&lt;/c2&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>UInt8<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>UInt8<ept i="2">&lt;/c2&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Extended<bpt i="2" x="2">&lt;w2&gt;</bpt>Grapheme<bpt i="3" x="3">&lt;w3&gt;</bpt>Cluster<bpt i="4" x="4">&lt;w4&gt;</bpt>Literal<bpt i="5" x="5">&lt;w5&gt;</bpt>Type<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is <bpt i="6" x="6">&lt;c6&gt;</bpt><ept i="6">&lt;/c6&gt;</ept><bpt i="7" x="7">&lt;c7&gt;</bpt>String<bpt i="8" x="8">&lt;w8&gt;</bpt>Literal<bpt i="9" x="9">&lt;w9&gt;</bpt>Type<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Extended<bpt i="2" x="2">&lt;w2&gt;</bpt>Grapheme<bpt i="3" x="3">&lt;w3&gt;</bpt>Cluster<bpt i="4" x="4">&lt;w4&gt;</bpt>Literal<bpt i="5" x="5">&lt;w5&gt;</bpt>Type<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>が<bpt i="6" x="6">&lt;c6&gt;</bpt><ept i="6">&lt;/c6&gt;</ept><bpt i="7" x="7">&lt;c7&gt;</bpt>String<bpt i="8" x="8">&lt;w8&gt;</bpt>Literal<bpt i="9" x="9">&lt;w9&gt;</bpt>Type<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Extended<bpt i="2" x="2">&lt;w2&gt;</bpt>Grapheme<bpt i="3" x="3">&lt;w3&gt;</bpt>Cluster<bpt i="4" x="4">&lt;w4&gt;</bpt>Literal<bpt i="5" x="5">&lt;w5&gt;</bpt>Type<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is <bpt i="6" x="6">&lt;c6&gt;</bpt><ept i="6">&lt;/c6&gt;</ept><bpt i="7" x="7">&lt;c7&gt;</bpt>Unicode<bpt i="8" x="8">&lt;w8&gt;</bpt>Scalar<bpt i="9" x="9">&lt;w9&gt;</bpt>Literal<bpt i="10" x="10">&lt;w10&gt;</bpt>Type<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Extended<bpt i="2" x="2">&lt;w2&gt;</bpt>Grapheme<bpt i="3" x="3">&lt;w3&gt;</bpt>Cluster<bpt i="4" x="4">&lt;w4&gt;</bpt>Literal<bpt i="5" x="5">&lt;w5&gt;</bpt>Type<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>が<bpt i="6" x="6">&lt;c6&gt;</bpt><ept i="6">&lt;/c6&gt;</ept><bpt i="7" x="7">&lt;c7&gt;</bpt>Unicode<bpt i="8" x="8">&lt;w8&gt;</bpt>Scalar<bpt i="9" x="9">&lt;w9&gt;</bpt>Literal<bpt i="10" x="10">&lt;w10&gt;</bpt>Type<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Indices<ept i="1">&lt;/c1&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>Default<bpt i="3" x="3">&lt;w3&gt;</bpt>Indices<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>&lt;<ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>Self<ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>&gt;<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Indices<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Default<bpt i="3" x="3">&lt;w3&gt;</bpt>Indices<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>&lt;<ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>Self<ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>&gt;<ept i="6">&lt;/c6&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Iterator<ept i="1">&lt;/c1&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>Indexing<bpt i="3" x="3">&lt;w3&gt;</bpt>Iterator<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>&lt;<ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>Self<ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>&gt;<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Iterator<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Indexing<bpt i="3" x="3">&lt;w3&gt;</bpt>Iterator<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>&lt;<ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>Self<ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>&gt;<ept i="6">&lt;/c6&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Raw<bpt i="2" x="2">&lt;w2&gt;</bpt>Significand<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Fixed<bpt i="4" x="4">&lt;w4&gt;</bpt>Width<bpt i="5" x="5">&lt;w5&gt;</bpt>Integer<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Raw<bpt i="2" x="2">&lt;w2&gt;</bpt>Significand<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Fixed<bpt i="4" x="4">&lt;w4&gt;</bpt>Width<bpt i="5" x="5">&lt;w5&gt;</bpt>Integer<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>String<bpt i="2" x="2">&lt;w2&gt;</bpt>Interpolation<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is <bpt i="3" x="3">&lt;c3&gt;</bpt>Default<bpt i="4" x="4">&lt;w4&gt;</bpt>String<bpt i="5" x="5">&lt;w5&gt;</bpt>Interpolation<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>String<bpt i="2" x="2">&lt;w2&gt;</bpt>Interpolation<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Default<bpt i="4" x="4">&lt;w4&gt;</bpt>String<bpt i="5" x="5">&lt;w5&gt;</bpt>Interpolation<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Sub<bpt i="2" x="2">&lt;w2&gt;</bpt>Sequence<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is <bpt i="3" x="3">&lt;c3&gt;</bpt>Slice<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>&lt;<ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>Self<ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>&gt;<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt><ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>Sub<bpt i="2" x="2">&lt;w2&gt;</bpt>Sequence<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Slice<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>&lt;<ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>Self<ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>&gt;<ept i="6">&lt;/c6&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Bidirectional<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>Base<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>.<ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>Element<ept i="5">&lt;/c5&gt;</ept> conforms to <bpt i="6" x="6">&lt;c6&gt;</bpt>Bidirectional<bpt i="7" x="7">&lt;w7&gt;</bpt>Collection<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Bidirectional<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="3" x="3">&lt;c3&gt;</bpt>Base<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>.<ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>Element<ept i="5">&lt;/c5&gt;</ept>が<bpt i="6" x="6">&lt;c6&gt;</bpt>Bidirectional<bpt i="7" x="7">&lt;w7&gt;</bpt>Collection<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Collection<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Base<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Element<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Collection<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Collection<ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="2" x="2">&lt;c2&gt;</bpt>Base<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Element<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Collection<ept i="5">&lt;/c5&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Collection<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>Base<bpt i="3" x="3">&lt;w3&gt;</bpt>.Element<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="4" x="4">&lt;c4&gt;</bpt>Collection<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>Base<ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>.<ept i="6">&lt;/c6&gt;</ept><bpt i="7" x="7">&lt;c7&gt;</bpt>Index<ept i="7">&lt;/c7&gt;</ept> conforms to <bpt i="8" x="8">&lt;c8&gt;</bpt>Hashable<ept i="8">&lt;/c8&gt;</ept>, and <bpt i="9" x="9">&lt;c9&gt;</bpt>Base<ept i="9">&lt;/c9&gt;</ept><bpt i="10" x="10">&lt;c10&gt;</bpt>.<ept i="10">&lt;/c10&gt;</ept><bpt i="11" x="11">&lt;c11&gt;</bpt>Element<ept i="11">&lt;/c11&gt;</ept><bpt i="12" x="12">&lt;c12&gt;</bpt>.<ept i="12">&lt;/c12&gt;</ept><bpt i="13" x="13">&lt;c13&gt;</bpt>Index<ept i="13">&lt;/c13&gt;</ept> conforms to <bpt i="14" x="14">&lt;c14&gt;</bpt>Hashable<ept i="14">&lt;/c14&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Collection<ept i="1">&lt;/c1&gt;</ept>に準拠する、<bpt i="2" x="2">&lt;c2&gt;</bpt>Base<bpt i="3" x="3">&lt;w3&gt;</bpt>.Element<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt>Collection<ept i="4">&lt;/c4&gt;</ept>に準拠する、<bpt i="5" x="5">&lt;c5&gt;</bpt>Base<ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>.<ept i="6">&lt;/c6&gt;</ept><bpt i="7" x="7">&lt;c7&gt;</bpt>Index<ept i="7">&lt;/c7&gt;</ept>が<bpt i="8" x="8">&lt;c8&gt;</bpt>Hashable<ept i="8">&lt;/c8&gt;</ept>に準拠する、そして<bpt i="9" x="9">&lt;c9&gt;</bpt>Base<ept i="9">&lt;/c9&gt;</ept><bpt i="10" x="10">&lt;c10&gt;</bpt>.<ept i="10">&lt;/c10&gt;</ept><bpt i="11" x="11">&lt;c11&gt;</bpt>Element<ept i="11">&lt;/c11&gt;</ept><bpt i="12" x="12">&lt;c12&gt;</bpt>.<ept i="12">&lt;/c12&gt;</ept><bpt i="13" x="13">&lt;c13&gt;</bpt>Index<ept i="13">&lt;/c13&gt;</ept>が<bpt i="14" x="14">&lt;c14&gt;</bpt>Hashable<ept i="14">&lt;/c14&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Comparable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Comparable<ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Sequence<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Sequence<ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>String<bpt i="4" x="4">&lt;w4&gt;</bpt>Protocol<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>String<bpt i="4" x="4">&lt;w4&gt;</bpt>Protocol<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Element<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Comparable<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Element<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Comparable<ept i="5">&lt;/c5&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Element<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Equatable<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Element<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Equatable<ept i="5">&lt;/c5&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Element<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Sequence<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Element<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Sequence<ept i="5">&lt;/c5&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Element<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>String<bpt i="6" x="6">&lt;w6&gt;</bpt>Protocol<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Element<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>String<bpt i="6" x="6">&lt;w6&gt;</bpt>Protocol<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>Bound<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Strideable<ept i="3">&lt;/c3&gt;</ept>, and <bpt i="4" x="4">&lt;c4&gt;</bpt>Bound<ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>.<ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>Stride<ept i="6">&lt;/c6&gt;</ept> conforms to <bpt i="7" x="7">&lt;c7&gt;</bpt>Signed<bpt i="8" x="8">&lt;w8&gt;</bpt>Integer<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠する、<bpt i="2" x="2">&lt;c2&gt;</bpt>Bound<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Strideable<ept i="3">&lt;/c3&gt;</ept>に準拠する、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>Bound<ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>.<ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>Stride<ept i="6">&lt;/c6&gt;</ept>が<bpt i="7" x="7">&lt;c7&gt;</bpt>Signed<bpt i="8" x="8">&lt;w8&gt;</bpt>Integer<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>Bound<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Strideable<ept i="3">&lt;/c3&gt;</ept>, and <bpt i="4" x="4">&lt;c4&gt;</bpt>Bound<bpt i="5" x="5">&lt;w5&gt;</bpt>.Stride<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="6" x="6">&lt;c6&gt;</bpt>Signed<bpt i="7" x="7">&lt;w7&gt;</bpt>Integer<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>に準拠する、<bpt i="2" x="2">&lt;c2&gt;</bpt>Bound<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Strideable<ept i="3">&lt;/c3&gt;</ept>に準拠する、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>Bound<bpt i="5" x="5">&lt;w5&gt;</bpt>.Stride<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>が<bpt i="6" x="6">&lt;c6&gt;</bpt>Signed<bpt i="7" x="7">&lt;w7&gt;</bpt>Integer<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Sequence<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>Bound<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Strideable<ept i="3">&lt;/c3&gt;</ept>, and <bpt i="4" x="4">&lt;c4&gt;</bpt>Bound<ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>.<ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>Stride<ept i="6">&lt;/c6&gt;</ept> conforms to <bpt i="7" x="7">&lt;c7&gt;</bpt>Signed<bpt i="8" x="8">&lt;w8&gt;</bpt>Integer<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Sequence<ept i="1">&lt;/c1&gt;</ept>に準拠する、<bpt i="2" x="2">&lt;c2&gt;</bpt>Bound<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Strideable<ept i="3">&lt;/c3&gt;</ept>に準拠する、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>Bound<ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>.<ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>Stride<ept i="6">&lt;/c6&gt;</ept>が<bpt i="7" x="7">&lt;c7&gt;</bpt>Signed<bpt i="8" x="8">&lt;w8&gt;</bpt>Integer<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Strideable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Bound<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Stride<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Signed<bpt i="6" x="6">&lt;w6&gt;</bpt>Integer<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Strideable<ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="2" x="2">&lt;c2&gt;</bpt>Bound<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Stride<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Signed<bpt i="6" x="6">&lt;w6&gt;</bpt>Integer<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>String<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>Bound<ept i="3">&lt;/c3&gt;</ept> conforms to <bpt i="4" x="4">&lt;c4&gt;</bpt>Strideable<ept i="4">&lt;/c4&gt;</ept>, and <bpt i="5" x="5">&lt;c5&gt;</bpt>Bound<ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>.<ept i="6">&lt;/c6&gt;</ept><bpt i="7" x="7">&lt;c7&gt;</bpt>Stride<ept i="7">&lt;/c7&gt;</ept> conforms to <bpt i="8" x="8">&lt;c8&gt;</bpt>Signed<bpt i="9" x="9">&lt;w9&gt;</bpt>Integer<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>String<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する、<bpt i="3" x="3">&lt;c3&gt;</bpt>Bound<ept i="3">&lt;/c3&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt>Strideable<ept i="4">&lt;/c4&gt;</ept>に準拠する、そして<bpt i="5" x="5">&lt;c5&gt;</bpt>Bound<ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>.<ept i="6">&lt;/c6&gt;</ept><bpt i="7" x="7">&lt;c7&gt;</bpt>Stride<ept i="7">&lt;/c7&gt;</ept>が<bpt i="8" x="8">&lt;c8&gt;</bpt>Signed<bpt i="9" x="9">&lt;w9&gt;</bpt>Integer<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>Bound<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Strideable<ept i="3">&lt;/c3&gt;</ept>, and <bpt i="4" x="4">&lt;c4&gt;</bpt>Bound<ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>.<ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>Stride<ept i="6">&lt;/c6&gt;</ept> conforms to <bpt i="7" x="7">&lt;c7&gt;</bpt>Signed<bpt i="8" x="8">&lt;w8&gt;</bpt>Integer<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>である、<bpt i="2" x="2">&lt;c2&gt;</bpt>Bound<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Strideable<ept i="3">&lt;/c3&gt;</ept>に準拠する、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>Bound<ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>.<ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>Stride<ept i="6">&lt;/c6&gt;</ept>が<bpt i="7" x="7">&lt;c7&gt;</bpt>Signed<bpt i="8" x="8">&lt;w8&gt;</bpt>Integer<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Change<bpt i="1" x="1">&lt;w1&gt;</bpt>Element<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt>Decodable<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>Encodable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Change<bpt i="1" x="1">&lt;w1&gt;</bpt>Element<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Decodable<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>Encodable<ept i="3">&lt;/c3&gt;</ept>に準拠する場合に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Change<bpt i="1" x="1">&lt;w1&gt;</bpt>Element<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt>Equatable<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Change<bpt i="1" x="1">&lt;w1&gt;</bpt>Element<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Equatable<ept i="2">&lt;/c2&gt;</ept>に準拠する場合に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Change<bpt i="1" x="1">&lt;w1&gt;</bpt>Element<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt>Hashable<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Change<bpt i="1" x="1">&lt;w1&gt;</bpt>Element<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Hashable<ept i="2">&lt;/c2&gt;</ept>に準拠する場合に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<bpt i="2" x="2">&lt;w2&gt;</bpt>With<bpt i="3" x="3">&lt;w3&gt;</bpt>Configuration<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<bpt i="2" x="2">&lt;w2&gt;</bpt>With<bpt i="3" x="3">&lt;w3&gt;</bpt>Configuration<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<bpt i="2" x="2">&lt;w2&gt;</bpt>With<bpt i="3" x="3">&lt;w3&gt;</bpt>Configuration<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<bpt i="2" x="2">&lt;w2&gt;</bpt>With<bpt i="3" x="3">&lt;w3&gt;</bpt>Configuration<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<bpt i="3" x="3">&lt;w3&gt;</bpt>Convertible<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<bpt i="3" x="3">&lt;w3&gt;</bpt>Convertible<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Sequence<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Sequence<ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>String<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>String<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>Float<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Float<ept i="1">&lt;/c1&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>UInt8<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>UInt8<ept i="1">&lt;/c1&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<bpt i="1" x="1">&lt;w1&gt;</bpt>Of<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Comparable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<bpt i="1" x="1">&lt;w1&gt;</bpt>Of<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Comparable<ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<bpt i="1" x="1">&lt;w1&gt;</bpt>Of<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<bpt i="1" x="1">&lt;w1&gt;</bpt>Of<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Elements<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Bidirectional<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Elements<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Bidirectional<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Elements<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Comparable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Elements<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Comparable<ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Elements<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Elements<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Elements<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Sequence<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Elements<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Sequence<ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Elements<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>String<bpt i="4" x="4">&lt;w4&gt;</bpt>Protocol<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Elements<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Element<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>String<bpt i="4" x="4">&lt;w4&gt;</bpt>Protocol<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Elements<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Index<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Comparable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Elements<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Index<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Comparable<ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Elements<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Index<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>Elements<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Bidirectional<bpt i="6" x="6">&lt;w6&gt;</bpt>Collection<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Elements<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Index<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>に準拠するそして<bpt i="4" x="4">&lt;c4&gt;</bpt>Elements<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Bidirectional<bpt i="6" x="6">&lt;w6&gt;</bpt>Collection<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Elements<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Index<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Elements<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Index<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Elements<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Index<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Sequence<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Elements<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Index<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Sequence<ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Elements<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Index<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>String<bpt i="4" x="4">&lt;w4&gt;</bpt>Protocol<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Elements<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Index<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>String<bpt i="4" x="4">&lt;w4&gt;</bpt>Protocol<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Elements<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Index<ept i="2">&lt;/c2&gt;</ept> is <bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>Elements<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Bidirectional<bpt i="6" x="6">&lt;w6&gt;</bpt>Collection<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Elements<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>.<ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Index<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>であるそして<bpt i="4" x="4">&lt;c4&gt;</bpt>Elements<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Bidirectional<bpt i="6" x="6">&lt;w6&gt;</bpt>Collection<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Flatten<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<it pos="begin" x="2">&lt;Base&gt;.Iterator&lt;w2&gt;</it>.Element<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Comparable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Flatten<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<it pos="begin" x="2">&lt;Base&gt;.Iterator&lt;w2&gt;</it>.Element<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Comparable<ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Flatten<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<it pos="begin" x="2">&lt;Base&gt;.Iterator&lt;w2&gt;</it>.Element<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>Base<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Bidirectional<bpt i="6" x="6">&lt;w6&gt;</bpt>Collection<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, and <bpt i="7" x="7">&lt;c7&gt;</bpt>Base<ept i="7">&lt;/c7&gt;</ept><bpt i="8" x="8">&lt;c8&gt;</bpt>.<ept i="8">&lt;/c8&gt;</ept><bpt i="9" x="9">&lt;c9&gt;</bpt>Element<ept i="9">&lt;/c9&gt;</ept> conforms to <bpt i="10" x="10">&lt;c10&gt;</bpt>Bidirectional<bpt i="11" x="11">&lt;w11&gt;</bpt>Collection<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Flatten<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<it pos="begin" x="2">&lt;Base&gt;.Iterator&lt;w2&gt;</it>.Element<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>に準拠するそして<bpt i="4" x="4">&lt;c4&gt;</bpt>Base<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Bidirectional<bpt i="6" x="6">&lt;w6&gt;</bpt>Collection<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>に準拠する、そして<bpt i="7" x="7">&lt;c7&gt;</bpt>Base<ept i="7">&lt;/c7&gt;</ept><bpt i="8" x="8">&lt;c8&gt;</bpt>.<ept i="8">&lt;/c8&gt;</ept><bpt i="9" x="9">&lt;c9&gt;</bpt>Element<ept i="9">&lt;/c9&gt;</ept>が<bpt i="10" x="10">&lt;c10&gt;</bpt>Bidirectional<bpt i="11" x="11">&lt;w11&gt;</bpt>Collection<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Flatten<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<it pos="begin" x="2">&lt;Base&gt;.Iterator&lt;w2&gt;</it>.Element<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>Base<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Collection<ept i="5">&lt;/c5&gt;</ept>, and <bpt i="6" x="6">&lt;c6&gt;</bpt>Base<ept i="6">&lt;/c6&gt;</ept><bpt i="7" x="7">&lt;c7&gt;</bpt>.<ept i="7">&lt;/c7&gt;</ept><bpt i="8" x="8">&lt;c8&gt;</bpt>Element<ept i="8">&lt;/c8&gt;</ept> conforms to <bpt i="9" x="9">&lt;c9&gt;</bpt>Collection<ept i="9">&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Flatten<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<it pos="begin" x="2">&lt;Base&gt;.Iterator&lt;w2&gt;</it>.Element<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>に準拠する、<bpt i="4" x="4">&lt;c4&gt;</bpt>Base<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Collection<ept i="5">&lt;/c5&gt;</ept>に準拠する、そして<bpt i="6" x="6">&lt;c6&gt;</bpt>Base<ept i="6">&lt;/c6&gt;</ept><bpt i="7" x="7">&lt;c7&gt;</bpt>.<ept i="7">&lt;/c7&gt;</ept><bpt i="8" x="8">&lt;c8&gt;</bpt>Element<ept i="8">&lt;/c8&gt;</ept>が<bpt i="9" x="9">&lt;c9&gt;</bpt>Collection<ept i="9">&lt;/c9&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Flatten<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<it pos="begin" x="2">&lt;Base&gt;.Iterator&lt;w2&gt;</it>.Element<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Flatten<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<it pos="begin" x="2">&lt;Base&gt;.Iterator&lt;w2&gt;</it>.Element<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Flatten<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<it pos="begin" x="2">&lt;Base&gt;.Iterator&lt;w2&gt;</it>.Element<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Sequence<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Flatten<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<it pos="begin" x="2">&lt;Base&gt;.Iterator&lt;w2&gt;</it>.Element<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Sequence<ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Flatten<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<it pos="begin" x="2">&lt;Base&gt;.Iterator&lt;w2&gt;</it>.Element<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>String<bpt i="4" x="4">&lt;w4&gt;</bpt>Protocol<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Flatten<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<it pos="begin" x="2">&lt;Base&gt;.Iterator&lt;w2&gt;</it>.Element<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>String<bpt i="4" x="4">&lt;w4&gt;</bpt>Protocol<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Flatten<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<it pos="begin" x="2">&lt;Base&gt;.Iterator&lt;w2&gt;</it>.Element<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is <bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>Base<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Bidirectional<bpt i="6" x="6">&lt;w6&gt;</bpt>Collection<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, and <bpt i="7" x="7">&lt;c7&gt;</bpt>Base<ept i="7">&lt;/c7&gt;</ept><bpt i="8" x="8">&lt;c8&gt;</bpt>.<ept i="8">&lt;/c8&gt;</ept><bpt i="9" x="9">&lt;c9&gt;</bpt>Element<ept i="9">&lt;/c9&gt;</ept> conforms to <bpt i="10" x="10">&lt;c10&gt;</bpt>Bidirectional<bpt i="11" x="11">&lt;w11&gt;</bpt>Collection<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Flatten<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<it pos="begin" x="2">&lt;Base&gt;.Iterator&lt;w2&gt;</it>.Element<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>である、<bpt i="4" x="4">&lt;c4&gt;</bpt>Base<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Bidirectional<bpt i="6" x="6">&lt;w6&gt;</bpt>Collection<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>に準拠する、そして<bpt i="7" x="7">&lt;c7&gt;</bpt>Base<ept i="7">&lt;/c7&gt;</ept><bpt i="8" x="8">&lt;c8&gt;</bpt>.<ept i="8">&lt;/c8&gt;</ept><bpt i="9" x="9">&lt;c9&gt;</bpt>Element<ept i="9">&lt;/c9&gt;</ept>が<bpt i="10" x="10">&lt;c10&gt;</bpt>Bidirectional<bpt i="11" x="11">&lt;w11&gt;</bpt>Collection<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Key<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Key<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>に準拠する場合に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Key<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Value<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Decodable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Key<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="2" x="2">&lt;c2&gt;</bpt>Value<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Decodable<ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Key<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Value<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Encodable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Key<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="2" x="2">&lt;c2&gt;</bpt>Value<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Encodable<ept i="3">&lt;/c3&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Key<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Key<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Key<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<bpt i="3" x="3">&lt;w3&gt;</bpt>Convertible<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>Value<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>MLData<bpt i="6" x="6">&lt;w6&gt;</bpt>Value<bpt i="7" x="7">&lt;w7&gt;</bpt>Convertible<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Key<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<bpt i="3" x="3">&lt;w3&gt;</bpt>Convertible<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="4" x="4">&lt;c4&gt;</bpt>Value<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>MLData<bpt i="6" x="6">&lt;w6&gt;</bpt>Value<bpt i="7" x="7">&lt;w7&gt;</bpt>Convertible<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Key<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Sequence<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Key<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Sequence<ept i="1">&lt;/c1&gt;</ept>に準拠する場合に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Key<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>String<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Key<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>String<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Key<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>NSAttributed<bpt i="2" x="2">&lt;w2&gt;</bpt>String<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Key<ept i="4">&lt;/c4&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt>Value<ept i="5">&lt;/c5&gt;</ept> is <bpt i="6" x="6">&lt;c6&gt;</bpt>Any<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Key<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>NSAttributed<bpt i="2" x="2">&lt;w2&gt;</bpt>String<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Key<ept i="4">&lt;/c4&gt;</ept>であるそして<bpt i="5" x="5">&lt;c5&gt;</bpt>Value<ept i="5">&lt;/c5&gt;</ept>が<bpt i="6" x="6">&lt;c6&gt;</bpt>Any<ept i="6">&lt;/c6&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Segment<bpt i="1" x="1">&lt;w1&gt;</bpt>Of<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Element<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Comparable<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Segment<bpt i="1" x="1">&lt;w1&gt;</bpt>Of<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Element<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Comparable<ept i="5">&lt;/c5&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Segment<bpt i="1" x="1">&lt;w1&gt;</bpt>Of<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Element<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Equatable<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Segment<bpt i="1" x="1">&lt;w1&gt;</bpt>Of<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Element<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Equatable<ept i="5">&lt;/c5&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Any<bpt i="2" x="2">&lt;w2&gt;</bpt>Object<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Any<bpt i="2" x="2">&lt;w2&gt;</bpt>Object<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Expressible<bpt i="2" x="2">&lt;w2&gt;</bpt>By<bpt i="3" x="3">&lt;w3&gt;</bpt>Integer<bpt i="4" x="4">&lt;w4&gt;</bpt>Literal<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Expressible<bpt i="2" x="2">&lt;w2&gt;</bpt>By<bpt i="3" x="3">&lt;w3&gt;</bpt>Integer<bpt i="4" x="4">&lt;w4&gt;</bpt>Literal<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する場合に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Fixed<bpt i="2" x="2">&lt;w2&gt;</bpt>Width<bpt i="3" x="3">&lt;w3&gt;</bpt>Integer<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Fixed<bpt i="2" x="2">&lt;w2&gt;</bpt>Width<bpt i="3" x="3">&lt;w3&gt;</bpt>Integer<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>_Expressible<bpt i="2" x="2">&lt;w2&gt;</bpt>By<bpt i="3" x="3">&lt;w3&gt;</bpt>Builtin<bpt i="4" x="4">&lt;w4&gt;</bpt>Integer<bpt i="5" x="5">&lt;w5&gt;</bpt>Literal<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>_Expressible<bpt i="2" x="2">&lt;w2&gt;</bpt>By<bpt i="3" x="3">&lt;w3&gt;</bpt>Builtin<bpt i="4" x="4">&lt;w4&gt;</bpt>Integer<bpt i="5" x="5">&lt;w5&gt;</bpt>Literal<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt><ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Sub<bpt i="3" x="3">&lt;w3&gt;</bpt>Sequence<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt><ept i="1">&lt;/c1&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>Sub<bpt i="3" x="3">&lt;w3&gt;</bpt>Sequence<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>Any<bpt i="2" x="2">&lt;w2&gt;</bpt>Key<bpt i="3" x="3">&lt;w3&gt;</bpt>Path<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Self<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Any<bpt i="2" x="2">&lt;w2&gt;</bpt>Key<bpt i="3" x="3">&lt;w3&gt;</bpt>Path<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Success<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>Never<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Failure<ept i="2">&lt;/c2&gt;</ept> is <bpt i="3" x="3">&lt;c3&gt;</bpt>Never<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Success<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Never<ept i="1">&lt;/c1&gt;</ept>であるそして<bpt i="2" x="2">&lt;c2&gt;</bpt>Failure<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Never<ept i="3">&lt;/c3&gt;</ept>である時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Transformed<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Transformed<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>に準拠する場合に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Transformed<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Transformed<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Value<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Value<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>に準拠する場合に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Value<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Value<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Value<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Value<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Value<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Sequence<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Value<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Sequence<ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Available when <bpt i="0" x="0">&lt;c0&gt;</bpt>Value<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>String<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Value<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>String<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Basic Arithmetic</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>基本算術</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Basic Behaviors</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>基本の挙動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Basic Values</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>基本的な値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because <bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept> is the default type for an array literal, without writing any other code, you can declare an array with a particular element type by providing one or more values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept>は配列リテラルのための省略時の型なので、なんら他のコードを書くことなく、あなたはひとつ以上の値を提供することによって特定の要素型を持つ配列を宣言できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because <bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<bpt i="1" x="1">&lt;w1&gt;</bpt>Of<bpt i="2" x="2">&lt;w2&gt;</bpt>Two<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> doesn’t define its own <bpt i="3" x="3">&lt;c3&gt;</bpt>make<bpt i="4" x="4">&lt;w4&gt;</bpt>Iterator()<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> method or <bpt i="5" x="5">&lt;c5&gt;</bpt>Iterator<ept i="5">&lt;/c5&gt;</ept> associated type, it uses the default iterator type, <bpt i="6" x="6">&lt;c6&gt;</bpt>Indexing<bpt i="7" x="7">&lt;w7&gt;</bpt>Iterator<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<bpt i="1" x="1">&lt;w1&gt;</bpt>Of<bpt i="2" x="2">&lt;w2&gt;</bpt>Two<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は独自の<bpt i="3" x="3">&lt;c3&gt;</bpt>make<bpt i="4" x="4">&lt;w4&gt;</bpt>Iterator()<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>メソッドまたは<bpt i="5" x="5">&lt;c5&gt;</bpt>Iterator<ept i="5">&lt;/c5&gt;</ept>関連型を定義しないことから、それは省略時のイテレータ型、<bpt i="6" x="6">&lt;c6&gt;</bpt>Indexing<bpt i="7" x="7">&lt;w7&gt;</bpt>Iterator<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because <bpt i="0" x="0">&lt;c0&gt;</bpt>Integer<bpt i="1" x="1">&lt;w1&gt;</bpt>Ref<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is a class, its instances can be compared using the identical-to operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>===<ept i="2">&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Integer<bpt i="1" x="1">&lt;w1&gt;</bpt>Ref<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>がクラスであるので、それのインスタンスは同一性演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>===<ept i="2">&lt;/c2&gt;</ept>）を使って比較されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because Cocoa methods with errors parameters are imported as throwing methods, you handle them using Swift's <bpt i="0" x="0">&lt;c0&gt;</bpt>do<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>エラーパラメータを持つCocoaメソッドはスローメソッドとしてインポートされることから、あなたはそれらをSwiftの<bpt i="0" x="0">&lt;c0&gt;</bpt>do<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept>文で処理できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because NaN compares not less than nor greater than any value, this method returns <bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept> when called on NaN or when NaN is passed as <bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>NaNはあらゆる値より少なくもないし大きくもないと比較されるので、このメソッドは、NaN上で呼ばれた時またはNaNが<bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>として渡された時に<bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because NaN is incomparable with any value, this method returns <bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept> when called on NaN or when NaN is passed as <bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>NaNはあらゆる値と比較可能でないので、このメソッドは、NaN上で呼ばれた時またはNaNが<bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>として渡された時に<bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because NaN is not equal to any value, including NaN, use this property instead of the equal-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept>) or not-equal-to operator (<bpt i="1" x="1">&lt;c1&gt;</bpt>!=<ept i="1">&lt;/c1&gt;</ept>) to test whether a value is or is not NaN.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>NaNは、NaNを含めてあらゆる値と等しくないので、同等演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept>）または不等演算子（<bpt i="1" x="1">&lt;c1&gt;</bpt>!=<ept i="1">&lt;/c1&gt;</ept>）の代わりにこのプロパティを使うことで、ある値がNaNであるのかまたはないのかをテストしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because Swift can’t guarantee at compile time that these methods and properties are actually available on an <bpt i="4" x="4">&lt;c4&gt;</bpt>Any<bpt i="5" x="5">&lt;w5&gt;</bpt>Object<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> instance’s underlying type, these <bpt i="6" x="6">&lt;c6&gt;</bpt>@objc<ept i="6">&lt;/c6&gt;</ept> symbols are available as implicitly unwrapped optional methods and properties, respectively.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftはそれらのメソッドやプロパティが<bpt i="4" x="4">&lt;c4&gt;</bpt>Any<bpt i="5" x="5">&lt;w5&gt;</bpt>Object<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>インスタンスの下に横たわる型で実際に利用可能であるとコンパイル時に保証しないため、これら<bpt i="6" x="6">&lt;c6&gt;</bpt>@objc<ept i="6">&lt;/c6&gt;</ept>シンボルは暗黙的にアンラップされるオプショナルのメソッドやプロパティとしてそれぞれ利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because a NaN always compares not equal to itself, to test whether a floating-point value is NaN, use its <bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Na<bpt i="2" x="2">&lt;w2&gt;</bpt>N<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property instead of the equal-to operator (<bpt i="3" x="3">&lt;c3&gt;</bpt>==<ept i="3">&lt;/c3&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>NaNは常にそれ自身に対して等しくないと比較されることから、浮動小数点値がNaNかどうかテストするには、それの<bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Na<bpt i="2" x="2">&lt;w2&gt;</bpt>N<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティを同等演算子（<bpt i="3" x="3">&lt;c3&gt;</bpt>==<ept i="3">&lt;/c3&gt;</ept>）の代わりに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because a closed range cannot represent an empty range, this property is always <bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>完結範囲は空の範囲を表すことができないので、このプロパティは常に<bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because a closed range includes its upper bound, a closed range whose lower bound is equal to the upper bound contains that value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>完結範囲はそれの上側の境界を含むことから、それの下側の境界が上側の境界と等しい完結範囲はその値を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because a closed range includes its upper bound, the ranges in the following example also overlap:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>完結範囲はそれの上方の境界を含むことから、以下の例の範囲もまた重なります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because any arbitrary subclass of <bpt i="4" x="4">&lt;c4&gt;</bpt>NSArray<ept i="4">&lt;/c4&gt;</ept> can become an <bpt i="5" x="5">&lt;c5&gt;</bpt>Array<ept i="5">&lt;/c5&gt;</ept>, there are no guarantees about representation or efficiency in this case.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>何であれ随意の<bpt i="4" x="4">&lt;c4&gt;</bpt>NSArray<ept i="4">&lt;/c4&gt;</ept>のサブクラスが<bpt i="5" x="5">&lt;c5&gt;</bpt>Array<ept i="5">&lt;/c5&gt;</ept>になることが可能であるので、表現や効率についてはこの場合保証されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because arrays increase their allocated capacity using an exponential strategy, appending a single element to an array is an O(1) operation when averaged over many calls to the <bpt i="0" x="0">&lt;c0&gt;</bpt>append(_:)<ept i="0">&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列はそれらの割り当てられた容量を指数戦略で増やすので、ある単一の要素を配列に加えることは、<bpt i="0" x="0">&lt;c0&gt;</bpt>append(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドへの多くの呼び出しにわたって平均した場合は、O(1)演算です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because both Swift methods have the same behavior, they share the same page in the documentation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>両方のSwiftメソッドは同じ挙動を持つことから、それらは文書化において同じページを共有します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because both types have the same interface, you can replace one with the other in most circumstances, without making other changes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>両方の型は同じインターフェイスを持つため、あなたは多くの状況で一方を他方で置き換えることが、他の変更をすることなく可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because calculating the average of the observations involves combining every value of the <bpt i="0" x="0">&lt;c0&gt;</bpt>temps<bpt i="1" x="1">&lt;w1&gt;</bpt>Fahrenheit<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> array, any NaN values cause the result to also be NaN, as seen in this example:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>観測の平均の算出は<bpt i="0" x="0">&lt;c0&gt;</bpt>temps<bpt i="1" x="1">&lt;w1&gt;</bpt>Fahrenheit<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>配列のすべての値を足し合わせることを必然的に含むことから、何らかのNaN値はまたNaNになるという結果を引き起こします、この例で見られるように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because case conversion can result in multiple characters, the result of <bpt i="0" x="0">&lt;c0&gt;</bpt>lowercased()<ept i="0">&lt;/c0&gt;</ept> is a string.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ケース変換が複数の文字という結果になり得ることから、<bpt i="0" x="0">&lt;c0&gt;</bpt>lowercased()<ept i="0">&lt;/c0&gt;</ept>の結果はある文字列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because case conversion can result in multiple characters, the result of <bpt i="0" x="0">&lt;c0&gt;</bpt>uppercased()<ept i="0">&lt;/c0&gt;</ept> is a string.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ケース変換が複数の文字という結果になり得ることから、<bpt i="0" x="0">&lt;c0&gt;</bpt>uppercased()<ept i="0">&lt;/c0&gt;</ept>の結果はある文字列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because default implementations of the remainder of the relational operators are provided by the standard library, you’ll be able to use <bpt i="6" x="6">&lt;c6&gt;</bpt>!=<ept i="6">&lt;/c6&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt>&gt;<ept i="7">&lt;/c7&gt;</ept>, <bpt i="8" x="8">&lt;c8&gt;</bpt>&lt;=<ept i="8">&lt;/c8&gt;</ept>, and <bpt i="9" x="9">&lt;c9&gt;</bpt>&gt;=<ept i="9">&lt;/c9&gt;</ept> with instances of your type without any further code.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>関係演算子の残りの省略時の実装は標準ライブラリによって提供されることから、あなたは<bpt i="6" x="6">&lt;c6&gt;</bpt>!=<ept i="6">&lt;/c6&gt;</ept>、<bpt i="7" x="7">&lt;c7&gt;</bpt>&gt;<ept i="7">&lt;/c7&gt;</ept>、<bpt i="8" x="8">&lt;c8&gt;</bpt>&lt;=<ept i="8">&lt;/c8&gt;</ept>、そして<bpt i="9" x="9">&lt;c9&gt;</bpt>&gt;=<ept i="9">&lt;/c9&gt;</ept>をあなたの型のインスタンスにおいてなんらこれ以上のコード無しに使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because each character in a string can be made up of one or more Unicode scalar values, the number of characters in a string may not match the length of the Unicode scalar value representation or the length of the string in a particular binary representation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>文字列中の各文字はひとつ以上のユニコードスカラー値から成り立つので、ある文字列の文字数はユニコードスカラー値表現の長さ、または特定のバイナリ表現での文字列の長さと一致しないかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because floating-point types such as <bpt i="0" x="0">&lt;c0&gt;</bpt>Float<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept> are their own <bpt i="2" x="2">&lt;c2&gt;</bpt>Stride<ept i="2">&lt;/c2&gt;</ept> types, they cannot be used as the bounds of a countable range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>浮動小数点型、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>Float<ept i="0">&lt;/c0&gt;</ept>および<bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept>は、それら独自の<bpt i="2" x="2">&lt;c2&gt;</bpt>Stride<ept i="2">&lt;/c2&gt;</ept>型であるので、それらは可付番範囲の境界として使われることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because many functions and initializers fully specify the types of their parameters, you can often use an array literal with or without elements as a parameter.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>多くの関数とイニシャライザはそれらのパラメータの型を完全に指定することから、あなたはしばしば要素のあるまたはない配列リテラルをパラメータとして使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because structures are value types—unlike classes—local changes to a structure aren't visible to the rest of your app unless you intentionally communicate those changes as part of the flow of your app.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>構造体が値型であることから — クラスとは違い — 構造体への局所的変更はあなたのアプリの残りには不可視です、あなたが意図的にそれら変更をあなたのアプリのフローの一部として伝達しない限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because testing whether one NaN is equal to another NaN results in <bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>, use the <bpt i="1" x="1">&lt;c1&gt;</bpt>is<bpt i="2" x="2">&lt;w2&gt;</bpt>Na<bpt i="3" x="3">&lt;w3&gt;</bpt>N<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> property to test whether a value is NaN.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるNaNが別のNaNと等しいかどうかテストすることは<bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>の結果になることから、<bpt i="1" x="1">&lt;c1&gt;</bpt>is<bpt i="2" x="2">&lt;w2&gt;</bpt>Na<bpt i="3" x="3">&lt;w3&gt;</bpt>N<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>プロパティを使うことである値がNaNかどうかテストしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because the <bpt i="0" x="0">&lt;c0&gt;</bpt>Grid<bpt i="1" x="1">&lt;w1&gt;</bpt>Point<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type is not hashable yet, it can’t be used in a set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Grid<bpt i="1" x="1">&lt;w1&gt;</bpt>Point<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型はまだハッシュ可能でないことから、それは集合において使用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because the <bpt i="0" x="0">&lt;c0&gt;</bpt>String(reflecting:)<ept i="0">&lt;/c0&gt;</ept> initializer works for instances of <bpt i="1" x="1">&lt;e1&gt;</bpt>any<ept i="1">&lt;/e1&gt;</ept> type, returning an instance’s <bpt i="2" x="2">&lt;c2&gt;</bpt>debug<bpt i="3" x="3">&lt;w3&gt;</bpt>Description<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> if the value passed conforms to <bpt i="4" x="4">&lt;c4&gt;</bpt>Custom<bpt i="5" x="5">&lt;w5&gt;</bpt>Debug<bpt i="6" x="6">&lt;w6&gt;</bpt>String<bpt i="7" x="7">&lt;w7&gt;</bpt>Convertible<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, accessing a type’s <bpt i="8" x="8">&lt;c8&gt;</bpt>debug<bpt i="9" x="9">&lt;w9&gt;</bpt>Description<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> property directly or using <bpt i="10" x="10">&lt;c10&gt;</bpt>Custom<bpt i="11" x="11">&lt;w11&gt;</bpt>Debug<bpt i="12" x="12">&lt;w12&gt;</bpt>String<bpt i="13" x="13">&lt;w13&gt;</bpt>Convertible<ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> as a generic constraint is discouraged.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>String(reflecting:)<ept i="0">&lt;/c0&gt;</ept>イニシャライザが<bpt i="1" x="1">&lt;e1&gt;</bpt>あらゆる<ept i="1">&lt;/e1&gt;</ept>型のインスタンスに対して働いて、渡される値が<bpt i="2" x="2">&lt;c2&gt;</bpt>debug<bpt i="3" x="3">&lt;w3&gt;</bpt>Description<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に準拠するならばインスタンスの<bpt i="4" x="4">&lt;c4&gt;</bpt>Custom<bpt i="5" x="5">&lt;w5&gt;</bpt>Debug<bpt i="6" x="6">&lt;w6&gt;</bpt>String<bpt i="7" x="7">&lt;w7&gt;</bpt>Convertible<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を返すので、ある型のもつ<bpt i="8" x="8">&lt;c8&gt;</bpt>debug<bpt i="9" x="9">&lt;w9&gt;</bpt>Description<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>プロパティに直にアクセスすることや、総称体制約として<bpt i="10" x="10">&lt;c10&gt;</bpt>Custom<bpt i="11" x="11">&lt;w11&gt;</bpt>Debug<bpt i="12" x="12">&lt;w12&gt;</bpt>String<bpt i="13" x="13">&lt;w13&gt;</bpt>Convertible<ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>を使うことは推奨されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because the <bpt i="1" x="1">&lt;c1&gt;</bpt>Cake<ept i="1">&lt;/c1&gt;</ept> structure has fields with unnamed types, you use the <bpt i="2" x="2">&lt;c2&gt;</bpt>.init<ept i="2">&lt;/c2&gt;</ept> initializers (allowed due to Swift's type inference) to set the initial value for each of the structure’s unnamed fields.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Cake<ept i="1">&lt;/c1&gt;</ept>構造体は無名型でのフィールドを持つことから、あなたは<bpt i="2" x="2">&lt;c2&gt;</bpt>.init<ept i="2">&lt;/c2&gt;</ept>イニシャライザ（Swiftの持つ型推論によって与えられるもの）を使用して、初期値をその構造体の持つ無名フィールドの各々に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because the <bpt i="1" x="1">&lt;c1&gt;</bpt>Error<ept i="1">&lt;/c1&gt;</ept> protocol has no requirements of its own, you can declare conformance on any custom type you create.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Error<ept i="1">&lt;/c1&gt;</ept>プロトコルはそれ自身の要件を持たないので、あなたは準拠を宣言することがあなたが作成するあらゆるあつらえの型で可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because the <bpt i="2" x="2">&lt;c2&gt;</bpt>hypotenuse(_:<bpt i="3" x="3">&lt;w3&gt;</bpt>_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> function uses a generic parameter constrained to the <bpt i="4" x="4">&lt;c4&gt;</bpt>Floating<bpt i="5" x="5">&lt;w5&gt;</bpt>Point<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> protocol, you can call it using any floating-point type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>hypotenuse(_:<bpt i="3" x="3">&lt;w3&gt;</bpt>_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>関数は<bpt i="4" x="4">&lt;c4&gt;</bpt>Floating<bpt i="5" x="5">&lt;w5&gt;</bpt>Point<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>プロトコルに制約された総称体パラメータを使うので、あなたはそれを呼び出すことがあらゆる浮動小数点型を使って行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because the <bpt i="2" x="2">&lt;c2&gt;</bpt>my<bpt i="3" x="3">&lt;w3&gt;</bpt>ID<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> property is declared as a constant, it can't change locally.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>なぜなら<bpt i="2" x="2">&lt;c2&gt;</bpt>my<bpt i="3" x="3">&lt;w3&gt;</bpt>ID<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロパティは定数として宣言されるからです、それはローカルに変更できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because the <bpt i="3" x="3">&lt;c3&gt;</bpt>Pen<bpt i="4" x="4">&lt;w4&gt;</bpt>Pal<bpt i="5" x="5">&lt;w5&gt;</bpt>Record<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> structure doesn't control the identity of the underlying database records, there's no risk that the changes made to local <bpt i="6" x="6">&lt;c6&gt;</bpt>Pen<bpt i="7" x="7">&lt;w7&gt;</bpt>Pal<bpt i="8" x="8">&lt;w8&gt;</bpt>Record<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> instances accidentally change values in the database.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>Pen<bpt i="4" x="4">&lt;w4&gt;</bpt>Pal<bpt i="5" x="5">&lt;w5&gt;</bpt>Record<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>構造体が基礎をなすデータベースレコードの同一性を制御しないことから、ローカルの<bpt i="6" x="6">&lt;c6&gt;</bpt>Pen<bpt i="7" x="7">&lt;w7&gt;</bpt>Pal<bpt i="8" x="8">&lt;w8&gt;</bpt>Record<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>インスタンスになされる変更が誤って値をデータベースにおいて変更する危険はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because the <bpt i="4" x="4">&lt;c4&gt;</bpt>Int8<ept i="4">&lt;/c4&gt;</ept> type can represent <bpt i="5" x="5">&lt;c5&gt;</bpt>127<ept i="5">&lt;/c5&gt;</ept> at maximum, the attempt to create <bpt i="6" x="6">&lt;c6&gt;</bpt>z<ept i="6">&lt;/c6&gt;</ept> with a value of <bpt i="7" x="7">&lt;c7&gt;</bpt>1000<ept i="7">&lt;/c7&gt;</ept> results in a runtime error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>Int8<ept i="4">&lt;/c4&gt;</ept>型は、最大で<bpt i="5" x="5">&lt;c5&gt;</bpt>127<ept i="5">&lt;/c5&gt;</ept>を表せることから、<bpt i="6" x="6">&lt;c6&gt;</bpt>z<ept i="6">&lt;/c6&gt;</ept>を<bpt i="7" x="7">&lt;c7&gt;</bpt>1000<ept i="7">&lt;/c7&gt;</ept>の値で作成する試みは、実行時エラーという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because the first field of the <bpt i="0" x="0">&lt;c0&gt;</bpt>Cake<ept i="0">&lt;/c0&gt;</ept> structure is unnamed, its initializer’s first parameter doesn't have a label.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Cake<ept i="0">&lt;/c0&gt;</ept>構造体の最初のフィールドが無名であるため、それのイニシャライザの持つ最初のパラメータはラベルを持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because the generated header is part of the framework’s public interface, only declarations marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>public<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>open<ept i="1">&lt;/c1&gt;</ept> modifier appear in the generated header for a framework target.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>生成されたヘッダがフレームワークのパブリックインターフェイスの一部であることから、<bpt i="0" x="0">&lt;c0&gt;</bpt>public<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>open<ept i="1">&lt;/c1&gt;</ept>修飾子で印された宣言だけがフレームワークターゲットに対する生成ヘッダに現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because the predicate throws when it receives <bpt i="7" x="7">&lt;c7&gt;</bpt>2<ept i="7">&lt;/c7&gt;</ept> from the base sequence, this example throws without ever printing anything.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>述部はそれが<bpt i="7" x="7">&lt;c7&gt;</bpt>2<ept i="7">&lt;/c7&gt;</ept>を基底シーケンスから受け取る時にスローすることから、この例は決して何かを印字することなくスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because the quotient is representable as an <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>, the division succeeds.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>商が<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>として表現可能であることから、除算は成功します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because the result of this nil-coalescing operation is itself an optional value, you can chain default values by using <bpt i="0" x="0">&lt;c0&gt;</bpt>??<ept i="0">&lt;/c0&gt;</ept> multiple times.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このnil合体演算の結果がそれ自体オプショナル値であることから、あなたは幾らかの省略時の値を<bpt i="0" x="0">&lt;c0&gt;</bpt>??<ept i="0">&lt;/c0&gt;</ept>を複数回使うことで連鎖することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because the tasks you add to a group with this method are nonthrowing, those tasks can’t respond to cancellation by throwing <bpt i="0" x="0">&lt;c0&gt;</bpt>Cancellation<bpt i="1" x="1">&lt;w1&gt;</bpt>Error<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがグループにこのメソッドで加えるタスクはスローしないことから、それらタスクは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Cancellation<bpt i="1" x="1">&lt;w1&gt;</bpt>Error<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をスローすることによって取り消しに応答できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because there is no key for <bpt i="11" x="11">&lt;c11&gt;</bpt>4<ept i="11">&lt;/c11&gt;</ept>, the closure returns <bpt i="12" x="12">&lt;c12&gt;</bpt>nil<ept i="12">&lt;/c12&gt;</ept> in this case, which <bpt i="13" x="13">&lt;c13&gt;</bpt>compact<bpt i="14" x="14">&lt;w14&gt;</bpt>Map(_:)<ept i="14">&lt;/w14&gt;</ept><ept i="13">&lt;/c13&gt;</ept> omits from the transformed asynchronous sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="11" x="11">&lt;c11&gt;</bpt>4<ept i="11">&lt;/c11&gt;</ept>に対するキーがないことから、クロージャは<bpt i="12" x="12">&lt;c12&gt;</bpt>nil<ept i="12">&lt;/c12&gt;</ept>をその場合には返します、それは<bpt i="13" x="13">&lt;c13&gt;</bpt>compact<bpt i="14" x="14">&lt;w14&gt;</bpt>Map(_:)<ept i="14">&lt;/w14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>がこの変換された非同期シーケンスから省きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because this initializer does not perform any checks, it should be used as an optimization only when you are absolutely certain that <bpt i="0" x="0">&lt;c0&gt;</bpt>lower<ept i="0">&lt;/c0&gt;</ept> is less than or equal to <bpt i="1" x="1">&lt;c1&gt;</bpt>upper<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザは何ら確認を行わないので、それは、あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>lower<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>upper<ept i="1">&lt;/c1&gt;</ept>より少ないか等しいことを絶対に確信している場合にのみ１つの最適化として使われるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because unions in C use the same base memory address for all of their fields, all of the computed properties in a union imported by Swift use the same underlying memory.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Cでの共用体は同じ基盤メモリアドレスをすべてのそれのフィールドに対して使うことから、スウィフトによってインポートされる共用体の中の計算プロパティのすべては同じ基礎をなすメモリを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because weak and unowned references cannot be the only reference to an object, passing a weak or unowned reference as <bpt i="6" x="6">&lt;c6&gt;</bpt>object<ept i="6">&lt;/c6&gt;</ept> always results in <bpt i="7" x="7">&lt;c7&gt;</bpt>false<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>弱いおよび非所有の参照は、あるオブジェクトに対する唯一の参照ではありえないので、弱いまたは非所有参照を<bpt i="6" x="6">&lt;c6&gt;</bpt>object<ept i="6">&lt;/c6&gt;</ept>として渡すことは常に<bpt i="7" x="7">&lt;c7&gt;</bpt>false<ept i="7">&lt;/c7&gt;</ept>という結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Before appending, the array allocates new storage that is large enough store the resulting elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>追加の前に、この配列は新しいストレージを割り当てます、それは結果として生じる要素らを格納するのに十分に大きいものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Before shifting, the masking left shift operator masks the shift to this range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シフトする前に、マスク左シフト演算子は、シフトをマスクしてこの範囲にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Before shifting, the masking right shift operator masks the shift to this range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シフトする前に、マスク右シフト演算子は、シフトをマスクしてこの範囲にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Before you call a method on an object's delegate, make sure that the delegate isn't <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがメソッドをオブジェクトの持つ委任先で呼び出す前に、委任先が<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>でないことを確実にしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Bidirectional collections can therefore offer additional operations, such as a <bpt i="2" x="2">&lt;c2&gt;</bpt>last<ept i="2">&lt;/c2&gt;</ept> property that provides efficient access to the last element and a <bpt i="3" x="3">&lt;c3&gt;</bpt>reversed()<ept i="3">&lt;/c3&gt;</ept> method that presents the elements in reverse order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>二方向性のコレクションは、従って追加の演算を提案します、例えば最後の要素への手際のよいアクセスを提供する<bpt i="2" x="2">&lt;c2&gt;</bpt>last<ept i="2">&lt;/c2&gt;</ept>プロパティ、そして要素を逆順で提示する<bpt i="3" x="3">&lt;c3&gt;</bpt>reversed()<ept i="3">&lt;/c3&gt;</ept>メソッドなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Bidirectional collections offer traversal backward from any valid index, not including a collection’s <bpt i="0" x="0">&lt;c0&gt;</bpt>start<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>二方向性のコレクションは、あらゆる有効な、しかしコレクションの<bpt i="0" x="0">&lt;c0&gt;</bpt>start<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を含まないインデックスから後方へ辿っていくことを提案します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Bidirectional<bpt i="0" x="0">&lt;w0&gt;</bpt>Collection Implementations <ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>双方向<bpt i="0" x="0">&lt;w0&gt;</bpt>コレクションの実装 <ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Binary Integer Operators</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２進整数演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Binary<bpt i="0" x="0">&lt;w0&gt;</bpt>Floating<bpt i="1" x="1">&lt;w1&gt;</bpt>Point Implementations <ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>バイナリ<bpt i="0" x="0">&lt;w0&gt;</bpt>浮動<bpt i="1" x="1">&lt;w1&gt;</bpt>小数点の実装 <ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Binary<bpt i="0" x="0">&lt;w0&gt;</bpt>Integer Implementations <ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>バイナリ<bpt i="0" x="0">&lt;w0&gt;</bpt>整数の実装<ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>BinaryFloatingPoint Implementations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>バイナリ浮動小数点実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Bit Fields</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ビットフィールド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Bit Pattern Conversion</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ビットパターン変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Bit Shift</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ビットシフト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Bitwise Operations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ビット単位演算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Bitwise conversion from one integer type to another.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある整数型から別のものへのビット単位変換。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Both of these methods return the original, unwrapped type of the object.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これらのメソッドの両方とも、元の、オブジェクトのアンラップされた型を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Both parameters must be valid indices of the collection and not equal to <bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>両方のパラメータは、このコレクションの有効なインデックスであり、<bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と等しくない必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Both parameters must be valid indices of the collection that are not equal to <bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>両方のパラメータは、このコレクションの有効なインデックスで、<bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と等しくない必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Both processes are described below.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>双方の行程は下で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Bridging Between Array and NSArray</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ArrayとNSArrayの間のブリッジ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Bridging Between Dictionary and NSDictionary</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>DictionaryとNSDictionaryの間のブリッジ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Bridging from <bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept> to <bpt i="1" x="1">&lt;c1&gt;</bpt>NSArray<ept i="1">&lt;/c1&gt;</ept> takes O(1) time and O(1) space if the array’s elements are already instances of a class or an <bpt i="2" x="2">&lt;c2&gt;</bpt>@objc<ept i="2">&lt;/c2&gt;</ept> protocol; otherwise, it takes O(<bpt i="3" x="3">&lt;e3&gt;</bpt>n<ept i="3">&lt;/e3&gt;</ept>) time and space.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept>から<bpt i="1" x="1">&lt;c1&gt;</bpt>NSArray<ept i="1">&lt;/c1&gt;</ept>へのブリッジは、配列のもつ要素がすでにあるクラスまたは<bpt i="2" x="2">&lt;c2&gt;</bpt>@objc<ept i="2">&lt;/c2&gt;</ept>プロトコルのインスタンスであるならば、O(1)時間とO(1)空間をとります；そうでなければ、それはO(<bpt i="3" x="3">&lt;e3&gt;</bpt>n<ept i="3">&lt;/e3&gt;</ept>)の時間と空間をとります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Bridging from <bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept> to <bpt i="1" x="1">&lt;c1&gt;</bpt>NSDictionary<ept i="1">&lt;/c1&gt;</ept> always takes O(1) time and space.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept>から<bpt i="1" x="1">&lt;c1&gt;</bpt>NSDictionary<ept i="1">&lt;/c1&gt;</ept>へのブリッジは、常にO(1)時間と空間をとります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Bridging from <bpt i="0" x="0">&lt;c0&gt;</bpt>NSDictionary<ept i="0">&lt;/c0&gt;</ept> to <bpt i="1" x="1">&lt;c1&gt;</bpt>Dictionary<ept i="1">&lt;/c1&gt;</ept> first calls the <bpt i="2" x="2">&lt;c2&gt;</bpt>copy(with:)<ept i="2">&lt;/c2&gt;</ept> method (<bpt i="3" x="3">&lt;c3&gt;</bpt>- copy<bpt i="4" x="4">&lt;w4&gt;</bpt>With<bpt i="5" x="5">&lt;w5&gt;</bpt>Zone:<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> in Objective-C) on the dictionary to get an immutable copy and then performs additional Swift bookkeeping work that takes O(1) time.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NSDictionary<ept i="0">&lt;/c0&gt;</ept>から<bpt i="1" x="1">&lt;c1&gt;</bpt>Dictionary<ept i="1">&lt;/c1&gt;</ept>へのブリッジは、最初に<bpt i="2" x="2">&lt;c2&gt;</bpt>copy(with:)<ept i="2">&lt;/c2&gt;</ept>メソッド（Objective-Cでの<bpt i="3" x="3">&lt;c3&gt;</bpt>- copy<bpt i="4" x="4">&lt;w4&gt;</bpt>With<bpt i="5" x="5">&lt;w5&gt;</bpt>Zone:<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>）をその辞書上で呼び出して可変のコピーを取得して、それからO(1)時間を取る追加的なSwift簿記作業を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Build apps using a powerful open language.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>強力でオープンな言語を使ってアプリを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>By default this limit is unlimited.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>初期状態ではこの限界は、制限されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>By default, a collection conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Sequence<ept i="0">&lt;/c0&gt;</ept> protocol by supplying <bpt i="1" x="1">&lt;c1&gt;</bpt>Indexing<bpt i="2" x="2">&lt;w2&gt;</bpt>Iterator<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> as its associated <bpt i="3" x="3">&lt;c3&gt;</bpt>Iterator<ept i="3">&lt;/c3&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>初期状態で、あるコレクションは<bpt i="0" x="0">&lt;c0&gt;</bpt>Sequence<ept i="0">&lt;/c0&gt;</ept>プロトコルに、<bpt i="1" x="1">&lt;c1&gt;</bpt>Indexing<bpt i="2" x="2">&lt;w2&gt;</bpt>Iterator<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>をそれの関連<bpt i="3" x="3">&lt;c3&gt;</bpt>Iterator<ept i="3">&lt;/c3&gt;</ept>型として提供することによって準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>By default, any custom collection type you create will inherit a <bpt i="0" x="0">&lt;c0&gt;</bpt>make<bpt i="1" x="1">&lt;w1&gt;</bpt>Iterator()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method that returns an <bpt i="2" x="2">&lt;c2&gt;</bpt>Indexing<bpt i="3" x="3">&lt;w3&gt;</bpt>Iterator<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance, making it unnecessary to declare your own.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>初期状態で、あなたが作成するあらゆるあつらえのコレクション型は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Indexing<bpt i="1" x="1">&lt;w1&gt;</bpt>Iterator<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを返す<bpt i="2" x="2">&lt;c2&gt;</bpt>make<bpt i="3" x="3">&lt;w3&gt;</bpt>Iterator()<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドを継承していて、それをあなた自身で宣言する必要がないようにしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>By default, the generated header contains interfaces for Swift declarations marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>public<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>open<ept i="1">&lt;/c1&gt;</ept> modifier.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>特に何もしなければ、生成されたヘッダは<bpt i="0" x="0">&lt;c0&gt;</bpt>public<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>open<ept i="1">&lt;/c1&gt;</ept>修飾子で印されたSwift宣言を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>By default, this name is the same as your product name, with any nonalphanumeric characters replaced with an underscore (<bpt i="2" x="2">&lt;c2&gt;</bpt>_<ept i="2">&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時には、この名前は、あらゆる非アルファベット文字がアンダースコア（<bpt i="2" x="2">&lt;c2&gt;</bpt>_<ept i="2">&lt;/c2&gt;</ept>）で置き換えられたあなたの製品名と同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>C <bpt i="0" x="0">&lt;c0&gt;</bpt>struct<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>union<ept i="1">&lt;/c1&gt;</ept> types can define fields that have no name or that are of an unnamed type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Cの<bpt i="0" x="0">&lt;c0&gt;</bpt>struct<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>union<ept i="1">&lt;/c1&gt;</ept>型は、名前を持たないまたは無名型であるフィールドを定義できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>C APIs</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>C API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>C Interoperability</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>C互換性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>C Syntax</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>C構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>C Variadic Functions</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>C可変長引数関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>C and Objective-C Pointers</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>CおよびObjective-Cポインタ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>C function pointers are imported into Swift as closures with the C function pointer calling convention, denoted by the <bpt i="0" x="0">&lt;c0&gt;</bpt>@convention(c)<ept i="0">&lt;/c0&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>C関数ポインターは、<bpt i="0" x="0">&lt;c0&gt;</bpt>@convention(c)<ept i="0">&lt;/c0&gt;</ept>属性によって示される、C関数呼出規約を持つクロージャとしてSwiftにインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>C functions that use the <bpt i="2" x="2">&lt;c2&gt;</bpt>...<ept i="2">&lt;/c2&gt;</ept> syntax for variadic arguments are not imported, and therefore can’t be called using <bpt i="3" x="3">&lt;c3&gt;</bpt>CVar<bpt i="4" x="4">&lt;w4&gt;</bpt>Arg<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> arguments.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>...<ept i="2">&lt;/c2&gt;</ept>構文を可変長引数に使うC関数はインポートされません、そしてそれゆえ<bpt i="3" x="3">&lt;c3&gt;</bpt>CVar<bpt i="4" x="4">&lt;w4&gt;</bpt>Arg<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>引数を使って呼び出されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>C macros that are more complex than simple constant definitions have no counterpart in Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>単純な定数宣言よりもっと複雑なCマクロは、相当するものをSwiftにおいて持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calculates the additive inverse of a value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値の加法の逆元を計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calculates the result of shifting a value’s binary representation the specified number of digits to the right, masking the shift amount to the type’s bit width, and stores the result in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値のバイナリ表現を指定された桁数だけ右にシフトする結果を計算します、シフト量をその型のもつビット幅にマスクしています、そして結果を左手側の変数に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calculating <bpt i="3" x="3">&lt;c3&gt;</bpt>count<ept i="3">&lt;/c3&gt;</ept> can be an O(<bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept>) operation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>count<ept i="3">&lt;/c3&gt;</ept>の算出は、O(<bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept>)演算であるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Call <bpt i="0" x="0">&lt;c0&gt;</bpt>body(p)<ept i="0">&lt;/c0&gt;</ept>, where <bpt i="1" x="1">&lt;c1&gt;</bpt>p<ept i="1">&lt;/c1&gt;</ept> is a pointer to the collection’s contiguous storage.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>body(p)<ept i="0">&lt;/c0&gt;</ept>を呼び出します、ここで<bpt i="1" x="1">&lt;c1&gt;</bpt>p<ept i="1">&lt;/c1&gt;</ept>はコレクションのもつ隣接ストレージへのポインタです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Call <bpt i="0" x="0">&lt;c0&gt;</bpt>body(p)<ept i="0">&lt;/c0&gt;</ept>, where <bpt i="1" x="1">&lt;c1&gt;</bpt>p<ept i="1">&lt;/c1&gt;</ept> is a pointer to the collection’s mutable contiguous storage.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>body(p)<ept i="0">&lt;/c0&gt;</ept>を呼び出します、ここで<bpt i="1" x="1">&lt;c1&gt;</bpt>p<ept i="1">&lt;/c1&gt;</ept>はコレクションのもつ可変の隣接ストレージへのポインタです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Call <bpt i="0" x="0">&lt;c0&gt;</bpt>first<bpt i="1" x="1">&lt;w1&gt;</bpt>Index(where:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> again, this time on the slice created in step 2.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>first<bpt i="1" x="1">&lt;w1&gt;</bpt>Index(where:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>もう一度呼び出します、今回は手順にで作成したスライス上で。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Call <bpt i="0" x="0">&lt;c0&gt;</bpt>first<bpt i="1" x="1">&lt;w1&gt;</bpt>Index(where:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to find the index of the first element in the <bpt i="2" x="2">&lt;c2&gt;</bpt>absences<ept i="2">&lt;/c2&gt;</ept> array that is greater than zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>first<bpt i="1" x="1">&lt;w1&gt;</bpt>Index(where:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を呼んで<bpt i="2" x="2">&lt;c2&gt;</bpt>absences<ept i="2">&lt;/c2&gt;</ept>配列の中の、ゼロより大きい最初の要素がもつインデックスを手に入れてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Call <bpt i="0" x="0">&lt;c0&gt;</bpt>random<bpt i="1" x="1">&lt;w1&gt;</bpt>Element()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to select a random element from an array or another collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>random<bpt i="1" x="1">&lt;w1&gt;</bpt>Element()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を呼び出して、ある無作為な要素を配列または別のコレクションから選んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Call <bpt i="0" x="0">&lt;c0&gt;</bpt>random<bpt i="1" x="1">&lt;w1&gt;</bpt>Element(using:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to select a random element from an array or another collection when you are using a custom random number generator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>random<bpt i="1" x="1">&lt;w1&gt;</bpt>Element(using:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を呼び出して、あなたがあつらえの無作為数生成子を使っている場合に、ある無作為な要素を配列または別のコレクションから選んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Call <bpt i="2" x="2">&lt;c2&gt;</bpt>hasher<bpt i="3" x="3">&lt;w3&gt;</bpt>.combine(_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> with each of these components.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>hasher<bpt i="3" x="3">&lt;w3&gt;</bpt>.combine(_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>をそれら構成要素とともに呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Call Functions with Pointer Parameters</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>関数をポインタパラメータを使って呼び出す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Callers should apply the same preconditions to the return value as they would to a range provided directly by the user.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>呼び出し側は、同じ前提条件を戻り値に適用すべきです、それらがユーザによって直接に提供される範囲にするように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calling <bpt i="0" x="0">&lt;c0&gt;</bpt>appending(path:)<ept i="0">&lt;/c0&gt;</ept> results in the same key path as if the given key path had been specified using dot notation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>appending(path:)<ept i="0">&lt;/c0&gt;</ept>を呼び出すことは、与えられたキーパスがドット表記法を使って指定された場合と同じキーパスという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calling <bpt i="0" x="0">&lt;c0&gt;</bpt>check<bpt i="1" x="1">&lt;w1&gt;</bpt>Cancellation()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> on the <bpt i="2" x="2">&lt;c2&gt;</bpt>Task<ept i="2">&lt;/c2&gt;</ept>, which throws a <bpt i="3" x="3">&lt;c3&gt;</bpt>Cancellation<bpt i="4" x="4">&lt;w4&gt;</bpt>Error<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>check<bpt i="1" x="1">&lt;w1&gt;</bpt>Cancellation()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を<bpt i="2" x="2">&lt;c2&gt;</bpt>Task<ept i="2">&lt;/c2&gt;</ept>上で呼び出す、それは<bpt i="3" x="3">&lt;c3&gt;</bpt>Cancellation<bpt i="4" x="4">&lt;w4&gt;</bpt>Error<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>をスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calling <bpt i="2" x="2">&lt;c2&gt;</bpt>swap<bpt i="3" x="3">&lt;w3&gt;</bpt>At(_:<bpt i="4" x="4">&lt;w4&gt;</bpt>_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> with the same index as both <bpt i="5" x="5">&lt;c5&gt;</bpt>i<ept i="5">&lt;/c5&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt>j<ept i="6">&lt;/c6&gt;</ept> has no effect.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>swap<bpt i="3" x="3">&lt;w3&gt;</bpt>At(_:<bpt i="4" x="4">&lt;w4&gt;</bpt>_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を<bpt i="5" x="5">&lt;c5&gt;</bpt>i<ept i="5">&lt;/c5&gt;</ept>と<bpt i="6" x="6">&lt;c6&gt;</bpt>j<ept i="6">&lt;/c6&gt;</ept>両方で同じインデックスで呼び出すことは、効果を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calling Objective-C APIs Asynchronously</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-C APIを非同期に呼び出す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calling the <bpt i="0" x="0">&lt;c0&gt;</bpt>dump(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>_:<bpt i="2" x="2">&lt;w2&gt;</bpt>_:<bpt i="3" x="3">&lt;w3&gt;</bpt>_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function and printing in the debugger uses both <bpt i="4" x="4">&lt;c4&gt;</bpt>String(reflecting:)<ept i="4">&lt;/c4&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt>Mirror(reflecting:)<ept i="5">&lt;/c5&gt;</ept> to collect information about an instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>dump(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>_:<bpt i="2" x="2">&lt;w2&gt;</bpt>_:<bpt i="3" x="3">&lt;w3&gt;</bpt>_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数を呼び出してデバッガに出力することは、<bpt i="4" x="4">&lt;c4&gt;</bpt>String(reflecting:)<ept i="4">&lt;/c4&gt;</ept>と<bpt i="5" x="5">&lt;c5&gt;</bpt>Mirror(reflecting:)<ept i="5">&lt;/c5&gt;</ept>の両方を使ってインスタンスの情報を収集します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calling the <bpt i="0" x="0">&lt;c0&gt;</bpt>numeric<bpt i="1" x="1">&lt;w1&gt;</bpt>Cast(_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function is equivalent to calling an initializer for the destination type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>numeric<bpt i="1" x="1">&lt;w1&gt;</bpt>Cast(_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数を呼び出すことは、行き先型に対するイニシャライザを呼び出すことに等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calling the <bpt i="0" x="0">&lt;c0&gt;</bpt>reserve<bpt i="1" x="1">&lt;w1&gt;</bpt>Capacity(_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method on a dictionary with bridged storage triggers a copy to contiguous storage even if the existing storage has room to store <bpt i="2" x="2">&lt;c2&gt;</bpt>minimum<bpt i="3" x="3">&lt;w3&gt;</bpt>Capacity<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> key-value pairs.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>reserve<bpt i="1" x="1">&lt;w1&gt;</bpt>Capacity(_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドをブリッジされたストレージを持つ辞書で呼び出すことは、隣接ストレージへのコピーを引き起こします、たとえ既存のストレージに<bpt i="2" x="2">&lt;c2&gt;</bpt>minimum<bpt i="3" x="3">&lt;w3&gt;</bpt>Capacity<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>キー値ペアを格納する余地があるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calling the <bpt i="0" x="0">&lt;c0&gt;</bpt>reserve<bpt i="1" x="1">&lt;w1&gt;</bpt>Capacity(_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method on an array with bridged storage triggers a copy to contiguous storage even if the existing storage has room to store <bpt i="2" x="2">&lt;c2&gt;</bpt>minimum<bpt i="3" x="3">&lt;w3&gt;</bpt>Capacity<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>reserve<bpt i="1" x="1">&lt;w1&gt;</bpt>Capacity(_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドをブリッジされたストレージを持つ配列で呼び出すことは、隣接ストレージへのコピーを引き起こします、たとえ既存のストレージに<bpt i="2" x="2">&lt;c2&gt;</bpt>minimum<bpt i="3" x="3">&lt;w3&gt;</bpt>Capacity<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>要素を格納する余地があるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calling the <bpt i="2" x="2">&lt;c2&gt;</bpt>remove<bpt i="3" x="3">&lt;w3&gt;</bpt>Subrange(_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method instead is preferred.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>remove<bpt i="3" x="3">&lt;w3&gt;</bpt>Subrange(_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドを代わりに呼ぶことが好まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calling the <bpt i="6" x="6">&lt;c6&gt;</bpt>insert(contents<bpt i="7" x="7">&lt;w7&gt;</bpt>Of:<bpt i="8" x="8">&lt;w8&gt;</bpt>at:)<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> method instead is preferred.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt>insert(contents<bpt i="7" x="7">&lt;w7&gt;</bpt>Of:<bpt i="8" x="8">&lt;w8&gt;</bpt>at:)<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>メソッドを代わりに呼ぶことが好まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calling the function with different class types shows how the <bpt i="4" x="4">&lt;c4&gt;</bpt>get<bpt i="5" x="5">&lt;w5&gt;</bpt>Default<bpt i="6" x="6">&lt;w6&gt;</bpt>Value()<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> class method is only conditionally available.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この関数を異なるクラス型で呼び出すことは、どのように<bpt i="4" x="4">&lt;c4&gt;</bpt>get<bpt i="5" x="5">&lt;w5&gt;</bpt>Default<bpt i="6" x="6">&lt;w6&gt;</bpt>Value()<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>クラスメソッドが条件付きでのみ利用可能であるのかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calling the related <bpt i="0" x="0">&lt;c0&gt;</bpt>sorted()<ept i="0">&lt;/c0&gt;</ept> method is equivalent to calling this method and passing the less-than operator (<bpt i="1" x="1">&lt;c1&gt;</bpt>&lt;<ept i="1">&lt;/c1&gt;</ept>) as the predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>関連した<bpt i="0" x="0">&lt;c0&gt;</bpt>sorted()<ept i="0">&lt;/c0&gt;</ept>メソッドを呼び出すことは、このメソッドを呼び出して、より小さい演算子（<bpt i="1" x="1">&lt;c1&gt;</bpt>&lt;<ept i="1">&lt;/c1&gt;</ept>）を述部として渡すことと等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calling this function breaks the guarantees of the Swift type system; use with extreme care.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この関数を呼ぶことは、Swift型システムの保証を壊します；最大限の注意を払ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calling this function more than once is idempotent; i.e. finishing more than once does not alter the state beyond the requirements of AsyncSequence; which claims that all values past a terminal state are nil.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この関数を一回以上呼び出すことは冪等です；すなわち、一回以上終了することはAsyncSequenceの要件を越えてその状態を改めません；それは終端状態を過ぎた全ての値はnilであると主張します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calling this method invalidates all indices with respect to the dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを呼び出すことは、この辞書に関するすべてのインデックスを無効にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calling this method invalidates any existing indices for use with this dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを呼び出すことは、この辞書で使うためのあらゆる既存のインデックスを無効にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calling this method may invalidate all saved indices of this collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを呼び出すことは、このコレクションの全ての保存されたインデックスを無効にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calling this method may invalidate any existing indices for use with this collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを呼び出すことは、このコレクションで使うためのあらゆる既存のインデックスを無効にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calling this property directly is discouraged.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このプロパティを直接に呼び出すことは、推奨されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calls a closure with a pointer to the array’s contiguous storage.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャを配列のもつ隣接ストレージへのポインタとともに呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calls the given closure on each element in the sequence in the same order as a <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> loop.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定されたクロージャをそのシーケンスの各要素上で<bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>ループと同じ順番で呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calls the given closure with a mutable pointer to the given argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたクロージャを与えられた引数に対する可変ポインタを使って呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calls the given closure with a pointer to the array’s mutable contiguous storage.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたクロージャを配列のもつ可変の隣接ストレージへのポインタとともに呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calls the given closure with a pointer to the underlying bytes of the array’s contiguous storage.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたクロージャを、配列の隣接ストレージの基礎をなすバイトへのポインタとともに呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calls the given closure with a pointer to the underlying bytes of the array’s mutable contiguous storage.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたクロージャを、配列の可変の隣接ストレージの基礎をなすバイトへのポインタとともに呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calls the given closure with the with the “current” task in which this function was invoked.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたクロージャを、それにおいてこの関数が発動されたところの “現在の” タスクで呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Canceling Tasks</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>タスクの取り消し</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Canceling the task in which the group is running also cancels the group and all of its child tasks.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その中においてグループが動作しているタスクを取り消すことはまた、そのグループと全てのそれの子タスクを取り消します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Cancellation</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>取り消し</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Cancelling an active iteration will first invoke the onTermination callback and then resume yeilding nil.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>活動中の反復が取れ消されることは、最初にonTerminationコールバックを発動します、その次にnilを生み出すことを再開します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Cast between a Swift value type and its corresponding reference type by using the <bpt i="1" x="1">&lt;c1&gt;</bpt>as<ept i="1">&lt;/c1&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swift値型とそれの対応する参照型の間で<bpt i="1" x="1">&lt;c1&gt;</bpt>as<ept i="1">&lt;/c1&gt;</ept>キーワードを使ってキャストしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Cast instances of the Objective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>id<ept i="0">&lt;/c0&gt;</ept> type to a specific Swift type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>id<ept i="0">&lt;/c0&gt;</ept>のインスタンスをSwift型にキャストします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Casting AnyObject Instances to a Known Type</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>AnyObjectインスタンスを既知の型へキャストする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Casting an instance of a reference type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>参照型のインスタンスのキャスト。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Casting is always safe in the context of a <bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キャストは<bpt i="0" x="0">&lt;c0&gt;</bpt>switch<ept i="0">&lt;/c0&gt;</ept>文の文脈においては常に安全です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Catch Errors</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>エラーをキャッチする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Cerating a Random Value</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>無作為な値を作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Check That Delegates Exist</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その委任先が存在するか確認する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Check if the task is cancelled and throw an <bpt i="0" x="0">&lt;c0&gt;</bpt>Cancellation<bpt i="1" x="1">&lt;w1&gt;</bpt>Error<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> if it was.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>タスクが取り消されるかどうか確認します、そしてそれがそうであったならば<bpt i="0" x="0">&lt;c0&gt;</bpt>Cancellation<bpt i="1" x="1">&lt;w1&gt;</bpt>Error<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Checking a Character’s Case</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>文字のケースを確認する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Checking a Character’s Numeric Properties</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>文字の数値プロパティを確認する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Checking for Containment</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>制約を調べる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Checking the <bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Cancelled<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> value of the current <bpt i="2" x="2">&lt;c2&gt;</bpt>Task<ept i="2">&lt;/c2&gt;</ept> inside <bpt i="3" x="3">&lt;c3&gt;</bpt>next()<ept i="3">&lt;/c3&gt;</ept> and returning <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept> to terminate the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>next()<ept i="3">&lt;/c3&gt;</ept>の内部の現在の<bpt i="2" x="2">&lt;c2&gt;</bpt>Task<ept i="2">&lt;/c2&gt;</ept>の<bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Cancelled<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>値を調べるそして<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>を返してシーケンスを終端する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Checks a necessary condition for making forward progress.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これは進捗を前へ進めるために必要な条件を確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Choose Structures by Default</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>構造体を通常は使ってください</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Choosing Between Structures and Classes</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>構造体かクラスのいずれかを選ぶ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Choosing the Smallest and Largest Value</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最小および最大値を選ぶ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Clamping Conversion</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>固定変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Clamping a Range</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲を固定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Class clusters that include immutable and mutable subclasses, like <bpt i="0" x="0">&lt;c0&gt;</bpt>NSArray<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>NSMutable<bpt i="2" x="2">&lt;w2&gt;</bpt>Array<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>, are bridged to a single value type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NSArray<ept i="0">&lt;/c0&gt;</ept>および<bpt i="1" x="1">&lt;c1&gt;</bpt>NSMutable<bpt i="2" x="2">&lt;w2&gt;</bpt>Array<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>のような、不変および可変のサブクラスを含むクラスクラスタは、単一の値型にブリッジされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Class instance identity, on the other hand, is compared using the triple-equals identical-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>===<ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>一方、クラスインスタンス同一性は、３つの等号の同一性演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>===<ept i="0">&lt;/c0&gt;</ept>）を使って比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Classes in Swift come with a built-in notion of identity because they're reference types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftでのクラスそれらは、組み込みの同一性の概念を備えています、なぜならそれらが参照型だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Classes specific to Objective-C or inherently tied to the Objective-C runtime, like <bpt i="0" x="0">&lt;c0&gt;</bpt>NSObject<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>NSAutorelease<bpt i="2" x="2">&lt;w2&gt;</bpt>Pool<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>NSException<ept i="3">&lt;/c3&gt;</ept>, and <bpt i="4" x="4">&lt;c4&gt;</bpt>NSProxy<ept i="4">&lt;/c4&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-C特有の、またはObjective-Cランタイムに本質的に結びつけられ切り離せないクラス、<bpt i="0" x="0">&lt;c0&gt;</bpt>NSObject<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>NSAutorelease<bpt i="2" x="2">&lt;w2&gt;</bpt>Pool<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>NSException<ept i="3">&lt;/c3&gt;</ept>、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>NSProxy<ept i="4">&lt;/c4&gt;</ept>のような</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Coalescing Nil Values</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>nil値の合体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Cocoa APIs often provide protocols that include delegate methods.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Cocoa APIは、しばしば委任先メソッドを含むプロトコルを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Cocoa Design Patterns</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Cocoaデザインパターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Cocoa Frameworks</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Cocoaフレームワーク</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Code outside the standard library can extend string interpolation on <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> and many other common types by extending <bpt i="1" x="1">&lt;c1&gt;</bpt>Default<bpt i="2" x="2">&lt;w2&gt;</bpt>String<bpt i="3" x="3">&lt;w3&gt;</bpt>Interpolation<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> and adding an <bpt i="4" x="4">&lt;c4&gt;</bpt>append<bpt i="5" x="5">&lt;w5&gt;</bpt>Interpolation(...)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>標準ライブラリの外側のコードは、文字列補間を<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>および多くの他の一般の型の上で拡張することが、<bpt i="1" x="1">&lt;c1&gt;</bpt>Default<bpt i="2" x="2">&lt;w2&gt;</bpt>String<bpt i="3" x="3">&lt;w3&gt;</bpt>Interpolation<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>を拡張することそして<bpt i="4" x="4">&lt;c4&gt;</bpt>append<bpt i="5" x="5">&lt;w5&gt;</bpt>Interpolation(...)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>メソッドを加えることで可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Coding<bpt i="0" x="0">&lt;w0&gt;</bpt>Key Implementations <ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コーディング<bpt i="0" x="0">&lt;w0&gt;</bpt>キー実装<ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Collection Implementations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクション実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Collection Literals</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションリテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Collection Traversal</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクション横断</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Collections</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>さまざまなコレクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Collections are used extensively throughout the standard library.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションは標準ライブラリの至る所で広範囲にわたって使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Combining Arrays</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列を結合する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Command Line Input</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コマンドライン入力</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Command-line arguments for the current process.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>現在のプロセスに対するコマンドライン引数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Common Patterns</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>共通パターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Common conversions supported by the Swift standard library include the following:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swift標準ライブラリによってサポートされる一般的な変換は、以下を含みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Common protocol to which all actors conform.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それへと全てのアクターが準拠する共通プロコル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Common use cases are file handles, network connections, and shared hardware intermediaries like <bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>CBCentral<bpt i="3" x="3">&lt;w3&gt;</bpt>Manager<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>一般的な利用事例は、ファイルハンドル、ネットワーク接続、そして<bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>CBCentral<bpt i="3" x="3">&lt;w3&gt;</bpt>Manager<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept>のような共有ハードウェア仲介です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Comparable Implementations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Comparable実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Comparable Requirements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Comparable要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Compare each significant property for equality in your <bpt i="5" x="5">&lt;c5&gt;</bpt>==<ept i="5">&lt;/c5&gt;</ept> method's implementation:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>重要なプロパティそれぞれを同等性についてあなたの<bpt i="5" x="5">&lt;c5&gt;</bpt>==<ept i="5">&lt;/c5&gt;</ept>メソッドの実装において比較してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Compare tuples of between two and six <bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept> elements using these comparative operators.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つと６つの間の<bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept>要素のタプルをそれらの比較演算を使って比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Compare tuples of between two and six <bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept> elements for equality or inequality.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つと６つの間の<bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept>要素のタプルを同等性または不等性について比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Comparing Across Integer Types</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>さまざまな整数型を比較する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Comparing Arrays</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列の比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Comparing Boolean Values</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ブール値を比較する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Comparing Characters</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>文字の比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Comparing Dictionaries</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書の比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Comparing Identity</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同一性の比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Comparing Pointers</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ポインタを比較する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Comparing Ranges</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲の比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Comparing Ranges as Collections</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲をコレクションとして比較する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Comparing Values</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値の比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Comparison</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: Amortized O(1) if the dictionary does not wrap a bridged <bpt i="0" x="0">&lt;c0&gt;</bpt>NSDictionary<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：この辞書が、ブリッジされた<bpt i="0" x="0">&lt;c0&gt;</bpt>NSDictionary<ept i="0">&lt;/c0&gt;</ept>をラップしないならば均してO(1)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: Amortized O(1) if the dictionary does not wrap a bridged <bpt i="0" x="0">&lt;c0&gt;</bpt>NSDictionary<ept i="0">&lt;/c0&gt;</ept>; otherwise, the performance is unspecified.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：この辞書が、ブリッジされた<bpt i="0" x="0">&lt;c0&gt;</bpt>NSDictionary<ept i="0">&lt;/c0&gt;</ept>をラップしないならば均してO(1)；それ以外では、性能は不特定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: Averages to O(1) over many calls to <bpt i="0" x="0">&lt;c0&gt;</bpt>pop<bpt i="1" x="1">&lt;w1&gt;</bpt>First()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：多くの<bpt i="0" x="0">&lt;c0&gt;</bpt>pop<bpt i="1" x="1">&lt;w1&gt;</bpt>First()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対する呼び出しにわたって均してO(1)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(1)</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(1) if the collection conforms to <bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>; otherwise, O(<bpt i="3" x="3">&lt;e3&gt;</bpt>k<ept i="3">&lt;/e3&gt;</ept>), where <bpt i="4" x="4">&lt;e4&gt;</bpt>k<ept i="4">&lt;/e4&gt;</ept> is equal to <bpt i="5" x="5">&lt;c5&gt;</bpt>max<bpt i="6" x="6">&lt;w6&gt;</bpt>Length<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：コレクションが<bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠するならば、O(1)；そうでなければ、O(<bpt i="3" x="3">&lt;e3&gt;</bpt>k<ept i="3">&lt;/e3&gt;</ept>)、そこで<bpt i="4" x="4">&lt;e4&gt;</bpt>k<ept i="4">&lt;/e4&gt;</ept>は<bpt i="5" x="5">&lt;c5&gt;</bpt>max<bpt i="6" x="6">&lt;w6&gt;</bpt>Length<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>に相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(1) if the collection conforms to <bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>; otherwise, O(<bpt i="3" x="3">&lt;e3&gt;</bpt>k<ept i="3">&lt;/e3&gt;</ept>), where <bpt i="4" x="4">&lt;e4&gt;</bpt>k<ept i="4">&lt;/e4&gt;</ept> is the absolute value of <bpt i="5" x="5">&lt;c5&gt;</bpt>distance<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：もしコレクションが<bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠するならば、O(1)；そうでなければ、O(<bpt i="3" x="3">&lt;e3&gt;</bpt>k<ept i="3">&lt;/e3&gt;</ept>)、そこで<bpt i="4" x="4">&lt;e4&gt;</bpt>k<ept i="4">&lt;/e4&gt;</ept>は<bpt i="5" x="5">&lt;c5&gt;</bpt>distance<ept i="5">&lt;/c5&gt;</ept>の値の絶対値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(1) if the collection conforms to <bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>; otherwise, O(<bpt i="3" x="3">&lt;e3&gt;</bpt>k<ept i="3">&lt;/e3&gt;</ept>), where <bpt i="4" x="4">&lt;e4&gt;</bpt>k<ept i="4">&lt;/e4&gt;</ept> is the number of elements to drop from the beginning of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：コレクションが<bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠するならば、O(1)；そうでなければ、O(<bpt i="3" x="3">&lt;e3&gt;</bpt>k<ept i="3">&lt;/e3&gt;</ept>)、そこで<bpt i="4" x="4">&lt;e4&gt;</bpt>k<ept i="4">&lt;/e4&gt;</ept>はコレクションの冒頭から除外する要素の数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(1) if the collection conforms to <bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>; otherwise, O(<bpt i="3" x="3">&lt;e3&gt;</bpt>k<ept i="3">&lt;/e3&gt;</ept>), where <bpt i="4" x="4">&lt;e4&gt;</bpt>k<ept i="4">&lt;/e4&gt;</ept> is the number of elements to drop.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：コレクションが<bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠するならば、O(1)；そうでなければ、O(<bpt i="3" x="3">&lt;e3&gt;</bpt>k<ept i="3">&lt;/e3&gt;</ept>)、そこで<bpt i="4" x="4">&lt;e4&gt;</bpt>k<ept i="4">&lt;/e4&gt;</ept>は除外される要素の数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(1) if the collection conforms to <bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>; otherwise, O(<bpt i="3" x="3">&lt;e3&gt;</bpt>k<ept i="3">&lt;/e3&gt;</ept>), where <bpt i="4" x="4">&lt;e4&gt;</bpt>k<ept i="4">&lt;/e4&gt;</ept> is the number of elements to remove.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(1)、もしコレクションが<bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠するならば；そうでなければ、O(<bpt i="3" x="3">&lt;e3&gt;</bpt>k<ept i="3">&lt;/e3&gt;</ept>)、そこで<bpt i="4" x="4">&lt;e4&gt;</bpt>k<ept i="4">&lt;/e4&gt;</ept>は除去される要素の数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(1) if the collection conforms to <bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>; otherwise, O(<bpt i="3" x="3">&lt;e3&gt;</bpt>k<ept i="3">&lt;/e3&gt;</ept>), where <bpt i="4" x="4">&lt;e4&gt;</bpt>k<ept i="4">&lt;/e4&gt;</ept> is the number of elements to select from the beginning of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：コレクションが<bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠するならば、O(1)；そうでなければ、O(<bpt i="3" x="3">&lt;e3&gt;</bpt>k<ept i="3">&lt;/e3&gt;</ept>)、そこで<bpt i="4" x="4">&lt;e4&gt;</bpt>k<ept i="4">&lt;/e4&gt;</ept>はコレクションの冒頭から選択する要素の数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(1) if the collection conforms to <bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>; otherwise, O(<bpt i="3" x="3">&lt;e3&gt;</bpt>k<ept i="3">&lt;/e3&gt;</ept>), where <bpt i="4" x="4">&lt;e4&gt;</bpt>k<ept i="4">&lt;/e4&gt;</ept> is the resulting distance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(1)、もしコレクションが<bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠するならば；そうでなければ、O(<bpt i="3" x="3">&lt;e3&gt;</bpt>k<ept i="3">&lt;/e3&gt;</ept>)、そこで<bpt i="4" x="4">&lt;e4&gt;</bpt>k<ept i="4">&lt;/e4&gt;</ept>は結果の隔たりです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(1) if the collection conforms to <bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>; otherwise, O(<bpt i="3" x="3">&lt;e3&gt;</bpt>k<ept i="3">&lt;/e3&gt;</ept>), where <bpt i="4" x="4">&lt;e4&gt;</bpt>k<ept i="4">&lt;/e4&gt;</ept> is the specified number of elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(1)、もしコレクションが<bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠するならば；そうでなければ、O(<bpt i="3" x="3">&lt;e3&gt;</bpt>k<ept i="3">&lt;/e3&gt;</ept>)、そこで<bpt i="4" x="4">&lt;e4&gt;</bpt>k<ept i="4">&lt;/e4&gt;</ept>は指定した要素の数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(1) if the collection conforms to <bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>; otherwise, O(<bpt i="3" x="3">&lt;e3&gt;</bpt>n<ept i="3">&lt;/e3&gt;</ept>), where <bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept> is the absolute value of <bpt i="5" x="5">&lt;c5&gt;</bpt>n<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(1)、もしコレクションが<bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠するならば；そうでなければ、O(<bpt i="3" x="3">&lt;e3&gt;</bpt>n<ept i="3">&lt;/e3&gt;</ept>)、そこで<bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept>は<bpt i="5" x="5">&lt;c5&gt;</bpt>n<ept i="5">&lt;/c5&gt;</ept>の値の絶対値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(1) if the collection conforms to <bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>; otherwise, O(<bpt i="3" x="3">&lt;e3&gt;</bpt>n<ept i="3">&lt;/e3&gt;</ept>), where <bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept> is the length of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(1)、もしコレクションが<bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠するならば；そうでなければ、O(<bpt i="3" x="3">&lt;e3&gt;</bpt>n<ept i="3">&lt;/e3&gt;</ept>)、そこで<bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept>はコレクションの長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(1) if the collection conforms to <bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>; otherwise, O(<bpt i="3" x="3">&lt;e3&gt;</bpt>n<ept i="3">&lt;/e3&gt;</ept>), where <bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept> is the resulting distance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(1)、もしコレクションが<bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠するならば；そうでなければ、O(<bpt i="3" x="3">&lt;e3&gt;</bpt>n<ept i="3">&lt;/e3&gt;</ept>)、そこで<bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept>は結果となる隔たりです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(1) on average, over many calls to <bpt i="0" x="0">&lt;c0&gt;</bpt>append(_:)<ept i="0">&lt;/c0&gt;</ept> on the same array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：同じ配列上での<bpt i="0" x="0">&lt;c0&gt;</bpt>append(_:)<ept i="0">&lt;/c0&gt;</ept>への多くの呼び出しに対して、均してO(1)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(1), except if the sequence also conforms to <bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(1)、例外としてシーケンスが同様に<bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<ept i="0">&lt;/c0&gt;</ept>に準拠する場合を除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(1), with O(<bpt i="0" x="0">&lt;e0&gt;</bpt>k<ept i="0">&lt;/e0&gt;</ept>) deferred to each iteration of the result, where <bpt i="1" x="1">&lt;e1&gt;</bpt>k<ept i="1">&lt;/e1&gt;</ept> is the number of elements to drop from the beginning of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(1)、結果の各反復に対してO(<bpt i="0" x="0">&lt;e0&gt;</bpt>k<ept i="0">&lt;/e0&gt;</ept>)延期されて、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>k<ept i="1">&lt;/e1&gt;</ept>はシーケンスの冒頭から除かれる要素の数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(1).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(1)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>k<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>k<ept i="1">&lt;/e1&gt;</ept> is the length of the result.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>k<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>k<ept i="1">&lt;/e1&gt;</ept>は結果の長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>k<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>k<ept i="1">&lt;/e1&gt;</ept> is the number of elements to drop from the beginning of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>k<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>k<ept i="1">&lt;/e1&gt;</ept>はシーケンスの冒頭から除かれる要素の数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>k<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>k<ept i="1">&lt;/e1&gt;</ept> is the specified number of elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>k<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>k<ept i="1">&lt;/e1&gt;</ept>は指定された要素の数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept> + <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>), where <bpt i="2" x="2">&lt;e2&gt;</bpt>m<ept i="2">&lt;/e2&gt;</ept> is the length of this sequence and <bpt i="3" x="3">&lt;e3&gt;</bpt>n<ept i="3">&lt;/e3&gt;</ept> is the length of the result.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept> + <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>)、ここで<bpt i="2" x="2">&lt;e2&gt;</bpt>m<ept i="2">&lt;/e2&gt;</ept>はこのシーケンスの長さで、<bpt i="3" x="3">&lt;e3&gt;</bpt>n<ept i="3">&lt;/e3&gt;</ept>は結果の長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept> + <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>), where <bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept> is the length of the original dictionary and <bpt i="3" x="3">&lt;e3&gt;</bpt>m<ept i="3">&lt;/e3&gt;</ept> is the length of the resulting dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept> + <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>)、ここで<bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept>は元の辞書の長さで、<bpt i="3" x="3">&lt;e3&gt;</bpt>m<ept i="3">&lt;/e3&gt;</ept>は結果の辞書の長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept> + <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>), where <bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept> is the length of this sequence and <bpt i="3" x="3">&lt;e3&gt;</bpt>m<ept i="3">&lt;/e3&gt;</ept> is the length of the result.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept> + <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>)、ここで<bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept>はこのシーケンスの長さで、<bpt i="3" x="3">&lt;e3&gt;</bpt>m<ept i="3">&lt;/e3&gt;</ept>は結果の長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept>) on average, where <bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept> is the length of <bpt i="2" x="2">&lt;c2&gt;</bpt>new<bpt i="3" x="3">&lt;w3&gt;</bpt>Elements<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, over many calls to <bpt i="4" x="4">&lt;c4&gt;</bpt>append(contents<bpt i="5" x="5">&lt;w5&gt;</bpt>Of:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> on the same array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>new<bpt i="3" x="3">&lt;w3&gt;</bpt>Elements<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の長さで、同じ配列上での<bpt i="4" x="4">&lt;c4&gt;</bpt>append(contents<bpt i="5" x="5">&lt;w5&gt;</bpt>Of:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>への多くの呼び出しに対してで。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept> is the length of <bpt i="2" x="2">&lt;c2&gt;</bpt>new<bpt i="3" x="3">&lt;w3&gt;</bpt>Elements<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>new<bpt i="3" x="3">&lt;w3&gt;</bpt>Elements<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept> is the length of the right-hand-side argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept>は右手側の引数の長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept> is the lesser of the length of the sequence and the length of <bpt i="2" x="2">&lt;c2&gt;</bpt>other<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept>はシーケンスの長さと<bpt i="2" x="2">&lt;c2&gt;</bpt>other<ept i="2">&lt;/c2&gt;</ept>の長さのより短い方です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept> is the lesser of the length of the sequence and the length of <bpt i="2" x="2">&lt;c2&gt;</bpt>possible<bpt i="3" x="3">&lt;w3&gt;</bpt>Prefix<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>m<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept>はシーケスの長さと<bpt i="2" x="2">&lt;c2&gt;</bpt>possible<bpt i="3" x="3">&lt;w3&gt;</bpt>Prefix<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の長さのより短い方です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept> * log(<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>)), where <bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept> is the length of the parameter.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept> * log(<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>))、ここで<bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept>はパラメータの長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept> + <bpt i="1" x="1">&lt;e1&gt;</bpt>c<ept i="1">&lt;/e1&gt;</ept>), where <bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept> is <bpt i="3" x="3">&lt;c3&gt;</bpt>self<bpt i="4" x="4">&lt;w4&gt;</bpt>.count<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> and <bpt i="5" x="5">&lt;e5&gt;</bpt>c<ept i="5">&lt;/e5&gt;</ept> is the number of changes contained by the parameter.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept> + <bpt i="1" x="1">&lt;e1&gt;</bpt>c<ept i="1">&lt;/e1&gt;</ept>)、ここで<bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>self<bpt i="4" x="4">&lt;w4&gt;</bpt>.count<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>です、そして<bpt i="5" x="5">&lt;e5&gt;</bpt>c<ept i="5">&lt;/e5&gt;</ept>はパラメータによって含まれる変更の数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept> + <bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept>), where <bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept> is length of the array and <bpt i="3" x="3">&lt;e3&gt;</bpt>m<ept i="3">&lt;/e3&gt;</ept> is the length of <bpt i="4" x="4">&lt;c4&gt;</bpt>new<bpt i="5" x="5">&lt;w5&gt;</bpt>Elements<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept> + <bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept>)、ここで<bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept>は配列の長さです、そして<bpt i="3" x="3">&lt;e3&gt;</bpt>m<ept i="3">&lt;/e3&gt;</ept>は<bpt i="4" x="4">&lt;c4&gt;</bpt>new<bpt i="5" x="5">&lt;w5&gt;</bpt>Elements<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept> + <bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept>), where <bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept> is length of this collection and <bpt i="3" x="3">&lt;e3&gt;</bpt>m<ept i="3">&lt;/e3&gt;</ept> is the length of <bpt i="4" x="4">&lt;c4&gt;</bpt>new<bpt i="5" x="5">&lt;w5&gt;</bpt>Elements<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept> + <bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept>)、ここで<bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept>は配列の長さです、そして<bpt i="3" x="3">&lt;e3&gt;</bpt>m<ept i="3">&lt;/e3&gt;</ept>は<bpt i="4" x="4">&lt;c4&gt;</bpt>new<bpt i="5" x="5">&lt;w5&gt;</bpt>Elements<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept> log <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>), where <bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept> is the length of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept> log <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>)、ここで<bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept>はコレクションの長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept> log <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>), where <bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept> is the length of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept> log <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>)、ここで<bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept>はシーケンスの長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>) where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the number of collection differences.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>はコレクション差異それらの数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the length of the array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>は配列の長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the length of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>はコレクションの長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the length of the dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>は辞書の長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the length of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>はシーケンスの長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the number of elements in the array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>は配列の中の要素数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the number of elements in the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>はコレクションの中の要素数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the number of key-value pairs in the dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)、ここで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>は辞書の中のキー値ペアの数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: Reading an element from an array is O(1).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：ある要素を配列から読み出すことはO(1)です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Complexity: Worst case performance is O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept> * <bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept>), where <bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept> is the count of this collection and <bpt i="3" x="3">&lt;e3&gt;</bpt>m<ept i="3">&lt;/e3&gt;</ept> is <bpt i="4" x="4">&lt;c4&gt;</bpt>other<bpt i="5" x="5">&lt;w5&gt;</bpt>.count<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算量：最悪の場合の性能は、O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept> * <bpt i="1" x="1">&lt;e1&gt;</bpt>m<ept i="1">&lt;/e1&gt;</ept>)です、ここで<bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept>はこのコレクションの総数です、そして<bpt i="3" x="3">&lt;e3&gt;</bpt>m<ept i="3">&lt;/e3&gt;</ept>は<bpt i="4" x="4">&lt;c4&gt;</bpt>other<bpt i="5" x="5">&lt;w5&gt;</bpt>.count<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conform Automatically to Equatable and Hashable</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>自動的にequatableとhashableに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conform Manually to Equatable and Hashable</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>手動でequatableとhashableに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforming Types</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これらの型が準拠</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforming to ExpressibleByArrayLiteral</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ExpressibleByArrayLiteralに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforming to ExpressibleByExtendedGraphemeClusterLiteral</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ExpressibleByExtendedGraphemeClusterLiteralに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforming to ExpressibleByFloatLiteral</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ExpressibleByFloatLiteralに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforming to ExpressibleByIntegerLiteral</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ExpressibleByIntegerLiteralに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforming to ExpressibleByStringLiteral</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ExpressibleByStringLiteralに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforming to ExpressibleByUnicodeScalarLiteral</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ExpressibleByUnicodeScalarLiteralに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforming to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept> protocols is straightforward and makes it easier to use your own types in Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>プロトコルに準拠することは、あなた独自の型をSwiftで使うのをわかりやすいそしてより容易なものにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforming to the AdditiveArithmetic Protocol</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>AdditiveArithmeticプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforming to the BidirectionalCollection Protocol</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>BidirectionalCollectionプロトコルへの準拠</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforming to the CaseIterable Protocol</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>CaseIterableプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforming to the Collection Protocol</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Collectionプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforming to the Comparable Protocol</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Comparableプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforming to the CustomDebugStringConvertible Protocol</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>CustomDebugStringConvertibleプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforming to the CustomPlaygroundDisplayConvertible Protocol</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>CustomPlaygroundDisplayConvertibleプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforming to the CustomStringConvertible Protocol</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>CustomStringConvertibleプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforming to the Equatable Protocol</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Equatableプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforming to the ExpressibleByDictionaryLiteral Protocol</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ExpressibleByDictionaryLiteralプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforming to the FixedWidthInteger Protocol</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>FixedWidthIntegerプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforming to the Hashable Protocol</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Hashableプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforming to the Identifiable Protocol</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Identifiableプロトコルに準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms To</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次に準拠</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>A<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>B<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>A<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="2" x="2">&lt;c2&gt;</bpt>B<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>A<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>B<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>C<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Equatable<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>D<ept i="6">&lt;/c6&gt;</ept> conforms to <bpt i="7" x="7">&lt;c7&gt;</bpt>Equatable<ept i="7">&lt;/c7&gt;</ept>, <bpt i="8" x="8">&lt;c8&gt;</bpt>E<ept i="8">&lt;/c8&gt;</ept> conforms to <bpt i="9" x="9">&lt;c9&gt;</bpt>Equatable<ept i="9">&lt;/c9&gt;</ept>, <bpt i="10" x="10">&lt;c10&gt;</bpt>F<ept i="10">&lt;/c10&gt;</ept> conforms to <bpt i="11" x="11">&lt;c11&gt;</bpt>Equatable<ept i="11">&lt;/c11&gt;</ept>, <bpt i="12" x="12">&lt;c12&gt;</bpt>G<ept i="12">&lt;/c12&gt;</ept> conforms to <bpt i="13" x="13">&lt;c13&gt;</bpt>Equatable<ept i="13">&lt;/c13&gt;</ept>, and <bpt i="14" x="14">&lt;c14&gt;</bpt>H<ept i="14">&lt;/c14&gt;</ept> conforms to <bpt i="15" x="15">&lt;c15&gt;</bpt>Equatable<ept i="15">&lt;/c15&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>A<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠する、<bpt i="2" x="2">&lt;c2&gt;</bpt>B<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>に準拠する、<bpt i="4" x="4">&lt;c4&gt;</bpt>C<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Equatable<ept i="5">&lt;/c5&gt;</ept>に準拠する、<bpt i="6" x="6">&lt;c6&gt;</bpt>D<ept i="6">&lt;/c6&gt;</ept>が<bpt i="7" x="7">&lt;c7&gt;</bpt>Equatable<ept i="7">&lt;/c7&gt;</ept>に準拠する、<bpt i="8" x="8">&lt;c8&gt;</bpt>E<ept i="8">&lt;/c8&gt;</ept>が<bpt i="9" x="9">&lt;c9&gt;</bpt>Equatable<ept i="9">&lt;/c9&gt;</ept>に準拠する、<bpt i="10" x="10">&lt;c10&gt;</bpt>F<ept i="10">&lt;/c10&gt;</ept>が<bpt i="11" x="11">&lt;c11&gt;</bpt>Equatable<ept i="11">&lt;/c11&gt;</ept>に準拠する、<bpt i="12" x="12">&lt;c12&gt;</bpt>G<ept i="12">&lt;/c12&gt;</ept>が<bpt i="13" x="13">&lt;c13&gt;</bpt>Equatable<ept i="13">&lt;/c13&gt;</ept>に準拠する、そして<bpt i="14" x="14">&lt;c14&gt;</bpt>H<ept i="14">&lt;/c14&gt;</ept>が<bpt i="15" x="15">&lt;c15&gt;</bpt>Equatable<ept i="15">&lt;/c15&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>A<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>B<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>C<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Equatable<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>D<ept i="6">&lt;/c6&gt;</ept> conforms to <bpt i="7" x="7">&lt;c7&gt;</bpt>Equatable<ept i="7">&lt;/c7&gt;</ept>, <bpt i="8" x="8">&lt;c8&gt;</bpt>E<ept i="8">&lt;/c8&gt;</ept> conforms to <bpt i="9" x="9">&lt;c9&gt;</bpt>Equatable<ept i="9">&lt;/c9&gt;</ept>, <bpt i="10" x="10">&lt;c10&gt;</bpt>F<ept i="10">&lt;/c10&gt;</ept> conforms to <bpt i="11" x="11">&lt;c11&gt;</bpt>Equatable<ept i="11">&lt;/c11&gt;</ept>, and <bpt i="12" x="12">&lt;c12&gt;</bpt>G<ept i="12">&lt;/c12&gt;</ept> conforms to <bpt i="13" x="13">&lt;c13&gt;</bpt>Equatable<ept i="13">&lt;/c13&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>A<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠する、<bpt i="2" x="2">&lt;c2&gt;</bpt>B<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>に準拠する、<bpt i="4" x="4">&lt;c4&gt;</bpt>C<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Equatable<ept i="5">&lt;/c5&gt;</ept>に準拠する、<bpt i="6" x="6">&lt;c6&gt;</bpt>D<ept i="6">&lt;/c6&gt;</ept>が<bpt i="7" x="7">&lt;c7&gt;</bpt>Equatable<ept i="7">&lt;/c7&gt;</ept>に準拠する、<bpt i="8" x="8">&lt;c8&gt;</bpt>E<ept i="8">&lt;/c8&gt;</ept>が<bpt i="9" x="9">&lt;c9&gt;</bpt>Equatable<ept i="9">&lt;/c9&gt;</ept>に準拠する、<bpt i="10" x="10">&lt;c10&gt;</bpt>F<ept i="10">&lt;/c10&gt;</ept>が<bpt i="11" x="11">&lt;c11&gt;</bpt>Equatable<ept i="11">&lt;/c11&gt;</ept>に準拠する、そして<bpt i="12" x="12">&lt;c12&gt;</bpt>G<ept i="12">&lt;/c12&gt;</ept>が<bpt i="13" x="13">&lt;c13&gt;</bpt>Equatable<ept i="13">&lt;/c13&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>A<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>B<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>C<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Equatable<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>D<ept i="6">&lt;/c6&gt;</ept> conforms to <bpt i="7" x="7">&lt;c7&gt;</bpt>Equatable<ept i="7">&lt;/c7&gt;</ept>, <bpt i="8" x="8">&lt;c8&gt;</bpt>E<ept i="8">&lt;/c8&gt;</ept> conforms to <bpt i="9" x="9">&lt;c9&gt;</bpt>Equatable<ept i="9">&lt;/c9&gt;</ept>, and <bpt i="10" x="10">&lt;c10&gt;</bpt>F<ept i="10">&lt;/c10&gt;</ept> conforms to <bpt i="11" x="11">&lt;c11&gt;</bpt>Equatable<ept i="11">&lt;/c11&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>A<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠する、<bpt i="2" x="2">&lt;c2&gt;</bpt>B<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>に準拠する、<bpt i="4" x="4">&lt;c4&gt;</bpt>C<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Equatable<ept i="5">&lt;/c5&gt;</ept>に準拠する、<bpt i="6" x="6">&lt;c6&gt;</bpt>D<ept i="6">&lt;/c6&gt;</ept>が<bpt i="7" x="7">&lt;c7&gt;</bpt>Equatable<ept i="7">&lt;/c7&gt;</ept>に準拠する、<bpt i="8" x="8">&lt;c8&gt;</bpt>E<ept i="8">&lt;/c8&gt;</ept>が<bpt i="9" x="9">&lt;c9&gt;</bpt>Equatable<ept i="9">&lt;/c9&gt;</ept>に準拠する、そして<bpt i="10" x="10">&lt;c10&gt;</bpt>F<ept i="10">&lt;/c10&gt;</ept>が<bpt i="11" x="11">&lt;c11&gt;</bpt>Equatable<ept i="11">&lt;/c11&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>A<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>B<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>C<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Equatable<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>D<ept i="6">&lt;/c6&gt;</ept> conforms to <bpt i="7" x="7">&lt;c7&gt;</bpt>Equatable<ept i="7">&lt;/c7&gt;</ept>, and <bpt i="8" x="8">&lt;c8&gt;</bpt>E<ept i="8">&lt;/c8&gt;</ept> conforms to <bpt i="9" x="9">&lt;c9&gt;</bpt>Equatable<ept i="9">&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>A<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠する、<bpt i="2" x="2">&lt;c2&gt;</bpt>B<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>に準拠する、<bpt i="4" x="4">&lt;c4&gt;</bpt>C<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Equatable<ept i="5">&lt;/c5&gt;</ept>に準拠する、<bpt i="6" x="6">&lt;c6&gt;</bpt>D<ept i="6">&lt;/c6&gt;</ept>が<bpt i="7" x="7">&lt;c7&gt;</bpt>Equatable<ept i="7">&lt;/c7&gt;</ept>に準拠する、そして<bpt i="8" x="8">&lt;c8&gt;</bpt>E<ept i="8">&lt;/c8&gt;</ept>が<bpt i="9" x="9">&lt;c9&gt;</bpt>Equatable<ept i="9">&lt;/c9&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>A<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>B<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>C<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Equatable<ept i="5">&lt;/c5&gt;</ept>, and <bpt i="6" x="6">&lt;c6&gt;</bpt>D<ept i="6">&lt;/c6&gt;</ept> conforms to <bpt i="7" x="7">&lt;c7&gt;</bpt>Equatable<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>A<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠する、<bpt i="2" x="2">&lt;c2&gt;</bpt>B<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>に準拠する、<bpt i="4" x="4">&lt;c4&gt;</bpt>C<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Equatable<ept i="5">&lt;/c5&gt;</ept>に準拠する、そして<bpt i="6" x="6">&lt;c6&gt;</bpt>D<ept i="6">&lt;/c6&gt;</ept>が<bpt i="7" x="7">&lt;c7&gt;</bpt>Equatable<ept i="7">&lt;/c7&gt;</ept>に準拠する場合に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>A<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>B<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>, and <bpt i="4" x="4">&lt;c4&gt;</bpt>C<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Equatable<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>A<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠する、<bpt i="2" x="2">&lt;c2&gt;</bpt>B<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>に準拠する、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>C<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Equatable<ept i="5">&lt;/c5&gt;</ept>に準拠する時に利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Bidirectional<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>Base<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>.<ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>Index<ept i="5">&lt;/c5&gt;</ept> conforms to <bpt i="6" x="6">&lt;c6&gt;</bpt>Hashable<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Bidirectional<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="3" x="3">&lt;c3&gt;</bpt>Base<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>.<ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>Index<ept i="5">&lt;/c5&gt;</ept>が<bpt i="6" x="6">&lt;c6&gt;</bpt>Hashable<ept i="6">&lt;/c6&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Bidirectional<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Bidirectional<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Collection<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Base<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Index<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Hashable<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Collection<ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="2" x="2">&lt;c2&gt;</bpt>Base<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Index<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Hashable<ept i="5">&lt;/c5&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Collection<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>Base<bpt i="3" x="3">&lt;w3&gt;</bpt>.Element<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="4" x="4">&lt;c4&gt;</bpt>Collection<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>Base<ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>.<ept i="6">&lt;/c6&gt;</ept><bpt i="7" x="7">&lt;c7&gt;</bpt>Index<ept i="7">&lt;/c7&gt;</ept> conforms to <bpt i="8" x="8">&lt;c8&gt;</bpt>Hashable<ept i="8">&lt;/c8&gt;</ept>, and <bpt i="9" x="9">&lt;c9&gt;</bpt>Base<ept i="9">&lt;/c9&gt;</ept><bpt i="10" x="10">&lt;c10&gt;</bpt>.<ept i="10">&lt;/c10&gt;</ept><bpt i="11" x="11">&lt;c11&gt;</bpt>Element<ept i="11">&lt;/c11&gt;</ept><bpt i="12" x="12">&lt;c12&gt;</bpt>.<ept i="12">&lt;/c12&gt;</ept><bpt i="13" x="13">&lt;c13&gt;</bpt>Index<ept i="13">&lt;/c13&gt;</ept> conforms to <bpt i="14" x="14">&lt;c14&gt;</bpt>Hashable<ept i="14">&lt;/c14&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Base<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Collection<ept i="1">&lt;/c1&gt;</ept>に準拠する、<bpt i="2" x="2">&lt;c2&gt;</bpt>Base<bpt i="3" x="3">&lt;w3&gt;</bpt>.Element<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt>Collection<ept i="4">&lt;/c4&gt;</ept>に準拠する、<bpt i="5" x="5">&lt;c5&gt;</bpt>Base<ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>.<ept i="6">&lt;/c6&gt;</ept><bpt i="7" x="7">&lt;c7&gt;</bpt>Index<ept i="7">&lt;/c7&gt;</ept>が<bpt i="8" x="8">&lt;c8&gt;</bpt>Hashable<ept i="8">&lt;/c8&gt;</ept>に準拠する、そして<bpt i="9" x="9">&lt;c9&gt;</bpt>Base<ept i="9">&lt;/c9&gt;</ept><bpt i="10" x="10">&lt;c10&gt;</bpt>.<ept i="10">&lt;/c10&gt;</ept><bpt i="11" x="11">&lt;c11&gt;</bpt>Element<ept i="11">&lt;/c11&gt;</ept><bpt i="12" x="12">&lt;c12&gt;</bpt>.<ept i="12">&lt;/c12&gt;</ept><bpt i="13" x="13">&lt;c13&gt;</bpt>Index<ept i="13">&lt;/c13&gt;</ept>が<bpt i="14" x="14">&lt;c14&gt;</bpt>Hashable<ept i="14">&lt;/c14&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>Bound<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Strideable<ept i="3">&lt;/c3&gt;</ept>, and <bpt i="4" x="4">&lt;c4&gt;</bpt>Bound<bpt i="5" x="5">&lt;w5&gt;</bpt>.Stride<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="6" x="6">&lt;c6&gt;</bpt>Signed<bpt i="7" x="7">&lt;w7&gt;</bpt>Integer<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>に準拠する、<bpt i="2" x="2">&lt;c2&gt;</bpt>Bound<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Strideable<ept i="3">&lt;/c3&gt;</ept>に準拠する、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>Bound<bpt i="5" x="5">&lt;w5&gt;</bpt>.Stride<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>が<bpt i="6" x="6">&lt;c6&gt;</bpt>Signed<bpt i="7" x="7">&lt;w7&gt;</bpt>Integer<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Strideable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Bound<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Stride<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Signed<bpt i="6" x="6">&lt;w6&gt;</bpt>Integer<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Strideable<ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="2" x="2">&lt;c2&gt;</bpt>Bound<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Stride<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Signed<bpt i="6" x="6">&lt;w6&gt;</bpt>Integer<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bound<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>である時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Change<bpt i="1" x="1">&lt;w1&gt;</bpt>Element<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt>Decodable<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>Encodable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Change<bpt i="1" x="1">&lt;w1&gt;</bpt>Element<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Decodable<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>Encodable<ept i="3">&lt;/c3&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Change<bpt i="1" x="1">&lt;w1&gt;</bpt>Element<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt>Equatable<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Change<bpt i="1" x="1">&lt;w1&gt;</bpt>Element<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Equatable<ept i="2">&lt;/c2&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Change<bpt i="1" x="1">&lt;w1&gt;</bpt>Element<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt>Hashable<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Change<bpt i="1" x="1">&lt;w1&gt;</bpt>Element<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Hashable<ept i="2">&lt;/c2&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Content<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Modifier<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Content<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="2" x="2">&lt;c2&gt;</bpt>Modifier<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>CKRecord<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<bpt i="3" x="3">&lt;w3&gt;</bpt>Protocol<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>CKRecord<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<bpt i="3" x="3">&lt;w3&gt;</bpt>Protocol<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>に準拠している時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<bpt i="2" x="2">&lt;w2&gt;</bpt>With<bpt i="3" x="3">&lt;w3&gt;</bpt>Configuration<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<bpt i="2" x="2">&lt;w2&gt;</bpt>With<bpt i="3" x="3">&lt;w3&gt;</bpt>Configuration<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠している時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<bpt i="2" x="2">&lt;w2&gt;</bpt>With<bpt i="3" x="3">&lt;w3&gt;</bpt>Configuration<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<bpt i="2" x="2">&lt;w2&gt;</bpt>With<bpt i="3" x="3">&lt;w3&gt;</bpt>Configuration<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠している時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<bpt i="3" x="3">&lt;w3&gt;</bpt>Convertible<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<bpt i="3" x="3">&lt;w3&gt;</bpt>Convertible<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>UInt8<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>UInt8<ept i="1">&lt;/c1&gt;</ept>である場合に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Elements<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Bidirectional<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Elements<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Bidirectional<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Elements<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Elements<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Failure<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Failure<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Failure<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Failure<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Failure<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Failure<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Failure<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Failure<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>First<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Gesture<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>Second<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Gesture<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>First<ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>.<ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>Value<ept i="6">&lt;/c6&gt;</ept> conforms to <bpt i="7" x="7">&lt;c7&gt;</bpt>Equatable<ept i="7">&lt;/c7&gt;</ept>, and <bpt i="8" x="8">&lt;c8&gt;</bpt>Second<ept i="8">&lt;/c8&gt;</ept><bpt i="9" x="9">&lt;c9&gt;</bpt>.<ept i="9">&lt;/c9&gt;</ept><bpt i="10" x="10">&lt;c10&gt;</bpt>Value<ept i="10">&lt;/c10&gt;</ept> conforms to <bpt i="11" x="11">&lt;c11&gt;</bpt>Equatable<ept i="11">&lt;/c11&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>First<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Gesture<ept i="1">&lt;/c1&gt;</ept>に準拠する、<bpt i="2" x="2">&lt;c2&gt;</bpt>Second<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Gesture<ept i="3">&lt;/c3&gt;</ept>に準拠する、<bpt i="4" x="4">&lt;c4&gt;</bpt>First<ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>.<ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>Value<ept i="6">&lt;/c6&gt;</ept>が<bpt i="7" x="7">&lt;c7&gt;</bpt>Equatable<ept i="7">&lt;/c7&gt;</ept>に準拠する、そして<bpt i="8" x="8">&lt;c8&gt;</bpt>Second<ept i="8">&lt;/c8&gt;</ept><bpt i="9" x="9">&lt;c9&gt;</bpt>.<ept i="9">&lt;/c9&gt;</ept><bpt i="10" x="10">&lt;c10&gt;</bpt>Value<ept i="10">&lt;/c10&gt;</ept>が<bpt i="11" x="11">&lt;c11&gt;</bpt>Equatable<ept i="11">&lt;/c11&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>First<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Gesture<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>Second<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Gesture<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>First<ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>.<ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>Value<ept i="6">&lt;/c6&gt;</ept> conforms to <bpt i="7" x="7">&lt;c7&gt;</bpt>Hashable<ept i="7">&lt;/c7&gt;</ept>, and <bpt i="8" x="8">&lt;c8&gt;</bpt>Second<ept i="8">&lt;/c8&gt;</ept><bpt i="9" x="9">&lt;c9&gt;</bpt>.<ept i="9">&lt;/c9&gt;</ept><bpt i="10" x="10">&lt;c10&gt;</bpt>Value<ept i="10">&lt;/c10&gt;</ept> conforms to <bpt i="11" x="11">&lt;c11&gt;</bpt>Hashable<ept i="11">&lt;/c11&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>First<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Gesture<ept i="1">&lt;/c1&gt;</ept>に準拠する、<bpt i="2" x="2">&lt;c2&gt;</bpt>Second<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Gesture<ept i="3">&lt;/c3&gt;</ept>に準拠する、<bpt i="4" x="4">&lt;c4&gt;</bpt>First<ept i="4">&lt;/c4&gt;</ept><bpt i="5" x="5">&lt;c5&gt;</bpt>.<ept i="5">&lt;/c5&gt;</ept><bpt i="6" x="6">&lt;c6&gt;</bpt>Value<ept i="6">&lt;/c6&gt;</ept>が<bpt i="7" x="7">&lt;c7&gt;</bpt>Hashable<ept i="7">&lt;/c7&gt;</ept>に準拠する、そして<bpt i="8" x="8">&lt;c8&gt;</bpt>Second<ept i="8">&lt;/c8&gt;</ept><bpt i="9" x="9">&lt;c9&gt;</bpt>.<ept i="9">&lt;/c9&gt;</ept><bpt i="10" x="10">&lt;c10&gt;</bpt>Value<ept i="10">&lt;/c10&gt;</ept>が<bpt i="11" x="11">&lt;c11&gt;</bpt>Hashable<ept i="11">&lt;/c11&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>ID<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>ID<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Key<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Value<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Decodable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Key<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="2" x="2">&lt;c2&gt;</bpt>Value<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Decodable<ept i="3">&lt;/c3&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Key<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Value<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Encodable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Key<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="2" x="2">&lt;c2&gt;</bpt>Value<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Encodable<ept i="3">&lt;/c3&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Key<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<bpt i="3" x="3">&lt;w3&gt;</bpt>Convertible<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>Value<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>MLData<bpt i="6" x="6">&lt;w6&gt;</bpt>Value<bpt i="7" x="7">&lt;w7&gt;</bpt>Convertible<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Key<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<bpt i="3" x="3">&lt;w3&gt;</bpt>Convertible<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="4" x="4">&lt;c4&gt;</bpt>Value<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>MLData<bpt i="6" x="6">&lt;w6&gt;</bpt>Value<bpt i="7" x="7">&lt;w7&gt;</bpt>Convertible<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Music<bpt i="1" x="1">&lt;w1&gt;</bpt>Item<bpt i="2" x="2">&lt;w2&gt;</bpt>Type<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Decodable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Music<bpt i="1" x="1">&lt;w1&gt;</bpt>Item<bpt i="2" x="2">&lt;w2&gt;</bpt>Type<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Decodable<ept i="3">&lt;/c3&gt;</ept>に準拠している時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Music<bpt i="1" x="1">&lt;w1&gt;</bpt>Item<bpt i="2" x="2">&lt;w2&gt;</bpt>Type<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Encodable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Music<bpt i="1" x="1">&lt;w1&gt;</bpt>Item<bpt i="2" x="2">&lt;w2&gt;</bpt>Type<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Encodable<ept i="3">&lt;/c3&gt;</ept>に準拠している時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Music<bpt i="1" x="1">&lt;w1&gt;</bpt>Item<bpt i="2" x="2">&lt;w2&gt;</bpt>Type<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Music<bpt i="1" x="1">&lt;w1&gt;</bpt>Item<bpt i="2" x="2">&lt;w2&gt;</bpt>Type<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>に準拠している時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Music<bpt i="1" x="1">&lt;w1&gt;</bpt>Item<bpt i="2" x="2">&lt;w2&gt;</bpt>Type<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Hashable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Music<bpt i="1" x="1">&lt;w1&gt;</bpt>Item<bpt i="2" x="2">&lt;w2&gt;</bpt>Type<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Hashable<ept i="3">&lt;/c3&gt;</ept>に準拠している時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Output<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>Output<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Encodable<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>Failure<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Decodable<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>Failure<ept i="6">&lt;/c6&gt;</ept> conforms to <bpt i="7" x="7">&lt;c7&gt;</bpt>Encodable<ept i="7">&lt;/c7&gt;</ept>, and <bpt i="8" x="8">&lt;c8&gt;</bpt>Failure<ept i="8">&lt;/c8&gt;</ept> conforms to <bpt i="9" x="9">&lt;c9&gt;</bpt>Error<ept i="9">&lt;/c9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Output<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>に準拠する、<bpt i="2" x="2">&lt;c2&gt;</bpt>Output<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Encodable<ept i="3">&lt;/c3&gt;</ept>に準拠する、<bpt i="4" x="4">&lt;c4&gt;</bpt>Failure<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Decodable<ept i="5">&lt;/c5&gt;</ept>に準拠する、<bpt i="6" x="6">&lt;c6&gt;</bpt>Failure<ept i="6">&lt;/c6&gt;</ept>が<bpt i="7" x="7">&lt;c7&gt;</bpt>Encodable<ept i="7">&lt;/c7&gt;</ept>に準拠する、そして<bpt i="8" x="8">&lt;c8&gt;</bpt>Failure<ept i="8">&lt;/c8&gt;</ept>が<bpt i="9" x="9">&lt;c9&gt;</bpt>Error<ept i="9">&lt;/c9&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Output<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>Output<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Encodable<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>Failure<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Decodable<ept i="5">&lt;/c5&gt;</ept>, and <bpt i="6" x="6">&lt;c6&gt;</bpt>Failure<ept i="6">&lt;/c6&gt;</ept> conforms to <bpt i="7" x="7">&lt;c7&gt;</bpt>Encodable<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Output<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>に準拠する、<bpt i="2" x="2">&lt;c2&gt;</bpt>Output<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Encodable<ept i="3">&lt;/c3&gt;</ept>に準拠する、<bpt i="4" x="4">&lt;c4&gt;</bpt>Failure<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Decodable<ept i="5">&lt;/c5&gt;</ept>に準拠する、そして<bpt i="6" x="6">&lt;c6&gt;</bpt>Failure<ept i="6">&lt;/c6&gt;</ept>が<bpt i="7" x="7">&lt;c7&gt;</bpt>Encodable<ept i="7">&lt;/c7&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Output<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Output<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Prefix<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Suffix<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Prefix<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="2" x="2">&lt;c2&gt;</bpt>Suffix<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Signed<bpt i="1" x="1">&lt;w1&gt;</bpt>Type<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt>Custom<bpt i="3" x="3">&lt;w3&gt;</bpt>Debug<bpt i="4" x="4">&lt;w4&gt;</bpt>String<bpt i="5" x="5">&lt;w5&gt;</bpt>Convertible<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Signed<bpt i="1" x="1">&lt;w1&gt;</bpt>Type<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Custom<bpt i="3" x="3">&lt;w3&gt;</bpt>Debug<bpt i="4" x="4">&lt;w4&gt;</bpt>String<bpt i="5" x="5">&lt;w5&gt;</bpt>Convertible<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Signed<bpt i="1" x="1">&lt;w1&gt;</bpt>Type<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt>Equatable<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Signed<bpt i="1" x="1">&lt;w1&gt;</bpt>Type<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Equatable<ept i="2">&lt;/c2&gt;</ept>に準拠している時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Signed<bpt i="1" x="1">&lt;w1&gt;</bpt>Type<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt>Hashable<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Signed<bpt i="1" x="1">&lt;w1&gt;</bpt>Type<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Hashable<ept i="2">&lt;/c2&gt;</ept>に準拠している時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Success<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Failure<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Success<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="2" x="2">&lt;c2&gt;</bpt>Failure<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Success<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Failure<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Hashable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Success<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="2" x="2">&lt;c2&gt;</bpt>Failure<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Hashable<ept i="3">&lt;/c3&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Upstream<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Other<ept i="2">&lt;/c2&gt;</ept> conforms to <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Upstream<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="2" x="2">&lt;c2&gt;</bpt>Other<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Upstream<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Upstream<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Output<ept i="4">&lt;/c4&gt;</ept> conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Equatable<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Upstream<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠するそして<bpt i="2" x="2">&lt;c2&gt;</bpt>Upstream<ept i="2">&lt;/c2&gt;</ept><bpt i="3" x="3">&lt;c3&gt;</bpt>.<ept i="3">&lt;/c3&gt;</ept><bpt i="4" x="4">&lt;c4&gt;</bpt>Output<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>Equatable<ept i="5">&lt;/c5&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Upstream<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Upstream<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Value<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Bidirectional<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>Mutable<bpt i="4" x="4">&lt;w4&gt;</bpt>Collection<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Value<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Bidirectional<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>Mutable<bpt i="4" x="4">&lt;w4&gt;</bpt>Collection<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Value<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Value<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Value<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Value<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Value<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Identifiable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Value<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Identifiable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Value<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Mutable<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Value<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Mutable<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Decodable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Encodable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>に準拠する時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<bpt i="1" x="1">&lt;w1&gt;</bpt>Element<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt>Decodable<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<bpt i="1" x="1">&lt;w1&gt;</bpt>Element<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Decodable<ept i="2">&lt;/c2&gt;</ept>に準拠している時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<bpt i="1" x="1">&lt;w1&gt;</bpt>Element<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt>Encodable<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<bpt i="1" x="1">&lt;w1&gt;</bpt>Element<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Encodable<ept i="2">&lt;/c2&gt;</ept>に準拠している時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<bpt i="1" x="1">&lt;w1&gt;</bpt>Element<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt>Equatable<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<bpt i="1" x="1">&lt;w1&gt;</bpt>Element<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Equatable<ept i="2">&lt;/c2&gt;</ept>に準拠している時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conforms when <bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<bpt i="1" x="1">&lt;w1&gt;</bpt>Element<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt>Hashable<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<bpt i="1" x="1">&lt;w1&gt;</bpt>Element<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Hashable<ept i="2">&lt;/c2&gt;</ept>に準拠している時に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Consider a class called <bpt i="0" x="0">&lt;c0&gt;</bpt>Integer<bpt i="1" x="1">&lt;w1&gt;</bpt>Ref<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> that wraps an integer value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Integer<bpt i="1" x="1">&lt;w1&gt;</bpt>Ref<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と呼ばれるクラスを考えてください、それはある整数値をラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Consider the following recommendations to help choose which option makes sense when adding a new data type to your app.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の忠告を考慮して、どちらの選択が道理にかなっているか、新しいデータ型をあなたのアプリに追加する時に選択する助けにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Construct a AsyncStream buffering given an Element type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたElement型をバッファするAsyncStreamを組み立てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Construct a AsyncThrowingStream buffering given an Element type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたElement型をバッファするAsyncThrowingStreamを組み立てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Construct an iterator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるイテレータを組み立てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Consult the IEEE 754 standard for additional details.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>IEEE 754標準をさらなる詳細として参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Continuations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>さまざまな継続</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conversely, because a forward or bidirectional collection must traverse the entire collection to count the number of contained elements, accessing its <bpt i="1" x="1">&lt;c1&gt;</bpt>count<ept i="1">&lt;/c1&gt;</ept> property is an O(<bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept>) operation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>反対に、前方または双方向性のコレクションはコレクション全体を辿っていくことで含まれる要素の数を数えるので、それの<bpt i="1" x="1">&lt;c1&gt;</bpt>count<ept i="1">&lt;/c1&gt;</ept>プロパティにアクセスすることはO(<bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept>)演算になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conversion from a pointer to an integer value with the bit pattern of the pointer’s address in memory, or vice versa.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるポインタからそのポインタのもつメモリでのアドレスのビットパターンをもつ整数値への変換、またはその逆。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Convert Unmanaged Objects to Memory-Managed Objects</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>管理されないオブジェクトをメモリ管理オブジェクトに変換する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Converting Between Arrays and Create ML Types</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列間で変換するそしてML型を作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Converting Between Dictionaries and Create ML Types</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書の間で変換してML型を作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Converting Between Numeric Types</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>数値型の間で変換する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Converting Floating-Point Values</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>浮動小数点値の変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Converting Integers</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>整数の変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Converting Pointers</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ポインタの変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Converting Ranges</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲を変換する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Converting Strings</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>文字列の変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Converting an NSNumber to a Boolean</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>NSNumberをブールに変換する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Converting with No Loss of Precision</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>精度の損失なしに変換する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Core Foundation objects returned from annotated APIs are automatically memory-managed in Swift—you don't need to invoke the <bpt i="0" x="0">&lt;c0&gt;</bpt>CFRetain<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>CFRelease<ept i="1">&lt;/c1&gt;</ept>, or <bpt i="2" x="2">&lt;c2&gt;</bpt>CFAutorelease<ept i="2">&lt;/c2&gt;</ept> functions yourself.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>注釈をつけられたAPIから返されるCore Foundationオブジェクトは、自動的にSwiftにおいてメモリ管理されます ― あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>CFRetain<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>CFRelease<ept i="1">&lt;/c1&gt;</ept>、または<bpt i="2" x="2">&lt;c2&gt;</bpt>CFAutorelease<ept i="2">&lt;/c2&gt;</ept>関数をあなた自身で呼び出す必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Create a Singleton</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シングルトンの作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Create a new dictionary by using a dictionary literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい辞書を辞書リテラルを使って作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Create a new range using the closed range operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>...<ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい範囲を完結範囲演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>...<ept i="0">&lt;/c0&gt;</ept>）を使って作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Create a slice of the <bpt i="0" x="0">&lt;c0&gt;</bpt>absences<ept i="0">&lt;/c0&gt;</ept> array starting after the index found in step 1.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>absences<ept i="0">&lt;/c0&gt;</ept>配列のスライスを、手順１で見つけたインデックスの後から開始して作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Create a slice of the <bpt i="0" x="0">&lt;c0&gt;</bpt>absences<ept i="0">&lt;/c0&gt;</ept> array that holds the second half of the days.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>学期後半の日付を保持する、<bpt i="0" x="0">&lt;c0&gt;</bpt>absences<ept i="0">&lt;/c0&gt;</ept>配列のスライスを作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Create an enumeration that conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Error<ept i="0">&lt;/c0&gt;</ept> protocol with a case for each possible error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Error<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する列挙を、各ありうるエラーに対して１つのケース節で作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Create instances of <bpt i="1" x="1">&lt;c1&gt;</bpt>Bool<ept i="1">&lt;/c1&gt;</ept> by using one of the Boolean literals <bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>, or by assigning the result of a Boolean method or operation to a variable or constant.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Bool<ept i="1">&lt;/c1&gt;</ept>のインスタンスをブールリテラルの<bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>または<bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>のうち１つを使うことによって、またはブールのメソッドや演算の結果を変数や定数に代入することによって作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Create new instances of floating-point types using integer or floating-point literals.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>浮動小数点型の新しいインスタンスを、整数または浮動小数点リテラルを使って作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a Boolean from an integer wrapped in a data value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるブールをあるデータ値の中にラップされる整数から作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a NaN (“not a number”) value with the specified payload.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定されたペイロードをもつNaN（「非数」）値を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a character containing the given Unicode scalar value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたユニコードスカラー値を含んでいるひとつの文字を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a character from a single-character string.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある単一文字の文字列から１つの文字を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a character with the specified value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された値でひとつの文字を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a checked continuation from an unsafe continuation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>検査済み継続を非安全継続から作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a collection containing the specified number of the given element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された数の与えられた要素を含んでいるコレクションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a dictionary by merging key-value pairs in a sequence into the dictionary, using a combining closure to determine the value for duplicate keys.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある辞書を作成します、あるシーケンスの中のキー値ペアをその辞書に合併させることによってです、結合用のクロージャを使って重複キーに対する値を決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a dictionary by merging the given dictionary into this dictionary, using a combining closure to determine the value for duplicate keys.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた辞書をこの辞書へと結合することによって１つの辞書を作成します、結び付けられているクロージャを使って何らかの重複キーに対して値を決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a dictionary initialized with a dictionary literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書リテラルで初期化される辞書を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a dictionary that contains the keys and values from an attribute container, using a specified attribute scope.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある辞書を作成します、それはキーと値をある属性コンテナから含むものです、ある指定された属性スコープを使っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a dictionary that contains the keys and values from an attribute container, using an attribute scope that a key path identifies.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある辞書を作成します、それはキーと値をある属性コンテナから含むものです、ある属性スコープを使っていてそれはあるキーパスを識別します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a double from another double wrapped in a data value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるdoubleをデータ値の中にラップされる別のdoubleから作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new Boolean value from the given string.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた文字列から新しいブール値を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new array by decoding from the given decoder.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい配列を指定のエンコーダからエンコードすることによって作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new array containing the specified number of a single, repeated value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された数の、ある単一の値の繰り返しを含んでいる新しい配列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new collection by concatenating the elements of a collection and a sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるコレクションとあるシーケンスの要素を連結することによって新しいコレクションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new collection by concatenating the elements of a sequence and a collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンスとあるコレクションの要素を連結することによって新しいコレクションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new collection by concatenating the elements of two collections.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つのコレクションの要素を連結することによって新しいコレクションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new collection difference from a collection of changes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいコレクション差異を、変更それらからなるあるコレクションから作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new context with the given path of coding keys and a description of what went wrong.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたコーディングキーのパスと何がうまくいかなかったかの説明で新しいコンテキストを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new contiguous array by decoding from the given decoder.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい隣接配列をこの与えられたデコーダから復号することによって作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new dictionary by decoding from the given decoder.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい辞書を、指定のデコーダからデコードすることによって作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new dictionary from the key-value pairs in the given sequence, using a combining closure to determine the value for any duplicate keys.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい辞書を、与えられたシーケンスの中のキー値ペアから作成します、結合用のクロージャを使って何らかの重複キーに対して値を決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new dictionary from the key-value pairs in the given sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい辞書を、与えられたシーケンスの中のキー値ペアから作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new dictionary whose keys are the groupings returned by the given closure and whose values are arrays of the elements that returned each key.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい辞書を作成します、それのキーは与えられたクロージャによって返されるグループ分けです、そしてそれの値はいくらかの要素からなる配列で、それが各キーで返されるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new floating-point value using the sign of one value and the magnitude of another.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値の符号ともう一方の規模とを使って新しい浮動小数点値を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new hasher.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいハーシャーを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new index wrapping <bpt i="0" x="0">&lt;c0&gt;</bpt>base<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>base<ept i="0">&lt;/c0&gt;</ept>をラップしている新しいインデックスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance by decoding from the given decoder.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたデコーダからデコードすることで新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance from an interpolated string literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいインスタンスを補間文字列リテラルから作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance from the bit pattern of the given instance by sign-extending or truncating to fit this type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型に適合するように符号拡張または切り詰めることによって、指定インスタンスのビットパターンから新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance from the bit pattern of the given instance by truncating or sign-extending if needed to fit this type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>もしこの型に適合するのに必要ならば切り詰めるか符号拡張によって、指定インスタンスのビットパターンから新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance from the given integer, if it can be represented exactly.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた整数から新しいインスタンスを作成します、もしそれが正確に表現できるならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance from the given integer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた整数から新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance from the given string.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた値から新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance from the given value, if it can be represented exactly.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいインスタンスをこの与えられた値から作成します、もしそれが正確に表現できるならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance from the given value, rounded to the closest possible representation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた値から新しいインスタンスを作成します、最も近い可能な表現に丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance from the specified integer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された整数から新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance from the specified sign and bit patterns.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された符号とビットパターンから新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance initialized to the given value, if it can be represented without rounding.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それが丸めなしに表されるならば、与えられた値に初期化される新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance initialized to the given value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた値に初期化される新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance of a collection containing the elements of a sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンスの要素を含んでいるあるコレクションの新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance that approximates the given value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた値におおよそ相当する新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance with the given raw value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた生の値で新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance with the representable value that’s closest to the given integer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた整数に最も近い表現可能な値を使って新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance with the same memory representation as the given value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた値と同じメモリ表現で新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new instance with the specified raw value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された生の値を持つ新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new integer value from the given string and radix.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた文字列と基数から新しい整数値を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new integer value from the given string.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた文字列から新しい整数値を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new pointer from the given address, specified as a bit pattern.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいポインタをこの与えられたアドレスから作成します、ビットパターンとして指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new pointer from the given pointer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいボインタをこの与えられたポインタから作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new sequence that wraps and forwards operations to <bpt i="0" x="0">&lt;c0&gt;</bpt>base<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>base<ept i="0">&lt;/c0&gt;</ept>をラップしてそれへと演算を転送する新規シーケンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new typed pointer from the given opaque pointer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた不透明ポインタから新しい型付ポインタを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new value equal to zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ゼロに等しい新しい値を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new value from the given sign, exponent, and significand.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた符号、指数、そして仮数から新しい値を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new value with the bit pattern of the given pointer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたポインタのビットパターンで新しい値を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new value with the given bit pattern.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたビットパターンから新しい値を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new value, if the given integer can be represented exactly.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた整数が正確に表現できるならば、新しい値を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new value, rounded to the closest possible representation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい値を作成します、最も近い可能な表現へ丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new vector by decoding scalars from the given decoder.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある新しいベクターをこの与えられたデコーダからスカラーをデコードすることによって作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a new, empty array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい、空の配列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a sequence of pairs built out of two underlying sequences.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの根底にあるシーケンスから組み立てられるペアからなるシーケンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a sequence whose <bpt i="0" x="0">&lt;c0&gt;</bpt>make<bpt i="1" x="1">&lt;w1&gt;</bpt>Iterator()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method forwards to <bpt i="2" x="2">&lt;c2&gt;</bpt>make<bpt i="3" x="3">&lt;w3&gt;</bpt>Underlying<bpt i="4" x="4">&lt;w4&gt;</bpt>Iterator<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それの<bpt i="0" x="0">&lt;c0&gt;</bpt>make<bpt i="1" x="1">&lt;w1&gt;</bpt>Iterator()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを<bpt i="2" x="2">&lt;c2&gt;</bpt>make<bpt i="3" x="3">&lt;w3&gt;</bpt>Underlying<bpt i="4" x="4">&lt;w4&gt;</bpt>Iterator<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>へと転送するあるシーケンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a set containing the elements of the given array literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた配列リテラルの要素を含んでいる集合を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a string interpolation with storage pre-sized for a literal with the indicated attributes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるリテラルに対してあらかじめサイズ指定されるストレージで、指し示される属性で、文字列補間を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a type-erased collection that wraps the given collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたコレクションをラップする型消去コレクションを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a type-erased hashable value that wraps the given instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型消去ハッシュ可能値を作成します、それは与えられたインスタンスをラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a value initialized to zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ゼロに初期化される値を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a vector from the specified elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるベクターをこの指定された要素それらから作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates a vector with zero in all lanes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるベクターを全レーンにおいてゼロで作成します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an <bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Bidirectional<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> having the same underlying collection as <bpt i="3" x="3">&lt;c3&gt;</bpt>other<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Bidirectional<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を作成します、<bpt i="3" x="3">&lt;c3&gt;</bpt>other<ept i="3">&lt;/c3&gt;</ept>と同じ基礎をなすコレクションを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an <bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Collection<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> having the same underlying collection as <bpt i="2" x="2">&lt;c2&gt;</bpt>other<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Collection<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を作成します、<bpt i="2" x="2">&lt;c2&gt;</bpt>other<ept i="2">&lt;/c2&gt;</ept>と同じ基礎をなすコレクションを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an <bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Random<bpt i="2" x="2">&lt;w2&gt;</bpt>Access<bpt i="3" x="3">&lt;w3&gt;</bpt>Collection<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> having the same underlying collection as <bpt i="4" x="4">&lt;c4&gt;</bpt>other<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Random<bpt i="2" x="2">&lt;w2&gt;</bpt>Access<bpt i="3" x="3">&lt;w3&gt;</bpt>Collection<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を作成します、<bpt i="4" x="4">&lt;c4&gt;</bpt>other<ept i="4">&lt;/c4&gt;</ept>と同じ基盤コレクションを持っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an array containing the elements of a sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンスの要素を含んでいる配列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an array from a column in a machine learning data table.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>機械学習データテーブルの縦列から配列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an array from a data-value dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列をデータ値辞書から作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an array from a dictionary wrapped in a data value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある配列をあるデータ値の中にラップされる辞書から作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an array from a sequence wrapped in a data value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある配列をあるデータ値の中にラップされるシーケンスから作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an array from an untyped column in a machine learning data table.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>機械学習データテーブルの型無し縦列から配列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an array from the given array literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された配列リテラルから配列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an array with the specified capacity, then calls the given closure with a buffer covering the array’s uninitialized memory.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい配列をこの指定された収納能力で作成します、それから与えられたクロージャを、配列のもつ初期化されないメモリを含むバッファで呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an asynchronous sequence that concatenates the results of calling the given error-throwing transformation with each element of this sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある非同期シーケンスを作成します、それは与えられたエラースロー変換をこのシーケンスの各要素で呼び出すことの結果を連結します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an asynchronous sequence that concatenates the results of calling the given transformation with each element of this sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある非同期シーケンスを作成します、それは与えられた変換をこのシーケンスの各要素で呼び出すことの結果を連結します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given error-throwing predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある非同期シーケンスを作成します、それは基底シーケンスの要素それらを、順番に含みます、それらは与えられたエラースロー述部を満たすものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an asynchronous sequence that contains, in order, the elements of the base sequence that satisfy the given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある非同期シーケンスを作成します、それは基底シーケンスの要素それらを、順番に含みます、それらは与えられた述部を満たすものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an asynchronous sequence that maps an error-throwing closure over the base sequence’s elements, omitting results that don’t return a value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある非同期シーケンスを作成します、それはあるエラースロークロージャを基底シーケンスのもつ要素のすべてにわたってマップします、値を返さない結果を省きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements, omitting results that don’t return a value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある非同期シーケンスを作成します、それは与えられたクロージャを非同期シーケンスのもつ要素のすべてにわたってマップします、値を返さない結果を省きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an asynchronous sequence that maps the given closure over the asynchronous sequence’s elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある非同期シーケンスを作成します、それは与えられたクロージャを非同期シーケンスのもつ要素のすべてにわたってマップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an asynchronous sequence that maps the given error-throwing closure over the asynchronous sequence’s elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある非同期シーケンスを作成します、それは与えられたエラースロークロージャを非同期シーケンスのもつ要素のすべてにわたってマップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an empty dictionary with preallocated space for at least the specified number of elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>空の辞書を、あらかじめアロケートされたスペースで少なくとも指定された要素数に対して作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an empty dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>空の辞書を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an instance containing just the given element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた要素だけを含んでいるインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an instance equal to the given Boolean value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたブール値と同じインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an instance equivalent to the given <bpt i="0" x="0">&lt;c0&gt;</bpt>Range<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた<bpt i="0" x="0">&lt;c0&gt;</bpt>Range<ept i="0">&lt;/c0&gt;</ept>と等しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an instance from a string interpolation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある文字列補間からインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an instance initialized to <bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>に初期化されるインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an instance initialized to the given Boolean value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたブール値に初期化されるインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an instance initialized to the given string value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた文字列値へ初期化されるインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an instance initialized to the given value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた値に初期化されるインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an instance initialized to the specified Boolean literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定されたブールリテラルに初期化されるインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an instance initialized to the specified floating-point value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された浮動小数点値に初期化されるインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an instance initialized to the specified integer value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された整数値に初期化されるインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an instance initialized with <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>で初期化されるインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an instance initialized with the given elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた要素で初期化されるインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an instance initialized with the given key-value pairs.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた「キー値」ペアで初期化されるインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an instance of the drop-while sequence iterator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>drop-whileシーケンスイテレータのあるインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an instance with the given bounds.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた境界を使ってインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>１つのインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an integer from another integer wrapped in a data value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある整数をデータ値の中にラップされる別の整数から作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an integer from its big-endian representation, changing the byte order if necessary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それのビッグエンディアン表現から整数を作成します、必要ならばバイト順を変更します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an integer from its little-endian representation, changing the byte order if necessary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それのリトルエンディアン表現から整数を作成します、必要ならばバイト順を変更します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an integer from the given floating-point value, if it can be represented exactly.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた浮動小数点値から整数を作成します、もしそれが正確に表現可能ならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an integer from the given floating-point value, rounding toward zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた浮動小数点値から整数を作成します、ゼロへの丸めを行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an integer that captures the full value of the given object identifier.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたオブジェクト識別子の完全な値を捕獲する整数を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an iterator that wraps a base iterator but whose type depends only on the base iterator’s element type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>基盤イテレータをラップするイテレータを作成します、しかしそれの型は基盤イテレータのもつ要素型にのみ影響を受けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates an iterator that wraps the given closure in its <bpt i="0" x="0">&lt;c0&gt;</bpt>next()<ept i="0">&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたクロージャをそれの<bpt i="0" x="0">&lt;c0&gt;</bpt>next()<ept i="0">&lt;/c0&gt;</ept>の中にラップするイテレータを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creates the asynchronous iterator that produces elements of this asynchronous sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>非同期イテレータを作成します、それはこの非同期シーケンスの要素を取り出すものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creating a Binary Integer</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２進整数を作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creating a Boolean From Another Value</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>別の値からあるブールを作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creating a Character</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある文字を作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creating a Dictionary</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書の作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creating a Dictionary from an Attribute Container</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書を属性コンテナから作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creating a Hasher</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ハーシャーを作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creating a Random Integer</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>無作為な整数を作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creating a Random Value</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>無作為な値を作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creating a Range</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲を作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creating a Range Expression</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲式を作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creating a Type That Supports Custom String Interpolation</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あつらえの文字列補間をサボートする型を作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creating a Type That Supports the Default String Interpolation</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時の文字列補間をサポートする型を作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creating an Array</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列の作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creating an Iterator</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>イテレータを作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creating and Applying Differences</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>差異の作成と適用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Custom Encoding and Decoding</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>カスタムエンコーディングとデコーディング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Customize NSObject Subclass Behavior</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>NSObjectサブクラス挙動をカスタマイズする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Customizing Your Type's Reflection</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたの型のリフレクションのカスタマイズ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Data Flow and Control Flow</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>データの流れと制御の流れ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Data Modeling</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>データモデリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Debugging and Reflection</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>デバッグとリフレクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Decide how to store data and model behavior.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>どのようにデータを格納して挙動をモデル化するか決定を下します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Decimal floating-point types admit a large number of non-canonical encodings.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>10進浮動小数点型は、多数の非正準エンコーディングを認めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Declaration</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Declarations marked with the <bpt i="3" x="3">&lt;c3&gt;</bpt>private<ept i="3">&lt;/c3&gt;</ept> or <bpt i="4" x="4">&lt;c4&gt;</bpt>fileprivate<ept i="4">&lt;/c4&gt;</ept> modifier don't appear in the generated header, and aren't exposed to the Objective-C runtime unless they are explicitly marked with a <bpt i="5" x="5">&lt;c5&gt;</bpt>@IBAction<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>@IBOutlet<ept i="6">&lt;/c6&gt;</ept>, or <bpt i="7" x="7">&lt;c7&gt;</bpt>@objc<ept i="7">&lt;/c7&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>private<ept i="3">&lt;/c3&gt;</ept>または<bpt i="4" x="4">&lt;c4&gt;</bpt>fileprivate<ept i="4">&lt;/c4&gt;</ept>修飾子で印された宣言は生成されたヘッダに現れません、そしてObjective-Cランタイムに露出されません、それらが明示的に<bpt i="5" x="5">&lt;c5&gt;</bpt>@IBAction<ept i="5">&lt;/c5&gt;</ept>、<bpt i="6" x="6">&lt;c6&gt;</bpt>@IBOutlet<ept i="6">&lt;/c6&gt;</ept>、または<bpt i="7" x="7">&lt;c7&gt;</bpt>@objc<ept i="7">&lt;/c7&gt;</ept>属性で印されない限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Declaring Iterator Topography</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>イテレータの構造的特徴を宣言する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Declaring conformance to the <bpt i="0" x="0">&lt;c0&gt;</bpt>CVar<bpt i="1" x="1">&lt;w1&gt;</bpt>Arg<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol for types defined outside the standard library is not supported.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>標準ライブラリ外で定義される型に対して<bpt i="0" x="0">&lt;c0&gt;</bpt>CVar<bpt i="1" x="1">&lt;w1&gt;</bpt>Arg<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルへの準拠を宣言することは、サポートされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Default Implementations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Default Literal Types</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時のリテラル型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Define an Observer</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オブザーバを定義する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Delegate methods can customize how an app responds to an event.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>委任先メソッドは、どのようにアプリがイベントに応答するかをカスタマイズできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Depending on the size and span of <bpt i="2" x="2">&lt;c2&gt;</bpt>range<ept i="2">&lt;/c2&gt;</ept>, some concrete values may be represented more frequently than others.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>range<ept i="2">&lt;/c2&gt;</ept>の大きさと幅に依存して、いくつかの具体的な値は他のものよりずっと頻繁に表現されるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Depending on the size and span of <bpt i="3" x="3">&lt;c3&gt;</bpt>range<ept i="3">&lt;/c3&gt;</ept>, some concrete values may be represented more frequently than others.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>range<ept i="3">&lt;/c3&gt;</ept>の大きさと幅に依存して、いくつかの具体的な値は他のものよりずっと頻繁に表現されるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Deprecated</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>非推奨</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Describing a Boolean</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ブールを記述する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Describing a Character</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある文字の説明</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Describing a Dictionary</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある辞書の記述</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Describing a Double</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるDoubleの記述</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Describing a Float</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Floatを記述する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Describing a Range</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲を記述する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Describing an Array</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列を記述する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Describing an Error</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>エラーを記述する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Describing an Integer</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>整数を記述する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Diagram showing the steps to import Objective-C declarations into Swift code.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>図はObjective-C宣言をSwiftコードにインポートする行程を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Dictionaries are empty when created with an initializer or an empty dictionary literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書は、イニシャライザまたは空の辞書リテラルで作成した場合は空です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Dictionary has two subscripting interfaces:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書は２つの添え字インターフェイスを持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Digest Implementations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要約実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Discussion</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>解説</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Divides the first value by the second and stores the quotient in the left-hand-side variable, rounding to a representable value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最初の値を２番目の値で除算して、商を左手側の変数に格納します、表現可能な値へ丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Divides the first value by the second and stores the quotient in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最初の値を２番目の値で除算して、商を左手側の変数に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Divides the first value by the second and stores the remainder in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最初の値を２番目の値で除算して、余りを左手側の変数に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Dividing by zero is not an error when using this method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ゼロによる除算は、このメソッドを使う場合はエラーではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Do not call this initializer directly.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザを直接に呼ばないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Do not call this method directly.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを直接に呼ばないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Do not create an instance of this type directly.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型のインスタンスを直接に作成しないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Do not escape it from the closure for later use.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それを後で使うためにクロージャから脱出させないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Do not rely on <bpt i="2" x="2">&lt;c2&gt;</bpt>Any<bpt i="3" x="3">&lt;w3&gt;</bpt>Hashable<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> generating such compatible hashes, as the hash encoding that it uses may change between any two releases of the standard library.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Any<bpt i="3" x="3">&lt;w3&gt;</bpt>Hashable<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>がこのような比較可能ハッシュを生成することを当てにしないでください、それが使うハッシュ符号化が標準ライブラリの何らかの２つのリリースの間に変化するかもしれないので。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Do not rely on a previously stored index value after altering a collection with any operation that can change its length.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるコレクションをそれの長さを変える何らかの演算で手直し後に、以前に格納されたインデックス値を当てにしないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Do not rely on anything about the array that is the target of this method during execution of the <bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept> closure; it might not appear to have its correct value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドのターゲットである配列について<bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept>クロージャの実行の間に何であれ依存しないでください：それは、それの正しい値を持つように見えないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Do not save hash values to use during a future execution.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>将来の実行の間に使うためにハッシュ値を保存しないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Do not save or otherwise reuse hash values across executions of your program.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのプログラムの実行それらにまたがってハッシュ値を保存または別なふうに再利用しないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Do not store or return the pointer for later use.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>後で使うためにポインタを格納したり返したりしないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Do not use <bpt i="6" x="6">&lt;c6&gt;</bpt>unsafe<bpt i="7" x="7">&lt;w7&gt;</bpt>Bit<bpt i="8" x="8">&lt;w8&gt;</bpt>Cast(_:<bpt i="9" x="9">&lt;w9&gt;</bpt>to:)<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> with class or pointer types; doing so may introduce undefined behavior.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt>unsafe<bpt i="7" x="7">&lt;w7&gt;</bpt>Bit<bpt i="8" x="8">&lt;w8&gt;</bpt>Cast(_:<bpt i="9" x="9">&lt;w9&gt;</bpt>to:)<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>をクラスまたはポインタ型で使わないでください；そうすることは未定義挙動を導きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Do not use this subscript to modify dictionary values if the dictionary’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Value<ept i="0">&lt;/c0&gt;</ept> type is a class.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この添え字を使って、辞書値を修正しないでください、もしその辞書の持つ<bpt i="0" x="0">&lt;c0&gt;</bpt>Value<ept i="0">&lt;/c0&gt;</ept>型がクラスであるならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Doesn’t check for cancellation, and always executes the passed <bpt i="0" x="0">&lt;c0&gt;</bpt>operation<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>取り消しを調べないでください、そして常に渡された<bpt i="0" x="0">&lt;c0&gt;</bpt>operation<ept i="0">&lt;/c0&gt;</ept>を遂行してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Doing so may become a compile-time error in the future.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そうすることは、コンパイル時エラーに将来はなるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Don’t call this initializer directly.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザを直に呼ばないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Don’t expect any particular ordering of key-value pairs.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>何らかの特定のキー値ペア順番付けを当てにしないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Don’t store an unsafe task handle for use outside this method’s closure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>非安全タスクハンドルをこのメソッドのもつクロージャの外側で使うために格納しないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Don’t use the equal-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept>) to test whether a value is NaN.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同等演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept>を使ってある値がNaNかどうかをテストしないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Don’t use this property to check whether a floating point value is negative.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このプロパティを使って浮動小数点値が負かどうか調べないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Downcast Objects to Call Methods and Access Properties</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オブジェクトをダウンキャストしてメソッドの呼び出しおよびプロパティにアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Dumps the given object’s contents using its mirror to standard output.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたオブジェクトの内容をそれのミラーを使って標準出力にダンプします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Dumps the given object’s contents using its mirror to the specified output stream.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたオブジェクトの内容をそれのミラーを使って指定出力ストリームにダンプします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>During the registration period, you need to add and remove names as students add and drop the class.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>履修期間の間、あなたはそのクラスに生徒を加えたり落としたりするたびに名前を加えたり取り除いたりする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Dynamic Sequences</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>動的なシーケンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Each array has an independent value that includes the values of all of its elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>各配列はひとつの独立した値を持ち、それはそれのいくらかある要素の値すべてを含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Each element of the result is the maximum of the corresponding elements of the inputs.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果の各要素は、入力の対応する要素それらの最大です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Each element of the result is the minimum of the corresponding elements of the inputs.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果の各要素は、入力の対応する要素それらの最小です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Each entry in the table is identified using its key, which is a hashable type such as a string or number.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのテーブル（表）の中の登録項目はそれのキーを使って特定され、そのキーはハッシュ化型、例えば文字列や数などです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Each floating-point type has its own possible range and precision.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>各浮動小数点型は、それ独自の可能な範囲と精度を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Each key in <bpt i="0" x="0">&lt;c0&gt;</bpt>elements<ept i="0">&lt;/c0&gt;</ept> must be unique.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>各キーは<bpt i="0" x="0">&lt;c0&gt;</bpt>elements<ept i="0">&lt;/c0&gt;</ept>において特有でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Each key in the keys collection has a unique value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このキーコレクションの中の各キーは、特有な値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Each value in the sequence is separated by <bpt i="2" x="2">&lt;c2&gt;</bpt>stride<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスの各値は、<bpt i="2" x="2">&lt;c2&gt;</bpt>stride<ept i="2">&lt;/c2&gt;</ept>によって隔てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Each value in the sequence steps by <bpt i="2" x="2">&lt;c2&gt;</bpt>stride<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスの各値は、<bpt i="2" x="2">&lt;c2&gt;</bpt>stride<ept i="2">&lt;/c2&gt;</ept>だけまたいで越えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Edit the bridging header to expose your Objective-C code to your Swift code:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ブリッジヘッダを編集して、あなたのObjective-CコードをあなたのSwiftコードに露出してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Either <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>, randomly chosen with equal probability.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>のどちらか、等しい確率で無作為に選ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Elements are sorted in ascending order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要素は昇順にソートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Elements that are used to split the collection are not returned as part of any subsequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションを分割するのに使われる要素らは、どれかの下位シーケンスの一部として返されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Elements that are used to split the sequence are not returned as part of any subsequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスを分割するのに使われる要素らは、どれかの下位シーケンスの一部として返されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encoders and Decoders</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>エンコーダとデコーダ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encodes the contents of this dictionary into the given encoder.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この辞書の内容を指定のエンコーダへとエンコードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encodes the elements of this array into the given encoder in an unkeyed container.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この配列の要素を指定されたエンコーダへとあるキー付けされないコンテナにおいてエンコードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encodes the elements of this contiguous array into the given encoder in an unkeyed container.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この隣接配列の要素をこの与えられたエンコーダへとキー付けされないコンテナにおいて符号化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encodes the scalars of this vector into the given encoder in an unkeyed container.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このベクターのスカラーそれらをこの与えられたエンコーダへとキー付けされないコンテナの中に符号化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encodes this value into the given encoder.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値を与えられたエンコーダにエンコードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encoding and Decoding</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>エンコーディングとデコーディング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encoding and Decoding Custom Types</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あつらえの型のエンコーディングとデコーディング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encoding and Decoding Values</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値をエンコードおよびデコードする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encoding and Decoding a Range</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある範囲を符号化そして復号する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Encoding, Decoding, and Serialization</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>エンコード、デコード、そしてシリアライズ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>End of Iteration</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>反復の終わり</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Enumeration Case</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>列挙ケース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Enumeration Cases</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>列挙ケース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Enumerations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Equality and Ordering</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同等性と順序</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Equality implies substitutability—any two instances that compare equally can be used interchangeably in any code that depends on their values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同等性は代替可能性を暗黙的に意味します—同等性を比較されるあらゆる２つのインスタンスは、それらの値に影響を受けるあらゆるコードにおいて入れ替えて使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Equality is Separate From Identity</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同等性は同一性と別個のものです</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Equality is the inverse of inequality.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同等性は、不等性の裏返しです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Equatable Requirements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Equatable 要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Errors and Exceptions</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>エラーと例外</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Essential components are those that contribute to the type’s implementation of <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>本質的な構成要素は、その型のもつ<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>の実装に寄与するそれらです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Evaluates a closure while ensuring that the given instance is not destroyed before the closure returns.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャを評価する一方で与えられたインスタンスがそのクロージャが返る前に破棄されないことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Evaluation of the <bpt i="2" x="2">&lt;c2&gt;</bpt>||<ept i="2">&lt;/c2&gt;</ept> operator is one of the following:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>||<ept i="2">&lt;/c2&gt;</ept>演算子の評価は、次のうちの１つです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Evaluation of the <bpt i="3" x="3">&lt;c3&gt;</bpt>&amp;&amp;<ept i="3">&lt;/c3&gt;</ept> operator is one of the following:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>&amp;&amp;<ept i="3">&lt;/c3&gt;</ept>演算子の評価は、次のうちの１つです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Even though the barrier guarantees that neither closure will escape the function, the <bpt i="6" x="6">&lt;c6&gt;</bpt>async(execute:)<ept i="6">&lt;/c6&gt;</ept> method still requires that the closures passed be marked as <bpt i="7" x="7">&lt;c7&gt;</bpt>@escaping<ept i="7">&lt;/c7&gt;</ept>, so the first version of the function does not compile.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>たとえこの障壁がどちらのクロージャも関数を脱出しないことを保証するとしても、<bpt i="6" x="6">&lt;c6&gt;</bpt>async(execute:)<ept i="6">&lt;/c6&gt;</ept>メソッドは依然としてこれらの渡されるクロージャが<bpt i="7" x="7">&lt;c7&gt;</bpt>@escaping<ept i="7">&lt;/c7&gt;</ept>として印されることを要求します、それで最初のバージョンの関数はコンパイルしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Every <bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept> instance is composed of one or more Unicode scalar values that are grouped together as an <bpt i="1" x="1">&lt;e1&gt;</bpt>extended grapheme cluster<ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>すべての<bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept>インスタンスは、１つの<bpt i="1" x="1">&lt;e1&gt;</bpt>拡張書記素クラスタ<ept i="1">&lt;/e1&gt;</ept>として一緒にまとめられる１つの以上のユニコードスカラー値から構成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Every array reserves a specific amount of memory to hold its contents.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>すべての配列はある特定の量のメモリを確保することでその内容を保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Every dictionary is an unordered collection of key-value pairs.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>すべての辞書は、キー値ペアの順番付けられないコレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Every distinct value of the conforming type has a corresponding unique value of the <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type, but there may be values of the <bpt i="2" x="2">&lt;c2&gt;</bpt>Raw<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type that don’t have a corresponding value of the conforming type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>準拠する型のすべての個々の値は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型の対応する特有な値を持ちます、しかし準拠する型の値に対応しない<bpt i="2" x="2">&lt;c2&gt;</bpt>Raw<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型の値があっても構いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Every element of <bpt i="2" x="2">&lt;c2&gt;</bpt>numbers<ept i="2">&lt;/c2&gt;</ept> up to, but not including, the first negative value is included in the result.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最初の負の値までの、しかしそれを含まない、<bpt i="2" x="2">&lt;c2&gt;</bpt>numbers<ept i="2">&lt;/c2&gt;</ept>のすべての要素は、この結果の中に含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Every key in <bpt i="0" x="0">&lt;c0&gt;</bpt>keys<bpt i="1" x="1">&lt;w1&gt;</bpt>And<bpt i="2" x="2">&lt;w2&gt;</bpt>Values<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be unique.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>keys<bpt i="1" x="1">&lt;w1&gt;</bpt>And<bpt i="2" x="2">&lt;w2&gt;</bpt>Values<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の中のすべてのキーは特有でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Every value except NaN compares less than or equal to <bpt i="0" x="0">&lt;c0&gt;</bpt>+infinity<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>NaNを除くあらゆる値は、<bpt i="0" x="0">&lt;c0&gt;</bpt>+infinity<ept i="0">&lt;/c0&gt;</ept>より少ないか等しいと比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Every value except for NaN and <bpt i="0" x="0">&lt;c0&gt;</bpt>+infinity<ept i="0">&lt;/c0&gt;</ept> compares less than <bpt i="1" x="1">&lt;c1&gt;</bpt>+infinity<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>NaNと<bpt i="0" x="0">&lt;c0&gt;</bpt>+infinity<ept i="0">&lt;/c0&gt;</ept>を除くあらゆる値は、<bpt i="1" x="1">&lt;c1&gt;</bpt>+infinity<ept i="1">&lt;/c1&gt;</ept>より少ないと比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Exact Conversion</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>厳密変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Example:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Exceptional values need not take part in the strict total order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それら普通でない値は、全順序において役割を果たすには及びません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Exchanges the values at the specified indices of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのコレクションの指定インデックスでの値を交換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Exchanges the values of the two arguments.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの引数の値を交換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Excluding Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要素を除外する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Execute an operation with a cancellation handler that’s immediately invoked if the current task is canceled.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>現在のタスクが取り消されるならば直ちに発動されるある取り消しハンドラを備えた操作を遂行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Existential Types</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>存在型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Exiting a Program</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>プログラムの終了</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Expanding this set to include types that represent more than simple Boolean values is discouraged.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>単純なブール値より多く表現する型を含めるためにこの集合を拡大することは推奨されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Expected Performance</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>期待される性能</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Explicit construction from an UnsafeMutablePointer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>UnsafeMutablePointerからの明示的な組み立て。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Exponent</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Exposing nonvalue aspects of <bpt i="2" x="2">&lt;c2&gt;</bpt>Equatable<ept i="2">&lt;/c2&gt;</ept> types other than class identity is discouraged, and any that <bpt i="3" x="3">&lt;e3&gt;</bpt>are<ept i="3">&lt;/e3&gt;</ept> exposed should be explicitly pointed out in documentation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Equatable<ept i="2">&lt;/c2&gt;</ept>型の非値の面を露出することはクラス識別子を除いて推奨されません、そして露出<bpt i="3" x="3">&lt;e3&gt;</bpt>される<ept i="3">&lt;/e3&gt;</ept>ものは何でも、明白に文書において指摘されるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Expressible<bpt i="0" x="0">&lt;w0&gt;</bpt>By<bpt i="1" x="1">&lt;w1&gt;</bpt>Extended<bpt i="2" x="2">&lt;w2&gt;</bpt>Grapheme<bpt i="3" x="3">&lt;w3&gt;</bpt>Cluster<bpt i="4" x="4">&lt;w4&gt;</bpt>Literal Implementations <ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Expressible<bpt i="0" x="0">&lt;w0&gt;</bpt>By<bpt i="1" x="1">&lt;w1&gt;</bpt>Extended<bpt i="2" x="2">&lt;w2&gt;</bpt>Grapheme<bpt i="3" x="3">&lt;w3&gt;</bpt>Cluster<bpt i="4" x="4">&lt;w4&gt;</bpt>Literal実装 <ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Expressible<bpt i="0" x="0">&lt;w0&gt;</bpt>By<bpt i="1" x="1">&lt;w1&gt;</bpt>String<bpt i="2" x="2">&lt;w2&gt;</bpt>Interpolation Implementations <ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Expressible<bpt i="0" x="0">&lt;w0&gt;</bpt>By<bpt i="1" x="1">&lt;w1&gt;</bpt>String<bpt i="2" x="2">&lt;w2&gt;</bpt>Interpolation 実装<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Expressible<bpt i="0" x="0">&lt;w0&gt;</bpt>By<bpt i="1" x="1">&lt;w1&gt;</bpt>String<bpt i="2" x="2">&lt;w2&gt;</bpt>Literal Implementations <ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Expressible<bpt i="0" x="0">&lt;w0&gt;</bpt>By<bpt i="1" x="1">&lt;w1&gt;</bpt>String<bpt i="2" x="2">&lt;w2&gt;</bpt>Literal実装<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Extending default string interpolation behavior</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時の文字列補間挙動を拡張する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Extending the Default Interpolation Behavior</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時の補間挙動を拡張する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Failure to satisfy that assumption is a serious programming error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>了解事項を満たすことの失敗は、重大なプログラミングエラーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Finalizes the hasher state and returns the hash value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ハーシャー状態をファイナライズしてハッシュ値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Finalizing a Hasher</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ハーシャーをファイナライズする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Finalizing consumes the hasher: it is illegal to finalize a hasher you don’t own, or to perform operations on a finalized hasher.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ファイナライズすることは、ハーシャーを消費します：あなたが所有者でないハーシャーをファイナライズすること、またはファイナライズされたハーシャー上で演算を実行することは不正です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Finally, report the average temperature and observation counts:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最後に、平均温度と観測数を報告します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Finding Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要素を見つける</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Finding the Dynamic Type in a Generic Context</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>総称体の文脈において動的型を見つける</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Finding the Sign and Magnitude</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>符号と規模を見つける</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>First Steps</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>初歩</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>First, a set of observations in Celsius is parsed from strings to <bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept> values:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>まず、摂氏での観測の一揃いは、文字列から<bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept>値へ解析されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>First, retrieve a sequence’s iterator, and then call the iterator’s <bpt i="2" x="2">&lt;c2&gt;</bpt>next()<ept i="2">&lt;/c2&gt;</ept> method until it returns <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>まず、あるシーケンスのもつイテレータを見つけて取ってきてください、そしてそのイテレータの持つ<bpt i="2" x="2">&lt;c2&gt;</bpt>next()<ept i="2">&lt;/c2&gt;</ept>メソッドを、それが<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>を返すまで呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Fixed<bpt i="0" x="0">&lt;w0&gt;</bpt>Width<bpt i="1" x="1">&lt;w1&gt;</bpt>Integer Implementations <ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>固定<bpt i="0" x="0">&lt;w0&gt;</bpt>長<bpt i="1" x="1">&lt;w1&gt;</bpt>整数実装<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>FixedWidthInteger Implementations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>固定長整数実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Floating Point</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>浮動小数点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Floating-Point Operators for Double</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Double用の浮動小数点演算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Floating-Point Operators for Float</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Float用の浮動小数点演算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Floating-Point Type Aliases</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>浮動小数点型エイリアス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Floating-Point Values</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>浮動小数点値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Floating-point types are used to represent fractional numbers, like 5.5, 100.0, or 3.14159274.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>浮動小数点型は、5.5、100.0、または3.14159274のような、小数を表すために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Floating-point types represent values that are neither finite numbers nor infinity as NaN, an abbreviation for “not a number.” Comparing a NaN with any value, including another NaN, results in <bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>浮動小数点型は、有限数でも無限大でもない値を「not a number」の略語、NaNで表します。NaNを別のNaNを含む何らかの値と比較することは、<bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>の結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Floating-point values are represented as a <bpt i="0" x="0">&lt;e0&gt;</bpt>sign<ept i="0">&lt;/e0&gt;</ept> and a <bpt i="1" x="1">&lt;e1&gt;</bpt>magnitude<ept i="1">&lt;/e1&gt;</ept>, where the magnitude is calculated using the type’s <bpt i="2" x="2">&lt;e2&gt;</bpt>radix<ept i="2">&lt;/e2&gt;</ept> and the instance’s <bpt i="3" x="3">&lt;e3&gt;</bpt>significand<ept i="3">&lt;/e3&gt;</ept> and <bpt i="4" x="4">&lt;e4&gt;</bpt>exponent<ept i="4">&lt;/e4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>浮動小数点値は、<bpt i="0" x="0">&lt;e0&gt;</bpt>符号<ept i="0">&lt;/e0&gt;</ept>と<bpt i="1" x="1">&lt;e1&gt;</bpt>規模<ept i="1">&lt;/e1&gt;</ept>として表されます、そこにおいて規模はその型のもつ<bpt i="2" x="2">&lt;e2&gt;</bpt>基数<ept i="2">&lt;/e2&gt;</ept>とインスタンスの<bpt i="3" x="3">&lt;e3&gt;</bpt>仮数<ept i="3">&lt;/e3&gt;</ept>と<bpt i="4" x="4">&lt;e4&gt;</bpt>指数<ept i="4">&lt;/e4&gt;</ept>を使って計算されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Floating<bpt i="0" x="0">&lt;w0&gt;</bpt>Point Implementations <ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>浮動小数<bpt i="0" x="0">&lt;w0&gt;</bpt>点実装<ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For <bpt i="5" x="5">&lt;c5&gt;</bpt>nan<ept i="5">&lt;/c5&gt;</ept> or <bpt i="6" x="6">&lt;c6&gt;</bpt>-infinity<ept i="6">&lt;/c6&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt>x<bpt i="8" x="8">&lt;w8&gt;</bpt>.next<bpt i="9" x="9">&lt;w9&gt;</bpt>Down<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> is <bpt i="10" x="10">&lt;c10&gt;</bpt>x<ept i="10">&lt;/c10&gt;</ept> itself.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>nan<ept i="5">&lt;/c5&gt;</ept>または<bpt i="6" x="6">&lt;c6&gt;</bpt>-infinity<ept i="6">&lt;/c6&gt;</ept>に対して、<bpt i="7" x="7">&lt;c7&gt;</bpt>x<bpt i="8" x="8">&lt;w8&gt;</bpt>.next<bpt i="9" x="9">&lt;w9&gt;</bpt>Down<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>は<bpt i="10" x="10">&lt;c10&gt;</bpt>x<ept i="10">&lt;/c10&gt;</ept>それ自身です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For <bpt i="5" x="5">&lt;c5&gt;</bpt>nan<ept i="5">&lt;/c5&gt;</ept> or <bpt i="6" x="6">&lt;c6&gt;</bpt>infinity<ept i="6">&lt;/c6&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt>x<bpt i="8" x="8">&lt;w8&gt;</bpt>.next<bpt i="9" x="9">&lt;w9&gt;</bpt>Up<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> is <bpt i="10" x="10">&lt;c10&gt;</bpt>x<ept i="10">&lt;/c10&gt;</ept> itself.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>nan<ept i="5">&lt;/c5&gt;</ept>または<bpt i="6" x="6">&lt;c6&gt;</bpt>infinity<ept i="6">&lt;/c6&gt;</ept>に対して、<bpt i="7" x="7">&lt;c7&gt;</bpt>x<bpt i="8" x="8">&lt;w8&gt;</bpt>.next<bpt i="9" x="9">&lt;w9&gt;</bpt>Up<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>は<bpt i="10" x="10">&lt;c10&gt;</bpt>x<ept i="10">&lt;/c10&gt;</ept>それ自身です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For Foundation types that <bpt i="0" x="0">&lt;e0&gt;</bpt>aren't<ept i="0">&lt;/e0&gt;</ept> bridged to value types, the Swift overlay renames classes and protocols, as well as related enumerations and constants.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値型にブリッジ<bpt i="0" x="0">&lt;e0&gt;</bpt>されない<ept i="0">&lt;/e0&gt;</ept>Foundation型に対して、Swiftオーバーレイはクラスとプロトコルを改名します、それだけでなく関連する列挙と定数も。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For NaN, both <bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Finite<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>is<bpt i="3" x="3">&lt;w3&gt;</bpt>Infinite<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> are false.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>NaNに対して、<bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Finite<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>および<bpt i="2" x="2">&lt;c2&gt;</bpt>is<bpt i="3" x="3">&lt;w3&gt;</bpt>Infinite<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は、falseです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For a <bpt i="0" x="0">&lt;c0&gt;</bpt>struct<ept i="0">&lt;/c0&gt;</ept>, all its stored properties must conform to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>struct<ept i="0">&lt;/c0&gt;</ept>に対して、すべてのそれの格納プロパティは<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For a <bpt i="0" x="0">&lt;c0&gt;</bpt>struct<ept i="0">&lt;/c0&gt;</ept>, all its stored properties must conform to <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>struct<ept i="0">&lt;/c0&gt;</ept>に対して、すべてのそれの格納プロパティは<bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>に準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For a structure, <bpt i="0" x="0">&lt;e0&gt;</bpt>all<ept i="0">&lt;/e0&gt;</ept> its stored properties must conform to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Hashable<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>構造体に対して、<bpt i="0" x="0">&lt;e0&gt;</bpt>全ての<ept i="0">&lt;/e0&gt;</ept>それの格納プロパティは、<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>および<bpt i="2" x="2">&lt;c2&gt;</bpt>Hashable<ept i="2">&lt;/c2&gt;</ept>に準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For a type <bpt i="1" x="1">&lt;c1&gt;</bpt>F<ept i="1">&lt;/c1&gt;</ept>, positive and negative infinity are represented as <bpt i="2" x="2">&lt;c2&gt;</bpt>F<bpt i="3" x="3">&lt;w3&gt;</bpt>.infinity<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>-F<bpt i="5" x="5">&lt;w5&gt;</bpt>.infinity<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, respectively.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型<bpt i="1" x="1">&lt;c1&gt;</bpt>F<ept i="1">&lt;/c1&gt;</ept>に対して、正と負の無限大はそれぞれ<bpt i="2" x="2">&lt;c2&gt;</bpt>F<bpt i="3" x="3">&lt;w3&gt;</bpt>.infinity<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>-F<bpt i="5" x="5">&lt;w5&gt;</bpt>.infinity<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>のように表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For a type <bpt i="1" x="1">&lt;c1&gt;</bpt>T<ept i="1">&lt;/c1&gt;</ept>, the resulting value is in the range <bpt i="2" x="2">&lt;c2&gt;</bpt>T<bpt i="3" x="3">&lt;w3&gt;</bpt>.min...T<bpt i="4" x="4">&lt;w4&gt;</bpt>.max<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型<bpt i="1" x="1">&lt;c1&gt;</bpt>T<ept i="1">&lt;/c1&gt;</ept>に対して、結果となる値は範囲<bpt i="2" x="2">&lt;c2&gt;</bpt>T<bpt i="3" x="3">&lt;w3&gt;</bpt>.min...T<bpt i="4" x="4">&lt;w4&gt;</bpt>.max<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の中です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For a value <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>, a distance <bpt i="1" x="1">&lt;c1&gt;</bpt>n<ept i="1">&lt;/c1&gt;</ept>, and a value <bpt i="2" x="2">&lt;c2&gt;</bpt>y = x<bpt i="3" x="3">&lt;w3&gt;</bpt>.advanced(by: n)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>x<bpt i="5" x="5">&lt;w5&gt;</bpt>.distance(to: y) == n<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>、隔たり<bpt i="1" x="1">&lt;c1&gt;</bpt>n<ept i="1">&lt;/c1&gt;</ept>、および値<bpt i="2" x="2">&lt;c2&gt;</bpt>y = x<bpt i="3" x="3">&lt;w3&gt;</bpt>.advanced(by: n)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に対して、<bpt i="4" x="4">&lt;c4&gt;</bpt>x<bpt i="5" x="5">&lt;w5&gt;</bpt>.distance(to: y) == n<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For a value <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>, the comparison <bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.sign == .minus<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is not necessarily the same as <bpt i="3" x="3">&lt;c3&gt;</bpt>x &lt; 0<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>に対して、比較<bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.sign == .minus<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>は必ずしも<bpt i="3" x="3">&lt;c3&gt;</bpt>x &lt; 0<ept i="3">&lt;/c3&gt;</ept>と同じではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For a value <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>, the result of <bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.divided<bpt i="3" x="3">&lt;w3&gt;</bpt>Reporting<bpt i="4" x="4">&lt;w4&gt;</bpt>Overflow(by: 0)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>(x, true)<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.divided<bpt i="3" x="3">&lt;w3&gt;</bpt>Reporting<bpt i="4" x="4">&lt;w4&gt;</bpt>Overflow(by: 0)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の結果は<bpt i="5" x="5">&lt;c5&gt;</bpt>(x, true)<ept i="5">&lt;/c5&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For a value <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>, the result of <bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.remainder<bpt i="3" x="3">&lt;w3&gt;</bpt>Reporting<bpt i="4" x="4">&lt;w4&gt;</bpt>Overflow(dividing<bpt i="5" x="5">&lt;w5&gt;</bpt>By: 0)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is <bpt i="6" x="6">&lt;c6&gt;</bpt>(x, true)<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.remainder<bpt i="3" x="3">&lt;w3&gt;</bpt>Reporting<bpt i="4" x="4">&lt;w4&gt;</bpt>Overflow(dividing<bpt i="5" x="5">&lt;w5&gt;</bpt>By: 0)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の結果は<bpt i="6" x="6">&lt;c6&gt;</bpt>(x, true)<ept i="6">&lt;/c6&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For a value <bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept> of a floating-point type <bpt i="2" x="2">&lt;c2&gt;</bpt>F<ept i="2">&lt;/c2&gt;</ept>, the magnitude can be calculated as the following, where <bpt i="3" x="3">&lt;c3&gt;</bpt>**<ept i="3">&lt;/c3&gt;</ept> is exponentiation:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>浮動小数点型<bpt i="2" x="2">&lt;c2&gt;</bpt>F<ept i="2">&lt;/c2&gt;</ept>の値<bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept>に対して、規模は次のように計算されることができます、ここで<bpt i="3" x="3">&lt;c3&gt;</bpt>**<ept i="3">&lt;/c3&gt;</ept>は冪演算です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For an <bpt i="0" x="0">&lt;c0&gt;</bpt>enum<ept i="0">&lt;/c0&gt;</ept>, all its associated values must conform to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>enum<ept i="0">&lt;/c0&gt;</ept>に対して、すべてのそれの関連値は<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For an <bpt i="0" x="0">&lt;c0&gt;</bpt>enum<ept i="0">&lt;/c0&gt;</ept>, all its associated values must conform to <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>enum<ept i="0">&lt;/c0&gt;</ept>に対して、すべてのそれの関連値は<bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>に準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For an enumeration, <bpt i="0" x="0">&lt;e0&gt;</bpt>all<ept i="0">&lt;/e0&gt;</ept> its associated values must conform to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Hashable<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>列挙に対して、<bpt i="0" x="0">&lt;e0&gt;</bpt>全ての<ept i="0">&lt;/e0&gt;</ept>それの関連値は、<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>および<bpt i="2" x="2">&lt;c2&gt;</bpt>Hashable<ept i="2">&lt;/c2&gt;</ept>に準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For an index <bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept> into a collection <bpt i="1" x="1">&lt;c1&gt;</bpt>c<ept i="1">&lt;/c1&gt;</ept>, calling <bpt i="2" x="2">&lt;c2&gt;</bpt>c<bpt i="3" x="3">&lt;w3&gt;</bpt>.index(after: i)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> returns the same index every time.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクション<bpt i="0" x="0">&lt;c0&gt;</bpt>c<ept i="0">&lt;/c0&gt;</ept>へのインデックス<bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt>c<bpt i="3" x="3">&lt;w3&gt;</bpt>.index(after: i)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を呼び出すことはいつでも同じインデックスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For an instance of <bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>start<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is always zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept>のインスタンスに対して、<bpt i="1" x="1">&lt;c1&gt;</bpt>start<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>は常にゼロです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For an instance of <bpt i="0" x="0">&lt;c0&gt;</bpt>Contiguous<bpt i="1" x="1">&lt;w1&gt;</bpt>Array<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>start<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is always zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Contiguous<bpt i="1" x="1">&lt;w1&gt;</bpt>Array<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のインスタンスに対して、<bpt i="2" x="2">&lt;c2&gt;</bpt>start<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は常にゼロです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For an unspecialized Objective-C type, Swift infers the generic parameterization for the imported class type constraints.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>特殊化されないObjective-C型に対して、スウィフトは総称体パラメータ化をインポートされたクラス型制約に対して推測します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For any NaN value, the property’s value is “nan”, and for positive and negative infinity its value is “inf” and “-inf”.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あらゆるNaN値に対して、このプロパティの持つ値は “nan” です、そして正と負の無限大に対してそれの値は “inf” と “-inf” です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For any finite value <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.next<bpt i="3" x="3">&lt;w3&gt;</bpt>Down<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is less than <bpt i="4" x="4">&lt;c4&gt;</bpt>x<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>何らかの有限の値<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.next<bpt i="3" x="3">&lt;w3&gt;</bpt>Down<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>は<bpt i="4" x="4">&lt;c4&gt;</bpt>x<ept i="4">&lt;/c4&gt;</ept>より小さいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For any finite value <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.next<bpt i="3" x="3">&lt;w3&gt;</bpt>Up<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is greater than <bpt i="4" x="4">&lt;c4&gt;</bpt>x<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>何らかの有限値<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.next<bpt i="3" x="3">&lt;w3&gt;</bpt>Up<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>は<bpt i="4" x="4">&lt;c4&gt;</bpt>x<ept i="4">&lt;/c4&gt;</ept>より大きいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For any finite value, this property provides a string that can be converted back to an instance of <bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept> without rounding errors.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あらゆる有限の値に対して、このプロパティはある文字列を提供します、それは丸め誤差なしに逆に<bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept>のインスタンスへと変換されることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For any finite value, this property provides a string that can be converted back to an instance of <bpt i="0" x="0">&lt;c0&gt;</bpt>Float16<ept i="0">&lt;/c0&gt;</ept> without rounding errors.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あらゆる有限の値に対して、このプロパティはある文字列を提供します、それは丸め誤差なしに逆に<bpt i="0" x="0">&lt;c0&gt;</bpt>Float16<ept i="0">&lt;/c0&gt;</ept>のインスタンスへと変換されることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For any finite value, this property provides a string that can be converted back to an instance of <bpt i="0" x="0">&lt;c0&gt;</bpt>Float80<ept i="0">&lt;/c0&gt;</ept> without rounding errors.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あらゆる有限の値に対して、このプロパティはある文字列を提供します、それは丸め誤差なしに逆に<bpt i="0" x="0">&lt;c0&gt;</bpt>Float80<ept i="0">&lt;/c0&gt;</ept>のインスタンスへと変換されることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For any finite value, this property provides a string that can be converted back to an instance of <bpt i="0" x="0">&lt;c0&gt;</bpt>Float<ept i="0">&lt;/c0&gt;</ept> without rounding errors.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あらゆる有限の値に対して、このプロパティはある文字列を提供します、それは丸め誤差なしに逆に<bpt i="0" x="0">&lt;c0&gt;</bpt>Float<ept i="0">&lt;/c0&gt;</ept>のインスタンスへと変換されることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For any floating-point value <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> of type <bpt i="1" x="1">&lt;c1&gt;</bpt>F<ept i="1">&lt;/c1&gt;</ept>, the result of the following is equal to <bpt i="2" x="2">&lt;c2&gt;</bpt>x<ept i="2">&lt;/c2&gt;</ept>, with the distinction that the result is canonicalized if <bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept> is in a noncanonical encoding:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>何らかの浮動小数点値型<bpt i="1" x="1">&lt;c1&gt;</bpt>F<ept i="1">&lt;/c1&gt;</ept>の<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>に対して、以下の結果は<bpt i="2" x="2">&lt;c2&gt;</bpt>x<ept i="2">&lt;/c2&gt;</ept>と等しいです、その違いは<bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>が非正準符号化になるならば結果は正準化されることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For any numeric value <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.magnitude<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is the absolute value of <bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>何らかの数値<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.magnitude<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>の絶対値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For any representable power of two, <bpt i="0" x="0">&lt;c0&gt;</bpt>significand<bpt i="1" x="1">&lt;w1&gt;</bpt>Width<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is zero, because <bpt i="2" x="2">&lt;c2&gt;</bpt>significand<ept i="2">&lt;/c2&gt;</ept> is <bpt i="3" x="3">&lt;c3&gt;</bpt>1<bpt i="4" x="4">&lt;w4&gt;</bpt>.0<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あらゆる表現可能な２の冪に対して、<bpt i="0" x="0">&lt;c0&gt;</bpt>significand<bpt i="1" x="1">&lt;w1&gt;</bpt>Width<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>はゼロです、なぜなら<bpt i="2" x="2">&lt;c2&gt;</bpt>significand<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>1<bpt i="4" x="4">&lt;w4&gt;</bpt>.0<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For any two integers <bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept>, their quotient <bpt i="2" x="2">&lt;c2&gt;</bpt>q<ept i="2">&lt;/c2&gt;</ept>, and their remainder <bpt i="3" x="3">&lt;c3&gt;</bpt>r<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>a == b * q + r<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>何らかの２つの整数<bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept>、それらの商<bpt i="2" x="2">&lt;c2&gt;</bpt>q<ept i="2">&lt;/c2&gt;</ept>、そしてそれらの余り<bpt i="3" x="3">&lt;c3&gt;</bpt>r<ept i="3">&lt;/c3&gt;</ept>に対して、<bpt i="4" x="4">&lt;c4&gt;</bpt>a == b * q + r<ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For any value, <bpt i="0" x="0">&lt;c0&gt;</bpt>x + .zero == x<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>.zero + x == x<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あらゆる値に対して、<bpt i="0" x="0">&lt;c0&gt;</bpt>x + .zero == x<ept i="0">&lt;/c0&gt;</ept>かつ<bpt i="1" x="1">&lt;c1&gt;</bpt>.zero + x == x<ept i="1">&lt;/c1&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For any values <bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>a != b<ept i="2">&lt;/c2&gt;</ept> implies that <bpt i="3" x="3">&lt;c3&gt;</bpt>a == b<ept i="3">&lt;/c3&gt;</ept> is <bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>何らかの<bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt>a != b<ept i="2">&lt;/c2&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>a == b<ept i="3">&lt;/c3&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>であることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For any values <bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>a == b<ept i="2">&lt;/c2&gt;</ept> implies that <bpt i="3" x="3">&lt;c3&gt;</bpt>a != b<ept i="3">&lt;/c3&gt;</ept> is <bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>何らかの値<bpt i="0" x="0">&lt;c0&gt;</bpt>a<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>b<ept i="1">&lt;/c1&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt>a == b<ept i="2">&lt;/c2&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>a != b<ept i="3">&lt;/c3&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>であることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For arrays of most <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> types, this storage is a contiguous block of memory.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ほとんどの<bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>型の配列に対して、このストレージは隣接メモリブロックです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For arrays with an <bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept> type that is a class or <bpt i="2" x="2">&lt;c2&gt;</bpt>@objc<ept i="2">&lt;/c2&gt;</ept> protocol type, this storage can be a contiguous block of memory or an instance of <bpt i="3" x="3">&lt;c3&gt;</bpt>NSArray<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>クラスや<bpt i="2" x="2">&lt;c2&gt;</bpt>@objc<ept i="2">&lt;/c2&gt;</ept>プロトコル型である<bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept>型を持つ配列に対して、このストレージは隣接メモリブロックまたは<bpt i="3" x="3">&lt;c3&gt;</bpt>NSArray<ept i="3">&lt;/c3&gt;</ept>のインスタンスであることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For bridging to be possible, the <bpt i="3" x="3">&lt;c3&gt;</bpt>Element<ept i="3">&lt;/c3&gt;</ept> type of your array must be a class, an <bpt i="4" x="4">&lt;c4&gt;</bpt>@objc<ept i="4">&lt;/c4&gt;</ept> protocol (a protocol imported from Objective-C or marked with the <bpt i="5" x="5">&lt;c5&gt;</bpt>@objc<ept i="5">&lt;/c5&gt;</ept> attribute), or a type that bridges to a Foundation type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ブリッジが可能にされるには、あなたの配列の<bpt i="3" x="3">&lt;c3&gt;</bpt>Element<ept i="3">&lt;/c3&gt;</ept>型は、あるクラス、<bpt i="4" x="4">&lt;c4&gt;</bpt>@objc<ept i="4">&lt;/c4&gt;</ept>プロトコル（Objective-Cからインポートされるまたは<bpt i="5" x="5">&lt;c5&gt;</bpt>@objc<ept i="5">&lt;/c5&gt;</ept>属性で印されるプロトコル）、またはあるFoundation型にブリッジされる型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For bridging to be possible, the <bpt i="3" x="3">&lt;c3&gt;</bpt>Key<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>Value<ept i="4">&lt;/c4&gt;</ept> types of a dictionary must be classes, <bpt i="5" x="5">&lt;c5&gt;</bpt>@objc<ept i="5">&lt;/c5&gt;</ept> protocols, or types that bridge to Foundation types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ブリッジが可能にされるには、辞書の<bpt i="3" x="3">&lt;c3&gt;</bpt>Key<ept i="3">&lt;/c3&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>Value<ept i="4">&lt;/c4&gt;</ept>型がクラス、<bpt i="5" x="5">&lt;c5&gt;</bpt>@objc<ept i="5">&lt;/c5&gt;</ept>プロトコル、またはFoundation型にブリッジする型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For class types, the following mappings apply:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>クラス型のために、以下のマッピングが適用されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For collections that don’t conform to <bpt i="3" x="3">&lt;c3&gt;</bpt>Random<bpt i="4" x="4">&lt;w4&gt;</bpt>Access<bpt i="5" x="5">&lt;w5&gt;</bpt>Collection<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, accessing the <bpt i="6" x="6">&lt;c6&gt;</bpt>count<ept i="6">&lt;/c6&gt;</ept> property iterates through the elements of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>Random<bpt i="4" x="4">&lt;w4&gt;</bpt>Access<bpt i="5" x="5">&lt;w5&gt;</bpt>Collection<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に準拠しないコレクションに対して、<bpt i="6" x="6">&lt;c6&gt;</bpt>count<ept i="6">&lt;/c6&gt;</ept>プロパティにアクセスすることはコレクションの要素を始めから終わりまで反復します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, <bpt i="6" x="6">&lt;c6&gt;</bpt>Any<bpt i="7" x="7">&lt;w7&gt;</bpt>Hashable(42)<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> compares as equal to <bpt i="8" x="8">&lt;c8&gt;</bpt>Any<bpt i="9" x="9">&lt;w9&gt;</bpt>Hashable(42 as NSNumber)<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、<bpt i="6" x="6">&lt;c6&gt;</bpt>Any<bpt i="7" x="7">&lt;w7&gt;</bpt>Hashable(42)<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>は、<bpt i="8" x="8">&lt;c8&gt;</bpt>Any<bpt i="9" x="9">&lt;w9&gt;</bpt>Hashable(42 as NSNumber)<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>と等しいとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, <bpt i="6" x="6">&lt;e6&gt;</bpt>6<ept i="6">&lt;/e6&gt;</ept> is a multiple of <bpt i="7" x="7">&lt;e7&gt;</bpt>3<ept i="7">&lt;/e7&gt;</ept> because <bpt i="8" x="8">&lt;e8&gt;</bpt>6 = 2*3<ept i="8">&lt;/e8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、<bpt i="6" x="6">&lt;e6&gt;</bpt>6<ept i="6">&lt;/e6&gt;</ept>は<bpt i="7" x="7">&lt;e7&gt;</bpt>3<ept i="7">&lt;/e7&gt;</ept>の倍数です、なぜなら<bpt i="8" x="8">&lt;e8&gt;</bpt>6 = 2*3<ept i="8">&lt;/e8&gt;</ept>なので。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, a country’s Unicode flag character is made up of two regional indicator scalar values that correspond to that country’s ISO 3166-1 alpha-2 code.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、ある国のユニコードの国旗文字は、その国のISO 3166-1 alpha-2コードに対応する２つの地域指定スカラー値から作り上げられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, a function pointer that has the type <bpt i="1" x="1">&lt;c1&gt;</bpt>int (*)(void)<ept i="1">&lt;/c1&gt;</ept> in C is imported into Swift as <bpt i="2" x="2">&lt;c2&gt;</bpt>@convention(c) () -&gt; Int32<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、Cにおける<bpt i="1" x="1">&lt;c1&gt;</bpt>int (*)(void)<ept i="1">&lt;/c1&gt;</ept>型をもつ関数ポインターは、スウィフトに<bpt i="2" x="2">&lt;c2&gt;</bpt>@convention(c) () -&gt; Int32<ept i="2">&lt;/c2&gt;</ept>としてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, a program can import a C API like the one defined here:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あるプログラムはC APIをここで定義されるもののようにインポートできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, a random-access collection, which can measure the distance between two indices in O(1) time, can calculate its <bpt i="0" x="0">&lt;c0&gt;</bpt>count<ept i="0">&lt;/c0&gt;</ept> property in O(1) time.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、ランダムアクセスのコレクションは、２つのインデックス間の隔たりをO(1)時間で測ることが可能で、それの<bpt i="0" x="0">&lt;c0&gt;</bpt>count<ept i="0">&lt;/c0&gt;</ept>プロパティをO(1)時間で計算できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, a type might cache an expensive computed value so that it only needs to calculate it once.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、ある型は高くつく計算値をキャッシュするかもしれません、それを計算する必要がただ一度だけであるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, an app might recommend multiple different penpals in response to user feedback.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あるアプリはユーザのフィードバックに答えて複数の異なる文通友達を勧めるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, an instance of <bpt i="1" x="1">&lt;c1&gt;</bpt>Int16<ept i="1">&lt;/c1&gt;</ept> can represent the value <bpt i="2" x="2">&lt;c2&gt;</bpt>500<ept i="2">&lt;/c2&gt;</ept>, so the first conversion in the code sample below succeeds.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、<bpt i="1" x="1">&lt;c1&gt;</bpt>Int16<ept i="1">&lt;/c1&gt;</ept>のインスタンスは値<bpt i="2" x="2">&lt;c2&gt;</bpt>500<ept i="2">&lt;/c2&gt;</ept>を表せます、それで下のコード例の最初の変換は成功します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, bridging from <bpt i="3" x="3">&lt;c3&gt;</bpt>NSArray<ept i="3">&lt;/c3&gt;</ept> to <bpt i="4" x="4">&lt;c4&gt;</bpt>Array&lt;Int&gt;<ept i="4">&lt;/c4&gt;</ept> performs such a copy.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、<bpt i="3" x="3">&lt;c3&gt;</bpt>NSArray<ept i="3">&lt;/c3&gt;</ept>から<bpt i="4" x="4">&lt;c4&gt;</bpt>Array&lt;Int&gt;<ept i="4">&lt;/c4&gt;</ept>へのブリッジは、そのようなコピーを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, consider a C structure named <bpt i="0" x="0">&lt;c0&gt;</bpt>Cake<ept i="0">&lt;/c0&gt;</ept> that contains the fields <bpt i="1" x="1">&lt;c1&gt;</bpt>layers<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>height<ept i="2">&lt;/c2&gt;</ept> nested within an unnamed union type, and a field <bpt i="3" x="3">&lt;c3&gt;</bpt>toppings<ept i="3">&lt;/c3&gt;</ept> of an unnamed struct type:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>Cake<ept i="0">&lt;/c0&gt;</ept>と名前を付けられるC構造体を考えてください、それはフィールド<bpt i="1" x="1">&lt;c1&gt;</bpt>layers<ept i="1">&lt;/c1&gt;</ept>および<bpt i="2" x="2">&lt;c2&gt;</bpt>height<ept i="2">&lt;/c2&gt;</ept>を無名のunion型内部に入れ子にされて、そしてフィールド<bpt i="3" x="3">&lt;c3&gt;</bpt>toppings<ept i="3">&lt;/c3&gt;</ept>を無名struct型で含みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, consider a C union named <bpt i="0" x="0">&lt;c0&gt;</bpt>Schroedingers<bpt i="1" x="1">&lt;w1&gt;</bpt>Cat<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> that has an <bpt i="2" x="2">&lt;c2&gt;</bpt>is<bpt i="3" x="3">&lt;w3&gt;</bpt>Alive<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and an <bpt i="4" x="4">&lt;c4&gt;</bpt>is<bpt i="5" x="5">&lt;w5&gt;</bpt>Dead<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> field:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>Schroedingers<bpt i="1" x="1">&lt;w1&gt;</bpt>Cat<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と名前を付けられるC共用体を考えてください、それは<bpt i="2" x="2">&lt;c2&gt;</bpt>is<bpt i="3" x="3">&lt;w3&gt;</bpt>Alive<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>is<bpt i="5" x="5">&lt;w5&gt;</bpt>Dead<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>フィールドを持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, consider the <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>present(completion:)<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> method from PassKit.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例として、PassKit由来の<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>present(completion:)<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>メソッドを考えてみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, consider the <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>remove<bpt i="2" x="2">&lt;w2&gt;</bpt>Item(at:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> method from <bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>File<bpt i="5" x="5">&lt;w5&gt;</bpt>Manager<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>remove<bpt i="2" x="2">&lt;w2&gt;</bpt>Item(at:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>メソッドで<bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>File<bpt i="5" x="5">&lt;w5&gt;</bpt>Manager<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>からのものを考えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, consider the <bpt i="4" x="4">&lt;a4&gt;</bpt><bpt i="5" x="5">&lt;c5&gt;</bpt>write(_:<bpt i="6" x="6">&lt;w6&gt;</bpt>timeout:<bpt i="7" x="7">&lt;w7&gt;</bpt>completion<bpt i="8" x="8">&lt;w8&gt;</bpt>Handler:)<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept><ept i="4">&lt;/a4&gt;</ept> method from <bpt i="9" x="9">&lt;s9&gt;</bpt><bpt i="10" x="10">&lt;c10&gt;</bpt>URLSession<bpt i="11" x="11">&lt;w11&gt;</bpt>Stream<bpt i="12" x="12">&lt;w12&gt;</bpt>Task<ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept><ept i="9">&lt;/s9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、<bpt i="9" x="9">&lt;s9&gt;</bpt><bpt i="10" x="10">&lt;c10&gt;</bpt>URLSession<bpt i="11" x="11">&lt;w11&gt;</bpt>Stream<bpt i="12" x="12">&lt;w12&gt;</bpt>Task<ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept><ept i="9">&lt;/s9&gt;</ept>由来の<bpt i="4" x="4">&lt;a4&gt;</bpt><bpt i="5" x="5">&lt;c5&gt;</bpt>write(_:<bpt i="6" x="6">&lt;w6&gt;</bpt>timeout:<bpt i="7" x="7">&lt;w7&gt;</bpt>completion<bpt i="8" x="8">&lt;w8&gt;</bpt>Handler:)<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept><ept i="4">&lt;/a4&gt;</ept>メソッドを考えてみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, consider the following C function declarations:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、以下のC関数宣言を考えてみてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, consider the following Objective-C class and category declarations:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、次のObjective-Cクラスおよびカテゴリ宣言を考えてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, even if the operation is running code that never checks for cancellation, a cancellation handler still runs and provides a chance to run some cleanup code.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、たとえ取り消しを決して調べないコードを演算が実行しているとしても、ある取り消しハンドラが依然として動作してそしてあるクリーンアップコードを実行する機会を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, given the following C structure:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、以下のC構造体を与えられて：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, given the following Objective-C method that performs an operation on the specified class:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、指定されたクラス上である演算を実行する以下のObjective-Cメソッドを与えられて：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, given the following Objective-C property declarations:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、以下のObjective-Cプロパティを与えられて：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, here’s an unannotated C function:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、ここに注釈をつけられなかったC関数があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, here’s how to call the <bpt i="0" x="0">&lt;c0&gt;</bpt>vasprintf(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>_:<bpt i="2" x="2">&lt;w2&gt;</bpt>_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function in Swift:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、ここに<bpt i="0" x="0">&lt;c0&gt;</bpt>vasprintf(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>_:<bpt i="2" x="2">&lt;w2&gt;</bpt>_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数をSwiftにおいて呼び出す方法があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, if the two <bpt i="0" x="0">&lt;c0&gt;</bpt>year<ept i="0">&lt;/c0&gt;</ept> properties are equal but the two <bpt i="1" x="1">&lt;c1&gt;</bpt>month<ept i="1">&lt;/c1&gt;</ept> properties are not, the date with the lesser value for <bpt i="2" x="2">&lt;c2&gt;</bpt>month<ept i="2">&lt;/c2&gt;</ept> is the lesser of the two dates.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、２つの<bpt i="0" x="0">&lt;c0&gt;</bpt>year<ept i="0">&lt;/c0&gt;</ept>プロパティは等しいけれども２つの<bpt i="1" x="1">&lt;c1&gt;</bpt>month<ept i="1">&lt;/c1&gt;</ept>プロパティは異なるならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>month<ept i="2">&lt;/c2&gt;</ept>に対してより少ない値を持つ日付は２つの日付のうちより少ないものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, if you have a type that represents a local database connection, the code that manages access to that database needs full control over the state of the database as viewed from your app.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたがローカルデータベース接続を表す型を持つならば、そのデータベースへのアクセスを管理するコードは、データベースの状態すべてわたって完全な制御をあなたのアプリから眺められる際に必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, if you update the last element of the <bpt i="0" x="0">&lt;c0&gt;</bpt>absences<ept i="0">&lt;/c0&gt;</ept> array from <bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept> to <bpt i="2" x="2">&lt;c2&gt;</bpt>2<ept i="2">&lt;/c2&gt;</ept>, the <bpt i="3" x="3">&lt;c3&gt;</bpt>second<bpt i="4" x="4">&lt;w4&gt;</bpt>Half<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> slice is unchanged.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>absences<ept i="0">&lt;/c0&gt;</ept>配列の最後の要素を<bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept>から<bpt i="2" x="2">&lt;c2&gt;</bpt>2<ept i="2">&lt;/c2&gt;</ept>に更新する場合、<bpt i="3" x="3">&lt;c3&gt;</bpt>second<bpt i="4" x="4">&lt;w4&gt;</bpt>Half<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>スライスは変化していません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, if you want to print only the first word in a string, you can search for the index of the first space, and then create a substring up to that position.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたがある文字列の最初の単語のみを出力したいならば、最初の空白のインデックスを捜して、それからその位置までの下位文字列を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, if your array’s elements conform to <bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>, you can call the <bpt i="2" x="2">&lt;c2&gt;</bpt>sort()<ept i="2">&lt;/c2&gt;</ept> method without using arguments to sort the elements of your array in ascending order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたの配列のもつ要素が<bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>に準拠するならば、あなたは<bpt i="2" x="2">&lt;c2&gt;</bpt>sort()<ept i="2">&lt;/c2&gt;</ept>メソッドを引数を使うことなく呼び出して、あなたの配列の要素を昇順にソートすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, in a fixed-width integer type with a <bpt i="0" x="0">&lt;c0&gt;</bpt>bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Width<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> value of 8, the number -8 has three trailing zeros.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、8の<bpt i="0" x="0">&lt;c0&gt;</bpt>bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Width<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>値を持つ固定長整数型において、数-8は後に続くゼロを３つ持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, in a fixed-width integer type with a <bpt i="0" x="0">&lt;c0&gt;</bpt>bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Width<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> value of 8, the number <bpt i="2" x="2">&lt;e2&gt;</bpt>31<ept i="2">&lt;/e2&gt;</ept> has five bits equal to <bpt i="3" x="3">&lt;e3&gt;</bpt>1<ept i="3">&lt;/e3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、８の<bpt i="0" x="0">&lt;c0&gt;</bpt>bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Width<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>値を持つ固定長整数型において、数<bpt i="2" x="2">&lt;e2&gt;</bpt>31<ept i="2">&lt;/e2&gt;</ept>は<bpt i="3" x="3">&lt;e3&gt;</bpt>1<ept i="3">&lt;/e3&gt;</ept>に等しいビットを５つ持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, in a fixed-width integer type with a <bpt i="0" x="0">&lt;c0&gt;</bpt>bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Width<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> value of 8, the number <bpt i="2" x="2">&lt;e2&gt;</bpt>31<ept i="2">&lt;/e2&gt;</ept> has three leading zeros.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、８の<bpt i="0" x="0">&lt;c0&gt;</bpt>bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Width<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>値を持つ固定長整数型において、数<bpt i="2" x="2">&lt;e2&gt;</bpt>31<ept i="2">&lt;/e2&gt;</ept>は３つの先頭のゼロを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, in an integer type with a <bpt i="0" x="0">&lt;c0&gt;</bpt>bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Width<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> value of 8, the number <bpt i="2" x="2">&lt;e2&gt;</bpt>31<ept i="2">&lt;/e2&gt;</ept> has three leading zeros.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、８の<bpt i="0" x="0">&lt;c0&gt;</bpt>bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Width<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>値を持つ整数型において、数<bpt i="2" x="2">&lt;e2&gt;</bpt>31<ept i="2">&lt;/e2&gt;</ept>は３つの先頭のゼロを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, in the code below, nothing is canceled and the group doesn’t throw an error:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、下のコードにおいて、何も取り消されません、そしてグループはエラーをスローしません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, it would be reasonable to implement alternative operations in which operating on a signaling NaN triggers a runtime error or results in a diagnostic for debugging purposes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、それらにおいてはシグナルNaNに関する演算が実行時エラーを引き起こすまたはデバッグ目的の診断という結果になるといった、代替の演算を実装するのが妥当であるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, many Objective-C frameworks expose classes that you are expected to subclass.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、多くのObjective-Cフレームワークは、あなたがサブクラスを作るべき様々なクラスを公開します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, passing an empty range as <bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept> triggers a runtime error, because an empty range cannot be represented by a closed range instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、空の範囲を<bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>として渡すことは実行時エラーの引き金となります、空の範囲は完結範囲インスタンスによって表現されることができないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, suppose the C function above doesn't retain the <bpt i="0" x="0">&lt;c0&gt;</bpt>CFString<ept i="0">&lt;/c0&gt;</ept> object before returning it.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、上のC関数が<bpt i="0" x="0">&lt;c0&gt;</bpt>CFString<ept i="0">&lt;/c0&gt;</ept>オブジェクトを、それを返す前にリテインしないと思ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, suppose you have an array holding the number of absences from each class during a session.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたがある学期（２学期制）の各クラスの欠席者数が入った配列を持つと考えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>sign(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>using:<bpt i="3" x="3">&lt;w3&gt;</bpt>completion:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> method from PassKit is declared like this in Objective-C:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、PassKit由来の<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>sign(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>using:<bpt i="3" x="3">&lt;w3&gt;</bpt>completion:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>メソッドはObjective-Cにおいてこのように宣言されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>Compass<bpt i="1" x="1">&lt;w1&gt;</bpt>Direction<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> enumeration declared in this example conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt>Case<bpt i="3" x="3">&lt;w3&gt;</bpt>Iterable<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、この例で定義される<bpt i="0" x="0">&lt;c0&gt;</bpt>Compass<bpt i="1" x="1">&lt;w1&gt;</bpt>Direction<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>列挙は<bpt i="2" x="2">&lt;c2&gt;</bpt>Case<bpt i="3" x="3">&lt;w3&gt;</bpt>Iterable<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>Float<ept i="0">&lt;/c0&gt;</ept> type has an <bpt i="1" x="1">&lt;c1&gt;</bpt>exponent<bpt i="2" x="2">&lt;w2&gt;</bpt>Bit<bpt i="3" x="3">&lt;w3&gt;</bpt>Count<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> of 8, which gives an exponent bias of <bpt i="4" x="4">&lt;c4&gt;</bpt>127<ept i="4">&lt;/c4&gt;</ept> by the calculation above.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>Float<ept i="0">&lt;/c0&gt;</ept>型は、８の<bpt i="1" x="1">&lt;c1&gt;</bpt>exponent<bpt i="2" x="2">&lt;w2&gt;</bpt>Bit<bpt i="3" x="3">&lt;w3&gt;</bpt>Count<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>を持ちます、それは<bpt i="4" x="4">&lt;c4&gt;</bpt>127<ept i="4">&lt;/c4&gt;</ept>の指数バイアスを上記の計算によって与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>NSJSONReading<bpt i="1" x="1">&lt;w1&gt;</bpt>Options<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> option set is imported as <bpt i="2" x="2">&lt;c2&gt;</bpt>JSONSerialization<bpt i="3" x="3">&lt;w3&gt;</bpt>.Reading<bpt i="4" x="4">&lt;w4&gt;</bpt>Options<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>NSJSONReading<bpt i="1" x="1">&lt;w1&gt;</bpt>Options<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>オプションセットは<bpt i="2" x="2">&lt;c2&gt;</bpt>JSONSerialization<bpt i="3" x="3">&lt;w3&gt;</bpt>.Reading<bpt i="4" x="4">&lt;w4&gt;</bpt>Options<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>としてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>keys<ept i="0">&lt;/c0&gt;</ept> property of a dictionary isn’t an array with its own storage, it’s a collection that maps its elements from the dictionary only when they’re accessed, saving the time and space needed to allocate an array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、辞書の<bpt i="0" x="0">&lt;c0&gt;</bpt>keys<ept i="0">&lt;/c0&gt;</ept>プロパティはそれ自身のストレージを持つことになる配列ではありません、それはコレクションです、それはそれの要素らをそれらがアクセスされた時に限り辞書からマップします、そして配列を割り当てるのに必要とされる時間と空間を節約しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>sum(_:)<ept i="0">&lt;/c0&gt;</ept> function shown here takes an <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept> array as a parameter:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、ここで示す<bpt i="0" x="0">&lt;c0&gt;</bpt>sum(_:)<ept i="0">&lt;/c0&gt;</ept>関数は、<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>リテラルをパラメータとしてとります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the <bpt i="1" x="1">&lt;c1&gt;</bpt>log(name:<bpt i="2" x="2">&lt;w2&gt;</bpt>value:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> function shown here has an unconstrained generic <bpt i="3" x="3">&lt;c3&gt;</bpt>value<ept i="3">&lt;/c3&gt;</ept> parameter.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、ここで示す<bpt i="1" x="1">&lt;c1&gt;</bpt>log(name:<bpt i="2" x="2">&lt;w2&gt;</bpt>value:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>関数は、制約のない総称体の<bpt i="3" x="3">&lt;c3&gt;</bpt>value<ept i="3">&lt;/c3&gt;</ept>パラメータを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the <bpt i="2" x="2">&lt;c2&gt;</bpt>.map(_:)<ept i="2">&lt;/c2&gt;</ept> method returns a <bpt i="3" x="3">&lt;c3&gt;</bpt>Async<bpt i="4" x="4">&lt;w4&gt;</bpt>Map<bpt i="5" x="5">&lt;w5&gt;</bpt>Sequence<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> (or a <bpt i="6" x="6">&lt;c6&gt;</bpt>Async<bpt i="7" x="7">&lt;w7&gt;</bpt>Throwing<bpt i="8" x="8">&lt;w8&gt;</bpt>Map<bpt i="9" x="9">&lt;w9&gt;</bpt>Sequence<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, if the closure you provide to the <bpt i="10" x="10">&lt;c10&gt;</bpt>map(_:)<ept i="10">&lt;/c10&gt;</ept> method can throw an error).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、<bpt i="2" x="2">&lt;c2&gt;</bpt>.map(_:)<ept i="2">&lt;/c2&gt;</ept>メソッドはある<bpt i="3" x="3">&lt;c3&gt;</bpt>Async<bpt i="4" x="4">&lt;w4&gt;</bpt>Map<bpt i="5" x="5">&lt;w5&gt;</bpt>Sequence<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>を返します（または<bpt i="6" x="6">&lt;c6&gt;</bpt>Async<bpt i="7" x="7">&lt;w7&gt;</bpt>Throwing<bpt i="8" x="8">&lt;w8&gt;</bpt>Map<bpt i="9" x="9">&lt;w9&gt;</bpt>Sequence<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を、あなたが<bpt i="10" x="10">&lt;c10&gt;</bpt>map(_:)<ept i="10">&lt;/c10&gt;</ept>メソッドに提供するクロージャがエラーをスローするならば）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the <bpt i="2" x="2">&lt;c2&gt;</bpt>digits()<ept i="2">&lt;/c2&gt;</ept> function in the following example creates an iterator over a collection that lazily maps the elements of a <bpt i="3" x="3">&lt;c3&gt;</bpt>Range&lt;Int&gt;<ept i="3">&lt;/c3&gt;</ept> instance to strings.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、以下の例の<bpt i="2" x="2">&lt;c2&gt;</bpt>digits()<ept i="2">&lt;/c2&gt;</ept>関数は、あるコレクションを覆うイテレータを作成します、それは<bpt i="3" x="3">&lt;c3&gt;</bpt>Range&lt;Int&gt;<ept i="3">&lt;/c3&gt;</ept>インスタンスの要素を文字列へと遅延にマップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the <bpt i="3" x="3">&lt;c3&gt;</bpt>contains(_:)<ept i="3">&lt;/c3&gt;</ept> method returns a Boolean value that indicates if a given value exists in the <bpt i="4" x="4">&lt;c4&gt;</bpt>Async<bpt i="5" x="5">&lt;w5&gt;</bpt>Sequence<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、<bpt i="3" x="3">&lt;c3&gt;</bpt>contains(_:)<ept i="3">&lt;/c3&gt;</ept>メソッドはあるブール値を返します、それはある与えられた値が<bpt i="4" x="4">&lt;c4&gt;</bpt>Async<bpt i="5" x="5">&lt;w5&gt;</bpt>Sequence<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の中に存在するかどうかを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the <bpt i="7" x="7">&lt;c7&gt;</bpt>Int8<ept i="7">&lt;/c7&gt;</ept> type has a <bpt i="8" x="8">&lt;c8&gt;</bpt>bit<bpt i="9" x="9">&lt;w9&gt;</bpt>Width<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> value of 8 and can store any integer in the range <bpt i="10" x="10">&lt;c10&gt;</bpt>-128...127<ept i="10">&lt;/c10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、<bpt i="7" x="7">&lt;c7&gt;</bpt>Int8<ept i="7">&lt;/c7&gt;</ept>型は、８の<bpt i="8" x="8">&lt;c8&gt;</bpt>bit<bpt i="9" x="9">&lt;w9&gt;</bpt>Width<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>値を持ち、範囲<bpt i="10" x="10">&lt;c10&gt;</bpt>-128...127<ept i="10">&lt;/c10&gt;</ept>の中の何らかの整数を格納できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the code sample below creates a dictionary with string keys and values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、下のコード見本はある辞書を文字列のキーと値で作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the contents of a <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> are logged, as are the components of an <bpt i="1" x="1">&lt;c1&gt;</bpt>NSColor<ept i="1">&lt;/c1&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt>UIColor<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、ある<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>のそれら内容が記録されます、ある<bpt i="1" x="1">&lt;c1&gt;</bpt>NSColor<ept i="1">&lt;/c1&gt;</ept>または<bpt i="2" x="2">&lt;c2&gt;</bpt>UIColor<ept i="2">&lt;/c2&gt;</ept>の構成要素それらのように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the following characters all represent currency symbols:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、以下の表意文字は全て通貨記号を表します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the following characters all represent math symbols:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、以下の表意文字は全て数学シンボルを表します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the following characters all represent newlines:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、以下の表意文字は全てニューラインを表します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the following characters all represent numbers:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、以下の表意文字は全て数字を表します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the following characters all represent punctuation:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、以下の表意文字は全て句読点を表します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the following characters all represent symbols:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、以下の表意文字は全て記号を表します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the following characters all represent whitespace:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、以下の表意文字は全て空白を表します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the following characters all represent whole numbers:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、以下の表意文字は全て整数を表します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the following characters are all letters:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の文字は全て表音文字です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the following code provides a <bpt i="3" x="3">&lt;c3&gt;</bpt>binary<bpt i="4" x="4">&lt;w4&gt;</bpt>String<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> property on every fixed-width integer that represents the number’s binary representation, split into 8-bit chunks.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、以下のコードは<bpt i="3" x="3">&lt;c3&gt;</bpt>binary<bpt i="4" x="4">&lt;w4&gt;</bpt>String<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>プロパティをあらゆる固定長整数に関して提供します、それは数のバイナリ表現を、８ビットの塊へと分割して表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the following code sample does not compile, because it attempts to use the integer <bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept> in a logical context:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、以下のコードサンプルはコンパイルしません、なぜならそれが整数<bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept>を論理的文脈において使おうとするからです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the following conversions result in <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、次の変換は<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>という結果になります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the following conversions result in <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、以下の変換は<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>という結果になります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the number <bpt i="0" x="0">&lt;e0&gt;</bpt>-8<ept i="0">&lt;/e0&gt;</ept> has three trailing zeros.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、数<bpt i="0" x="0">&lt;e0&gt;</bpt>-8<ept i="0">&lt;/e0&gt;</ept>は後に続くゼロを３つ持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the parameter passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept> to the <bpt i="1" x="1">&lt;c1&gt;</bpt>print<bpt i="2" x="2">&lt;w2&gt;</bpt>Smiley<bpt i="3" x="3">&lt;w3&gt;</bpt>Info(_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> function in the example below is an instance of the <bpt i="4" x="4">&lt;c4&gt;</bpt>Smiley<ept i="4">&lt;/c4&gt;</ept> class or one of its subclasses.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、下の例において<bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept>として<bpt i="1" x="1">&lt;c1&gt;</bpt>print<bpt i="2" x="2">&lt;w2&gt;</bpt>Smiley<bpt i="3" x="3">&lt;w3&gt;</bpt>Info(_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>関数に渡されるパラメータは、<bpt i="4" x="4">&lt;c4&gt;</bpt>Smiley<ept i="4">&lt;/c4&gt;</ept>クラスまたはそれのサブクラスの１つのインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the special “not a number” value for floating-point types (<bpt i="1" x="1">&lt;c1&gt;</bpt>Floating<bpt i="2" x="2">&lt;w2&gt;</bpt>Point<bpt i="3" x="3">&lt;w3&gt;</bpt>.nan<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>) compares as neither less than, greater than, nor equal to any normal floating-point value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、浮動小数点型のための特別な「数でない」値（<bpt i="1" x="1">&lt;c1&gt;</bpt>Floating<bpt i="2" x="2">&lt;w2&gt;</bpt>Point<bpt i="3" x="3">&lt;w3&gt;</bpt>.nan<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>）は、何らかの通常の浮動小数点値とより少ないでも、より大きいでも、等しいでもないような比較をします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, this custom <bpt i="0" x="0">&lt;c0&gt;</bpt>Point<ept i="0">&lt;/c0&gt;</ept> struct uses the default representation supplied by the standard library:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、このあつらえの<bpt i="0" x="0">&lt;c0&gt;</bpt>Point<ept i="0">&lt;/c0&gt;</ept> structは、標準ライブラリによって提供される省略時の表現を使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, this version of the <bpt i="6" x="6">&lt;c6&gt;</bpt>update(with<bpt i="7" x="7">&lt;w7&gt;</bpt>Value)<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> method will re-copy <bpt i="8" x="8">&lt;c8&gt;</bpt>my<bpt i="9" x="9">&lt;w9&gt;</bpt>Storage<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> on every call:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、このバージョンの<bpt i="6" x="6">&lt;c6&gt;</bpt>update(with<bpt i="7" x="7">&lt;w7&gt;</bpt>Value)<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>メソッドは<bpt i="8" x="8">&lt;c8&gt;</bpt>my<bpt i="9" x="9">&lt;w9&gt;</bpt>Storage<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>を全ての呼び出しで再コピーします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, to check whether an array contains a particular value, you can pass the value itself to the <bpt i="1" x="1">&lt;c1&gt;</bpt>contains(_:)<ept i="1">&lt;/c1&gt;</ept> method when the array’s element conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt>Equatable<ept i="2">&lt;/c2&gt;</ept> instead of providing a closure that determines equivalence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、ある配列がある特定の値を含むかどうか調べるには、あなたはその値自体を<bpt i="1" x="1">&lt;c1&gt;</bpt>contains(_:)<ept i="1">&lt;/c1&gt;</ept>メソッドに渡すことが、その配列の要素が<bpt i="2" x="2">&lt;c2&gt;</bpt>Equatable<ept i="2">&lt;/c2&gt;</ept>に準拠する場合には、同等を判定するクロージャを提供する代わりに可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, to find the key for a particular value in a dictionary, use the <bpt i="0" x="0">&lt;c0&gt;</bpt>first<bpt i="1" x="1">&lt;w1&gt;</bpt>Index(where:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、辞書において特定の値に対するキーを見つけるには、<bpt i="0" x="0">&lt;c0&gt;</bpt>first<bpt i="1" x="1">&lt;w1&gt;</bpt>Index(where:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, to get the reversed version of a string, reverse its characters and initialize a new <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> instance from the result.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、ある文字列の逆版を得るには、それの文字を逆にして、新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>インスタンスをその結果から初期化してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, using a <bpt i="0" x="0">&lt;c0&gt;</bpt>Partial<bpt i="1" x="1">&lt;w1&gt;</bpt>Range<bpt i="2" x="2">&lt;w2&gt;</bpt>From<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> range expression with an array accesses the subrange from the start of the range expression until the end of the array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、<bpt i="0" x="0">&lt;c0&gt;</bpt>Partial<bpt i="1" x="1">&lt;w1&gt;</bpt>Range<bpt i="2" x="2">&lt;w2&gt;</bpt>From<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>範囲式をある配列で使うことは、その下位範囲に範囲式の始まりから配列の終わりまでにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, when converting a 16-bit value to an 8-bit type, only the lower 8 bits of <bpt i="3" x="3">&lt;c3&gt;</bpt>source<ept i="3">&lt;/c3&gt;</ept> are used.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、16bit値を8bit型へ変換する場合、<bpt i="3" x="3">&lt;c3&gt;</bpt>source<ept i="3">&lt;/c3&gt;</ept>の最も下位の8ビットが使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, when the transform receives <bpt i="6" x="6">&lt;c6&gt;</bpt>3<ept i="6">&lt;/c6&gt;</ept> from the base sequence, it creates a new <bpt i="7" x="7">&lt;c7&gt;</bpt>Counter<ept i="7">&lt;/c7&gt;</ept> that produces the values <bpt i="8" x="8">&lt;c8&gt;</bpt>1<ept i="8">&lt;/c8&gt;</ept>, <bpt i="9" x="9">&lt;c9&gt;</bpt>2<ept i="9">&lt;/c9&gt;</ept>, and <bpt i="10" x="10">&lt;c10&gt;</bpt>3<ept i="10">&lt;/c10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、変換が<bpt i="6" x="6">&lt;c6&gt;</bpt>3<ept i="6">&lt;/c6&gt;</ept>を基底シーケンスから受け取る場合、それは新しい<bpt i="7" x="7">&lt;c7&gt;</bpt>Counter<ept i="7">&lt;/c7&gt;</ept>を作成します、そしてそれが値<bpt i="8" x="8">&lt;c8&gt;</bpt>1<ept i="8">&lt;/c8&gt;</ept>、<bpt i="9" x="9">&lt;c9&gt;</bpt>2<ept i="9">&lt;/c9&gt;</ept>、そして<bpt i="10" x="10">&lt;c10&gt;</bpt>3<ept i="10">&lt;/c10&gt;</ept>を生み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you can add a single element to an array by using a <bpt i="3" x="3">&lt;c3&gt;</bpt>Collection<bpt i="4" x="4">&lt;w4&gt;</bpt>Of<bpt i="5" x="5">&lt;w5&gt;</bpt>One<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> instance with the concatenation operator (<bpt i="6" x="6">&lt;c6&gt;</bpt>+<ept i="6">&lt;/c6&gt;</ept>):</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたは単一の要素を配列へと追加することが、<bpt i="3" x="3">&lt;c3&gt;</bpt>Collection<bpt i="4" x="4">&lt;w4&gt;</bpt>Of<bpt i="5" x="5">&lt;w5&gt;</bpt>One<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>インスタンスを連結演算子（<bpt i="6" x="6">&lt;c6&gt;</bpt>+<ept i="6">&lt;/c6&gt;</ept>）とともに使うことによって可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you can also access the first character of <bpt i="1" x="1">&lt;c1&gt;</bpt>text<ept i="1">&lt;/c1&gt;</ept> using the <bpt i="2" x="2">&lt;c2&gt;</bpt>first<ept i="2">&lt;/c2&gt;</ept> property, which has the value of the first element of the collection, or <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept> if the collection is empty.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたはまた<bpt i="1" x="1">&lt;c1&gt;</bpt>text<ept i="1">&lt;/c1&gt;</ept>の最初の文字にアクセスすることが<bpt i="2" x="2">&lt;c2&gt;</bpt>first<ept i="2">&lt;/c2&gt;</ept>プロパティを使って行えます、それはコレクションの最初の要素の値、またはコレクションが空ならば<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you can concatenate the elements of a <bpt i="1" x="1">&lt;c1&gt;</bpt>Range&lt;Int&gt;<ept i="1">&lt;/c1&gt;</ept> instance and an integer array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたはある<bpt i="1" x="1">&lt;c1&gt;</bpt>Range&lt;Int&gt;<ept i="1">&lt;/c1&gt;</ept>インスタンスとある整数配列とに属する要素を連結することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you can concatenate the elements of an integer array and a <bpt i="1" x="1">&lt;c1&gt;</bpt>Range&lt;Int&gt;<ept i="1">&lt;/c1&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたはある整数配列とある<bpt i="1" x="1">&lt;c1&gt;</bpt>Range&lt;Int&gt;<ept i="1">&lt;/c1&gt;</ept>インスタンスとに属する要素を連結することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you can concatenate the elements of two integer arrays.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたは２つの整数配列に属する要素を連結することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you can replace an element of an array by using its subscript.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたは配列の中のある要素をそれの添え字を使うことによって置き換えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you can shuffle the numbers between <bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>9<ept i="1">&lt;/c1&gt;</ept> by calling the <bpt i="2" x="2">&lt;c2&gt;</bpt>shuffled()<ept i="2">&lt;/c2&gt;</ept> method on that range:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>9<ept i="1">&lt;/c1&gt;</ept>の間の数をシャッフルすることが、<bpt i="2" x="2">&lt;c2&gt;</bpt>shuffled()<ept i="2">&lt;/c2&gt;</ept>メソッドをその範囲上で呼び出すことによって可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you can shuffle the numbers between <bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>9<ept i="1">&lt;/c1&gt;</ept> by calling the <bpt i="2" x="2">&lt;c2&gt;</bpt>shuffled(using:)<ept i="2">&lt;/c2&gt;</ept> method on that range:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>9<ept i="1">&lt;/c1&gt;</ept>の間の数をシャッフルすることが、<bpt i="2" x="2">&lt;c2&gt;</bpt>shuffled(using:)<ept i="2">&lt;/c2&gt;</ept>メソッドをその範囲上で呼び出すことによって可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you can test whether the first <bpt i="3" x="3">&lt;c3&gt;</bpt>UInt8<ept i="3">&lt;/c3&gt;</ept> value in a string’s UTF-8 encoding is equal to the first <bpt i="4" x="4">&lt;c4&gt;</bpt>UInt32<ept i="4">&lt;/c4&gt;</ept> value in its Unicode scalar view:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたはある文字列のUTF-8符号化の中の最初の<bpt i="3" x="3">&lt;c3&gt;</bpt>UInt8<ept i="3">&lt;/c3&gt;</ept>値が、それのユニコードスカラー値での最初の<bpt i="4" x="4">&lt;c4&gt;</bpt>UInt32<ept i="4">&lt;/c4&gt;</ept>と等しいかどうかを試験できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you can test whether the first <bpt i="3" x="3">&lt;c3&gt;</bpt>UInt8<ept i="3">&lt;/c3&gt;</ept> value in a string’s UTF-8 encoding is not equal to the first <bpt i="4" x="4">&lt;c4&gt;</bpt>UInt32<ept i="4">&lt;/c4&gt;</ept> value in its Unicode scalar view:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたはある文字列のUTF-8符号化の中の最初の<bpt i="3" x="3">&lt;c3&gt;</bpt>UInt8<ept i="3">&lt;/c3&gt;</ept>値が、それのユニコードスカラー値での最初の<bpt i="4" x="4">&lt;c4&gt;</bpt>UInt32<ept i="4">&lt;/c4&gt;</ept>と等しくないかどうかを試験できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you can use the <bpt i="0" x="0">&lt;c0&gt;</bpt>shuffle(using:)<ept i="0">&lt;/c0&gt;</ept> method to randomly reorder the elements of an array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>shuffle(using:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使って、配列の要素を無作為に再配列することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you can use this method on a sequence of numbers to find their sum or product.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたはこのメソッドを数値からなるシーケンス上で使うことで、それらの和または積を見つけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you can use this method on an array of integers to filter adjacent equal entries or count frequencies.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたはこのメソッドを整数からなる配列で使うことで、隣接する同等の項目をフィルタしたり頻度を数えたりできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you can use this method on an array of numbers to find their sum or product.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたはこのメソッドを数値いくつかからなる配列で使うことで、それらの和または積を見つけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you can use this method on an sequence of numbers to find their sum or product.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたはこのメソッドを数値からなるシーケンス上で使うことで、それらの和または積を見つけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you could define a <bpt i="1" x="1">&lt;c1&gt;</bpt>User<ept i="1">&lt;/c1&gt;</ept> type with an <bpt i="2" x="2">&lt;c2&gt;</bpt>id<ept i="2">&lt;/c2&gt;</ept> property that is stable across your app and your app’s database storage.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたはある<bpt i="1" x="1">&lt;c1&gt;</bpt>User<ept i="1">&lt;/c1&gt;</ept>型を、あなたのアプリとあなたのアプリのもつデータベースストレージにわたって安定しているある<bpt i="2" x="2">&lt;c2&gt;</bpt>id<ept i="2">&lt;/c2&gt;</ept>プロパティで定義できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you might want to create an array with the integers from 1 through 7.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたは配列を１から７までの整数で作成したいかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, “ϰ” (U+03F0 GREEK KAPPA SYMBOL) is considered both a mathematical symbol and a letter.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、 “ϰ” (U+03F0 GREEK KAPPA SYMBOL) は、数学シンボルと表音文字の両方にみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For extensible floating-point types, <bpt i="0" x="0">&lt;c0&gt;</bpt>significand<bpt i="1" x="1">&lt;w1&gt;</bpt>Bit<bpt i="2" x="2">&lt;w2&gt;</bpt>Count<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> should be the maximum allowed significand width (without counting any leading integral bit of the significand).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>拡張可能な浮動小数点型に対して、<bpt i="0" x="0">&lt;c0&gt;</bpt>significand<bpt i="1" x="1">&lt;w1&gt;</bpt>Bit<bpt i="2" x="2">&lt;w2&gt;</bpt>Count<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は許される最大仮数幅であるべきです（全く仮数の先頭整数ビットを数えることなく）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For fixed-width floating-point types, this is the actual number of fractional significand bits.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>固定長浮動小数点型に対して、これは小数部仮数ビットの実際の数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For information about asynchronous functions, see <bpt i="0" x="0">&lt;a0&gt;</bpt>Concurrency<ept i="0">&lt;/a0&gt;</ept> in The Swift Programming Language.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>非同期関数についての情報として、<bpt i="0" x="0">&lt;a0&gt;</bpt>並行性<ept i="0">&lt;/a0&gt;</ept>をThe Swift Programming Languageで見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For instances of <bpt i="6" x="6">&lt;c6&gt;</bpt>NSDictionary<ept i="6">&lt;/c6&gt;</ept> that are already immutable, <bpt i="7" x="7">&lt;c7&gt;</bpt>copy(with:)<ept i="7">&lt;/c7&gt;</ept> usually returns the same dictionary in O(1) time; otherwise, the copying performance is unspecified.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>すでに可変の<bpt i="6" x="6">&lt;c6&gt;</bpt>NSDictionary<ept i="6">&lt;/c6&gt;</ept>のインスタンスに対しては、<bpt i="7" x="7">&lt;c7&gt;</bpt>copy(with:)<ept i="7">&lt;/c7&gt;</ept>は通常同じ辞書をO(1)時間で返します；そうでなければ、このコピー性能は不定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For instances of <bpt i="7" x="7">&lt;c7&gt;</bpt>NSArray<ept i="7">&lt;/c7&gt;</ept> that are already immutable, <bpt i="8" x="8">&lt;c8&gt;</bpt>copy(with:)<ept i="8">&lt;/c8&gt;</ept> usually returns the same array in O(1) time; otherwise, the copying performance is unspecified.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>元から不変である<bpt i="7" x="7">&lt;c7&gt;</bpt>NSArray<ept i="7">&lt;/c7&gt;</ept>のインスタンスに対しては、<bpt i="8" x="8">&lt;c8&gt;</bpt>copy(with:)<ept i="8">&lt;/c8&gt;</ept>は大抵は同じ配列をO(1)時間で返します；そうでなければ、コピーする性能は不定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For integer types, any remainder of the division is discarded.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>整数型に対して、除算の余りは何であれ破棄されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For more about arithmetic with overflow operators, see <bpt i="0" x="0">&lt;a0&gt;</bpt>Overflow Operators<ept i="0">&lt;/a0&gt;</ept> in <bpt i="1" x="1">&lt;e1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>The Swift Programming Language<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/e1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オーバーフロー演算子を使う算術についてさらには、<bpt i="0" x="0">&lt;a0&gt;</bpt>オーバーフロー演算子<ept i="0">&lt;/a0&gt;</ept>を<bpt i="1" x="1">&lt;e1&gt;</bpt><bpt i="2" x="2">&lt;a2&gt;</bpt>Swiftプログラミング言語<ept i="2">&lt;/a2&gt;</ept><ept i="1">&lt;/e1&gt;</ept>で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For more information about index invalidation in mutable collections, see the reference for the <bpt i="0" x="0">&lt;c0&gt;</bpt>Mutable<bpt i="1" x="1">&lt;w1&gt;</bpt>Collection<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Range<bpt i="3" x="3">&lt;w3&gt;</bpt>Replaceable<bpt i="4" x="4">&lt;w4&gt;</bpt>Collection<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocols, as well as for the specific type you’re using.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>可変コレクションにおけるインデックス無効化についてのさらなる情報は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Mutable<bpt i="1" x="1">&lt;w1&gt;</bpt>Collection<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>および<bpt i="2" x="2">&lt;c2&gt;</bpt>Range<bpt i="3" x="3">&lt;w3&gt;</bpt>Replaceable<bpt i="4" x="4">&lt;w4&gt;</bpt>Collection<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルに対してのリファレンスを見てください、もちろんあなたが使っている特定の型に対しても。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For more information about the Unicode terms used in this discussion, see the <bpt i="0" x="0">&lt;a0&gt;</bpt>Unicode.org glossary<ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この解説において使われるユニコード用語についてのさらなる情報は、<bpt i="0" x="0">&lt;a0&gt;</bpt>Unicode.org用語集<ept i="0">&lt;/a0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For more information about the available rounding rules, see the <bpt i="0" x="0">&lt;c0&gt;</bpt>Floating<bpt i="1" x="1">&lt;w1&gt;</bpt>Point<bpt i="2" x="2">&lt;w2&gt;</bpt>Rounding<bpt i="3" x="3">&lt;w3&gt;</bpt>Rule<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> enumeration.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>利用可能な丸め規則についてのさらなる情報として、<bpt i="0" x="0">&lt;c0&gt;</bpt>Floating<bpt i="1" x="1">&lt;w1&gt;</bpt>Point<bpt i="2" x="2">&lt;w2&gt;</bpt>Rounding<bpt i="3" x="3">&lt;w3&gt;</bpt>Rule<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>列挙を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For more information about using arrays, see <bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Array<bpt i="2" x="2">&lt;w2&gt;</bpt>Slice<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>, with which <bpt i="3" x="3">&lt;c3&gt;</bpt>Contiguous<bpt i="4" x="4">&lt;w4&gt;</bpt>Array<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> shares most properties and methods.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列の使用についてのさらなる情報は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>Array<bpt i="2" x="2">&lt;w2&gt;</bpt>Slice<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>を見てください、それらと<bpt i="3" x="3">&lt;c3&gt;</bpt>Contiguous<bpt i="4" x="4">&lt;w4&gt;</bpt>Array<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>はほとんどのプロパティとメソッドを共有します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For more information about using arrays, see <bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Contiguous<bpt i="2" x="2">&lt;w2&gt;</bpt>Array<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>, with which <bpt i="3" x="3">&lt;c3&gt;</bpt>Array<bpt i="4" x="4">&lt;w4&gt;</bpt>Slice<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> shares most properties and methods.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列の使用についてのさらなる情報として、<bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>Contiguous<bpt i="2" x="2">&lt;w2&gt;</bpt>Array<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>を見てください、それらと<bpt i="3" x="3">&lt;c3&gt;</bpt>Array<bpt i="4" x="4">&lt;w4&gt;</bpt>Slice<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>はほとんどのプロパティとメソッドを共有します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For more information, see <bpt i="0" x="0">&lt;a0&gt;</bpt>Ownership Policy<ept i="0">&lt;/a0&gt;</ept> in <bpt i="1" x="1">&lt;a1&gt;</bpt>Memory Management Programming Guide for Core Foundation<ept i="1">&lt;/a1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>更なる情報のために、<bpt i="0" x="0">&lt;a0&gt;</bpt>Ownership Policy<ept i="0">&lt;/a0&gt;</ept>を<bpt i="1" x="1">&lt;a1&gt;</bpt>Memory Management Programming Guide for Core Foundation<ept i="1">&lt;/a1&gt;</ept>で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For more information, see the <bpt i="0" x="0">&lt;c0&gt;</bpt>Default<bpt i="1" x="1">&lt;w1&gt;</bpt>String<bpt i="2" x="2">&lt;w2&gt;</bpt>Interpolation<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>String<bpt i="4" x="4">&lt;w4&gt;</bpt>Interpolation<bpt i="5" x="5">&lt;w5&gt;</bpt>Protocol<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> documentation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>さらなる情報として、<bpt i="0" x="0">&lt;c0&gt;</bpt>Default<bpt i="1" x="1">&lt;w1&gt;</bpt>String<bpt i="2" x="2">&lt;w2&gt;</bpt>Interpolation<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>String<bpt i="4" x="4">&lt;w4&gt;</bpt>Interpolation<bpt i="5" x="5">&lt;w5&gt;</bpt>Protocol<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>文書化を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For more information, see the <bpt i="0" x="0">&lt;c0&gt;</bpt>String<bpt i="1" x="1">&lt;w1&gt;</bpt>Interpolation<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> documentation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>さらなる情報として、<bpt i="0" x="0">&lt;c0&gt;</bpt>String<bpt i="1" x="1">&lt;w1&gt;</bpt>Interpolation<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の文書化を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For most numbers <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>, this is the difference between <bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept> and the next greater (in magnitude) representable number.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ほとんどの数<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>に対して、これは<bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept>と次の（規模における）より大きい表現可能な数との間の差異です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For other collections the counters may be out of range or of the wrong type to use as an index.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>他のコレクションに対してこれらのカウンタは、インデックスとして使うのには範囲外または間違った型になるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For other values of <bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>x<bpt i="5" x="5">&lt;w5&gt;</bpt>.significand<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is defined as follows:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>別の値<bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>に対して、<bpt i="4" x="4">&lt;c4&gt;</bpt>x<bpt i="5" x="5">&lt;w5&gt;</bpt>.significand<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は次のように定義されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For performance reasons, the size of the newly allocated storage might be greater than the requested capacity.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>性能上の理由から、新しく割り当てられたストレージは要請された容量より大きいかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For pointers to untyped, raw memory, the following mappings apply:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型無しの、生のメモリへのポインタに対して、以下のマッピングを適用します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For return types, variables, and arguments, the following mappings apply:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>戻り型、変数、そして引数のために、以下のマッピングが適用されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For signed integer types, this value is <bpt i="0" x="0">&lt;c0&gt;</bpt>(2 ** (bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Width - 1)) - 1<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, where <bpt i="2" x="2">&lt;c2&gt;</bpt>**<ept i="2">&lt;/c2&gt;</ept> is exponentiation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>符号付き整数型に対して、この値は<bpt i="0" x="0">&lt;c0&gt;</bpt>(2 ** (bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Width - 1)) - 1<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>です、そこで<bpt i="2" x="2">&lt;c2&gt;</bpt>**<ept i="2">&lt;/c2&gt;</ept>は冪演算です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For signed integer types, this value is <bpt i="0" x="0">&lt;c0&gt;</bpt>-(2 ** (bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Width - 1))<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, where <bpt i="2" x="2">&lt;c2&gt;</bpt>**<ept i="2">&lt;/c2&gt;</ept> is exponentiation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>符号付き整数型に対して、この値は<bpt i="0" x="0">&lt;c0&gt;</bpt>-(2 ** (bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Width - 1))<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>です、そこで<bpt i="2" x="2">&lt;c2&gt;</bpt>**<ept i="2">&lt;/c2&gt;</ept>は冪演算です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For signed integer types, this value is <bpt i="1" x="1">&lt;c1&gt;</bpt>-(2 ** (bit<bpt i="2" x="2">&lt;w2&gt;</bpt>Width - 1))<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>, where <bpt i="3" x="3">&lt;c3&gt;</bpt>**<ept i="3">&lt;/c3&gt;</ept> is exponentiation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>符号付き整数型に対して、この値は<bpt i="1" x="1">&lt;c1&gt;</bpt>-(2 ** (bit<bpt i="2" x="2">&lt;w2&gt;</bpt>Width - 1))<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>です、そこで<bpt i="3" x="3">&lt;c3&gt;</bpt>**<ept i="3">&lt;/c3&gt;</ept>は冪演算です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For signed integer types, this value is <bpt i="3" x="3">&lt;c3&gt;</bpt>(2 ** (bit<bpt i="4" x="4">&lt;w4&gt;</bpt>Width - 1)) - 1<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>符号付き整数型に対して、この値は<bpt i="3" x="3">&lt;c3&gt;</bpt>(2 ** (bit<bpt i="4" x="4">&lt;w4&gt;</bpt>Width - 1)) - 1<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For simple types such as integers and other structures, this means that when you change a value in one array, the value of that element does not change in any copies of the array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば整数および他の構造体のような単純な型にとって、これは、あなたがある配列の中のある値を変更する場合、その要素の値はその配列の何らかのコピーにおいては変化しないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For structs whose stored properties are all <bpt i="3" x="3">&lt;c3&gt;</bpt>Hashable<ept i="3">&lt;/c3&gt;</ept>, and for enum types that have all-<bpt i="4" x="4">&lt;c4&gt;</bpt>Hashable<ept i="4">&lt;/c4&gt;</ept> associated values, the compiler is able to provide an implementation of <bpt i="5" x="5">&lt;c5&gt;</bpt>hash(into:)<ept i="5">&lt;/c5&gt;</ept> automatically.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それらの格納プロパティが全て<bpt i="3" x="3">&lt;c3&gt;</bpt>Hashable<ept i="3">&lt;/c3&gt;</ept>であるstructに対して、そして全て<bpt i="4" x="4">&lt;c4&gt;</bpt>Hashable<ept i="4">&lt;/c4&gt;</ept>関連値を持つenum型に対して、コンパイラは<bpt i="5" x="5">&lt;c5&gt;</bpt>hash(into:)<ept i="5">&lt;/c5&gt;</ept>の実装を自動的に提供可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For tasks that need to handle cancellation by throwing an error, use the <bpt i="3" x="3">&lt;c3&gt;</bpt>with<bpt i="4" x="4">&lt;w4&gt;</bpt>Throwing<bpt i="5" x="5">&lt;w5&gt;</bpt>Task<bpt i="6" x="6">&lt;w6&gt;</bpt>Group(of:<bpt i="7" x="7">&lt;w7&gt;</bpt>returning:<bpt i="8" x="8">&lt;w8&gt;</bpt>body:)<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> method instead.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>エラーをスローすることによって取り消しを取り扱う必要があるタスクのために、<bpt i="3" x="3">&lt;c3&gt;</bpt>with<bpt i="4" x="4">&lt;w4&gt;</bpt>Throwing<bpt i="5" x="5">&lt;w5&gt;</bpt>Task<bpt i="6" x="6">&lt;w6&gt;</bpt>Group(of:<bpt i="7" x="7">&lt;w7&gt;</bpt>returning:<bpt i="8" x="8">&lt;w8&gt;</bpt>body:)<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>メソッドを代わりに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For this reason, imported Objective-C types frequently use <bpt i="3" x="3">&lt;c3&gt;</bpt>Any<bpt i="4" x="4">&lt;w4&gt;</bpt>Object<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> as the type for properties, method parameters, and return values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この理由から、インポートされたObjective-C型はしばしば<bpt i="3" x="3">&lt;c3&gt;</bpt>Any<bpt i="4" x="4">&lt;w4&gt;</bpt>Object<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>をプロパティ、メソッドパラメータ、そして戻り値の型として使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For this reason, the first operation that uses the contents of the dictionary may take O(<bpt i="5" x="5">&lt;e5&gt;</bpt>n<ept i="5">&lt;/e5&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この理由のために、辞書の内容を使う最初の演算はO(<bpt i="5" x="5">&lt;e5&gt;</bpt>n<ept i="5">&lt;/e5&gt;</ept>)をとるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For this reason, you should almost never need to use a bridged reference type directly in your own code.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この理由のために、あなたはブリッジ参照型を直接にあなた自身のコードにおいて使う必要はほとんどないはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For two finite values <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept>, the remainder <bpt i="2" x="2">&lt;c2&gt;</bpt>r<ept i="2">&lt;/c2&gt;</ept> of dividing <bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept> by <bpt i="4" x="4">&lt;c4&gt;</bpt>y<ept i="4">&lt;/c4&gt;</ept> satisfies <bpt i="5" x="5">&lt;c5&gt;</bpt>x == y * q + r<ept i="5">&lt;/c5&gt;</ept>, where <bpt i="6" x="6">&lt;c6&gt;</bpt>q<ept i="6">&lt;/c6&gt;</ept> is the integer nearest to <bpt i="7" x="7">&lt;c7&gt;</bpt>x / y<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの有限値<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept>に対して、<bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>を<bpt i="4" x="4">&lt;c4&gt;</bpt>y<ept i="4">&lt;/c4&gt;</ept>で割った余り<bpt i="2" x="2">&lt;c2&gt;</bpt>r<ept i="2">&lt;/c2&gt;</ept>は<bpt i="5" x="5">&lt;c5&gt;</bpt>x == y * q + r<ept i="5">&lt;/c5&gt;</ept>を満足させます、ここで<bpt i="6" x="6">&lt;c6&gt;</bpt>q<ept i="6">&lt;/c6&gt;</ept>は<bpt i="7" x="7">&lt;c7&gt;</bpt>x / y<ept i="7">&lt;/c7&gt;</ept>に最も近い整数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For two integers <bpt i="0" x="0">&lt;e0&gt;</bpt>a<ept i="0">&lt;/e0&gt;</ept> and <bpt i="1" x="1">&lt;e1&gt;</bpt>b<ept i="1">&lt;/e1&gt;</ept>, <bpt i="2" x="2">&lt;e2&gt;</bpt>a<ept i="2">&lt;/e2&gt;</ept> is a multiple of <bpt i="3" x="3">&lt;e3&gt;</bpt>b<ept i="3">&lt;/e3&gt;</ept> if there exists a third integer <bpt i="4" x="4">&lt;e4&gt;</bpt>q<ept i="4">&lt;/e4&gt;</ept> such that <bpt i="5" x="5">&lt;e5&gt;</bpt>a = q*b<ept i="5">&lt;/e5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの整数<bpt i="0" x="0">&lt;e0&gt;</bpt>a<ept i="0">&lt;/e0&gt;</ept>と<bpt i="1" x="1">&lt;e1&gt;</bpt>b<ept i="1">&lt;/e1&gt;</ept>に対して、<bpt i="2" x="2">&lt;e2&gt;</bpt>a<ept i="2">&lt;/e2&gt;</ept>は<bpt i="3" x="3">&lt;e3&gt;</bpt>b<ept i="3">&lt;/e3&gt;</ept>の倍数です、もし第３の整数<bpt i="4" x="4">&lt;e4&gt;</bpt>q<ept i="4">&lt;/e4&gt;</ept>が存在して、<bpt i="5" x="5">&lt;e5&gt;</bpt>a = q*b<ept i="5">&lt;/e5&gt;</ept>であるようなところでは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For two tuples to compare as equal, each corresponding pair of components must be equal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つのタプルが等しいと比較されるには、対応する構成要素同士がそれぞれ等しくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For two values <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept>, and a distance <bpt i="2" x="2">&lt;c2&gt;</bpt>n = x<bpt i="3" x="3">&lt;w3&gt;</bpt>.distance(to: y)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>x<bpt i="5" x="5">&lt;w5&gt;</bpt>.advanced(by: n) == y<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの値<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept>、そして隔たり<bpt i="2" x="2">&lt;c2&gt;</bpt>n = x<bpt i="3" x="3">&lt;w3&gt;</bpt>.distance(to: y)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に対して、<bpt i="4" x="4">&lt;c4&gt;</bpt>x<bpt i="5" x="5">&lt;w5&gt;</bpt>.advanced(by: n) == y<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For two values <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept>, the result of <bpt i="2" x="2">&lt;c2&gt;</bpt>maximum(x, y)<ept i="2">&lt;/c2&gt;</ept> is <bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept> if <bpt i="4" x="4">&lt;c4&gt;</bpt>x &gt; y<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>y<ept i="5">&lt;/c5&gt;</ept> if <bpt i="6" x="6">&lt;c6&gt;</bpt>x &lt;= y<ept i="6">&lt;/c6&gt;</ept>, or whichever of <bpt i="7" x="7">&lt;c7&gt;</bpt>x<ept i="7">&lt;/c7&gt;</ept> or <bpt i="8" x="8">&lt;c8&gt;</bpt>y<ept i="8">&lt;/c8&gt;</ept> is a number if the other is a quiet NaN.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの値<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt>maximum(x, y)<ept i="2">&lt;/c2&gt;</ept>の結果は<bpt i="4" x="4">&lt;c4&gt;</bpt>x &gt; y<ept i="4">&lt;/c4&gt;</ept>ならば<bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>、<bpt i="6" x="6">&lt;c6&gt;</bpt>x &lt;= y<ept i="6">&lt;/c6&gt;</ept>ならば<bpt i="5" x="5">&lt;c5&gt;</bpt>y<ept i="5">&lt;/c5&gt;</ept>、または他のものがクワイエットNaNならば<bpt i="7" x="7">&lt;c7&gt;</bpt>x<ept i="7">&lt;/c7&gt;</ept>か<bpt i="8" x="8">&lt;c8&gt;</bpt>y<ept i="8">&lt;/c8&gt;</ept>どちらか数である方です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For two values <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept>, the result of <bpt i="2" x="2">&lt;c2&gt;</bpt>maximum<bpt i="3" x="3">&lt;w3&gt;</bpt>Magnitude(x, y)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is <bpt i="4" x="4">&lt;c4&gt;</bpt>x<ept i="4">&lt;/c4&gt;</ept> if <bpt i="5" x="5">&lt;c5&gt;</bpt>x<bpt i="6" x="6">&lt;w6&gt;</bpt>.magnitude &gt; y<bpt i="7" x="7">&lt;w7&gt;</bpt>.magnitude<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, <bpt i="8" x="8">&lt;c8&gt;</bpt>y<ept i="8">&lt;/c8&gt;</ept> if <bpt i="9" x="9">&lt;c9&gt;</bpt>x<bpt i="10" x="10">&lt;w10&gt;</bpt>.magnitude &lt;= y<bpt i="11" x="11">&lt;w11&gt;</bpt>.magnitude<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>, or whichever of <bpt i="12" x="12">&lt;c12&gt;</bpt>x<ept i="12">&lt;/c12&gt;</ept> or <bpt i="13" x="13">&lt;c13&gt;</bpt>y<ept i="13">&lt;/c13&gt;</ept> is a number if the other is a quiet NaN.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの値<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt>maximum<bpt i="3" x="3">&lt;w3&gt;</bpt>Magnitude(x, y)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の結果は、<bpt i="5" x="5">&lt;c5&gt;</bpt>x<bpt i="6" x="6">&lt;w6&gt;</bpt>.magnitude &gt; y<bpt i="7" x="7">&lt;w7&gt;</bpt>.magnitude<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>ならば<bpt i="4" x="4">&lt;c4&gt;</bpt>x<ept i="4">&lt;/c4&gt;</ept>、<bpt i="9" x="9">&lt;c9&gt;</bpt>x<bpt i="10" x="10">&lt;w10&gt;</bpt>.magnitude &lt;= y<bpt i="11" x="11">&lt;w11&gt;</bpt>.magnitude<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>ならば<bpt i="8" x="8">&lt;c8&gt;</bpt>y<ept i="8">&lt;/c8&gt;</ept>、または他のものがクワイエットNaNならば<bpt i="12" x="12">&lt;c12&gt;</bpt>x<ept i="12">&lt;/c12&gt;</ept>か<bpt i="13" x="13">&lt;c13&gt;</bpt>y<ept i="13">&lt;/c13&gt;</ept>どちらか数である方です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For two values <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept>, the result of <bpt i="2" x="2">&lt;c2&gt;</bpt>minimum(x, y)<ept i="2">&lt;/c2&gt;</ept> is <bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept> if <bpt i="4" x="4">&lt;c4&gt;</bpt>x &lt;= y<ept i="4">&lt;/c4&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>y<ept i="5">&lt;/c5&gt;</ept> if <bpt i="6" x="6">&lt;c6&gt;</bpt>y &lt; x<ept i="6">&lt;/c6&gt;</ept>, or whichever of <bpt i="7" x="7">&lt;c7&gt;</bpt>x<ept i="7">&lt;/c7&gt;</ept> or <bpt i="8" x="8">&lt;c8&gt;</bpt>y<ept i="8">&lt;/c8&gt;</ept> is a number if the other is a quiet NaN.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの値<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt>minimum(x, y)<ept i="2">&lt;/c2&gt;</ept>の結果は<bpt i="4" x="4">&lt;c4&gt;</bpt>x &lt;= y<ept i="4">&lt;/c4&gt;</ept>ならば<bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>、<bpt i="6" x="6">&lt;c6&gt;</bpt>y &lt; x<ept i="6">&lt;/c6&gt;</ept>ならば<bpt i="5" x="5">&lt;c5&gt;</bpt>y<ept i="5">&lt;/c5&gt;</ept>、または他のものがクワイエットNaNならば<bpt i="7" x="7">&lt;c7&gt;</bpt>x<ept i="7">&lt;/c7&gt;</ept>か<bpt i="8" x="8">&lt;c8&gt;</bpt>y<ept i="8">&lt;/c8&gt;</ept>どちらか数である方です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For two values <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept>, the result of <bpt i="2" x="2">&lt;c2&gt;</bpt>minimum<bpt i="3" x="3">&lt;w3&gt;</bpt>Magnitude(x, y)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is <bpt i="4" x="4">&lt;c4&gt;</bpt>x<ept i="4">&lt;/c4&gt;</ept> if <bpt i="5" x="5">&lt;c5&gt;</bpt>x<bpt i="6" x="6">&lt;w6&gt;</bpt>.magnitude &lt;= y<bpt i="7" x="7">&lt;w7&gt;</bpt>.magnitude<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, <bpt i="8" x="8">&lt;c8&gt;</bpt>y<ept i="8">&lt;/c8&gt;</ept> if <bpt i="9" x="9">&lt;c9&gt;</bpt>y<bpt i="10" x="10">&lt;w10&gt;</bpt>.magnitude &lt; x<bpt i="11" x="11">&lt;w11&gt;</bpt>.magnitude<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>, or whichever of <bpt i="12" x="12">&lt;c12&gt;</bpt>x<ept i="12">&lt;/c12&gt;</ept> or <bpt i="13" x="13">&lt;c13&gt;</bpt>y<ept i="13">&lt;/c13&gt;</ept> is a number if the other is a quiet NaN.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの値<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept>に対して、<bpt i="2" x="2">&lt;c2&gt;</bpt>minimum<bpt i="3" x="3">&lt;w3&gt;</bpt>Magnitude(x, y)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の結果は<bpt i="5" x="5">&lt;c5&gt;</bpt>x<bpt i="6" x="6">&lt;w6&gt;</bpt>.magnitude &lt;= y<bpt i="7" x="7">&lt;w7&gt;</bpt>.magnitude<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>ならば<bpt i="4" x="4">&lt;c4&gt;</bpt>x<ept i="4">&lt;/c4&gt;</ept>、<bpt i="9" x="9">&lt;c9&gt;</bpt>y<bpt i="10" x="10">&lt;w10&gt;</bpt>.magnitude &lt; x<bpt i="11" x="11">&lt;w11&gt;</bpt>.magnitude<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>ならば<bpt i="8" x="8">&lt;c8&gt;</bpt>y<ept i="8">&lt;/c8&gt;</ept>、または他のものがクワイエットNaNならば<bpt i="12" x="12">&lt;c12&gt;</bpt>x<ept i="12">&lt;/c12&gt;</ept>か<bpt i="13" x="13">&lt;c13&gt;</bpt>y<ept i="13">&lt;/c13&gt;</ept>どちらか数である方です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For unsigned integer types, this value is <bpt i="0" x="0">&lt;c0&gt;</bpt>(2 ** bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Width) - 1<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, where <bpt i="2" x="2">&lt;c2&gt;</bpt>**<ept i="2">&lt;/c2&gt;</ept> is exponentiation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>符号なし整数型に対して、この値は<bpt i="0" x="0">&lt;c0&gt;</bpt>(2 ** bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Width) - 1<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>です、そこで<bpt i="2" x="2">&lt;c2&gt;</bpt>**<ept i="2">&lt;/c2&gt;</ept>は冪演算です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For unsigned integer types, this value is always <bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>符号なし整数型に対して、この値は常に<bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For value equality, see the equal-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept>) and the <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値の同等性については、同等演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept>）そして<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>プロトコルを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For value inequality, see the not-equal-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>!=<ept i="0">&lt;/c0&gt;</ept>) and the <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値の不等性については、不等演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>!=<ept i="0">&lt;/c0&gt;</ept>）そして<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>プロトコルを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For values <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept> and their truncated integer quotient <bpt i="2" x="2">&lt;c2&gt;</bpt>q<ept i="2">&lt;/c2&gt;</ept>, the remainder <bpt i="3" x="3">&lt;c3&gt;</bpt>r<ept i="3">&lt;/c3&gt;</ept> satisfies <bpt i="4" x="4">&lt;c4&gt;</bpt>x == y * q + r<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept>および切り捨てられる整数指数<bpt i="2" x="2">&lt;c2&gt;</bpt>q<ept i="2">&lt;/c2&gt;</ept>に対して、余り<bpt i="3" x="3">&lt;c3&gt;</bpt>r<ept i="3">&lt;/c3&gt;</ept>は<bpt i="4" x="4">&lt;c4&gt;</bpt>x == y * q + r<ept i="4">&lt;/c4&gt;</ept>を満足させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Forward declarations of Swift classes and protocols can be used only as types for method and property declarations.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftのクラスとプロトコルの前方宣言は、メソッドおよびプロパティ宣言に対する型としてのみ使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Foundation</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ファウンデーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Foundation classes often declare enumeration or constant types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Foundationクラスは、しばしば列挙や定数型を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Framework</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>フレームワーク</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>From Protocol</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>由来プロトコル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Function</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Further modifications to <bpt i="2" x="2">&lt;c2&gt;</bpt>numbers<ept i="2">&lt;/c2&gt;</ept> are made in place, while the two copies continue to share the original storage.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>numbers<ept i="2">&lt;/c2&gt;</ept>への以降の修正は、そこでなされます、一方２つのコピーは元々のストレージの共有を続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Generally, a <bpt i="1" x="1">&lt;c1&gt;</bpt>Character<ept i="1">&lt;/c1&gt;</ept> instance matches what the reader of a string will perceive as a single character.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>一般的に、ある<bpt i="1" x="1">&lt;c1&gt;</bpt>Character<ept i="1">&lt;/c1&gt;</ept>インスタンスがマッチするのは、ある文字列の読み手が単一の文字と知覚するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Generally, native Swift types that do not contain strong or weak references are trivial, as are imported C structs and enums.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>一般に、生粋のSwift型で強いまたは弱い参照を含まないものは自明です、インポートされたCのstructとenumのように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Generic Instance Method</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>総称体インスタンスメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Generic Type Alias</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>総称体型エイリアス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Getting and Setting Dictionary Values</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書の値の取得と設定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Given the <bpt i="6" x="6">&lt;c6&gt;</bpt>Counter<ept i="6">&lt;/c6&gt;</ept> sequence from the previous example, you can test for the existence of a sequence member with a one-line call:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以前の例からの<bpt i="6" x="6">&lt;c6&gt;</bpt>Counter<ept i="6">&lt;/c6&gt;</ept>シーケンスを与えられて、あなたはあるシーケンスメンバーの存在を一行呼び出しで試験できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Given two tuples <bpt i="0" x="0">&lt;c0&gt;</bpt>(a1, a2, ..., a<bpt i="1" x="1">&lt;w1&gt;</bpt>N)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>(b1, b2, ..., b<bpt i="3" x="3">&lt;w3&gt;</bpt>N)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the first tuple is after or the same as the second tuple if and only if <bpt i="4" x="4">&lt;c4&gt;</bpt>a1 &gt; b1<ept i="4">&lt;/c4&gt;</ept> or (<bpt i="5" x="5">&lt;c5&gt;</bpt>a1 == b1<ept i="5">&lt;/c5&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt>(a2, ..., a<bpt i="7" x="7">&lt;w7&gt;</bpt>N) &gt;= (b2, ..., b<bpt i="8" x="8">&lt;w8&gt;</bpt>N)<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つのタプル<bpt i="0" x="0">&lt;c0&gt;</bpt>(a1, a2, ..., a<bpt i="1" x="1">&lt;w1&gt;</bpt>N)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>(b1, b2, ..., b<bpt i="3" x="3">&lt;w3&gt;</bpt>N)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を与えられて、最初のタプルが２番目のタブルより後かそれと同じであるのは、<bpt i="4" x="4">&lt;c4&gt;</bpt>a1 &gt; b1<ept i="4">&lt;/c4&gt;</ept>または(<bpt i="5" x="5">&lt;c5&gt;</bpt>a1 == b1<ept i="5">&lt;/c5&gt;</ept>および<bpt i="6" x="6">&lt;c6&gt;</bpt>(a2, ..., a<bpt i="7" x="7">&lt;w7&gt;</bpt>N) &gt;= (b2, ..., b<bpt i="8" x="8">&lt;w8&gt;</bpt>N)<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>)である場合に限ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Given two tuples <bpt i="0" x="0">&lt;c0&gt;</bpt>(a1, a2, ..., a<bpt i="1" x="1">&lt;w1&gt;</bpt>N)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>(b1, b2, ..., b<bpt i="3" x="3">&lt;w3&gt;</bpt>N)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the first tuple is after the second tuple if and only if <bpt i="4" x="4">&lt;c4&gt;</bpt>a1 &gt; b1<ept i="4">&lt;/c4&gt;</ept> or (<bpt i="5" x="5">&lt;c5&gt;</bpt>a1 == b1<ept i="5">&lt;/c5&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt>(a2, ..., a<bpt i="7" x="7">&lt;w7&gt;</bpt>N) &gt; (b2, ..., b<bpt i="8" x="8">&lt;w8&gt;</bpt>N)<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つのタプル<bpt i="0" x="0">&lt;c0&gt;</bpt>(a1, a2, ..., a<bpt i="1" x="1">&lt;w1&gt;</bpt>N)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>(b1, b2, ..., b<bpt i="3" x="3">&lt;w3&gt;</bpt>N)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を与えられて、最初のタプルが２番目のタブルより後であるのは、<bpt i="4" x="4">&lt;c4&gt;</bpt>a1 &gt; b1<ept i="4">&lt;/c4&gt;</ept>または(<bpt i="5" x="5">&lt;c5&gt;</bpt>a1 == b1<ept i="5">&lt;/c5&gt;</ept>および<bpt i="6" x="6">&lt;c6&gt;</bpt>(a2, ..., a<bpt i="7" x="7">&lt;w7&gt;</bpt>N) &gt; (b2, ..., b<bpt i="8" x="8">&lt;w8&gt;</bpt>N)<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>)である場合に限ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Given two tuples <bpt i="0" x="0">&lt;c0&gt;</bpt>(a1, a2, ..., a<bpt i="1" x="1">&lt;w1&gt;</bpt>N)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>(b1, b2, ..., b<bpt i="3" x="3">&lt;w3&gt;</bpt>N)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the first tuple is before or the same as the second tuple if and only if <bpt i="4" x="4">&lt;c4&gt;</bpt>a1 &lt; b1<ept i="4">&lt;/c4&gt;</ept> or (<bpt i="5" x="5">&lt;c5&gt;</bpt>a1 == b1<ept i="5">&lt;/c5&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt>(a2, ..., a<bpt i="7" x="7">&lt;w7&gt;</bpt>N) &lt;= (b2, ..., b<bpt i="8" x="8">&lt;w8&gt;</bpt>N)<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つのタプル<bpt i="0" x="0">&lt;c0&gt;</bpt>(a1, a2, ..., a<bpt i="1" x="1">&lt;w1&gt;</bpt>N)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>(b1, b2, ..., b<bpt i="3" x="3">&lt;w3&gt;</bpt>N)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を与えられて、最初のタプルが２番目のタブルより前かそれと同じであるのは、<bpt i="4" x="4">&lt;c4&gt;</bpt>a1 &lt; b1<ept i="4">&lt;/c4&gt;</ept>または(<bpt i="5" x="5">&lt;c5&gt;</bpt>a1 == b1<ept i="5">&lt;/c5&gt;</ept>および<bpt i="6" x="6">&lt;c6&gt;</bpt>(a2, ..., a<bpt i="7" x="7">&lt;w7&gt;</bpt>N) &lt;= (b2, ..., b<bpt i="8" x="8">&lt;w8&gt;</bpt>N)<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>)である場合に限ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Given two tuples <bpt i="0" x="0">&lt;c0&gt;</bpt>(a1, a2, ..., a<bpt i="1" x="1">&lt;w1&gt;</bpt>N)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>(b1, b2, ..., b<bpt i="3" x="3">&lt;w3&gt;</bpt>N)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the first tuple is before the second tuple if and only if <bpt i="4" x="4">&lt;c4&gt;</bpt>a1 &lt; b1<ept i="4">&lt;/c4&gt;</ept> or (<bpt i="5" x="5">&lt;c5&gt;</bpt>a1 == b1<ept i="5">&lt;/c5&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt>(a2, ..., a<bpt i="7" x="7">&lt;w7&gt;</bpt>N) &lt; (b2, ..., b<bpt i="8" x="8">&lt;w8&gt;</bpt>N)<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つのタプル<bpt i="0" x="0">&lt;c0&gt;</bpt>(a1, a2, ..., a<bpt i="1" x="1">&lt;w1&gt;</bpt>N)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>(b1, b2, ..., b<bpt i="3" x="3">&lt;w3&gt;</bpt>N)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を与えられて、最初のタプルが２番目のタブルより後であるのは、<bpt i="4" x="4">&lt;c4&gt;</bpt>a1 &lt; b1<ept i="4">&lt;/c4&gt;</ept>または(<bpt i="5" x="5">&lt;c5&gt;</bpt>a1 == b1<ept i="5">&lt;/c5&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt>(a2, ..., a<bpt i="7" x="7">&lt;w7&gt;</bpt>N) &lt; (b2, ..., b<bpt i="8" x="8">&lt;w8&gt;</bpt>N)<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>)である場合に限ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Global Numeric Functions</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>グローバルな数値関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Growing the Size of an Array</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列の大きさの増大</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Guaranteed always unique (e.g. UUIDs).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>常に特有であると保証される（たとえば、UUID）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Handle Exceptions in Objective-C Only</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-Cにだけしかない例外を処理する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Handling Cocoa Errors in Swift</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>CocoaエラーをSwiftにおいて処理する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Handling Dynamically Typed Methods and Objects in Swift</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>動的に型付メソッドとオブジェクトをSwiftにおいて取り扱う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Hash values are not guaranteed to be equal across different executions of your program.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ハッシュ値は、あなたのプログラムの異なる実行をまたいで等しいことを保証されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Hashes the elements of the vector using the given hasher.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ベクターの要素をこの与えられたハーシャーを使ってハッシュ化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Hashes the essential components of this value by feeding them into the given hasher.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値の本質的な構成要素を、それらをその与えられたhasherへと与えることによって、ハッシュ化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Hashing a value means feeding its essential components into a hash function, represented by the <bpt i="0" x="0">&lt;c0&gt;</bpt>Hasher<ept i="0">&lt;/c0&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値をハッシュ化することは、それの本質的な構成要素を、<bpt i="0" x="0">&lt;c0&gt;</bpt>Hasher<ept i="0">&lt;/c0&gt;</ept>型によって表される、ハッシュ関数へと投入することを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here's how you handle the same error in Swift:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここに、あなたが同じエラーをSwiftで処理する方法があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here, an array of strings is created from an array literal holding only strings.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここでは、文字列からなる配列が、文字列だけを保持している配列リテラルから作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here, an array of strings is created from an array literal holding only strings:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここでは、文字列の配列が、文字列だけを保持する配列リテラルから作成されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here, the value for the key <bpt i="0" x="0">&lt;c0&gt;</bpt>"Coral"<ept i="0">&lt;/c0&gt;</ept> is updated from <bpt i="1" x="1">&lt;c1&gt;</bpt>16<ept i="1">&lt;/c1&gt;</ept> to <bpt i="2" x="2">&lt;c2&gt;</bpt>18<ept i="2">&lt;/c2&gt;</ept> and a new key-value pair is added for the key <bpt i="3" x="3">&lt;c3&gt;</bpt>"Cerise"<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここでは、キー<bpt i="0" x="0">&lt;c0&gt;</bpt>"Coral"<ept i="0">&lt;/c0&gt;</ept>に対する値が<bpt i="1" x="1">&lt;c1&gt;</bpt>16<ept i="1">&lt;/c1&gt;</ept>から<bpt i="2" x="2">&lt;c2&gt;</bpt>18<ept i="2">&lt;/c2&gt;</ept>に更新され、そして新しいキー値ペアがキー<bpt i="3" x="3">&lt;c3&gt;</bpt>"Cerise"<ept i="3">&lt;/c3&gt;</ept>に対して加えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here’s an example of a type that declares the minimal requirements for a collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここにある型の例があります、それはあるコレクションのための最小限の要件を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here’s an example of accessing the first character in a string through its subscript:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここにあるのはある文字列の最初の文字にそれの添え字を通してアクセスする例です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here’s an example of creating a set and an array using array literals:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここに配列リテラルを使って集合と配列を作成する例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here’s an example of creating an array initialized with five strings containing the letter <bpt i="0" x="0">&lt;e0&gt;</bpt>Z<ept i="0">&lt;/e0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここに、字<bpt i="0" x="0">&lt;e0&gt;</bpt>Z<ept i="0">&lt;/e0&gt;</ept>を含んでいる５つの文字列で初期化される配列を作成する例があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here’s an example of how you handle an error when calling a method in Objective-C:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここに、メソッドをObejctive-Cにおいて呼び出す時に、あなたがエラーを処理する方法の例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here’s an example of inserting a range of integers into an array of the same type:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここに整数の範囲を同じ型の配列へ挿入する例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here’s an example of sorting a list of students’ names.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここに、生徒名のリストをソートする例があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here’s an example of the number -8.5 represented as an instance of the <bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept> type, which defines a radix of 2.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここに<bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept>型のあるインスタンスとして表される数-8.5の例があります、それは２の基数を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here’s an example that finds a student name that begins with the letter “A”:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここに、文字「A」で始まる生徒名を見つける例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here’s an implementation of those steps:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここにこれらの手順の実装があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here’s how Swift imports them:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここにどのようにスウィフトがそれらをインポートするかがあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here’s how you can catch any <bpt i="0" x="0">&lt;c0&gt;</bpt>XMLParsing<bpt i="1" x="1">&lt;w1&gt;</bpt>Error<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> errors thrown by the <bpt i="2" x="2">&lt;c2&gt;</bpt>parse(_:)<ept i="2">&lt;/c2&gt;</ept> function:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここにあるのは、あなたが<bpt i="2" x="2">&lt;c2&gt;</bpt>parse(_:)<ept i="2">&lt;/c2&gt;</ept>関数によってスローされる何らかの<bpt i="0" x="0">&lt;c0&gt;</bpt>XMLParsing<bpt i="1" x="1">&lt;w1&gt;</bpt>Error<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>エラーを捕まえる方法です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here’s how you would create a dictionary of HTTP response codes and their related messages:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここにあるのは、あなたがHTTP応答コードとそれらの関連メッセージの辞書を作成する方法です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here’s the Swift version of those declarations when you import them:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここに、あなたがそれらをインポートする場合のSwiftバージョンのそれら宣言があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here’s the definition for <bpt i="2" x="2">&lt;c2&gt;</bpt>Integer<bpt i="3" x="3">&lt;w3&gt;</bpt>Ref<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and the <bpt i="4" x="4">&lt;c4&gt;</bpt>==<ept i="4">&lt;/c4&gt;</ept> function that makes it conform to <bpt i="5" x="5">&lt;c5&gt;</bpt>Equatable<ept i="5">&lt;/c5&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここに<bpt i="2" x="2">&lt;c2&gt;</bpt>Integer<bpt i="3" x="3">&lt;w3&gt;</bpt>Ref<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>とそれを<bpt i="4" x="4">&lt;c4&gt;</bpt>Equatable<ept i="4">&lt;/c4&gt;</ept>に準拠させる<bpt i="5" x="5">&lt;c5&gt;</bpt>==<ept i="5">&lt;/c5&gt;</ept>関数の定義があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here’s the initial declaration of the <bpt i="2" x="2">&lt;c2&gt;</bpt>Grid<bpt i="3" x="3">&lt;w3&gt;</bpt>Point<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここに<bpt i="2" x="2">&lt;c2&gt;</bpt>Grid<bpt i="3" x="3">&lt;w3&gt;</bpt>Point<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型の初期宣言があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here’s the initial declaration of the <bpt i="2" x="2">&lt;c2&gt;</bpt>Street<bpt i="3" x="3">&lt;w3&gt;</bpt>Address<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ここに<bpt i="2" x="2">&lt;c2&gt;</bpt>Street<bpt i="3" x="3">&lt;w3&gt;</bpt>Address<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型の初期宣言があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Hexadecimal digits include 0-9, Latin letters a-f and A-F, and their fullwidth compatibility forms.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>16進法桁は、0-9、Latin文字 a-f および A-F、そしてそれらの全角互換形式を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Historically “epsilon” has been used to refer to several different concepts in different languages, leading to confusion and bugs.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>歴史的に “イプシロン” は、異なる言語でいくつかの異なる概念に言及するのに使われていて、混乱とバグに通じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>However if you call this function from the body of a synchronous function, and that function isn’t executing in the context of any task, the unsafe task handle is <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>しかしながら、あなたがこの関数を同期関数の本体から呼び出すならば、そしてその関数が何らかのタスクの文脈において遂行していないならば、非安全タスクハンドルは<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>However, because the <bpt i="1" x="1">&lt;c1&gt;</bpt>Any<ept i="1">&lt;/c1&gt;</ept> type can refer to any type, a downcast to a more specific type isn't guaranteed by the compiler to succeed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>しかしながら、<bpt i="1" x="1">&lt;c1&gt;</bpt>Any<ept i="1">&lt;/c1&gt;</ept>型がどんな型でも参照できることから、より具体的な型へのダウンキャストはコンパイラによって成功することが保証されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>However, because the caller must potentially wait for values, you use the <bpt i="5" x="5">&lt;c5&gt;</bpt>await<ept i="5">&lt;/c5&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>しかしながら、呼び出し側が潜在的に値それらに対して待機することから、あなたは<bpt i="5" x="5">&lt;c5&gt;</bpt>await<ept i="5">&lt;/c5&gt;</ept>キーワードを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>However, during development, the ability to verify that the invariants are being upheld in testing is important.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>しかしながら、開発の間は、試験することで不変式それらが支持されていることを検証できることは重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>However, if a forced downcast fails, a runtime error is triggered:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>しかしながら、強制型キャストが失敗するならば、実行時エラーが引き起こされます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>However, if two arrays contain references to the same object, you can observe changes to that object’s properties from both arrays.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>しかしながら、２つの配列が同じオブジェクトへの参照を含むならば、あなたは両方の配列からそのオブジェクトの持つプロパティへの変更を観察するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>However, if you call <bpt i="0" x="0">&lt;c0&gt;</bpt>next()<ept i="0">&lt;/c0&gt;</ept> in the task group and propogate its error, all other tasks are canceled.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>しかしながら、あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>next()<ept i="0">&lt;/c0&gt;</ept>をタスクグループの中で呼び出してそしてそれのエラーを伝播するならば、全ての他のタスクは取り消されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>However, if you pass <bpt i="0" x="0">&lt;c0&gt;</bpt>19<ept i="0">&lt;/c0&gt;</ept> as <bpt i="1" x="1">&lt;c1&gt;</bpt>rhs<ept i="1">&lt;/c1&gt;</ept>, the method first bitmasks <bpt i="2" x="2">&lt;c2&gt;</bpt>rhs<ept i="2">&lt;/c2&gt;</ept> to <bpt i="3" x="3">&lt;c3&gt;</bpt>3<ept i="3">&lt;/c3&gt;</ept>, and then uses that masked value as the number of bits to shift <bpt i="4" x="4">&lt;c4&gt;</bpt>lhs<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>しかしながら、あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>19<ept i="0">&lt;/c0&gt;</ept>を<bpt i="1" x="1">&lt;c1&gt;</bpt>rhs<ept i="1">&lt;/c1&gt;</ept>として渡すならば、このメソッドは最初に<bpt i="2" x="2">&lt;c2&gt;</bpt>rhs<ept i="2">&lt;/c2&gt;</ept>を<bpt i="3" x="3">&lt;c3&gt;</bpt>3<ept i="3">&lt;/c3&gt;</ept>にビットマスクして、それからそのマスクされた値をビット数として使うことで<bpt i="4" x="4">&lt;c4&gt;</bpt>lhs<ept i="4">&lt;/c4&gt;</ept>をシフトします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>However, if you use <bpt i="0" x="0">&lt;c0&gt;</bpt>19<ept i="0">&lt;/c0&gt;</ept> as <bpt i="1" x="1">&lt;c1&gt;</bpt>rhs<ept i="1">&lt;/c1&gt;</ept>, the operation first bitmasks <bpt i="2" x="2">&lt;c2&gt;</bpt>rhs<ept i="2">&lt;/c2&gt;</ept> to <bpt i="3" x="3">&lt;c3&gt;</bpt>3<ept i="3">&lt;/c3&gt;</ept>, and then uses that masked value as the number of bits to shift <bpt i="4" x="4">&lt;c4&gt;</bpt>lhs<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>しかしながら、あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>19<ept i="0">&lt;/c0&gt;</ept>を<bpt i="1" x="1">&lt;c1&gt;</bpt>rhs<ept i="1">&lt;/c1&gt;</ept>として使うならば、この演算は最初に<bpt i="2" x="2">&lt;c2&gt;</bpt>rhs<ept i="2">&lt;/c2&gt;</ept>を<bpt i="3" x="3">&lt;c3&gt;</bpt>3<ept i="3">&lt;/c3&gt;</ept>にビットマスクして、それからそのマスクされた値をビット数として使うことで<bpt i="4" x="4">&lt;c4&gt;</bpt>lhs<ept i="4">&lt;/c4&gt;</ept>をシフトします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>However, if you use <bpt i="0" x="0">&lt;c0&gt;</bpt>8<ept i="0">&lt;/c0&gt;</ept> as the shift amount, the method first masks the shift amount to zero, and then performs the shift, resulting in no change to the original value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>しかしながら、あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>8<ept i="0">&lt;/c0&gt;</ept>をシフト量として使うならば、メソッドは最初にそのシフト量をマスクしてゼロにして、それからシフトを実行して、元の値に対して変更しないという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>However, in Swift, it’s imported as two methods:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>しかしながら、Swiftでは、それは２つのメソッドとしてインポートされます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>However, macros can make debugging and refactoring difficult.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>しかし、マクロはデバッグやリファクタリングを難しくすることがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>However, the kinds of inheritance hierarchies you can build with class inheritance can be also modeled using protocol inheritance and structures.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>しかしながら、あなたがクラス継承で構築できる種類の継承階層はまた、プロトコル継承と構造体を使ってモデル化できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>However, the underlying hash algorithm is designed to exhibit avalanche effects: slight changes to the seed or the input byte sequence will typically produce drastic changes in the generated hash value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>しかしながら、基礎をなすハッシュアルゴリズムは、雪崩効果を示すように設計されます：そのシードまたは入力バイト列に対するわずかな変更は、概して生成されたハッシュ値に徹底的な変化を生じさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>However, there’s no safe way to recover from Objective-C exceptions in Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>しかしながら、スウィフトにはObjective-C例外から回復する安全な方法はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>However, they're inaccessible at compile time and don't appear in the generated header for a framework target.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>しかしながら、それらはコンパイル時にはアクセス不可能です、そしてフレームワークターゲットに対する生成ヘッダの中に現れません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>However, when the closure receives <bpt i="15" x="15">&lt;c15&gt;</bpt>4<ept i="15">&lt;/c15&gt;</ept>, it throws an error, terminating the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>しかしながら、クロージャが<bpt i="15" x="15">&lt;c15&gt;</bpt>4<ept i="15">&lt;/c15&gt;</ept>を受け取る場合、それはシーケンスを終端して、エラーをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Identifiable Implementations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Identifiableの実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Identities could be any of the following:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同一性は、以下のどれかでありえます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>are<bpt i="1" x="1">&lt;w1&gt;</bpt>Equivalent(a, b)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>are<bpt i="3" x="3">&lt;w3&gt;</bpt>Equivalent(b, c)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> are both <bpt i="4" x="4">&lt;c4&gt;</bpt>true<ept i="4">&lt;/c4&gt;</ept>, then <bpt i="5" x="5">&lt;c5&gt;</bpt>are<bpt i="6" x="6">&lt;w6&gt;</bpt>Equivalent(a, c)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> is also <bpt i="7" x="7">&lt;c7&gt;</bpt>true<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>are<bpt i="1" x="1">&lt;w1&gt;</bpt>Equivalent(a, b)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>are<bpt i="3" x="3">&lt;w3&gt;</bpt>Equivalent(b, c)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が両方とも<bpt i="4" x="4">&lt;c4&gt;</bpt>true<ept i="4">&lt;/c4&gt;</ept>ならば、そのとき<bpt i="5" x="5">&lt;c5&gt;</bpt>are<bpt i="6" x="6">&lt;w6&gt;</bpt>Equivalent(a, c)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>もまた<bpt i="7" x="7">&lt;c7&gt;</bpt>true<ept i="7">&lt;/c7&gt;</ept>である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>are<bpt i="1" x="1">&lt;w1&gt;</bpt>In<bpt i="2" x="2">&lt;w2&gt;</bpt>Increasing<bpt i="3" x="3">&lt;w3&gt;</bpt>Order(a, b)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>are<bpt i="5" x="5">&lt;w5&gt;</bpt>In<bpt i="6" x="6">&lt;w6&gt;</bpt>Increasing<bpt i="7" x="7">&lt;w7&gt;</bpt>Order(b, c)<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> are both <bpt i="8" x="8">&lt;c8&gt;</bpt>true<ept i="8">&lt;/c8&gt;</ept>, then <bpt i="9" x="9">&lt;c9&gt;</bpt>are<bpt i="10" x="10">&lt;w10&gt;</bpt>In<bpt i="11" x="11">&lt;w11&gt;</bpt>Increasing<bpt i="12" x="12">&lt;w12&gt;</bpt>Order(a, c)<ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> is also <bpt i="13" x="13">&lt;c13&gt;</bpt>true<ept i="13">&lt;/c13&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>are<bpt i="1" x="1">&lt;w1&gt;</bpt>In<bpt i="2" x="2">&lt;w2&gt;</bpt>Increasing<bpt i="3" x="3">&lt;w3&gt;</bpt>Order(a, b)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>are<bpt i="5" x="5">&lt;w5&gt;</bpt>In<bpt i="6" x="6">&lt;w6&gt;</bpt>Increasing<bpt i="7" x="7">&lt;w7&gt;</bpt>Order(b, c)<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>が両方とも<bpt i="8" x="8">&lt;c8&gt;</bpt>true<ept i="8">&lt;/c8&gt;</ept>ならば、そのとき<bpt i="9" x="9">&lt;c9&gt;</bpt>are<bpt i="10" x="10">&lt;w10&gt;</bpt>In<bpt i="11" x="11">&lt;w11&gt;</bpt>Increasing<bpt i="12" x="12">&lt;w12&gt;</bpt>Order(a, c)<ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>もまた<bpt i="13" x="13">&lt;c13&gt;</bpt>true<ept i="13">&lt;/c13&gt;</ept>である。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Pattern<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is zero, the result is <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Pattern<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>がゼロならば、結果は<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>description<ept i="0">&lt;/c0&gt;</ept> is in an invalid format, or if the value it denotes in base 10 is not representable, the result is <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>description<ept i="0">&lt;/c0&gt;</ept>が無効な形式になっているならば、またはそれが底10で示す値が表現可能でないならば、結果は<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>distance &gt; 0<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>limit<ept i="1">&lt;/c1&gt;</ept> has no effect if it is less than <bpt i="2" x="2">&lt;c2&gt;</bpt>i<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>distance &gt; 0<ept i="0">&lt;/c0&gt;</ept>ならば、<bpt i="1" x="1">&lt;c1&gt;</bpt>limit<ept i="1">&lt;/c1&gt;</ept>はそれが<bpt i="2" x="2">&lt;c2&gt;</bpt>i<ept i="2">&lt;/c2&gt;</ept>より少ないならば効果を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>distance &gt; 0<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>limit<ept i="1">&lt;/c1&gt;</ept> should be greater than <bpt i="2" x="2">&lt;c2&gt;</bpt>i<ept i="2">&lt;/c2&gt;</ept> to have any effect.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>distance &gt; 0<ept i="0">&lt;/c0&gt;</ept>ならば、<bpt i="1" x="1">&lt;c1&gt;</bpt>limit<ept i="1">&lt;/c1&gt;</ept>が何らかの効果を持つには<bpt i="2" x="2">&lt;c2&gt;</bpt>i<ept i="2">&lt;/c2&gt;</ept>より大きくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>distance &gt; 0<ept i="0">&lt;/c0&gt;</ept>, a limit that is less than <bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept> has no effect.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>distance &gt; 0<ept i="0">&lt;/c0&gt;</ept>ならば、<bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept>より少ない限度は効果を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>end<ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="1" x="1">&lt;c1&gt;</bpt>start<ept i="1">&lt;/c1&gt;</ept>, the result is zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>end<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>start<ept i="1">&lt;/c1&gt;</ept>に等しいならば、結果はゼロです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>, an empty subsequence is returned in the result for each consecutive pair of <bpt i="1" x="1">&lt;c1&gt;</bpt>separator<ept i="1">&lt;/c1&gt;</ept> elements in the collection and for each instance of <bpt i="2" x="2">&lt;c2&gt;</bpt>separator<ept i="2">&lt;/c2&gt;</ept> at the start or end of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>ならば、このコレクション中の連続する<bpt i="1" x="1">&lt;c1&gt;</bpt>separator<ept i="1">&lt;/c1&gt;</ept>要素の対それぞれに、そしてコレクションの始めと終わりの<bpt i="2" x="2">&lt;c2&gt;</bpt>separator<ept i="2">&lt;/c2&gt;</ept>インスタンスそれぞれに、１つの空の下位シーケンスが結果において返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>, an empty subsequence is returned in the result for each consecutive pair of <bpt i="1" x="1">&lt;c1&gt;</bpt>separator<ept i="1">&lt;/c1&gt;</ept> elements in the sequence and for each instance of <bpt i="2" x="2">&lt;c2&gt;</bpt>separator<ept i="2">&lt;/c2&gt;</ept> at the start or end of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>ならば、このシーケンス中の連続する<bpt i="1" x="1">&lt;c1&gt;</bpt>separator<ept i="1">&lt;/c1&gt;</ept>要素の対それぞれに、そしてシーケンスの始めと終わりの<bpt i="2" x="2">&lt;c2&gt;</bpt>separator<ept i="2">&lt;/c2&gt;</ept>インスタンスそれぞれに、１つの空の下位シーケンスが結果において返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the <bpt i="1" x="1">&lt;c1&gt;</bpt>is<bpt i="2" x="2">&lt;w2&gt;</bpt>Separator<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> predicate and for each element at the start or end of the collection satisfying the <bpt i="3" x="3">&lt;c3&gt;</bpt>is<bpt i="4" x="4">&lt;w4&gt;</bpt>Separator<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>ならば、結果において<bpt i="1" x="1">&lt;c1&gt;</bpt>is<bpt i="2" x="2">&lt;w2&gt;</bpt>Separator<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>述部を満たす隣接する要素のペアそれぞれに対しておよび<bpt i="3" x="3">&lt;c3&gt;</bpt>is<bpt i="4" x="4">&lt;w4&gt;</bpt>Separator<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>述部を満たすコレクションの始まりまたは終わりでの要素それぞれに対して１つの空の下位シーケンスが返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>, an empty subsequence is returned in the result for each pair of consecutive elements satisfying the <bpt i="1" x="1">&lt;c1&gt;</bpt>is<bpt i="2" x="2">&lt;w2&gt;</bpt>Separator<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> predicate and for each element at the start or end of the sequence satisfying the <bpt i="3" x="3">&lt;c3&gt;</bpt>is<bpt i="4" x="4">&lt;w4&gt;</bpt>Separator<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>ならば、結果において<bpt i="1" x="1">&lt;c1&gt;</bpt>is<bpt i="2" x="2">&lt;w2&gt;</bpt>Separator<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>述部を満たす隣接する要素のペアそれぞれに対しておよび<bpt i="3" x="3">&lt;c3&gt;</bpt>is<bpt i="4" x="4">&lt;w4&gt;</bpt>Separator<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>述部を満たすシーケンスの始まりまたは終わりでの要素それぞれに対して１つの空の下位シーケンスが返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>from<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>, the result of this initializer is <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>from<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>ならば、このイニシャライザの結果は、<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>i &gt; c<bpt i="1" x="1">&lt;w1&gt;</bpt>.start<bpt i="2" x="2">&lt;w2&gt;</bpt>Index &amp;&amp; i &lt;= c<bpt i="3" x="3">&lt;w3&gt;</bpt>.end<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> <bpt i="5" x="5">&lt;c5&gt;</bpt>c<bpt i="6" x="6">&lt;w6&gt;</bpt>.index(after: c<bpt i="7" x="7">&lt;w7&gt;</bpt>.index(before: i)) == i<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>i &gt; c<bpt i="1" x="1">&lt;w1&gt;</bpt>.start<bpt i="2" x="2">&lt;w2&gt;</bpt>Index &amp;&amp; i &lt;= c<bpt i="3" x="3">&lt;w3&gt;</bpt>.end<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ならば<bpt i="5" x="5">&lt;c5&gt;</bpt>c<bpt i="6" x="6">&lt;w6&gt;</bpt>.index(after: c<bpt i="7" x="7">&lt;w7&gt;</bpt>.index(before: i)) == i<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>i &gt;= c<bpt i="1" x="1">&lt;w1&gt;</bpt>.start<bpt i="2" x="2">&lt;w2&gt;</bpt>Index &amp;&amp; i &lt; c<bpt i="3" x="3">&lt;w3&gt;</bpt>.end<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>c<bpt i="6" x="6">&lt;w6&gt;</bpt>.index(before: c<bpt i="7" x="7">&lt;w7&gt;</bpt>.index(after: i)) == i<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>i &gt;= c<bpt i="1" x="1">&lt;w1&gt;</bpt>.start<bpt i="2" x="2">&lt;w2&gt;</bpt>Index &amp;&amp; i &lt; c<bpt i="3" x="3">&lt;w3&gt;</bpt>.end<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ならば、<bpt i="5" x="5">&lt;c5&gt;</bpt>c<bpt i="6" x="6">&lt;w6&gt;</bpt>.index(before: c<bpt i="7" x="7">&lt;w7&gt;</bpt>.index(after: i)) == i<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Splits + 1<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> subsequences are returned, the last one is a suffix of the original collection containing the remaining elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Splits + 1<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の下位シーケンスが返されるならば、最後のものは、残りの要素を含んでいる元コレクションの後ろ部分です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Splits + 1<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> subsequences are returned, the last one is a suffix of the original sequence containing the remaining elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Splits + 1<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の下位シーケンスが返されるならば、最後のものは、残りの要素を含んでいる元シーケンスの後ろ部分です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>n &gt; 0<ept i="0">&lt;/c0&gt;</ept>, a limit that is less than <bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept> has no effect.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>n &gt; 0<ept i="0">&lt;/c0&gt;</ept>ならば、<bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept>より少ない限度は効果を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept> can’t be represented as an instance of <bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept> without rounding, the result of this initializer is <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept>のインスタンスとして表されることが丸めることなしには可能でないならば、このイニシャライザの結果は<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept> can’t be represented as an instance of <bpt i="1" x="1">&lt;c1&gt;</bpt>Float16<ept i="1">&lt;/c1&gt;</ept> without rounding, the result of this initializer is <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Float16<ept i="1">&lt;/c1&gt;</ept>のインスタンスとして表されることが丸めることなしには可能でないならば、このイニシャライザの結果は<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept> can’t be represented as an instance of <bpt i="1" x="1">&lt;c1&gt;</bpt>Float80<ept i="1">&lt;/c1&gt;</ept> without rounding, the result of this initializer is <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Float80<ept i="1">&lt;/c1&gt;</ept>のインスタンスとして表されることが丸めることなしには可能でないならば、このイニシャライザの結果は<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept> can’t be represented as an instance of <bpt i="1" x="1">&lt;c1&gt;</bpt>Float<ept i="1">&lt;/c1&gt;</ept> without rounding, the result of this initializer is <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>Float<ept i="1">&lt;/c1&gt;</ept>のインスタンスとして表されることが丸めることなしには可能でないならば、このイニシャライザの結果は<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>, the result is <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>ならば、結果は、<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept> matches every element in the sequence, the result is an empty sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>がシーケンスの中のすべての要素に合致するならば、結果は空のシーケンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept> matches every element in the sequence, the resulting sequence contains every element of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>がシーケンスの中のすべての要素に合致するならば、結果のシーケンスはそのシーケンスのすべての要素を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>resume(throwing:)<ept i="0">&lt;/c0&gt;</ept> is called on the continuation, this function throws that error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>resume(throwing:)<ept i="0">&lt;/c0&gt;</ept>が継続上で呼び出されるならば、この関数はそのエラーをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>source<ept i="0">&lt;/c0&gt;</ept> is outside the bounds of this type after rounding toward zero, a runtime error may occur.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>source<ept i="0">&lt;/c0&gt;</ept>がゼロへの丸め後にこの型の境界の外側ならば、実行時エラーが起こるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>text<ept i="0">&lt;/c0&gt;</ept> is in an invalid format or contains characters that are out of bounds for the given <bpt i="1" x="1">&lt;c1&gt;</bpt>radix<ept i="1">&lt;/c1&gt;</ept>, or if the value it denotes in the given <bpt i="2" x="2">&lt;c2&gt;</bpt>radix<ept i="2">&lt;/c2&gt;</ept> is not representable, the result is <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>text<ept i="0">&lt;/c0&gt;</ept> が無効な形式になっているか指定<bpt i="1" x="1">&lt;c1&gt;</bpt>radix<ept i="1">&lt;/c1&gt;</ept>の領域外の文字列を含むならば、または指定<bpt i="2" x="2">&lt;c2&gt;</bpt>radix<ept i="2">&lt;/c2&gt;</ept>においてそれが意味する値が表現可能でないならば、結果は<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>, newline characters and character combinations are stripped from the result; otherwise, newline characters or character combinations are preserved.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>ならば、改行文字および文字組み合わせは結果から剥ぎ取られます；そうでなければ、改行文字および文字組み合わせは保全されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>user<bpt i="1" x="1">&lt;w1&gt;</bpt>Prefs[greeting<bpt i="2" x="2">&lt;w2&gt;</bpt>Key]<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> has a value, that value is assigned to <bpt i="3" x="3">&lt;c3&gt;</bpt>greeting<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>user<bpt i="1" x="1">&lt;w1&gt;</bpt>Prefs[greeting<bpt i="2" x="2">&lt;w2&gt;</bpt>Key]<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が値を持つならば、その値は<bpt i="3" x="3">&lt;c3&gt;</bpt>greeting<ept i="3">&lt;/c3&gt;</ept>に割り当てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> is +/-infinity or NaN, then <bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.exponent<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is <bpt i="3" x="3">&lt;c3&gt;</bpt>Int<bpt i="4" x="4">&lt;w4&gt;</bpt>.max<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>が+/-infinityまたはNaNならば、そのとき<bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.exponent<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>Int<bpt i="4" x="4">&lt;w4&gt;</bpt>.max<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> is 10, <bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.significand<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is <bpt i="3" x="3">&lt;c3&gt;</bpt>1<bpt i="4" x="4">&lt;w4&gt;</bpt>.01<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> in binary, so <bpt i="5" x="5">&lt;c5&gt;</bpt>x<bpt i="6" x="6">&lt;w6&gt;</bpt>.significand<bpt i="7" x="7">&lt;w7&gt;</bpt>Width<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> is 2.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>が10ならば、<bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.significand<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>は２進数で<bpt i="3" x="3">&lt;c3&gt;</bpt>1<bpt i="4" x="4">&lt;w4&gt;</bpt>.01<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>です、それで<bpt i="5" x="5">&lt;c5&gt;</bpt>x<bpt i="6" x="6">&lt;w6&gt;</bpt>.significand<bpt i="7" x="7">&lt;w7&gt;</bpt>Width<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>は２です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>-greatest<bpt i="2" x="2">&lt;w2&gt;</bpt>Finite<bpt i="3" x="3">&lt;w3&gt;</bpt>Magnitude<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>, then <bpt i="4" x="4">&lt;c4&gt;</bpt>x<bpt i="5" x="5">&lt;w5&gt;</bpt>.next<bpt i="6" x="6">&lt;w6&gt;</bpt>Down<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is <bpt i="7" x="7">&lt;c7&gt;</bpt>-infinity<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>-greatest<bpt i="2" x="2">&lt;w2&gt;</bpt>Finite<bpt i="3" x="3">&lt;w3&gt;</bpt>Magnitude<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>ならば、そのとき<bpt i="4" x="4">&lt;c4&gt;</bpt>x<bpt i="5" x="5">&lt;w5&gt;</bpt>.next<bpt i="6" x="6">&lt;w6&gt;</bpt>Down<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は<bpt i="7" x="7">&lt;c7&gt;</bpt>-infinity<ept i="7">&lt;/c7&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>-infinity<ept i="1">&lt;/c1&gt;</ept>, then <bpt i="2" x="2">&lt;c2&gt;</bpt>x<bpt i="3" x="3">&lt;w3&gt;</bpt>.next<bpt i="4" x="4">&lt;w4&gt;</bpt>Up<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>-greatest<bpt i="6" x="6">&lt;w6&gt;</bpt>Finite<bpt i="7" x="7">&lt;w7&gt;</bpt>Magnitude<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>-infinity<ept i="1">&lt;/c1&gt;</ept>ならば、そのとき<bpt i="2" x="2">&lt;c2&gt;</bpt>x<bpt i="3" x="3">&lt;w3&gt;</bpt>.next<bpt i="4" x="4">&lt;w4&gt;</bpt>Up<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は<bpt i="5" x="5">&lt;c5&gt;</bpt>-greatest<bpt i="6" x="6">&lt;w6&gt;</bpt>Finite<bpt i="7" x="7">&lt;w7&gt;</bpt>Magnitude<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>-least<bpt i="2" x="2">&lt;w2&gt;</bpt>Nonzero<bpt i="3" x="3">&lt;w3&gt;</bpt>Magnitude<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>, then <bpt i="4" x="4">&lt;c4&gt;</bpt>x<bpt i="5" x="5">&lt;w5&gt;</bpt>.next<bpt i="6" x="6">&lt;w6&gt;</bpt>Up<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is <bpt i="7" x="7">&lt;c7&gt;</bpt>-0<bpt i="8" x="8">&lt;w8&gt;</bpt>.0<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>-least<bpt i="2" x="2">&lt;w2&gt;</bpt>Nonzero<bpt i="3" x="3">&lt;w3&gt;</bpt>Magnitude<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>ならば、そのとき<bpt i="4" x="4">&lt;c4&gt;</bpt>x<bpt i="5" x="5">&lt;w5&gt;</bpt>.next<bpt i="6" x="6">&lt;w6&gt;</bpt>Up<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は<bpt i="7" x="7">&lt;c7&gt;</bpt>-0<bpt i="8" x="8">&lt;w8&gt;</bpt>.0<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>greatest<bpt i="2" x="2">&lt;w2&gt;</bpt>Finite<bpt i="3" x="3">&lt;w3&gt;</bpt>Magnitude<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>, then <bpt i="4" x="4">&lt;c4&gt;</bpt>x<bpt i="5" x="5">&lt;w5&gt;</bpt>.next<bpt i="6" x="6">&lt;w6&gt;</bpt>Up<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is <bpt i="7" x="7">&lt;c7&gt;</bpt>infinity<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>greatest<bpt i="2" x="2">&lt;w2&gt;</bpt>Finite<bpt i="3" x="3">&lt;w3&gt;</bpt>Magnitude<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>ならば、そのとき<bpt i="4" x="4">&lt;c4&gt;</bpt>x<bpt i="5" x="5">&lt;w5&gt;</bpt>.next<bpt i="6" x="6">&lt;w6&gt;</bpt>Up<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は<bpt i="7" x="7">&lt;c7&gt;</bpt>infinity<ept i="7">&lt;/c7&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>infinity<ept i="1">&lt;/c1&gt;</ept>, then <bpt i="2" x="2">&lt;c2&gt;</bpt>x<bpt i="3" x="3">&lt;w3&gt;</bpt>.next<bpt i="4" x="4">&lt;w4&gt;</bpt>Down<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>greatest<bpt i="6" x="6">&lt;w6&gt;</bpt>Finite<bpt i="7" x="7">&lt;w7&gt;</bpt>Magnitude<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>infinity<ept i="1">&lt;/c1&gt;</ept>ならば、そのとき<bpt i="2" x="2">&lt;c2&gt;</bpt>x<bpt i="3" x="3">&lt;w3&gt;</bpt>.next<bpt i="4" x="4">&lt;w4&gt;</bpt>Down<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>は<bpt i="5" x="5">&lt;c5&gt;</bpt>greatest<bpt i="6" x="6">&lt;w6&gt;</bpt>Finite<bpt i="7" x="7">&lt;w7&gt;</bpt>Magnitude<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>least<bpt i="2" x="2">&lt;w2&gt;</bpt>Nonzero<bpt i="3" x="3">&lt;w3&gt;</bpt>Magnitude<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>, then <bpt i="4" x="4">&lt;c4&gt;</bpt>x<bpt i="5" x="5">&lt;w5&gt;</bpt>.next<bpt i="6" x="6">&lt;w6&gt;</bpt>Down<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is <bpt i="7" x="7">&lt;c7&gt;</bpt>0<bpt i="8" x="8">&lt;w8&gt;</bpt>.0<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>least<bpt i="2" x="2">&lt;w2&gt;</bpt>Nonzero<bpt i="3" x="3">&lt;w3&gt;</bpt>Magnitude<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>ならば、そのとき<bpt i="4" x="4">&lt;c4&gt;</bpt>x<bpt i="5" x="5">&lt;w5&gt;</bpt>.next<bpt i="6" x="6">&lt;w6&gt;</bpt>Down<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は<bpt i="7" x="7">&lt;c7&gt;</bpt>0<bpt i="8" x="8">&lt;w8&gt;</bpt>.0<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> is Float.pi, <bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.significand<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is <bpt i="3" x="3">&lt;c3&gt;</bpt>1<bpt i="4" x="4">&lt;w4&gt;</bpt>.10010010000111111011011<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> in binary, and <bpt i="5" x="5">&lt;c5&gt;</bpt>x<bpt i="6" x="6">&lt;w6&gt;</bpt>.significand<bpt i="7" x="7">&lt;w7&gt;</bpt>Width<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> is 23.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>がFloat.piならば、<bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.significand<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>は２進数で<bpt i="3" x="3">&lt;c3&gt;</bpt>1<bpt i="4" x="4">&lt;w4&gt;</bpt>.10010010000111111011011<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>です、それで<bpt i="5" x="5">&lt;c5&gt;</bpt>x<bpt i="6" x="6">&lt;w6&gt;</bpt>.significand<bpt i="7" x="7">&lt;w7&gt;</bpt>Width<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>は23です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> is NaN, then <bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.significand<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is NaN.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>がNaNならば、そのとき<bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.significand<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>はNaNです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> is infinite, then <bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.significand<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is infinity.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>が無限ならば、そのとき<bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.significand<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>は無限大です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> is not a finite number, then <bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.ulp<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is NaN.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>が有限数でないならば、そのとき<bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.ulp<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>はNaNです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> is very small in magnitude, then <bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.ulp<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> may be a subnormal number.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>が規模において非常に小さいならば、<bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.ulp<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>はサブノーマル数かもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> is zero, then <bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.exponent<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is <bpt i="3" x="3">&lt;c3&gt;</bpt>Int<bpt i="4" x="4">&lt;w4&gt;</bpt>.min<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>がゼロならば、そのとき<bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.exponent<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>Int<bpt i="4" x="4">&lt;w4&gt;</bpt>.min<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> is zero, then <bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.next<bpt i="3" x="3">&lt;w3&gt;</bpt>Down<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is <bpt i="4" x="4">&lt;c4&gt;</bpt>-least<bpt i="5" x="5">&lt;w5&gt;</bpt>Nonzero<bpt i="6" x="6">&lt;w6&gt;</bpt>Magnitude<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>がゼロならば、そのとき<bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.next<bpt i="3" x="3">&lt;w3&gt;</bpt>Down<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>は<bpt i="4" x="4">&lt;c4&gt;</bpt>-least<bpt i="5" x="5">&lt;w5&gt;</bpt>Nonzero<bpt i="6" x="6">&lt;w6&gt;</bpt>Magnitude<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> is zero, then <bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.next<bpt i="3" x="3">&lt;w3&gt;</bpt>Up<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is <bpt i="4" x="4">&lt;c4&gt;</bpt>least<bpt i="5" x="5">&lt;w5&gt;</bpt>Nonzero<bpt i="6" x="6">&lt;w6&gt;</bpt>Magnitude<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>がゼロならば、そのとき<bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.next<bpt i="3" x="3">&lt;w3&gt;</bpt>Up<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>は<bpt i="4" x="4">&lt;c4&gt;</bpt>least<bpt i="5" x="5">&lt;w5&gt;</bpt>Nonzero<bpt i="6" x="6">&lt;w6&gt;</bpt>Magnitude<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> is zero, then <bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.significand<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is 0.0.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>がゼロならば、そのとき<bpt i="1" x="1">&lt;c1&gt;</bpt>x<bpt i="2" x="2">&lt;w2&gt;</bpt>.significand<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>は0.0です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="1" x="1">&lt;c1&gt;</bpt>a<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>b<ept i="2">&lt;/c2&gt;</ept> are incomparable, and <bpt i="3" x="3">&lt;c3&gt;</bpt>b<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>c<ept i="4">&lt;/c4&gt;</ept> are incomparable, then <bpt i="5" x="5">&lt;c5&gt;</bpt>a<ept i="5">&lt;/c5&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt>c<ept i="6">&lt;/c6&gt;</ept> are also incomparable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>a<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>b<ept i="2">&lt;/c2&gt;</ept>が比較できないならば、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>b<ept i="3">&lt;/c3&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>c<ept i="4">&lt;/c4&gt;</ept>が比較できないならば、そのとき<bpt i="5" x="5">&lt;c5&gt;</bpt>a<ept i="5">&lt;/c5&gt;</ept>と<bpt i="6" x="6">&lt;c6&gt;</bpt>c<ept i="6">&lt;/c6&gt;</ept>もまた比較できない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="1" x="1">&lt;c1&gt;</bpt>body<ept i="1">&lt;/c1&gt;</ept> has a return value, that value is also used as the return value for the <bpt i="2" x="2">&lt;c2&gt;</bpt>with<bpt i="3" x="3">&lt;w3&gt;</bpt>Extended<bpt i="4" x="4">&lt;w4&gt;</bpt>Lifetime(_:<bpt i="5" x="5">&lt;w5&gt;</bpt>_:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>body<ept i="1">&lt;/c1&gt;</ept>が戻り値を持つならば、その値はまた<bpt i="2" x="2">&lt;c2&gt;</bpt>with<bpt i="3" x="3">&lt;w3&gt;</bpt>Extended<bpt i="4" x="4">&lt;w4&gt;</bpt>Lifetime(_:<bpt i="5" x="5">&lt;w5&gt;</bpt>_:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドの戻り値としても使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="1" x="1">&lt;c1&gt;</bpt>body<ept i="1">&lt;/c1&gt;</ept> has a return value, that value is also used as the return value for the <bpt i="2" x="2">&lt;c2&gt;</bpt>without<bpt i="3" x="3">&lt;w3&gt;</bpt>Actually<bpt i="4" x="4">&lt;w4&gt;</bpt>Escaping(_:<bpt i="5" x="5">&lt;w5&gt;</bpt>do:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>body<ept i="1">&lt;/c1&gt;</ept>が戻り値を持つならば、その値はまた<bpt i="2" x="2">&lt;c2&gt;</bpt>without<bpt i="3" x="3">&lt;w3&gt;</bpt>Actually<bpt i="4" x="4">&lt;w4&gt;</bpt>Escaping(_:<bpt i="5" x="5">&lt;w5&gt;</bpt>do:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>関数の戻り値としても使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="1" x="1">&lt;c1&gt;</bpt>element<ept i="1">&lt;/c1&gt;</ept> is not found in the collection, returns <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>element<ept i="1">&lt;/c1&gt;</ept>がコレクションの中に見つけられないならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="1" x="1">&lt;c1&gt;</bpt>element<ept i="1">&lt;/c1&gt;</ept> is not found in the collection, this method returns <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>element<ept i="1">&lt;/c1&gt;</ept>がコレクションの中に見つけられないならば、このメソッドは<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="1" x="1">&lt;c1&gt;</bpt>key<ept i="1">&lt;/c1&gt;</ept> already exists in the dictionary, <bpt i="2" x="2">&lt;c2&gt;</bpt>value<ept i="2">&lt;/c2&gt;</ept> replaces the existing associated value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>key<ept i="1">&lt;/c1&gt;</ept>が既に辞書の中に存在するならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>value<ept i="2">&lt;/c2&gt;</ept>が既存の結び付けられる値に取って代わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="1" x="1">&lt;c1&gt;</bpt>pointer<ept i="1">&lt;/c1&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>, the result is <bpt i="3" x="3">&lt;c3&gt;</bpt>0<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>pointer<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>ならば、結果は<bpt i="3" x="3">&lt;c3&gt;</bpt>0<ept i="3">&lt;/c3&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="1" x="1">&lt;c1&gt;</bpt>rhs<ept i="1">&lt;/c1&gt;</ept> is outside the range <bpt i="2" x="2">&lt;c2&gt;</bpt>0..<it pos="begin" x="3">&lt;lhs&lt;w3&gt;</it>.bit<bpt i="4" x="4">&lt;w4&gt;</bpt>Width<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, it is masked to produce a value within that range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>rhs<ept i="1">&lt;/c1&gt;</ept>が範囲<bpt i="2" x="2">&lt;c2&gt;</bpt>0..<it pos="begin" x="3">&lt;lhs&lt;w3&gt;</it>.bit<bpt i="4" x="4">&lt;w4&gt;</bpt>Width<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の外側ならば、それはマスクされてその範囲内の値を生み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="1" x="1">&lt;c1&gt;</bpt>text<ept i="1">&lt;/c1&gt;</ept> has invalid characters or is in an invalid format, the result is <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>text<ept i="1">&lt;/c1&gt;</ept>が無効な文字を持つまたは無効な形式であるならば、結果は<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="1" x="1">&lt;c1&gt;</bpt>transform<ept i="1">&lt;/c1&gt;</ept> throws an error, the sequence ends.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>transform<ept i="1">&lt;/c1&gt;</ept>がエラーをスローするならば、そのシーケンスは終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="2" x="2">&lt;c2&gt;</bpt>are<bpt i="3" x="3">&lt;w3&gt;</bpt>In<bpt i="4" x="4">&lt;w4&gt;</bpt>Increasing<bpt i="5" x="5">&lt;w5&gt;</bpt>Order<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> throws an error during the sort, the elements may be in a different order, but none will be lost.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>are<bpt i="3" x="3">&lt;w3&gt;</bpt>In<bpt i="4" x="4">&lt;w4&gt;</bpt>Increasing<bpt i="5" x="5">&lt;w5&gt;</bpt>Order<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>がエラーをソートの間にスローするならば、要素は異なる順番になるかもしれません、しかし何１つとしてなくさないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="2" x="2">&lt;c2&gt;</bpt>distance<ept i="2">&lt;/c2&gt;</ept> is positive, this is the same value as the result of <bpt i="3" x="3">&lt;c3&gt;</bpt>distance<ept i="3">&lt;/c3&gt;</ept> calls to <bpt i="4" x="4">&lt;c4&gt;</bpt>index(after:)<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>distance<ept i="2">&lt;/c2&gt;</ept>が正ならば、これは<bpt i="3" x="3">&lt;c3&gt;</bpt>distance<ept i="3">&lt;/c3&gt;</ept>で<bpt i="4" x="4">&lt;c4&gt;</bpt>index(after:)<ept i="4">&lt;/c4&gt;</ept>を呼び出す結果と同じ値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="2" x="2">&lt;c2&gt;</bpt>i == end<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, this method is equivalent to <bpt i="4" x="4">&lt;c4&gt;</bpt>append(_:)<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>i == end<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>ならば、このメソッドは<bpt i="4" x="4">&lt;c4&gt;</bpt>append(_:)<ept i="4">&lt;/c4&gt;</ept>に相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="2" x="2">&lt;c2&gt;</bpt>n<ept i="2">&lt;/c2&gt;</ept> is positive, this is the same value as the result of <bpt i="3" x="3">&lt;c3&gt;</bpt>n<ept i="3">&lt;/c3&gt;</ept> calls to <bpt i="4" x="4">&lt;c4&gt;</bpt>index(after:)<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>n<ept i="2">&lt;/c2&gt;</ept>が正ならば、これは<bpt i="3" x="3">&lt;c3&gt;</bpt>n<ept i="3">&lt;/c3&gt;</ept>で<bpt i="4" x="4">&lt;c4&gt;</bpt>index(after:)<ept i="4">&lt;/c4&gt;</ept>を呼び出すの結果と同じ値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="2" x="2">&lt;c2&gt;</bpt>path<ept i="2">&lt;/c2&gt;</ept> can’t be appended, returns <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>path<ept i="2">&lt;/c2&gt;</ept>が追加できないならば、<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>が返ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="2" x="2">&lt;c2&gt;</bpt>rhs<ept i="2">&lt;/c2&gt;</ept> is zero, the result of the division is infinity, with the sign of the result matching the sign of <bpt i="3" x="3">&lt;c3&gt;</bpt>lhs<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>rhs<ept i="2">&lt;/c2&gt;</ept>がゼロならば、除算の結果は無限大です、結果の符号は<bpt i="3" x="3">&lt;c3&gt;</bpt>lhs<ept i="3">&lt;/c3&gt;</ept>の符号と一致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="2" x="2">&lt;c2&gt;</bpt>source<ept i="2">&lt;/c2&gt;</ept> is less than the smallest representable value in this type, the result is the type’s <bpt i="3" x="3">&lt;c3&gt;</bpt>min<ept i="3">&lt;/c3&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>source<ept i="2">&lt;/c2&gt;</ept>がこの型の最も小さい表現可能な値より小さいならば、結果はこの型のもつ<bpt i="3" x="3">&lt;c3&gt;</bpt>min<ept i="3">&lt;/c3&gt;</ept>値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="2" x="2">&lt;c2&gt;</bpt>stop<bpt i="3" x="3">&lt;w3&gt;</bpt>On<bpt i="4" x="4">&lt;w4&gt;</bpt>Error<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is <bpt i="5" x="5">&lt;c5&gt;</bpt>false<ept i="5">&lt;/c5&gt;</ept>, the entire iterator will be exhausted.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>stop<bpt i="3" x="3">&lt;w3&gt;</bpt>On<bpt i="4" x="4">&lt;w4&gt;</bpt>Error<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>false<ept i="5">&lt;/c5&gt;</ept>ならば、イテレータ全体が使い尽くされることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="2" x="2">&lt;c2&gt;</bpt>x<ept i="2">&lt;/c2&gt;</ept> is equal to <bpt i="3" x="3">&lt;c3&gt;</bpt>y<ept i="3">&lt;/c3&gt;</ept>, returns <bpt i="4" x="4">&lt;c4&gt;</bpt>x<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>x<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>y<ept i="3">&lt;/c3&gt;</ept>と等しいならば、<bpt i="4" x="4">&lt;c4&gt;</bpt>x<ept i="4">&lt;/c4&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="2" x="2">&lt;c2&gt;</bpt>x<ept i="2">&lt;/c2&gt;</ept> is equal to <bpt i="3" x="3">&lt;c3&gt;</bpt>y<ept i="3">&lt;/c3&gt;</ept>, returns <bpt i="4" x="4">&lt;c4&gt;</bpt>y<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>x<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>y<ept i="3">&lt;/c3&gt;</ept>と等しいならば、<bpt i="4" x="4">&lt;c4&gt;</bpt>y<ept i="4">&lt;/c4&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="3" x="3">&lt;c3&gt;</bpt>body<ept i="3">&lt;/c3&gt;</ept> has a return value, that value is also used as the return value for the <bpt i="4" x="4">&lt;c4&gt;</bpt>with<bpt i="5" x="5">&lt;w5&gt;</bpt>Unsafe<bpt i="6" x="6">&lt;w6&gt;</bpt>Buffer<bpt i="7" x="7">&lt;w7&gt;</bpt>Pointer(_:)<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>body<ept i="3">&lt;/c3&gt;</ept>が戻り値を持つならば、その値はまた<bpt i="4" x="4">&lt;c4&gt;</bpt>with<bpt i="5" x="5">&lt;w5&gt;</bpt>Unsafe<bpt i="6" x="6">&lt;w6&gt;</bpt>Buffer<bpt i="7" x="7">&lt;w7&gt;</bpt>Pointer(_:)<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>メソッドの戻り値としても使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="3" x="3">&lt;c3&gt;</bpt>body<ept i="3">&lt;/c3&gt;</ept> has a return value, that value is also used as the return value for the <bpt i="4" x="4">&lt;c4&gt;</bpt>with<bpt i="5" x="5">&lt;w5&gt;</bpt>Unsafe<bpt i="6" x="6">&lt;w6&gt;</bpt>Current<bpt i="7" x="7">&lt;w7&gt;</bpt>Task(body:)<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>body<ept i="3">&lt;/c3&gt;</ept>が戻り値を持つならば、その値はまた<bpt i="4" x="4">&lt;c4&gt;</bpt>with<bpt i="5" x="5">&lt;w5&gt;</bpt>Unsafe<bpt i="6" x="6">&lt;w6&gt;</bpt>Current<bpt i="7" x="7">&lt;w7&gt;</bpt>Task(body:)<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>関数の戻り値としても使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="3" x="3">&lt;c3&gt;</bpt>key<ept i="3">&lt;/c3&gt;</ept> isn’t already a key of the dictionary, the <bpt i="4" x="4">&lt;c4&gt;</bpt>(key, value)<ept i="4">&lt;/c4&gt;</ept> pair is added.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>key<ept i="3">&lt;/c3&gt;</ept>がまだこの辞書のキーでないならば、<bpt i="4" x="4">&lt;c4&gt;</bpt>(key, value)<ept i="4">&lt;/c4&gt;</ept>ペアが加えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="3" x="3">&lt;c3&gt;</bpt>object<ept i="3">&lt;/c3&gt;</ept> is <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>, the return value is <bpt i="5" x="5">&lt;c5&gt;</bpt>false<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>object<ept i="3">&lt;/c3&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>ならば、戻り値は<bpt i="5" x="5">&lt;c5&gt;</bpt>false<ept i="5">&lt;/c5&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="3" x="3">&lt;c3&gt;</bpt>transform<ept i="3">&lt;/c3&gt;</ept> throws an error, the sequence ends.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>transform<ept i="3">&lt;/c3&gt;</ept>がエラーをスローするならば、そのシーケンスは終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept>, only nonempty subsequences are returned.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept>ならば、空でない下位シーケンスだけが返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="4" x="4">&lt;c4&gt;</bpt>body<ept i="4">&lt;/c4&gt;</ept> has a return value, that value is also used as the return value for the <bpt i="5" x="5">&lt;c5&gt;</bpt>with<bpt i="6" x="6">&lt;w6&gt;</bpt>Unsafe<bpt i="7" x="7">&lt;w7&gt;</bpt>Bytes(_:)<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>body<ept i="4">&lt;/c4&gt;</ept>が戻り値を持つならば、その値はまた<bpt i="5" x="5">&lt;c5&gt;</bpt>with<bpt i="6" x="6">&lt;w6&gt;</bpt>Unsafe<bpt i="7" x="7">&lt;w7&gt;</bpt>Bytes(_:)<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>メソッドの戻り値としても使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="4" x="4">&lt;c4&gt;</bpt>body<ept i="4">&lt;/c4&gt;</ept> has a return value, that value is also used as the return value for the <bpt i="5" x="5">&lt;c5&gt;</bpt>with<bpt i="6" x="6">&lt;w6&gt;</bpt>Unsafe<bpt i="7" x="7">&lt;w7&gt;</bpt>Mutable<bpt i="8" x="8">&lt;w8&gt;</bpt>Buffer<bpt i="9" x="9">&lt;w9&gt;</bpt>Pointer(_:)<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>body<ept i="4">&lt;/c4&gt;</ept>が戻り値を持つならば、その値はまた<bpt i="5" x="5">&lt;c5&gt;</bpt>with<bpt i="6" x="6">&lt;w6&gt;</bpt>Unsafe<bpt i="7" x="7">&lt;w7&gt;</bpt>Mutable<bpt i="8" x="8">&lt;w8&gt;</bpt>Buffer<bpt i="9" x="9">&lt;w9&gt;</bpt>Pointer(_:)<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>メソッドの戻り値としても使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="4" x="4">&lt;c4&gt;</bpt>body<ept i="4">&lt;/c4&gt;</ept> has a return value, that value is also used as the return value for the <bpt i="5" x="5">&lt;c5&gt;</bpt>with<bpt i="6" x="6">&lt;w6&gt;</bpt>Va<bpt i="7" x="7">&lt;w7&gt;</bpt>List(_:)<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>body<ept i="4">&lt;/c4&gt;</ept>が戻り値を持つならば、その値はまた<bpt i="5" x="5">&lt;c5&gt;</bpt>with<bpt i="6" x="6">&lt;w6&gt;</bpt>Va<bpt i="7" x="7">&lt;w7&gt;</bpt>List(_:)<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>関数の戻り値としても使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="4" x="4">&lt;c4&gt;</bpt>next<ept i="4">&lt;/c4&gt;</ept> never returns <bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept>, the sequence is infinite.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>next<ept i="4">&lt;/c4&gt;</ept>が決して<bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept>を返さないならば、 このシーケンスは果てがありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="4" x="4">&lt;c4&gt;</bpt>possible<bpt i="5" x="5">&lt;w5&gt;</bpt>Prefix<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> has no elements, the return value is <bpt i="6" x="6">&lt;c6&gt;</bpt>true<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>possible<bpt i="5" x="5">&lt;w5&gt;</bpt>Prefix<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>が１つも要素を持たないならば、戻り値は<bpt i="6" x="6">&lt;c6&gt;</bpt>true<ept i="6">&lt;/c6&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="5" x="5">&lt;c5&gt;</bpt>body<ept i="5">&lt;/c5&gt;</ept> has a return value, that value is also used as the return value for the <bpt i="6" x="6">&lt;c6&gt;</bpt>with<bpt i="7" x="7">&lt;w7&gt;</bpt>Unsafe<bpt i="8" x="8">&lt;w8&gt;</bpt>Mutable<bpt i="9" x="9">&lt;w9&gt;</bpt>Bytes(_:)<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>body<ept i="5">&lt;/c5&gt;</ept>が戻り値を持つならば、その値はまた<bpt i="6" x="6">&lt;c6&gt;</bpt>with<bpt i="7" x="7">&lt;w7&gt;</bpt>Unsafe<bpt i="8" x="8">&lt;w8&gt;</bpt>Mutable<bpt i="9" x="9">&lt;w9&gt;</bpt>Bytes(_:)<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>メソッドの戻り値としても使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="5" x="5">&lt;c5&gt;</bpt>distance<ept i="5">&lt;/c5&gt;</ept> is negative, this is the same value as the result of <bpt i="6" x="6">&lt;c6&gt;</bpt>abs(distance)<ept i="6">&lt;/c6&gt;</ept> calls to <bpt i="7" x="7">&lt;c7&gt;</bpt>index(before:)<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>distance<ept i="5">&lt;/c5&gt;</ept>が負ならば、これは<bpt i="6" x="6">&lt;c6&gt;</bpt>abs(distance)<ept i="6">&lt;/c6&gt;</ept>で<bpt i="7" x="7">&lt;c7&gt;</bpt>index(before:)<ept i="7">&lt;/c7&gt;</ept>を呼び出す結果と同じ値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="5" x="5">&lt;c5&gt;</bpt>n<ept i="5">&lt;/c5&gt;</ept> is negative, this is the same value as the result of <bpt i="6" x="6">&lt;c6&gt;</bpt>-n<ept i="6">&lt;/c6&gt;</ept> calls to <bpt i="7" x="7">&lt;c7&gt;</bpt>index(before:)<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>n<ept i="5">&lt;/c5&gt;</ept>が負ならば、これは<bpt i="6" x="6">&lt;c6&gt;</bpt>-n<ept i="6">&lt;/c6&gt;</ept>が<bpt i="7" x="7">&lt;c7&gt;</bpt>index(before:)<ept i="7">&lt;/c7&gt;</ept>を呼び出すの結果と同じ値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>, only nonempty subsequences are returned.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>ならば、空でない下位シーケンスだけが返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="6" x="6">&lt;c6&gt;</bpt>i == end<bpt i="7" x="7">&lt;w7&gt;</bpt>Index<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>, this method is equivalent to <bpt i="8" x="8">&lt;c8&gt;</bpt>append(contents<bpt i="9" x="9">&lt;w9&gt;</bpt>Of:)<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="6" x="6">&lt;c6&gt;</bpt>i == end<bpt i="7" x="7">&lt;w7&gt;</bpt>Index<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>ならば、このメソッドは<bpt i="8" x="8">&lt;c8&gt;</bpt>append(contents<bpt i="9" x="9">&lt;w9&gt;</bpt>Of:)<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>に相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="7" x="7">&lt;c7&gt;</bpt>transform<ept i="7">&lt;/c7&gt;</ept> throws an error, the sequence terminates.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="7" x="7">&lt;c7&gt;</bpt>transform<ept i="7">&lt;/c7&gt;</ept>がエラーをスローするならば、そのシーケンスは終端します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="8" x="8">&lt;c8&gt;</bpt>x / y<ept i="8">&lt;/c8&gt;</ept> is exactly halfway between two integers, <bpt i="9" x="9">&lt;c9&gt;</bpt>q<ept i="9">&lt;/c9&gt;</ept> is chosen to be even.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="8" x="8">&lt;c8&gt;</bpt>x / y<ept i="8">&lt;/c8&gt;</ept>が正確に２つの整数の間の中ほどならば、<bpt i="9" x="9">&lt;c9&gt;</bpt>q<ept i="9">&lt;/c9&gt;</ept>は偶数である方を選ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="9" x="9">&lt;c9&gt;</bpt>copy(with:)<ept i="9">&lt;/c9&gt;</ept> returns the same array, the instances of <bpt i="10" x="10">&lt;c10&gt;</bpt>NSArray<ept i="10">&lt;/c10&gt;</ept> and <bpt i="11" x="11">&lt;c11&gt;</bpt>Array<ept i="11">&lt;/c11&gt;</ept> share storage using the same copy-on-write optimization that is used when two instances of <bpt i="12" x="12">&lt;c12&gt;</bpt>Array<ept i="12">&lt;/c12&gt;</ept> share storage.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="9" x="9">&lt;c9&gt;</bpt>copy(with:)<ept i="9">&lt;/c9&gt;</ept>が同じ配列を返すならば、<bpt i="10" x="10">&lt;c10&gt;</bpt>NSArray<ept i="10">&lt;/c10&gt;</ept>と<bpt i="11" x="11">&lt;c11&gt;</bpt>Array<ept i="11">&lt;/c11&gt;</ept>のインスタンスは同じコピーオンライト最適化を使ってストレージを共有します、それは<bpt i="12" x="12">&lt;c12&gt;</bpt>Array<ept i="12">&lt;/c12&gt;</ept>の２つのインスタンスがストレージを共有するとき使う最適化です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If EOF has already been reached when <bpt i="0" x="0">&lt;c0&gt;</bpt>read<bpt i="1" x="1">&lt;w1&gt;</bpt>Line()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is called, the result is <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>read<bpt i="1" x="1">&lt;w1&gt;</bpt>Line()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が呼ばれるときEOFがすでに到達されているならば、結果は<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If Objective-C code calls a Swift method that throws an error, the error is automatically propagated to the error pointer argument of the bridged Objective-C method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-Cコードがエラーをスローするスウィフトメソッドを呼ぶならば、そのエラーはブリッジされたObjective-Cメソッドのエラーポインタ引数に自動的に伝達されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If a type does not support subnormals, <bpt i="3" x="3">&lt;c3&gt;</bpt>x<bpt i="4" x="4">&lt;w4&gt;</bpt>.ulp<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> may be rounded to zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある型がサブノーマルをサポートしないならば、<bpt i="3" x="3">&lt;c3&gt;</bpt>x<bpt i="4" x="4">&lt;w4&gt;</bpt>.ulp<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>はゼロに丸められるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If a type’s radix is 2, then for finite nonzero numbers, the significand is in the range <bpt i="0" x="0">&lt;c0&gt;</bpt>1<bpt i="1" x="1">&lt;w1&gt;</bpt>.0 ..&lt; 2<bpt i="2" x="2">&lt;w2&gt;</bpt>.0<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある型のもつ基数が２であるならば、そのとき有限の非ゼロの数に対して、仮数は範囲<bpt i="0" x="0">&lt;c0&gt;</bpt>1<bpt i="1" x="1">&lt;w1&gt;</bpt>.0 ..&lt; 2<bpt i="2" x="2">&lt;w2&gt;</bpt>.0<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の中になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If all imported members have default values, Swift also provides a default initializer that takes no arguments.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>すべてのインポートされたメンバが省略時の値を持つならば、スウィフトもまた引数を取らない省略時のイニシャライザをひとつ提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If an <bpt i="0" x="0">&lt;c0&gt;</bpt>on<bpt i="1" x="1">&lt;w1&gt;</bpt>Termination<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> callback is set, when iteration of a AsyncStream is cancelled via task cancellation that callback is invoked.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>on<bpt i="1" x="1">&lt;w1&gt;</bpt>Termination<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>コールバックが設定されるならば、AsyncStreamの反復がタスク取り消し経由で取り消される場合、そのコールバックが発動されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If an error producing Objective-C method returns a <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>BOOL<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> value to indicate the success or failure of a method call, Swift changes the return type of the function to <bpt i="2" x="2">&lt;c2&gt;</bpt>Void<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>エラーを生成しているObjective-Cメソッドが<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>BOOL<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>値を返して、メソッド呼び出しの成功または失敗を指し示すならば、スウィフトは関数の戻り型を<bpt i="2" x="2">&lt;c2&gt;</bpt>Void<ept i="2">&lt;/c2&gt;</ept>に変えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If an object has a stronger notion of identity, it may be appropriate to provide a custom implementation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるオブジェクトがより強い同一性概念を持つならば、それはあつらえの実装を提供するのが適切であるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If another method is declared with the resulting selector, the method name is not changed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果として生じるセレクタで別のメソッドが宣言されるならば、メソッド名は変更されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If another part of the app changes <bpt i="0" x="0">&lt;c0&gt;</bpt>my<bpt i="1" x="1">&lt;w1&gt;</bpt>Nickname<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and submits a change request back to the server, the most recently rejected penpal recommendation won't be mistakenly picked up by the change.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>アプリの別の部分が<bpt i="0" x="0">&lt;c0&gt;</bpt>my<bpt i="1" x="1">&lt;w1&gt;</bpt>Nickname<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を変更するそして変更要請をサーバに提出するとしても、最近拒否した文通友達推薦が、その変更によって間違って拾い上げられることはないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If both <bpt i="14" x="14">&lt;c14&gt;</bpt>x<ept i="14">&lt;/c14&gt;</ept> and <bpt i="15" x="15">&lt;c15&gt;</bpt>y<ept i="15">&lt;/c15&gt;</ept> are NaN, or either <bpt i="16" x="16">&lt;c16&gt;</bpt>x<ept i="16">&lt;/c16&gt;</ept> or <bpt i="17" x="17">&lt;c17&gt;</bpt>y<ept i="17">&lt;/c17&gt;</ept> is a signaling NaN, the result is NaN.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="14" x="14">&lt;c14&gt;</bpt>x<ept i="14">&lt;/c14&gt;</ept>と<bpt i="15" x="15">&lt;c15&gt;</bpt>y<ept i="15">&lt;/c15&gt;</ept>の両方がNaN、または<bpt i="16" x="16">&lt;c16&gt;</bpt>x<ept i="16">&lt;/c16&gt;</ept>または<bpt i="17" x="17">&lt;c17&gt;</bpt>y<ept i="17">&lt;/c17&gt;</ept>のどちらかがシグナルNaNならば、結果はNaNです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If both <bpt i="9" x="9">&lt;c9&gt;</bpt>x<ept i="9">&lt;/c9&gt;</ept> and <bpt i="10" x="10">&lt;c10&gt;</bpt>y<ept i="10">&lt;/c10&gt;</ept> are NaN, or either <bpt i="11" x="11">&lt;c11&gt;</bpt>x<ept i="11">&lt;/c11&gt;</ept> or <bpt i="12" x="12">&lt;c12&gt;</bpt>y<ept i="12">&lt;/c12&gt;</ept> is a signaling NaN, the result is NaN.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="9" x="9">&lt;c9&gt;</bpt>x<ept i="9">&lt;/c9&gt;</ept>と<bpt i="10" x="10">&lt;c10&gt;</bpt>y<ept i="10">&lt;/c10&gt;</ept>の両方がNaN、または<bpt i="11" x="11">&lt;c11&gt;</bpt>x<ept i="11">&lt;/c11&gt;</ept>または<bpt i="12" x="12">&lt;c12&gt;</bpt>y<ept i="12">&lt;/c12&gt;</ept>のどちらかがシグナルNaNならば、結果はNaNです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If both values are <bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>, the operator returns <bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>両方の値が<bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>ならば、演算子は<bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If calling the closure throws an error, the sequence ends and <bpt i="4" x="4">&lt;c4&gt;</bpt>next()<ept i="4">&lt;/c4&gt;</ept> rethrows the error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>クロージャを呼び出すことがエラーをスローするならば、シーケンスは終了します、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>next()<ept i="4">&lt;/c4&gt;</ept>はそのエラーを再スローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If calling the closure throws an error, the sequence ends and <bpt i="5" x="5">&lt;c5&gt;</bpt>next()<ept i="5">&lt;/c5&gt;</ept> rethrows the error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>クロージャを呼び出すことがエラーをスローするならば、シーケンスは終了します、そして<bpt i="5" x="5">&lt;c5&gt;</bpt>next()<ept i="5">&lt;/c5&gt;</ept>はそのエラーを再スローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If calling the closure throws an error, the sequence ends and <bpt i="7" x="7">&lt;c7&gt;</bpt>next()<ept i="7">&lt;/c7&gt;</ept> rethrows the error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>クロージャを呼び出すことがエラーをスローするならば、シーケンスは終了します、そして<bpt i="7" x="7">&lt;c7&gt;</bpt>next()<ept i="7">&lt;/c7&gt;</ept>はそのエラーを再スローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If calling the closure throws an error, the sequence ends and <bpt i="8" x="8">&lt;c8&gt;</bpt>next()<ept i="8">&lt;/c8&gt;</ept> rethrows the error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>クロージャを呼び出すことがエラーをスローするならば、シーケンスは終了します、そして<bpt i="8" x="8">&lt;c8&gt;</bpt>next()<ept i="8">&lt;/c8&gt;</ept>はそのエラーを再スローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If calling the predicate closure throws an error, the sequence ends and <bpt i="1" x="1">&lt;c1&gt;</bpt>next()<ept i="1">&lt;/c1&gt;</ept> rethrows the error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>述部クロージャを呼び出すことがエラーをスローするならば、シーケンスは終了します、そして<bpt i="1" x="1">&lt;c1&gt;</bpt>next()<ept i="1">&lt;/c1&gt;</ept>はそのエラーを再スローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If either of the values is <bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>, the operator returns <bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値のどちらかが<bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>ならば、演算子は<bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If either this value or <bpt i="3" x="3">&lt;c3&gt;</bpt>other<ept i="3">&lt;/c3&gt;</ept> is NaN, the result of this method is <bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値または<bpt i="3" x="3">&lt;c3&gt;</bpt>other<ept i="3">&lt;/c3&gt;</ept>のどちらかがNaNならば、このメソッドの結果は<bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If included, the exponent is separated by a single character, <bpt i="0" x="0">&lt;c0&gt;</bpt>e<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>E<ept i="1">&lt;/c1&gt;</ept>, and consists of an optional plus or minus sign character and a sequence of decimal digits.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>もし含むならば、指数は１つの文字<bpt i="0" x="0">&lt;c0&gt;</bpt>e<ept i="0">&lt;/c0&gt;</ept>もしくは<bpt i="1" x="1">&lt;c1&gt;</bpt>E<ept i="1">&lt;/c1&gt;</ept>によって区切られます、そして随意のプラスまたはマイナス符号文字と一連の10進の桁から成り立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If included, the exponent is separated by a single character, <bpt i="0" x="0">&lt;c0&gt;</bpt>p<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>P<ept i="1">&lt;/c1&gt;</ept>, and consists of an optional plus or minus sign character and a sequence of decimal digits.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>もし含むならば、指数は１つの文字<bpt i="0" x="0">&lt;c0&gt;</bpt>p<ept i="0">&lt;/c0&gt;</ept>もしくは<bpt i="1" x="1">&lt;c1&gt;</bpt>P<ept i="1">&lt;/c1&gt;</ept>によって区切られます、そして随意のプラスまたはマイナス符号文字と一連の10進の桁から成り立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If necessary, the byte order of this value is reversed from the typical byte order of this integer type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>必要ならば、この値のバイト順はこの整数型の典型的なバイト順からひっくり返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If no elements in the collection match <bpt i="4" x="4">&lt;c4&gt;</bpt>belongs<bpt i="5" x="5">&lt;w5&gt;</bpt>In<bpt i="6" x="6">&lt;w6&gt;</bpt>Second<bpt i="7" x="7">&lt;w7&gt;</bpt>Partition<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, the returned index is equal to the collection’s <bpt i="8" x="8">&lt;c8&gt;</bpt>end<bpt i="9" x="9">&lt;w9&gt;</bpt>Index<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの中の要素が１つも<bpt i="4" x="4">&lt;c4&gt;</bpt>belongs<bpt i="5" x="5">&lt;w5&gt;</bpt>In<bpt i="6" x="6">&lt;w6&gt;</bpt>Second<bpt i="7" x="7">&lt;w7&gt;</bpt>Partition<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>に一致しないならば、返されるインデックスはコレクションの<bpt i="8" x="8">&lt;c8&gt;</bpt>end<bpt i="9" x="9">&lt;w9&gt;</bpt>Index<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If no elements in the collection satisfy the given predicate, returns <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの要素が与えられた述部を満たすことがないならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If no such storage exists, it is created.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのようなストレージが存在しないならば、それは作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If no such storage exists, it is first created.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのようなストレージが存在しないならば、それが最初に作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If not, any value in <bpt i="4" x="4">&lt;c4&gt;</bpt>defaults[greeting<bpt i="5" x="5">&lt;w5&gt;</bpt>Key]<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> will succeed, and if not that, <bpt i="6" x="6">&lt;c6&gt;</bpt>greeting<ept i="6">&lt;/c6&gt;</ept> will be set to the non-optional default value, <bpt i="7" x="7">&lt;c7&gt;</bpt>"Greetings!"<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そうでないならば、<bpt i="4" x="4">&lt;c4&gt;</bpt>defaults[greeting<bpt i="5" x="5">&lt;w5&gt;</bpt>Key]<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の中の何らかの値が後を継ぎます、そしてそれもないならば、<bpt i="6" x="6">&lt;c6&gt;</bpt>greeting<ept i="6">&lt;/c6&gt;</ept>は非オプショナルの省略時の値、<bpt i="7" x="7">&lt;c7&gt;</bpt>"Greetings!"<ept i="7">&lt;/c7&gt;</ept>に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If stepping from <bpt i="1" x="1">&lt;c1&gt;</bpt>start<ept i="1">&lt;/c1&gt;</ept> by <bpt i="2" x="2">&lt;c2&gt;</bpt>stride<ept i="2">&lt;/c2&gt;</ept> does not produce <bpt i="3" x="3">&lt;c3&gt;</bpt>end<ept i="3">&lt;/c3&gt;</ept>, the last value in the sequence will be one step before going beyond <bpt i="4" x="4">&lt;c4&gt;</bpt>end<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>start<ept i="1">&lt;/c1&gt;</ept>から<bpt i="2" x="2">&lt;c2&gt;</bpt>stride<ept i="2">&lt;/c2&gt;</ept>だけまたいで越えるならば、<bpt i="3" x="3">&lt;c3&gt;</bpt>end<ept i="3">&lt;/c3&gt;</ept>を生成せず、シーケンスの最後の値は<bpt i="4" x="4">&lt;c4&gt;</bpt>end<ept i="4">&lt;/c4&gt;</ept>を越える前に一またぎあるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the <bpt i="0" x="0">&lt;c0&gt;</bpt>description<ept i="0">&lt;/c0&gt;</ept> value is any string other than <bpt i="1" x="1">&lt;c1&gt;</bpt>"true"<ept i="1">&lt;/c1&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt>"false"<ept i="2">&lt;/c2&gt;</ept>, the result is <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この<bpt i="0" x="0">&lt;c0&gt;</bpt>description<ept i="0">&lt;/c0&gt;</ept>値が<bpt i="1" x="1">&lt;c1&gt;</bpt>"true"<ept i="1">&lt;/c1&gt;</ept>または<bpt i="2" x="2">&lt;c2&gt;</bpt>"false"<ept i="2">&lt;/c2&gt;</ept>と違う何らかの文字列ならば、結果は<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the <bpt i="0" x="0">&lt;c0&gt;</bpt>overflow<ept i="0">&lt;/c0&gt;</ept> component is <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>, the <bpt i="2" x="2">&lt;c2&gt;</bpt>partial<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> component contains the entire difference.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>overflow<ept i="0">&lt;/c0&gt;</ept>構成部分が<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>ならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>partial<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>構成部分は差そのままを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the <bpt i="0" x="0">&lt;c0&gt;</bpt>overflow<ept i="0">&lt;/c0&gt;</ept> component is <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>, the <bpt i="2" x="2">&lt;c2&gt;</bpt>partial<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> component contains the entire product.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>overflow<ept i="0">&lt;/c0&gt;</ept>構成部分が<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>ならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>partial<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>構成部分は積そのままを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the <bpt i="0" x="0">&lt;c0&gt;</bpt>overflow<ept i="0">&lt;/c0&gt;</ept> component is <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>, the <bpt i="2" x="2">&lt;c2&gt;</bpt>partial<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> component contains the entire quotient.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>overflow<ept i="0">&lt;/c0&gt;</ept>構成部分が<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>ならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>partial<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>構成部分は全体の商を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the <bpt i="0" x="0">&lt;c0&gt;</bpt>overflow<ept i="0">&lt;/c0&gt;</ept> component is <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>, the <bpt i="2" x="2">&lt;c2&gt;</bpt>partial<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> component contains the entire remainder.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>overflow<ept i="0">&lt;/c0&gt;</ept>構成部分が<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>ならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>partial<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>構成部分は余りそのままを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the <bpt i="0" x="0">&lt;c0&gt;</bpt>overflow<ept i="0">&lt;/c0&gt;</ept> component is <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>, the <bpt i="2" x="2">&lt;c2&gt;</bpt>partial<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> component contains the entire sum.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>overflow<ept i="0">&lt;/c0&gt;</ept>構成部分が<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>ならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>partial<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>構成部分は合計そのままを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the <bpt i="4" x="4">&lt;c4&gt;</bpt>overflow<ept i="4">&lt;/c4&gt;</ept> component is <bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>, an overflow occurred and the <bpt i="6" x="6">&lt;c6&gt;</bpt>partial<bpt i="7" x="7">&lt;w7&gt;</bpt>Value<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> component contains either the truncated quotient or, if the quotient is undefined, the dividend.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>overflow<ept i="4">&lt;/c4&gt;</ept>構成部分が<bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>であるならば、オーバーフローが起こった、そして<bpt i="6" x="6">&lt;c6&gt;</bpt>partial<bpt i="7" x="7">&lt;w7&gt;</bpt>Value<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>構成部分は切り詰められた商または、商が未定義ならば、被除数のどちらかを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the <bpt i="4" x="4">&lt;c4&gt;</bpt>overflow<ept i="4">&lt;/c4&gt;</ept> component is <bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>, an overflow occurred and the <bpt i="6" x="6">&lt;c6&gt;</bpt>partial<bpt i="7" x="7">&lt;w7&gt;</bpt>Value<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> component contains the truncated product of this value and <bpt i="8" x="8">&lt;c8&gt;</bpt>rhs<ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>overflow<ept i="4">&lt;/c4&gt;</ept>構成部分が<bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>であるならば、オーバーフローが起こると<bpt i="6" x="6">&lt;c6&gt;</bpt>partial<bpt i="7" x="7">&lt;w7&gt;</bpt>Value<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>構成部分はこの値と<bpt i="8" x="8">&lt;c8&gt;</bpt>rhs<ept i="8">&lt;/c8&gt;</ept>の積の切り詰められたものを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the <bpt i="4" x="4">&lt;c4&gt;</bpt>overflow<ept i="4">&lt;/c4&gt;</ept> component is <bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>, an overflow occurred and the <bpt i="6" x="6">&lt;c6&gt;</bpt>partial<bpt i="7" x="7">&lt;w7&gt;</bpt>Value<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> component contains the truncated result of <bpt i="8" x="8">&lt;c8&gt;</bpt>rhs<ept i="8">&lt;/c8&gt;</ept> subtracted from this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>overflow<ept i="4">&lt;/c4&gt;</ept>構成部分が<bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>であるならば、オーバーフローが起こると<bpt i="6" x="6">&lt;c6&gt;</bpt>partial<bpt i="7" x="7">&lt;w7&gt;</bpt>Value<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>構成部分はこの値から<bpt i="8" x="8">&lt;c8&gt;</bpt>rhs<ept i="8">&lt;/c8&gt;</ept>を減算した結果の切り詰められたもの含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the <bpt i="4" x="4">&lt;c4&gt;</bpt>overflow<ept i="4">&lt;/c4&gt;</ept> component is <bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>, an overflow occurred and the <bpt i="6" x="6">&lt;c6&gt;</bpt>partial<bpt i="7" x="7">&lt;w7&gt;</bpt>Value<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> component contains the truncated sum of this value and <bpt i="8" x="8">&lt;c8&gt;</bpt>rhs<ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>overflow<ept i="4">&lt;/c4&gt;</ept>構成部分が<bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>であるならば、オーバーフローが起こると<bpt i="6" x="6">&lt;c6&gt;</bpt>partial<bpt i="7" x="7">&lt;w7&gt;</bpt>Value<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>構成部分はこの値と<bpt i="8" x="8">&lt;c8&gt;</bpt>rhs<ept i="8">&lt;/c8&gt;</ept>の合計の切り詰められたものを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the <bpt i="4" x="4">&lt;c4&gt;</bpt>overflow<ept i="4">&lt;/c4&gt;</ept> component is <bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>, an overflow occurred during division and the <bpt i="6" x="6">&lt;c6&gt;</bpt>partial<bpt i="7" x="7">&lt;w7&gt;</bpt>Value<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> component contains either the entire remainder or, if the remainder is undefined, the dividend.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>overflow<ept i="4">&lt;/c4&gt;</ept>構成部分が<bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>であるならば、除算の間にオーバーフローが起こった、そして<bpt i="6" x="6">&lt;c6&gt;</bpt>partial<bpt i="7" x="7">&lt;w7&gt;</bpt>Value<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>構成部分は余りそのまままたは、余りが未定義ならば、被除数のどちらかを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the Objective-C generic parameterization specifies class or protocols qualifications, the imported Swift declaration has a constraint that requires that type to be a subclass of the specified class or to conform to the specified protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-C総称体パラメータ化がクラスまたはプロトコル適格を指定するならば、インポートされたスウィフト宣言はある制約を持ちます、それがその型に要求するのは、指定されたクラスのサブクラスであることまたは指定されたプロトコルに準拠することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the Objective-C method’s error parameter is also its first parameter, Swift attempts to simplify the method name further, by removing the <bpt i="1" x="1">&lt;c1&gt;</bpt>With<bpt i="2" x="2">&lt;w2&gt;</bpt>Error<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt>And<bpt i="4" x="4">&lt;w4&gt;</bpt>Return<bpt i="5" x="5">&lt;w5&gt;</bpt>Error<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> suffix, if present, from the first part of the selector.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-Cメソッドのerrorパラメーターがまたそれの最初のパラメーターでもあるならば、スウィフトはメソッド名をいっそう単純化することを<bpt i="1" x="1">&lt;c1&gt;</bpt>With<bpt i="2" x="2">&lt;w2&gt;</bpt>Error<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>または<bpt i="3" x="3">&lt;c3&gt;</bpt>And<bpt i="4" x="4">&lt;w4&gt;</bpt>Return<bpt i="5" x="5">&lt;w5&gt;</bpt>Error<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>接尾辞を、もしあるならば、セレクタの最初の部分から取り除くことによって試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the array is empty, <bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="2" x="2">&lt;c2&gt;</bpt>start<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列が空ならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>start<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the array is empty, <bpt i="0" x="0">&lt;c0&gt;</bpt>start<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="2" x="2">&lt;c2&gt;</bpt>end<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列が空ならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>start<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>end<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the array is empty, <bpt i="3" x="3">&lt;c3&gt;</bpt>start<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is equal to <bpt i="5" x="5">&lt;c5&gt;</bpt>end<bpt i="6" x="6">&lt;w6&gt;</bpt>Index<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列が空ならば、<bpt i="3" x="3">&lt;c3&gt;</bpt>start<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は<bpt i="5" x="5">&lt;c5&gt;</bpt>end<bpt i="6" x="6">&lt;w6&gt;</bpt>Index<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the array is empty, <bpt i="4" x="4">&lt;c4&gt;</bpt>start<bpt i="5" x="5">&lt;w5&gt;</bpt>Index<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is equal to <bpt i="6" x="6">&lt;c6&gt;</bpt>end<bpt i="7" x="7">&lt;w7&gt;</bpt>Index<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列が空ならば、<bpt i="4" x="4">&lt;c4&gt;</bpt>start<bpt i="5" x="5">&lt;w5&gt;</bpt>Index<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>は<bpt i="6" x="6">&lt;c6&gt;</bpt>end<bpt i="7" x="7">&lt;w7&gt;</bpt>Index<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the array is empty, these properties are <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その配列が空であるならば、これらのプロパティは<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the array’s <bpt i="6" x="6">&lt;c6&gt;</bpt>Element<ept i="6">&lt;/c6&gt;</ept> type is a struct or enumeration, <bpt i="7" x="7">&lt;c7&gt;</bpt>Array<ept i="7">&lt;/c7&gt;</ept> and <bpt i="8" x="8">&lt;c8&gt;</bpt>Contiguous<bpt i="9" x="9">&lt;w9&gt;</bpt>Array<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> should have similar efficiency.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列の<bpt i="6" x="6">&lt;c6&gt;</bpt>Element<ept i="6">&lt;/c6&gt;</ept>型が構造体または列挙であるならば、<bpt i="7" x="7">&lt;c7&gt;</bpt>Array<ept i="7">&lt;/c7&gt;</ept>と<bpt i="8" x="8">&lt;c8&gt;</bpt>Contiguous<bpt i="9" x="9">&lt;w9&gt;</bpt>Array<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>は同じような効率を持つはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the asynchronous sequence is empty, this method returns <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>非同期シーケンスが空ならば、このメソッドは<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the base iterator returns <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>, indicating the end of the sequence, this iterator returns <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>基底イテレータが<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>を返して、シーケンスの終わりを指し示すならば、このイテレータは<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the bit width of the shifted integer type is a power of two, masking is performed using a bitmask; otherwise, masking is performed using a modulo operation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シフトされる整数型のビット幅が２の冪ならば、マスクはビットマスクを使って実行されます；そうでなければ、マスクはモジュロ演算を使って実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the call to this method simply appends the contents of <bpt i="6" x="6">&lt;c6&gt;</bpt>new<bpt i="7" x="7">&lt;w7&gt;</bpt>Elements<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> to the array, this method is equivalent to <bpt i="8" x="8">&lt;c8&gt;</bpt>append(contents<bpt i="9" x="9">&lt;w9&gt;</bpt>Of:)<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドへの呼び出しが単に<bpt i="6" x="6">&lt;c6&gt;</bpt>new<bpt i="7" x="7">&lt;w7&gt;</bpt>Elements<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>の内容を配列に追加するだけならば、このメソッドは<bpt i="8" x="8">&lt;c8&gt;</bpt>append(contents<bpt i="9" x="9">&lt;w9&gt;</bpt>Of:)<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the call to this method simply appends the contents of <bpt i="6" x="6">&lt;c6&gt;</bpt>new<bpt i="7" x="7">&lt;w7&gt;</bpt>Elements<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> to the collection, the complexity is O(<bpt i="8" x="8">&lt;e8&gt;</bpt>m<ept i="8">&lt;/e8&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドへの呼び出しが単に<bpt i="6" x="6">&lt;c6&gt;</bpt>new<bpt i="7" x="7">&lt;w7&gt;</bpt>Elements<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>の内容をコレクションに追加するだけならば、計算量はO(<bpt i="8" x="8">&lt;e8&gt;</bpt>m<ept i="8">&lt;/e8&gt;</ept>)です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the character does not represent a hexadecimal digit, the value of this property is <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>文字が16進法桁を表さないならば、このプロパティの値は<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the closure has a return value, that value is also used as the return value of the <bpt i="1" x="1">&lt;c1&gt;</bpt>with<bpt i="2" x="2">&lt;w2&gt;</bpt>Unsafe<bpt i="3" x="3">&lt;w3&gt;</bpt>Bytes(of:<bpt i="4" x="4">&lt;w4&gt;</bpt>_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>クロージャが戻り値を持つならば、その値はまた<bpt i="1" x="1">&lt;c1&gt;</bpt>with<bpt i="2" x="2">&lt;w2&gt;</bpt>Unsafe<bpt i="3" x="3">&lt;w3&gt;</bpt>Bytes(of:<bpt i="4" x="4">&lt;w4&gt;</bpt>_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>関数の戻り値としても使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the closure has a return value, that value is also used as the return value of the <bpt i="1" x="1">&lt;c1&gt;</bpt>with<bpt i="2" x="2">&lt;w2&gt;</bpt>Unsafe<bpt i="3" x="3">&lt;w3&gt;</bpt>Mutable<bpt i="4" x="4">&lt;w4&gt;</bpt>Bytes(of:<bpt i="5" x="5">&lt;w5&gt;</bpt>_:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>クロージャが戻り値を持つならば、その値はまた<bpt i="1" x="1">&lt;c1&gt;</bpt>with<bpt i="2" x="2">&lt;w2&gt;</bpt>Unsafe<bpt i="3" x="3">&lt;w3&gt;</bpt>Mutable<bpt i="4" x="4">&lt;w4&gt;</bpt>Bytes(of:<bpt i="5" x="5">&lt;w5&gt;</bpt>_:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>関数の戻り値としても使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the closure has a return value, that value is also used as the return value of the <bpt i="1" x="1">&lt;c1&gt;</bpt>with<bpt i="2" x="2">&lt;w2&gt;</bpt>Unsafe<bpt i="3" x="3">&lt;w3&gt;</bpt>Mutable<bpt i="4" x="4">&lt;w4&gt;</bpt>Pointer(to:<bpt i="5" x="5">&lt;w5&gt;</bpt>_:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>クロージャが戻り値を持つならば、その値はまた<bpt i="1" x="1">&lt;c1&gt;</bpt>with<bpt i="2" x="2">&lt;w2&gt;</bpt>Unsafe<bpt i="3" x="3">&lt;w3&gt;</bpt>Mutable<bpt i="4" x="4">&lt;w4&gt;</bpt>Pointer(to:<bpt i="5" x="5">&lt;w5&gt;</bpt>_:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>関数の戻り値としても使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the closure has a return value, that value is also used as the return value of the <bpt i="1" x="1">&lt;c1&gt;</bpt>with<bpt i="2" x="2">&lt;w2&gt;</bpt>Unsafe<bpt i="3" x="3">&lt;w3&gt;</bpt>Pointer(to:<bpt i="4" x="4">&lt;w4&gt;</bpt>_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>クロージャが戻り値を持つならば、その値はまた<bpt i="1" x="1">&lt;c1&gt;</bpt>with<bpt i="2" x="2">&lt;w2&gt;</bpt>Unsafe<bpt i="3" x="3">&lt;w3&gt;</bpt>Pointer(to:<bpt i="4" x="4">&lt;w4&gt;</bpt>_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>関数の戻り値としても使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the closure returns <bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>next()<ept i="6">&lt;/c6&gt;</ept> returns the received element; otherwise it awaits the next element from the base iterator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>クロージャが<bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>を返すならば、<bpt i="6" x="6">&lt;c6&gt;</bpt>next()<ept i="6">&lt;/c6&gt;</ept>は受け取った要素を返します；そうでなければそれは次の要素を基底イテレータから待ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the closure you provide throws an error, the sequence produces no elements and throws the error instead.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが提供するクロージャがエラーをスローするならば、シーケンスは要素を全く生み出しません、そして代わりにエラーをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the collection does not support an internal representation in a form of contiguous storage, <bpt i="2" x="2">&lt;c2&gt;</bpt>body<ept i="2">&lt;/c2&gt;</ept> is not called and <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept> is returned.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションがある内部表現を隣接ストレージの形式でサポートしないならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>body<ept i="2">&lt;/c2&gt;</ept>は呼び出されません、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>が返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the collection does not support an internal representation in a form of mutable contiguous storage, <bpt i="2" x="2">&lt;c2&gt;</bpt>body<ept i="2">&lt;/c2&gt;</ept> is not called and <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept> is returned.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションがある内部表現を可変の隣接ストレージの形式でサポートしないならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>body<ept i="2">&lt;/c2&gt;</ept>は呼び出されません、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>が返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the collection is empty, <bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="2" x="2">&lt;c2&gt;</bpt>start<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションが空ならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>start<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the collection is empty, <bpt i="0" x="0">&lt;c0&gt;</bpt>start<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="2" x="2">&lt;c2&gt;</bpt>end<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションが空ならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>start<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>end<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the collection is empty, the method returns <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションが空ならば、このメソッドは<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the collection is empty, the value of this property is <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションが空であるならば、このプロパティは<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the consistency of an app's models is stored on a server, you can model records as structures with identifiers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるアプリの持つモデルの一貫性がサーバ上に格納されるならば、あなたはレコードを、識別子を使って構造体としてモデル化できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the continuation has already been resumed through this object, then the attempt to resume the continuation will trap.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>継続が既にこのオブジェクトを通して再開されてしまったならば、そのとき継続を再開する試みはトラップするでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the count passed to <bpt i="0" x="0">&lt;c0&gt;</bpt>prefix(_:)<ept i="0">&lt;/c0&gt;</ept> exceeds the number of elements in the base sequence, the result contains all of the elements in the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>prefix(_:)<ept i="0">&lt;/c0&gt;</ept>に渡されるcountが基底シーケンスの中の要素の数を越えるならば、結果はそのシーケンスの要素のすべてを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the dictionary doesn’t contain the key, the key and value are added as a new key-value pair.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書がそのキーを含まないならば、キーと値は新しいキー値ペアとして加えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the dictionary uses <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept> keys, the contents are encoded in a keyed container.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書が<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>キーを使うならば、内容はキー付けされるコンテナの中にエンコードされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the dictionary wraps a bridged <bpt i="1" x="1">&lt;c1&gt;</bpt>NSDictionary<ept i="1">&lt;/c1&gt;</ept>, the performance is unspecified.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書が、ブリッジされた<bpt i="1" x="1">&lt;c1&gt;</bpt>NSDictionary<ept i="1">&lt;/c1&gt;</ept>をラップするならば、性能は不特定です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the dynamic type of <bpt i="0" x="0">&lt;c0&gt;</bpt>obj<ept i="0">&lt;/c0&gt;</ept> doesn’t implement a <bpt i="1" x="1">&lt;c1&gt;</bpt>get<bpt i="2" x="2">&lt;w2&gt;</bpt>Integer<bpt i="3" x="3">&lt;w3&gt;</bpt>Value()<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> method, the system returns a runtime error when you initialize <bpt i="4" x="4">&lt;c4&gt;</bpt>certain<bpt i="5" x="5">&lt;w5&gt;</bpt>Value<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>obj<ept i="0">&lt;/c0&gt;</ept>の動的型が<bpt i="1" x="1">&lt;c1&gt;</bpt>get<bpt i="2" x="2">&lt;w2&gt;</bpt>Integer<bpt i="3" x="3">&lt;w3&gt;</bpt>Value()<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>メソッドを実装しないならば、システムは実行時エラーをあなたが<bpt i="4" x="4">&lt;c4&gt;</bpt>certain<bpt i="5" x="5">&lt;w5&gt;</bpt>Value<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を初期化する時に返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the elements in an array are instances of a class, the semantics are the same, though they might appear different at first.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列に属する要素らがクラスのインスタンスらであるならば、意味論は同じです、にもかかわらずそれらは最初は異なっているように思うかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the given floating-point value cannot be represented exactly, the result is <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた浮動小数点値が正確に表現できないならば、結果は<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the given integer cannot be represented exactly, the result is <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた整数が正確に表現できないならば、結果は<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the given key is found in the dictionary, this method returns an index into the dictionary that corresponds with the key-value pair.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたキーがこの辞書の中に見つかるならば、このメソッドは辞書の中へのあるインデックスを返し、それがそのキー値ペアに対応するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the given key is not present in the dictionary, this method adds the key-value pair and returns <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたキーがこの辞書の中に存在しないならば、このメソッドはそのキー値ペアを加えて<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the instance passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>object<ept i="0">&lt;/c0&gt;</ept> is being accessed by multiple threads simultaneously, this function may still return <bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>object<ept i="0">&lt;/c0&gt;</ept>として渡されるインスタンスが複数のスレッドによって同時にアクセスされる場合、この関数は依然として<bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the iterator needs to clean up on cancellation, it can do so after checking for cancellation as described above, or in <bpt i="0" x="0">&lt;c0&gt;</bpt>deinit<ept i="0">&lt;/c0&gt;</ept> if it’s a reference type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>イテレータが取り消しに関して片付けを必要とするならば、それはそうすることが可能です、上で記述されるように取り消しを確認した後に、またはそれが参照型であるならば<bpt i="0" x="0">&lt;c0&gt;</bpt>deinit<ept i="0">&lt;/c0&gt;</ept>において。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the key is found in the dictionary, this method returns the key’s associated value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キーが辞書の中に見つけられるならば、このメソッドはそのキーの結び付けられる値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the key isn’t found in the dictionary, <bpt i="0" x="0">&lt;c0&gt;</bpt>remove<bpt i="1" x="1">&lt;w1&gt;</bpt>Value(for<bpt i="2" x="2">&lt;w2&gt;</bpt>Key:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> returns <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キーが辞書の中に見つけられないならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>remove<bpt i="1" x="1">&lt;w1&gt;</bpt>Value(for<bpt i="2" x="2">&lt;w2&gt;</bpt>Key:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the last non-block parameter of an Objective-C method is of type <bpt i="0" x="0">&lt;c0&gt;</bpt>NSError **<ept i="0">&lt;/c0&gt;</ept>, Swift replaces it with the throws keyword, to indicate that the method can throw an error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-Cメソッドの最後の非ブロックパラメーターが型<bpt i="0" x="0">&lt;c0&gt;</bpt>NSError **<ept i="0">&lt;/c0&gt;</ept>ならば、スウィフトはそれをthrowsキーワードで置き換えて、そのメソッドがエラーをスローできることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the maximum length exceeds the number of elements in the collection, the result contains all the elements in the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最大長がコレクションの要素の数を越えるならば、結果はコレクションの要素すべてを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the maximum length exceeds the number of elements in the collection, the result contains the entire collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最大長がコレクションの要素の数を越えるならば、結果はコレクション全体を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the maximum length exceeds the number of elements in the sequence, the result contains all the elements in the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最大長がシーケンスの要素の数を越えるならば、結果はシーケンスの要素すべてを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the method calls its completion handler with a nullable parameter, the asynchronous version in Swift is marked with the <bpt i="0" x="0">&lt;c0&gt;</bpt>@discardable<bpt i="1" x="1">&lt;w1&gt;</bpt>Result<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>メソッドがそれの完了ハンドラをヌル可能パラメータで呼び出すならば、Swiftでの非同期版は、<bpt i="0" x="0">&lt;c0&gt;</bpt>@discardable<bpt i="1" x="1">&lt;w1&gt;</bpt>Result<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>属性で印されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the method has more than one parameter, and the last parameter's selector piece is one of the following, Swift imports the method as an asynchronous method:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>メソッドが１つ以上のパラメータを持つ、そして最後のパラメータの持つセレクタ部分が以下の１つであるならば、Swiftはそのメソッドをある非同期メソッドとしてインポートします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the method has only one parameter and its selector ends with one of the following suffixes, Swift imports the method as an asynchronous method:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>メソッドがただ１つのパラメータを持つ、そしてそれのセレクタが以下の接尾辞の１つで終わるならば、Swiftはそのメソッドをある非同期メソッドとしてインポートします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the name begins with a number, the first digit is replaced with an underscore.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>名前が数字で始まるならば、最初の数字はアンダースコアで置き換えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the number of elements to drop exceeds the number of elements in the collection, the result is an empty subsequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省かれることになる要素の数がコレクションの要素の数を越えるならば、結果は空の下位シーケンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the number of elements to drop exceeds the number of elements in the sequence, the result is an empty sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>取り除く要素の数がシーケンスの要素数を越えるならば、結果は空のシーケンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the passed instance conforms to <bpt i="5" x="5">&lt;c5&gt;</bpt>Custom<bpt i="6" x="6">&lt;w6&gt;</bpt>String<bpt i="7" x="7">&lt;w7&gt;</bpt>Convertible<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, the <bpt i="8" x="8">&lt;c8&gt;</bpt>String(describing:)<ept i="8">&lt;/c8&gt;</ept> initializer and the <bpt i="9" x="9">&lt;c9&gt;</bpt>print(_:)<ept i="9">&lt;/c9&gt;</ept> function use the instance’s custom <bpt i="10" x="10">&lt;c10&gt;</bpt>description<ept i="10">&lt;/c10&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>渡されたインスタンスが<bpt i="5" x="5">&lt;c5&gt;</bpt>Custom<bpt i="6" x="6">&lt;w6&gt;</bpt>String<bpt i="7" x="7">&lt;w7&gt;</bpt>Convertible<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>に準拠するならば、<bpt i="8" x="8">&lt;c8&gt;</bpt>String(describing:)<ept i="8">&lt;/c8&gt;</ept>イニシャライザと<bpt i="9" x="9">&lt;c9&gt;</bpt>print(_:)<ept i="9">&lt;/c9&gt;</ept>関数はそのインスタンスのあつらえの<bpt i="10" x="10">&lt;c10&gt;</bpt>description<ept i="10">&lt;/c10&gt;</ept>プロパティを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the payload contains any other characters, it is ignored.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ペイロードが何か他の文字を含むならば、それは無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the predicate hasn’t failed yet, this method gets the next element from the base sequence and calls the predicate with it.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>述部がまだ失敗しないならば、このメソッドは次の要素を基底シーケンスから取得します、そして述部をそれとともに呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the predicate hasn’t yet failed, this method gets the next element from the base sequence and calls the predicate with it.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>述部がまだ失敗しないならば、このメソッドは次の要素を基底シーケンスから取得します、そして述部をそれとともに呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the predicate throws an error, the sequence contains only values produced prior to the error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>述部がエラーをスローするならば、シーケンスはエラーより前に生み出された値のみを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the quotient is too large to represent in the type, a runtime error may occur.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>商がこの型において表すのに大きすぎるならば、実行時エラーが起こるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the quotient of dividing <bpt i="0" x="0">&lt;c0&gt;</bpt>dividend<ept i="0">&lt;/c0&gt;</ept> by this value is too large to represent in the type, a runtime error may occur.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>dividend<ept i="0">&lt;/c0&gt;</ept>をこの値で除算した商がこの型で表すのに大きすぎるならば、実行時エラーが起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the result of advancing by <bpt i="10" x="10">&lt;c10&gt;</bpt>n<ept i="10">&lt;/c10&gt;</ept> is not representable as a value of this type, then a runtime error may occur.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="10" x="10">&lt;c10&gt;</bpt>n<ept i="10">&lt;/c10&gt;</ept>だけ前進する結果がこの型の値として表現可能でないならば、実行時エラーが起こるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the selector ends with <bpt i="0" x="0">&lt;c0&gt;</bpt>Asynchronously<ept i="0">&lt;/c0&gt;</ept>, that suffix is removed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>セレクタが<bpt i="0" x="0">&lt;c0&gt;</bpt>Asynchronously<ept i="0">&lt;/c0&gt;</ept>で終わるならば、その接尾辞は取り除かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the selector starts with <bpt i="0" x="0">&lt;c0&gt;</bpt>get<ept i="0">&lt;/c0&gt;</ept>, that prefix is removed and leading initialisms are converted to lowercase.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>セレクタが<bpt i="0" x="0">&lt;c0&gt;</bpt>get<ept i="0">&lt;/c0&gt;</ept>で始まるならば、その接頭辞は取り除かれます、そして先導している頭文字それらは小文字に変換されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the sequence contains any values, the first one is <bpt i="0" x="0">&lt;c0&gt;</bpt>start<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスが何らかの値を含むならば、最初のものは<bpt i="0" x="0">&lt;c0&gt;</bpt>start<ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the sequence has no elements, <bpt i="0" x="0">&lt;c0&gt;</bpt>next<bpt i="1" x="1">&lt;w1&gt;</bpt>Partial<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is never executed and <bpt i="3" x="3">&lt;c3&gt;</bpt>initial<bpt i="4" x="4">&lt;w4&gt;</bpt>Result<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is the result of the call to <bpt i="5" x="5">&lt;c5&gt;</bpt>reduce(_:<bpt i="6" x="6">&lt;w6&gt;</bpt>_:)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスが１つも要素を持たないならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>next<bpt i="1" x="1">&lt;w1&gt;</bpt>Partial<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は決して実行されません、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>initial<bpt i="4" x="4">&lt;w4&gt;</bpt>Result<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は<bpt i="5" x="5">&lt;c5&gt;</bpt>reduce(_:<bpt i="6" x="6">&lt;w6&gt;</bpt>_:)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>への呼び出しの結果となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the sequence has no elements, <bpt i="0" x="0">&lt;c0&gt;</bpt>update<bpt i="1" x="1">&lt;w1&gt;</bpt>Accumulating<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is never executed and <bpt i="3" x="3">&lt;c3&gt;</bpt>initial<bpt i="4" x="4">&lt;w4&gt;</bpt>Result<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is the result of the call to <bpt i="5" x="5">&lt;c5&gt;</bpt>reduce(into:<bpt i="6" x="6">&lt;w6&gt;</bpt>_:)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスが１つも要素を持たないならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>update<bpt i="1" x="1">&lt;w1&gt;</bpt>Accumulating<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は決して実行されません、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>initial<bpt i="4" x="4">&lt;w4&gt;</bpt>Result<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は<bpt i="5" x="5">&lt;c5&gt;</bpt>reduce(into:<bpt i="6" x="6">&lt;w6&gt;</bpt>_:)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>への呼び出しの結果となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the sequence has no elements, returns <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスが要素を持たないならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the sequence has no elements, returns <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスが要素を持たないならば、<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the sequence has no elements, the result is <bpt i="0" x="0">&lt;c0&gt;</bpt>initial<bpt i="1" x="1">&lt;w1&gt;</bpt>Result<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスが１つも要素を持たないならば、結果は<bpt i="0" x="0">&lt;c0&gt;</bpt>initial<bpt i="1" x="1">&lt;w1&gt;</bpt>Result<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the sequence is empty, this method returns <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスが空ならば、このメソッドは<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the string passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>string<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> does not correspond to any instance of this type, the result is <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>string<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として渡される値がこの型の何らかのインスタンスと一致しないならば、結果は<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the task this iterator is running in is canceled while next is awaiting a value, this will terminate the AsyncStream and next may return nil immediately (or will return nil on subseuqent calls)</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その中でこのイテレータが動作しているところのタスクが、nextが値を待っている間に取り消されるならば、これはAsyncStreamを終端するでしょう、そしてnextはnilを直ぐに返すかもしれません（または続いて起こる呼び出しそれらの上でnilを返すかもしれません）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the transform returns <bpt i="6" x="6">&lt;c6&gt;</bpt>nil<ept i="6">&lt;/c6&gt;</ept>, this method continues to wait for further elements until it gets one that transforms to a non-<bpt i="7" x="7">&lt;c7&gt;</bpt>nil<ept i="7">&lt;/c7&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>変換が<bpt i="6" x="6">&lt;c6&gt;</bpt>nil<ept i="6">&lt;/c6&gt;</ept>を返すならば、このメソッドはさらに先の要素を待ち続けます、それが非<bpt i="7" x="7">&lt;c7&gt;</bpt>nil<ept i="7">&lt;/c7&gt;</ept>値へと変換するものを取得するまで。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the two ranges do not overlap, the result is a single-element range at the upper or lower bound of <bpt i="0" x="0">&lt;c0&gt;</bpt>limits<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの範囲が重ならないならば、結果は<bpt i="0" x="0">&lt;c0&gt;</bpt>limits<ept i="0">&lt;/c0&gt;</ept>の上方または下方での単一要素範囲です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the two sequences passed to <bpt i="0" x="0">&lt;c0&gt;</bpt>zip(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> are different lengths, the resulting sequence is the same length as the shorter sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>zip(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に渡された２つのシーケンスが異なる長さであるならは、結果のシーケンスはより短いシーケンスと同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the type of the value pointed to by a C pointer cannot be represented by Swift, as is the case with an incomplete struct type, the pointer is imported as an <bpt i="0" x="0">&lt;c0&gt;</bpt>Opaque<bpt i="1" x="1">&lt;w1&gt;</bpt>Pointer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Cポインタによって指し示される値の型がSwiftによって表現できないならば、不完全なstruct型を持つケース節であるなど、そのポインタは<bpt i="0" x="0">&lt;c0&gt;</bpt>Opaque<bpt i="1" x="1">&lt;w1&gt;</bpt>Pointer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>としてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the type supports subnormal values, <bpt i="0" x="0">&lt;c0&gt;</bpt>least<bpt i="1" x="1">&lt;w1&gt;</bpt>Nonzero<bpt i="2" x="2">&lt;w2&gt;</bpt>Magnitude<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is smaller than <bpt i="3" x="3">&lt;c3&gt;</bpt>least<bpt i="4" x="4">&lt;w4&gt;</bpt>Normal<bpt i="5" x="5">&lt;w5&gt;</bpt>Magnitude<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>; otherwise they are equal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その型がサブノーマル値をサポートするならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>least<bpt i="1" x="1">&lt;w1&gt;</bpt>Nonzero<bpt i="2" x="2">&lt;w2&gt;</bpt>Magnitude<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>least<bpt i="4" x="4">&lt;w4&gt;</bpt>Normal<bpt i="5" x="5">&lt;w5&gt;</bpt>Magnitude<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>より小さいです；そうでなければそれらは等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the underlying collection stored by <bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept> does not satisfy <bpt i="1" x="1">&lt;c1&gt;</bpt>Bidirectional<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>, the result is <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>によって格納される基礎をなすコレクションが<bpt i="1" x="1">&lt;c1&gt;</bpt>Bidirectional<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の条件を満たさないならば、結果は<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the underlying collection stored by <bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept> does not satisfy <bpt i="1" x="1">&lt;c1&gt;</bpt>Random<bpt i="2" x="2">&lt;w2&gt;</bpt>Access<bpt i="3" x="3">&lt;w3&gt;</bpt>Collection<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>, the result is <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>によって格納される基礎をなすコレクションが<bpt i="1" x="1">&lt;c1&gt;</bpt>Random<bpt i="2" x="2">&lt;w2&gt;</bpt>Access<bpt i="3" x="3">&lt;w3&gt;</bpt>Collection<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の条件を満たさないならば、結果は<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the value fails to encode anything, <bpt i="0" x="0">&lt;c0&gt;</bpt>encoder<ept i="0">&lt;/c0&gt;</ept> will encode an empty keyed container in its place.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値が何かをエンコードに失敗するならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>encoder<ept i="0">&lt;/c0&gt;</ept>は空のキー付きコンテナをその場でエンコードします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the value is <bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>, the result of the operation is <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>; if the value is <bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>, the result is <bpt i="4" x="4">&lt;c4&gt;</bpt>true<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値が<bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>ならば、この演算の結果は<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>です；値が<bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>ならば、結果は<bpt i="4" x="4">&lt;c4&gt;</bpt>true<ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the value is zero, then <bpt i="0" x="0">&lt;c0&gt;</bpt>leading<bpt i="1" x="1">&lt;w1&gt;</bpt>Zero<bpt i="2" x="2">&lt;w2&gt;</bpt>Bit<bpt i="3" x="3">&lt;w3&gt;</bpt>Count<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="4" x="4">&lt;c4&gt;</bpt>bit<bpt i="5" x="5">&lt;w5&gt;</bpt>Width<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値がゼロならば、そのとき<bpt i="0" x="0">&lt;c0&gt;</bpt>leading<bpt i="1" x="1">&lt;w1&gt;</bpt>Zero<bpt i="2" x="2">&lt;w2&gt;</bpt>Bit<bpt i="3" x="3">&lt;w3&gt;</bpt>Count<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="4" x="4">&lt;c4&gt;</bpt>bit<bpt i="5" x="5">&lt;w5&gt;</bpt>Width<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the value is zero, then <bpt i="0" x="0">&lt;c0&gt;</bpt>trailing<bpt i="1" x="1">&lt;w1&gt;</bpt>Zero<bpt i="2" x="2">&lt;w2&gt;</bpt>Bit<bpt i="3" x="3">&lt;w3&gt;</bpt>Count<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to <bpt i="4" x="4">&lt;c4&gt;</bpt>bit<bpt i="5" x="5">&lt;w5&gt;</bpt>Width<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値がゼロならば、そのとき<bpt i="0" x="0">&lt;c0&gt;</bpt>trailing<bpt i="1" x="1">&lt;w1&gt;</bpt>Zero<bpt i="2" x="2">&lt;w2&gt;</bpt>Bit<bpt i="3" x="3">&lt;w3&gt;</bpt>Count<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="4" x="4">&lt;c4&gt;</bpt>bit<bpt i="5" x="5">&lt;w5&gt;</bpt>Width<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the value of an existing key is updated, <bpt i="0" x="0">&lt;c0&gt;</bpt>update<bpt i="1" x="1">&lt;w1&gt;</bpt>Value(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>for<bpt i="3" x="3">&lt;w3&gt;</bpt>Key:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> returns the original value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>既存のキーの値が更新されるならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>update<bpt i="1" x="1">&lt;w1&gt;</bpt>Value(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>for<bpt i="3" x="3">&lt;w3&gt;</bpt>Key:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は元の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the value of the payload is larger than can be stored as the payload of a <bpt i="3" x="3">&lt;c3&gt;</bpt>Double<bpt i="4" x="4">&lt;w4&gt;</bpt>.nan<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, the least significant bits are used.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ペイロードの値が<bpt i="3" x="3">&lt;c3&gt;</bpt>Double<bpt i="4" x="4">&lt;w4&gt;</bpt>.nan<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>のペイロードとして格納可能であるより大きいならば、最下位ビットが使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the value of the payload is larger than can be stored as the payload of a <bpt i="3" x="3">&lt;c3&gt;</bpt>Float16<bpt i="4" x="4">&lt;w4&gt;</bpt>.nan<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, the least significant bits are used.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ペイロードの値が<bpt i="3" x="3">&lt;c3&gt;</bpt>Float16<bpt i="4" x="4">&lt;w4&gt;</bpt>.nan<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>のペイロードとして格納可能であるより大きいならば、最下位ビットが使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the value of the payload is larger than can be stored as the payload of a <bpt i="3" x="3">&lt;c3&gt;</bpt>Float80<bpt i="4" x="4">&lt;w4&gt;</bpt>.nan<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, the least significant bits are used.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ペイロードの値が<bpt i="3" x="3">&lt;c3&gt;</bpt>Float80<bpt i="4" x="4">&lt;w4&gt;</bpt>.nan<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>のペイロードとして格納可能であるより大きいならば、最下位ビットが使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the value of the payload is larger than can be stored as the payload of a <bpt i="3" x="3">&lt;c3&gt;</bpt>Float<bpt i="4" x="4">&lt;w4&gt;</bpt>.nan<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, the least significant bits are used.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ペイロードの値が<bpt i="3" x="3">&lt;c3&gt;</bpt>Float<bpt i="4" x="4">&lt;w4&gt;</bpt>.nan<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>のペイロードとして格納可能であるより大きいならば、最下位ビットが使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the value passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>int<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> does not correspond to any instance of this type, the result is <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>int<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として渡される値がこの型の何らかのインスタンスと一致しないならば、結果は<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the value passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>source<ept i="0">&lt;/c0&gt;</ept> is greater than the maximum representable value in this type, the result is the type’s <bpt i="1" x="1">&lt;c1&gt;</bpt>max<ept i="1">&lt;/c1&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>source<ept i="0">&lt;/c0&gt;</ept>として渡された値がこの型において最大限の表現可能な値より大きいならば、結果はこの型のもつ<bpt i="1" x="1">&lt;c1&gt;</bpt>max<ept i="1">&lt;/c1&gt;</ept>値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the value passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>source<ept i="0">&lt;/c0&gt;</ept> is not representable exactly, the result is <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>source<ept i="0">&lt;/c0&gt;</ept>として渡された値が正確に表現可能でないならば、結果は<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the value passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>source<ept i="0">&lt;/c0&gt;</ept> is not representable in this type, a runtime error may occur.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>source<ept i="0">&lt;/c0&gt;</ept>として渡された値がこの型で表現可能でないならば、実行時エラーが起こるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the value you pass to <bpt i="0" x="0">&lt;c0&gt;</bpt>significand<ept i="0">&lt;/c0&gt;</ept> is NaN, the result is NaN.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>significand<ept i="0">&lt;/c0&gt;</ept>に渡す値がNaNならば、結果はNaNです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the value you pass to <bpt i="0" x="0">&lt;c0&gt;</bpt>significand<ept i="0">&lt;/c0&gt;</ept> is zero or infinite, the result is zero or infinite, regardless of the value of <bpt i="1" x="1">&lt;c1&gt;</bpt>exponent<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>significand<ept i="0">&lt;/c0&gt;</ept>に渡す値がゼロまたは無限大ならば、結果はゼロまたは無限大です、<bpt i="1" x="1">&lt;c1&gt;</bpt>exponent<ept i="1">&lt;/c1&gt;</ept>の値に関係なく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If there are additional details about the error that could be helpful for recovery, use associated values to include that information.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>復旧の助けになりうるそのエラーについての追加の詳細があるならば、関連値を使ってその情報を含めてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If there are multiple equal greatest arguments, the result is the last one.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>等しい最大の引数が複数あるならば、結果は最後のものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If there are multiple equal least arguments, the result is the first one.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>複数の最も少ない引数があるならば、結果は最初の１つです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If there is no upper limit, then <bpt i="3" x="3">&lt;c3&gt;</bpt>significand<bpt i="4" x="4">&lt;w4&gt;</bpt>Bit<bpt i="5" x="5">&lt;w5&gt;</bpt>Count<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> should be <bpt i="6" x="6">&lt;c6&gt;</bpt>Int<bpt i="7" x="7">&lt;w7&gt;</bpt>.max<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>上限がないならば、そのとき<bpt i="3" x="3">&lt;c3&gt;</bpt>significand<bpt i="4" x="4">&lt;w4&gt;</bpt>Bit<bpt i="5" x="5">&lt;w5&gt;</bpt>Count<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は<bpt i="6" x="6">&lt;c6&gt;</bpt>Int<bpt i="7" x="7">&lt;w7&gt;</bpt>.max<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If there is no value of the type that corresponds with the specified raw value, this initializer returns <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された生の値に対応する型の値が１つもないならば、このイニシャライザは<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If this call succeeds, this method passes along the element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この呼び出しが成功するならば、このメソッドは要素を先へ渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If this character does not represent a whole number, or the value is too large to represent as an <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>, the value of this property is <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文字が整数を表さない、またはその値が<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>として表すには大きすぎるならば、このプロパティの値は<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If this type has value semantics, the mirror should be unaffected by subsequent mutations of the instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型が値意味論を持つならば、ミラーはインスタンスのその後の変化によって影響を受けないべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If this type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Stride<ept i="0">&lt;/c0&gt;</ept> type conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Binary<bpt i="2" x="2">&lt;w2&gt;</bpt>Integer<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>, then for a value <bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>, a distance <bpt i="4" x="4">&lt;c4&gt;</bpt>n<ept i="4">&lt;/c4&gt;</ept>, and a value <bpt i="5" x="5">&lt;c5&gt;</bpt>y = x<bpt i="6" x="6">&lt;w6&gt;</bpt>.advanced(by: n)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt>x<bpt i="8" x="8">&lt;w8&gt;</bpt>.distance(to: y) == n<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Stride<ept i="0">&lt;/c0&gt;</ept>型が<bpt i="1" x="1">&lt;c1&gt;</bpt>Binary<bpt i="2" x="2">&lt;w2&gt;</bpt>Integer<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠するならば、そのとき値<bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>、隔たり<bpt i="4" x="4">&lt;c4&gt;</bpt>n<ept i="4">&lt;/c4&gt;</ept>、そして値<bpt i="5" x="5">&lt;c5&gt;</bpt>y = x<bpt i="6" x="6">&lt;w6&gt;</bpt>.advanced(by: n)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>に対して、<bpt i="7" x="7">&lt;c7&gt;</bpt>x<bpt i="8" x="8">&lt;w8&gt;</bpt>.distance(to: y) == n<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If this type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Stride<ept i="0">&lt;/c0&gt;</ept> type conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Binary<bpt i="2" x="2">&lt;w2&gt;</bpt>Integer<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>, then for two values <bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>y<ept i="4">&lt;/c4&gt;</ept>, and a distance <bpt i="5" x="5">&lt;c5&gt;</bpt>n = x<bpt i="6" x="6">&lt;w6&gt;</bpt>.distance(to: y)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt>x<bpt i="8" x="8">&lt;w8&gt;</bpt>.advanced(by: n) == y<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Stride<ept i="0">&lt;/c0&gt;</ept>型が<bpt i="1" x="1">&lt;c1&gt;</bpt>Binary<bpt i="2" x="2">&lt;w2&gt;</bpt>Integer<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠するならば、そのとき２つの値<bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>y<ept i="4">&lt;/c4&gt;</ept>、そして隔たり<bpt i="5" x="5">&lt;c5&gt;</bpt>n = x<bpt i="6" x="6">&lt;w6&gt;</bpt>.distance(to: y)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>に対して、<bpt i="7" x="7">&lt;c7&gt;</bpt>x<bpt i="8" x="8">&lt;w8&gt;</bpt>.advanced(by: n) == y<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If this value and <bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept> are both finite numbers, the truncating remainder has the same sign as this value and is strictly smaller in magnitude than <bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値と<bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>が両方とも有限の数ならば、切り捨てられる余りはこの値と同じ符号を持ち、そして厳密に<bpt i="1" x="1">&lt;c1&gt;</bpt>other<ept i="1">&lt;/c1&gt;</ept>より小さい規模になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If this value and <bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept> are finite numbers, the remainder is in the closed range <bpt i="1" x="1">&lt;c1&gt;</bpt>-abs(other / 2)...abs(other / 2)<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値と<bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>が有限数ならば、あまりは完結範囲<bpt i="1" x="1">&lt;c1&gt;</bpt>-abs(other / 2)...abs(other / 2)<ept i="1">&lt;/c1&gt;</ept>の中に入ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If this value is a finite nonzero number, <bpt i="0" x="0">&lt;c0&gt;</bpt>significand<bpt i="1" x="1">&lt;w1&gt;</bpt>Width<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is the number of fractional bits required to represent the value of <bpt i="2" x="2">&lt;c2&gt;</bpt>significand<ept i="2">&lt;/c2&gt;</ept>; otherwise, <bpt i="3" x="3">&lt;c3&gt;</bpt>significand<bpt i="4" x="4">&lt;w4&gt;</bpt>Width<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is -1.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値が有限の非ゼロ数ならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>significand<bpt i="1" x="1">&lt;w1&gt;</bpt>Width<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>significand<ept i="2">&lt;/c2&gt;</ept>の値を表すのに必要とされる小数部ビットの数です；そうでなければ、<bpt i="3" x="3">&lt;c3&gt;</bpt>significand<bpt i="4" x="4">&lt;w4&gt;</bpt>Width<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は-1です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If those compatible types use different definitions for equality, values that were originally distinct might compare as equal when they are converted to <bpt i="4" x="4">&lt;c4&gt;</bpt>Any<bpt i="5" x="5">&lt;w5&gt;</bpt>Hashable<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それらの互換型が同等性に対して異なる定義を使うならば、元来は異なるものであった値それらは、等しいとみなされるかもしれません、それらが<bpt i="4" x="4">&lt;c4&gt;</bpt>Any<bpt i="5" x="5">&lt;w5&gt;</bpt>Hashable<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>に変換される場合は：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If two representable values are equally close, the result is the value with more trailing zeros in its significand bit pattern.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの表現可能な値が同等であるくらい近いならば、結果はその仮数ビットパターンにおいてより多く後ろに続くゼロを持つ値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you accept, Xcode creates the bridging header file along with the file you were creating, and names it by using your product module name followed by <bpt i="0" x="0">&lt;c0&gt;</bpt>"-Bridging-Header<bpt i="1" x="1">&lt;w1&gt;</bpt>.h"<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが承諾するならば、Xcodeはブリッジヘッダファイルをあなたが作成していたファイルに加えて作成します、そしてあなたのプロダクトモジュール名に<bpt i="0" x="0">&lt;c0&gt;</bpt>"-Bridging-Header<bpt i="1" x="1">&lt;w1&gt;</bpt>.h"<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を続けることでそれに名前をつけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you are adding a known number of elements to an array, use this method to avoid multiple reallocations.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが数のわかった要素を配列に加えているならば、このメソッドを使って複数の再割り当てを避けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you are adding a known number of key-value pairs to a dictionary, use this method to avoid multiple reallocations.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが数のわかったキー値ペアを辞書に加えているならば、このメソッドを使って複数の再割り当てを避けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you are sorting strings to present to the end user, use <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> APIs that perform localized comparison instead.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが文字列をソートしてエンドユーザに提供するならば、代わりに<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> APIを使うべきです、それはローカライズされた比較を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you are sorting strings to present to the end user, use <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> APIs that perform localized comparison.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが文字列をソートしてエンドユーザに提供するならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> APIを使うべきです、それはローカライズされた比較を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you assign <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> as the value for the given key, the dictionary removes that key and its associated value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが与えられたキーに値として<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>を割り当てるならば、辞書はそのキーとそれの結び付けられた値を削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you assign <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> to an existing key, the key and its associated value are removed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>を既存のキーに割り当てるならば、そのキーとそれの関連値は削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you call <bpt i="0" x="0">&lt;c0&gt;</bpt>async(priority:<bpt i="1" x="1">&lt;w1&gt;</bpt>operation:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to create a new task in a canceled group, that task is immediately canceled after creation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>async(priority:<bpt i="1" x="1">&lt;w1&gt;</bpt>operation:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を呼び出すことで新しいタスクをある取り消されたグループの中に作成するならば、そのタスクは作成の後に直ぐに取り消されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you call <bpt i="0" x="0">&lt;c0&gt;</bpt>async(priority:<bpt i="1" x="1">&lt;w1&gt;</bpt>operation:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to create a new task in a canceled group, that task is is immediately canceled after being created.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>async(priority:<bpt i="1" x="1">&lt;w1&gt;</bpt>operation:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を呼び出すことで新しいタスクをある取り消されたグループの中に作成するならば、そのタスクは作成される後に直ぐに取り消されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you call this function from the body of an asynchronous function, the unsafe task handle passed to the closure is always non-nil because an asynchronous function always runs in the context of a task.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがこの関数を非同期関数の本体から呼び出すならば、クロージャに渡された非安全タスクハンドルは常に非nilです、なぜなら非同期関数は常にあるタスクの文脈において動作するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you change a reference to an object in one array, only that array has a reference to the new object.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがある配列におけるあるオブジェクトへの参照を変更するならば、単にその配列が新しいオブジェクトへの参照を持つだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you compare two instances of that type, whether or not the computed value has been cached shouldn't affect their equality, so the cached value should be excluded from comparison and hashing.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがその型の２つのインスタンスを比較するならば、計算値がキャッシュされるかどうかが、それらの同等性に影響すべきではありません、なのでキャッシュされた値は比較およびハッシュ化から排除されるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you create a custom sequence that can provide repeated access to its elements, make sure that its type conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<ept i="0">&lt;/c0&gt;</ept> protocol in order to give a more useful and more efficient interface for sequence and collection operations.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがそれの要素に繰り返しアクセスを提供できるあつらえのシーケンスを作成しているならば、より実用的でより効率的なインターフェイスをシーケンスおよびコレクション演算に与えるために、それの型が<bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠するのを確実にしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you don't need to know <bpt i="0" x="0">&lt;e0&gt;</bpt>how<ept i="0">&lt;/e0&gt;</ept> a property has changed, omit the <bpt i="1" x="1">&lt;c1&gt;</bpt>options<ept i="1">&lt;/c1&gt;</ept> parameter.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが<bpt i="0" x="0">&lt;e0&gt;</bpt>どのように<ept i="0">&lt;/e0&gt;</ept>プロパティが変更されたか知る必要がないならば、<bpt i="1" x="1">&lt;c1&gt;</bpt>options<ept i="1">&lt;/c1&gt;</ept>パラメータを省略します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you don't need to respond to events, you don't need to create a delegate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがイベントに応答することを必要としないならば、あなたは委任先を作成する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you don’t want the default behavior or don’t want to construct a <bpt i="11" x="11">&lt;c11&gt;</bpt>String<ept i="11">&lt;/c11&gt;</ept>, use a custom type conforming to <bpt i="12" x="12">&lt;c12&gt;</bpt>String<bpt i="13" x="13">&lt;w13&gt;</bpt>Interpolation<bpt i="14" x="14">&lt;w14&gt;</bpt>Protocol<ept i="14">&lt;/w14&gt;</ept><ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> instead.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが初期状態の挙動を望まないまたは<bpt i="11" x="11">&lt;c11&gt;</bpt>String<ept i="11">&lt;/c11&gt;</ept>を組み立てることを望まないならば、代わりに<bpt i="12" x="12">&lt;c12&gt;</bpt>String<bpt i="13" x="13">&lt;w13&gt;</bpt>Interpolation<bpt i="14" x="14">&lt;w14&gt;</bpt>Protocol<ept i="14">&lt;/w14&gt;</ept><ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>に準拠するあるあつらえの型を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you have prior knowledge that an <bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Object<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance has a particular type, you can use the unconditional downcast operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>as!<ept i="2">&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Object<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスがある特定の型を持つという事前の知識を持つならば、無条件のダウンキャスト演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>as!<ept i="2">&lt;/c2&gt;</ept>）を使うことも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you implement <bpt i="6" x="6">&lt;c6&gt;</bpt>Custom<bpt i="7" x="7">&lt;w7&gt;</bpt>Debug<bpt i="8" x="8">&lt;w8&gt;</bpt>String<bpt i="9" x="9">&lt;w9&gt;</bpt>Convertible<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> conformance for your custom type, you may want to consider providing a custom mirror by implementing <bpt i="10" x="10">&lt;c10&gt;</bpt>Custom<bpt i="11" x="11">&lt;w11&gt;</bpt>Reflectable<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> conformance, as well.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが<bpt i="6" x="6">&lt;c6&gt;</bpt>Custom<bpt i="7" x="7">&lt;w7&gt;</bpt>Debug<bpt i="8" x="8">&lt;w8&gt;</bpt>String<bpt i="9" x="9">&lt;w9&gt;</bpt>Convertible<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>準拠をあなたのあつらえの型に実装するならば、さらにまたあなたはあつらえのミラーを<bpt i="10" x="10">&lt;c10&gt;</bpt>Custom<bpt i="11" x="11">&lt;w11&gt;</bpt>Reflectable<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>準拠によって提供することを考慮したいかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you implement a custom data structure backed by an array that grows dynamically, naively calling the <bpt i="0" x="0">&lt;c0&gt;</bpt>reserve<bpt i="1" x="1">&lt;w1&gt;</bpt>Capacity(_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method can lead to worse than expected performance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが動的に増大する配列によって裏打ちされる誂えのデータ構造を実装するならば、無邪気に<bpt i="0" x="0">&lt;c0&gt;</bpt>reserve<bpt i="1" x="1">&lt;w1&gt;</bpt>Capacity(_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを呼び出すと予想される性能よりずっと悪くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you know approximately how many elements you will need to store, use the <bpt i="0" x="0">&lt;c0&gt;</bpt>reserve<bpt i="1" x="1">&lt;w1&gt;</bpt>Capacity(_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method before appending to the array to avoid intermediate reallocations.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>どのくらい多くの要素をあなたが格納する必要があるかをあなたがおおよそ知っているならば、配列に追加する前に<bpt i="0" x="0">&lt;c0&gt;</bpt>reserve<bpt i="1" x="1">&lt;w1&gt;</bpt>Capacity(_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使って中間的な再割り当てを回避するようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you mutate the collection while iterating over its indices, a strong reference can cause an unexpected copy of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがコレクションをそれのインデックス全体に反復している間に変化させるならば、ある強い参照はそのコレクションの予期されない複製の原因となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you mutate the collection while iterating over its indices, a strong reference can result in an unexpected copy of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがコレクションをそれのインデックス全体に反復している間に変化させるならば、ある強い参照はそのコレクションの予期しない複製という結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you need a reversed collection of the same type, you may be able to use the collection’s sequence-based or collection-based initializer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが同じ型での逆にされたコレクションを必要とするならば、あなたはコレクションのもつシーケンス基盤のまたはコレクション基盤のイニシャライザを使うことができるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you need an array that is preinitialized with a fixed number of default values, use the <bpt i="0" x="0">&lt;c0&gt;</bpt>Array(repeating:<bpt i="1" x="1">&lt;w1&gt;</bpt>count:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initializer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがある固定された数の省略時の値であらかじめ初期化される配列を必要とするならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>Array(repeating:<bpt i="1" x="1">&lt;w1&gt;</bpt>count:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>イニシャライザを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you need an ordered collection of key-value pairs and don’t need the fast key lookup that <bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept> provides, see the <bpt i="1" x="1">&lt;c1&gt;</bpt>Key<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<bpt i="3" x="3">&lt;w3&gt;</bpt>Pairs<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> type for an alternative.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが順番付けられたキー値ペアのコレクションを必要とするそして<bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept>が提供する高速な検索を必要としないならば、代わりのものとして<bpt i="1" x="1">&lt;c1&gt;</bpt>Key<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<bpt i="3" x="3">&lt;w3&gt;</bpt>Pairs<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>型を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you need more control or only a few results, you can use a pattern like the following:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが更なる制御または少しの結果を必要とするならば、あなたは以下のような手本を使用できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you need more control over the capacity of your array, implement your own geometric growth strategy, passing the size you compute to <bpt i="0" x="0">&lt;c0&gt;</bpt>reserve<bpt i="1" x="1">&lt;w1&gt;</bpt>Capacity(_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがあなたの配列の容量に関してより制御を必要とするならば、あなた独自の幾何数級的戦略を実装して、あなたが算出する大きさを<bpt i="0" x="0">&lt;c0&gt;</bpt>reserve<bpt i="1" x="1">&lt;w1&gt;</bpt>Capacity(_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you need the reference semantics that come with the Foundation reference type, you can access it with its original <bpt i="0" x="0">&lt;c0&gt;</bpt>NS<ept i="0">&lt;/c0&gt;</ept> class name prefix.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがFoundation参照型に付属する参照意味論を必要とするならば、あなたはそれに、それの元の<bpt i="0" x="0">&lt;c0&gt;</bpt>NS<ept i="0">&lt;/c0&gt;</ept>クラス名接頭辞でアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you need to customize this behavior, override the <bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>is<bpt i="5" x="5">&lt;w5&gt;</bpt>Equal(_:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept> method and <bpt i="6" x="6">&lt;a6&gt;</bpt><bpt i="7" x="7">&lt;c7&gt;</bpt>hash<ept i="7">&lt;/c7&gt;</ept><ept i="6">&lt;/a6&gt;</ept> property instead of the <bpt i="8" x="8">&lt;c8&gt;</bpt>==<ept i="8">&lt;/c8&gt;</ept> operator method and <bpt i="9" x="9">&lt;c9&gt;</bpt>hash<bpt i="10" x="10">&lt;w10&gt;</bpt>Value<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがこの挙動をカスタマイズする必要があるならば、<bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>is<bpt i="5" x="5">&lt;w5&gt;</bpt>Equal(_:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>メソッドと<bpt i="6" x="6">&lt;a6&gt;</bpt><bpt i="7" x="7">&lt;c7&gt;</bpt>hash<ept i="7">&lt;/c7&gt;</ept><ept i="6">&lt;/a6&gt;</ept>プロトコルをオーバーライドしてください、<bpt i="8" x="8">&lt;c8&gt;</bpt>==<ept i="8">&lt;/c8&gt;</ept>演算子メソッドと<bpt i="9" x="9">&lt;c9&gt;</bpt>hash<bpt i="10" x="10">&lt;w10&gt;</bpt>Value<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>プロパティではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you need to infer moves, call the <bpt i="0" x="0">&lt;c0&gt;</bpt>inferring<bpt i="1" x="1">&lt;w1&gt;</bpt>Moves()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method on the resulting difference.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが移動の推論を必要とするならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>inferring<bpt i="1" x="1">&lt;w1&gt;</bpt>Moves()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを結果の差異の上で呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you need to iterate over consecutive floating-point values, see the <bpt i="3" x="3">&lt;c3&gt;</bpt>stride(from:<bpt i="4" x="4">&lt;w4&gt;</bpt>through:<bpt i="5" x="5">&lt;w5&gt;</bpt>by:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが連続した不動小数点値にわたって反復適用していく必要があるならば、<bpt i="3" x="3">&lt;c3&gt;</bpt>stride(from:<bpt i="4" x="4">&lt;w4&gt;</bpt>through:<bpt i="5" x="5">&lt;w5&gt;</bpt>by:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>関数を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you need to mutate the argument through the pointer, use <bpt i="8" x="8">&lt;c8&gt;</bpt>with<bpt i="9" x="9">&lt;w9&gt;</bpt>Unsafe<bpt i="10" x="10">&lt;w10&gt;</bpt>Mutable<bpt i="11" x="11">&lt;w11&gt;</bpt>Pointer(to:<bpt i="12" x="12">&lt;w12&gt;</bpt>_:)<ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> instead.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがポインタを通して引数を変化させる必要があるならば、代わりに<bpt i="8" x="8">&lt;c8&gt;</bpt>with<bpt i="9" x="9">&lt;w9&gt;</bpt>Unsafe<bpt i="10" x="10">&lt;w10&gt;</bpt>Mutable<bpt i="11" x="11">&lt;w11&gt;</bpt>Pointer(to:<bpt i="12" x="12">&lt;w12&gt;</bpt>_:)<ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you need to pass an optional pointer as a <bpt i="0" x="0">&lt;c0&gt;</bpt>CVar<bpt i="1" x="1">&lt;w1&gt;</bpt>Arg<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> argument, use the <bpt i="2" x="2">&lt;c2&gt;</bpt>Int(bit<bpt i="3" x="3">&lt;w3&gt;</bpt>Pattern:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> initializer to interpret the optional pointer as an <bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept> value, which has the same C variadic calling conventions as a pointer on all supported platforms.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがオプショナル値を<bpt i="0" x="0">&lt;c0&gt;</bpt>CVar<bpt i="1" x="1">&lt;w1&gt;</bpt>Arg<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>引数として渡す必要があるならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>Int(bit<bpt i="3" x="3">&lt;w3&gt;</bpt>Pattern:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>イニシャライザを使って、オプショナルポインタを<bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept>値として解釈してください、それは全てのサポートされるプラットホーム上のポインタと同じC可変長引数呼出規約を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you need to pass those keys to a method that takes an array, however, use this initializer to convert that list from its type of <bpt i="1" x="1">&lt;c1&gt;</bpt>Lazy<bpt i="2" x="2">&lt;w2&gt;</bpt>Map<bpt i="3" x="3">&lt;w3&gt;</bpt>Collection&lt;Dictionary&lt;String, Int&gt;, Int&gt;<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> to a simple <bpt i="4" x="4">&lt;c4&gt;</bpt>[String]<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>しかしながら、あなたが配列を取るメソッドにそれらキーを渡す必要があるならば、このイニシャライザを使ってそのリストをそれの型の<bpt i="1" x="1">&lt;c1&gt;</bpt>Lazy<bpt i="2" x="2">&lt;w2&gt;</bpt>Map<bpt i="3" x="3">&lt;w3&gt;</bpt>Collection&lt;Dictionary&lt;String, Int&gt;, Int&gt;<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>から単純な<bpt i="4" x="4">&lt;c4&gt;</bpt>[String]<ept i="4">&lt;/c4&gt;</ept>へ変換してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you need to perform additional setup beyond initialization, you can assign the result of the invocation of a closure to the global constant:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが追加的な準備を初期化が済んだら実行する必要があるならば、あなたはあるクロージャの発動の結果をグローバル定数に割り当てることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you override one of these declarations, you must also override the other to maintain that guarantee.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがそれら宣言の一方をオーバーライドするならば、あなたはまた他方もオーバーライドしてその保証を維持してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you pass <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>, the operation preserves the buffer capacity that the collection has, otherwise the underlying buffer is released.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>を渡すならば、演算はそのコレクションが持つバッファ容量を保全します、そうでなければ基礎をなすバッファは解放されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you pass a value as <bpt i="0" x="0">&lt;c0&gt;</bpt>stride<ept i="0">&lt;/c0&gt;</ept> that moves away from <bpt i="1" x="1">&lt;c1&gt;</bpt>end<ept i="1">&lt;/c1&gt;</ept>, the sequence contains no values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがある値を<bpt i="0" x="0">&lt;c0&gt;</bpt>stride<ept i="0">&lt;/c0&gt;</ept>として渡してそれが<bpt i="1" x="1">&lt;c1&gt;</bpt>end<ept i="1">&lt;/c1&gt;</ept>から離れていくならば、シーケンスは全く値を含みません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you pass a zero-length range as the <bpt i="0" x="0">&lt;c0&gt;</bpt>subrange<ept i="0">&lt;/c0&gt;</ept> parameter, this method inserts the elements of <bpt i="1" x="1">&lt;c1&gt;</bpt>new<bpt i="2" x="2">&lt;w2&gt;</bpt>Elements<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> at <bpt i="3" x="3">&lt;c3&gt;</bpt>subrange<bpt i="4" x="4">&lt;w4&gt;</bpt>.start<bpt i="5" x="5">&lt;w5&gt;</bpt>Index<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがゼロ長範囲を<bpt i="0" x="0">&lt;c0&gt;</bpt>subrange<ept i="0">&lt;/c0&gt;</ept>パラメータとして渡すならば、このメソッドは<bpt i="1" x="1">&lt;c1&gt;</bpt>new<bpt i="2" x="2">&lt;w2&gt;</bpt>Elements<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の要素を<bpt i="3" x="3">&lt;c3&gt;</bpt>subrange<bpt i="4" x="4">&lt;w4&gt;</bpt>.start<bpt i="5" x="5">&lt;w5&gt;</bpt>Index<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>で挿入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you pass the array’s <bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property as the <bpt i="2" x="2">&lt;c2&gt;</bpt>index<ept i="2">&lt;/c2&gt;</ept> parameter, the new element is appended to the array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが配列の<bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティを<bpt i="2" x="2">&lt;c2&gt;</bpt>index<ept i="2">&lt;/c2&gt;</ept>パラメータとして渡すならば、新しい要素が配列に追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you pass the collection’s <bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property as the <bpt i="2" x="2">&lt;c2&gt;</bpt>index<ept i="2">&lt;/c2&gt;</ept> parameter, the new elements are appended to the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがコレクションの<bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティを<bpt i="2" x="2">&lt;c2&gt;</bpt>index<ept i="2">&lt;/c2&gt;</ept>パラメータとして渡すならば、いくらかの新しい要素がコレクションに追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you provide your own implementation, make sure to compute the value nondestructively.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがあなた独自の実装を提供するならば、値を非破壊的に計算することを確実にしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you return Core Foundation objects from your own C functions and Objective-C methods, you can annotate them with either the <bpt i="0" x="0">&lt;c0&gt;</bpt>CF<bpt i="1" x="1">&lt;w1&gt;</bpt>_RETURNS<bpt i="2" x="2">&lt;w2&gt;</bpt>_RETAINED<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt>CF<bpt i="4" x="4">&lt;w4&gt;</bpt>_RETURNS<bpt i="5" x="5">&lt;w5&gt;</bpt>_NOT<bpt i="6" x="6">&lt;w6&gt;</bpt>_RETAINED<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> macro to automatically insert memory management calls.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがCore Foundationオブジェクトをあなた独自のC関数およびObjective-Cメソッドから返すならば、あなたはそれらに<bpt i="0" x="0">&lt;c0&gt;</bpt>CF<bpt i="1" x="1">&lt;w1&gt;</bpt>_RETURNS<bpt i="2" x="2">&lt;w2&gt;</bpt>_RETAINED<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>または<bpt i="3" x="3">&lt;c3&gt;</bpt>CF<bpt i="4" x="4">&lt;w4&gt;</bpt>_RETURNS<bpt i="5" x="5">&lt;w5&gt;</bpt>_NOT<bpt i="6" x="6">&lt;w6&gt;</bpt>_RETAINED<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>マクロのどちらかで注釈をつけて、自動的にメモリ管理呼び出しを差し込むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you return any other type, a structured description is generated.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが何か他の型を返すならば、構造化された記述が生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you use <bpt i="0" x="0">&lt;c0&gt;</bpt>11<ept i="0">&lt;/c0&gt;</ept> as <bpt i="1" x="1">&lt;c1&gt;</bpt>rhs<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>x<ept i="2">&lt;/c2&gt;</ept> is overshifted such that all of its bits are set to zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>11<ept i="0">&lt;/c0&gt;</ept>を<bpt i="1" x="1">&lt;c1&gt;</bpt>rhs<ept i="1">&lt;/c1&gt;</ept>として使うならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>x<ept i="2">&lt;/c2&gt;</ept>は、それのビットのすべてがゼロに設定されるような、オーバーシフトをされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you use <bpt i="2" x="2">&lt;c2&gt;</bpt>2<ept i="2">&lt;/c2&gt;</ept> as the right-hand-side value in an operation on <bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>, the shift amount requires no masking.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが<bpt i="2" x="2">&lt;c2&gt;</bpt>2<ept i="2">&lt;/c2&gt;</ept>を右手側の値として<bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>に関する演算において使うならば、シフト量はマスクを必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you use <bpt i="2" x="2">&lt;c2&gt;</bpt>2<ept i="2">&lt;/c2&gt;</ept> as the right-hand-side value in an operation on <bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>, the value is shifted left by two bits.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが<bpt i="2" x="2">&lt;c2&gt;</bpt>2<ept i="2">&lt;/c2&gt;</ept>を<bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>上での演算の右手側の値として使うならば、値は2ビットだけ左にシフトされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you use <bpt i="2" x="2">&lt;c2&gt;</bpt>2<ept i="2">&lt;/c2&gt;</ept> as the right-hand-side value in an operation on <bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>, the value is shifted right by two bits.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが<bpt i="2" x="2">&lt;c2&gt;</bpt>2<ept i="2">&lt;/c2&gt;</ept>を<bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>上での演算の右手側の値として使うならば、値は2ビットだけ右にシフトされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you use an Objective-C API that needs to process your data, or you need to fit your data model into an existing class hierarchy defined in an Objective-C framework, you might need to use classes and class inheritance to model your data.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのデータを処理するのに必要であるObjective-C APIをあなたが使う、またはあなたのデータモデルをObjective-Cフレームワークにおいて定義される既存のクラス階層へと適合させる必要があるならば、あなたはクラスとクラス階層を使ってあなたのデータをモデル化する必要があるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you want a conforming type to differentiate between literal and interpolated segments, restrict the types that can be interpolated, support different interpolators from the ones on <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>, or avoid constructing a <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> containing the data, the type must specify a custom <bpt i="2" x="2">&lt;c2&gt;</bpt>String<bpt i="3" x="3">&lt;w3&gt;</bpt>Interpolation<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> associated type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがある準拠している型にリテラルと補間分節の間の区別がついて欲しいならば、補間されることが可能な型を制約して、<bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>でのものと異なる補間をサポートしてください、またはデータを含んでいる<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>を組み立てることを防止してください、その型はあるあつらえの<bpt i="2" x="2">&lt;c2&gt;</bpt>String<bpt i="3" x="3">&lt;w3&gt;</bpt>Interpolation<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>関連型を指定しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you want to mutate a value by writing through a pointer, use <bpt i="10" x="10">&lt;c10&gt;</bpt>with<bpt i="11" x="11">&lt;w11&gt;</bpt>Unsafe<bpt i="12" x="12">&lt;w12&gt;</bpt>Mutable<bpt i="13" x="13">&lt;w13&gt;</bpt>Bytes(of:<bpt i="14" x="14">&lt;w14&gt;</bpt>_:)<ept i="14">&lt;/w14&gt;</ept><ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> instead.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがある値をポインタを通して書き込むことで変化させたいならば、<bpt i="10" x="10">&lt;c10&gt;</bpt>with<bpt i="11" x="11">&lt;w11&gt;</bpt>Unsafe<bpt i="12" x="12">&lt;w12&gt;</bpt>Mutable<bpt i="13" x="13">&lt;w13&gt;</bpt>Bytes(of:<bpt i="14" x="14">&lt;w14&gt;</bpt>_:)<ept i="14">&lt;/w14&gt;</ept><ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>を代わりに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you want to opt out of overflow checking and wrap the result in case of any overflow, use the overflow addition operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;+<ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがオーバーフロー検査を取りやめて、あらゆるオーバーフローの場合に結果をラップしたいならば、オーバーフロー加算演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;+<ept i="0">&lt;/c0&gt;</ept>）を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you want to opt out of overflow checking and wrap the result in case of any overflow, use the overflow multiplication operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;*<ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがオーバーフロー検査を取りやめて、あらゆるオーバーフローの場合に結果をラップしたいならば、オーバーフロー乗算演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;*<ept i="0">&lt;/c0&gt;</ept>）を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you want to opt out of overflow checking and wrap the result in case of any overflow, use the overflow subtraction operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;-<ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがオーバーフロー検査を取りやめてあらゆるオーバーフローの場合に結果をラップしたいならば、オーバーフロー減算演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;-<ept i="0">&lt;/c0&gt;</ept>）を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you want to provide a custom description of your type to be logged in place of the default description, conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Custom<bpt i="1" x="1">&lt;w1&gt;</bpt>Playground<bpt i="2" x="2">&lt;w2&gt;</bpt>Display<bpt i="3" x="3">&lt;w3&gt;</bpt>Convertible<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたの型のあつらえの記述を提供して省略時の記述の代わりに記録されるようにしたいならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>Custom<bpt i="1" x="1">&lt;w1&gt;</bpt>Playground<bpt i="2" x="2">&lt;w2&gt;</bpt>Display<bpt i="3" x="3">&lt;w3&gt;</bpt>Convertible<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you're building an inheritance relationship from scratch, prefer protocol inheritance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが継承関係をゼロから構築するならば、プロトコル継承を選んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you're completely certain about the type of the object, you can use the forced downcast operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>as!<ept i="0">&lt;/c0&gt;</ept>) instead.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがオブジェクトの型について完全に確信しているならば、あなたは強制ダウンキャスト演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>as!<ept i="0">&lt;/c0&gt;</ept>）を代わりに使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you're new to Swift, read <bpt i="0" x="0">&lt;a0&gt;</bpt>The Swift Programming Language<ept i="0">&lt;/a0&gt;</ept> for a quick tour, a comprehensive language guide, and a full reference manual.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがSwiftに慣れていないならば、<bpt i="0" x="0">&lt;a0&gt;</bpt>Swiftプログラミング言語<ept i="0">&lt;/a0&gt;</ept>を素早い見学、包括的な言語案内、そして完全な参照手引書として読んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you're new to programming, check out <bpt i="1" x="1">&lt;a1&gt;</bpt>Swift Playgrounds<ept i="1">&lt;/a1&gt;</ept> on iPad.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがプログラミング初心者ならば、<bpt i="1" x="1">&lt;a1&gt;</bpt>Swift Playgrounds<ept i="1">&lt;/a1&gt;</ept>をiPadでチェックしましょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If your app target has an Objective-C bridging header, the generated header also includes interfaces marked with the <bpt i="2" x="2">&lt;c2&gt;</bpt>internal<ept i="2">&lt;/c2&gt;</ept> modifier.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのアプリターゲットがObjective-Cブリッジヘッダを含むならば、生成されたヘッダもまた<bpt i="2" x="2">&lt;c2&gt;</bpt>internal<ept i="2">&lt;/c2&gt;</ept>修飾子で印されたインターフェイスを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If your array’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> type is a class or <bpt i="1" x="1">&lt;c1&gt;</bpt>@objc<ept i="1">&lt;/c1&gt;</ept> protocol and you do not need to bridge the array to <bpt i="2" x="2">&lt;c2&gt;</bpt>NSArray<ept i="2">&lt;/c2&gt;</ept> or pass the array to Objective-C APIs, using <bpt i="3" x="3">&lt;c3&gt;</bpt>Contiguous<bpt i="4" x="4">&lt;w4&gt;</bpt>Array<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> may be more efficient and have more predictable performance than <bpt i="5" x="5">&lt;c5&gt;</bpt>Array<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたの配列の<bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>型がクラスまたは<bpt i="1" x="1">&lt;c1&gt;</bpt>@objc<ept i="1">&lt;/c1&gt;</ept>プロトコルで、あなたがその配列を<bpt i="2" x="2">&lt;c2&gt;</bpt>NSArray<ept i="2">&lt;/c2&gt;</ept>にブリッジしたりその配列をObjective-C APIに渡したりする必要がないならば、<bpt i="3" x="3">&lt;c3&gt;</bpt>Contiguous<bpt i="4" x="4">&lt;w4&gt;</bpt>Array<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>を使うことは<bpt i="5" x="5">&lt;c5&gt;</bpt>Array<ept i="5">&lt;/c5&gt;</ept>よりもより効率的でありそしてより予測どおりの性能を持つでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If your implementation returns an instance of one of the types above, that type’s specialized description is used.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたの実装が上の型の１つのインスタンスを返すならば、その型のもつ特殊化された記述が使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If your sequence might have duplicate keys, use the <bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>uniquing<bpt i="2" x="2">&lt;w2&gt;</bpt>Keys<bpt i="3" x="3">&lt;w3&gt;</bpt>With:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initializer instead.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのシーケンスが重複するキーを持つかもしれないならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>uniquing<bpt i="2" x="2">&lt;w2&gt;</bpt>Keys<bpt i="3" x="3">&lt;w3&gt;</bpt>With:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>イニシャライザを代わりに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If your type contains properties that don't affect whether two instances are considered equal, exclude those properties from comparison in the <bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept> method and from hashing in <bpt i="1" x="1">&lt;c1&gt;</bpt>hash(into:)<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つのインスタンスが等しいと考えられるかどうかに影響しないプロパティをあなたの型が含むならば、それらプロパティを<bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept>メソッドでの比較から、そして<bpt i="1" x="1">&lt;c1&gt;</bpt>hash(into:)<ept i="1">&lt;/c1&gt;</ept>でのハッシュ化から除外してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If your type has value semantics, the <bpt i="0" x="0">&lt;c0&gt;</bpt>playground<bpt i="1" x="1">&lt;w1&gt;</bpt>Description<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> should be unaffected by subsequent mutations, if possible.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたの型が値意味論を持つならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>playground<bpt i="1" x="1">&lt;w1&gt;</bpt>Description<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>はその後の変化によって影響を受けないべきです、できれば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If your type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>playground<bpt i="1" x="1">&lt;w1&gt;</bpt>Description<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> returns an instance which itself conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt>Custom<bpt i="3" x="3">&lt;w3&gt;</bpt>Playground<bpt i="4" x="4">&lt;w4&gt;</bpt>Display<bpt i="5" x="5">&lt;w5&gt;</bpt>Convertible<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, then that type’s <bpt i="6" x="6">&lt;c6&gt;</bpt>playground<bpt i="7" x="7">&lt;w7&gt;</bpt>Description<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> will be used, and so on.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたの型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>playground<bpt i="1" x="1">&lt;w1&gt;</bpt>Description<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>がそれ自体が<bpt i="2" x="2">&lt;c2&gt;</bpt>Custom<bpt i="3" x="3">&lt;w3&gt;</bpt>Playground<bpt i="4" x="4">&lt;w4&gt;</bpt>Display<bpt i="5" x="5">&lt;w5&gt;</bpt>Convertible<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に準拠するインスタンスを返すならば、そのときその型のもつ<bpt i="6" x="6">&lt;c6&gt;</bpt>playground<bpt i="7" x="7">&lt;w7&gt;</bpt>Description<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>が使われます、などなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you’re passing a generator that results in the same sequence of Boolean values each time you run your program, that sequence may change when your program is compiled using a different version of Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがあなたのプログラムを実行するたびごとに同じブール値からなるシーケンスという結果になる生成子を渡すならば、そのシーケンスは、あなたのプログラムが異なるSwiftバージョンを使ってコンパイルされる時に変わるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you’re passing a generator that results in the same sequence of elements each time you run your program, that sequence may change when your program is compiled using a different version of Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがあなたのプログラムを実行するたびごとに同じ要素からなるシーケンスという結果になる生成子を渡すならば、そのシーケンスは、あなたのプログラムが異なるSwiftバージョンを使ってコンパイルされる時に変わるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you’re passing a generator that results in the same sequence of floating-point values each time you run your program, that sequence may change when your program is compiled using a different version of Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがあなたのプログラムを実行するたびごとに同じ浮動小数点値からなるシーケンスという結果になる生成子を渡すならば、そのシーケンスは、あなたのプログラムが異なるSwiftバージョンを使ってコンパイルされる時に変わるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you’re passing a generator that results in the same sequence of integer values each time you run your program, that sequence may change when your program is compiled using a different version of Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがあなたのプログラムを実行するたびごとに同じ整数値からなるシーケンスという結果になる生成子を渡すならば、そのシーケンスは、あなたのプログラムが異なるSwiftバージョンを使ってコンパイルされる時に変わるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you’re passing a generator that results in the same shuffled order each time you run your program, that sequence may change when your program is compiled using a different version of Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがあなたのプログラムを実行するたびごとに同じシャッフルされた順番という結果になる生成子を渡すならば、そのシーケンスは、あなたのプログラムが異なるSwiftバージョンを使ってコンパイルされる時に変わるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you’re sure of the dynamic type of <bpt i="10" x="10">&lt;c10&gt;</bpt>obj<ept i="10">&lt;/c10&gt;</ept>, you can call <bpt i="11" x="11">&lt;c11&gt;</bpt>get<bpt i="12" x="12">&lt;w12&gt;</bpt>Integer<bpt i="13" x="13">&lt;w13&gt;</bpt>Value()<ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> directly.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが<bpt i="10" x="10">&lt;c10&gt;</bpt>obj<ept i="10">&lt;/c10&gt;</ept>の動的型に確信を持つならば、あなたは<bpt i="11" x="11">&lt;c11&gt;</bpt>get<bpt i="12" x="12">&lt;w12&gt;</bpt>Integer<bpt i="13" x="13">&lt;w13&gt;</bpt>Value()<ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>を直接に呼び出すこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you’re working directly with numeric values, use the addition operator (<bpt i="1" x="1">&lt;c1&gt;</bpt>+<ept i="1">&lt;/c1&gt;</ept>) instead of this method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが直接に数値を扱っているならば、加算演算子（<bpt i="1" x="1">&lt;c1&gt;</bpt>+<ept i="1">&lt;/c1&gt;</ept>）をこのメソッドの代わりに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Imagine you have a set of temperature data for which you need to report some general statistics: the total number of observations, the number of valid observations, and the average temperature.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが幾つかの一般統計：観測総数、有効観測数、そして平均温度を報告しなければならない一揃いの温度データを持つと想像してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Implement this method to conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを実装して、<bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Implementing <bpt i="0" x="0">&lt;c0&gt;</bpt>next()<ept i="0">&lt;/c0&gt;</ept> with a <bpt i="1" x="1">&lt;c1&gt;</bpt>with<bpt i="2" x="2">&lt;w2&gt;</bpt>Task<bpt i="3" x="3">&lt;w3&gt;</bpt>Cancellation<bpt i="4" x="4">&lt;w4&gt;</bpt>Handler(handler:<bpt i="5" x="5">&lt;w5&gt;</bpt>operation:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> invocation to immediately react to cancellation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>next()<ept i="0">&lt;/c0&gt;</ept>をある<bpt i="1" x="1">&lt;c1&gt;</bpt>with<bpt i="2" x="2">&lt;w2&gt;</bpt>Task<bpt i="3" x="3">&lt;w3&gt;</bpt>Cancellation<bpt i="4" x="4">&lt;w4&gt;</bpt>Handler(handler:<bpt i="5" x="5">&lt;w5&gt;</bpt>operation:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>発動をつかって実装して、直接に取り消しに反応を示す。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Import Code Within a Framework Target</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>フレームワークターゲット内部でコードをインポートする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Import Code Within an App Target</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>アプリターゲット内部でコードをインポートする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Import Swift code into Objective-C within the same framework:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>SwiftコードをObjective-Cへと同じフレームワーク内部でインポートする：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Import the Swift code from that framework target into any Objective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept> file within that target using this syntax and substituting the appropriate names:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのフレームワークターゲットからのSwiftコードを何らかのObjective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept>ファイルにそのターゲット内部で、この構文を使ってそして適切な名前で置き換えて、インポートしてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Import your Objective-C headers into an Objective-C bridging header file to expose the declarations to all your Swift files.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのObjective-CヘッダをObjective-Cブリッジヘッダファイルにインポートして、それら宣言をあなたのSwiftファイルすべてに露出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Important</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>重要</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Imported C and Objective-C APIs</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インポートされたCおよびObjective-C API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Importing Objective-C into Swift</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-CをSwiftにインポートする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Importing Swift into Objective-C</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>SwiftをObjective-Cにインポートする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In -O builds, has no effect.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>-Oビルドでは、影響はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In -O builds, no test is performed to ensure that <bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept> actually has the dynamic type <bpt i="4" x="4">&lt;c4&gt;</bpt>T<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>-Oビルドにおいて、全くテストは実行されず<bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>が実際に動的型<bpt i="4" x="4">&lt;c4&gt;</bpt>T<ept i="4">&lt;/c4&gt;</ept>を持つことを保証されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In -Ounchecked builds, the optimizer may assume that this function is never called.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>-Ouncheckedビルドでは、最適化はこの関数が決して呼ばれないと決めてかかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In <bpt i="0" x="0">&lt;c0&gt;</bpt>-O<ept i="0">&lt;/c0&gt;</ept> builds (the default for Xcode’s Release configuration), <bpt i="1" x="1">&lt;c1&gt;</bpt>condition<ept i="1">&lt;/c1&gt;</ept> is not evaluated, and there are no effects.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>-O<ept i="0">&lt;/c0&gt;</ept>ビルド（省略時のXcodeのRelease構成）では、<bpt i="1" x="1">&lt;c1&gt;</bpt>condition<ept i="1">&lt;/c1&gt;</ept>は評価されません、そして影響はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In <bpt i="0" x="0">&lt;c0&gt;</bpt>-O<ept i="0">&lt;/c0&gt;</ept> builds (the default for Xcode’s Release configuration), stops program execution.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>-O<ept i="0">&lt;/c0&gt;</ept>ビルド（XcodeのRelease構成の初期設定）では、プログラム実行を停止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In <bpt i="0" x="0">&lt;c0&gt;</bpt>-O<ept i="0">&lt;/c0&gt;</ept> builds (the default for Xcode’s Release configuration): If <bpt i="1" x="1">&lt;c1&gt;</bpt>condition<ept i="1">&lt;/c1&gt;</ept> evaluates to <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>, stop program execution.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>-O<ept i="0">&lt;/c0&gt;</ept>ビルド（省略時のXcodeのRelease構成）では：<bpt i="1" x="1">&lt;c1&gt;</bpt>condition<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>に評価されるならば、プログラム実行を止めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In <bpt i="0" x="0">&lt;c0&gt;</bpt>-Ounchecked<ept i="0">&lt;/c0&gt;</ept> builds, <bpt i="1" x="1">&lt;c1&gt;</bpt>condition<ept i="1">&lt;/c1&gt;</ept> is not evaluated, but the optimizer may assume that it <bpt i="2" x="2">&lt;e2&gt;</bpt>always<ept i="2">&lt;/e2&gt;</ept> evaluates to <bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>-Ounchecked<ept i="0">&lt;/c0&gt;</ept>ビルドにおいて、<bpt i="1" x="1">&lt;c1&gt;</bpt>condition<ept i="1">&lt;/c1&gt;</ept>は評価されません、しかし最適化は、それが<bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept>に<bpt i="2" x="2">&lt;e2&gt;</bpt>常に<ept i="2">&lt;/e2&gt;</ept>に評価されると決めてかかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In <bpt i="0" x="0">&lt;c0&gt;</bpt>-Ounchecked<ept i="0">&lt;/c0&gt;</ept> builds, the optimizer may assume that this function is never called.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>-Ounchecked<ept i="0">&lt;/c0&gt;</ept>ビルドでは、最適化はこの関数が決して呼ばれないと決めてかかります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In Build Settings, in Swift Compiler - General, make sure the Objective-C Bridging Header build setting has a path to the bridging header file.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Build Settingsでは、Swift Compiler - Generalにおいて、Objective-C Bridging Header ビルド設定がブリッジヘッダファイルに対するパスを持つことを確実にしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In Cocoa, methods that perform asynchronous operations take a completion handler as their last parameter, and the method calls that block after the operation finishes to return a result or an error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Cocoaでは、非同期演算を実行するメソッドは、それの最後のパラメータとしてある完了ハンドラを、そして演算が終了する後では遮断するメソッド呼び出しいくつかをとって、結果またはエラーを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In Cocoa, methods that produce errors take an <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>NSError<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> pointer parameter as their last parameter, which populates its argument with an <bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;c3&gt;</bpt>NSError<ept i="3">&lt;/c3&gt;</ept><ept i="2">&lt;/s2&gt;</ept> object if an error occurs.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Cocoaでは、エラーを生成するメソッドは<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>NSError<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>ポインタパラメータをそれらの最後のパラメータとして取ります、エラーが発生するならばその引数に<bpt i="2" x="2">&lt;s2&gt;</bpt><bpt i="3" x="3">&lt;c3&gt;</bpt>NSError<ept i="3">&lt;/c3&gt;</ept><ept i="2">&lt;/s2&gt;</ept>オブジェクトが入ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In Objective-C, exceptions are distinct from errors.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-Cにおいて、例外はエラーとは別個のものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In Objective-C, it's declared like this:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-Cでは、それはこのように宣言されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In Objective-C, the <bpt i="0" x="0">&lt;c0&gt;</bpt>id<ept i="0">&lt;/c0&gt;</ept> type represents objects that are instances of any Objective-C class.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-Cでは、<bpt i="0" x="0">&lt;c0&gt;</bpt>id<ept i="0">&lt;/c0&gt;</ept>型は、何らかのObjective-Cクラスのインスタンスであるオブジェクトを表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In Swift it‘s imported as two methods, an asychronous method that takes a closure and an asynchronous throwing method that returns a tuple:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftではそれは２つのメソッドとしてインポートされます、あるクロージャをとる非同期メソッドそしてあるタプルを返す非同期スローメソッド：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In Swift, calling a method that throws requires explicit error handling.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>スウィフトでは、スローするメソッドを呼び出すことは明確にエラー処理することを必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In Swift, it’s imported like this:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>スウィフトでは、それはこのようにインポートされます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In Swift, you can call C variadic functions, such as <bpt i="0" x="0">&lt;c0&gt;</bpt>vasprintf(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>_:<bpt i="2" x="2">&lt;w2&gt;</bpt>_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, using the Swift <bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>get<bpt i="5" x="5">&lt;w5&gt;</bpt>Va<bpt i="6" x="6">&lt;w6&gt;</bpt>List(_:)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept> or <bpt i="7" x="7">&lt;a7&gt;</bpt><bpt i="8" x="8">&lt;c8&gt;</bpt>with<bpt i="9" x="9">&lt;w9&gt;</bpt>Va<bpt i="10" x="10">&lt;w10&gt;</bpt>List(_:<bpt i="11" x="11">&lt;w11&gt;</bpt>_:)<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept><ept i="7">&lt;/a7&gt;</ept> functions.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftでは、あなたはC可変長引数関数、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>vasprintf(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>_:<bpt i="2" x="2">&lt;w2&gt;</bpt>_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>などを呼び出すことが、Swiftの<bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>get<bpt i="5" x="5">&lt;w5&gt;</bpt>Va<bpt i="6" x="6">&lt;w6&gt;</bpt>List(_:)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>または<bpt i="7" x="7">&lt;a7&gt;</bpt><bpt i="8" x="8">&lt;c8&gt;</bpt>with<bpt i="9" x="9">&lt;w9&gt;</bpt>Va<bpt i="10" x="10">&lt;w10&gt;</bpt>List(_:<bpt i="11" x="11">&lt;w11&gt;</bpt>_:)<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept><ept i="7">&lt;/a7&gt;</ept>関数を使って可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In Swift, you can recover from errors passed using Cocoa’s error pattern, as described above in <bpt i="0" x="0">&lt;a0&gt;</bpt>Catch Errors<ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftでは、あなたはCocoaのエラーパターンを使って渡されるエラーから復旧できます、上の<bpt i="0" x="0">&lt;a0&gt;</bpt>エラーをキャッチする<ept i="0">&lt;/a0&gt;</ept>で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In Swift, you can use each pair of toll-free bridged Foundation and Core Foundation types interchangeably.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>スウィフトにおいて、あなたは、トールフリーブリッジ（無料の橋渡し）されたFoundationとCore Foundation型の各対を入れ替えて使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In Swift, you can use functions and generics to achieve the same results without any compromises.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>スウィフトでは、あなたはどんな妥協もなしで同じ結果を成し遂げるために、関数と総称体を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In a <bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<bpt i="1" x="1">&lt;w1&gt;</bpt>Of<bpt i="2" x="2">&lt;w2&gt;</bpt>One<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance, <bpt i="3" x="3">&lt;c3&gt;</bpt>end<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is always <bpt i="5" x="5">&lt;c5&gt;</bpt>1<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<bpt i="1" x="1">&lt;w1&gt;</bpt>Of<bpt i="2" x="2">&lt;w2&gt;</bpt>One<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスにおいて、<bpt i="3" x="3">&lt;c3&gt;</bpt>end<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は常に<bpt i="5" x="5">&lt;c5&gt;</bpt>1<ept i="5">&lt;/c5&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In a <bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<bpt i="1" x="1">&lt;w1&gt;</bpt>Of<bpt i="2" x="2">&lt;w2&gt;</bpt>One<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance, <bpt i="3" x="3">&lt;c3&gt;</bpt>start<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is always <bpt i="5" x="5">&lt;c5&gt;</bpt>0<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある<bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<bpt i="1" x="1">&lt;w1&gt;</bpt>Of<bpt i="2" x="2">&lt;w2&gt;</bpt>One<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスにおいて、<bpt i="3" x="3">&lt;c3&gt;</bpt>start<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は常に<bpt i="5" x="5">&lt;c5&gt;</bpt>0<ept i="5">&lt;/c5&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In a case like this, where a generic parameter <bpt i="1" x="1">&lt;c1&gt;</bpt>T<ept i="1">&lt;/c1&gt;</ept> is bound to a protocol <bpt i="2" x="2">&lt;c2&gt;</bpt>P<ept i="2">&lt;/c2&gt;</ept>, the type parameter is not statically known to be a protocol type in the body of the generic function.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このような場合において、総称体パラメータ<bpt i="1" x="1">&lt;c1&gt;</bpt>T<ept i="1">&lt;/c1&gt;</ept>がプロトコル<bpt i="2" x="2">&lt;c2&gt;</bpt>P<ept i="2">&lt;/c2&gt;</ept>に束縛されるところでは、その型パラメータは、プロトコル型であることを総称体関数の本文において静的に知られません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In a collection, the subsequence should also conform to <bpt i="1" x="1">&lt;c1&gt;</bpt>Collection<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるコレクションにおいて、下位シーケンスはまた<bpt i="1" x="1">&lt;c1&gt;</bpt>Collection<ept i="1">&lt;/c1&gt;</ept>に準拠すべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In a mutable <bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept> instance, you can modify in place a value that you’ve accessed through a keyed subscript.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>可変の<bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept>インスタンスでは、あなたがキーによる添え字を通してアクセスしたある値をその場で修正できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In addition to creating a character from a single-character string literal, you can also convert a unicode scalar value or single-character string.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある文字を単一文字文字列リテラルから作成することに加えて、あなたはまた、あるユニコードスカラー値や単一文字文字列を変換できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In addition to representing specific numbers, floating-point types also have special values for working with overflow and nonnumeric results of calculation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>特定の数を表すことに加えて、浮動小数点型はまた、オーバーフローおよび非数の計算結果で使うための特別な値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In addition to simplifying your code, this automatic conformance reduces errors, because any new properties you add to your custom types are automatically included when hashing and testing for equality.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのコードを単純にすることに加えて、この自動式の準拠はエラーを減らします、なぜならあなたのあつらえの型にあなたが加える何らかの新しいプロパティは、ハッシュ化および同等性テストをする場合に自動的に含まれるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In addition to the operations that collections inherit from the <bpt i="1" x="1">&lt;c1&gt;</bpt>Sequence<ept i="1">&lt;/c1&gt;</ept> protocol, you gain access to methods that depend on accessing an element at a specific position in a collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションが<bpt i="1" x="1">&lt;c1&gt;</bpt>Sequence<ept i="1">&lt;/c1&gt;</ept>プロトコルから継承するメソッドに加えて、あなたは、コレクションの特定の位置で要素にアクセスすることを当てにするメソッドへの利用権を手に入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In addition to using a dictionary literal, you can also create a dictionary using these initializers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書リテラルを使うことに加えて、あなたはまた辞書をこれらのイニシャライザを使って作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In addition to using an array literal, you can also create an array using these initializers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列リテラルを使うことに加えて、あなたはまた配列をこれらのイニシャライザを使って作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In addition, because <bpt i="1" x="1">&lt;c1&gt;</bpt>abs(_:)<ept i="1">&lt;/c1&gt;</ept> always returns a value of the same type, even in a generic context, using the function instead of the <bpt i="2" x="2">&lt;c2&gt;</bpt>magnitude<ept i="2">&lt;/c2&gt;</ept> property is encouraged.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>加えて、<bpt i="1" x="1">&lt;c1&gt;</bpt>abs(_:)<ept i="1">&lt;/c1&gt;</ept>は常に同じ型の値を返すことから、総称体の文脈においてさえも、この関数を<bpt i="2" x="2">&lt;c2&gt;</bpt>magnitude<ept i="2">&lt;/c2&gt;</ept>プロパティの代わりに使うことは推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In addition, because <bpt i="3" x="3">&lt;c3&gt;</bpt>Integer<bpt i="4" x="4">&lt;w4&gt;</bpt>Ref<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> conforms to the <bpt i="5" x="5">&lt;c5&gt;</bpt>Equatable<ept i="5">&lt;/c5&gt;</ept> protocol, instances can also be compared using the equal-to operator (<bpt i="6" x="6">&lt;c6&gt;</bpt>==<ept i="6">&lt;/c6&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>加えて、<bpt i="3" x="3">&lt;c3&gt;</bpt>Integer<bpt i="4" x="4">&lt;w4&gt;</bpt>Ref<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は<bpt i="5" x="5">&lt;c5&gt;</bpt>Equatable<ept i="5">&lt;/c5&gt;</ept>プロトコルに準拠することから、インスタンスはまた同等性演算子（<bpt i="6" x="6">&lt;c6&gt;</bpt>==<ept i="6">&lt;/c6&gt;</ept>）を使って比較されることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In addition, bidirectional collections have more efficient implementations of some sequence and collection methods, such as <bpt i="4" x="4">&lt;c4&gt;</bpt>suffix(_:)<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>さらに加えて、二方向性のコレクションはいくらかのシーケンスおよびコレクションメソッドのもっと手際の良い実装を持ちます、例えば<bpt i="4" x="4">&lt;c4&gt;</bpt>suffix(_:)<ept i="4">&lt;/c4&gt;</ept>など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In addition, the following conditions must hold:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>加えて、以下の条件が保持されなければなりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In addition, the unqualified <bpt i="6" x="6">&lt;c6&gt;</bpt>list<bpt i="7" x="7">&lt;w7&gt;</bpt>Of<bpt i="8" x="8">&lt;w8&gt;</bpt>Objects<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> method uses the <bpt i="9" x="9">&lt;c9&gt;</bpt>NSCopying<ept i="9">&lt;/c9&gt;</ept> generic constraint inferred from the <bpt i="10" x="10">&lt;c10&gt;</bpt>List<ept i="10">&lt;/c10&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>加えて、不適格<bpt i="6" x="6">&lt;c6&gt;</bpt>list<bpt i="7" x="7">&lt;w7&gt;</bpt>Of<bpt i="8" x="8">&lt;w8&gt;</bpt>Objects<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>メソッドは、<bpt i="9" x="9">&lt;c9&gt;</bpt>NSCopying<ept i="9">&lt;/c9&gt;</ept>総称体制約を<bpt i="10" x="10">&lt;c10&gt;</bpt>List<ept i="10">&lt;/c10&gt;</ept>型から推論されて使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In addition, there are two other edge cases:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>加えて、２つの別の境界事例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In an app that consults a remote database, for example, an instance's identity may be fully owned by an external entity and communicated by an identifier.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、リモートデータベースに助言を求めるアプリでは、あるインスタンスの持つ同一性は、外部存在によって完全に所有され、そしてある識別子によって伝えられるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In an empty collection, <bpt i="0" x="0">&lt;c0&gt;</bpt>start<bpt i="1" x="1">&lt;w1&gt;</bpt>Index == end<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>空のコレクションでは、<bpt i="0" x="0">&lt;c0&gt;</bpt>start<bpt i="1" x="1">&lt;w1&gt;</bpt>Index == end<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In cases like this, the simplest fix is often to simply remove the call to <bpt i="0" x="0">&lt;c0&gt;</bpt>reserve<bpt i="1" x="1">&lt;w1&gt;</bpt>Capacity(_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, and let the <bpt i="2" x="2">&lt;c2&gt;</bpt>append(_:)<ept i="2">&lt;/c2&gt;</ept> method grow the array for you.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このような場合に、最も簡単な修正はしばしば単純に<bpt i="0" x="0">&lt;c0&gt;</bpt>reserve<bpt i="1" x="1">&lt;w1&gt;</bpt>Capacity(_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の呼出しを取り除いて、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>append(_:)<ept i="2">&lt;/c2&gt;</ept>メソッドがあなたの代わりの配列を成長させるようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In contrast, this example throws <bpt i="0" x="0">&lt;c0&gt;</bpt>Some<bpt i="1" x="1">&lt;w1&gt;</bpt>Error<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and cancels all of the tasks in the group:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>対照的に、この例は<bpt i="0" x="0">&lt;c0&gt;</bpt>Some<bpt i="1" x="1">&lt;w1&gt;</bpt>Error<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をスローします、そしてそのグループの中の全てのタスクを取り消します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In debug builds, an instance in the left-hand side of a <bpt i="4" x="4">&lt;c4&gt;</bpt>&amp;&amp;<ept i="4">&lt;/c4&gt;</ept> or <bpt i="5" x="5">&lt;c5&gt;</bpt>||<ept i="5">&lt;/c5&gt;</ept> expression may still be referenced when evaluating the right-hand side, inflating the instance’s reference count.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>デバッグビルドにおいて、<bpt i="4" x="4">&lt;c4&gt;</bpt>&amp;&amp;<ept i="4">&lt;/c4&gt;</ept>または<bpt i="5" x="5">&lt;c5&gt;</bpt>||<ept i="5">&lt;/c5&gt;</ept>式の左手側でのインスタンスは、右手側を評価している時に依然として参照されるかもしれません、インスタンスのもつ参照カウントを上昇させながら。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In fact, <bpt i="0" x="0">&lt;c0&gt;</bpt>s<bpt i="1" x="1">&lt;w1&gt;</bpt>.flat<bpt i="2" x="2">&lt;w2&gt;</bpt>Map(transform)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equivalent to <bpt i="3" x="3">&lt;c3&gt;</bpt>Array(s<bpt i="4" x="4">&lt;w4&gt;</bpt>.map(transform).joined())<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>実際のところ、<bpt i="0" x="0">&lt;c0&gt;</bpt>s<bpt i="1" x="1">&lt;w1&gt;</bpt>.flat<bpt i="2" x="2">&lt;w2&gt;</bpt>Map(transform)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>Array(s<bpt i="4" x="4">&lt;w4&gt;</bpt>.map(transform).joined())<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In most cases, you should use the equal-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept>) to test whether two instances are equal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ほとんどの場合、あなたは同等演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept>）を使って２つのインスタンスが等しいかどうかをテストするべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In most cases, you won't need to modify this setting.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ほとんどの場合では、あなたはこの設定を修正する必要はないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other languages, similar data types are known as hashes or associated arrays.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>他の言語では、同じようなデータ型はハッシュまたは連想配列として知られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other words, for ordinary sequences <bpt i="1" x="1">&lt;c1&gt;</bpt>s<ept i="1">&lt;/c1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>言い換えれば、よくあるシーケンス <bpt i="1" x="1">&lt;c1&gt;</bpt>s<ept i="1">&lt;/c1&gt;</ept>に対して：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In particular, <bpt i="4" x="4">&lt;c4&gt;</bpt>x<bpt i="5" x="5">&lt;w5&gt;</bpt>.sign == .minus<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> if <bpt i="6" x="6">&lt;c6&gt;</bpt>x<ept i="6">&lt;/c6&gt;</ept> is -0, and while <bpt i="7" x="7">&lt;c7&gt;</bpt>x &lt; 0<ept i="7">&lt;/c7&gt;</ept> is always <bpt i="8" x="8">&lt;c8&gt;</bpt>false<ept i="8">&lt;/c8&gt;</ept> if <bpt i="9" x="9">&lt;c9&gt;</bpt>x<ept i="9">&lt;/c9&gt;</ept> is NaN, <bpt i="10" x="10">&lt;c10&gt;</bpt>x<bpt i="11" x="11">&lt;w11&gt;</bpt>.sign<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> could be either <bpt i="12" x="12">&lt;c12&gt;</bpt>.plus<ept i="12">&lt;/c12&gt;</ept> or <bpt i="13" x="13">&lt;c13&gt;</bpt>.minus<ept i="13">&lt;/c13&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>とりわけ、<bpt i="6" x="6">&lt;c6&gt;</bpt>x<ept i="6">&lt;/c6&gt;</ept>が-0ならば<bpt i="4" x="4">&lt;c4&gt;</bpt>x<bpt i="5" x="5">&lt;w5&gt;</bpt>.sign == .minus<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>、一方で<bpt i="9" x="9">&lt;c9&gt;</bpt>x<ept i="9">&lt;/c9&gt;</ept>がNaNならば、<bpt i="10" x="10">&lt;c10&gt;</bpt>x<bpt i="11" x="11">&lt;w11&gt;</bpt>.sign<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>が<bpt i="12" x="12">&lt;c12&gt;</bpt>.plus<ept i="12">&lt;/c12&gt;</ept>または<bpt i="13" x="13">&lt;c13&gt;</bpt>.minus<ept i="13">&lt;/c13&gt;</ept>のどちらでも、<bpt i="7" x="7">&lt;c7&gt;</bpt>x &lt; 0<ept i="7">&lt;/c7&gt;</ept>は常に<bpt i="8" x="8">&lt;c8&gt;</bpt>false<ept i="8">&lt;/c8&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In particular, negating a signed, fixed-width integer type’s minimum results in a value that cannot be represented.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>とりわけ、符号付きの、固定長整数型のもつ最小値を負にすることは、表現できない値という結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In particular, note that <bpt i="0" x="0">&lt;c0&gt;</bpt>j<ept i="0">&lt;/c0&gt;</ept>, the index of the second day with absences, was found in a slice of the original array and then used to access a value in the original <bpt i="1" x="1">&lt;c1&gt;</bpt>absences<ept i="1">&lt;/c1&gt;</ept> array itself.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>特に、欠席者のいる第２の日付のインデックス、<bpt i="0" x="0">&lt;c0&gt;</bpt>j<ept i="0">&lt;/c0&gt;</ept>が、オリジナル配列のひとつのスライス上で捜されて、それから値のアクセスのためにオリジナルの<bpt i="1" x="1">&lt;c1&gt;</bpt>absences<ept i="1">&lt;/c1&gt;</ept>配列自身において使われる点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In particular, passing NaN as <bpt i="3" x="3">&lt;c3&gt;</bpt>other<ept i="3">&lt;/c3&gt;</ept> always results in <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>とりわけ、NaNを<bpt i="3" x="3">&lt;c3&gt;</bpt>other<ept i="3">&lt;/c3&gt;</ept>として渡すことは常に<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>の結果となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In particular, that slice, unlike an array, may have a nonzero <bpt i="2" x="2">&lt;c2&gt;</bpt>start<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and an <bpt i="4" x="4">&lt;c4&gt;</bpt>end<bpt i="5" x="5">&lt;w5&gt;</bpt>Index<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> that is not equal to <bpt i="6" x="6">&lt;c6&gt;</bpt>count<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>特に、そのスライスは、配列と違い、非ゼロの<bpt i="2" x="2">&lt;c2&gt;</bpt>start<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>と<bpt i="6" x="6">&lt;c6&gt;</bpt>count<ept i="6">&lt;/c6&gt;</ept>に等しくない<bpt i="4" x="4">&lt;c4&gt;</bpt>end<bpt i="5" x="5">&lt;w5&gt;</bpt>Index<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を持つかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In particular, the absolute value of a signed, fixed-width integer type’s minimum cannot be represented.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>とりわけ、符号付きの、固定長整数型のもつ極小は、表現されることは可能ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In particular, this discussion mentions <bpt i="1" x="1">&lt;a1&gt;</bpt>extended grapheme clusters<ept i="1">&lt;/a1&gt;</ept> and <bpt i="2" x="2">&lt;a2&gt;</bpt>Unicode scalar values<ept i="2">&lt;/a2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>とりわけ、この解説は<bpt i="1" x="1">&lt;a1&gt;</bpt>拡張書記素クラスタ<ept i="1">&lt;/a1&gt;</ept>と<bpt i="2" x="2">&lt;a2&gt;</bpt>ユニコードスカラー値<ept i="2">&lt;/a2&gt;</ept>について言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In playgrounds and -Onone builds (the default for Xcode’s Debug configuration), stop program execution in a debuggable state after printing <bpt i="0" x="0">&lt;c0&gt;</bpt>message<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>プレイグラウンドおよび-Ononeビルド（省略時のXcodeのDebug構成）では、<bpt i="0" x="0">&lt;c0&gt;</bpt>message<ept i="0">&lt;/c0&gt;</ept>を出力した後にデバッグ可能状態でプログラム実行を停止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In playgrounds and <bpt i="0" x="0">&lt;c0&gt;</bpt>-Onone<ept i="0">&lt;/c0&gt;</ept> builds (the default for Xcode’s Debug configuration), stops program execution in a debuggable state after printing <bpt i="1" x="1">&lt;c1&gt;</bpt>message<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>プレイグラウンドおよび<bpt i="0" x="0">&lt;c0&gt;</bpt>-Onone<ept i="0">&lt;/c0&gt;</ept>ビルド（XcodeのDebug構成の初期設定）では、<bpt i="1" x="1">&lt;c1&gt;</bpt>message<ept i="1">&lt;/c1&gt;</ept>を出力した後デバッグ可能な状態でプログラム実行を停止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In playgrounds and <bpt i="0" x="0">&lt;c0&gt;</bpt>-Onone<ept i="0">&lt;/c0&gt;</ept> builds (the default for Xcode’s Debug configuration): If <bpt i="1" x="1">&lt;c1&gt;</bpt>condition<ept i="1">&lt;/c1&gt;</ept> evaluates to <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>, stop program execution in a debuggable state after printing <bpt i="3" x="3">&lt;c3&gt;</bpt>message<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>プレイグラウンドおよび<bpt i="0" x="0">&lt;c0&gt;</bpt>-Onone<ept i="0">&lt;/c0&gt;</ept>ビルド（省略時のXcodeのDebug構成）において：<bpt i="1" x="1">&lt;c1&gt;</bpt>condition<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>に評価されるならば、<bpt i="3" x="3">&lt;c3&gt;</bpt>message<ept i="3">&lt;/c3&gt;</ept>を出力した後にデバッグ可能状態でプログラム実行を停止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In short, the iterator is what produces the asynchronous sequence’s values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要約すれば、そのイテレータは、非同期シーケンスのもつ値それらを取り出すものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In some uses, such as in a <bpt i="4" x="4">&lt;c4&gt;</bpt>class<ept i="4">&lt;/c4&gt;</ept> initializer, you may find that the language rules do not allow you to use <bpt i="5" x="5">&lt;c5&gt;</bpt>with<bpt i="6" x="6">&lt;w6&gt;</bpt>Va<bpt i="7" x="7">&lt;w7&gt;</bpt>List(_:<bpt i="8" x="8">&lt;w8&gt;</bpt>_:)<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> as intended.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>いくらの利用では、例えば<bpt i="4" x="4">&lt;c4&gt;</bpt>class<ept i="4">&lt;/c4&gt;</ept>でのように、あなたは言語規則があなたに<bpt i="5" x="5">&lt;c5&gt;</bpt>with<bpt i="6" x="6">&lt;w6&gt;</bpt>Va<bpt i="7" x="7">&lt;w7&gt;</bpt>List(_:<bpt i="8" x="8">&lt;w8&gt;</bpt>_:)<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>を意図したように利用させないのを発見するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In that case, the default value and key are not written back to the dictionary after an operation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その場合には、省略時の値とキーは、演算の後に辞書へと書き戻されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In that case, the method returns <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その場合には、このメソッドは<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the <bpt i="0" x="0">&lt;c0&gt;</bpt>Zip2Sequence<ept i="0">&lt;/c0&gt;</ept> instance returned by this function, the elements of the <bpt i="1" x="1">&lt;e1&gt;</bpt>i<ept i="1">&lt;/e1&gt;</ept>th pair are the <bpt i="2" x="2">&lt;e2&gt;</bpt>i<ept i="2">&lt;/e2&gt;</ept>th elements of each underlying sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この関数によって返される<bpt i="0" x="0">&lt;c0&gt;</bpt>Zip2Sequence<ept i="0">&lt;/c0&gt;</ept>インスタンスにおいて、<bpt i="1" x="1">&lt;e1&gt;</bpt>i<ept i="1">&lt;/e1&gt;</ept>番目の対の要素らは、基盤となる各シーケンスの<bpt i="2" x="2">&lt;e2&gt;</bpt>i<ept i="2">&lt;/e2&gt;</ept>番目の要素らです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the <bpt i="3" x="3">&lt;c3&gt;</bpt>hash(into:)<ept i="3">&lt;/c3&gt;</ept> method, call the <bpt i="4" x="4">&lt;c4&gt;</bpt>combine(_:)<ept i="4">&lt;/c4&gt;</ept> method on the provided hasher with each significant property:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>hash(into:)<ept i="3">&lt;/c3&gt;</ept>メソッドにおいて、<bpt i="4" x="4">&lt;c4&gt;</bpt>combine(_:)<ept i="4">&lt;/c4&gt;</ept>メソッドをその提供されたhasher上で各重要プロパティとともに呼び出してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the example above, <bpt i="0" x="0">&lt;c0&gt;</bpt>more<bpt i="1" x="1">&lt;w1&gt;</bpt>Numbers<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> has the same type as <bpt i="2" x="2">&lt;c2&gt;</bpt>numbers<ept i="2">&lt;/c2&gt;</ept>, which is <bpt i="3" x="3">&lt;c3&gt;</bpt>[Int]<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>上の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>more<bpt i="1" x="1">&lt;w1&gt;</bpt>Numbers<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>numbers<ept i="2">&lt;/c2&gt;</ept>と同じ型を持ちます、それは<bpt i="3" x="3">&lt;c3&gt;</bpt>[Int]<ept i="3">&lt;/c3&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the example above, <bpt i="3" x="3">&lt;c3&gt;</bpt>first<bpt i="4" x="4">&lt;w4&gt;</bpt>Space<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is used to extract the prefix that contains elements up to that index.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>上の例において、<bpt i="3" x="3">&lt;c3&gt;</bpt>first<bpt i="4" x="4">&lt;w4&gt;</bpt>Space<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は、そのインデックスまでの要素を含んでいる前の部分を抜き取るために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the example below, <bpt i="0" x="0">&lt;c0&gt;</bpt>json<bpt i="1" x="1">&lt;w1&gt;</bpt>Response<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> contains an encoded <bpt i="2" x="2">&lt;c2&gt;</bpt>Pen<bpt i="3" x="3">&lt;w3&gt;</bpt>Pal<bpt i="4" x="4">&lt;w4&gt;</bpt>Record<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance from a server:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>json<bpt i="1" x="1">&lt;w1&gt;</bpt>Response<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、あるサーバからのエンコード済み<bpt i="2" x="2">&lt;c2&gt;</bpt>Pen<bpt i="3" x="3">&lt;w3&gt;</bpt>Pal<bpt i="4" x="4">&lt;w4&gt;</bpt>Record<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the example below, a <bpt i="0" x="0">&lt;c0&gt;</bpt>numbers<ept i="0">&lt;/c0&gt;</ept> array is created along with two copies that share the same storage.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>numbers<ept i="0">&lt;/c0&gt;</ept>配列は２つのコピーと連れだって作成されます、それは同じストレージを共有します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the example below, changing the value of the <bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Alive<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> computed property on an instance of the <bpt i="2" x="2">&lt;c2&gt;</bpt>Schroedingers<bpt i="3" x="3">&lt;w3&gt;</bpt>Cat<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> structure also changes the value of the instance’s <bpt i="4" x="4">&lt;c4&gt;</bpt>is<bpt i="5" x="5">&lt;w5&gt;</bpt>Dead<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> computed property:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Alive<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>計算プロパティの値を<bpt i="2" x="2">&lt;c2&gt;</bpt>Schroedingers<bpt i="3" x="3">&lt;w3&gt;</bpt>Cat<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>構造体のインスタンス上で変更することは、またそのインスタンスの<bpt i="4" x="4">&lt;c4&gt;</bpt>is<bpt i="5" x="5">&lt;w5&gt;</bpt>Dead<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>計算プロパティの値も変更します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the example below, the <bpt i="0" x="0">&lt;c0&gt;</bpt>\.object<bpt i="1" x="1">&lt;w1&gt;</bpt>To<bpt i="2" x="2">&lt;w2&gt;</bpt>Observe<bpt i="3" x="3">&lt;w3&gt;</bpt>.my<bpt i="4" x="4">&lt;w4&gt;</bpt>Date<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> key path refers to the <bpt i="5" x="5">&lt;c5&gt;</bpt>my<bpt i="6" x="6">&lt;w6&gt;</bpt>Date<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> property of <bpt i="7" x="7">&lt;c7&gt;</bpt>My<bpt i="8" x="8">&lt;w8&gt;</bpt>Object<bpt i="9" x="9">&lt;w9&gt;</bpt>To<bpt i="10" x="10">&lt;w10&gt;</bpt>Observe<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>\.object<bpt i="1" x="1">&lt;w1&gt;</bpt>To<bpt i="2" x="2">&lt;w2&gt;</bpt>Observe<bpt i="3" x="3">&lt;w3&gt;</bpt>.my<bpt i="4" x="4">&lt;w4&gt;</bpt>Date<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>キーパスは、<bpt i="7" x="7">&lt;c7&gt;</bpt>My<bpt i="8" x="8">&lt;w8&gt;</bpt>Object<bpt i="9" x="9">&lt;w9&gt;</bpt>To<bpt i="10" x="10">&lt;w10&gt;</bpt>Observe<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>の<bpt i="5" x="5">&lt;c5&gt;</bpt>my<bpt i="6" x="6">&lt;w6&gt;</bpt>Date<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>プロパティを参照します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the example, <bpt i="0" x="0">&lt;c0&gt;</bpt>obj<ept i="0">&lt;/c0&gt;</ept> has a static type of <bpt i="1" x="1">&lt;c1&gt;</bpt>Any<bpt i="2" x="2">&lt;w2&gt;</bpt>Object<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> and a dynamic type of <bpt i="3" x="3">&lt;c3&gt;</bpt>Integer<bpt i="4" x="4">&lt;w4&gt;</bpt>Ref<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>obj<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>Any<bpt i="2" x="2">&lt;w2&gt;</bpt>Object<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の静的型と<bpt i="3" x="3">&lt;c3&gt;</bpt>Integer<bpt i="4" x="4">&lt;w4&gt;</bpt>Ref<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>の動的型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following code, the <bpt i="0" x="0">&lt;c0&gt;</bpt>count<ept i="0">&lt;/c0&gt;</ept> variable has the same static and dynamic type: <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下のコードにおいて、<bpt i="0" x="0">&lt;c0&gt;</bpt>count<ept i="0">&lt;/c0&gt;</ept>変数は同じ静的および動的型：<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, <bpt i="1" x="1">&lt;c1&gt;</bpt>key<bpt i="2" x="2">&lt;w2&gt;</bpt>Path1<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>key<bpt i="4" x="4">&lt;w4&gt;</bpt>Path2<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> are equivalent:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例において、<bpt i="1" x="1">&lt;c1&gt;</bpt>key<bpt i="2" x="2">&lt;w2&gt;</bpt>Path1<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>key<bpt i="4" x="4">&lt;w4&gt;</bpt>Path2<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は同等です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, <bpt i="4" x="4">&lt;c4&gt;</bpt>y<ept i="4">&lt;/c4&gt;</ept> is NaN.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例において、<bpt i="4" x="4">&lt;c4&gt;</bpt>y<ept i="4">&lt;/c4&gt;</ept>はNaNです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, an array of numbers is partitioned by a predicate that matches elements greater than 30.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の例において、数からなる配列は、30より大きな要素に合致するという述部によって仕切られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the <bpt i="15" x="15">&lt;c15&gt;</bpt>map(_:)<ept i="15">&lt;/c15&gt;</ept> method transforms each <bpt i="16" x="16">&lt;c16&gt;</bpt>Int<ept i="16">&lt;/c16&gt;</ept> received from a <bpt i="17" x="17">&lt;c17&gt;</bpt>Counter<ept i="17">&lt;/c17&gt;</ept> sequence into a <bpt i="18" x="18">&lt;c18&gt;</bpt>String<ept i="18">&lt;/c18&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例において、<bpt i="15" x="15">&lt;c15&gt;</bpt>map(_:)<ept i="15">&lt;/c15&gt;</ept>メソッドは<bpt i="17" x="17">&lt;c17&gt;</bpt>Counter<ept i="17">&lt;/c17&gt;</ept>シーケンスから受け取った各<bpt i="16" x="16">&lt;c16&gt;</bpt>Int<ept i="16">&lt;/c16&gt;</ept>を<bpt i="18" x="18">&lt;c18&gt;</bpt>String<ept i="18">&lt;/c18&gt;</ept>へと変換します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the closure provides an ordering for an array of a custom enumeration that describes an HTTP response.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例では、そのクロージャは、あるHTTP応答を記述するあつらえ列挙の配列に対してある順序付けを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the constant <bpt i="0" x="0">&lt;c0&gt;</bpt>y<ept i="0">&lt;/c0&gt;</ept> is successfully created from <bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept>, an <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept> instance with a value of <bpt i="3" x="3">&lt;c3&gt;</bpt>100<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例において、定数<bpt i="0" x="0">&lt;c0&gt;</bpt>y<ept i="0">&lt;/c0&gt;</ept>は、<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>インスタンスで<bpt i="2" x="2">&lt;c2&gt;</bpt>100<ept i="2">&lt;/c2&gt;</ept>の値を持つ<bpt i="3" x="3">&lt;c3&gt;</bpt>x<ept i="3">&lt;/c3&gt;</ept>からうまく作成されます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the constant <bpt i="2" x="2">&lt;c2&gt;</bpt>x<ept i="2">&lt;/c2&gt;</ept> is successfully created from a value of <bpt i="3" x="3">&lt;c3&gt;</bpt>100<ept i="3">&lt;/c3&gt;</ept>, while the attempt to initialize the constant <bpt i="4" x="4">&lt;c4&gt;</bpt>y<ept i="4">&lt;/c4&gt;</ept> from <bpt i="5" x="5">&lt;c5&gt;</bpt>1<bpt i="6" x="6">&lt;w6&gt;</bpt>_000<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> fails because the <bpt i="7" x="7">&lt;c7&gt;</bpt>Int8<ept i="7">&lt;/c7&gt;</ept> type can represent <bpt i="8" x="8">&lt;c8&gt;</bpt>127<ept i="8">&lt;/c8&gt;</ept> at maximum:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例において、定数<bpt i="2" x="2">&lt;c2&gt;</bpt>x<ept i="2">&lt;/c2&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>100<ept i="3">&lt;/c3&gt;</ept>の値から首尾よく作り上げられます、一方で定数<bpt i="4" x="4">&lt;c4&gt;</bpt>y<ept i="4">&lt;/c4&gt;</ept>を<bpt i="5" x="5">&lt;c5&gt;</bpt>1<bpt i="6" x="6">&lt;w6&gt;</bpt>_000<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>から初期化する試みは失敗します、なぜなら<bpt i="7" x="7">&lt;c7&gt;</bpt>Int8<ept i="7">&lt;/c7&gt;</ept>型は最大で<bpt i="8" x="8">&lt;c8&gt;</bpt>127<ept i="8">&lt;/c8&gt;</ept>を表現可能だからです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the constant <bpt i="2" x="2">&lt;c2&gt;</bpt>x<ept i="2">&lt;/c2&gt;</ept> is successfully created from a value of <bpt i="3" x="3">&lt;c3&gt;</bpt>21<bpt i="4" x="4">&lt;w4&gt;</bpt>.0<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, while the attempt to initialize the constant <bpt i="5" x="5">&lt;c5&gt;</bpt>y<ept i="5">&lt;/c5&gt;</ept> from <bpt i="6" x="6">&lt;c6&gt;</bpt>21<bpt i="7" x="7">&lt;w7&gt;</bpt>.5<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> fails:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>続く例において、定数<bpt i="2" x="2">&lt;c2&gt;</bpt>x<ept i="2">&lt;/c2&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>21<bpt i="4" x="4">&lt;w4&gt;</bpt>.0<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>の値から首尾よく作成されます、一方で定数<bpt i="5" x="5">&lt;c5&gt;</bpt>y<ept i="5">&lt;/c5&gt;</ept>を<bpt i="6" x="6">&lt;c6&gt;</bpt>21<bpt i="7" x="7">&lt;w7&gt;</bpt>.5<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>から初期化する試みは失敗します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the difference of <bpt i="1" x="1">&lt;c1&gt;</bpt>10<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>21<ept i="2">&lt;/c2&gt;</ept> is less than zero, the minimum representable <bpt i="3" x="3">&lt;c3&gt;</bpt>UInt<ept i="3">&lt;/c3&gt;</ept> value, so the result is the partial value after discarding the overflowing bits.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例において、<bpt i="1" x="1">&lt;c1&gt;</bpt>10<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>21<ept i="2">&lt;/c2&gt;</ept>の差はゼロ、最小限表現可能な<bpt i="3" x="3">&lt;c3&gt;</bpt>UInt<ept i="3">&lt;/c3&gt;</ept>値、よりも少ないです、それで結果はオーバーフローするビットを廃棄後の部分的な値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the difference of <bpt i="1" x="1">&lt;c1&gt;</bpt>10<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>21<ept i="2">&lt;/c2&gt;</ept> is less than zero, the minimum representable <bpt i="3" x="3">&lt;c3&gt;</bpt>UInt<ept i="3">&lt;/c3&gt;</ept> value, so the result is the result is the partial value after discarding the overflowing bits.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例において、<bpt i="1" x="1">&lt;c1&gt;</bpt>10<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>21<ept i="2">&lt;/c2&gt;</ept>の差はゼロ、最小限表現可能な<bpt i="3" x="3">&lt;c3&gt;</bpt>UInt<ept i="3">&lt;/c3&gt;</ept>値、よりも少ないです、それで結果はオーバーフローするビットを廃棄後の部分的な値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the key-value pair for the key <bpt i="0" x="0">&lt;c0&gt;</bpt>"Aquamarine"<ept i="0">&lt;/c0&gt;</ept> is removed from the dictionary by assigning <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> to the key-based subscript.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>"Aquamarine"<ept i="0">&lt;/c0&gt;</ept>に対するキー値ペアは、<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>をキー基盤の添え字に割り当てることによって辞書から削除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the predicate provides an ordering for an array of a custom <bpt i="0" x="0">&lt;c0&gt;</bpt>HTTPResponse<ept i="0">&lt;/c0&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例では、その述部はあつらえの<bpt i="0" x="0">&lt;c0&gt;</bpt>HTTPResponse<ept i="0">&lt;/c0&gt;</ept>型の配列に対してある順序付けを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the product of <bpt i="1" x="1">&lt;c1&gt;</bpt>10<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>50<ept i="2">&lt;/c2&gt;</ept> is greater than the maximum representable <bpt i="3" x="3">&lt;c3&gt;</bpt>Int8<ept i="3">&lt;/c3&gt;</ept> value, so the result is the partial value after discarding the overflowing bits.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例において、<bpt i="1" x="1">&lt;c1&gt;</bpt>10<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>50<ept i="2">&lt;/c2&gt;</ept>の積は、最大限表現可能な<bpt i="3" x="3">&lt;c3&gt;</bpt>Int8<ept i="3">&lt;/c3&gt;</ept>値より大きいです、それで結果はオーバーフローするビットを廃棄後の部分的な値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the result of <bpt i="0" x="0">&lt;c0&gt;</bpt>21 * 21<ept i="0">&lt;/c0&gt;</ept> is greater than the maximum representable <bpt i="1" x="1">&lt;c1&gt;</bpt>Int8<ept i="1">&lt;/c1&gt;</ept> value:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>21 * 21<ept i="0">&lt;/c0&gt;</ept>の結果は、最大限表現可能な<bpt i="1" x="1">&lt;c1&gt;</bpt>Int8<ept i="1">&lt;/c1&gt;</ept>値より大きいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the result of <bpt i="0" x="0">&lt;c0&gt;</bpt>21 + 120<ept i="0">&lt;/c0&gt;</ept> is greater than the maximum representable <bpt i="1" x="1">&lt;c1&gt;</bpt>Int8<ept i="1">&lt;/c1&gt;</ept> value:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>21 + 120<ept i="0">&lt;/c0&gt;</ept>の結果は、最大限表現可能な<bpt i="1" x="1">&lt;c1&gt;</bpt>Int8<ept i="1">&lt;/c1&gt;</ept>値より大きいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the result of <bpt i="0" x="0">&lt;c0&gt;</bpt>21 - 50<ept i="0">&lt;/c0&gt;</ept> is less than zero, the minimum representable <bpt i="1" x="1">&lt;c1&gt;</bpt>UInt8<ept i="1">&lt;/c1&gt;</ept> value:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>21 - 50<ept i="0">&lt;/c0&gt;</ept>の結果は、最大限表現可能な<bpt i="1" x="1">&lt;c1&gt;</bpt>UInt8<ept i="1">&lt;/c1&gt;</ept>値より大きいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the sum of <bpt i="1" x="1">&lt;c1&gt;</bpt>100<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>121<ept i="2">&lt;/c2&gt;</ept> is greater than the maximum representable <bpt i="3" x="3">&lt;c3&gt;</bpt>Int8<ept i="3">&lt;/c3&gt;</ept> value, so the result is the partial value after discarding the overflowing bits.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例において、<bpt i="1" x="1">&lt;c1&gt;</bpt>100<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>121<ept i="2">&lt;/c2&gt;</ept>の合計は、最大限表現可能な<bpt i="3" x="3">&lt;c3&gt;</bpt>Int8<ept i="3">&lt;/c3&gt;</ept>値より大きいです、それで結果はオーバーフローするビットを廃棄後の部分的な値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the value <bpt i="0" x="0">&lt;c0&gt;</bpt>127<bpt i="1" x="1">&lt;w1&gt;</bpt>.75<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is rounded to <bpt i="2" x="2">&lt;c2&gt;</bpt>127<ept i="2">&lt;/c2&gt;</ept>, which is representable by the <bpt i="3" x="3">&lt;c3&gt;</bpt>Int8<ept i="3">&lt;/c3&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>続く例において、値<bpt i="0" x="0">&lt;c0&gt;</bpt>127<bpt i="1" x="1">&lt;w1&gt;</bpt>.75<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>127<ept i="2">&lt;/c2&gt;</ept>へ丸められます、それは<bpt i="3" x="3">&lt;c3&gt;</bpt>Int8<ept i="3">&lt;/c3&gt;</ept>型によって表現可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the implementations above, the <bpt i="2" x="2">&lt;c2&gt;</bpt>Player<ept i="2">&lt;/c2&gt;</ept> type uses <bpt i="3" x="3">&lt;c3&gt;</bpt>name<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>position<ept i="4">&lt;/c4&gt;</ept> in both methods.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>上の実装において、<bpt i="2" x="2">&lt;c2&gt;</bpt>Player<ept i="2">&lt;/c2&gt;</ept>型は<bpt i="3" x="3">&lt;c3&gt;</bpt>name<ept i="3">&lt;/c3&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>position<ept i="4">&lt;/c4&gt;</ept>を両方のメソッドにおいて使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the next example, <bpt i="0" x="0">&lt;c0&gt;</bpt>y<ept i="0">&lt;/c0&gt;</ept> has a value of <bpt i="1" x="1">&lt;c1&gt;</bpt>21<bpt i="2" x="2">&lt;w2&gt;</bpt>.5<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>, which is encoded as <bpt i="3" x="3">&lt;c3&gt;</bpt>1<bpt i="4" x="4">&lt;w4&gt;</bpt>.34375 * 2 ** 4<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>y<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>21<bpt i="2" x="2">&lt;w2&gt;</bpt>.5<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の値を持ちます、それは<bpt i="3" x="3">&lt;c3&gt;</bpt>1<bpt i="4" x="4">&lt;w4&gt;</bpt>.34375 * 2 ** 4<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>のようにエンコードされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the umbrella header, import every Objective-C header you want to expose to Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>アンブレラヘッダにおいて、あなたが望むあらゆるObjective-CヘッダをインポートすることでSwiftに露出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this case, see the documentation of <bpt i="1" x="1">&lt;c1&gt;</bpt>Collection<bpt i="2" x="2">&lt;w2&gt;</bpt>.underestimated<bpt i="3" x="3">&lt;w3&gt;</bpt>Count<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この場合には、<bpt i="1" x="1">&lt;c1&gt;</bpt>Collection<bpt i="2" x="2">&lt;w2&gt;</bpt>.underestimated<bpt i="3" x="3">&lt;w3&gt;</bpt>Count<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の文書を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this case, the newly created set drops the duplicate value (“Dave”) and doesn’t maintain the order of the array literal’s elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この場合において、新たに作成された集合は、重複した値（「Dave」）を落とします、そして配列リテラルのもつ要素の順番を維持しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this case, the values stored in the array are references to objects that live outside the array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この場合、配列に格納される値らは、その配列の外側で生活しているオブジェクトらへの参照です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, <bpt i="0" x="0">&lt;c0&gt;</bpt>filter(_:)<ept i="0">&lt;/c0&gt;</ept> is used to include only names shorter than five characters.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>filter(_:)<ept i="0">&lt;/c0&gt;</ept>は５つの文字より短い名前のみ含めるために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, <bpt i="0" x="0">&lt;c0&gt;</bpt>good<bpt i="1" x="1">&lt;w1&gt;</bpt>Number<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is assigned a value of <bpt i="2" x="2">&lt;c2&gt;</bpt>100<ept i="2">&lt;/c2&gt;</ept> because <bpt i="3" x="3">&lt;c3&gt;</bpt>Int("100")<ept i="3">&lt;/c3&gt;</ept> succeeded in returning a non-<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept> result.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>good<bpt i="1" x="1">&lt;w1&gt;</bpt>Number<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>100<ept i="2">&lt;/c2&gt;</ept>の値を割り当てられます、なぜなら<bpt i="3" x="3">&lt;c3&gt;</bpt>Int("100")<ept i="3">&lt;/c3&gt;</ept>が非<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>の結果を返すことに成功したからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, <bpt i="0" x="0">&lt;c0&gt;</bpt>good<bpt i="1" x="1">&lt;w1&gt;</bpt>Number<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is assigned a value of <bpt i="2" x="2">&lt;c2&gt;</bpt>100<ept i="2">&lt;/c2&gt;</ept> because <bpt i="3" x="3">&lt;c3&gt;</bpt>Int("100")<ept i="3">&lt;/c3&gt;</ept> succeeds in returning a non-<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept> result.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>good<bpt i="1" x="1">&lt;w1&gt;</bpt>Number<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>100<ept i="2">&lt;/c2&gt;</ept>の値を割り当てられます、なぜなら<bpt i="3" x="3">&lt;c3&gt;</bpt>Int("100")<ept i="3">&lt;/c3&gt;</ept>が非<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>の結果を返すことに成功するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, <bpt i="0" x="0">&lt;c0&gt;</bpt>lhs<ept i="0">&lt;/c0&gt;</ept> tests whether <bpt i="1" x="1">&lt;c1&gt;</bpt>error<ept i="1">&lt;/c1&gt;</ept> is an empty string.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>lhs<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>error<ept i="1">&lt;/c1&gt;</ept>が空の文字列かどうかテストします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, <bpt i="0" x="0">&lt;c0&gt;</bpt>lhs<ept i="0">&lt;/c0&gt;</ept> tests whether <bpt i="1" x="1">&lt;c1&gt;</bpt>measurements<bpt i="2" x="2">&lt;w2&gt;</bpt>.count<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is greater than zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>lhs<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>measurements<bpt i="2" x="2">&lt;w2&gt;</bpt>.count<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>がゼロより大きいかどうかテストします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, <bpt i="0" x="0">&lt;c0&gt;</bpt>map<ept i="0">&lt;/c0&gt;</ept> is used first to convert the names in the array to lowercase strings and then to count their characters.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例では、<bpt i="0" x="0">&lt;c0&gt;</bpt>map<ept i="0">&lt;/c0&gt;</ept>は最初に配列中の名前を小文字文字列に変換するために、それからそれらの文字を数えるために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> has a value of <bpt i="1" x="1">&lt;c1&gt;</bpt>21<bpt i="2" x="2">&lt;w2&gt;</bpt>.5<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>, which is stored as <bpt i="3" x="3">&lt;c3&gt;</bpt>1<bpt i="4" x="4">&lt;w4&gt;</bpt>.34375 * 2**4<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, where <bpt i="5" x="5">&lt;c5&gt;</bpt>**<ept i="5">&lt;/c5&gt;</ept> is exponentiation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>21<bpt i="2" x="2">&lt;w2&gt;</bpt>.5<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の値を持ちます、それは<bpt i="3" x="3">&lt;c3&gt;</bpt>1<bpt i="4" x="4">&lt;w4&gt;</bpt>.34375 * 2**4<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>として格納されます、ここで<bpt i="5" x="5">&lt;c5&gt;</bpt>**<ept i="5">&lt;/c5&gt;</ept>は冪です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> is initialized as an <bpt i="1" x="1">&lt;c1&gt;</bpt>Int8<ept i="1">&lt;/c1&gt;</ept> instance by clamping <bpt i="2" x="2">&lt;c2&gt;</bpt>500<ept i="2">&lt;/c2&gt;</ept> to the range <bpt i="3" x="3">&lt;c3&gt;</bpt>-128...127<ept i="3">&lt;/c3&gt;</ept>, and <bpt i="4" x="4">&lt;c4&gt;</bpt>y<ept i="4">&lt;/c4&gt;</ept> is initialized as a <bpt i="5" x="5">&lt;c5&gt;</bpt>UInt<ept i="5">&lt;/c5&gt;</ept> instance by clamping <bpt i="6" x="6">&lt;c6&gt;</bpt>-500<ept i="6">&lt;/c6&gt;</ept> to the range <bpt i="7" x="7">&lt;c7&gt;</bpt>0...UInt<bpt i="8" x="8">&lt;w8&gt;</bpt>.max<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>Int8<ept i="1">&lt;/c1&gt;</ept>インスタンスとして、<bpt i="2" x="2">&lt;c2&gt;</bpt>500<ept i="2">&lt;/c2&gt;</ept>を範囲<bpt i="3" x="3">&lt;c3&gt;</bpt>-128...127<ept i="3">&lt;/c3&gt;</ept>に制限すること（クランピング）によって初期化されます、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>y<ept i="4">&lt;/c4&gt;</ept>は<bpt i="5" x="5">&lt;c5&gt;</bpt>UInt<ept i="5">&lt;/c5&gt;</ept>インスタンスとして、<bpt i="6" x="6">&lt;c6&gt;</bpt>-500<ept i="6">&lt;/c6&gt;</ept>を範囲<bpt i="7" x="7">&lt;c7&gt;</bpt>0...UInt<bpt i="8" x="8">&lt;w8&gt;</bpt>.max<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>に制限することによって初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, accessing the <bpt i="0" x="0">&lt;c0&gt;</bpt>text<ept i="0">&lt;/c0&gt;</ept> property of the <bpt i="1" x="1">&lt;c1&gt;</bpt>smiley<bpt i="2" x="2">&lt;w2&gt;</bpt>Type<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> metatype retrieves the overridden value from the <bpt i="3" x="3">&lt;c3&gt;</bpt>Emoji<bpt i="4" x="4">&lt;w4&gt;</bpt>Smiley<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> subclass, instead of the <bpt i="5" x="5">&lt;c5&gt;</bpt>Smiley<ept i="5">&lt;/c5&gt;</ept> class’s original definition.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、<bpt i="1" x="1">&lt;c1&gt;</bpt>smiley<bpt i="2" x="2">&lt;w2&gt;</bpt>Type<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>メタタイプの<bpt i="0" x="0">&lt;c0&gt;</bpt>text<ept i="0">&lt;/c0&gt;</ept>プロパティにアクセスすることは、<bpt i="3" x="3">&lt;c3&gt;</bpt>Emoji<bpt i="4" x="4">&lt;w4&gt;</bpt>Smiley<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>サブクラスからオーバーライドされた値を取って来ます、<bpt i="5" x="5">&lt;c5&gt;</bpt>Smiley<ept i="5">&lt;/c5&gt;</ept>クラスのもつ元の定義ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, an array of three ranges is flattened so that the elements of each range can be iterated in turn.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、３つの範囲からなる配列は平坦化されます、それで各範囲の要素は順に反復されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, an asynchronous sequence called <bpt i="0" x="0">&lt;c0&gt;</bpt>Counter<ept i="0">&lt;/c0&gt;</ept> produces <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept> values from <bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept> to <bpt i="3" x="3">&lt;c3&gt;</bpt>10<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>Counter<ept i="0">&lt;/c0&gt;</ept>と呼ばれる非同期シーケンスは<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>値を<bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>から<bpt i="3" x="3">&lt;c3&gt;</bpt>10<ept i="3">&lt;/c3&gt;</ept>まで生み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, an asynchronous sequence called <bpt i="0" x="0">&lt;c0&gt;</bpt>Counter<ept i="0">&lt;/c0&gt;</ept> produces <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept> values from <bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept> to <bpt i="3" x="3">&lt;c3&gt;</bpt>4<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>Counter<ept i="0">&lt;/c0&gt;</ept>と呼ばれる非同期シーケンスは<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>値を<bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>から<bpt i="3" x="3">&lt;c3&gt;</bpt>4<ept i="3">&lt;/c3&gt;</ept>まで生み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, an asynchronous sequence called <bpt i="0" x="0">&lt;c0&gt;</bpt>Counter<ept i="0">&lt;/c0&gt;</ept> produces <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept> values from <bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept> to <bpt i="3" x="3">&lt;c3&gt;</bpt>5<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>Counter<ept i="0">&lt;/c0&gt;</ept>と呼ばれる非同期シーケンスは、<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>値を<bpt i="2" x="2">&lt;c2&gt;</bpt>1<ept i="2">&lt;/c2&gt;</ept>から<bpt i="3" x="3">&lt;c3&gt;</bpt>5<ept i="3">&lt;/c3&gt;</ept>まで生み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, both assignments to the <bpt i="0" x="0">&lt;c0&gt;</bpt>printed<bpt i="1" x="1">&lt;w1&gt;</bpt>Message<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> variable call this Boolean literal initializer behind the scenes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>printed<bpt i="1" x="1">&lt;w1&gt;</bpt>Message<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>変数への代入は両方ともこのブールリテラルイニシャライザを舞台裏で呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, note the difference in the result of using <bpt i="0" x="0">&lt;c0&gt;</bpt>map<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>compact<bpt i="2" x="2">&lt;w2&gt;</bpt>Map<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> with a transformation that returns an optional <bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>map<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>compact<bpt i="2" x="2">&lt;w2&gt;</bpt>Map<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>を、オプショナル<bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>値を返す変換とともに使う結果の違いに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, note the difference in the result of using <bpt i="0" x="0">&lt;c0&gt;</bpt>map<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>flat<bpt i="2" x="2">&lt;w2&gt;</bpt>Map<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> with a transformation that returns an array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>map<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>flat<bpt i="2" x="2">&lt;w2&gt;</bpt>Map<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>をある配列を返す変換とともに使うことの結果における違いに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, note the difference in the result of using <bpt i="0" x="0">&lt;c0&gt;</bpt>map<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>flat<bpt i="2" x="2">&lt;w2&gt;</bpt>Map<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> with a transformation that returns an optional <bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>map<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>flat<bpt i="2" x="2">&lt;w2&gt;</bpt>Map<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>を、オプショナル<bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>値を返す変換とともに使う結果の違いに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, note the difference in the result of using <bpt i="0" x="0">&lt;c0&gt;</bpt>map<bpt i="1" x="1">&lt;w1&gt;</bpt>Values<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>compact<bpt i="3" x="3">&lt;w3&gt;</bpt>Map<bpt i="4" x="4">&lt;w4&gt;</bpt>Values<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> with a transformation that returns an optional <bpt i="5" x="5">&lt;c5&gt;</bpt>Int<ept i="5">&lt;/c5&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>map<bpt i="1" x="1">&lt;w1&gt;</bpt>Values<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>compact<bpt i="3" x="3">&lt;w3&gt;</bpt>Map<bpt i="4" x="4">&lt;w4&gt;</bpt>Values<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を、オプショナル<bpt i="5" x="5">&lt;c5&gt;</bpt>Int<ept i="5">&lt;/c5&gt;</ept>値を返す変換とともに使う結果の違いに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, the <bpt i="0" x="0">&lt;c0&gt;</bpt>case 3<ept i="0">&lt;/c0&gt;</ept> expression uses this pattern-matching operator to test whether <bpt i="1" x="1">&lt;c1&gt;</bpt>weekday<ept i="1">&lt;/c1&gt;</ept> is equal to the value <bpt i="2" x="2">&lt;c2&gt;</bpt>3<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例では、<bpt i="0" x="0">&lt;c0&gt;</bpt>case 3<ept i="0">&lt;/c0&gt;</ept>式はこのパターンマッチング演算子を使って<bpt i="1" x="1">&lt;c1&gt;</bpt>weekday<ept i="1">&lt;/c1&gt;</ept>が値<bpt i="2" x="2">&lt;c2&gt;</bpt>3<ept i="2">&lt;/c2&gt;</ept>と等しいかどうかテストします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, the <bpt i="4" x="4">&lt;c4&gt;</bpt>colors<ept i="4">&lt;/c4&gt;</ept> array can be bridged to <bpt i="5" x="5">&lt;c5&gt;</bpt>NSArray<ept i="5">&lt;/c5&gt;</ept> because the <bpt i="6" x="6">&lt;c6&gt;</bpt>colors<ept i="6">&lt;/c6&gt;</ept> array’s <bpt i="7" x="7">&lt;c7&gt;</bpt>String<ept i="7">&lt;/c7&gt;</ept> elements bridge to <bpt i="8" x="8">&lt;c8&gt;</bpt>NSString<ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例では、<bpt i="4" x="4">&lt;c4&gt;</bpt>colors<ept i="4">&lt;/c4&gt;</ept>配列は<bpt i="5" x="5">&lt;c5&gt;</bpt>NSArray<ept i="5">&lt;/c5&gt;</ept>にブリッジできます、なぜならそれの<bpt i="6" x="6">&lt;c6&gt;</bpt>colors<ept i="6">&lt;/c6&gt;</ept>配列のもつ<bpt i="7" x="7">&lt;c7&gt;</bpt>String<ept i="7">&lt;/c7&gt;</ept>要素が<bpt i="8" x="8">&lt;c8&gt;</bpt>NSString<ept i="8">&lt;/c8&gt;</ept>にブリッジするからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, the assignment to the <bpt i="0" x="0">&lt;c0&gt;</bpt>twas<bpt i="1" x="1">&lt;w1&gt;</bpt>Brillig<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> constant calls this Boolean literal initializer behind the scenes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>twas<bpt i="1" x="1">&lt;w1&gt;</bpt>Brillig<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>定数への代入は、このブールリテラルイニシャライザを舞台裏で呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, the assignment to the <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> constant calls this floating-point literal initializer behind the scenes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>定数への代入は、この浮動小数点リテラルイニシャライザを舞台裏で呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, the assignment to the <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> constant calls this integer literal initializer behind the scenes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>定数への代入は、この整数リテラルイニシャライザを舞台裏で呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, the compiler infers the full type of each array literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例では、コンパイラは各配列の完全な型を推論します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, the resulting array is the same length as <bpt i="2" x="2">&lt;c2&gt;</bpt>words<ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、結果の配列は<bpt i="2" x="2">&lt;c2&gt;</bpt>words<ept i="2">&lt;/c2&gt;</ept>と同じ長さです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, three elements in the middle of an array of integers are replaced by the five elements of a <bpt i="0" x="0">&lt;c0&gt;</bpt>Repeated&lt;Int&gt;<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例では、整数からなる配列の真ん中の３つの要素が、<bpt i="0" x="0">&lt;c0&gt;</bpt>Repeated&lt;Int&gt;<ept i="0">&lt;/c0&gt;</ept>インスタンスの５つの要素によって置き換えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In your <bpt i="0" x="0">&lt;c0&gt;</bpt>hash(into:)<ept i="0">&lt;/c0&gt;</ept> implementation, call <bpt i="1" x="1">&lt;c1&gt;</bpt>combine(_:)<ept i="1">&lt;/c1&gt;</ept> on the provided <bpt i="2" x="2">&lt;c2&gt;</bpt>Hasher<ept i="2">&lt;/c2&gt;</ept> instance with the essential components of your type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたの<bpt i="0" x="0">&lt;c0&gt;</bpt>hash(into:)<ept i="0">&lt;/c0&gt;</ept>実装において、<bpt i="1" x="1">&lt;c1&gt;</bpt>combine(_:)<ept i="1">&lt;/c1&gt;</ept>をその提供された<bpt i="2" x="2">&lt;c2&gt;</bpt>Hasher<ept i="2">&lt;/c2&gt;</ept>インスタンス上で、あなたの型の本質的な構成要素とともに呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In your Objective-C bridging header, import every Objective-C header you want to expose to Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのObjective-Cブリッジヘッダにおいて、あなたが露出したいあらゆるObjective-CヘッダをSwiftにインポートしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Include Swift Classes in Objective-C Headers Using Forward Declarations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>SwiftクラスをObjective-Cヘッダの中に前方宣言を使ってインクルードする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Including More Data in Errors</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>さらなるデータをエラーに含める</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Indicates that a precondition was violated.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これは前提条件が破られたことを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Indicates that an internal sanity check failed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これはある内部的な正常性確認が失敗したことを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Indication of the type of termination informed to <bpt i="0" x="0">&lt;c0&gt;</bpt>on<bpt i="1" x="1">&lt;w1&gt;</bpt>Termination<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>on<bpt i="1" x="1">&lt;w1&gt;</bpt>Termination<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に告知した終了の型を指し示すもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Indication that the continuation was yielded when the stream was already in a terminal state: either by cancel or by finishing.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ストリームが既に終端状態であった時に継続が生み出されたというしるし；取り消しによってまたは終了によってのどちらか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Indices and Iterators</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インデックスとイテレータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Indices that are moved forward and backward in a bidirectional collection move by the same amount in each direction.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>二方向性のコレクションにおいて前方および後方に移動されるインデックス値は、各方向で同じ量だけ移動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inequality is the inverse of equality.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>不等性は、同等性の裏返しです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Infinite values with the same sign are equal to each other.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同じ符号を持つ無限大値は互いに等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Infinity</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>無限大</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Infinity compares greater than all finite numbers and equal to other infinite values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>無限大は、すべての有限の数より大きい、そして他の無限大の値と等しいと比較されます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Information about an error condition including a domain, a domain-specific error code, and application-specific information.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある領域、ある領域特有のエラーコード、そしてアプリケーション特有の情報を含んでいるエラー条件についての情報。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Infrequently Used Functionality</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>滅多に使われない機能性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Infrequently Used Intializers</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>滅多に使われないイニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inherited By</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>継承される先</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inherits From</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>継承元</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Initialization with Literals</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>リテラルを使った初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Initializers</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>イニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Input and Output</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>入力と出力</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inserts a new element at the specified position.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある新しい要素を指定された位置で挿入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inserts the elements of a sequence into the collection at the specified position.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンスに属する複数の要素をコレクションへ指定された位置で挿入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inside the closure, set the <bpt i="0" x="0">&lt;c0&gt;</bpt>initialized<bpt i="1" x="1">&lt;w1&gt;</bpt>Count<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> parameter to the number of elements that are initialized by the closure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>クロージャ内部で、<bpt i="0" x="0">&lt;c0&gt;</bpt>initialized<bpt i="1" x="1">&lt;w1&gt;</bpt>Count<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>パラメータを、クロージャによって初期化される要素の数に設定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inside unit test targets, you can access imported internal declarations as if they were public by prepending <bpt i="8" x="8">&lt;c8&gt;</bpt>@testable<ept i="8">&lt;/c8&gt;</ept> to the product module import statement.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ユニットテスト内部で、あなたはインポートされたinternal宣言に、まるでそれらがパブリックだったかのようにアクセスすることが、製品モジュールインポート文に<bpt i="8" x="8">&lt;c8&gt;</bpt>@testable<ept i="8">&lt;/c8&gt;</ept>を前に付けることによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inspecting a Boolean</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ブールを調査する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inspecting a Character</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>表意文字を調べる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inspecting a Dictionary</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書を調査する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inspecting a Range</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲を調査する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inspecting an Array</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列を調査する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instance Casting</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インスタンスのキャスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instance Method</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インスタンスメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instance Methods</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インスタンスメソッド </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instance Properties</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>様々なインスタンスプロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instance Property</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インスタンスプロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instead of calling this initializer, most code calls the <bpt i="0" x="0">&lt;c0&gt;</bpt>with<bpt i="1" x="1">&lt;w1&gt;</bpt>Checked<bpt i="2" x="2">&lt;w2&gt;</bpt>Continuation(function:<bpt i="3" x="3">&lt;w3&gt;</bpt>_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> or <bpt i="4" x="4">&lt;c4&gt;</bpt>with<bpt i="5" x="5">&lt;w5&gt;</bpt>Checked<bpt i="6" x="6">&lt;w6&gt;</bpt>Throwing<bpt i="7" x="7">&lt;w7&gt;</bpt>Continuation(function:<bpt i="8" x="8">&lt;w8&gt;</bpt>_:)<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> function instead.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザを呼びださずに、ほとんどのコードは<bpt i="0" x="0">&lt;c0&gt;</bpt>with<bpt i="1" x="1">&lt;w1&gt;</bpt>Checked<bpt i="2" x="2">&lt;w2&gt;</bpt>Continuation(function:<bpt i="3" x="3">&lt;w3&gt;</bpt>_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>または<bpt i="4" x="4">&lt;c4&gt;</bpt>with<bpt i="5" x="5">&lt;w5&gt;</bpt>Checked<bpt i="6" x="6">&lt;w6&gt;</bpt>Throwing<bpt i="7" x="7">&lt;w7&gt;</bpt>Continuation(function:<bpt i="8" x="8">&lt;w8&gt;</bpt>_:)<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>関数を代わりに呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instead of copying over the elements of a slice to new storage, an <bpt i="2" x="2">&lt;c2&gt;</bpt>Array<bpt i="3" x="3">&lt;w3&gt;</bpt>Slice<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance presents a view onto the storage of a larger array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある断片部分（スライス）の要素をすっかり新しいストレージにコピーする代わりに、<bpt i="2" x="2">&lt;c2&gt;</bpt>Array<bpt i="3" x="3">&lt;w3&gt;</bpt>Slice<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスはある大きな配列に関するある見方（ビュー）を提示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instead of having constant time when averaged over many calls, the function may decay to performance that is linear in <bpt i="6" x="6">&lt;c6&gt;</bpt>values<bpt i="7" x="7">&lt;w7&gt;</bpt>.count<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>多くの呼出しの全体を平均したとき定数時を持つのではなく、<bpt i="6" x="6">&lt;c6&gt;</bpt>values<bpt i="7" x="7">&lt;w7&gt;</bpt>.count<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>において線形である性能を関数が衰えさせるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instead of returning an iterator with a type that encapsulates the implementation of the collection, the <bpt i="4" x="4">&lt;c4&gt;</bpt>digits()<ept i="4">&lt;/c4&gt;</ept> function first wraps the iterator in an <bpt i="5" x="5">&lt;c5&gt;</bpt>Any<bpt i="6" x="6">&lt;w6&gt;</bpt>Iterator<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このコレクションの実装をカプセル化するある型をもつイテレータを返すのではなく、<bpt i="4" x="4">&lt;c4&gt;</bpt>digits()<ept i="4">&lt;/c4&gt;</ept>関数はイテレータを<bpt i="5" x="5">&lt;c5&gt;</bpt>Any<bpt i="6" x="6">&lt;w6&gt;</bpt>Iterator<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>インスタンスの中にまずラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instead of trapping on out-of-range values, using the failable <bpt i="1" x="1">&lt;c1&gt;</bpt>init?(exactly:)<ept i="1">&lt;/c1&gt;</ept> initializer results in <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲外の値に関してトラップするのではなく、失敗できる<bpt i="1" x="1">&lt;c1&gt;</bpt>init?(exactly:)<ept i="1">&lt;/c1&gt;</ept>イニシャライザは<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>という結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instead, convert an instance of any type to a string by using the <bpt i="0" x="0">&lt;c0&gt;</bpt>String(describing:)<ept i="0">&lt;/c0&gt;</ept> initializer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>代わりに、どんな型のインスタンスでも文字列へと、<bpt i="0" x="0">&lt;c0&gt;</bpt>String(describing:)<ept i="0">&lt;/c0&gt;</ept>イニシャライザを使って変換してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instead, convert an instance of any type to a string by using the <bpt i="0" x="0">&lt;c0&gt;</bpt>String(reflecting:)<ept i="0">&lt;/c0&gt;</ept> initializer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>代わりに、どんな型のインスタンスでも文字列へと、<bpt i="0" x="0">&lt;c0&gt;</bpt>String(reflecting:)<ept i="0">&lt;/c0&gt;</ept>イニシャライザを使って変換してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instead, create a new <bpt i="0" x="0">&lt;c0&gt;</bpt>Bool<ept i="0">&lt;/c0&gt;</ept> instance by using one of the Boolean literals <bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>代わりに、新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>Bool<ept i="0">&lt;/c0&gt;</ept>インスタンスをブールリテラルの<bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>または<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>のうち１つを使って作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instead, create a new array by using an array literal as its value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>代わりに、配列リテラルをその値として使うことで新しい配列を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instead, each presents a view onto the storage of the <bpt i="4" x="4">&lt;c4&gt;</bpt>absences<ept i="4">&lt;/c4&gt;</ept> array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>代わりに、<bpt i="4" x="4">&lt;c4&gt;</bpt>absences<ept i="4">&lt;/c4&gt;</ept>配列のストレージ上でのひとつのビューをそれぞれが提示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instead, initialize a variable or constant using a floating-point literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>代わりに、浮動小数点リテラルを使って変数や定数を初期化してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instead, initialize a variable or constant using an integer literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>代わりに、整数リテラルを使って変数や定数を初期化してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instead, initialize a variable or constant using one of the Boolean literals <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>代わりに、変数や定数をブールリテラル<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>のうちの１つを使って初期化してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instead, use only the <bpt i="1" x="1">&lt;c1&gt;</bpt>Unsafe<bpt i="2" x="2">&lt;w2&gt;</bpt>Mutable<bpt i="3" x="3">&lt;w3&gt;</bpt>Buffer<bpt i="4" x="4">&lt;w4&gt;</bpt>Pointer<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> argument to <bpt i="5" x="5">&lt;c5&gt;</bpt>body<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その代わりに、<bpt i="1" x="1">&lt;c1&gt;</bpt>Unsafe<bpt i="2" x="2">&lt;w2&gt;</bpt>Mutable<bpt i="3" x="3">&lt;w3&gt;</bpt>Buffer<bpt i="4" x="4">&lt;w4&gt;</bpt>Pointer<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>引数だけを<bpt i="5" x="5">&lt;c5&gt;</bpt>body<ept i="5">&lt;/c5&gt;</ept>に使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instead, use only the <bpt i="1" x="1">&lt;c1&gt;</bpt>Unsafe<bpt i="2" x="2">&lt;w2&gt;</bpt>Mutable<bpt i="3" x="3">&lt;w3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Buffer<bpt i="5" x="5">&lt;w5&gt;</bpt>Pointer<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> argument to <bpt i="6" x="6">&lt;c6&gt;</bpt>body<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その代わりに、<bpt i="1" x="1">&lt;c1&gt;</bpt>Unsafe<bpt i="2" x="2">&lt;w2&gt;</bpt>Mutable<bpt i="3" x="3">&lt;w3&gt;</bpt>Raw<bpt i="4" x="4">&lt;w4&gt;</bpt>Buffer<bpt i="5" x="5">&lt;w5&gt;</bpt>Pointer<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>引数だけを<bpt i="6" x="6">&lt;c6&gt;</bpt>body<ept i="6">&lt;/c6&gt;</ept>に使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instead, use string interpolation to create a new string by including values, literals, variables, or expressions enclosed in parentheses, prefixed by a backslash (<bpt i="0" x="0">&lt;c0&gt;</bpt>\(<ept i="0">&lt;/c0&gt;</ept>…<bpt i="1" x="1">&lt;c1&gt;</bpt>)<ept i="1">&lt;/c1&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>代わりに、文字列補間を使って、バックスラッシュ<bpt i="0" x="0">&lt;c0&gt;</bpt>\(<ept i="0">&lt;/c0&gt;</ept>…<bpt i="1" x="1">&lt;c1&gt;</bpt>)<ept i="1">&lt;/c1&gt;</ept>を前に置いた丸括弧に囲まれた値、リテラル、変数、または式を含めることで、新しい文字列を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instead, use the <bpt i="4" x="4">&lt;c4&gt;</bpt>task<ept i="4">&lt;/c4&gt;</ept> property of <bpt i="5" x="5">&lt;c5&gt;</bpt>Unsafe<bpt i="6" x="6">&lt;w6&gt;</bpt>Current<bpt i="7" x="7">&lt;w7&gt;</bpt>Task<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> to access an instance of <bpt i="8" x="8">&lt;c8&gt;</bpt>Task<ept i="8">&lt;/c8&gt;</ept> that you can store long-term and interact with outside of the closure body.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>代わりに、<bpt i="5" x="5">&lt;c5&gt;</bpt>Unsafe<bpt i="6" x="6">&lt;w6&gt;</bpt>Current<bpt i="7" x="7">&lt;w7&gt;</bpt>Task<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>の<bpt i="4" x="4">&lt;c4&gt;</bpt>task<ept i="4">&lt;/c4&gt;</ept>プロパティを使うことで、あなたが長期間格納することそしてクロージャ本体の外側で相互作用することが可能な<bpt i="8" x="8">&lt;c8&gt;</bpt>Task<ept i="8">&lt;/c8&gt;</ept>のインスタンスにアクセスしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instead, use the Boolean literal <bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept> to create a new <bpt i="1" x="1">&lt;c1&gt;</bpt>Bool<ept i="1">&lt;/c1&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>代わりに、ブールリテラル<bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>を使って新しい<bpt i="1" x="1">&lt;c1&gt;</bpt>Bool<ept i="1">&lt;/c1&gt;</ept>インスタンスを作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instead, use the value’s <bpt i="1" x="1">&lt;c1&gt;</bpt>is<bpt i="2" x="2">&lt;w2&gt;</bpt>Na<bpt i="3" x="3">&lt;w3&gt;</bpt>N<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>代わりに、その値の<bpt i="1" x="1">&lt;c1&gt;</bpt>is<bpt i="2" x="2">&lt;w2&gt;</bpt>Na<bpt i="3" x="3">&lt;w3&gt;</bpt>N<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>プロパティを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instead, when you need an operation to have a specific numeric result, filter out any NaN values using the <bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Na<bpt i="2" x="2">&lt;w2&gt;</bpt>N<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そうではなく、あなたがある特定の数値結果を持つ演算を必要とする場合、あらゆるNaN値を<bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Na<bpt i="2" x="2">&lt;w2&gt;</bpt>N<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>特性を使って除去してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instead, you use <bpt i="5" x="5">&lt;c5&gt;</bpt>await<ept i="5">&lt;/c5&gt;</ept> to receive values as they become available.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その代わりに、あなたは<bpt i="5" x="5">&lt;c5&gt;</bpt>await<ept i="5">&lt;/c5&gt;</ept>を使って値それらをそれらが利用可能になるにつれて回収します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Integer</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>整数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Integer Operators</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>整数演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Interpolates the given value’s textual representation into the string literal being created.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた値のもつテキスト表現を、その作成されている文字列リテラルへと補間します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Invalid bytes are replaced by Unicode <bpt i="1" x="1">&lt;a1&gt;</bpt>replacement characters<ept i="1">&lt;/a1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>無効なバイトは、<bpt i="1" x="1">&lt;a1&gt;</bpt>ユニコード代替文字<ept i="1">&lt;/a1&gt;</ept>で置き換えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Invokes the given closure with a C <bpt i="0" x="0">&lt;c0&gt;</bpt>va<bpt i="1" x="1">&lt;w1&gt;</bpt>_list<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> argument derived from the given array of arguments.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたクロージャを、その与えられた引数の配列から引き出されたC <bpt i="0" x="0">&lt;c0&gt;</bpt>va<bpt i="1" x="1">&lt;w1&gt;</bpt>_list<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>引数で発動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Invokes the given closure with a buffer pointer covering the raw bytes of the given argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたクロージャを、与えられた引数の生のバイトを変換しているバッファポインタとともに発動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Invokes the given closure with a mutable buffer pointer covering the raw bytes of the given argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたクロージャを、与えられた引数の生のバイトを変換している可変バッファポインタとともに発動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Invokes the given closure with a pointer to the given argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたクロージャを、与えられた引数に対するポインタとともに発動します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It acts as an iterator by using a collection’s indices to step over each value in the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それは、コレクションのインデックスを使ってコレクションの中の各値のすべてを渡っていくあるイテレータとしての役割を果たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It also means that when you share a class instance across your app, changes you make to that instance are visible to every part of your code that holds a reference to that instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それはまた、あなたがあるクラスインスタンスをあなたのアプリの至る所で共有する場合、あなたがそのインスタンスになす変更は、そのインスタンスに対する参照を保持するあなたのコードのあらゆる部分で見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is called by the compiler to handle dictionary literals.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それは、辞書リテラルを取り扱うためにコンパイラによって呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is not intended to be used from multiple concurrent contexts.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それは複数の並行性文脈から使われることを意図されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is thread safe to send and finish; all calls are to the continuation are serialized, however calling this from multiple concurrent contexts could result in out of order delivery.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それは、スレッド安全に送信および終了します；並行性への呼び出しそれら全てはシリアル化されます、しかしながらこれを複数の並行性文脈から呼び出すことは、順序違い配達という結果になりえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is thread safe to send and finish; all calls to the continuation are serialized, however calling this from multiple concurrent contexts could result in out of order delivery.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それは、スレッド安全に送信および終了します；並行性への呼び出しそれら全てはシリアル化されます、しかしながらこれを複数の並行性文脈から呼び出すことは、順序違い配達という結果になりえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is undefined behavior for the escapable closure to be stored, referenced, or executed after the function returns.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>関数が返った後に格納、参照、または実行されることは、脱出可能クロージャにとって未定義挙動です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is undefined behavior to attempt to mutate through the pointer by conversion to <bpt i="5" x="5">&lt;c5&gt;</bpt>Unsafe<bpt i="6" x="6">&lt;w6&gt;</bpt>Mutable<bpt i="7" x="7">&lt;w7&gt;</bpt>Raw<bpt i="8" x="8">&lt;w8&gt;</bpt>Buffer<bpt i="9" x="9">&lt;w9&gt;</bpt>Pointer<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> or any other mutable pointer type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ポインタを通して<bpt i="5" x="5">&lt;c5&gt;</bpt>Unsafe<bpt i="6" x="6">&lt;w6&gt;</bpt>Mutable<bpt i="7" x="7">&lt;w7&gt;</bpt>Raw<bpt i="8" x="8">&lt;w8&gt;</bpt>Buffer<bpt i="9" x="9">&lt;w9&gt;</bpt>Pointer<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>または何か他の可変ポインタ型への変換によって変化させようと試みることは、未定義挙動です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is undefined behavior to try to mutate through the pointer argument by converting it to <bpt i="5" x="5">&lt;c5&gt;</bpt>Unsafe<bpt i="6" x="6">&lt;w6&gt;</bpt>Mutable<bpt i="7" x="7">&lt;w7&gt;</bpt>Pointer<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> or any other mutable pointer type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ポインタ引数を通して変化させることを、それを<bpt i="5" x="5">&lt;c5&gt;</bpt>Unsafe<bpt i="6" x="6">&lt;w6&gt;</bpt>Mutable<bpt i="7" x="7">&lt;w7&gt;</bpt>Pointer<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>または何か他の可変ポインタ型へ変換することによって、試みるのは未定義挙動です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is up to both the conformer and the receiver of the protocol to document the nature of the identity.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その同一性の本質を文書化するのは、そのプロトコルの準拠側とレシーバの両方の責任です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is used by the compiler when interpreting string interpolations.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それは文字列補間を解釈する時にコンパイラによって使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is used by the compiler when you create a string using string interpolation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それはあなたが文字列補間を使って文字列を作成する時にコンパイラによって使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is used by the compiler when you use a Boolean literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それは、あなたがブールリテラルを使う時にコンパイラによって使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is used by the compiler when you use a string literal to initialize a <bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それは、あなたが文字列リテラルを使って<bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept>インスタンスを初期化する時にコンパイラによって使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is used by the compiler when you use an array literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それは、あなたが配列リテラルを使う時にコンパイラによって使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It's a good idea for all your custom model types to conform.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのあつらえのモデル型すべてにとって準拠することは良い考えです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It's appropriate to use a class in this case, but be sure to limit which parts of your app get access to the shared database object.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この場合にはクラスを使うのが適切です、しかしあなたのアプリのどの部分が共有データベースオブジェクトに対するアクセスを手に入れるかに限界を設けることを確実にしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It's useful for communicating changes between logically separated parts of your app—such as between models and views.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それは、あなたのアプリの論理的に分離された部分の間で変更を伝えるために役立ちます — 例えばモデルとビューの間など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Iterating Over a Collection's Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの要素すべてに反復していく</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Iterating Over a Range's Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある範囲の持つ要素すべてに反復していく</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Iterating Over an Array's Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列の要素すべてに反復する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Iterating Over the Contents of a Dictionary</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書の内容すべてにわたって反復していく</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Iterating over Keys and Values</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キーと値のすべてに反復する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Iterating over a dictionary yields the key-value pairs as two-element tuples.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある辞書すべてを対象として反復することは、キー値ペアを２要素タプルとして生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Iterating over the elements of a collection by their positions yields the same elements in the same order as iterating over that collection using its iterator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるコレクションの要素すべてにそれの位置によって反復していくことは、そのコレクションすべてにそれのイテレータを使って反復していくのと同じ要素を同じ順序で生み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It’s used by the compiler when you create a string using string interpolation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それは、あなたが文字列を文字列補完を使って作成する時に、コンパイラによって使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Key Paths</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キーパス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Key-Path Expressions</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キーパス式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Key-value observing is a Cocoa programming pattern you use to notify objects about changes to properties of other objects.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キー値監視は、他のオブジェクトのプロパティに対する変更を通知するためにあなたが使うCocoaプログラミングパターンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Language Interoperability</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>言語互換性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Learn Swift</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftを学ぶ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Learn how Cocoa error parameters are converted to Swift throwing methods.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>CocoaエラーパラメータがSwiftスローメソッドに変換される方法を学んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Learn how Swift represents imported C structures and unions, including types with bitfields and unnamed fields.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>SwiftがインポートされたC構造体と共用体を表す方法を、ビットフィールドおよび無名フィールドを持つ型を含めて、学びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Learn how functions and methods that take a completion handler are converted to Swift asynchronous functions.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>完了ハンドラをとる関数およびメソッドがどのようにSwift非同期関数へと変換されるかを学んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Learn how imported Objective-C protocol-qualified classes and metaclasses are represented.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インポートされたObjective-Cプロトコル適応のクラスおよびメタクラスが表される方法を学びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Learn how to call imported functions that are declared in a C header.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Cヘッダにおいて宣言されるインポートされた関数を呼び出す方法を学びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Learn the recommended steps to migrate your code.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのコードを移行するための推奨される段階を学んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Like the standard <bpt i="10" x="10">&lt;c10&gt;</bpt>Iterator<bpt i="11" x="11">&lt;w11&gt;</bpt>Protocol<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>, the <bpt i="12" x="12">&lt;c12&gt;</bpt>Async<bpt i="13" x="13">&lt;w13&gt;</bpt>Iterator<bpt i="14" x="14">&lt;w14&gt;</bpt>Protocol<ept i="14">&lt;/w14&gt;</ept><ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> defines a single <bpt i="15" x="15">&lt;c15&gt;</bpt>next()<ept i="15">&lt;/c15&gt;</ept> method to produce elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>標準的な<bpt i="10" x="10">&lt;c10&gt;</bpt>Iterator<bpt i="11" x="11">&lt;w11&gt;</bpt>Protocol<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>のように、<bpt i="12" x="12">&lt;c12&gt;</bpt>Async<bpt i="13" x="13">&lt;w13&gt;</bpt>Iterator<bpt i="14" x="14">&lt;w14&gt;</bpt>Protocol<ept i="14">&lt;/w14&gt;</ept><ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>はただ１つの<bpt i="15" x="15">&lt;c15&gt;</bpt>next()<ept i="15">&lt;/c15&gt;</ept>メソッドだけを定義して要素それらを生み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Likewise, if <bpt i="2" x="2">&lt;c2&gt;</bpt>distance &lt; 0<ept i="2">&lt;/c2&gt;</ept>, a limit that is greater than <bpt i="3" x="3">&lt;c3&gt;</bpt>i<ept i="3">&lt;/c3&gt;</ept> has no effect.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同様に、<bpt i="2" x="2">&lt;c2&gt;</bpt>distance &lt; 0<ept i="2">&lt;/c2&gt;</ept>ならば、<bpt i="3" x="3">&lt;c3&gt;</bpt>i<ept i="3">&lt;/c3&gt;</ept>より大きい限度は効果を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Likewise, if <bpt i="2" x="2">&lt;c2&gt;</bpt>n &lt; 0<ept i="2">&lt;/c2&gt;</ept>, a limit that is greater than <bpt i="3" x="3">&lt;c3&gt;</bpt>i<ept i="3">&lt;/c3&gt;</ept> has no effect.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同様に、<bpt i="2" x="2">&lt;c2&gt;</bpt>n &lt; 0<ept i="2">&lt;/c2&gt;</ept>ならば、<bpt i="3" x="3">&lt;c3&gt;</bpt>i<ept i="3">&lt;/c3&gt;</ept>より大きい限度は効果を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Likewise, if <bpt i="3" x="3">&lt;c3&gt;</bpt>distance &lt; 0<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>limit<ept i="4">&lt;/c4&gt;</ept> has no effect if it is greater than <bpt i="5" x="5">&lt;c5&gt;</bpt>i<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同様に、<bpt i="3" x="3">&lt;c3&gt;</bpt>distance &lt; 0<ept i="3">&lt;/c3&gt;</ept>ならば、<bpt i="4" x="4">&lt;c4&gt;</bpt>limit<ept i="4">&lt;/c4&gt;</ept>はそれが<bpt i="5" x="5">&lt;c5&gt;</bpt>i<ept i="5">&lt;/c5&gt;</ept>より大きいならば効果を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Likewise, if <bpt i="3" x="3">&lt;c3&gt;</bpt>distance &lt; 0<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>limit<ept i="4">&lt;/c4&gt;</ept> should be less than <bpt i="5" x="5">&lt;c5&gt;</bpt>i<ept i="5">&lt;/c5&gt;</ept> to have any effect.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同様に、<bpt i="3" x="3">&lt;c3&gt;</bpt>distance &lt; 0<ept i="3">&lt;/c3&gt;</ept>ならば、<bpt i="4" x="4">&lt;c4&gt;</bpt>limit<ept i="4">&lt;/c4&gt;</ept>が何らかの効果を持つには<bpt i="5" x="5">&lt;c5&gt;</bpt>i<ept i="5">&lt;/c5&gt;</ept>より少なくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Likewise, if you pass a zero-length collection as the <bpt i="0" x="0">&lt;c0&gt;</bpt>new<bpt i="1" x="1">&lt;w1&gt;</bpt>Elements<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> parameter, this method removes the elements in the given subrange without replacement.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同様に、あなたがゼロ長コレクションを<bpt i="0" x="0">&lt;c0&gt;</bpt>new<bpt i="1" x="1">&lt;w1&gt;</bpt>Elements<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>パラメータとして渡すならば、このメソッドは与えられた下位範囲の中の要素を置き換えることなく削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Local changes to model types like <bpt i="0" x="0">&lt;c0&gt;</bpt>Pen<bpt i="1" x="1">&lt;w1&gt;</bpt>Pal<bpt i="2" x="2">&lt;w2&gt;</bpt>Record<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> are useful.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Pen<bpt i="1" x="1">&lt;w1&gt;</bpt>Pal<bpt i="2" x="2">&lt;w2&gt;</bpt>Record<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のようなモデル型に対するローカルな変更は、役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Long-term storage of <bpt i="0" x="0">&lt;c0&gt;</bpt>Array<bpt i="1" x="1">&lt;w1&gt;</bpt>Slice<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instances is discouraged.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Array<bpt i="1" x="1">&lt;w1&gt;</bpt>Slice<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスの長期ストレージは推奨されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Long-term storage of a slice may therefore prolong the lifetime of elements that are no longer otherwise accessible, which can appear to be memory and object leakage.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるスライスの長期ストレージは、もはやそれ以外ではアクセス可能ではない要素の寿命を延長し、それはメモリとオブジェクトの漏洩であるように見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lowercase characters change when converted to uppercase, but not when converted to lowercase.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ローワーケース文字は、アッパーケースへ変換される時は変化します、しかしローワーケースに変換される時はそうではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>MLShaped<bpt i="0" x="0">&lt;w0&gt;</bpt>Array<bpt i="1" x="1">&lt;w1&gt;</bpt>Protocol Implementations <ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>MLShaped<bpt i="0" x="0">&lt;w0&gt;</bpt>Array<bpt i="1" x="1">&lt;w1&gt;</bpt>プロトコル実装<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Macros are imported when they use literals for string, floating-point, or integer values, or use operators like <bpt i="1" x="1">&lt;c1&gt;</bpt>+<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>-<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>&gt;<ept i="3">&lt;/c3&gt;</ept>, and <bpt i="4" x="4">&lt;c4&gt;</bpt>==<ept i="4">&lt;/c4&gt;</ept> between literals or previously defined macros.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>マクロは、それらがリテラルを文字列に対して使う、または<bpt i="1" x="1">&lt;c1&gt;</bpt>+<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>-<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>&gt;<ept i="3">&lt;/c3&gt;</ept>、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>==<ept i="4">&lt;/c4&gt;</ept>のような演算子をリテラルや以前に定義されたマクロの間で使う場合にインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Maintaining State in Your Apps</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのアプリの状態を保守する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Make your custom types easier to use by ensuring that they conform to Swift protocols.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのカスタム型を、それらがSwiftプロトコルに準拠するのを確実にすることで、より簡単に使えるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Make your data types encodable and decodable for compatibility with external representations such as JSON.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのデータ型のエンコーディングとデコーディングを外部表現、例えばJSONなどとの互換性のために行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Managed Buffers</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>バッファ管理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Managing a Shared Resource Using a Singleton</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>共有されるリソースをシングルトンを使って管理する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Manipulating Indices</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インデックスを操る</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Manual Memory Management</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>手動メモリ管理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Many individual characters, such as “é”, “김”, and “🇮🇳”, can be made up of multiple Unicode scalar values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>多くの単一の文字、例えば「é」、「김」、そして「🇮🇳」などが、複数のユニコードスカラー値から構成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Many other types are renamed or nested to clarify relationships.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>多くの他の型は、改名または入れ子にされて、関係がはっきりします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Many standard library types are both equatable and hashable, including strings, integers, floating-point values, Boolean values, and collections of equatable and hashable types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>多くの標準ライブラリ型は、文字列、整数、浮動点小数値、ブール値、そしてequatableとhashable型のコレクション型を含めて、equatableとhashableの両方です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Many types in the standard library already conform to the <bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>標準ライブラリの多くの型はすでに<bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>プロトコルに準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Many types in the standard library conform to <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>: Strings, integers, floating-point and Boolean values, and even sets are hashable by default.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>標準ライブラリの中の多くの型は<bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>に準拠します：様々な文字列、整数、浮動小数点およびブール値、そして様々な集合さえも、初期状態でハッシュ可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Many value types in Swift bridge to Objective-C counterparts, like <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftでの多くの値型は、Objective-Cの相当物へとブリッジします、<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>や<bpt i="3" x="3">&lt;c3&gt;</bpt>Int<ept i="3">&lt;/c3&gt;</ept>のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Mark properties that you want to observe through key-value observing with both the <bpt i="0" x="0">&lt;c0&gt;</bpt>@objc<ept i="0">&lt;/c0&gt;</ept> attribute and the <bpt i="1" x="1">&lt;c1&gt;</bpt>dynamic<ept i="1">&lt;/c1&gt;</ept> modifier.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがキー値監視を通して監視したいプロパティを<bpt i="0" x="0">&lt;c0&gt;</bpt>@objc<ept i="0">&lt;/c0&gt;</ept>属性と<bpt i="1" x="1">&lt;c1&gt;</bpt>dynamic<ept i="1">&lt;/c1&gt;</ept>修飾子の両方で印してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Masked Arithmetic</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>隠された算術</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Memory Access</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>メモリアクセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Merges the given dictionary into this dictionary, using a combining closure to determine the value for any duplicate keys.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた辞書をこの辞書へと結合します、結合用のクロージャを使って何らかの重複キーに対して値を決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Merges the key-value pairs in the given sequence into the dictionary, using a combining closure to determine the value for any duplicate keys.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたシーケンスの中のキー値ペアをこの辞書へと結合します、結合用のクロージャを使って何らかの重複キーに対して値を決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Methods and properties that are marked with the <bpt i="2" x="2">&lt;c2&gt;</bpt>internal<ept i="2">&lt;/c2&gt;</ept> modifier and declared within a class that inherits from an Objective-C class are accessible to the Objective-C runtime.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>internal<ept i="2">&lt;/c2&gt;</ept>修飾子で印されたそしてObjective-Cクラスから継承するクラス内部で宣言されたメソッドとプロパティは、Objective-Cランタイムからアクセス可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Methods that return another <bpt i="0" x="0">&lt;c0&gt;</bpt>Async<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> return a type specific to the method’s semantics.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>もう１つの<bpt i="0" x="0">&lt;c0&gt;</bpt>Async<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を返すメソッドそれらは、メソッドのもつ意味論に特有のひとつの型を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Methods whose completion handlers populate a <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>NSError<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> pointer parameter also become throwing methods in Swift, as described in <bpt i="2" x="2">&lt;a2&gt;</bpt>About Imported Cocoa Error Parameters<ept i="2">&lt;/a2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それの持つ完了ハンドラに<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>NSError<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>ポインタパラメータが入っているメソッドはまた、Swiftではスローするメソッドになります、<bpt i="2" x="2">&lt;a2&gt;</bpt>インポートされるCocoaエラーパラメータについて<ept i="2">&lt;/a2&gt;</ept>で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Methods whose completion handlers take multiple arguments become methods that return a tuple.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それの完了ハンドラが複数の引数をとるメソッドは、あるタプルを返すメソッドになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Migrating Your Objective-C Code to Swift</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのObjective-Cコードのスウィフトへの移行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Modifying Copies of Arrays</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列のコピーを修正する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Moreover, Swift structures can adopt protocols to gain behavior through default implementations.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その上さらに、Swift構造体はプロトコルを採用することで、省略時の実装を通して挙動を獲得できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Moreover, a collection’s indices form a finite range of the positions of the collection’s elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その上、コレクションのインデックスは、コレクションの要素の位置からなる有限の範囲を形成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Moreover, inequality is the inverse of equality, so any custom implementation of the <bpt i="0" x="0">&lt;c0&gt;</bpt>!=<ept i="0">&lt;/c0&gt;</ept> operator must guarantee that <bpt i="1" x="1">&lt;c1&gt;</bpt>a != b<ept i="1">&lt;/c1&gt;</ept> implies <bpt i="2" x="2">&lt;c2&gt;</bpt>!(a == b)<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その上に、不等性は同等性の逆です、それで<bpt i="0" x="0">&lt;c0&gt;</bpt>!=<ept i="0">&lt;/c0&gt;</ept>演算子のあらゆるあつらえの実装は、<bpt i="1" x="1">&lt;c1&gt;</bpt>a != b<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>!(a == b)<ept i="2">&lt;/c2&gt;</ept>を意味することを保証しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Most <bpt i="0" x="0">&lt;c0&gt;</bpt>String<bpt i="1" x="1">&lt;w1&gt;</bpt>Interpolation<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> types will store information about the literals and interpolations appended to them in one or more properties.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ほとんどの<bpt i="0" x="0">&lt;c0&gt;</bpt>String<bpt i="1" x="1">&lt;w1&gt;</bpt>Interpolation<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型は、それらに加えられたリテラルと補間についての情報を１つ以上のプロパティにおいて格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Most basic types in the Swift standard library conform to <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swift標準ライブラリの基本的な型のほとんどは<bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Most collections in the standard library use <bpt i="2" x="2">&lt;c2&gt;</bpt>Indexing<bpt i="3" x="3">&lt;w3&gt;</bpt>Iterator<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> as their iterator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>標準ライブラリの中のほとんどのコレクションは、<bpt i="2" x="2">&lt;c2&gt;</bpt>Indexing<bpt i="3" x="3">&lt;w3&gt;</bpt>Iterator<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>をそれらのイテレータとして使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Most operations with a NaN operand produce a NaN result.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>NaN演算数を使うほとんどの演算は、結果NaNを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Multiple copies of an array share the same storage until you modify one of the copies.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある配列の複数のコピーは、あなたがコピーの１つを修正するまでは、同じストレージを共有します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Multiplies two values and produces their product, rounding to a representable value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの値を乗算してそれらの積を生成します、表現可能な値へ丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Multiplies two values and produces their product.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの値を乗算してそれらの積を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Multiplies two values and stores the result in the left-hand-side variable, rounding to a representable value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの値を乗算して、結果を左手側の変数に格納します、表現可能な値へ丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Multiplies two values and stores the result in the left-hand-side variable, wrapping any overflow.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの値を乗算して結果を左手側の変数に格納します、あらゆるオーバーフローをラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Multiplies two values and stores the result in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの値を乗算して、結果を左手側の変数に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Must be finite.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>有限でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Must never be called, since this collection is always empty.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>決して呼ばないでください、このコレクションは常に空であるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>NaN (“not a number”)</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>NaN（「非数」）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>NaN is not equal to any value, including itself.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>NaNは、それ自身を含めてあらゆる値と等しくありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>NaN propagates through many arithmetic operations.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>NaNは、いくつもの算術演算をずっと伝播していきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>NaN values compare not equal to every value, including themselves.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>NaNは、それら自身を含めてあらゆる値に対して等しくないと比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Negation</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>負にする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Negative values are returned in two’s complement representation, regardless of the type’s underlying implementation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>負の値が、２の補数表現において返されます、その型のもつ基礎となる実装に関係なく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Neither the <bpt i="0" x="0">&lt;c0&gt;</bpt>first<bpt i="1" x="1">&lt;w1&gt;</bpt>Half<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> nor <bpt i="2" x="2">&lt;c2&gt;</bpt>second<bpt i="3" x="3">&lt;w3&gt;</bpt>Half<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> slices allocate any new storage of their own.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>first<bpt i="1" x="1">&lt;w1&gt;</bpt>Half<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>および<bpt i="2" x="2">&lt;c2&gt;</bpt>second<bpt i="3" x="3">&lt;w3&gt;</bpt>Half<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>スライスのどちらも、なんらそれら独自の新規ストレージを割り当てません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Never call <bpt i="0" x="0">&lt;c0&gt;</bpt>finalize()<ept i="0">&lt;/c0&gt;</ept> on <bpt i="1" x="1">&lt;c1&gt;</bpt>hasher<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>finalize()<ept i="0">&lt;/c0&gt;</ept>を<bpt i="1" x="1">&lt;c1&gt;</bpt>hasher<ept i="1">&lt;/c1&gt;</ept>上で決して呼び出さないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Never resuming leaves the task in a suspended state indefinitely, and leaks any associated resources.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>再開することは、そのタスクを決して曖昧に中断状態のままにしておきません、そしていかなる関連したリソースも漏洩しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Next, implement the <bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept> operator function, the requirement inherited from the <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次に、<bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept>演算子関数、<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>プロトコルから継承される要件を実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Next, the observations in Celsius are converted to Fahrenheit:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次に、摂氏での観測は華氏に変換されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>No further bridging is required when accessing elements of the <bpt i="5" x="5">&lt;c5&gt;</bpt>Array<ept i="5">&lt;/c5&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>さらなるブリッジは<bpt i="5" x="5">&lt;c5&gt;</bpt>Array<ept i="5">&lt;/c5&gt;</ept>インスタンスの要素にアクセスするとき全く必要とされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>None</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>なし</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Normally, you don’t need to be aware of the difference between concrete and existential metatypes, but calling <bpt i="0" x="0">&lt;c0&gt;</bpt>type(of:)<ept i="0">&lt;/c0&gt;</ept> can yield unexpected results in a generic context with a type parameter bound to a protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>通常、あなたは具象と存在のメタタイプの間の違いを意識する必要はありません、しかし<bpt i="0" x="0">&lt;c0&gt;</bpt>type(of:)<ept i="0">&lt;/c0&gt;</ept>を呼び出すことは、あるプロトコルに束縛された型パラメータを伴うある総称体の文脈において予期しない結果を生み出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>注意</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note Renamed Reference Types</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>改名される参照型に注意してください</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that <bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Hashable<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> does not guarantee that it preserves the hash encoding of wrapped values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>注意してください、<bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Hashable<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、それがそのラップされた値のハッシュ符号化を保全することを保証しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that <bpt i="0" x="0">&lt;c0&gt;</bpt>Float80<bpt i="1" x="1">&lt;w1&gt;</bpt>.significand<bpt i="2" x="2">&lt;w2&gt;</bpt>Bit<bpt i="3" x="3">&lt;w3&gt;</bpt>Count<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is 63, even though 64 bits are used to store the significand in the memory representation of a <bpt i="4" x="4">&lt;c4&gt;</bpt>Float80<ept i="4">&lt;/c4&gt;</ept> (unlike other floating-point types, <bpt i="5" x="5">&lt;c5&gt;</bpt>Float80<ept i="5">&lt;/c5&gt;</ept> explicitly stores the leading integral significand bit, but the <bpt i="6" x="6">&lt;c6&gt;</bpt>Binary<bpt i="7" x="7">&lt;w7&gt;</bpt>Floating<bpt i="8" x="8">&lt;w8&gt;</bpt>Point<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> APIs provide an abstraction so that users don’t need to be aware of this detail).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Float80<bpt i="1" x="1">&lt;w1&gt;</bpt>.significand<bpt i="2" x="2">&lt;w2&gt;</bpt>Bit<bpt i="3" x="3">&lt;w3&gt;</bpt>Count<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は63であることに注意してください、64ビットが使用されて仮数を<bpt i="4" x="4">&lt;c4&gt;</bpt>Float80<ept i="4">&lt;/c4&gt;</ept>メモリ表現に格納するとしてもです（他の浮動小数点型と違い、<bpt i="5" x="5">&lt;c5&gt;</bpt>Float80<ept i="5">&lt;/c5&gt;</ept>は明示的に先頭整数仮数ビットを格納します、しかし<bpt i="6" x="6">&lt;c6&gt;</bpt>Binary<bpt i="7" x="7">&lt;w7&gt;</bpt>Floating<bpt i="8" x="8">&lt;w8&gt;</bpt>Point<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>APIはある抽象化を提供します、それでユーザはこの詳細に通じている必要はありません）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that <bpt i="10" x="10">&lt;c10&gt;</bpt>q<ept i="10">&lt;/c10&gt;</ept> is <bpt i="11" x="11">&lt;e11&gt;</bpt>not<ept i="11">&lt;/e11&gt;</ept> <bpt i="12" x="12">&lt;c12&gt;</bpt>x / y<ept i="12">&lt;/c12&gt;</ept> computed in floating-point arithmetic, and that <bpt i="13" x="13">&lt;c13&gt;</bpt>q<ept i="13">&lt;/c13&gt;</ept> may not be representable in any available integer type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="10" x="10">&lt;c10&gt;</bpt>q<ept i="10">&lt;/c10&gt;</ept>が浮動小数点算術で計算される<bpt i="12" x="12">&lt;c12&gt;</bpt>x / y<ept i="12">&lt;/c12&gt;</ept>では<bpt i="11" x="11">&lt;e11&gt;</bpt>ない<ept i="11">&lt;/e11&gt;</ept>こと、そして<bpt i="13" x="13">&lt;c13&gt;</bpt>q<ept i="13">&lt;/c13&gt;</ept>は何らかの利用可能な整数型において表現可能でないかもしれないことに注意してください</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that in this example, <bpt i="0" x="0">&lt;c0&gt;</bpt>image<bpt i="1" x="1">&lt;w1&gt;</bpt>Paths<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is subscripted using a dictionary index.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例において、<bpt i="0" x="0">&lt;c0&gt;</bpt>image<bpt i="1" x="1">&lt;w1&gt;</bpt>Paths<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が辞書インデックスを使って添え字をすることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that some elements in the <bpt i="0" x="0">&lt;c0&gt;</bpt>temperature<bpt i="1" x="1">&lt;w1&gt;</bpt>Data <ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> array are not valid numbers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>temperature<bpt i="1" x="1">&lt;w1&gt;</bpt>Data <ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>配列の幾つかの要素は有効な数字ではないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that the <bpt i="0" x="0">&lt;c0&gt;</bpt>&gt;<ept i="0">&lt;/c0&gt;</ept> operator provided by the standard library is used in this example, not the <bpt i="1" x="1">&lt;c1&gt;</bpt>&lt;<ept i="1">&lt;/c1&gt;</ept> operator implemented above.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>標準ライブラリによって提供される<bpt i="0" x="0">&lt;c0&gt;</bpt>&gt;<ept i="0">&lt;/c0&gt;</ept>演算子がこの例で使われることに注意してください、上で実装される<bpt i="1" x="1">&lt;c1&gt;</bpt>&lt;<ept i="1">&lt;/c1&gt;</ept>演算子ではなしに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that the <bpt i="0" x="0">&lt;c0&gt;</bpt>inout<ept i="0">&lt;/c0&gt;</ept> exclusivity rules mean that, like any other <bpt i="1" x="1">&lt;c1&gt;</bpt>inout<ept i="1">&lt;/c1&gt;</ept> argument, <bpt i="2" x="2">&lt;c2&gt;</bpt>value<ept i="2">&lt;/c2&gt;</ept> cannot be directly accessed by other code for the duration of <bpt i="3" x="3">&lt;c3&gt;</bpt>body<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>inout<ept i="0">&lt;/c0&gt;</ept>排他規則が意味することに注意してください、何か他の<bpt i="1" x="1">&lt;c1&gt;</bpt>inout<ept i="1">&lt;/c1&gt;</ept>と同様に、<bpt i="2" x="2">&lt;c2&gt;</bpt>value<ept i="2">&lt;/c2&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>body<ept i="3">&lt;/c3&gt;</ept>の継続期間には他のコードによって直接にアクセス可能ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that the value may not be preserved, particularly when converting between signed to unsigned integer types or when the destination type has a smaller bit width than the source type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>注意すべきはその値が保たれないかもしれないことです、とりわけ符号付きから符号なし整数型への間の変換の場合、または行先の型が元の型より小さなビット幅を持つ場合には。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note: transacting upon the remaining count is only valid when then calls to yield are mutually exclusive.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>注意：残りの総数に関して取引（トランザクト）をすることは、生み出すためのその後の呼び出しそれらが互いに排他的である場合に有効であるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice that the <bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>remove<bpt i="2" x="2">&lt;w2&gt;</bpt>Item(at:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/s0&gt;</ept> method is imported by Swift with a <bpt i="3" x="3">&lt;c3&gt;</bpt>Void<ept i="3">&lt;/c3&gt;</ept> return type, no error parameter, and a <bpt i="4" x="4">&lt;c4&gt;</bpt>throws<ept i="4">&lt;/c4&gt;</ept> declaration.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;s0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>remove<bpt i="2" x="2">&lt;w2&gt;</bpt>Item(at:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/s0&gt;</ept>メソッドが、スウィフトによって<bpt i="3" x="3">&lt;c3&gt;</bpt>Void<ept i="3">&lt;/c3&gt;</ept>の戻り型で、errorパラメーターなしで、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>throws<ept i="4">&lt;/c4&gt;</ept>宣言でインポートされることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notify objects about changes to the properties of other objects.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>他のオブジェクトのプロパティに対する変更についてオブジェクトに通知します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Now suppose you have an array of addresses that you need to check for a particular address.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>今あなたがいくらかの住所からなる配列、あなたがある特定の住所を確認する必要があるものを持つと仮定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Now that <bpt i="0" x="0">&lt;c0&gt;</bpt>Date<ept i="0">&lt;/c0&gt;</ept> conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>, you can compare instances of the type with any of the relational operators.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>今や<bpt i="0" x="0">&lt;c0&gt;</bpt>Date<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>に準拠します、あなたはこの型のインスタンスを関係演算子のどれででも比較できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Now that <bpt i="0" x="0">&lt;c0&gt;</bpt>Grid<bpt i="1" x="1">&lt;w1&gt;</bpt>Point<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conforms to the <bpt i="2" x="2">&lt;c2&gt;</bpt>Hashable<ept i="2">&lt;/c2&gt;</ept> protocol, you can create a set of previously tapped grid points.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Grid<bpt i="1" x="1">&lt;w1&gt;</bpt>Point<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Hashable<ept i="2">&lt;/c2&gt;</ept>プロトコルに準拠する今、あなたは以前にタップされた格子点の集合を作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Now that the <bpt i="0" x="0">&lt;c0&gt;</bpt>shorter<bpt i="1" x="1">&lt;w1&gt;</bpt>Indices<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> array holds the indices of the shorter names in the <bpt i="2" x="2">&lt;c2&gt;</bpt>names<ept i="2">&lt;/c2&gt;</ept> set, you can use those indices to access elements in the set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>現在、<bpt i="0" x="0">&lt;c0&gt;</bpt>shorter<bpt i="1" x="1">&lt;w1&gt;</bpt>Indices<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>配列は<bpt i="2" x="2">&lt;c2&gt;</bpt>names<ept i="2">&lt;/c2&gt;</ept>集合の中のより短い名前のインデックスを保持します、あなたはそれらのインデックスを使ってこの集合の要素にアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Numbers and Basic Values</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>数と基本的な値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Numbers, Data, and Basic Values</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>数、データ、そして基本的な値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Numeric Protocols</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>数に関するプロトコル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Numeric Values</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>数値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Objective-C APIs</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-C API</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Objective-C and C Code Customization</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-CとCコードのカスタム化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Objective-C classes qualified by one or more protocols, like the one in the example below, are imported by Swift as protocol composition types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下の例でのもののような、１つ以上のプロトコルによる基準を満たすObjective-Cクラスは、スウィフトによってプロトコル合成型としてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Objective-C exception handling uses the <bpt i="0" x="0">&lt;c0&gt;</bpt>@try<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>@catch<ept i="1">&lt;/c1&gt;</ept>, and <bpt i="2" x="2">&lt;c2&gt;</bpt>@throw<ept i="2">&lt;/c2&gt;</ept> syntax to indicate unrecoverable programmer errors.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-C例外処理は、<bpt i="0" x="0">&lt;c0&gt;</bpt>@try<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>@catch<ept i="1">&lt;/c1&gt;</ept>、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>@throw<ept i="2">&lt;/c2&gt;</ept>構文を使って回復不可能なプログラマエラーを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Objective-C reference type</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-C参照型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Objective-C type declarations that use lightweight generic parameterization are imported by Swift with information about the type of their contents preserved.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>軽量総称体パラメーター化を使うObjective-C宣言は、それらの保管される内容についての情報を使ってスウィフトによってインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Objects that are set up to use key-value observing—such as <bpt i="0" x="0">&lt;c0&gt;</bpt>observed<ept i="0">&lt;/c0&gt;</ept> above—notify their observers about property changes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キー値監視を使うように設定されるそれらオブジェクト — 例えば上の<bpt i="0" x="0">&lt;c0&gt;</bpt>observed<ept i="0">&lt;/c0&gt;</ept> — は、それらのオブザーバにプロパティの変化について通知します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Objects with a concrete type of <bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Object<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> maintain a specific dynamic type and can be cast to that type using one of the type-cast operators (<bpt i="2" x="2">&lt;c2&gt;</bpt>as<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>as?<ept i="3">&lt;/c3&gt;</ept>, or <bpt i="4" x="4">&lt;c4&gt;</bpt>as!<ept i="4">&lt;/c4&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>具象型として<bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Object<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を持つオブジェクトは、特定の動的型を保守して、その型へと型キャスト演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>as<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>as?<ept i="3">&lt;/c3&gt;</ept>。または<bpt i="4" x="4">&lt;c4&gt;</bpt>as!<ept i="4">&lt;/c4&gt;</ept>）の１つを使ってキャストされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Offsets the given index by the specified distance, or so that it equals the given limiting index.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたインデックスをこの指定された隔たりで補います、またはそれでそれは与えられた限界インデックスと等しくなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Offsets the given index by the specified distance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたインデックスを指定された間隔で補います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Often, the optimizer can eliminate bounds checks within an array algorithm, but when that fails, invoking the same algorithm on the buffer pointer passed into your closure lets you trade safety for speed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>しばしば、最適化機能は配列アルゴリズム内部で境界検査を省くことができます、しかしそれが失敗する時、同じアルゴリズムをあなたのクロージャへ渡されるバッファポインタ上で発動することは、あなたに安全をスピードと交換させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Often, the optimizer can eliminate bounds- and uniqueness-checks within an algorithm, but when that fails, invoking the same algorithm on <bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept>\ ’s argument lets you trade safety for speed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>しばしば、最適化機能はアルゴリズム内部で境界および固有さ検査を省くことができます、しかしそれが失敗する時、同じアルゴリズムを<bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept>の引数上で発動することは、あなたに安全をスピードと交換させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Omits a specified number of elements from the base asynchronous sequence, then passes through all remaining elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された数の要素を基底非同期シーケンスから除きます、それから全ての残りの要素をずっと渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Omits elements from the base asynchronous sequence until a given closure returns false, after which it passes through all remaining elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要素を基底非同期シーケンスから、ある与えられたクロージャがfalseを返すまで省きます、それの後それは全ての残りの要素をずっと渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Omits elements from the base sequence until a given error-throwing closure returns false, after which it passes through all remaining elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要素を基底シーケンスから、ある与えられたエラースロークロージャがfalseを返すまで省きます、それの後それは全ての残りの要素をずっと渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Omitting the <bpt i="2" x="2">&lt;c2&gt;</bpt>options<ept i="2">&lt;/c2&gt;</ept> parameter forgoes storing the new and old property values, which causes the <bpt i="3" x="3">&lt;c3&gt;</bpt>old<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt>new<bpt i="6" x="6">&lt;w6&gt;</bpt>Value<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> properties to be <bpt i="7" x="7">&lt;c7&gt;</bpt>nil<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>options<ept i="2">&lt;/c2&gt;</ept>パラメータを省略することは、新しいそして古いプロパティ値を格納することをやめます、それは<bpt i="3" x="3">&lt;c3&gt;</bpt>old<bpt i="4" x="4">&lt;w4&gt;</bpt>Value<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>と<bpt i="5" x="5">&lt;c5&gt;</bpt>new<bpt i="6" x="6">&lt;w6&gt;</bpt>Value<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>プロパティが<bpt i="7" x="7">&lt;c7&gt;</bpt>nil<ept i="7">&lt;/c7&gt;</ept>になる原因となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>On 32-bit platforms, <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept> is the same size as <bpt i="1" x="1">&lt;c1&gt;</bpt>Int32<ept i="1">&lt;/c1&gt;</ept>, and on 64-bit platforms, <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept> is the same size as <bpt i="3" x="3">&lt;c3&gt;</bpt>Int64<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>32ビットプラットホーム上では、<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>Int32<ept i="1">&lt;/c1&gt;</ept>と同じ大きさです、そして64ビットプラットホーム上では、<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>Int64<ept i="3">&lt;/c3&gt;</ept>と同じ大きさです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>On This Page</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この項には</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>On a big-endian platform, for any integer <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>x == x<bpt i="2" x="2">&lt;w2&gt;</bpt>.big<bpt i="3" x="3">&lt;w3&gt;</bpt>Endian<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ビッグエンディアンプラットホーム上で、何らかの整数<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="1" x="1">&lt;c1&gt;</bpt>x == x<bpt i="2" x="2">&lt;w2&gt;</bpt>.big<bpt i="3" x="3">&lt;w3&gt;</bpt>Endian<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>On a little-endian platform, for any integer <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>x == x<bpt i="2" x="2">&lt;w2&gt;</bpt>.little<bpt i="3" x="3">&lt;w3&gt;</bpt>Endian<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>リトルエンディアンプラットホーム上で、何らかの整数<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>に対して、<bpt i="1" x="1">&lt;c1&gt;</bpt>x == x<bpt i="2" x="2">&lt;w2&gt;</bpt>.little<bpt i="3" x="3">&lt;w3&gt;</bpt>Endian<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>On i386 and x86_64, <bpt i="0" x="0">&lt;c0&gt;</bpt>Float80<ept i="0">&lt;/c0&gt;</ept> has a number of non-canonical encodings.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>i386およびx86_64では、<bpt i="0" x="0">&lt;c0&gt;</bpt>Float80<ept i="0">&lt;/c0&gt;</ept>は非正準エンコーディングのある数を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>On platforms that flush subnormal numbers to zero (such as armv7 with the default floating-point environment), Swift interprets subnormal <bpt i="0" x="0">&lt;c0&gt;</bpt>Float<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept> values as non-canonical zeros.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>非正規化数をゼロへとフラッシュするプラットホーム（たとえば省略時の浮動小数点環境でのarmv7）上では、Swiftは非正規化数<bpt i="0" x="0">&lt;c0&gt;</bpt>Float<ept i="0">&lt;/c0&gt;</ept>および<bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept>値を非正準のゼロとして解釈します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>On platforms that fully support IEEE 754, every <bpt i="2" x="2">&lt;c2&gt;</bpt>Float<ept i="2">&lt;/c2&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt>Double<ept i="3">&lt;/c3&gt;</ept> value is canonical, but non-canonical values can exist on other platforms or for other types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>完全にIEEE 754をサポートするプラットホーム上では、あらゆる<bpt i="2" x="2">&lt;c2&gt;</bpt>Float<ept i="2">&lt;/c2&gt;</ept>または<bpt i="3" x="3">&lt;c3&gt;</bpt>Double<ept i="3">&lt;/c3&gt;</ept>値は正準です、しかし非正準値は他のプラットホーム上でまたは他の型に対して存在できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>On removal, this method invalidates all indices with respect to the dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>除去において、このメソッドはこの辞書に関するすべてのインデックスを無効にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Once <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> has been returned, all subsequent calls return <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>一旦<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>が返されるならば、すべての続いて起こる呼び出しは<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Once again, use pattern matching to conditionally catch errors.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>再び、パターンマッチを条件付きでエラーを捕まえるのに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Once the predicate returns <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept> it will not be called again.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>いったん述部が<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>を返すならそれは再び呼び出されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>One of the values to multiply before adding to this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値に加えられる前に掛け合わされる値のうちの１つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Only the <bpt i="1" x="1">&lt;c1&gt;</bpt>Optional<ept i="1">&lt;/c1&gt;</ept> type conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt>Expressible<bpt i="3" x="3">&lt;w3&gt;</bpt>By<bpt i="4" x="4">&lt;w4&gt;</bpt>Nil<bpt i="5" x="5">&lt;w5&gt;</bpt>Literal<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Optional<ept i="1">&lt;/c1&gt;</ept>型だけが<bpt i="2" x="2">&lt;c2&gt;</bpt>Expressible<bpt i="3" x="3">&lt;w3&gt;</bpt>By<bpt i="4" x="4">&lt;w4&gt;</bpt>Nil<bpt i="5" x="5">&lt;w5&gt;</bpt>Literal<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Operations on types conforming to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Floating<bpt i="1" x="1">&lt;w1&gt;</bpt>Point<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol should support this behavior, but they might also support other options.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Floating<bpt i="1" x="1">&lt;w1&gt;</bpt>Point<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する型での演算はこの挙動をサポートします、しかしそれらはまた他の選択肢もサポートするかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Operations with infinite values follow real arithmetic as much as possible: Adding or subtracting a finite value, or multiplying or dividing infinity by a nonzero finite value, results in infinity.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>無限大値を伴う演算は、実数算術にできうる限り従います：ある無限大値を加算や減算すること、または非ゼロの有限値によって無限に乗算や除算することは、無限大の結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Operator</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Operator Functions</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>演算子関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Optimizations are sometimes applied that can reduce the amount of copying.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最適化は時折適用されて、コピー回数を減らすことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Order Dependent Operations on Dictionary</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書での順序依存演算</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Other than these signaling operations, a signaling NaN behaves in the same manner as a quiet NaN.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これらのシグナル演算の他は、シグナルNaNはクワイエットNaNと同じ流儀で振舞います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Otherwise, <bpt i="3" x="3">&lt;c3&gt;</bpt>next()<ept i="3">&lt;/c3&gt;</ept> evaluates the result with the <bpt i="4" x="4">&lt;c4&gt;</bpt>predicate<ept i="4">&lt;/c4&gt;</ept> closure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そうでなければ、<bpt i="3" x="3">&lt;c3&gt;</bpt>next()<ept i="3">&lt;/c3&gt;</ept>は結果を<bpt i="4" x="4">&lt;c4&gt;</bpt>predicate<ept i="4">&lt;/c4&gt;</ept>クロージャで評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Otherwise, <bpt i="3" x="3">&lt;c3&gt;</bpt>next()<ept i="3">&lt;/c3&gt;</ept> returns the result of calling the transforming closure on the received element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そうでなければ、<bpt i="3" x="3">&lt;c3&gt;</bpt>next()<ept i="3">&lt;/c3&gt;</ept>は変換クロージャをその受け取った要素上で呼び出す結果を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Otherwise, <bpt i="4" x="4">&lt;c4&gt;</bpt>next()<ept i="4">&lt;/c4&gt;</ept> calls the transforming closure on the received element, returning it if the transform returns a non-<bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そうでなければ、<bpt i="4" x="4">&lt;c4&gt;</bpt>next()<ept i="4">&lt;/c4&gt;</ept>は変換クロージャをその受け取った要素上で呼び出して、その変換が非<bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept>値を返すならばそれを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Otherwise, <bpt i="4" x="4">&lt;c4&gt;</bpt>next()<ept i="4">&lt;/c4&gt;</ept> calls the transforming closure on the received element, takes the resulting asynchronous sequence, and creates an asynchronous iterator from it.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そうでなければ、<bpt i="4" x="4">&lt;c4&gt;</bpt>next()<ept i="4">&lt;/c4&gt;</ept>は変換クロージャをその受け取った要素上で呼び出して、結果の非同期シーケンスをとり、そして非同期イテレータをそれから作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Otherwise, <bpt i="4" x="4">&lt;c4&gt;</bpt>next()<ept i="4">&lt;/c4&gt;</ept> returns the result of calling the transforming closure on the received element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そうでなければ、<bpt i="4" x="4">&lt;c4&gt;</bpt>next()<ept i="4">&lt;/c4&gt;</ept>は変換クロージャをその受け取った要素上で呼び出す結果を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Otherwise, a Unicode replacement character (<bpt i="2" x="2">&lt;c2&gt;</bpt>"\u{FFFD}"<ept i="2">&lt;/c2&gt;</ept>) is inserted for each detected error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そうでなければ、ユニコード代用文字（<bpt i="2" x="2">&lt;c2&gt;</bpt>"\u{FFFD}"<ept i="2">&lt;/c2&gt;</ept>）が各検出エラーに対して挿入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Otherwise, if no convention can be inferred, the method is left intact.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それ以外では、推論されることができる慣行がないならば、メソッドは元のままにしておかれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Otherwise, it returns <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>, ending the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そうでなければ、それは<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>を返します、そしてシーケンスを終わらせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Otherwise, iteration will stop if an encoding error is detected.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そうでなければ、反復はエンコーディングエラーが検出されるならば停止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Otherwise, the contents are encoded as alternating key-value pairs in an unkeyed container.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そうでなければ、内容は交互キー値ペアとしてキー付けされないコンテナの中にエンコードされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Overflow checking is not performed in <bpt i="0" x="0">&lt;c0&gt;</bpt>-Ounchecked<ept i="0">&lt;/c0&gt;</ept> builds.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オーバーフロー検査は、<bpt i="0" x="0">&lt;c0&gt;</bpt>-Ounchecked<ept i="0">&lt;/c0&gt;</ept>ビルドでは実行されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Overview</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>概要</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Parameters</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>パラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Parsing of the string is case insensitive.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文字列の構文解析は、大文字小文字に影響されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Pass <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> to create a signaling NaN or <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept> to create a quiet NaN.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シグナルNaNを作成するために<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>を、またはクワイエットNaNを作成するために<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>を渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Pass <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> to keep the existing capacity of the array after removing its elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>を渡すと、この配列の既存の容量をそれの要素の削除後に保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Pass <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> to stop translation when an encoding error is detected in <bpt i="1" x="1">&lt;c1&gt;</bpt>input<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>を渡すと、翻訳はエンコーディングエラーが<bpt i="1" x="1">&lt;c1&gt;</bpt>input<ept i="1">&lt;/c1&gt;</ept>において検出されるときに停止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Pass a closure as <bpt i="1" x="1">&lt;c1&gt;</bpt>combine<ept i="1">&lt;/c1&gt;</ept> that returns the value to use in the resulting dictionary: The closure can choose between the two values, combine them to produce a new value, or even throw an error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるクロージャを<bpt i="1" x="1">&lt;c1&gt;</bpt>combine<ept i="1">&lt;/c1&gt;</ept>として渡してください、それは結果の辞書において使う値を返します：そのクロージャは２つの値のどちらかを選ぶこと、それらを結合して新しい値を生成すること、またはエラーをスローすることさえ出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Pass a negative value as <bpt i="3" x="3">&lt;c3&gt;</bpt>stride<ept i="3">&lt;/c3&gt;</ept> to create a sequence from a higher start to a lower end:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>負の値を<bpt i="3" x="3">&lt;c3&gt;</bpt>stride<ept i="3">&lt;/c3&gt;</ept>として渡して、上方から開始して下方に終わるシーケンスを作成してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Pass the greater-than operator (<bpt i="1" x="1">&lt;c1&gt;</bpt>&gt;<ept i="1">&lt;/c1&gt;</ept>) operator as the predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>より大きい（<bpt i="1" x="1">&lt;c1&gt;</bpt>&gt;<ept i="1">&lt;/c1&gt;</ept>）演算子を述部として渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Passing a NaN to an operation generally results in NaN.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>NaNをある演算に渡すことは、一般的にNaNという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Passing a sequence with duplicate keys to this initializer results in a runtime error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>重複するキーを持つシーケンスをこのイニシャライザに渡すことは、実行時エラーという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Passing a sequence with no elements or an empty collection as <bpt i="0" x="0">&lt;c0&gt;</bpt>possible<bpt i="1" x="1">&lt;w1&gt;</bpt>Prefix<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> always results in <bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>１つの要素もないシーケンスまたは空のコレクションを<bpt i="0" x="0">&lt;c0&gt;</bpt>possible<bpt i="1" x="1">&lt;w1&gt;</bpt>Prefix<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として渡すことは、常に<bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>という結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Passing a value that can’t be represented in this type results in a runtime error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型において表せない値を渡すことは、実行時エラーという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Passing any other format or any additional characters as <bpt i="0" x="0">&lt;c0&gt;</bpt>text<ept i="0">&lt;/c0&gt;</ept> results in <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>何か他の形式または追加文字を<bpt i="0" x="0">&lt;c0&gt;</bpt>text<ept i="0">&lt;/c0&gt;</ept>として渡すことは、<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>の結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Passing pointers to mutable arrays of ObjC class pointers is not directly supported.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ObjCクラスポインタの可変配列へポインタを渡すことは、直接にサポートされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Passing the collection’s <bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> as the <bpt i="2" x="2">&lt;c2&gt;</bpt>start<ept i="2">&lt;/c2&gt;</ept> parameter results in an empty subsequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの<bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を<bpt i="2" x="2">&lt;c2&gt;</bpt>start<ept i="2">&lt;/c2&gt;</ept>パラメータとして渡すことは、空のシーケンスという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Passing the collection’s starting index as the <bpt i="0" x="0">&lt;c0&gt;</bpt>end<ept i="0">&lt;/c0&gt;</ept> parameter results in an empty subsequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの開始インデックスを<bpt i="0" x="0">&lt;c0&gt;</bpt>end<ept i="0">&lt;/c0&gt;</ept>パラメータとして渡すことは、空のシーケンスという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Passing the same index as both <bpt i="2" x="2">&lt;c2&gt;</bpt>i<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>j<ept i="3">&lt;/c3&gt;</ept> has no effect.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>i<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>j<ept i="3">&lt;/c3&gt;</ept>の両方と同じアンデックスを渡すことは、効果を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Pattern Matching</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>パターンマッチング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Perform arithmetic and bitwise operations or compare values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>算術およびビット単位の演算を実行します、または値を比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Perform order-dependent operations common to all collections, as implemented for <bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>すべてのコレクションに共通の順序依存演算を、<bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept>に対して実装されたように実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Performing Calculations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>計算の実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Performing Calculations with Overflow</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オーバーフローを伴う計算の実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Performing Collection Operations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクション演算の実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Performing Double-Width Calculations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２倍幅計算の実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Performing a bitwise NOT operation on 0 returns a value with every bit set to <bpt i="0" x="0">&lt;c0&gt;</bpt>1<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ビット単位のNOT演算を0に関して実行することは、すべてのビットが<bpt i="0" x="0">&lt;c0&gt;</bpt>1<ept i="0">&lt;/c0&gt;</ept>に設定された値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Performing an invalid cast triggers a runtime error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>不正なキャストを行うことは実行時エラーの引き金になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Performing truncating division with floating-point values results in a truncated integer quotient and a remainder.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>不動小数点値で切り捨て除算を実行することは、切り捨てられる整数指数と余りという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Performs a logical AND operation on two Boolean values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>論理AND（積）演算を２つのブール値で実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Performs a logical NOT operation on a Boolean value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>論理否定演算をあるブール値上で実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Performs a logical OR operation on two Boolean values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>論理OR（和）演算を２つのブール値で実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Performs a nil-coalescing operation, returning the wrapped value of an <bpt i="0" x="0">&lt;c0&gt;</bpt>Optional<ept i="0">&lt;/c0&gt;</ept> instance or a default <bpt i="1" x="1">&lt;c1&gt;</bpt>Optional<ept i="1">&lt;/c1&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>nil合体演算を実行します、ラップされた値の<bpt i="0" x="0">&lt;c0&gt;</bpt>Optional<ept i="0">&lt;/c0&gt;</ept>インスタンスまたは省略時の<bpt i="1" x="1">&lt;c1&gt;</bpt>Optional<ept i="1">&lt;/c1&gt;</ept>値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Performs a nil-coalescing operation, returning the wrapped value of an <bpt i="0" x="0">&lt;c0&gt;</bpt>Optional<ept i="0">&lt;/c0&gt;</ept> instance or a default value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>nil合体演算を実行します、ラップされた値の<bpt i="0" x="0">&lt;c0&gt;</bpt>Optional<ept i="0">&lt;/c0&gt;</ept>インスタンスまたは省略時の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Performs a traditional C-style assert with an optional message.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>随意のメッセージを持つ伝統的なC形式アサートを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Persistently unique per environment (e.g. database record keys).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>環境ごとに永続的に特有である（たとえば、データベースレコードキー）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Platform-specific classes, like <bpt i="0" x="0">&lt;c0&gt;</bpt>NSBackground<bpt i="1" x="1">&lt;w1&gt;</bpt>Activity<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>NSUser<bpt i="3" x="3">&lt;w3&gt;</bpt>Notification<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, and <bpt i="4" x="4">&lt;c4&gt;</bpt>NSXPCConnection<ept i="4">&lt;/c4&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>プラットホーム特有のクラス、<bpt i="0" x="0">&lt;c0&gt;</bpt>NSBackground<bpt i="1" x="1">&lt;w1&gt;</bpt>Activity<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>NSUser<bpt i="3" x="3">&lt;w3&gt;</bpt>Notification<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>NSXPCConnection<ept i="4">&lt;/c4&gt;</ept>のような</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Playground logging can generate, at a minimum, a structured description of any type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>プレイグラウンドログは、最低でも、あらゆる型の構造化された記述を生成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Playground logging generates a richer, more specialized description of core types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>プレイグラウンドログは、中心的な型のより豊かな、さらに特殊化された記述を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Playground logging may also be able to support specialized descriptions of other types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>プレイグラウンドログはまた、他の型の特殊化された記述のサポートが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Positive infinity compares greater than every finite value and negative infinity, while negative infinity compares less than every finite value and positive infinity.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>正の無限大はすべての有限値と負の無限大より大きいと比較されます、一方負の無限大はすべての有限値と正の無限大より小さいと比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Positive infinity.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>正の無限大</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Precondition: <bpt i="0" x="0">&lt;c0&gt;</bpt>maximum<ept i="0">&lt;/c0&gt;</ept> must compare equal to itself (i.e. cannot be NaN).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>前提条件：<bpt i="0" x="0">&lt;c0&gt;</bpt>maximum<ept i="0">&lt;/c0&gt;</ept>はそれ自身と等しいと比較されなければなりません（すなわちNaNであることはできません）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Precondition: <bpt i="0" x="0">&lt;c0&gt;</bpt>minimum<ept i="0">&lt;/c0&gt;</ept> must compare equal to itself (i.e. cannot be NaN).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>前提条件：<bpt i="0" x="0">&lt;c0&gt;</bpt>minimum<ept i="0">&lt;/c0&gt;</ept>はそれ自身と等しいと比較されなければなりません（すなわちNaNであることはできません）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Precondition: <bpt i="0" x="0">&lt;c0&gt;</bpt>next()<ept i="0">&lt;/c0&gt;</ept> has not been applied to a copy of <bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept> since the copy was made.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>前提条件：<bpt i="0" x="0">&lt;c0&gt;</bpt>next()<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept>のコピーに、そのコピーが作成されて以来まったく適用されていないこと。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Precondition: <bpt i="0" x="0">&lt;c0&gt;</bpt>position<ept i="0">&lt;/c0&gt;</ept> indicates a valid position in <bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>position != end<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>前提条件：<bpt i="0" x="0">&lt;c0&gt;</bpt>position<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept>の中の有効な位置を指し示して<bpt i="2" x="2">&lt;c2&gt;</bpt>position != end<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>であること。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Precondition: <bpt i="0" x="0">&lt;c0&gt;</bpt>position<ept i="0">&lt;/c0&gt;</ept> is a valid position in <bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>position != end<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>前提条件：<bpt i="0" x="0">&lt;c0&gt;</bpt>position<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept>の中の有効な位置であり<bpt i="2" x="2">&lt;c2&gt;</bpt>position != end<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>であること。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Precondition: <bpt i="0" x="0">&lt;c0&gt;</bpt>self != nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>前提条件：<bpt i="0" x="0">&lt;c0&gt;</bpt>self != nil<ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Precondition: The sequence must not have duplicate keys.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>前提条件：シーケンスは重複するキーを持ってはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Precondition: the pointee has been initialized with an instance of type <bpt i="0" x="0">&lt;c0&gt;</bpt>Pointee<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>前提条件：pointeeが型<bpt i="0" x="0">&lt;c0&gt;</bpt>Pointee<ept i="0">&lt;/c0&gt;</ept>のインスタンスを使って初期化されていること。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Prefer Swift Value Types to Bridged Objective-C Reference Types</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swift値型はブリッジされたObjective-C参照型より好ましい</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Prefer this method over <bpt i="0" x="0">&lt;c0&gt;</bpt>reduce(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> for efficiency when the result is a copy-on-write type, for example an <bpt i="2" x="2">&lt;c2&gt;</bpt>Array<ept i="2">&lt;/c2&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt>Dictionary<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを、効率のために<bpt i="0" x="0">&lt;c0&gt;</bpt>reduce(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>より優先してください、その結果がコピーオンライト型である場合、例えば<bpt i="2" x="2">&lt;c2&gt;</bpt>Array<ept i="2">&lt;/c2&gt;</ept>または<bpt i="3" x="3">&lt;c3&gt;</bpt>Dictionary<ept i="3">&lt;/c3&gt;</ept>に対しては。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Preserving an Array’s Geometric Growth Strategy</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列の幾何数級的増大戦略を守る</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Preventing Timing Problems When Using Closures</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>クロージャを使う場合のタイミング問題を防ぐ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Print the result using the index found in step 2 on the original <bpt i="0" x="0">&lt;c0&gt;</bpt>absences<ept i="0">&lt;/c0&gt;</ept> array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>手順２で見つけたインデックスをオリジナル<bpt i="0" x="0">&lt;c0&gt;</bpt>absences<ept i="0">&lt;/c0&gt;</ept>配列上で使って結果を出力してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Print the results using the indices found in steps 1 and 3 on the original <bpt i="0" x="0">&lt;c0&gt;</bpt>absences<ept i="0">&lt;/c0&gt;</ept> array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>手順１と手順３で見つけたインデックスをオリジナル<bpt i="0" x="0">&lt;c0&gt;</bpt>absences<ept i="0">&lt;/c0&gt;</ept>配列上で使って結果を出力してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Printing and Dumping</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>プリントとダンプ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Produces the next element in the compact map sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コンパクトマップシーケンスの中の次の要素を生じさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Produces the next element in the drop-first sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>drop-firstシーケンスの中の次の要素を生み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Produces the next element in the drop-while sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>drop-whileシーケンスの中の次の要素を生み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Produces the next element in the filter sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>フィルタシーケンスの中の次の要素を生み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Produces the next element in the flat map sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>フラットマップシーケンスの中の次の要素を生み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Produces the next element in the map sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>マップシーケンスの中の次の要素を生み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Produces the next element in the prefix sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>prefixシーケンスの中の次の要素を生み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Produces the next element in the prefix-while sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>prefix-whileシーケンスの中の次の要素を生み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Producing Iterator Values</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>イテレータ値を生み出す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Proper alignment ensures that the result of <bpt i="1" x="1">&lt;c1&gt;</bpt>distance(to:)<ept i="1">&lt;/c1&gt;</ept> accurately measures the distance between the two pointers, counted in strides of <bpt i="2" x="2">&lt;c2&gt;</bpt>Pointee<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>適切なアライメントは、<bpt i="1" x="1">&lt;c1&gt;</bpt>distance(to:)<ept i="1">&lt;/c1&gt;</ept>の結果が正確に２つのポインタの間の隔たりを、<bpt i="2" x="2">&lt;c2&gt;</bpt>Pointee<ept i="2">&lt;/c2&gt;</ept>のストライドで数えて、測ることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Protocols permit classes, structures, and enumerations to participate in inheritance, while class inheritance is only compatible with other classes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>プロトコルは、クラス、構造体、そして列挙に対して継承に参加することを許可します、一方でクラス継承は他のクラスと互換性があるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Provide access to a shared resource using a single, shared class instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>共有リソースへのアクセスを単一の、共有クラスインスタンスを使って提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Providing a Hash Value</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ハッシュ値の提供</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Querying Runtime Values</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>実行時値の問い合わせ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Querying a Double</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Doubleに問い合わせる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Querying a Double's State</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Doubleの状態を問い合わせる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Querying a Float</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Floatに問い合わせる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Querying a Float's State</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Floatの状態を問い合わせる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Range Expressions</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Range-Checked Conversion</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲確認変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Ranges</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>さまざまな範囲</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Raw Representation</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>生の表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Reference Counting</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>参照カウント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Reference Types</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>参照型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Related Array Types</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>関連した配列型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Relationships</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>関係</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes all elements from the array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列からすべての要素を取り除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes all key-value pairs from the dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>すべてのキー値ペアを辞書から削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes all the elements that satisfy the given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた述部を満たす要素すべてを除去します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes and returns the element at the specified position.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された位置での要素を削除して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes and returns the first element of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの最初の要素を削除して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes and returns the first key-value pair of the dictionary if the dictionary isn’t empty.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その辞書が空でないならば、辞書の中の最初のキー値ペアを削除して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes and returns the key-value pair at the specified index.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キー値ペアを指定されたインデックスで削除して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes and returns the last element of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの最後の要素を削除して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes the elements in the specified subrange from the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された下位範囲の中の要素をコレクションから削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes the given key and its associated value from the dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定されたキーと関連値を辞書から取り除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes the given number of elements from the end of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた数の要素をコレクションの終わりから削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes the specified number of elements from the beginning of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された数の要素をコレクションの始まりから削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removes the specified number of elements from the end of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された数の要素をコレクションの終わりから削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removing Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要素の削除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Removing Keys and Values</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キーと値の削除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Reordering Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要素を再配列する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Reordering an Array's Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列の要素を再配列します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Reorders the elements of the collection such that all the elements that match the given predicate are after all the elements that don’t match.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの要素を再配列します、例えば、与えられた述部にマッチする要素すべてが、合致しない要素すべての後になるなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Repeatedly calling this method returns all the elements of the underlying sequence in order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>繰り返しこのメソッドを呼び出すことは、基礎をなすシーケンスのすべての要素を順番に返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Repeatedly calling this method returns, in order, all the elements of the underlying sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>繰り返しこのメソッドを呼び出すことは、基礎をなすシーケンスのすべての要素を、順番に返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Replaces a range of elements with the elements in the specified collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある範囲の要素を指定されたコレクションの要素で置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Replaces the given index with its predecessor.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたインデックスをそれの前のものと取り替えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Replaces the given index with its successor.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたインデックスをそれの後に続くものと取り替えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Replaces the specified subrange of elements with the given collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>いくらかの要素からなる指定された下位範囲を与えられたコレクションで置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Replaces this value with its additive inverse.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値をそれの加法の逆元で置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Replaces this value with its square root, rounded to a representable value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値をそれの平方根で置き換えます、表現可能な値に丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Replaces this value with the remainder of itself divided by the given value using truncating division.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>切り捨て除算を使ってそれ自身を与えられた値で除算した余りでこの値を置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Replaces this value with the remainder of itself divided by the given value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それ自身を与えられた値で除算した余りでこの値を置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Represents a string literal with interpolations while it is being built up.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある文字列リテラルでいくらかの補間をもつものを、それが作り上げられている間に表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Represents the contents of a string literal with interpolations while it’s being built up.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>いくらかの補間をもつある文字列リテラルの内容それらを、それが作り上げられている間に表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Required.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>必須。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Reserves enough space to store the specified number of elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された数の要素を格納するのに十分な空間を確保します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Reserves enough space to store the specified number of key-value pairs.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された数のキー値ペアを格納するのに十分な空間を確保します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Resources</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>リソース</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Respond to a Property Change</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>プロパティの変更に応答する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Respond to events on behalf of a delegator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>委任元に代わってイベントに応答します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Resume the task awaiting the continuation by having it either return normally or throw an error based on the state of the given <bpt i="0" x="0">&lt;c0&gt;</bpt>Result<ept i="0">&lt;/c0&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>継続を待っているタスクを、それにそれの中断地点からこの与えられた<bpt i="0" x="0">&lt;c0&gt;</bpt>Result<ept i="0">&lt;/c0&gt;</ept>値の状態に基づいて通常に復帰させるかエラーをスローさせるかどちらかによって再開します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Resume the task awaiting the continuation by having it return normally from its suspension point.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>継続を待っているタスクを、それにそれの中断地点から通常に復帰させることによって再開します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Resume the task awaiting the continuation by having it throw an error from its suspension point.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>継続を待っているタスクを、それにそれの中断地点からエラーをスローさせることによって再開します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Resume the task awaiting the next iteration point by having it return nil or throw which signifies the end of the iteration.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の反復地点を待っているタスクを、それに反復の終わりを意味するnilを返させるまたはスローさせることによって再開します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Resume the task awaiting the next iteration point by having it return nil which signifies the end of the iteration.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の反復地点を待っているタスクを、それに反復の終わりを意味するnilを返させることによって再開します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Resume the task awaiting the next iteration point by having it return nomally from its suspension point or buffer the value if no awaiting next iteration is active.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の反復地点を待っているタスクを、それに通常に復帰させることによってそれの中断地点から再開します。または待っている次の反復が活動中でないならば値をバッファに移します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Resume the task awaiting the next iteration point by having it return normally from its suspension point or buffer the value if no awaiting next iteration is active where the <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>Void<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の反復地点を待っているタスクを、それに通常に復帰させることによってそれの中断地点から再開します。または待っている次の反復が活動中でないならば値をバッファに移します、そこで<bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>は<bpt i="1" x="1">&lt;c1&gt;</bpt>Void<ept i="1">&lt;/c1&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Resume the task awaiting the next iteration point by having it return normally from its suspension point or buffer the value if no awaiting next iteration is active.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の反復地点を待っているタスクを、それに通常に復帰させることによってそれの中断地点から再開します。または待っている次の反復が活動中でないならば値をバッファに移します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Resuming from a continuation more than once is undefined behavior.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある継続から一回以上再開することは、未定義挙動です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Retrieve or set the <bpt i="0" x="0">&lt;c0&gt;</bpt>Pointee<ept i="0">&lt;/c0&gt;</ept> instance referenced by <bpt i="1" x="1">&lt;c1&gt;</bpt>self<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>self<ept i="0">&lt;/c0&gt;</ept>によって参照される<bpt i="1" x="1">&lt;c1&gt;</bpt>Pointee<ept i="1">&lt;/c1&gt;</ept>インスタンスを回収または設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Retrieve the executor for this actor as an optimized, unowned reference.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>エグゼキュータ（遂行者）をこのアクターのためにある最適化された、非所有参照として取って来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Retrieve the localized description for this error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このエラーの現地語化された説明を取ってきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Return Value</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>戻り値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns <bpt i="0" x="0">&lt;c0&gt;</bpt>-1<ept i="0">&lt;/c0&gt;</ept> if this value is negative and <bpt i="1" x="1">&lt;c1&gt;</bpt>1<ept i="1">&lt;/c1&gt;</ept> if it’s positive; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt>0<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値が負ならば<bpt i="0" x="0">&lt;c0&gt;</bpt>-1<ept i="0">&lt;/c0&gt;</ept>そしてそれが正ならば<bpt i="1" x="1">&lt;c1&gt;</bpt>1<ept i="1">&lt;/c1&gt;</ept>；それ以外では<bpt i="2" x="2">&lt;c2&gt;</bpt>0<ept i="2">&lt;/c2&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>, indicating that there are no more elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>もう要素は無いことを指し示す、<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if the task is cancelled, and should stop executing.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>を返します、もしタスクが取り消される、そして遂行を停止すべきならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> if this value is a multiple of the given value, and <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept> otherwise.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>をもしこの値がその与えられた値の倍数ならば、そして<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>をそうでないならば返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a <bpt i="0" x="0">&lt;c0&gt;</bpt>CVa<bpt i="1" x="1">&lt;w1&gt;</bpt>List<bpt i="2" x="2">&lt;w2&gt;</bpt>Pointer<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> that is backed by autoreleased storage, built from the given array of arguments.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オートリリースされるストレージによって裏付けられる<bpt i="0" x="0">&lt;c0&gt;</bpt>CVa<bpt i="1" x="1">&lt;w1&gt;</bpt>List<bpt i="2" x="2">&lt;w2&gt;</bpt>Pointer<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を返します、いくらかの引数からなる与えられた配列から組み立てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether a value is included in a range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値が範囲に含まれるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether any corresponding components of the two tuples are not equal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つのタプルの対応する構成要素いずれかが等しくないかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether every element of a sequence satisfies a given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスのすべての要素がある与えられた述部を満たすかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the corresponding components of two tuples are equal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つのタプルの対応する構成要素らが等しいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the first argument represents a position before the second argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最初の引数が２番目の引数の前の位置を表すかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the first tuple is ordered after or the same as the second in a lexicographical ordering.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>語彙筆記的順序において最初のタプルが２番目の後ろまたはそれと同じ順序かかどうかを指し示しているブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the first tuple is ordered after the second in a lexicographical ordering.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>語彙筆記的順序において最初のタプルが２番目の後ろの順序かかどうかを指し示しているブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the first tuple is ordered before or the same as the second in a lexicographical ordering.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>語彙筆記的順序において最初のタプルが２番目の前またはそれと同じ順序かかどうかを指し示しているブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the first tuple is ordered before the second in a lexicographical ordering.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>語彙筆記的順序において最初のタプルが２番目の前の順序かかどうかを指し示しているブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the given element is contained within the range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた要素がこの範囲内に含まれるかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the given keys are equal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたキーが等しいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the given object is known to have a single strong reference.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるブール値を返して、与えられたオブジェクトが１つだけ強い参照を持つことを知られるかどうかを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the initial elements of the sequence are equivalent to the elements in another sequence, using the given predicate as the equivalence test.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスの最初の要素らが別のシーケンスの中の要素らと同等かどうかを、与えられた述部を同等性テストとして使って指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the initial elements of the sequence are the same as the elements in another sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスの最初の要素らが別のシーケンスの中の要素らと同じかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the sequence contains an element that satisfies the given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された述部を満足させるある要素をシーケンスが含むかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the sequence contains the given element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された要素をシーケンスが含むかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the given predicate to compare elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスが別のシーケンスの前に来るかどうかをある語彙筆記的順序（字典）順序において、与えられた述部を使って要素を比較して、指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the sequence precedes another sequence in a lexicographical (dictionary) ordering, using the less-than operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;<ept i="0">&lt;/c0&gt;</ept>) to compare elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのシーケンスが別のシーケンスの前に来るかどうかを、ある語彙筆記的順序（字典）順序において、より小さい演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;<ept i="0">&lt;/c0&gt;</ept>）を使って要素を比較して、指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the two arguments are equal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの引数が等しいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the two arguments are not equal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの引数が等しくないかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the two given values are equal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの与えられた値が等しいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the two given values are not equal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの与えられた値が等しくないかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the value of the first argument is greater than or equal to that of the second argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最初の引数の値が２番目の引数のそれより大きいまたは等しいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the value of the first argument is greater than that of the second argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最初の引数の値が２番目の引数のそれより大きいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the value of the first argument is less than or equal to that of the second argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最初の引数の値が２番目の引数のそれより少ないまたは等しいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether the value of the first argument is less than that of the second argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最初の引数の値が２番目の引数のそれより少ないかどうかを指し示しているブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether this instance is equal to the given value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このインスタンスが与えられた値と等しいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether this instance is less than or equal to the given value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このインスタンスが与えられた値より小さいまたは等しいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether this instance is less than the given value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このインスタンスが与えられた値より小さいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether this instance should precede or tie positions with the given value in an ascending sort.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このインスタンスがある昇順ソートにおいて、与えられた値より前にくるまたは同じ位置かどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether this range and the given range contain an element in common.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この範囲と与えられた範囲がある要素を共通に含むかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether this sequence and another sequence contain equivalent elements in the same order, using the given predicate as the equivalence test.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスともう一方のシーケンスが同等の要素を同じ順序で含むかどうかを、与えられた述部を同等テストとして使って、指し示しているブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether this sequence and another sequence contain the same elements in the same order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスともう一方のシーケンスが同じ要素を同じ順序で含むかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether two arguments match by value equality.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるブール値を返します、２つの引数が値等式によって一致するかどうかを指し示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether two arrays contain the same elements in the same order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの配列が同じ要素を同じ順序で含むかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether two indices wrap equal underlying indices.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つのインデックスが等しい基礎をなすインデックスをラップするかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether two ranges are equal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの範囲が等しいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether two references point to different object instances.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの参照が異なるオブジェクトインスタンスを指しているかどうかを示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether two references point to the same object instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの参照が同じオブジェクトインスタンスを指しているかどうかを示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether two type-erased hashable instances wrap the same value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの型消去ハッシュ可能インスタンスが同じ値をラップするかどうかを指し示しているブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether two types are identical.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの型が同一かどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether two types are not identical.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの型が同一でないかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether two values are equal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの値が等しいかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value indicating whether two values are not equal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの値が等しくないかどうかを指し示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value that indicates whether all elements produced by the asynchronous sequence satisfies the given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるブール値を返します、それは非同期シーケンスによって生み出される全ての要素がこの与えられた述部を満足させるかどうかを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value that indicates whether the asynchronous sequence contains an element that satisfies the given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるブール値を返します、それは非同期シーケンスがこの与えられた述部を満足させる要素を含むかどうかを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a Boolean value that indicates whether the asynchronous sequence contains the given element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるブール値を返します、それは非同期シーケンスがこの与えられた要素を含むかどうかを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a closed range that contains both of its bounds.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それの境界の両方を含む完結範囲を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a copy of this range clamped to the given limiting range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた限界範囲に締め金具で留められる（制限を課される）、この範囲のコピーを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a half-open range that contains its lower bound but not its upper bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それの下側の境界は含むがそれの上側の境界はそうしない半開範囲を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a lowercased version of this character.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文字のローワーケース版を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a new <bpt i="0" x="0">&lt;c0&gt;</bpt>.data<bpt i="1" x="1">&lt;w1&gt;</bpt>Corrupted<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> error using a constructed coding path and the given debug description.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>.data<bpt i="1" x="1">&lt;w1&gt;</bpt>Corrupted<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>エラーを返します、組み立てられたコーディングパスと与えられたデバッグ説明を使っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a new collection difference with associations between individual elements that have been removed and inserted only once.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ただ一度だけ除去および挿入された個々の要素の間の関連性それらをもつある新しいコレクション差異を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a new dictionary containing only the key-value pairs that have non-<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> values as the result of transformation by the given closure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたクロージャによる変換の結果として非<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>を持つキー値ペアだけを含んでいる新しい辞書を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a new dictionary containing the key-value pairs of the dictionary that satisfy the given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この辞書のキー値ペアで与えられた述部を満たすものを含んでいる新しい辞書を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a new dictionary containing the keys of this dictionary with the values transformed by the given closure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたクロージャによって変形された値とともに、この辞書のキーを含んでいる新しい辞書を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a new key path created by appending the given key path to this one.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたキーパスをこのものに加えることによって作成された新しいキーパスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a new string by concatenating the elements of the sequence, adding the given separator between each element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>各要素の間に与えられた分離子を加えて、シーケンスの要素を連結することによる新しい文字列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a partial range extending upward from a lower bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下側の境界から上方に拡張している部分的な範囲を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a partial range up to, and including, its upper bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それの上側の境界までの、そしてそれを含む部分的な範囲を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a partial range up to, but not including, its upper bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それの上側の境界までの、しかしそれを含んでいない、部分的な範囲を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a pointer offset from this pointer by the specified number of instances.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このポインタから指定された数のインスタンスだけオフセットしたポインタを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a pointer to the next consecutive instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の隣接インスタンスへのポインタを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a pointer to the previous consecutive instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>前の隣接インスタンスへのポインタを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a random Boolean value, using the given generator as a source for randomness.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>無作為なブール値を返します、与えられた生成子を無作為さの出典として使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a random Boolean value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>無作為なブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a random element of the collection, using the given generator as a source for randomness.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションのある無作為な要素を返します、与えられた生成子を無作為さの出典として使って使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a random element of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションのある無作為の要素を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a random value within the specified range, using the given generator as a source for randomness.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された範囲内のある無作為な値を返します、与えられた生成子を無作為さの出典として使って使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a random value within the specified range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された範囲内のある無作為の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a sequence by skipping the initial, consecutive elements that satisfy the given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた述部を満たす、冒頭の、隣接する要素を飛ばすことによるあるシーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a sequence containing all but the given number of final elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた数の末尾要素以外すべてを含んでいるあるシーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a sequence containing all but the given number of initial elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された数の冒頭要素以外すべてを含んでいるあるシーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a sequence containing the initial, consecutive elements that satisfy the given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた述部を満たす、冒頭の、隣接する要素を含んでいるあるシーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a sequence formed from <bpt i="0" x="0">&lt;c0&gt;</bpt>first<ept i="0">&lt;/c0&gt;</ept> and repeated lazy applications of <bpt i="1" x="1">&lt;c1&gt;</bpt>next<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>first<ept i="0">&lt;/c0&gt;</ept>からそして繰り返し<bpt i="1" x="1">&lt;c1&gt;</bpt>next<ept i="1">&lt;/c1&gt;</ept>を遅延適用して形成されたシーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a sequence formed from repeated lazy applications of <bpt i="0" x="0">&lt;c0&gt;</bpt>next<ept i="0">&lt;/c0&gt;</ept> to a mutable <bpt i="1" x="1">&lt;c1&gt;</bpt>state<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>繰り返し<bpt i="0" x="0">&lt;c0&gt;</bpt>next<ept i="0">&lt;/c0&gt;</ept>を可変の<bpt i="1" x="1">&lt;c1&gt;</bpt>state<ept i="1">&lt;/c1&gt;</ept>に遅延適用することから形成されたシーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a sequence from a starting value to, but not including, an end value, stepping by the specified amount.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定の量だけ歩を進めて、始まりの値から終わりの値まで、しかしそれは含めないシーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a sequence from a starting value toward, and possibly including, an end value, stepping by the specified amount.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定の量だけ歩を進めて、始まりの値から終わりの値の方へ、そしてもしかするとそれを含めるシーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a sequence of pairs (<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>, <bpt i="1" x="1">&lt;e1&gt;</bpt>x<ept i="1">&lt;/e1&gt;</ept>), where <bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept> represents a consecutive integer starting at zero and <bpt i="3" x="3">&lt;e3&gt;</bpt>x<ept i="3">&lt;/e3&gt;</ept> represents an element of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ペア (<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>, <bpt i="1" x="1">&lt;e1&gt;</bpt>x<ept i="1">&lt;/e1&gt;</ept>) のシーケンスを返します、そこで<bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept>はゼロで開始する連続した数を表して、<bpt i="3" x="3">&lt;e3&gt;</bpt>x<ept i="3">&lt;/e3&gt;</ept>はシーケンスの要素を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a sequence, up to the specified maximum length, containing the initial elements of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された最大長まで、そのシーケンスの冒頭の要素を含んでいる、あるシーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a string read from standard input through the end of the current line or until EOF is reached.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>標準入力から現在の行の終わりまでまたはEOFが到達されるまで読み込んだ文字列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a subsequence by skipping elements while <bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept> returns <bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept> and returning the remaining elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>を返す間は要素を飛ばして残りの要素を返すことによって、ある下位シーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a subsequence containing all but the given number of initial elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された数の冒頭要素以外すべてを含んでいる下位シーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a subsequence containing all but the specified number of final elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された数の末尾要素以外すべてを含んでいる下位シーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a subsequence containing the initial elements until <bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept> returns <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept> and skipping the remaining elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>を返すまで冒頭の要素を含んでいて残りの要素を飛ばしている、ある下位シーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a subsequence from the specified position to the end of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された位置からコレクションの終わりまでの下位シーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a subsequence from the start of the collection through the specified position.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの始まりから指定された位置までも含む下位シーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a subsequence from the start of the collection up to, but not including, the specified position.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの始まりから指定された位置まで、しかしそれは含めない下位シーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a subsequence, up to the given maximum length, containing the final elements of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下位シーケンスを、指定された最大長まで、コレクションの末尾の要素を含めて返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a subsequence, up to the given maximum length, containing the final elements of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下位シーケンスを、指定された最大長まで、シーケンスの末尾の要素を含めて返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a subsequence, up to the specified maximum length, containing the initial elements of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下位シーケンスを、指定された最大長まで、コレクションの冒頭の要素を含めて返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a tuple containing the high and low parts of the result of multiplying this value by the given value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値を指定の値で掛ける結果の高および低部分を含んでいるタプルを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a tuple containing the quotient and remainder obtained by dividing the given value by this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた値をこの値で割ることで入手される商と余りを含んでいるタプルを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a tuple containing the quotient and remainder of dividing the given value by this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた値をこの値で除算した商と余りを含んでいるタプルを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a value that is offset the specified distance from this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定の隔たりをこの値からオフセットされたある値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns a view presenting the elements of the collection in reverse order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの要素を逆順に表しているある見方を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns an array containing the concatenated results of calling the given transformation with each element of this sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された変換をこのシーケンスの各要素で呼び出す結果を連結したものを含んでいる配列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns an array containing the elements of this sequence in reverse order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスの要素を逆順に含んでいる配列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns an array containing the non-<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> results of calling the given transformation with each element of this sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された変換をこのシーケンスの各要素で呼び出す結果で非-<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>のものを含んでいる配列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns an array containing the results of mapping the given closure over the sequence’s elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたクロージャをシーケンスのもつ要素全体にわたってマップする結果を含んでいる配列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns an array containing, in order, the elements of the sequence that satisfy the given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された述部を満足させるものであるシーケンスの要素を、順序通りに、含んでいる配列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given error-throwing predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある非同期シーケンスを返します、基底シーケンスの冒頭の、連続する要素いくつかを含んでいます、それらは与えられたエラースロー述部を満たすものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns an asynchronous sequence, containing the initial, consecutive elements of the base sequence that satisfy the given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある非同期シーケンスを返します、基底シーケンスの冒頭の、連続する要素いくつかを含んでいます、それらは与えられた述部を満たすものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns an asynchronous sequence, up to the specified maximum length, containing the initial elements of the base asynchronous sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された最大長まで、その基底非同期シーケンスの冒頭の要素を含んでいる、ある非同期シーケンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns an empty iterator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>空のイテレータを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns an encoding container appropriate for holding a single primitive value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>単一プリミティブ値を保持するのに適切なエンコーディングコンテナを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns an encoding container appropriate for holding multiple unkeyed values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>複数のキー付けされない値を保持するのに適切なエンコーディングコンテナを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns an encoding container appropriate for holding multiple values keyed by the given key type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたキー型によってキー付けされる複数の値を保持するのに適切なエンコーディングコンテナを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns an index that is the specified distance from the given index, unless that distance is beyond a given limiting index.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたインデックスから指定された隔たりのインデックスを返します、その隔たりが与えられた限界インデックスを越えない限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns an index that is the specified distance from the given index.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたインデックスから指定された隔たりのインデックスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns an iterator over the dictionary’s key-value pairs.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書のキー値ペアすべてを対象とするイテレータを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns an iterator over the elements of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの要素すべてを対象としたイテレータを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns an iterator over the elements of this collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このコレクションの要素すべてを対象としたイテレータを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns an iterator over the elements of this sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスの要素すべてを対象としたあるイテレータを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns an uppercased version of this character.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文字のアッパーケース版を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns nil if <bpt i="0" x="0">&lt;c0&gt;</bpt>from<ept i="0">&lt;/c0&gt;</ept> is nil.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>from<ept i="0">&lt;/c0&gt;</ept>がnilならばnilを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the absolute value of the given number.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた数の絶対値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the additive inverse of the specified value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された値の加法の逆元を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the bits of the given instance, interpreted as having the specified type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたインスタンスのビットを返します、指定された型を持つと解釈されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the concatenated elements of this sequence of sequences, inserting the given separator between each element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>各要素の間に与えられた分離子を挿入して、このシーケンスに属する複数のシーケンスの要素を鎖状に連結して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the data stored in this decoder as represented in a container appropriate for holding a single primitive value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このデコーダの中に格納されるデータを、単一プリミティブ値を保持するのに適したコンテナの中に表現される通りに返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the data stored in this decoder as represented in a container appropriate for holding values with no keys.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このデコーダの中に格納されるデータを、キーなしで値を保持するのに適したコンテナの中に表現される通りに返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the data stored in this decoder as represented in a container keyed by the given key type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このデコーダの中に格納されるデータを、与えられたキー型によってキー付けされるコンテナの中に表現された通りに返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the difference needed to produce this collection’s ordered elements from the given collection, using the given predicate as an equivalence test.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このコレクションのもつ順番付けられた要素をこの与えられたコレクションから生成するのに必要とされる差異を返します、与えられた述部を同等性テストとして使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the difference needed to produce this collection’s ordered elements from the given collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このコレクションのもつ順番付けられた要素をこの与えられたコレクションから生成するのに必要とされる差異を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the difference obtained by subtracting the given value from this value, along with a Boolean value indicating whether overflow occurred in the operation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた値をこの値から減じることで入手される差、それに加えてオーバーフローがその演算において起こったかどうかを示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the difference of the two given values, wrapping the result in case of any overflow.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの与えられた値の差を返します、何らかのオーバーフローの場合には結果をラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the distance between two indices.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つのインデックス間の隔たりを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the distance from this pointer to the given pointer, counted as instances of the pointer’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Pointee<ept i="0">&lt;/c0&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このポインタから与えられたポインタまでの隔たりを返します、ポインタのもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Pointee<ept i="0">&lt;/c0&gt;</ept>型のインスタンスとして数えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the distance from this value to the given value, expressed as a stride.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値から特定の値までの隔たりを返します、ストライドとして表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the dynamic type of a value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値の動的型を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the elements of the sequence, shuffled using the given generator as a source for randomness.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスの要素を返します、与えられた生成子を無作為さの出典として使って混ぜ合わされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the elements of the sequence, shuffled.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>入れ替えた、シーケンスの要素を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the elements of the sequence, sorted using the given predicate as the comparison between elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた述部を要素間の比較として使ってソートされた、シーケンスの要素を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the elements of the sequence, sorted.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスに属する要素を、ソートして返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the elements of this sequence of sequences, concatenated.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスに属する複数のシーケンスの要素を、鎖状に連結して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the first element of the sequence that satisfies the given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた述部を満たすこのシーケンスの最初の要素を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the first index in which an element of the collection satisfies the given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最初のインデックスで、それにおけるコレクションの要素が与えられた述部を満足させるものを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the first index where the specified value appears in the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された値がコレクションにおいて現れるところの最初のインデックスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the given instance cast unconditionally to the specified type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたインスタンスを無条件に特定の型にキャストして返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the given integer as the equivalent value in a different integer type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた整数を同等値としてある異なる整数型において返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the given number unchanged.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた数を変更せずに返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the greater of the two given values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの与えられた値の大きい方を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the greater of two comparable values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの比較可能な値のうちより大きいものを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the greatest argument passed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>渡された引数の最も大きいものを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the index for the given key.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたキーに対するインデックスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the index of the last element in the collection that matches the given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた述部に合致する、コレクションの中の最後の要素のインデックスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the inverse of the bits set in the argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>引数におけるビットの逆順を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the last element of the sequence that satisfies the given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた述部を満たす、シーケンスの最後の要素を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the last index where the specified value appears in the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された値がコレクションにおいて現れるところの最後のインデックスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the least argument passed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>渡された引数の最も少ないものを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the lesser of the two given values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの与えられた値のより小さい方を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the lesser of two comparable values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの比較可能な値のうちより小さいものを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the longest possible subsequences of the collection, in order, around elements equal to the given element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた要素と等しい要素を避けるようにして、このコレクションの最も長くなりうる下位シーケンスを、順番に返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the longest possible subsequences of the collection, in order, that don’t contain elements satisfying the given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた述部を満たす要素を含んでいない、このコレクションの最も長くなりうる下位シーケンスそれらを順序どおりに返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the longest possible subsequences of the sequence, in order, around elements equal to the given element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた要素と等しい要素を避けるようにして、このシーケンスの最も長くなりうる下位シーケンスを、順番に返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the longest possible subsequences of the sequence, in order, that don’t contain elements satisfying the given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた述部を満たす要素を含んでいない、このシーケンスの最も長くなりうる下位シーケンスそれらを順序どおりに返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the maximum element in an asynchronous sequence of comparable elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>比較可能要素それらからなるある非同期シーケンスの中の最大の要素を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the maximum element in the asynchronous sequence, using the given predicate as the comparison between elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>非同期シーケンスの中の最大の要素を返します、与えられた述部を要素間の比較として使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the maximum element in the sequence, using the given predicate as the comparison between elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスの中の最大の要素を返します、与えられた述部を要素間の比較として使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the maximum element in the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスの中の最大の要素を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the minimum element in an asynchronous sequence of comparable elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>比較可能要素それらからなるある非同期シーケンスの中の最小の要素を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the minimum element in the asynchronous sequence, using the given predicate as the comparison between elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>非同期シーケンスの中の最小の要素を返します、与えられた述部を要素間の比較として使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the minimum element in the sequence, using the given predicate as the comparison between elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスの中の最小の要素を返します、与えられた述部を要素間の比較として使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the minimum element in the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスの中の最小の要素を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the position immediately after the given index.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたインデックスの直後の位置を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the position immediately before the given index.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたインデックスの直前の位置を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the product of the two given values, wrapping the result in case of any overflow.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの与えられた値の積を返します、何らかのオーバーフローの場合には結果をラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the product of this value and the given value, along with a Boolean value indicating whether overflow occurred in the operation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値と与えられた値の積、それに加えてオーバーフローがその演算において起こったかどうかを示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the quotient and remainder of this value divided by the given value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた値で除算されたこの値の商と余りを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the quotient obtained by dividing this value by the given value, along with a Boolean value indicating whether overflow occurred in the operation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値を指定の値で割ることで入手される商、それに加えてオーバーフローがその演算において起こったかどうかを示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the quotient of dividing the first value by the second, rounded to a representable value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最初の値を２番目の値で除算した商を返します、表現可能な値に丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the quotient of dividing the first value by the second.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最初の値を２番目の値で除算した商を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the range of indices described by this range expression within the given collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたコレクション内の、この範囲式によって記述されるインデックスの範囲を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the remainder after dividing this value by the given value, along with a Boolean value indicating whether overflow occurred during division.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値を指定の値によって除算する後の余り、それに加えてオーバーフローが除算の間に起こったかどうかを示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the remainder of dividing the first value by the second.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最初の値を２番目の値で除算した余りを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the remainder of this value divided by the given value using truncating division.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>切り捨て除算を使って与えられた値で除算されたこの値の余りを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the remainder of this value divided by the given value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた値で除算されたこの値の余りを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the result of adding the product of the two given values to this value, computed without intermediate rounding.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの与えられた値の積をこの値に加える結果を返します、中間の丸めなしで計算されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the result of combining the elements of the asynchronous sequence using the given closure, given a mutable initial value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>非同期シーケンスの要素をこの与えられたクロージャを使って結合する結果を返します、ある可変の初期値を与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the result of combining the elements of the asynchronous sequence using the given closure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>非同期シーケンスの要素をこの与えられたクロージャを使って結合する結果を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the result of combining the elements of the sequence using the given closure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられたクロージャを使って、このシーケンスの要素それらを結合する結果を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the result of performing a bitwise AND operation on the two given values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ビット単位AND演算を２つの与えられた値に関して実行する結果を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the result of performing a bitwise OR operation on the two given values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ビット単位OR演算を２つの与えられた値に関して実行する結果を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the result of performing a bitwise XOR operation on the two given values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ビット単位XOR演算を２つの与えられた値に関して実行する結果を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the result of shifting a value’s binary representation the specified number of digits to the left, masking the shift amount to the type’s bit width, and stores the result in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値のバイナリ表現を指定された桁数だけ左にシフトする結果を返します、シフト量をその型のもつビット幅にマスクしています、そして結果を左手側の変数に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the result of shifting a value’s binary representation the specified number of digits to the left, masking the shift amount to the type’s bit width.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値のバイナリ表現を指定された桁数だけ左にシフトする結果を返します、シフト量をマスクしてその型のもつビット幅にしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the result of shifting a value’s binary representation the specified number of digits to the left.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値のバイナリ表現を指定された桁数だけ左にシフトする結果を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the result of shifting a value’s binary representation the specified number of digits to the right, masking the shift amount to the type’s bit width.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値のバイナリ表現を指定された桁数だけ右にシフトする結果を返します、シフト量をその型のもつビット幅にマスクしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the result of shifting a value’s binary representation the specified number of digits to the right.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値のバイナリ表現を指定された桁数だけ右にシフトする結果を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the square root of the value, rounded to a representable value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値の平方根を返します、表現可能な値に丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the sum of the two given values, wrapping the result in case of any overflow.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの与えられた値の合計を返します、何らかのオーバーフローの場合には結果をラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the sum of this value and the given value, along with a Boolean value indicating whether overflow occurred in the operation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値と与えられた値の合計、それに加えてオーバーフローがその演算において起こったかどうかを示すブール値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the value with greater magnitude.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>より大きい規模を持つ値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns the value with lesser magnitude.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>より小さい規模を持つ値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns this value rounded to an integral value using the specified rounding rule.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された丸め規則を使って整数値に丸められたこの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returns this value rounded to an integral value using “schoolbook rounding.”</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>「教科書丸め」を使って整数値に丸めたこの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Reverses the elements of the collection in place.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの要素をその場で逆順にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Right shift operations on negative values “fill in” the high bits with ones instead of zeros.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>負値上での右シフト演算は、高ビットを１で「満たします」、ゼロではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Round to the closest allowed value that is greater than or equal to the source.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ソースより大きいか等しい最も近い許される値に丸めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Round to the closest allowed value that is less than or equal to the source.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ソースより小さいか等しい最も近い許される値に丸めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Round to the closest allowed value whose magnitude is greater than or equal to that of the source.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それの規模がソースのそれより大きいか等しい最も近い許される値に丸めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Round to the closest allowed value whose magnitude is less than or equal to that of the source.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それの規模がソースのそれより小さいか等しい最も近い許される値に丸めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Round to the closest allowed value; if two values are equally close, the even one is chosen.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最も近い許される値に丸めます；２つの値が同じくらい近いならば、偶数のものが選ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Round to the closest allowed value; if two values are equally close, the one with greater magnitude is chosen.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最も近い許される値に丸めます；２つの値が同じくらい近いならば、より大きい規模を持つものが選ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Rounding Values</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値を丸める</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Rounds the value to an integral value using the specified rounding rule.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された丸め規則を使ってこの値を整数値に丸めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Rounds this value to an integral value using “schoolbook rounding.”</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>「教科書丸め」を使ってこの値を整数値に丸めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>SIMD Implementations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>SIMD実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>SIMD Vector Types</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>SIMDベクター型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>SIMD-Supporting Types</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>SIMD支援型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Saved indices may become invalid as a result of mutating operations.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>保存されたインデックスは変更を行う演算の結果として無効となるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Screenshot of the Xcode prompt to configure an Objective-C bridging header.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Xcodeのスクリーンショットは、Objective-Cブリッジヘッダを構成設定するよう促します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>See <bpt i="0" x="0">&lt;a0&gt;</bpt>Toll-Free Bridging<ept i="0">&lt;/a0&gt;</ept> for more information.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>さらなる情報のために<bpt i="0" x="0">&lt;a0&gt;</bpt>Toll-Free Bridging<ept i="0">&lt;/a0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>See <bpt i="0" x="0">&lt;c0&gt;</bpt>String<bpt i="1" x="1">&lt;w1&gt;</bpt>Interpolation<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> for details on <bpt i="3" x="3">&lt;c3&gt;</bpt>append<bpt i="4" x="4">&lt;w4&gt;</bpt>Interpolation<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> methods.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>String<bpt i="1" x="1">&lt;w1&gt;</bpt>Interpolation<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を<bpt i="3" x="3">&lt;c3&gt;</bpt>append<bpt i="4" x="4">&lt;w4&gt;</bpt>Interpolation<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>メソッドに関する詳細として見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>See Also</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>参照</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>See String.UTF16View for more information</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>String.UTF16Viewをさらなる情報のために見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>See String.UTF8View for more information</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>String.UTF8Viewをさらなる情報のために見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>See also the <bpt i="0" x="0">&lt;c0&gt;</bpt>ulp<ept i="0">&lt;/c0&gt;</ept> member property.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>また<bpt i="0" x="0">&lt;c0&gt;</bpt>ulp<ept i="0">&lt;/c0&gt;</ept>メンバープロパティも見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>See also the <bpt i="0" x="0">&lt;c0&gt;</bpt>ulp<bpt i="1" x="1">&lt;w1&gt;</bpt>Of<bpt i="2" x="2">&lt;w2&gt;</bpt>One<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> static property.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>また<bpt i="0" x="0">&lt;c0&gt;</bpt>ulp<bpt i="1" x="1">&lt;w1&gt;</bpt>Of<bpt i="2" x="2">&lt;w2&gt;</bpt>One<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>静的プロパティを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Selecting Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要素の選択</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Selecting and Excluding Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要素の選択と除外</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Sequence and Collection Protocols</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスおよびコレクションプロトコル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Set<bpt i="0" x="0">&lt;w0&gt;</bpt>Algebra Implementations <ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合<bpt i="0" x="0">&lt;w0&gt;</bpt>代数実装<ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Sets and Dictionaries</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>集合と辞書</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Setting the pointee autoreleases the new value before trivially storing it in the referenced memory.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>pointeeを設定することは、新しい値をオートリリースします、それをその参照されたメモリの中に自明に格納する前に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Sharing class instances pervasively throughout an app makes logic errors more likely.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>アプリの隅々まで行き渡る共有クラスインスタンスは、論理エラーをより招きやすくします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Sharing indices between collections and their subsequences is an important part of the design of Swift’s collection algorithms.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションとそれらの下位シーケンスとの間のインデックスの共有は、Swiftのコレクションアルゴリズム設計の重要な部分のひとつです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Shuffles the collection in place, using the given generator as a source for randomness.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションをその場で混ぜ合わせます、与えられた生成子を無作為さの出典として使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Shuffles the collection in place.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションをその場で混ぜ合わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Signaling NaNs typically raise the Invalid flag when used in general computing operations.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シグナルNaNは、一般的な計算操作に使われる時に通常は無効フラグをあげます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Signed Integers</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>符号付き整数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Signed<bpt i="0" x="0">&lt;w0&gt;</bpt>Integer Implementations <ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>符号付き<bpt i="0" x="0">&lt;w0&gt;</bpt>整数実装<ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Similarly, if an error producing Objective-C method returns a <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept> value to indicate the failure of a method call, Swift changes the return type of the function to a nonoptional type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同様に、エラーを生成しているObjective-Cメソッドが<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>値を返してメソッド呼び出しの失敗を指し示すならば、スウィフトは関数の戻り型を非オプショナル型に変えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Simply surround a comma-separated list of values, instances, or literals with square brackets to create an array literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>単にコンマ区切りの値、インスタンス、またはリテラルを角括弧で囲むことで、配列リテラルを作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Since equality between instances of <bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept> types is an equivalence relation, any of your custom types that conform to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept> must satisfy three conditions, for any values <bpt i="2" x="2">&lt;c2&gt;</bpt>a<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>b<ept i="3">&lt;/c3&gt;</ept>, and <bpt i="4" x="4">&lt;c4&gt;</bpt>c<ept i="4">&lt;/c4&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept>型のインスタンス間の同等性は等値関係であることから、<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠するあなたのあつらえの型は何であれ、任意の値<bpt i="2" x="2">&lt;c2&gt;</bpt>a<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>b<ept i="3">&lt;/c3&gt;</ept>、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>c<ept i="4">&lt;/c4&gt;</ept>に対して、３つの条件を満たす必要があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Since there is no key for <bpt i="11" x="11">&lt;c11&gt;</bpt>4<ept i="11">&lt;/c11&gt;</ept>, the closure returns <bpt i="12" x="12">&lt;c12&gt;</bpt>nil<ept i="12">&lt;/c12&gt;</ept> in this case, which <bpt i="13" x="13">&lt;c13&gt;</bpt>compact<bpt i="14" x="14">&lt;w14&gt;</bpt>Map(_:)<ept i="14">&lt;/w14&gt;</ept><ept i="13">&lt;/c13&gt;</ept> omits from the transformed asynchronous sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="11" x="11">&lt;c11&gt;</bpt>4<ept i="11">&lt;/c11&gt;</ept>に対するキーがないことから、クロージャは<bpt i="12" x="12">&lt;c12&gt;</bpt>nil<ept i="12">&lt;/c12&gt;</ept>をその場合には返します、それは<bpt i="13" x="13">&lt;c13&gt;</bpt>compact<bpt i="14" x="14">&lt;w14&gt;</bpt>Map(_:)<ept i="14">&lt;/w14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>がこの変換されたシーケンスから省きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Single-value methods eliminate the need for a <bpt i="0" x="0">&lt;c0&gt;</bpt>for await<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> loop, and instead let you make a single <bpt i="2" x="2">&lt;c2&gt;</bpt>await<ept i="2">&lt;/c2&gt;</ept> call.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>単一値のメソッドそれらは、<bpt i="0" x="0">&lt;c0&gt;</bpt>for await<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>ループの必要性を排除します、そして代わりにあなたにある単一の<bpt i="2" x="2">&lt;c2&gt;</bpt>await<ept i="2">&lt;/c2&gt;</ept>呼び出しをさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Slices Are Views onto Arrays</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>スライスは配列に関する見方です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Slices Inherit Collection Semantics</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>スライスはコレクションの意味論を継承します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Slices Maintain Indices</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>スライスはインデックスを維持します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Slices Share Indices</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>スライスはインデックスを共有します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Slices maintain the same indices of the larger array for the same elements, so the starting index of a slice depends on how it was created, letting you perform index-based operations on either a full array or a slice.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>スライスはより大きな配列と同じインデックスを同じ要素に対して維持します、そのためスライスの開始インデックスはそれがどう作成されたかによって決まり、あなたにインデックスに基づく演算を完全な配列またはスライスのどちらでも実行させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Solve complex problems and write high-performance, readable code.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>複雑な問題を解決します、そして高性能の、読みやすいコードを記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Some examples:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>いくつかの例：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Some other types, such as optionals, arrays and ranges automatically become hashable when their type arguments implement the same.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>いくつかの他の型、オプショナル、配列および範囲は、自動的にハッシュ可能になります、それらの型引数が同じものを実装する場合には。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Some sequence and collection operations can be used more simply when the elements conform to <bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>いくつかのシーケンスとコレクションの演算子は、要素が<bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept>に準拠する時はより簡単に使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Some special cases apply:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>いくつかの特別な場合が適用されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Sometimes you may want different error states to include the same common data, such as the position in a file or some of your application’s state.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>時にはあなたは、いくらかの異なるエラー状態をこの同じ通常のデータに含めたいかもしれません、例えばあるファイル中の位置やあなたのアプリケーションの何らかの状態など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Sorts the collection in place, using the given predicate as the comparison between elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションをその場でソートします、与えられた述部を要素間の比較として使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Sorts the collection in place.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションをその場でソートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Special-Use Collections</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>特殊用途のコレクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Special-Use Numeric Types</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>特殊用途の数値型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Specifically, you use the <bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept> type to hold elements of a single type, the array’s <bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>とりわけ、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept>型をある単一の型、その配列のもつ<bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept>型、の複数の要素を保持するために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Specifying the Associated Type</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>関連型を指定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Specifying the Identified Item</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同一視される項目を指定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Splitting and Joining Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要素の分割と連結</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Standard Library</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>標準ライブラリ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Standard input is interpreted as <bpt i="0" x="0">&lt;c0&gt;</bpt>UTF-8<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>標準入力は、<bpt i="0" x="0">&lt;c0&gt;</bpt>UTF-8<ept i="0">&lt;/c0&gt;</ept>として解釈されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Starting with <bpt i="1" x="1">&lt;c1&gt;</bpt>start<ept i="1">&lt;/c1&gt;</ept>, each successive value of the sequence adds <bpt i="2" x="2">&lt;c2&gt;</bpt>stride<ept i="2">&lt;/c2&gt;</ept> until the next value would be beyond <bpt i="3" x="3">&lt;c3&gt;</bpt>end<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>start<ept i="1">&lt;/c1&gt;</ept>で開始して、シーケンスのそれぞれ次の値は<bpt i="2" x="2">&lt;c2&gt;</bpt>stride<ept i="2">&lt;/c2&gt;</ept>を、次の値が<bpt i="3" x="3">&lt;c3&gt;</bpt>end<ept i="3">&lt;/c3&gt;</ept>を越えることになるまで加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Starting with <bpt i="1" x="1">&lt;c1&gt;</bpt>start<ept i="1">&lt;/c1&gt;</ept>, each successive value of the sequence adds <bpt i="2" x="2">&lt;c2&gt;</bpt>stride<ept i="2">&lt;/c2&gt;</ept> until the next value would be equal to or beyond <bpt i="3" x="3">&lt;c3&gt;</bpt>end<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>start<ept i="1">&lt;/c1&gt;</ept>で開始して、シーケンスのそれぞれ次の値は<bpt i="2" x="2">&lt;c2&gt;</bpt>stride<ept i="2">&lt;/c2&gt;</ept>を、次の値が<bpt i="3" x="3">&lt;c3&gt;</bpt>end<ept i="3">&lt;/c3&gt;</ept>に等しいか越えるまで加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Starts a new scope in which a dynamic number of throwing tasks can be created.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいタスクグループを開始します、それにおいて動的な数のスローするタスクが作成されることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Starts a new task group which provides a scope in which a dynamic number of tasks may be created.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいタスクグループを開始します、それはあるスコープを提供しそれにおいて動的な数のタスクが作成されるかもしれないものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Storage for a vector of 16 floating-point values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>16浮動小数点値のベクターに対するストレージ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Storage for a vector of 16 integers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>16整数のベクターに対するストレージ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Storage for a vector of 32 floating-point values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>32浮動小数点値のベクターに対するストレージ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Storage for a vector of 32 integers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>32整数のベクターに対するストレージ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Storage for a vector of 64 floating-point values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>64浮動小数点値のベクターに対するストレージ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Storage for a vector of 64 integers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>64整数のベクターに対するストレージ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Storage for a vector of eight floating-point values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>８浮動小数点値のベクターに対するストレージ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Storage for a vector of eight integers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>８整数のベクターに対するストレージ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Storage for a vector of four floating-point values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>４浮動小数点値のベクターに対するストレージ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Storage for a vector of four integers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>4整数のベクターに対するストレージ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Storage for a vector of two floating-point values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２浮動小数点値のベクターに対するストレージ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Storage for a vector of two integers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２整数のベクターに対するストレージ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Stores the result of performing a bitwise AND operation on the two given values in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ビット単位AND演算を２つの与えられた値に関して実行する結果を左手側の変数に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Stores the result of performing a bitwise OR operation on the two given values in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ビット単位OR演算を２つの与えられた値に関して実行する結果を左手側の変数に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Stores the result of performing a bitwise XOR operation on the two given values in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ビット単位XOR演算を２つの与えられた値に関して実行する結果を左手側の変数に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Stores the result of shifting a value’s binary representation the specified number of digits to the left in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値のバイナリ表現を指定された桁数だけ左にシフトする結果を左手側の変数に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Stores the result of shifting a value’s binary representation the specified number of digits to the right in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値のバイナリ表現を指定された桁数だけ右にシフトする結果を左手側の変数に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Storing an unsafe task handle doesn’t have an impact on the task’s actual life cycle, and the behavior of accessing an unsafe task handle outside of the <bpt i="0" x="0">&lt;c0&gt;</bpt>with<bpt i="1" x="1">&lt;w1&gt;</bpt>Unsafe<bpt i="2" x="2">&lt;w2&gt;</bpt>Current<bpt i="3" x="3">&lt;w3&gt;</bpt>Task(body:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method’s closure isn’t defined.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>非安全タスクハンドルを格納することは、タスクのもつ実際のライフサイクルに影響を与えません、そして非安全タスクハンドルに<bpt i="0" x="0">&lt;c0&gt;</bpt>with<bpt i="1" x="1">&lt;w1&gt;</bpt>Unsafe<bpt i="2" x="2">&lt;w2&gt;</bpt>Current<bpt i="3" x="3">&lt;w3&gt;</bpt>Task(body:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドのもつクロージャの外側でアクセスすることの挙動は未定義です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Strideable Implementations</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Strideable実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Strides</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ストライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>String Literals</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>文字列リテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>String Representation</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>文字列表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>String<bpt i="0" x="0">&lt;w0&gt;</bpt>Protocol Implementations <ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>String<bpt i="0" x="0">&lt;w0&gt;</bpt>プロトコル実装<ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Strings and Characters</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>文字列と文字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Strings and Text</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>文字列とテキスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Strings are collections of <bpt i="2" x="2">&lt;c2&gt;</bpt>Character<ept i="2">&lt;/c2&gt;</ept> instances, so the number of visible characters is generally the most natural way to count the length of a string.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>文字列は、<bpt i="2" x="2">&lt;c2&gt;</bpt>Character<ept i="2">&lt;/c2&gt;</ept>インスタンスのコレクションです、なので見ることのできる文字の数はたいてい文字列の長さを数える最も自然な方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Strings in Swift conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept> protocol, so the names are sorted in ascending order according to the less-than operator (<bpt i="1" x="1">&lt;c1&gt;</bpt>&lt;<ept i="1">&lt;/c1&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>文字列はSwift では<bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠します、それでこれらの名前はより小さい演算子（<bpt i="1" x="1">&lt;c1&gt;</bpt>&lt;<ept i="1">&lt;/c1&gt;</ept>）によって昇順にソートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Structures</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>構造体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Structures and classes are good choices for storing data and modeling behavior in your apps, but their similarities can make it difficult to choose one over the other.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>構造体とクラスは、あなたのアプリにおけるデータ格納と挙動モデル化のための良い選択です、しかしそれらの類似点は他方より一方を選ぶのを難しくするかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Structures and classes both support a form of inheritance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>構造体とクラスは両方とも継承の形式をサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Structures and protocols can only adopt protocols; they can't inherit from classes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>構造体とプロトコルは、プロトコルの採用だけが可能です；それらはクラスから継承できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Structures in Swift include many features that are limited to classes in other languages: They can include stored properties, computed properties, and methods.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftでのさまざまな構造体は、他の言語ではクラスに限られる多くの機能を含みます：それらは格納プロパティ、計算プロパティ、そしてメソッドを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Structures with Default Values</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時の値を持つ構造体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Subnormal numbers are often called <bpt i="0" x="0">&lt;e0&gt;</bpt>denormal<ept i="0">&lt;/e0&gt;</ept> or <bpt i="1" x="1">&lt;e1&gt;</bpt>denormalized<ept i="1">&lt;/e1&gt;</ept>—these are different names for the same concept.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>サブノーマル数は、しばしば<bpt i="0" x="0">&lt;e0&gt;</bpt>デノーマル<ept i="0">&lt;/e0&gt;</ept>または<bpt i="1" x="1">&lt;e1&gt;</bpt>デノーマライズされた<ept i="1">&lt;/e1&gt;</ept>と呼ばれます—それらは同じ概念に対する異なる名前です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Subnormal values don’t use the full precision available to values of a type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>サブノーマル値は、ある型の値に利用可能な完全な精度を使うことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Subscripting a dictionary with a key returns an optional value, because a dictionary might not hold a value for the key that you use in the subscript.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるキーで辞書に添え字を使うことは、オプショナル値を返します、なぜなら辞書はあなたが添え字に使ったキーに対して値を保持しないかもしれないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Subscripting with a key takes the following form:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キーによる添え字は以下の形式をとります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Subscripting with a key, yielding an optional value:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キーによる添え字、オプショナル値を生じます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Subscripting with an index, yielding a key-value pair:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インデックスによる添え字、キー値ペアを生じます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Subscripts</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>添え字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Subtracts one value from another and produces their difference, rounded to a representable value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値をもう一方から減じて、それらの差を返します、表現可能な値へ丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Subtracts one value from another and produces their difference.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値をもう一方から減じて、それらの差を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Subtracts the second value from the first and stores the difference in the left-hand-side variable, rounding to a representable value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２番目の値を最初のものから減じて、その差を左手側の変数の中に格納します、表現可能な値へ丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Subtracts the second value from the first and stores the difference in the left-hand-side variable, wrapping any overflow.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２番目の値を最初のものから減じてその差を左手側の変数の中に格納します、あらゆるオーバーフローをラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Subtracts the second value from the first and stores the difference in the left-hand-side variable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２番目の値を最初のものから減じて、その差を左手側の変数の中に格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Such types are called global actor types, and can be applied to any declaration to specify that such types are isolated to that global actor type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのような型はグローバルアクター型と呼ばれます、そしてあらゆる宣言に適用されることでそのような型それらがそのグローバルアクター型と分離されることを指定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Supporting Functions</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>補助関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Supporting Types</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>支援を行う型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Suppose you are tasked with finding the first two days with absences in the session.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがこの学期において欠席者のある最初の２つの日付を見つける任務を負うと考えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Suppose you need to store a list of the names of students that are signed up for a class you’re teaching.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが生徒の名前のリストをしまっておく必要があると仮定してみましょう、それはあなたが教えているクラスに受講届けを出されるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Suspends the current task, then calls the given closure with a checked continuation for the current task.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>現在のタスクを中断します、それからこの与えられたクロージャを、現在のタスクに対する検査済み継続で呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Suspends the current task, then calls the given closure with a checked throwing continuation for the current task.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>現在のタスクを中断します、それからこの与えられたクロージャを、現在のタスクに対する検査済みスロー継続で呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Suspends the current task, then calls the given closure with an unsafe continuation for the current task.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>現在のタスクを中断します、それからこの与えられたクロージャを、現在のタスクに対する安全でない継続で呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Suspends the current task, then calls the given closure with an unsafe throwing continuation for the current task.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>現在のタスクを中断します、それからこの与えられたクロージャを、現在のタスクに対する安全でないスロー継続で呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift 5.5 and later automatically translates Objective-C methods that take completion handlers into asynchronous methods using Swift's native concurrency support, in addition to importing the callback-based version of the method into Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swift 5.5以降は、完了ハンドラをとるObjective-Cメソッドを非同期メソッドへとSwiftの生得の並行性サポートを使って自動的に翻訳します、そのメソッドのコールバック基盤バージョンをSwiftへとインポートするのに加えて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift Standard Library</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swift標準ライブラリ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift Standard Library Functions</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swift標準ライブラリ関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift Syntax</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>スウィフト構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift and Objective-C in the Same Project</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同じプロジェクトの中のSwiftとObjective-C</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift automatically imports simple, constant-like macros, declared with the <bpt i="0" x="0">&lt;c0&gt;</bpt>#define<ept i="0">&lt;/c0&gt;</ept> directive, as global constants.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftは自動的に簡単に、<bpt i="0" x="0">&lt;c0&gt;</bpt>#define<ept i="0">&lt;/c0&gt;</ept>で宣言される、定数のようなマクロをグローバル定数としてインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift automatically translates Objective-C methods that produce errors into methods that throw an error according to Swift’s native error handling functionality.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>スウィフトは、自動的にエラーを生成するObjective-Cメソッドを、スウィフト固有のエラー処理機能に従ってエラーをスローするメソッドに翻訳します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift deliberately avoids using the term “epsilon” because:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftは、故意に用語 “イプシロン” を使うのを避けます、なぜなら：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift ensures your code is fast and efficient, while its memory safety and native error handling make the language safe by design.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftは、あなたのコードが高速で効率的であるのを受け合う一方で、それのメモリ安全と生得のエラー処理は言語を計画的に安全にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift examines Objective-C method declarations and translates them into Swift throwing methods, with shorter names when possible.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftは、Objective-Cメソッド宣言を調べて、それらをSwiftスローメソッドへと、可能な場合はより短い名前で翻訳します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift imports C unions as Swift structures.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>スウィフトは、C共用体をスウィフト構造体としてインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift imports Cocoa methods with error parameters as throwing methods, as described in <bpt i="3" x="3">&lt;a3&gt;</bpt>About Imported Cocoa Error Parameters<ept i="3">&lt;/a3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftは、エラーパラメータを持つCocoaメソッドをスローメソッドとしてインポートします、<bpt i="3" x="3">&lt;a3&gt;</bpt>インポートされるCocoaエラーパラメータについて<ept i="3">&lt;/a3&gt;</ept>で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift imports Objective-C methods that take a completion handler as two related Swift methods: a method that takes a closure, and an asynchronous method that doesn’t take a closure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftは、完了ハンドラをとるObjective-Cメソッドを２つの同族のSwiftメソッド：あるクロージャをとるメソッド、そしてクロージャをとらない非同期メソッドとしてインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift imports any C structure declared in a C header as a Swift structure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>スウィフトは、Cヘッダにおいて宣言されるどんなC構造体もスウィフト構造体としてインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift imports any function declared in a C header as a Swift global function.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>スウィフトは、Cヘッダにおいて宣言されるどんな関数もスウィフトのグローバルな関数としてインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift imports bit fields that are declared in structures, like those found in Foundation’s <bpt i="0" x="0">&lt;c0&gt;</bpt>NSDecimal<ept i="0">&lt;/c0&gt;</ept> type, as computed properties.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftは、構造体において宣言されるビットフィールド、Foundationの<bpt i="0" x="0">&lt;c0&gt;</bpt>NSDecimal<ept i="0">&lt;/c0&gt;</ept>型において見つけられるそれらに似たもの、を計算プロパティとしてインポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift includes modern features like type inference, optionals, and closures, which make the syntax concise yet expressive.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftは、型推論、オプショナル、そしてクロージャのような、モダンな機能を含みます、それは構文を簡潔にその上さらに表現豊かにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift is developed in the open.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftは、オープンに開発されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift makes it easy to create arrays in your code using an array literal: simply surround a comma-separated list of values with square brackets.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftはあなたのコードにおいて配列の作成を配列リテラルを使って簡単にします：単純にコンマ区切りの値のリストを角括弧で囲んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift numeric types (<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>Float<ept i="1">&lt;/c1&gt;</ept>, and so on)</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swift数値型（<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>Float<ept i="1">&lt;/c1&gt;</ept>、など）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift only imports C variadic functions that use a <bpt i="0" x="0">&lt;c0&gt;</bpt>va<bpt i="1" x="1">&lt;w1&gt;</bpt>_list<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> for their arguments.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftは、C可変長引数関数で、<bpt i="0" x="0">&lt;c0&gt;</bpt>va<bpt i="1" x="1">&lt;w1&gt;</bpt>_list<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をそれの引数として使うものをインポートするだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift provides a default debugging textual representation for any type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftは、省略時のデバッグ用テキスト表現をあらゆる型に提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift sees every header you expose publicly in your umbrella header.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftは、あなたがパブリックにあなたのアンブレラヘッダにおいて露出するすべてのヘッダを見ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift uses only simple Boolean values in conditional contexts to help avoid accidental programming errors and to help maintain the clarity of each control statement.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftは、単純なブール値だけを条件文脈において使用することによって、思いがけないプログラミングエラーを防ぐのを助けます、そして各制御文の明瞭性を保つのを助けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift value type</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swift値型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift will automatically use <bpt i="10" x="10">&lt;c10&gt;</bpt>Default<bpt i="11" x="11">&lt;w11&gt;</bpt>String<bpt i="12" x="12">&lt;w12&gt;</bpt>Interpolation<ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> as the interpolation type and provide an implementation for <bpt i="13" x="13">&lt;c13&gt;</bpt>init(string<bpt i="14" x="14">&lt;w14&gt;</bpt>Interpolation:)<ept i="14">&lt;/w14&gt;</ept><ept i="13">&lt;/c13&gt;</ept> that passes the interpolated literal’s contents to <bpt i="15" x="15">&lt;c15&gt;</bpt>init(string<bpt i="16" x="16">&lt;w16&gt;</bpt>Literal:)<ept i="16">&lt;/w16&gt;</ept><ept i="15">&lt;/c15&gt;</ept>, so you don’t need to implement anything specific to this protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftは、自動的に<bpt i="10" x="10">&lt;c10&gt;</bpt>Default<bpt i="11" x="11">&lt;w11&gt;</bpt>String<bpt i="12" x="12">&lt;w12&gt;</bpt>Interpolation<ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>を補間型として使います、そして<bpt i="13" x="13">&lt;c13&gt;</bpt>init(string<bpt i="14" x="14">&lt;w14&gt;</bpt>Interpolation:)<ept i="14">&lt;/w14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>に対する実装を提供し、それは補間されたリテラルの内容を<bpt i="15" x="15">&lt;c15&gt;</bpt>init(string<bpt i="16" x="16">&lt;w16&gt;</bpt>Literal:)<ept i="16">&lt;/w16&gt;</ept><ept i="15">&lt;/c15&gt;</ept>に渡します、それであなたはこのプロトコルに特有な何かを実装する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift wraps these returned Core Foundation objects in an <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>Unmanaged<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>&lt;Instance&gt;<ept i="2">&lt;/c2&gt;</ept> structure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftは、これらの返されたCore Foundationオブジェクトを <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>Unmanaged<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept><bpt i="2" x="2">&lt;c2&gt;</bpt>&lt;Instance&gt;<ept i="2">&lt;/c2&gt;</ept>構造体でラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Swift’s enumerations are well suited to represent simple errors.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftの列挙は、単純なエラーを表すのによく適します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Task Group Cancellation</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>タスクグループ取り消し</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Testing</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>テスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>That continuation is Sendable, in that it is intended to be used from concurrent contexts external to the iteration of the AsyncStream.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その継続は、それがAsyncStreamの反復に関係ない並行性文脈から使われるよう意図されるという点でSendableです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>That default representation is used by the <bpt i="0" x="0">&lt;c0&gt;</bpt>String(reflecting:)<ept i="0">&lt;/c0&gt;</ept> initializer and the <bpt i="1" x="1">&lt;c1&gt;</bpt>debug<bpt i="2" x="2">&lt;w2&gt;</bpt>Print(_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> function for types that don’t provide their own.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時の表現は、<bpt i="0" x="0">&lt;c0&gt;</bpt>String(reflecting:)<ept i="0">&lt;/c0&gt;</ept>イニシャライザおよび<bpt i="1" x="1">&lt;c1&gt;</bpt>debug<bpt i="2" x="2">&lt;w2&gt;</bpt>Print(_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>関数によって、それらが自前で提供しない型に対して使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>That is, <bpt i="3" x="3">&lt;c3&gt;</bpt>bit<bpt i="4" x="4">&lt;w4&gt;</bpt>Pattern % Memory<bpt i="5" x="5">&lt;w5&gt;</bpt>Layout&lt;Pointee&gt;.alignment<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> must be <bpt i="6" x="6">&lt;c6&gt;</bpt>0<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>すなわち、<bpt i="3" x="3">&lt;c3&gt;</bpt>bit<bpt i="4" x="4">&lt;w4&gt;</bpt>Pattern % Memory<bpt i="5" x="5">&lt;w5&gt;</bpt>Layout&lt;Pointee&gt;.alignment<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は、<bpt i="6" x="6">&lt;c6&gt;</bpt>0<ept i="6">&lt;/c6&gt;</ept>でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>That is, for any elements <bpt i="1" x="1">&lt;c1&gt;</bpt>a<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>b<ept i="2">&lt;/c2&gt;</ept>, and <bpt i="3" x="3">&lt;c3&gt;</bpt>c<ept i="3">&lt;/c3&gt;</ept>, the following conditions must hold:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>すなわち、何らかの要素<bpt i="1" x="1">&lt;c1&gt;</bpt>a<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>b<ept i="2">&lt;/c2&gt;</ept>、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>c<ept i="3">&lt;/c3&gt;</ept>に対して、以下の条件が保持されなければなりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>That is, for any elements <bpt i="5" x="5">&lt;c5&gt;</bpt>a<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>b<ept i="6">&lt;/c6&gt;</ept>, and <bpt i="7" x="7">&lt;c7&gt;</bpt>c<ept i="7">&lt;/c7&gt;</ept>, the following conditions must hold:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>すなわち、何らかの要素<bpt i="5" x="5">&lt;c5&gt;</bpt>a<ept i="5">&lt;/c5&gt;</ept>、<bpt i="6" x="6">&lt;c6&gt;</bpt>b<ept i="6">&lt;/c6&gt;</ept>、そして<bpt i="7" x="7">&lt;c7&gt;</bpt>c<ept i="7">&lt;/c7&gt;</ept>に対して、以下の条件が保持されなければなりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>That is, for any index <bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept> into a bidirectional collection <bpt i="1" x="1">&lt;c1&gt;</bpt>c<ept i="1">&lt;/c1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>すなわち、二方向性のコレクション<bpt i="1" x="1">&lt;c1&gt;</bpt>c<ept i="1">&lt;/c1&gt;</ept>に対する何らかのインデックス<bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept>は：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>That is, if <bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept> is an instance of <bpt i="2" x="2">&lt;c2&gt;</bpt>Double<ept i="2">&lt;/c2&gt;</ept>, then <bpt i="3" x="3">&lt;c3&gt;</bpt>Double(x<bpt i="4" x="4">&lt;w4&gt;</bpt>.description) == x<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is always true.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>すなわち、<bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Double<ept i="2">&lt;/c2&gt;</ept>のインスタンスならば、そのとき<bpt i="3" x="3">&lt;c3&gt;</bpt>Double(x<bpt i="4" x="4">&lt;w4&gt;</bpt>.description) == x<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は常に真です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>That is, if <bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept> is an instance of <bpt i="2" x="2">&lt;c2&gt;</bpt>Float16<ept i="2">&lt;/c2&gt;</ept>, then <bpt i="3" x="3">&lt;c3&gt;</bpt>Float16(x<bpt i="4" x="4">&lt;w4&gt;</bpt>.description) == x<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is always true.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>すなわち、<bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Float16<ept i="2">&lt;/c2&gt;</ept>のインスタンスならば、そのとき<bpt i="3" x="3">&lt;c3&gt;</bpt>Float16(x<bpt i="4" x="4">&lt;w4&gt;</bpt>.description) == x<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は常に真です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>That is, if <bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept> is an instance of <bpt i="2" x="2">&lt;c2&gt;</bpt>Float80<ept i="2">&lt;/c2&gt;</ept>, then <bpt i="3" x="3">&lt;c3&gt;</bpt>Float80(x<bpt i="4" x="4">&lt;w4&gt;</bpt>.description) == x<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is always true.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>すなわち、<bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Float80<ept i="2">&lt;/c2&gt;</ept>のインスタンスならば、そのとき<bpt i="3" x="3">&lt;c3&gt;</bpt>Float80(x<bpt i="4" x="4">&lt;w4&gt;</bpt>.description) == x<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は常に真です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>That is, if <bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept> is an instance of <bpt i="2" x="2">&lt;c2&gt;</bpt>Float<ept i="2">&lt;/c2&gt;</ept>, then <bpt i="3" x="3">&lt;c3&gt;</bpt>Float(x<bpt i="4" x="4">&lt;w4&gt;</bpt>.description) == x<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> is always true.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>すなわち、<bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>Float<ept i="2">&lt;/c2&gt;</ept>のインスタンスならば、そのとき<bpt i="3" x="3">&lt;c3&gt;</bpt>Float(x<bpt i="4" x="4">&lt;w4&gt;</bpt>.description) == x<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は常に真です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>That is, if <bpt i="2" x="2">&lt;c2&gt;</bpt>source<ept i="2">&lt;/c2&gt;</ept> is negative, the result is padded with ones; otherwise, the result is padded with zeros.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>すなわち、<bpt i="2" x="2">&lt;c2&gt;</bpt>source<ept i="2">&lt;/c2&gt;</ept>が負ならば、結果は１で詰め物をされます；そうでなければ、結果はゼロで詰め物をされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>That is, when working with a slice of a mutable collection that has value semantics, such as an array, mutating the original collection triggers a copy of that collection and does not affect the contents of the slice.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>すなわち、値意味論を持つ可変コレクション、例えば配列などのスライスを扱う場合、元のコレクションを変化させることはそのコレクションのコピーを引き起こし、スライスの内容に作用しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>That method call automatically triggers the observer's change handler:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのメソッド呼び出しは、自動的にオブザーバの持つ変更ハンドラを誘発します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>That same value is too large to represent as an <bpt i="3" x="3">&lt;c3&gt;</bpt>Int8<ept i="3">&lt;/c3&gt;</ept> instance, so the second conversion fails, triggering a runtime error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その同じ値は、<bpt i="3" x="3">&lt;c3&gt;</bpt>Int8<ept i="3">&lt;/c3&gt;</ept>インスタンスとして表すには大きすぎます、それで２番目の変換は、実行時エラーを引き起こして失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>That way, Swift can handle memory management for you.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのように、スウィフトはあなたの代わりにメモリ管理をうまく取り扱うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>That will ensure that <bpt i="2" x="2">&lt;c2&gt;</bpt>is<bpt i="3" x="3">&lt;w3&gt;</bpt>Known<bpt i="4" x="4">&lt;w4&gt;</bpt>Uniquely<bpt i="5" x="5">&lt;w5&gt;</bpt>Referenced(_:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> only returns <bpt i="6" x="6">&lt;c6&gt;</bpt>true<ept i="6">&lt;/c6&gt;</ept> when there is really one accessor, or when there is a race condition, which is already undefined behavior.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それは<bpt i="2" x="2">&lt;c2&gt;</bpt>is<bpt i="3" x="3">&lt;w3&gt;</bpt>Known<bpt i="4" x="4">&lt;w4&gt;</bpt>Uniquely<bpt i="5" x="5">&lt;w5&gt;</bpt>Referenced(_:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>が本当に１つのアクセッサしかない時に、またはすでに未定義挙動であるところの競合状態の時に<bpt i="6" x="6">&lt;c6&gt;</bpt>true<ept i="6">&lt;/c6&gt;</ept>を返すだけであるのを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;a0&gt;</bpt>IEEE 754 specification<ept i="0">&lt;/a0&gt;</ept> defines a <bpt i="1" x="1">&lt;e1&gt;</bpt>canonical<ept i="1">&lt;/e1&gt;</ept>, or preferred, encoding of a floating-point value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;a0&gt;</bpt>IEEE 754仕様<ept i="0">&lt;/a0&gt;</ept>は、ある<bpt i="1" x="1">&lt;e1&gt;</bpt>正準の<ept i="1">&lt;/e1&gt;</ept>、または推奨の、浮動小数点値のエンコーディングを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;&lt;&lt;=<ept i="0">&lt;/c0&gt;</ept> operator performs a <bpt i="1" x="1">&lt;e1&gt;</bpt>masking shift<ept i="1">&lt;/e1&gt;</ept>, where the value used as <bpt i="2" x="2">&lt;c2&gt;</bpt>rhs<ept i="2">&lt;/c2&gt;</ept> is masked to produce a value in the range <bpt i="3" x="3">&lt;c3&gt;</bpt>0..<it pos="begin" x="4">&lt;lhs&lt;w4&gt;</it>.bit<bpt i="5" x="5">&lt;w5&gt;</bpt>Width<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;&lt;&lt;=<ept i="0">&lt;/c0&gt;</ept>演算子は、<bpt i="1" x="1">&lt;e1&gt;</bpt>マスクするシフト<ept i="1">&lt;/e1&gt;</ept>を実行します、そこにおいて<bpt i="2" x="2">&lt;c2&gt;</bpt>rhs<ept i="2">&lt;/c2&gt;</ept>として使われる値はマスクされることで範囲<bpt i="3" x="3">&lt;c3&gt;</bpt>0..<it pos="begin" x="4">&lt;lhs&lt;w4&gt;</it>.bit<bpt i="5" x="5">&lt;w5&gt;</bpt>Width<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>の中の値を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;&gt;&gt;=<ept i="0">&lt;/c0&gt;</ept> operator performs a <bpt i="1" x="1">&lt;e1&gt;</bpt>masking shift<ept i="1">&lt;/e1&gt;</ept>, where the value passed as <bpt i="2" x="2">&lt;c2&gt;</bpt>rhs<ept i="2">&lt;/c2&gt;</ept> is masked to produce a value in the range <bpt i="3" x="3">&lt;c3&gt;</bpt>0..<it pos="begin" x="4">&lt;lhs&lt;w4&gt;</it>.bit<bpt i="5" x="5">&lt;w5&gt;</bpt>Width<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;&gt;&gt;=<ept i="0">&lt;/c0&gt;</ept>演算子は、<bpt i="1" x="1">&lt;e1&gt;</bpt>マスクするシフト<ept i="1">&lt;/e1&gt;</ept>を実行します、そこにおいて<bpt i="2" x="2">&lt;c2&gt;</bpt>rhs<ept i="2">&lt;/c2&gt;</ept>として渡される値はマスクされることで範囲<bpt i="3" x="3">&lt;c3&gt;</bpt>0..<it pos="begin" x="4">&lt;lhs&lt;w4&gt;</it>.bit<bpt i="5" x="5">&lt;w5&gt;</bpt>Width<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>の中の値を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>*<ept i="0">&lt;/c0&gt;</ept> operator implements the multiplication operation defined by the <bpt i="1" x="1">&lt;a1&gt;</bpt>IEEE 754 specification<ept i="1">&lt;/a1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>*<ept i="0">&lt;/c0&gt;</ept>演算子は、<bpt i="1" x="1">&lt;a1&gt;</bpt>IEEE 754 仕様<ept i="1">&lt;/a1&gt;</ept>によって定義される乗算演算子を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>+<ept i="0">&lt;/c0&gt;</ept> operator implements the addition operation defined by the <bpt i="1" x="1">&lt;a1&gt;</bpt>IEEE 754 specification<ept i="1">&lt;/a1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>+<ept i="0">&lt;/c0&gt;</ept>演算子は、<bpt i="1" x="1">&lt;a1&gt;</bpt>IEEE 754 仕様<ept i="1">&lt;/a1&gt;</ept>によって定義される加算演算子を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>-<ept i="0">&lt;/c0&gt;</ept> operator implements the subtraction operation defined by the <bpt i="1" x="1">&lt;a1&gt;</bpt>IEEE 754 specification<ept i="1">&lt;/a1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>-<ept i="0">&lt;/c0&gt;</ept>演算子は、<bpt i="1" x="1">&lt;a1&gt;</bpt>IEEE 754 仕様<ept i="1">&lt;/a1&gt;</ept>によって定義される減算演算子を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>/<ept i="0">&lt;/c0&gt;</ept> operator implements the division operation defined by the <bpt i="1" x="1">&lt;a1&gt;</bpt>IEEE 754 specification<ept i="1">&lt;/a1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>/<ept i="0">&lt;/c0&gt;</ept>演算子は、<bpt i="1" x="1">&lt;a1&gt;</bpt>IEEE 754 仕様<ept i="1">&lt;/a1&gt;</ept>によって定義される除算演算子を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;&lt;<ept i="0">&lt;/c0&gt;</ept> operator performs a <bpt i="1" x="1">&lt;e1&gt;</bpt>smart shift<ept i="1">&lt;/e1&gt;</ept>, which defines a result for a shift of any value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;&lt;<ept i="0">&lt;/c0&gt;</ept>演算子は、ある<bpt i="1" x="1">&lt;e1&gt;</bpt>賢いシフト<ept i="1">&lt;/e1&gt;</ept>を実行します、それは何らかの値のシフトに対する結果を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept> comparison and the <bpt i="1" x="1">&lt;c1&gt;</bpt>contains(_:)<ept i="1">&lt;/c1&gt;</ept> method call in the following example depend on strings and integers being equatable:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept>比較と<bpt i="1" x="1">&lt;c1&gt;</bpt>contains(_:)<ept i="1">&lt;/c1&gt;</ept>メソッド呼び出しは以下の例において、文字列と整数がequatableであることに依存します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>&gt;&gt;<ept i="0">&lt;/c0&gt;</ept> operator performs a <bpt i="1" x="1">&lt;e1&gt;</bpt>smart shift<ept i="1">&lt;/e1&gt;</ept>, which defines a result for a shift of any value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>&gt;&gt;<ept i="0">&lt;/c0&gt;</ept>演算子は、ある<bpt i="1" x="1">&lt;e1&gt;</bpt>賢いシフト<ept i="1">&lt;/e1&gt;</ept>を実行します、それは何らかの値のシフトに対する結果を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>&gt;&gt;=<ept i="0">&lt;/c0&gt;</ept> operator performs a <bpt i="1" x="1">&lt;e1&gt;</bpt>smart shift<ept i="1">&lt;/e1&gt;</ept>, which defines a result for a shift of any value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>&gt;&gt;=<ept i="0">&lt;/c0&gt;</ept>演算子は、ある<bpt i="1" x="1">&lt;e1&gt;</bpt>賢いシフト<ept i="1">&lt;/e1&gt;</ept>を実行します、それは何らかの値のシフトに対する結果を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Actor<ept i="0">&lt;/c0&gt;</ept> protocol generalizes over all actor types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Actor<ept i="0">&lt;/c0&gt;</ept>プロトコルは、アクター型を端から端まで一般化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Additive<bpt i="1" x="1">&lt;w1&gt;</bpt>Arithmetic<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol provides a suitable basis for additive arithmetic on scalar values, such as integers and floating-point numbers, or vectors.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Additive<bpt i="1" x="1">&lt;w1&gt;</bpt>Arithmetic<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルは、例えば整数および浮動小数点数、またはベクターなど、スカラー値に関する加算算術にふさわしい基礎を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Hashable<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type forwards equality comparisons and hashing operations to an underlying hashable value, hiding the type of the wrapped value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Hashable<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型は、さまざまな同等性比較およびハッシュ演算をある基盤をなすハッシュ可能値に転送して、ラップされた値の型を隠しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Array<bpt i="1" x="1">&lt;w1&gt;</bpt>Slice<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type makes it fast and efficient for you to perform operations on sections of a larger array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Array<bpt i="1" x="1">&lt;w1&gt;</bpt>Slice<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型は、ある大きな配列の各部分上で演算を実行することをあなたの代わりにより速くより効率的にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Async<bpt i="1" x="1">&lt;w1&gt;</bpt>Iterator<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> defines the type returned by the <bpt i="3" x="3">&lt;c3&gt;</bpt>make<bpt i="4" x="4">&lt;w4&gt;</bpt>Async<bpt i="5" x="5">&lt;w5&gt;</bpt>Iterator()<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> method of the <bpt i="6" x="6">&lt;c6&gt;</bpt>Async<bpt i="7" x="7">&lt;w7&gt;</bpt>Sequence<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Async<bpt i="1" x="1">&lt;w1&gt;</bpt>Iterator<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、<bpt i="6" x="6">&lt;c6&gt;</bpt>Async<bpt i="7" x="7">&lt;w7&gt;</bpt>Sequence<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>プロトコルの<bpt i="3" x="3">&lt;c3&gt;</bpt>make<bpt i="4" x="4">&lt;w4&gt;</bpt>Async<bpt i="5" x="5">&lt;w5&gt;</bpt>Iterator()<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>メソッドによって返される型を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Floating<bpt i="2" x="2">&lt;w2&gt;</bpt>Point<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol extends the <bpt i="3" x="3">&lt;c3&gt;</bpt>Floating<bpt i="4" x="4">&lt;w4&gt;</bpt>Point<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> protocol with operations specific to floating-point binary types, as defined by the <bpt i="5" x="5">&lt;a5&gt;</bpt>IEEE 754 specification<ept i="5">&lt;/a5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Floating<bpt i="2" x="2">&lt;w2&gt;</bpt>Point<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルは、<bpt i="3" x="3">&lt;c3&gt;</bpt>Floating<bpt i="4" x="4">&lt;w4&gt;</bpt>Point<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>プロトコルを、<bpt i="5" x="5">&lt;a5&gt;</bpt>IEEE 754仕様<ept i="5">&lt;/a5&gt;</ept>で定義されるとおりに、浮動小数点バイナリ型に特有の演算で拡張します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Integer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol is the basis for all the integer types provided by the standard library.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Integer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルは、標準ライブラリによって提供される全ての整数型の土台です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept> type represents a character made up of one or more Unicode scalar values, grouped by a Unicode boundary algorithm.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept>型は、あるユニコード境界アルゴリズムによって一群にされる、ひとつ以上のユニコードスカラー値から成り立っている１つの文字を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<ept i="0">&lt;/c0&gt;</ept> protocol declares and provides default implementations for many operations that depend on elements being accessible by their subscript.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<ept i="0">&lt;/c0&gt;</ept>プロトコルは、多くの演算に対して省略時の実装を宣言および提供していて、それは要素がそれらの添え字によってアクセス可能になっているのを当てにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<bpt i="1" x="1">&lt;w1&gt;</bpt>Of<bpt i="2" x="2">&lt;w2&gt;</bpt>Two<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> structure is a fixed-size collection that always holds two elements of a specific type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この<bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<bpt i="1" x="1">&lt;w1&gt;</bpt>Of<bpt i="2" x="2">&lt;w2&gt;</bpt>Two<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>構造体は固定サイズのコレクションです、それは常にある決まった型の２つの要素を保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept> protocol is used for types that have an inherent order, such as numbers and strings.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept>プロトコルは、本来備わっている順番を持つ型、例えば数や文字列などで使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Contiguous<bpt i="1" x="1">&lt;w1&gt;</bpt>Array<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>Array<bpt i="3" x="3">&lt;w3&gt;</bpt>Slice<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> types are not bridged; instances of those types always have a contiguous block of memory as their storage.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Contiguous<bpt i="1" x="1">&lt;w1&gt;</bpt>Array<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>Array<bpt i="3" x="3">&lt;w3&gt;</bpt>Slice<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型はブリッジされません；それらの型のインスタンスは常に隣接するメモリブロックをそれらのストレージとして持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Contiguous<bpt i="1" x="1">&lt;w1&gt;</bpt>Array<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type is a specialized array that always stores its elements in a contiguous region of memory.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Contiguous<bpt i="1" x="1">&lt;w1&gt;</bpt>Array<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、それの要素がメモリの隣接領域に常に格納される特殊化された配列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Fixed<bpt i="1" x="1">&lt;w1&gt;</bpt>Width<bpt i="2" x="2">&lt;w2&gt;</bpt>Integer<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol adds binary bitwise operations, bit shifts, and overflow handling to the operations supported by the <bpt i="3" x="3">&lt;c3&gt;</bpt>Binary<bpt i="4" x="4">&lt;w4&gt;</bpt>Integer<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Fixed<bpt i="1" x="1">&lt;w1&gt;</bpt>Width<bpt i="2" x="2">&lt;w2&gt;</bpt>Integer<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルは、バイナリビット単位演算子、ビットシフト、そしてオーバーフロー処理を、<bpt i="3" x="3">&lt;c3&gt;</bpt>Binary<bpt i="4" x="4">&lt;w4&gt;</bpt>Integer<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>プロトコルによってサポートされる演算に加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Floating<bpt i="1" x="1">&lt;w1&gt;</bpt>Point<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol declares common arithmetic operations, so you can write functions and algorithms that work on any floating-point type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Floating<bpt i="1" x="1">&lt;w1&gt;</bpt>Point<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルは通常の算術演算子を宣言します、それであなたは何らかの浮動小数点型上で働く関数およびアルゴリズムを書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Indexing<bpt i="1" x="1">&lt;w1&gt;</bpt>Iterator<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type is the default iterator for any collection that doesn’t declare its own.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Indexing<bpt i="1" x="1">&lt;w1&gt;</bpt>Iterator<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型は、それ独自のものを宣言しないあらゆるコレクションに対する省略時のイテレータです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>NO<ept i="0">&lt;/c0&gt;</ept> macro from Objective-C is bridged to Swift as an <bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>Obj<bpt i="3" x="3">&lt;w3&gt;</bpt>CBool<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept> value of <bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-Cからの<bpt i="0" x="0">&lt;c0&gt;</bpt>NO<ept i="0">&lt;/c0&gt;</ept>マクロは、<bpt i="4" x="4">&lt;c4&gt;</bpt>false<ept i="4">&lt;/c4&gt;</ept>の<bpt i="1" x="1">&lt;a1&gt;</bpt><bpt i="2" x="2">&lt;c2&gt;</bpt>Obj<bpt i="3" x="3">&lt;w3&gt;</bpt>CBool<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept><ept i="1">&lt;/a1&gt;</ept>値としてSwiftにブリッジされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Player<ept i="0">&lt;/c0&gt;</ept> type is a class, so it doesn't qualify for automatic synthesis of the <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt>Hashable<ept i="2">&lt;/c2&gt;</ept> requirements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Player<ept i="0">&lt;/c0&gt;</ept>型はクラスです、なのでそれは<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>または<bpt i="2" x="2">&lt;c2&gt;</bpt>Hashable<ept i="2">&lt;/c2&gt;</ept>要件の自動的な合成の基準を満たしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Set<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Array<ept i="1">&lt;/c1&gt;</ept> types each handle array literals in their own way to create new instances.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Set<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>Array<ept i="1">&lt;/c1&gt;</ept>型は、それぞれ配列リテラルをそれら独自の方法で取り扱って、新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Street<bpt i="1" x="1">&lt;w1&gt;</bpt>Address<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type now conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt>Equatable<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Street<bpt i="1" x="1">&lt;w1&gt;</bpt>Address<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型は、今や<bpt i="2" x="2">&lt;c2&gt;</bpt>Equatable<ept i="2">&lt;/c2&gt;</ept>に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Static<bpt i="2" x="2">&lt;w2&gt;</bpt>String<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> types conform to the <bpt i="3" x="3">&lt;c3&gt;</bpt>Expressible<bpt i="4" x="4">&lt;w4&gt;</bpt>By<bpt i="5" x="5">&lt;w5&gt;</bpt>String<bpt i="6" x="6">&lt;w6&gt;</bpt>Literal<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>Static<bpt i="2" x="2">&lt;w2&gt;</bpt>String<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>型は、<bpt i="3" x="3">&lt;c3&gt;</bpt>Expressible<bpt i="4" x="4">&lt;w4&gt;</bpt>By<bpt i="5" x="5">&lt;w5&gt;</bpt>String<bpt i="6" x="6">&lt;w6&gt;</bpt>Literal<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>プロトコルに準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>Static<bpt i="2" x="2">&lt;w2&gt;</bpt>String<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>Character<ept i="3">&lt;/c3&gt;</ept>, and <bpt i="4" x="4">&lt;c4&gt;</bpt>Unicode<bpt i="5" x="5">&lt;w5&gt;</bpt>.Scalar<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> types all conform to the <bpt i="6" x="6">&lt;c6&gt;</bpt>Expressible<bpt i="7" x="7">&lt;w7&gt;</bpt>By<bpt i="8" x="8">&lt;w8&gt;</bpt>Unicode<bpt i="9" x="9">&lt;w9&gt;</bpt>Scalar<bpt i="10" x="10">&lt;w10&gt;</bpt>Literal<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>Static<bpt i="2" x="2">&lt;w2&gt;</bpt>String<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>Character<ept i="3">&lt;/c3&gt;</ept>、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>Unicode<bpt i="5" x="5">&lt;w5&gt;</bpt>.Scalar<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>型は、すべて<bpt i="6" x="6">&lt;c6&gt;</bpt>Expressible<bpt i="7" x="7">&lt;w7&gt;</bpt>By<bpt i="8" x="8">&lt;w8&gt;</bpt>Unicode<bpt i="9" x="9">&lt;w9&gt;</bpt>Scalar<bpt i="10" x="10">&lt;w10&gt;</bpt>Literal<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>プロトコルに準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>Static<bpt i="2" x="2">&lt;w2&gt;</bpt>String<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>, and <bpt i="3" x="3">&lt;c3&gt;</bpt>Character<ept i="3">&lt;/c3&gt;</ept> types conform to the <bpt i="4" x="4">&lt;c4&gt;</bpt>Expressible<bpt i="5" x="5">&lt;w5&gt;</bpt>By<bpt i="6" x="6">&lt;w6&gt;</bpt>Extended<bpt i="7" x="7">&lt;w7&gt;</bpt>Grapheme<bpt i="8" x="8">&lt;w8&gt;</bpt>Cluster<bpt i="9" x="9">&lt;w9&gt;</bpt>Literal<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>String<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>Static<bpt i="2" x="2">&lt;w2&gt;</bpt>String<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>Character<ept i="3">&lt;/c3&gt;</ept>型は、<bpt i="4" x="4">&lt;c4&gt;</bpt>Expressible<bpt i="5" x="5">&lt;w5&gt;</bpt>By<bpt i="6" x="6">&lt;w6&gt;</bpt>Extended<bpt i="7" x="7">&lt;w7&gt;</bpt>Grapheme<bpt i="8" x="8">&lt;w8&gt;</bpt>Cluster<bpt i="9" x="9">&lt;w9&gt;</bpt>Literal<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>プロトコルに準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>String<bpt i="1" x="1">&lt;w1&gt;</bpt>Literal<bpt i="2" x="2">&lt;w2&gt;</bpt>Type<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> of an interpolation type must match the <bpt i="3" x="3">&lt;c3&gt;</bpt>String<bpt i="4" x="4">&lt;w4&gt;</bpt>Literal<bpt i="5" x="5">&lt;w5&gt;</bpt>Type<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> of the conforming type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>補間型の<bpt i="0" x="0">&lt;c0&gt;</bpt>String<bpt i="1" x="1">&lt;w1&gt;</bpt>Literal<bpt i="2" x="2">&lt;w2&gt;</bpt>Type<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、準拠している型の<bpt i="3" x="3">&lt;c3&gt;</bpt>String<bpt i="4" x="4">&lt;w4&gt;</bpt>Literal<bpt i="5" x="5">&lt;w5&gt;</bpt>Type<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>と合致しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Unmanaged&lt;Instance&gt;<ept i="0">&lt;/c0&gt;</ept> structure provides two methods to convert an unmanaged object to a memory-managed object—<bpt i="1" x="1">&lt;c1&gt;</bpt>take<bpt i="2" x="2">&lt;w2&gt;</bpt>Unretained<bpt i="3" x="3">&lt;w3&gt;</bpt>Value()<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>take<bpt i="5" x="5">&lt;w5&gt;</bpt>Retained<bpt i="6" x="6">&lt;w6&gt;</bpt>Value()<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Unmanaged&lt;Instance&gt;<ept i="0">&lt;/c0&gt;</ept>構造体は、２つのメソッドを、管理されないオブジェクトをメモリ管理されたオブジェクトに変換するために提供します ― <bpt i="1" x="1">&lt;c1&gt;</bpt>take<bpt i="2" x="2">&lt;w2&gt;</bpt>Unretained<bpt i="3" x="3">&lt;w3&gt;</bpt>Value()<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>take<bpt i="5" x="5">&lt;w5&gt;</bpt>Retained<bpt i="6" x="6">&lt;w6&gt;</bpt>Value()<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>Words<ept i="0">&lt;/c0&gt;</ept> type must conform to the <bpt i="1" x="1">&lt;c1&gt;</bpt>Random<bpt i="2" x="2">&lt;w2&gt;</bpt>Access<bpt i="3" x="3">&lt;w3&gt;</bpt>Collection<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> protocol with an <bpt i="4" x="4">&lt;c4&gt;</bpt>Element<ept i="4">&lt;/c4&gt;</ept> type of <bpt i="5" x="5">&lt;c5&gt;</bpt>UInt<ept i="5">&lt;/c5&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt>Index<ept i="6">&lt;/c6&gt;</ept> type of <bpt i="7" x="7">&lt;c7&gt;</bpt>Int<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Words<ept i="0">&lt;/c0&gt;</ept>型は、<bpt i="1" x="1">&lt;c1&gt;</bpt>Random<bpt i="2" x="2">&lt;w2&gt;</bpt>Access<bpt i="3" x="3">&lt;w3&gt;</bpt>Collection<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>プロトコルに、<bpt i="5" x="5">&lt;c5&gt;</bpt>UInt<ept i="5">&lt;/c5&gt;</ept>の<bpt i="4" x="4">&lt;c4&gt;</bpt>Element<ept i="4">&lt;/c4&gt;</ept>型そして<bpt i="7" x="7">&lt;c7&gt;</bpt>Int<ept i="7">&lt;/c7&gt;</ept>の<bpt i="6" x="6">&lt;c6&gt;</bpt>Index<ept i="6">&lt;/c6&gt;</ept>型を使って準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>base<ept i="0">&lt;/c0&gt;</ept> property can be cast back to its original type using one of the type casting operators (<bpt i="1" x="1">&lt;c1&gt;</bpt>as?<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>as!<ept i="2">&lt;/c2&gt;</ept>, or <bpt i="3" x="3">&lt;c3&gt;</bpt>as<ept i="3">&lt;/c3&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>base<ept i="0">&lt;/c0&gt;</ept>プロパティは、それの元の型へキャストされて戻されることが型キャスト演算子（<bpt i="1" x="1">&lt;c1&gt;</bpt>as?<ept i="1">&lt;/c1&gt;</ept>、<bpt i="2" x="2">&lt;c2&gt;</bpt>as!<ept i="2">&lt;/c2&gt;</ept>、または<bpt i="3" x="3">&lt;c3&gt;</bpt>as<ept i="3">&lt;/c3&gt;</ept>）を使って可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>binary<bpt i="1" x="1">&lt;w1&gt;</bpt>String<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> implementation uses the static <bpt i="2" x="2">&lt;c2&gt;</bpt>bit<bpt i="3" x="3">&lt;w3&gt;</bpt>Width<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> property and the right shift operator (<bpt i="4" x="4">&lt;c4&gt;</bpt>&gt;&gt;<ept i="4">&lt;/c4&gt;</ept>), both of which are available to any type that conforms to the <bpt i="5" x="5">&lt;c5&gt;</bpt>Fixed<bpt i="6" x="6">&lt;w6&gt;</bpt>Width<bpt i="7" x="7">&lt;w7&gt;</bpt>Integer<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>binary<bpt i="1" x="1">&lt;w1&gt;</bpt>String<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>実装は、静的<bpt i="2" x="2">&lt;c2&gt;</bpt>bit<bpt i="3" x="3">&lt;w3&gt;</bpt>Width<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロパティと右シフト演算子（<bpt i="4" x="4">&lt;c4&gt;</bpt>&gt;&gt;<ept i="4">&lt;/c4&gt;</ept>）を使います、それらの両方とも<bpt i="5" x="5">&lt;c5&gt;</bpt>Fixed<bpt i="6" x="6">&lt;w6&gt;</bpt>Width<bpt i="7" x="7">&lt;w7&gt;</bpt>Integer<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>プロトコルに準拠するあらゆる型で使用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>exponent<ept i="0">&lt;/c0&gt;</ept> property has the following edge cases:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>exponent<ept i="0">&lt;/c0&gt;</ept>プロパティは、次の境界事例を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>first<bpt i="1" x="1">&lt;w1&gt;</bpt>Space<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> constant is an index into the <bpt i="2" x="2">&lt;c2&gt;</bpt>text<ept i="2">&lt;/c2&gt;</ept> string—the position of the first space in the string.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>first<bpt i="1" x="1">&lt;w1&gt;</bpt>Space<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>定数は、<bpt i="2" x="2">&lt;c2&gt;</bpt>text<ept i="2">&lt;/c2&gt;</ept>文字列へのあるインデックス — その文字列の中の最初の空白の位置、です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>get<bpt i="1" x="1">&lt;w1&gt;</bpt>Default<bpt i="2" x="2">&lt;w2&gt;</bpt>Value(_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function uses optional chaining to safely call the implicitly unwrapped class method on <bpt i="3" x="3">&lt;c3&gt;</bpt>c<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>get<bpt i="1" x="1">&lt;w1&gt;</bpt>Default<bpt i="2" x="2">&lt;w2&gt;</bpt>Value(_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数は、オプショナル連鎖を使って、暗黙的にアンラップされるクラスメソッドを<bpt i="3" x="3">&lt;c3&gt;</bpt>c<ept i="3">&lt;/c3&gt;</ept>上で安全に呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>hash(into:)<ept i="0">&lt;/c0&gt;</ept> method in this example feeds the grid point’s <bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>y<ept i="2">&lt;/c2&gt;</ept> properties into the provided hasher.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>hash(into:)<ept i="0">&lt;/c0&gt;</ept>メソッドはこの例において、格子点のもつ<bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>y<ept i="2">&lt;/c2&gt;</ept>プロパティをその提供されたhasherへと与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>high<ept i="0">&lt;/c0&gt;</ept> component of the value carries the sign, if the type is signed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値の<bpt i="0" x="0">&lt;c0&gt;</bpt>high<ept i="0">&lt;/c0&gt;</ept>構成部分は符号を運びます、その型が符号付きならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>index(after:)<ept i="0">&lt;/c0&gt;</ept> method for advancing an index into your collection</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるインデックスをあなたのコレクションにおいて前に進めるための<bpt i="0" x="0">&lt;c0&gt;</bpt>index(after:)<ept i="0">&lt;/c0&gt;</ept>メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>invalid<bpt i="1" x="1">&lt;w1&gt;</bpt>Input<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> case includes the invalid character as an associated value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>invalid<bpt i="1" x="1">&lt;w1&gt;</bpt>Input<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>ケース節は、無効な文字を関連値として含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Equal(to:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method implements the equality predicate defined by the <bpt i="2" x="2">&lt;a2&gt;</bpt>IEEE 754 specification<ept i="2">&lt;/a2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Equal(to:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドは、<bpt i="2" x="2">&lt;a2&gt;</bpt>IEEE 754仕様<ept i="2">&lt;/a2&gt;</ept>によって定義される同等性述部を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Known<bpt i="2" x="2">&lt;w2&gt;</bpt>Uniquely<bpt i="3" x="3">&lt;w3&gt;</bpt>Referenced(_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function is useful for implementing the copy-on-write optimization for the deep storage of value types:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Known<bpt i="2" x="2">&lt;w2&gt;</bpt>Uniquely<bpt i="3" x="3">&lt;w3&gt;</bpt>Referenced(_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数は、値型の深い貯蔵に対してコピーオンライト最適化を実装するのに便利です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Less(than:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method implements the less-than predicate defined by the <bpt i="2" x="2">&lt;a2&gt;</bpt>IEEE 754 specification<ept i="2">&lt;/a2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Less(than:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドは、<bpt i="2" x="2">&lt;a2&gt;</bpt>IEEE 754仕様<ept i="2">&lt;/a2&gt;</ept>によって定義される「より少ない」述部を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Less<bpt i="2" x="2">&lt;w2&gt;</bpt>Than<bpt i="3" x="3">&lt;w3&gt;</bpt>Or<bpt i="4" x="4">&lt;w4&gt;</bpt>Equal<bpt i="5" x="5">&lt;w5&gt;</bpt>To(_:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method implements the less-than-or-equal predicate defined by the <bpt i="6" x="6">&lt;a6&gt;</bpt>IEEE 754 specification<ept i="6">&lt;/a6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Less<bpt i="2" x="2">&lt;w2&gt;</bpt>Than<bpt i="3" x="3">&lt;w3&gt;</bpt>Or<bpt i="4" x="4">&lt;w4&gt;</bpt>Equal<bpt i="5" x="5">&lt;w5&gt;</bpt>To(_:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドは、<bpt i="6" x="6">&lt;a6&gt;</bpt>IEEE 754仕様<ept i="6">&lt;/a6&gt;</ept>によって定義される「より少ないか等しい」述部を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Totally<bpt i="2" x="2">&lt;w2&gt;</bpt>Ordered(below<bpt i="3" x="3">&lt;w3&gt;</bpt>Or<bpt i="4" x="4">&lt;w4&gt;</bpt>Equal<bpt i="5" x="5">&lt;w5&gt;</bpt>To:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method implements the total order relation as defined by the <bpt i="6" x="6">&lt;a6&gt;</bpt>IEEE 754 specification<ept i="6">&lt;/a6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Totally<bpt i="2" x="2">&lt;w2&gt;</bpt>Ordered(below<bpt i="3" x="3">&lt;w3&gt;</bpt>Or<bpt i="4" x="4">&lt;w4&gt;</bpt>Equal<bpt i="5" x="5">&lt;w5&gt;</bpt>To:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドは、全順序関係を<bpt i="6" x="6">&lt;a6&gt;</bpt>IEEE 754仕様<ept i="6">&lt;/a6&gt;</ept>によって定義されるとおりに実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Zero<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property of a value <bpt i="2" x="2">&lt;c2&gt;</bpt>x<ept i="2">&lt;/c2&gt;</ept> is <bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept> when <bpt i="4" x="4">&lt;c4&gt;</bpt>x<ept i="4">&lt;/c4&gt;</ept> represents either <bpt i="5" x="5">&lt;c5&gt;</bpt>-0<bpt i="6" x="6">&lt;w6&gt;</bpt>.0<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> or <bpt i="7" x="7">&lt;c7&gt;</bpt>+0<bpt i="8" x="8">&lt;w8&gt;</bpt>.0<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値<bpt i="2" x="2">&lt;c2&gt;</bpt>x<ept i="2">&lt;/c2&gt;</ept>の<bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Zero<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティが<bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept>であるのは、<bpt i="4" x="4">&lt;c4&gt;</bpt>x<ept i="4">&lt;/c4&gt;</ept>が<bpt i="5" x="5">&lt;c5&gt;</bpt>-0<bpt i="6" x="6">&lt;w6&gt;</bpt>.0<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>または<bpt i="7" x="7">&lt;c7&gt;</bpt>+0<bpt i="8" x="8">&lt;w8&gt;</bpt>.0<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>のどちらかを表す場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>joined<ept i="0">&lt;/c0&gt;</ept> method is always lazy, but does not implicitly confer laziness on algorithms applied to its result.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>joined<ept i="0">&lt;/c0&gt;</ept>メソッドは常に遅延です、しかしそれの結果に適用されるアルゴリズム上に、遅延性を暗黙的に授けられません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>maximum<ept i="0">&lt;/c0&gt;</ept> method implements the <bpt i="1" x="1">&lt;c1&gt;</bpt>max<bpt i="2" x="2">&lt;w2&gt;</bpt>Num<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> operation defined by the <bpt i="3" x="3">&lt;a3&gt;</bpt>IEEE 754 specification<ept i="3">&lt;/a3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>maximum<ept i="0">&lt;/c0&gt;</ept>メソッドは、<bpt i="3" x="3">&lt;a3&gt;</bpt>IEEE 754仕様<ept i="3">&lt;/a3&gt;</ept>によって定義される<bpt i="1" x="1">&lt;c1&gt;</bpt>max<bpt i="2" x="2">&lt;w2&gt;</bpt>Num<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>演算を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>maximum<bpt i="1" x="1">&lt;w1&gt;</bpt>Magnitude<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method implements the <bpt i="2" x="2">&lt;c2&gt;</bpt>max<bpt i="3" x="3">&lt;w3&gt;</bpt>Num<bpt i="4" x="4">&lt;w4&gt;</bpt>Mag<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> operation defined by the <bpt i="5" x="5">&lt;a5&gt;</bpt>IEEE 754 specification<ept i="5">&lt;/a5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>maximum<bpt i="1" x="1">&lt;w1&gt;</bpt>Magnitude<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドは、<bpt i="5" x="5">&lt;a5&gt;</bpt>IEEE 754仕様<ept i="5">&lt;/a5&gt;</ept>によって定義される<bpt i="2" x="2">&lt;c2&gt;</bpt>max<bpt i="3" x="3">&lt;w3&gt;</bpt>Num<bpt i="4" x="4">&lt;w4&gt;</bpt>Mag<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>演算を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>minimum<ept i="0">&lt;/c0&gt;</ept> method implements the <bpt i="1" x="1">&lt;c1&gt;</bpt>min<bpt i="2" x="2">&lt;w2&gt;</bpt>Num<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> operation defined by the <bpt i="3" x="3">&lt;a3&gt;</bpt>IEEE 754 specification<ept i="3">&lt;/a3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>minimum<ept i="0">&lt;/c0&gt;</ept>メソッドは<bpt i="1" x="1">&lt;c1&gt;</bpt>min<bpt i="2" x="2">&lt;w2&gt;</bpt>Num<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>演算を実装します、それは<bpt i="3" x="3">&lt;a3&gt;</bpt>IEEE 754仕様<ept i="3">&lt;/a3&gt;</ept>によって定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>minimum<bpt i="1" x="1">&lt;w1&gt;</bpt>Magnitude<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method implements the <bpt i="2" x="2">&lt;c2&gt;</bpt>min<bpt i="3" x="3">&lt;w3&gt;</bpt>Num<bpt i="4" x="4">&lt;w4&gt;</bpt>Mag<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> operation defined by the <bpt i="5" x="5">&lt;a5&gt;</bpt>IEEE 754 specification<ept i="5">&lt;/a5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>minimum<bpt i="1" x="1">&lt;w1&gt;</bpt>Magnitude<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドは、<bpt i="5" x="5">&lt;a5&gt;</bpt>IEEE 754仕様<ept i="5">&lt;/a5&gt;</ept>によって定義される<bpt i="2" x="2">&lt;c2&gt;</bpt>min<bpt i="3" x="3">&lt;w3&gt;</bpt>Num<bpt i="4" x="4">&lt;w4&gt;</bpt>Mag<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>演算を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>next<bpt i="1" x="1">&lt;w1&gt;</bpt>Partial<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> closure executes sequentially with an accumulating value initialized to <bpt i="3" x="3">&lt;c3&gt;</bpt>initial<bpt i="4" x="4">&lt;w4&gt;</bpt>Result<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> and each element of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>next<bpt i="1" x="1">&lt;w1&gt;</bpt>Partial<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>クロージャは、<bpt i="3" x="3">&lt;c3&gt;</bpt>initial<bpt i="4" x="4">&lt;w4&gt;</bpt>Result<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>へと初期化された蓄積値とそのシーケンスの各要素を使って連続して遂行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>next<bpt i="1" x="1">&lt;w1&gt;</bpt>Partial<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> closure is called sequentially with an accumulating value initialized to <bpt i="3" x="3">&lt;c3&gt;</bpt>initial<bpt i="4" x="4">&lt;w4&gt;</bpt>Result<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> and each element of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>next<bpt i="1" x="1">&lt;w1&gt;</bpt>Partial<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>クロージャは、<bpt i="3" x="3">&lt;c3&gt;</bpt>initial<bpt i="4" x="4">&lt;w4&gt;</bpt>Result<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>へと初期化された蓄積値とシーケンスの各要素とともに連続して呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>next<bpt i="1" x="1">&lt;w1&gt;</bpt>Partial<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> closure is called with <bpt i="3" x="3">&lt;c3&gt;</bpt>initial<bpt i="4" x="4">&lt;w4&gt;</bpt>Result<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>—<bpt i="5" x="5">&lt;c5&gt;</bpt>0<ept i="5">&lt;/c5&gt;</ept> in this case—and the first element of <bpt i="6" x="6">&lt;c6&gt;</bpt>numbers<ept i="6">&lt;/c6&gt;</ept>, returning the sum: <bpt i="7" x="7">&lt;c7&gt;</bpt>1<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>next<bpt i="1" x="1">&lt;w1&gt;</bpt>Partial<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>クロージャが、<bpt i="3" x="3">&lt;c3&gt;</bpt>initial<bpt i="4" x="4">&lt;w4&gt;</bpt>Result<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>—この場合では<bpt i="5" x="5">&lt;c5&gt;</bpt>0<ept i="5">&lt;/c5&gt;</ept>—そして<bpt i="6" x="6">&lt;c6&gt;</bpt>numbers<ept i="6">&lt;/c6&gt;</ept>の最初の要素とともに呼び出されて、その合計：<bpt i="7" x="7">&lt;c7&gt;</bpt>1<ept i="7">&lt;/c7&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>next<bpt i="1" x="1">&lt;w1&gt;</bpt>Partial<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> closure receives <bpt i="3" x="3">&lt;c3&gt;</bpt>initial<bpt i="4" x="4">&lt;w4&gt;</bpt>Result<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> the first time the closure executes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>next<bpt i="1" x="1">&lt;w1&gt;</bpt>Partial<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>クロージャは、<bpt i="3" x="3">&lt;c3&gt;</bpt>initial<bpt i="4" x="4">&lt;w4&gt;</bpt>Result<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>を、そのクロージャが遂行される最初の時に受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>next<bpt i="1" x="1">&lt;w1&gt;</bpt>Partial<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> closure receives <bpt i="3" x="3">&lt;c3&gt;</bpt>initial<bpt i="4" x="4">&lt;w4&gt;</bpt>Result<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> the first time the closure runs.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>next<bpt i="1" x="1">&lt;w1&gt;</bpt>Partial<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、<bpt i="3" x="3">&lt;c3&gt;</bpt>initial<bpt i="4" x="4">&lt;w4&gt;</bpt>Result<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>を、クロージャが動作する最初の時に受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>numbers<ept i="0">&lt;/c0&gt;</ept> array is now arranged in two partitions.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>numbers<ept i="0">&lt;/c0&gt;</ept>配列は今や２つの区分に整頓されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>offset<ept i="0">&lt;/c0&gt;</ept> value is the offset of the element to be removed in the original state of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>offset<ept i="0">&lt;/c0&gt;</ept>値は、コレクションの元の状態での取り除かれることになる要素のオフセットです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>offset<ept i="0">&lt;/c0&gt;</ept> value is the offset of the inserted element in the final state of the collection after the difference is fully applied.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>offset<ept i="0">&lt;/c0&gt;</ept>値は、差異が完全に適用される後のコレクションの最終的状態でのその挿入された要素のオフセットです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>perform(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>simultaneously<bpt i="2" x="2">&lt;w2&gt;</bpt>With:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function ends with a call to the <bpt i="3" x="3">&lt;c3&gt;</bpt>sync(flags:<bpt i="4" x="4">&lt;w4&gt;</bpt>execute:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> method using the <bpt i="5" x="5">&lt;c5&gt;</bpt>.barrier<ept i="5">&lt;/c5&gt;</ept> flag, which forces the function to wait until both closures have completed running before returning.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>perform(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>simultaneously<bpt i="2" x="2">&lt;w2&gt;</bpt>With:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数は、<bpt i="3" x="3">&lt;c3&gt;</bpt>sync(flags:<bpt i="4" x="4">&lt;w4&gt;</bpt>execute:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>メソッドへの <bpt i="5" x="5">&lt;c5&gt;</bpt>.barrier<ept i="5">&lt;/c5&gt;</ept>フラグを使った呼び出しで終わります、それはその関数に返る前に両方のクロージャが実行を完了し終わるまで待つことを強要します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>r1<ept i="0">&lt;/c0&gt;</ept> range is bounded on the lower end by <bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept> because that is the starting index of the <bpt i="2" x="2">&lt;c2&gt;</bpt>numbers<ept i="2">&lt;/c2&gt;</ept> array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>r1<ept i="0">&lt;/c0&gt;</ept>範囲は、<bpt i="1" x="1">&lt;c1&gt;</bpt>0<ept i="1">&lt;/c1&gt;</ept>によって下端に境界をつけられます、なぜならそれが<bpt i="2" x="2">&lt;c2&gt;</bpt>numbers<ept i="2">&lt;/c2&gt;</ept>配列の開始インデックスだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>random()<ept i="0">&lt;/c0&gt;</ept> static method chooses a random value from a continuous uniform distribution in <bpt i="1" x="1">&lt;c1&gt;</bpt>range<ept i="1">&lt;/c1&gt;</ept>, and then converts that value to the nearest representable value in this type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>random()<ept i="0">&lt;/c0&gt;</ept>静的メソッドは無作為の値を<bpt i="1" x="1">&lt;c1&gt;</bpt>range<ept i="1">&lt;/c1&gt;</ept>の中の連続一様分布から選びます、それからその値をその型で表現可能な最も近い値に変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>random(in:<bpt i="1" x="1">&lt;w1&gt;</bpt>using:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> static method chooses a random value from a continuous uniform distribution in <bpt i="2" x="2">&lt;c2&gt;</bpt>range<ept i="2">&lt;/c2&gt;</ept>, and then converts that value to the nearest representable value in this type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>random(in:<bpt i="1" x="1">&lt;w1&gt;</bpt>using:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>静的メソッドは無作為の値を<bpt i="2" x="2">&lt;c2&gt;</bpt>range<ept i="2">&lt;/c2&gt;</ept>の中の連続一様分布から選びます、それからその値をその型で表現可能な最も近い値に変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>response<bpt i="1" x="1">&lt;w1&gt;</bpt>Messages<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> variable is inferred to have type <bpt i="2" x="2">&lt;c2&gt;</bpt>[Int: String]<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>response<bpt i="1" x="1">&lt;w1&gt;</bpt>Messages<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>変数は、型<bpt i="2" x="2">&lt;c2&gt;</bpt>[Int: String]<ept i="2">&lt;/c2&gt;</ept>を持つと推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>round()<ept i="0">&lt;/c0&gt;</ept> method uses the <bpt i="1" x="1">&lt;c1&gt;</bpt>.to<bpt i="2" x="2">&lt;w2&gt;</bpt>Nearest<bpt i="3" x="3">&lt;w3&gt;</bpt>Or<bpt i="4" x="4">&lt;w4&gt;</bpt>Away<bpt i="5" x="5">&lt;w5&gt;</bpt>From<bpt i="6" x="6">&lt;w6&gt;</bpt>Zero<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> rounding rule, where a value halfway between two integral values is rounded to the one with greater magnitude.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>round()<ept i="0">&lt;/c0&gt;</ept>メソッドは<bpt i="1" x="1">&lt;c1&gt;</bpt>.to<bpt i="2" x="2">&lt;w2&gt;</bpt>Nearest<bpt i="3" x="3">&lt;w3&gt;</bpt>Or<bpt i="4" x="4">&lt;w4&gt;</bpt>Away<bpt i="5" x="5">&lt;w5&gt;</bpt>From<bpt i="6" x="6">&lt;w6&gt;</bpt>Zero<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>丸め規則を使います、そこでは２つの整数値の間の中ほどの値はより大きい規模を持つものへと丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>rounded()<ept i="0">&lt;/c0&gt;</ept> method uses the <bpt i="1" x="1">&lt;c1&gt;</bpt>.to<bpt i="2" x="2">&lt;w2&gt;</bpt>Nearest<bpt i="3" x="3">&lt;w3&gt;</bpt>Or<bpt i="4" x="4">&lt;w4&gt;</bpt>Away<bpt i="5" x="5">&lt;w5&gt;</bpt>From<bpt i="6" x="6">&lt;w6&gt;</bpt>Zero<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> rounding rule, where a value halfway between two integral values is rounded to the one with greater magnitude.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>rounded()<ept i="0">&lt;/c0&gt;</ept>メソッドは<bpt i="1" x="1">&lt;c1&gt;</bpt>.to<bpt i="2" x="2">&lt;w2&gt;</bpt>Nearest<bpt i="3" x="3">&lt;w3&gt;</bpt>Or<bpt i="4" x="4">&lt;w4&gt;</bpt>Away<bpt i="5" x="5">&lt;w5&gt;</bpt>From<bpt i="6" x="6">&lt;w6&gt;</bpt>Zero<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>丸め規則を使います、そこでは２つの整数値の間の中ほどの値はより大きい規模を持つものへと丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>sign<ept i="0">&lt;/c0&gt;</ept> property is <bpt i="1" x="1">&lt;c1&gt;</bpt>.minus<ept i="1">&lt;/c1&gt;</ept> if the value’s signbit is set, and <bpt i="2" x="2">&lt;c2&gt;</bpt>.plus<ept i="2">&lt;/c2&gt;</ept> otherwise.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>sign<ept i="0">&lt;/c0&gt;</ept>プロパティは、値のsignbitがセットされるならば<bpt i="1" x="1">&lt;c1&gt;</bpt>.minus<ept i="1">&lt;/c1&gt;</ept>です、そしてそうでないなら<bpt i="2" x="2">&lt;c2&gt;</bpt>.plus<ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>significand<bpt i="1" x="1">&lt;w1&gt;</bpt>Bit<bpt i="2" x="2">&lt;w2&gt;</bpt>Pattern<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property does not include the leading integral bit of the significand, even for types like <bpt i="3" x="3">&lt;c3&gt;</bpt>Float80<ept i="3">&lt;/c3&gt;</ept> that store it explicitly.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>significand<bpt i="1" x="1">&lt;w1&gt;</bpt>Bit<bpt i="2" x="2">&lt;w2&gt;</bpt>Pattern<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティは、仮数の先頭整数ビットを含みません、それを明示的に格納する<bpt i="3" x="3">&lt;c3&gt;</bpt>Float80<ept i="3">&lt;/c3&gt;</ept>のような型に対してさえも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>sink<ept i="0">&lt;/c0&gt;</ept> closure is called with each resulting UTF-32 code unit as the function iterates over its input.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>sink<ept i="0">&lt;/c0&gt;</ept>クロージャは、結果UTF-32コードユニットそれぞれで、それのinputに反復していく関数として呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>start<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>end<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> properties</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>start<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>および<bpt i="2" x="2">&lt;c2&gt;</bpt>end<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>sum()<ept i="0">&lt;/c0&gt;</ept> method is now available on any sequence with values that conform to <bpt i="1" x="1">&lt;c1&gt;</bpt>Additive<bpt i="2" x="2">&lt;w2&gt;</bpt>Arithmetic<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>, whether it is an array of <bpt i="3" x="3">&lt;c3&gt;</bpt>Double<ept i="3">&lt;/c3&gt;</ept> or a range of <bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>sum()<ept i="0">&lt;/c0&gt;</ept>メソッドは、今では<bpt i="1" x="1">&lt;c1&gt;</bpt>Additive<bpt i="2" x="2">&lt;w2&gt;</bpt>Arithmetic<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する値をもつあらゆるシーケンス上で利用可能です、それが<bpt i="3" x="3">&lt;c3&gt;</bpt>Double<ept i="3">&lt;/c3&gt;</ept>からなる配列であろうと <bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept>からなるある範囲であろうと。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>ulp<bpt i="1" x="1">&lt;w1&gt;</bpt>Of<bpt i="2" x="2">&lt;w2&gt;</bpt>One<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> constant corresponds to the C macros <bpt i="3" x="3">&lt;c3&gt;</bpt>FLT<bpt i="4" x="4">&lt;w4&gt;</bpt>_EPSILON<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, <bpt i="5" x="5">&lt;c5&gt;</bpt>DBL<bpt i="6" x="6">&lt;w6&gt;</bpt>_EPSILON<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, and others with a similar purpose.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>ulp<bpt i="1" x="1">&lt;w1&gt;</bpt>Of<bpt i="2" x="2">&lt;w2&gt;</bpt>One<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>定数は、Cマクロ<bpt i="3" x="3">&lt;c3&gt;</bpt>FLT<bpt i="4" x="4">&lt;w4&gt;</bpt>_EPSILON<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>、<bpt i="5" x="5">&lt;c5&gt;</bpt>DBL<bpt i="6" x="6">&lt;w6&gt;</bpt>_EPSILON<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>、そして類似した目的を持つ他のものに相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>update<bpt i="1" x="1">&lt;w1&gt;</bpt>Accumulating<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> closure is called sequentially with a mutable accumulating value initialized to <bpt i="3" x="3">&lt;c3&gt;</bpt>initial<bpt i="4" x="4">&lt;w4&gt;</bpt>Result<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> and each element of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>update<bpt i="1" x="1">&lt;w1&gt;</bpt>Accumulating<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>クロージャは、<bpt i="3" x="3">&lt;c3&gt;</bpt>initial<bpt i="4" x="4">&lt;w4&gt;</bpt>Result<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>へと初期化された可変の蓄積値とシーケンスの各要素とともに連続して呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>update<bpt i="1" x="1">&lt;w1&gt;</bpt>Accumulating<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> closure is called with the initial accumulating value—<bpt i="3" x="3">&lt;c3&gt;</bpt>[:]<ept i="3">&lt;/c3&gt;</ept> in this case—and the first character of <bpt i="4" x="4">&lt;c4&gt;</bpt>letters<ept i="4">&lt;/c4&gt;</ept>, modifying the accumulating value by setting <bpt i="5" x="5">&lt;c5&gt;</bpt>1<ept i="5">&lt;/c5&gt;</ept> for the key <bpt i="6" x="6">&lt;c6&gt;</bpt>"a"<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>update<bpt i="1" x="1">&lt;w1&gt;</bpt>Accumulating<bpt i="2" x="2">&lt;w2&gt;</bpt>Result<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>クロージャが、初期蓄積値—この場合では<bpt i="3" x="3">&lt;c3&gt;</bpt>[:]<ept i="3">&lt;/c3&gt;</ept>—そして<bpt i="4" x="4">&lt;c4&gt;</bpt>letters<ept i="4">&lt;/c4&gt;</ept>の最初の文字とともに呼び出されて、<bpt i="5" x="5">&lt;c5&gt;</bpt>1<ept i="5">&lt;/c5&gt;</ept>をキー<bpt i="6" x="6">&lt;c6&gt;</bpt>"a"<ept i="6">&lt;/c6&gt;</ept>に対して設定することで蓄積値を修正します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>with<bpt i="1" x="1">&lt;w1&gt;</bpt>Unsafe<bpt i="2" x="2">&lt;w2&gt;</bpt>Mutable<bpt i="3" x="3">&lt;w3&gt;</bpt>Pointer(to:<bpt i="4" x="4">&lt;w4&gt;</bpt>_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function is useful for calling Objective-C APIs that take in/out parameters (and default-constructible out parameters) by pointer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>with<bpt i="1" x="1">&lt;w1&gt;</bpt>Unsafe<bpt i="2" x="2">&lt;w2&gt;</bpt>Mutable<bpt i="3" x="3">&lt;w3&gt;</bpt>Pointer(to:<bpt i="4" x="4">&lt;w4&gt;</bpt>_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数は、ポインタによって「in/out」パラメータ（そして何もしなくとも構築可能な「out」パラメーター）を取るObjective-C APIを呼ぶのに役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;c0&gt;</bpt>with<bpt i="1" x="1">&lt;w1&gt;</bpt>Unsafe<bpt i="2" x="2">&lt;w2&gt;</bpt>Pointer(to:<bpt i="3" x="3">&lt;w3&gt;</bpt>_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function is useful for calling Objective-C APIs that take in parameters by const pointer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>with<bpt i="1" x="1">&lt;w1&gt;</bpt>Unsafe<bpt i="2" x="2">&lt;w2&gt;</bpt>Pointer(to:<bpt i="3" x="3">&lt;w3&gt;</bpt>_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数は、constポインタによってパラメータを取り入れるObjective-C APIを呼び出すのに役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="11" x="11">&lt;c11&gt;</bpt>flat<bpt i="12" x="12">&lt;w12&gt;</bpt>Map(_:)<ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> method “flattens” the resulting sequence-of-sequences into a single <bpt i="13" x="13">&lt;c13&gt;</bpt>Async<bpt i="14" x="14">&lt;w14&gt;</bpt>Sequence<ept i="14">&lt;/w14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="11" x="11">&lt;c11&gt;</bpt>flat<bpt i="12" x="12">&lt;w12&gt;</bpt>Map(_:)<ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>メソッドは、結果のシーケンスのシーケンスを単一の<bpt i="13" x="13">&lt;c13&gt;</bpt>Async<bpt i="14" x="14">&lt;w14&gt;</bpt>Sequence<ept i="14">&lt;/w14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>へと “平坦にします”。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="12" x="12">&lt;c12&gt;</bpt>with<bpt i="13" x="13">&lt;w13&gt;</bpt>Va<bpt i="14" x="14">&lt;w14&gt;</bpt>List(_:<bpt i="15" x="15">&lt;w15&gt;</bpt>_:)<ept i="15">&lt;/w15&gt;</ept><ept i="14">&lt;/w14&gt;</ept><ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> function takes an array of <bpt i="16" x="16">&lt;a16&gt;</bpt><bpt i="17" x="17">&lt;c17&gt;</bpt>CVar<bpt i="18" x="18">&lt;w18&gt;</bpt>Arg<ept i="18">&lt;/w18&gt;</ept><ept i="17">&lt;/c17&gt;</ept><ept i="16">&lt;/a16&gt;</ept> values and provides a <bpt i="19" x="19">&lt;a19&gt;</bpt><bpt i="20" x="20">&lt;c20&gt;</bpt>CVa<bpt i="21" x="21">&lt;w21&gt;</bpt>List<bpt i="22" x="22">&lt;w22&gt;</bpt>Pointer<ept i="22">&lt;/w22&gt;</ept><ept i="21">&lt;/w21&gt;</ept><ept i="20">&lt;/c20&gt;</ept><ept i="19">&lt;/a19&gt;</ept> value within the body of a closure parameter, whereas the <bpt i="23" x="23">&lt;c23&gt;</bpt>get<bpt i="24" x="24">&lt;w24&gt;</bpt>Va<bpt i="25" x="25">&lt;w25&gt;</bpt>List(_:)<ept i="25">&lt;/w25&gt;</ept><ept i="24">&lt;/w24&gt;</ept><ept i="23">&lt;/c23&gt;</ept> function returns this value directly.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="12" x="12">&lt;c12&gt;</bpt>with<bpt i="13" x="13">&lt;w13&gt;</bpt>Va<bpt i="14" x="14">&lt;w14&gt;</bpt>List(_:<bpt i="15" x="15">&lt;w15&gt;</bpt>_:)<ept i="15">&lt;/w15&gt;</ept><ept i="14">&lt;/w14&gt;</ept><ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>関数は、<bpt i="16" x="16">&lt;a16&gt;</bpt><bpt i="17" x="17">&lt;c17&gt;</bpt>CVar<bpt i="18" x="18">&lt;w18&gt;</bpt>Arg<ept i="18">&lt;/w18&gt;</ept><ept i="17">&lt;/c17&gt;</ept><ept i="16">&lt;/a16&gt;</ept>値からなるひとつの配列をとって、<bpt i="19" x="19">&lt;a19&gt;</bpt><bpt i="20" x="20">&lt;c20&gt;</bpt>CVa<bpt i="21" x="21">&lt;w21&gt;</bpt>List<bpt i="22" x="22">&lt;w22&gt;</bpt>Pointer<ept i="22">&lt;/w22&gt;</ept><ept i="21">&lt;/w21&gt;</ept><ept i="20">&lt;/c20&gt;</ept><ept i="19">&lt;/a19&gt;</ept>値をクロージャパラメータの本体内で提供します、一方で<bpt i="23" x="23">&lt;c23&gt;</bpt>get<bpt i="24" x="24">&lt;w24&gt;</bpt>Va<bpt i="25" x="25">&lt;w25&gt;</bpt>List(_:)<ept i="25">&lt;/w25&gt;</ept><ept i="24">&lt;/w24&gt;</ept><ept i="23">&lt;/c23&gt;</ept>関数はこの値を直接に返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;c1&gt;</bpt>CFType<bpt i="2" x="2">&lt;w2&gt;</bpt>Ref<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> type completely remaps to the <bpt i="3" x="3">&lt;c3&gt;</bpt>Any<bpt i="4" x="4">&lt;w4&gt;</bpt>Object<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>CFType<bpt i="2" x="2">&lt;w2&gt;</bpt>Ref<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>型は、<bpt i="3" x="3">&lt;c3&gt;</bpt>Any<bpt i="4" x="4">&lt;w4&gt;</bpt>Object<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>型に完全にリマップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept> protocol inherits from the <bpt i="2" x="2">&lt;c2&gt;</bpt>Equatable<ept i="2">&lt;/c2&gt;</ept> protocol, so you must also satisfy that protocol’s requirements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>プロトコルは、<bpt i="2" x="2">&lt;c2&gt;</bpt>Equatable<ept i="2">&lt;/c2&gt;</ept>プロトコルから継承します、それであなたは同様にそのプロトコルのもつ要件も満たさなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;c1&gt;</bpt>binade<ept i="1">&lt;/c1&gt;</ept> property is a member of the same binade as this value, but with a unit significand.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>binade<ept i="1">&lt;/c1&gt;</ept>プロパティは、この値と同じbinadeに属するあるメンバです、しかしある単位仮数を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;c1&gt;</bpt>id<ept i="1">&lt;/c1&gt;</ept> type is instead imported by Swift as the <bpt i="2" x="2">&lt;c2&gt;</bpt>Any<ept i="2">&lt;/c2&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>id<ept i="1">&lt;/c1&gt;</ept>型は、代わりにSwiftによって<bpt i="2" x="2">&lt;c2&gt;</bpt>Any<ept i="2">&lt;/c2&gt;</ept>型としてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>Array<ept i="2">&lt;/c2&gt;</ept> type’s <bpt i="3" x="3">&lt;c3&gt;</bpt>append(_:)<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>append(contents<bpt i="5" x="5">&lt;w5&gt;</bpt>Of:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> methods take care of this detail for you, but <bpt i="6" x="6">&lt;c6&gt;</bpt>reserve<bpt i="7" x="7">&lt;w7&gt;</bpt>Capacity(_:)<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> allocates only as much space as you tell it to (padded to a round value), and no more.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Array<ept i="2">&lt;/c2&gt;</ept>型のもつ<bpt i="3" x="3">&lt;c3&gt;</bpt>append(_:)<ept i="3">&lt;/c3&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>append(contents<bpt i="5" x="5">&lt;w5&gt;</bpt>Of:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>メソッドは、この詳細をあなたの代わりに面倒を見ます、しかし<bpt i="6" x="6">&lt;c6&gt;</bpt>reserve<bpt i="7" x="7">&lt;w7&gt;</bpt>Capacity(_:)<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>はあなたがそれに伝える（ある丸め値に詰め込まれた）のと同じ程度の空間だけをアロケートして、それ以上は何もしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>Binary<bpt i="3" x="3">&lt;w3&gt;</bpt>Integer<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol provides initializers for four different kinds of conversion.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Binary<bpt i="3" x="3">&lt;w3&gt;</bpt>Integer<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルは、イニシャライザを４つの異なる種類の変換に対して提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>Compass<bpt i="3" x="3">&lt;w3&gt;</bpt>Direction<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> example above demonstrates this automatic implementation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>上の<bpt i="2" x="2">&lt;c2&gt;</bpt>Compass<bpt i="3" x="3">&lt;w3&gt;</bpt>Direction<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>例は、この自動実装を実演します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>form<bpt i="3" x="3">&lt;w3&gt;</bpt>Remainder(dividing<bpt i="4" x="4">&lt;w4&gt;</bpt>By:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method is always exact.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>form<bpt i="3" x="3">&lt;w3&gt;</bpt>Remainder(dividing<bpt i="4" x="4">&lt;w4&gt;</bpt>By:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドは常に正確です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>form<bpt i="3" x="3">&lt;w3&gt;</bpt>Truncating<bpt i="4" x="4">&lt;w4&gt;</bpt>Remainder(dividing<bpt i="5" x="5">&lt;w5&gt;</bpt>By:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method is always exact.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>form<bpt i="3" x="3">&lt;w3&gt;</bpt>Truncating<bpt i="4" x="4">&lt;w4&gt;</bpt>Remainder(dividing<bpt i="5" x="5">&lt;w5&gt;</bpt>By:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドは常に正確です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>remainder(dividing<bpt i="3" x="3">&lt;w3&gt;</bpt>By:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method is always exact.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>remainder(dividing<bpt i="3" x="3">&lt;w3&gt;</bpt>By:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドは常に厳密に正確です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>remove<bpt i="3" x="3">&lt;w3&gt;</bpt>Last()<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method must be used only on a nonempty collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>remove<bpt i="3" x="3">&lt;w3&gt;</bpt>Last()<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドは、空でないコレクションでのみ使われるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="2" x="2">&lt;c2&gt;</bpt>truncating<bpt i="3" x="3">&lt;w3&gt;</bpt>Remainder(dividing<bpt i="4" x="4">&lt;w4&gt;</bpt>By:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method is always exact.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>truncating<bpt i="3" x="3">&lt;w3&gt;</bpt>Remainder(dividing<bpt i="4" x="4">&lt;w4&gt;</bpt>By:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドは常に正確です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="3" x="3">&lt;c3&gt;</bpt>..&lt;<ept i="3">&lt;/c3&gt;</ept> operator creates a range that doesn’t include the upper bound, so it’s always safe to use with <bpt i="4" x="4">&lt;c4&gt;</bpt>end<bpt i="5" x="5">&lt;w5&gt;</bpt>Index<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>..&lt;<ept i="3">&lt;/c3&gt;</ept>演算子は上方の境界を含まないある範囲を作成します、それでそれは常に<bpt i="4" x="4">&lt;c4&gt;</bpt>end<bpt i="5" x="5">&lt;w5&gt;</bpt>Index<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>と使うのに安全です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="3" x="3">&lt;c3&gt;</bpt>==<ept i="3">&lt;/c3&gt;</ept> operator is a requirement of the <bpt i="4" x="4">&lt;c4&gt;</bpt>Equatable<ept i="4">&lt;/c4&gt;</ept> protocol, which <bpt i="5" x="5">&lt;c5&gt;</bpt>Comparable<ept i="5">&lt;/c5&gt;</ept> extends—see that protocol’s documentation for more information about equality in Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>==<ept i="3">&lt;/c3&gt;</ept>演算子は、<bpt i="5" x="5">&lt;c5&gt;</bpt>Comparable<ept i="5">&lt;/c5&gt;</ept>が拡張する<bpt i="4" x="4">&lt;c4&gt;</bpt>Equatable<ept i="4">&lt;/c4&gt;</ept>プロトコルの要件です — そのプロトコルの文書をSwiftにおける同等性についてのさらなる情報のために見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="3" x="3">&lt;c3&gt;</bpt>Key<ept i="3">&lt;/c3&gt;</ept> type of the dictionary is <bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept>, and the <bpt i="5" x="5">&lt;c5&gt;</bpt>Value<ept i="5">&lt;/c5&gt;</ept> type of the dictionary is <bpt i="6" x="6">&lt;c6&gt;</bpt>String<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書の<bpt i="3" x="3">&lt;c3&gt;</bpt>Key<ept i="3">&lt;/c3&gt;</ept>型は<bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept>です、そして辞書の<bpt i="5" x="5">&lt;c5&gt;</bpt>Value<ept i="5">&lt;/c5&gt;</ept>型は<bpt i="6" x="6">&lt;c6&gt;</bpt>String<ept i="6">&lt;/c6&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="3" x="3">&lt;c3&gt;</bpt>NSError<ept i="3">&lt;/c3&gt;</ept> parameter on an asynchronous throwing method must also be nullable, which indicates that the parameter is used only to communicate an error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>非同期スローメソッド上の<bpt i="3" x="3">&lt;c3&gt;</bpt>NSError<ept i="3">&lt;/c3&gt;</ept>パラメータは、同様にnull可能でなければなりません、それはそのパラメータがエラーとの通信にのみ使われることを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="3" x="3">&lt;c3&gt;</bpt>String(describing:)<ept i="3">&lt;/c3&gt;</ept> initializer is the preferred way to convert an instance of <bpt i="4" x="4">&lt;e4&gt;</bpt>any<ept i="4">&lt;/e4&gt;</ept> type to a string.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>String(describing:)<ept i="3">&lt;/c3&gt;</ept>イニシャライザは、<bpt i="4" x="4">&lt;e4&gt;</bpt>あらゆる<ept i="4">&lt;/e4&gt;</ept>型のインスタンスをある文字列へ変換する好ましい方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="3" x="3">&lt;c3&gt;</bpt>high<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>low<ept i="4">&lt;/c4&gt;</ept> properties of the <bpt i="5" x="5">&lt;c5&gt;</bpt>result<ept i="5">&lt;/c5&gt;</ept> value represent 2000 when concatenated to form a double-width integer; that is, using <bpt i="6" x="6">&lt;c6&gt;</bpt>result<bpt i="7" x="7">&lt;w7&gt;</bpt>.high<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> as the high byte and <bpt i="8" x="8">&lt;c8&gt;</bpt>result<bpt i="9" x="9">&lt;w9&gt;</bpt>.low<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> as the low byte of a <bpt i="10" x="10">&lt;c10&gt;</bpt>UInt16<ept i="10">&lt;/c10&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>result<ept i="5">&lt;/c5&gt;</ept>値の<bpt i="3" x="3">&lt;c3&gt;</bpt>high<ept i="3">&lt;/c3&gt;</ept>および<bpt i="4" x="4">&lt;c4&gt;</bpt>low<ept i="4">&lt;/c4&gt;</ept>プロパティは、二倍幅整数に成形するために連結される時2000を表します；すなわち、<bpt i="10" x="10">&lt;c10&gt;</bpt>UInt16<ept i="10">&lt;/c10&gt;</ept>インスタンスの高バイトとして<bpt i="6" x="6">&lt;c6&gt;</bpt>result<bpt i="7" x="7">&lt;w7&gt;</bpt>.high<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>をそして低バイトとして<bpt i="8" x="8">&lt;c8&gt;</bpt>result<bpt i="9" x="9">&lt;w9&gt;</bpt>.low<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>を使って。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt>all<bpt i="5" x="5">&lt;w5&gt;</bpt>Satisfy(_:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> method checks to see whether all elements produced by the sequence are less than <bpt i="6" x="6">&lt;c6&gt;</bpt>10<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>all<bpt i="5" x="5">&lt;w5&gt;</bpt>Satisfy(_:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>メソッドは、シーケンスによって生み出されたすべての要素が<bpt i="6" x="6">&lt;c6&gt;</bpt>10<ept i="6">&lt;/c6&gt;</ept>より小さいかどうか見るために調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt>contains(_:)<ept i="4">&lt;/c4&gt;</ept> method checks to see whether the sequence produces the value <bpt i="5" x="5">&lt;c5&gt;</bpt>5<ept i="5">&lt;/c5&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>contains(_:)<ept i="4">&lt;/c4&gt;</ept>メソッドは、シーケンスが値<bpt i="5" x="5">&lt;c5&gt;</bpt>5<ept i="5">&lt;/c5&gt;</ept>を生み出すかどうか見るために調べます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt>contains(where:)<ept i="4">&lt;/c4&gt;</ept> method checks to see whether the sequence produces a value divisible by <bpt i="5" x="5">&lt;c5&gt;</bpt>3<ept i="5">&lt;/c5&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>contains(where:)<ept i="4">&lt;/c4&gt;</ept>メソッドは、シーケンスが<bpt i="5" x="5">&lt;c5&gt;</bpt>3<ept i="5">&lt;/c5&gt;</ept>で割り切れる値を生み出すかどうか見るために調べます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt>drop(while:)<ept i="4">&lt;/c4&gt;</ept> method causes the modified sequence to ignore received values until it encounters one that is divisible by <bpt i="5" x="5">&lt;c5&gt;</bpt>3<ept i="5">&lt;/c5&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>drop(while:)<ept i="4">&lt;/c4&gt;</ept>メソッドは、修正されたシーケンスが、それが<bpt i="5" x="5">&lt;c5&gt;</bpt>3<ept i="5">&lt;/c5&gt;</ept>によって割り切れるものに出くわすまで受け取った値を無視することを引き起こします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt>drop<bpt i="5" x="5">&lt;w5&gt;</bpt>First(_:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> method causes the modified sequence to ignore the values <bpt i="6" x="6">&lt;c6&gt;</bpt>0<ept i="6">&lt;/c6&gt;</ept> through <bpt i="7" x="7">&lt;c7&gt;</bpt>4<ept i="7">&lt;/c7&gt;</ept>, and instead emit <bpt i="8" x="8">&lt;c8&gt;</bpt>5<ept i="8">&lt;/c8&gt;</ept> through <bpt i="9" x="9">&lt;c9&gt;</bpt>10<ept i="9">&lt;/c9&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>drop<bpt i="5" x="5">&lt;w5&gt;</bpt>First(_:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>メソッドは、その修正されたシーケンスに値<bpt i="6" x="6">&lt;c6&gt;</bpt>0<ept i="6">&lt;/c6&gt;</ept>から<bpt i="7" x="7">&lt;c7&gt;</bpt>4<ept i="7">&lt;/c7&gt;</ept>を無視させます、そして代わりに<bpt i="8" x="8">&lt;c8&gt;</bpt>5<ept i="8">&lt;/c8&gt;</ept>から<bpt i="9" x="9">&lt;c9&gt;</bpt>10<ept i="9">&lt;/c9&gt;</ept>を放出させます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt>filter(_:)<ept i="4">&lt;/c4&gt;</ept> method returns <bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept> for even values and <bpt i="6" x="6">&lt;c6&gt;</bpt>false<ept i="6">&lt;/c6&gt;</ept> for odd values, thereby filtering out the odd values, but also throws an error for values divisible by 5:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>filter(_:)<ept i="4">&lt;/c4&gt;</ept>メソッドは、<bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>を偶数値に対してそして<bpt i="6" x="6">&lt;c6&gt;</bpt>false<ept i="6">&lt;/c6&gt;</ept>を奇数値に対して返します、それによって奇数値を取り除いています、しかしまた５で割り切れる値に対してエラーをスローします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt>filter(_:)<ept i="4">&lt;/c4&gt;</ept> method returns <bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept> for even values and <bpt i="6" x="6">&lt;c6&gt;</bpt>false<ept i="6">&lt;/c6&gt;</ept> for odd values, thereby filtering out the odd values:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>filter(_:)<ept i="4">&lt;/c4&gt;</ept>メソッドは、<bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>を偶数値に対してそして<bpt i="6" x="6">&lt;c6&gt;</bpt>false<ept i="6">&lt;/c6&gt;</ept>を奇数値に対して返します、それによって奇数値を取り除いています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt>first(where:)<ept i="4">&lt;/c4&gt;</ept> method returns the first member of the sequence that’s evenly divisible by both <bpt i="5" x="5">&lt;c5&gt;</bpt>2<ept i="5">&lt;/c5&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt>3<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>first(where:)<ept i="4">&lt;/c4&gt;</ept>メソッドは、<bpt i="5" x="5">&lt;c5&gt;</bpt>2<ept i="5">&lt;/c5&gt;</ept>と<bpt i="6" x="6">&lt;c6&gt;</bpt>3<ept i="6">&lt;/c6&gt;</ept>の両方で整然と割り切れるこのシーケンスの最初のメンバーを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt>high<ept i="4">&lt;/c4&gt;</ept> and <bpt i="5" x="5">&lt;c5&gt;</bpt>low<ept i="5">&lt;/c5&gt;</ept> compnents of the <bpt i="6" x="6">&lt;c6&gt;</bpt>result<ept i="6">&lt;/c6&gt;</ept> value represent <bpt i="7" x="7">&lt;c7&gt;</bpt>-1920<ept i="7">&lt;/c7&gt;</ept> when concatenated to form a double-width integer; that is, using <bpt i="8" x="8">&lt;c8&gt;</bpt>result<bpt i="9" x="9">&lt;w9&gt;</bpt>.high<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> as the high byte and <bpt i="10" x="10">&lt;c10&gt;</bpt>result<bpt i="11" x="11">&lt;w11&gt;</bpt>.low<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> as the low byte of an <bpt i="12" x="12">&lt;c12&gt;</bpt>Int16<ept i="12">&lt;/c12&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>result<ept i="4">&lt;/c4&gt;</ept>値の<bpt i="5" x="5">&lt;c5&gt;</bpt>high<ept i="5">&lt;/c5&gt;</ept>と<bpt i="6" x="6">&lt;c6&gt;</bpt>low<ept i="6">&lt;/c6&gt;</ept>構成要素は、２倍幅整数に成形するために連結される場合<bpt i="7" x="7">&lt;c7&gt;</bpt>-1920<ept i="7">&lt;/c7&gt;</ept>を表します；すなわち、<bpt i="8" x="8">&lt;c8&gt;</bpt>result<bpt i="9" x="9">&lt;w9&gt;</bpt>.high<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>を高バイトとして<bpt i="10" x="10">&lt;c10&gt;</bpt>result<bpt i="11" x="11">&lt;w11&gt;</bpt>.low<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>を低バイトとして<bpt i="12" x="12">&lt;c12&gt;</bpt>Int16<ept i="12">&lt;/c12&gt;</ept>インスタンスに使って。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt>max()<ept i="4">&lt;/c4&gt;</ept> method returns the max value of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>max()<ept i="4">&lt;/c4&gt;</ept>メソッドは、シーケンスの最大値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt>min()<ept i="4">&lt;/c4&gt;</ept> method returns the minimum value of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>min()<ept i="4">&lt;/c4&gt;</ept>メソッドは、シーケンスの最小値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt>prefix(_:)<ept i="4">&lt;/c4&gt;</ept> method causes the modified sequence to pass through the first six values, then end.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>prefix(_:)<ept i="4">&lt;/c4&gt;</ept>メソッドは、その修正されたシーケンスに最初の６つの値をずっと渡させて、それから終わらせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt>prefix(_:)<ept i="4">&lt;/c4&gt;</ept> method causes the modified sequence to pass through values less than <bpt i="5" x="5">&lt;c5&gt;</bpt>8<ept i="5">&lt;/c5&gt;</ept>, but throws an error when it receives a value that’s divisible by <bpt i="6" x="6">&lt;c6&gt;</bpt>5<ept i="6">&lt;/c6&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>prefix(_:)<ept i="4">&lt;/c4&gt;</ept>メソッドは、修正されたシーケンスが<bpt i="5" x="5">&lt;c5&gt;</bpt>8<ept i="5">&lt;/c5&gt;</ept>より少ない値それらを通過させる、しかしそれが<bpt i="6" x="6">&lt;c6&gt;</bpt>5<ept i="6">&lt;/c6&gt;</ept>で割り切れる値を受け取る時はエラーをスローするようにします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt>prefix(while:)<ept i="4">&lt;/c4&gt;</ept> method causes the modified sequence to pass along values so long as they aren’t divisible by <bpt i="5" x="5">&lt;c5&gt;</bpt>2<ept i="5">&lt;/c5&gt;</ept> and <bpt i="6" x="6">&lt;c6&gt;</bpt>3<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>prefix(while:)<ept i="4">&lt;/c4&gt;</ept>メソッドは、修正されたシーケンスが値それらを、それらが<bpt i="5" x="5">&lt;c5&gt;</bpt>2<ept i="5">&lt;/c5&gt;</ept>と<bpt i="6" x="6">&lt;c6&gt;</bpt>3<ept i="6">&lt;/c6&gt;</ept>によって割り切れない限り通過させるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="4" x="4">&lt;c4&gt;</bpt>reduce(_:<bpt i="5" x="5">&lt;w5&gt;</bpt>_:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> method sums the values received from the asynchronous sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>reduce(_:<bpt i="5" x="5">&lt;w5&gt;</bpt>_:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>メソッドは、非同期シーケンスから受け取った値それらを合計します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="0" x="0">&lt;e0&gt;</bpt>exponent<ept i="0">&lt;/e0&gt;</ept> of a floating-point value is the integer part of the logarithm of the value’s magnitude.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>浮動小数点値の<bpt i="0" x="0">&lt;e0&gt;</bpt>指数<ept i="0">&lt;/e0&gt;</ept>は、値の規模の対数の整数部分です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;e1&gt;</bpt>static type<ept i="1">&lt;/e1&gt;</ept> of a value is the known, compile-time type of the value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値の<bpt i="1" x="1">&lt;e1&gt;</bpt>静的型<ept i="1">&lt;/e1&gt;</ept>は、既知の、コンパイル時のその値の型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="2" x="2">&lt;e2&gt;</bpt>dynamic type<ept i="2">&lt;/e2&gt;</ept> of a value is the value’s actual type at run-time, which can be a subtype of its concrete type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値の<bpt i="2" x="2">&lt;e2&gt;</bpt>動的型<ept i="2">&lt;/e2&gt;</ept>は、その値の実行時での実際の型です、それはそれの具象型の下位型であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="3" x="3">&lt;e3&gt;</bpt>exponent bias<ept i="3">&lt;/e3&gt;</ept> of a type <bpt i="4" x="4">&lt;c4&gt;</bpt>F<ept i="4">&lt;/c4&gt;</ept> can be calculated as the following, where <bpt i="5" x="5">&lt;c5&gt;</bpt>**<ept i="5">&lt;/c5&gt;</ept> is exponentiation:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある型<bpt i="4" x="4">&lt;c4&gt;</bpt>F<ept i="4">&lt;/c4&gt;</ept>の<bpt i="3" x="3">&lt;e3&gt;</bpt>指数バイアス<ept i="3">&lt;/e3&gt;</ept>は、以下のように計算されます、ここで<bpt i="5" x="5">&lt;c5&gt;</bpt>**<ept i="5">&lt;/c5&gt;</ept>は冪です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The ASCII encoding value of this character, if it is an ASCII character.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文字のASCIIエンコーディング値、もしそれがASCIIならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The ASCII representation of a number in the radix passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>radix<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>radix<ept i="0">&lt;/c0&gt;</ept>として渡される基数におけるある数のASCII表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The ASCII representation of a number.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある数のASCII表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The Boolean value to copy.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コピーされるブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The Boolean value to negate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>否定するブール値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The Boolean wrapped in a data value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるデータ値の中のラップされるブール。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The C <bpt i="0" x="0">&lt;c0&gt;</bpt>bool<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Boolean<ept i="1">&lt;/c1&gt;</ept> types and the Objective-C <bpt i="2" x="2">&lt;c2&gt;</bpt>BOOL<ept i="2">&lt;/c2&gt;</ept> type are all bridged into Swift as <bpt i="3" x="3">&lt;c3&gt;</bpt>Bool<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Cの<bpt i="0" x="0">&lt;c0&gt;</bpt>bool<ept i="0">&lt;/c0&gt;</ept>および<bpt i="1" x="1">&lt;c1&gt;</bpt>Boolean<ept i="1">&lt;/c1&gt;</ept>型とObjective-Cの<bpt i="2" x="2">&lt;c2&gt;</bpt>BOOL<ept i="2">&lt;/c2&gt;</ept>型は、すべてSwiftに<bpt i="3" x="3">&lt;c3&gt;</bpt>Bool<ept i="3">&lt;/c3&gt;</ept>としてブリッジされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The C ‘_Bool’ and C++ ‘bool’ type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Cの「_Bool」およびC++の「bool」型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The C ‘_Float16’ type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>C「_Float16」型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The C ‘char’ type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Cの「char」型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The C ‘double’ type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>C「double」型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The C ‘float’ type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>C「float」型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The C ‘int’ type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>C「int」型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The C ‘long long’ type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>C「long long」型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The C ‘long’ type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>C「long」型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The C ‘short’ type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>C「short」型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The C ‘signed char’ type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>C「signed char」型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The C ‘unsigned char’ type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>C「unsigned char」型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The C ‘unsigned int’ type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>C「unsigned int」型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The C ‘unsigned long long’ type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>C「unsigned long long」型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The C ‘unsigned long’ type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>C「unsigned long」型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The C ‘unsigned short’ type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>C「unsigned short」型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The C++ ‘wchar_t’ type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>C++「wchar_t」型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The C++11 ‘char16_t’ type, which has UTF-16 encoding.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>C++11「char16_t」型、それはUTF-16エンコーディングされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The C++11 ‘char32_t’ type, which has UTF-32 encoding.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>C++11「char32_t」型、それはUTF-32エンコーディングされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The Cocoa delegation pattern doesn't require that delegates are instantiated.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Cocoa委任パターンは、委任先がインスタンス化されることを要求しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The IEEE 754 floating-point classes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>IEEE 754浮動小数点の様々な部類。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The NaN values in the <bpt i="0" x="0">&lt;c0&gt;</bpt>temps<bpt i="1" x="1">&lt;w1&gt;</bpt>Celsius<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> array are propagated through the conversion and remain NaN in <bpt i="2" x="2">&lt;c2&gt;</bpt>temps<bpt i="3" x="3">&lt;w3&gt;</bpt>Fahrenheit<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>temps<bpt i="1" x="1">&lt;w1&gt;</bpt>Celsius<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>配列の中のNaN値は、変換を通して伝播されていき、<bpt i="2" x="2">&lt;c2&gt;</bpt>temps<bpt i="3" x="3">&lt;w3&gt;</bpt>Fahrenheit<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>においてNaNのままです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The Objective-C declarations are automatically available from any Swift file within that target, with no import statements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-C宣言は、自動的にあらゆるSwiftファイルからそのターゲット内部で、インポート文なしで利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The Sendable protocol indicates that value of the given type can be safely used in concurrent code.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Sendableプロトコルは、与えられた型の値が並行性コードにおいて安全に使用できることを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The Swift interfaces in the generated header include references to all of the Objective-C types used in them, so make sure to import the Objective-C headers for those types first.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>生成されたヘッダの中のSwiftインタフェースそれらは、それらの中で使われるObjective-C型への全ての参照を含みます、それで最初にそれらの型に対するObjective-Cヘッダをインポートすることを確実にしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The Swift standard library and Foundation use structures for types you use frequently, such as numbers, strings, arrays, and dictionaries.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swift標準ライブラリとFoundationは、あなたが頻繁に使う型、例えば数、文字列、配列、そして辞書などに対して構造体を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The Unicode encoding of <bpt i="0" x="0">&lt;c0&gt;</bpt>input<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>input<ept i="0">&lt;/c0&gt;</ept>のユニコードエンコーディング。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The Unicode scalar value to convert into a character.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>１つの文字へ変換するユニコードスカラー値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The UnsafeSendable protocol indicates that value of the given type can be safely used in concurrent code, but disables some safety checking at the conformance site.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>UnsafeSendableプロトコルは、与えられた型の値が並行性コードにおいて安全に使用できる、しかしいくつかの安全検査を適応場所で作動しなくすることを指し示します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The absolute value of <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> must be representable in the same type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>の絶対値は、同じ型において表現可能である必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The absolute value of <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>の絶対値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The accessed slice uses the same indices for the same elements as the original collection uses.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>アクセスされるスライス（切り取り）は、同じ要素に対して元のコレクションが使うのと同じインデックスを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The accessed slice uses the same indices for the same elements as the original collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>アクセスされるスライス（切り取り）は、同じ要素に対して元のコレクションと同じインデックスを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The addition operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>+<ept i="0">&lt;/c0&gt;</ept>) calculates the sum of its two arguments.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>加算演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>+<ept i="0">&lt;/c0&gt;</ept>）は、それの２つの引数の合計を計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The additive inverse of the argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この引数の加法の逆元。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The address passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Pattern<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must have the correct alignment for the pointer’s <bpt i="2" x="2">&lt;c2&gt;</bpt>Pointee<ept i="2">&lt;/c2&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Pattern<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として渡されるアドレスは、ポインタの持つ<bpt i="2" x="2">&lt;c2&gt;</bpt>Pointee<ept i="2">&lt;/c2&gt;</ept>型に対して整合状態でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The algorithm used to create random values may change in a future version of Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>無作為値を作成するために使われるアルゴリズムは、将来のSwiftバージョンで変わるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The algorithm used to select a random element may change in a future version of Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある無作為な要素を選択するために使われるアルゴリズムは、将来のSwiftバージョンで変わるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The algorithm used to shuffle a collection may change in a future version of Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるコレクションをシャッフルするために使われるアルゴリズムは、将来のSwiftバージョンで変わるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The algorithm used to shuffle a sequence may change in a future version of Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるシーケンスをシャッフルするために使われるアルゴリズムは、将来のSwiftバージョンで変更するかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The allowed formats for each of these representations is then as follows:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これらの表現のそれぞれに対する許される形式はそれで以下になります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The alpha-2 code for The United States is “US”, so its flag character is made up of the Unicode scalar values <bpt i="0" x="0">&lt;c0&gt;</bpt>"\u{1F1FA}"<ept i="0">&lt;/c0&gt;</ept> (REGIONAL INDICATOR SYMBOL LETTER U) and <bpt i="1" x="1">&lt;c1&gt;</bpt>"\u{1F1F8}"<ept i="1">&lt;/c1&gt;</ept> (REGIONAL INDICATOR SYMBOL LETTER S).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>アメリカ合衆国に対するalpha-2コードは、「US」です、それでそれの国旗文字はユニコードスカラー値<bpt i="0" x="0">&lt;c0&gt;</bpt>"\u{1F1FA}"<ept i="0">&lt;/c0&gt;</ept>（REGIONAL INDICATOR SYMBOL LETTER U）と<bpt i="1" x="1">&lt;c1&gt;</bpt>"\u{1F1F8}"<ept i="1">&lt;/c1&gt;</ept>（REGIONAL INDICATOR SYMBOL LETTER S）から作り上げられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The amount to step by with each iteration.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>各反復でそれだけ間隔をとることになる量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The argument is valid only for the duration of the closure’s execution.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>引数は、ただクロージャの実行の間に対してのみ有効とされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The array to append to.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>追加先の配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The array wrapped in a data value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>データ値の中にラップされる配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The arrays in the “values” position of the new dictionary each contain at least one element, with the elements in the same order as the source sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい辞書の「values」位置での配列は、それぞれ少なくとも１つの要素を含み、元となるシーケンスと同じ順序で要素を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The array’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> type must be a <bpt i="1" x="1">&lt;e1&gt;</bpt>trivial type<ept i="1">&lt;/e1&gt;</ept>, which can be copied with just a bit-for-bit copy without any indirection or reference-counting operations.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この配列の持つ<bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>型は<bpt i="1" x="1">&lt;e1&gt;</bpt>自明型<ept i="1">&lt;/e1&gt;</ept>でなければなりません、それは単にビット対ビットコピーでコピーされることが、何らかの間接参照または参照カウント操作なしで可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The array’s “past the end” position—that is, the position one greater than the last valid subscript argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列の「終わりを過ぎた」位置—すなわち、最後の有効な添え字引数より１つ大きい位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The assignment to the <bpt i="0" x="0">&lt;c0&gt;</bpt>o<bpt i="1" x="1">&lt;w1&gt;</bpt>Breve<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> constant calls this initializer behind the scenes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>o<bpt i="1" x="1">&lt;w1&gt;</bpt>Breve<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>定数への代入は、このイニシャライザを舞台裏で呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The asynchronous iterator for iterating a AsyncStream.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>AsyncStreamを反復するための非同期イテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The asynchronous iterator for iterating a AsyncThrowingStream.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>AsyncThrowingStreamを反復するための非同期イテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The attribute container with the keys and values to populate this dictionary with.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この辞書にそれらを入れることになるキーと値それらを備えた属性コンテナ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The attribute scope of the keys in <bpt i="0" x="0">&lt;c0&gt;</bpt>container<ept i="0">&lt;/c0&gt;</ept> that a key path identifies.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるキーパスが識別する<bpt i="0" x="0">&lt;c0&gt;</bpt>container<ept i="0">&lt;/c0&gt;</ept>の中のキーそれらの属性スコープ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The attribute scope of the keys in <bpt i="0" x="0">&lt;c0&gt;</bpt>container<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>container<ept i="0">&lt;/c0&gt;</ept>の中のキーそれらの属性スコープ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The available number of fractional significand bits.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>利用可能な小数の仮数ビットの数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The base state.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>基底状態。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The base, precision, and exponent range are not fixed in any way by this protocol, but it enforces the basic requirements of any IEEE 754 floating-point type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>基数、精度、そして指数範囲は、このプロトコルによって何らかの方法で固定されません、しかしそれはIEEE 754浮動小数点型どれかの基本要件を強要します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The big-endian representation of this integer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この整数のビッグエンディアン表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The bit pattern matches the binary interchange format defined by the <bpt i="0" x="0">&lt;a0&gt;</bpt>IEEE 754 specification<ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ビットパターンは<bpt i="0" x="0">&lt;a0&gt;</bpt>IEEE 754仕様<ept i="0">&lt;/a0&gt;</ept>で定義されるバイナリ交換形式に一致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The bit pattern of the value’s encoding.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値の持つエンコーディングのビットパターン。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The bit pattern to use for the exponent field of the new value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい値の指数フィールドに使うためのビットパターン。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The bit pattern to use for the significand field of the new value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい値の仮数フィールドに使うためのビットパターン。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The bit width of a <bpt i="0" x="0">&lt;c0&gt;</bpt>Int16<ept i="0">&lt;/c0&gt;</ept> instance is 16.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Int16<ept i="0">&lt;/c0&gt;</ept>インスタンスのビット幅は16です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The bit width of a <bpt i="0" x="0">&lt;c0&gt;</bpt>Int32<ept i="0">&lt;/c0&gt;</ept> instance is 32.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Int32<ept i="0">&lt;/c0&gt;</ept>インスタンスのビット幅は32です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The bit width of a <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept> instance is 32 on 32-bit platforms and 64 on 64-bit platforms.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>インスタンスのビット幅は、32ビットプラットホーム上では32そして64ビットプラットホーム上では64です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The bitwise NOT operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>~<ept i="0">&lt;/c0&gt;</ept>) is a prefix operator that returns a value in which all the bits of its argument are flipped: Bits that are <bpt i="1" x="1">&lt;c1&gt;</bpt>1<ept i="1">&lt;/c1&gt;</ept> in the argument are <bpt i="2" x="2">&lt;c2&gt;</bpt>0<ept i="2">&lt;/c2&gt;</ept> in the result, and bits that are <bpt i="3" x="3">&lt;c3&gt;</bpt>0<ept i="3">&lt;/c3&gt;</ept> in the argument are <bpt i="4" x="4">&lt;c4&gt;</bpt>1<ept i="4">&lt;/c4&gt;</ept> in the result.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ビット単位のNOT演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>~<ept i="0">&lt;/c0&gt;</ept>）は前置演算子で、それの引数のビットすべてがひっくり返されるある値を返します：引数において<bpt i="1" x="1">&lt;c1&gt;</bpt>1<ept i="1">&lt;/c1&gt;</ept>であるビットは結果において<bpt i="2" x="2">&lt;c2&gt;</bpt>0<ept i="2">&lt;/c2&gt;</ept>になります、そして引数において<bpt i="3" x="3">&lt;c3&gt;</bpt>0<ept i="3">&lt;/c3&gt;</ept>であるビットは結果において<bpt i="4" x="4">&lt;c4&gt;</bpt>1<ept i="4">&lt;/c4&gt;</ept>になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The block has a <bpt i="0" x="0">&lt;c0&gt;</bpt>void<ept i="0">&lt;/c0&gt;</ept> return type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのブロックは<bpt i="0" x="0">&lt;c0&gt;</bpt>void<ept i="0">&lt;/c0&gt;</ept>戻り型を持つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The block is called exactly once, on all possible paths of control flow.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのブロックは、制御の流れの全ての可能な経路上で、厳密に一回だけ呼び出される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The bounds of the range must be valid indices of the array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲の境界は、配列の有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The bounds of the range must be valid indices of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この範囲の境界は、コレクションの有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The bounds of the result are always limited to the bounds of <bpt i="0" x="0">&lt;c0&gt;</bpt>limits<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果の領域は、常に<bpt i="0" x="0">&lt;c0&gt;</bpt>limits<ept i="0">&lt;/c0&gt;</ept>の領域に制限されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The buffer is the size of the instance passed as <bpt i="2" x="2">&lt;c2&gt;</bpt>value<ept i="2">&lt;/c2&gt;</ept> and does not include any remote storage.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>バッファは、<bpt i="2" x="2">&lt;c2&gt;</bpt>value<ept i="2">&lt;/c2&gt;</ept>として渡されるインスタンスの大きさで、あらゆるリモートストレージを含みません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The buffer pointer argument is valid only for the duration of the closure’s execution.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>バッファポインタは、ただクロージャの実行の間に対してのみ有効とされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The buffer pointer argument to the <bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept> closure provides a collection interface to the raw bytes of <bpt i="1" x="1">&lt;c1&gt;</bpt>value<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept>クロージャへのバッファポインタ引数は、<bpt i="1" x="1">&lt;c1&gt;</bpt>value<ept i="1">&lt;/c1&gt;</ept>の生のバイトへのコレクションインターフェイスを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The buffering is only for values that have yet to be consumed by iteration.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>バッファするのは、まだ反復によって消費されない値に対してだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The build closure passes in a Continuation which can be used in concurrent contexts.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>buildクロージャは、あるContinuationに渡されます、それは並行性文脈において使われることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The call to <bpt i="0" x="0">&lt;c0&gt;</bpt>reserve<bpt i="1" x="1">&lt;w1&gt;</bpt>Capacity(_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> increases the <bpt i="2" x="2">&lt;c2&gt;</bpt>values<ept i="2">&lt;/c2&gt;</ept> array’s capacity by exactly 10 elements on each pass through <bpt i="3" x="3">&lt;c3&gt;</bpt>add<bpt i="4" x="4">&lt;w4&gt;</bpt>Ten<bpt i="5" x="5">&lt;w5&gt;</bpt>Quadratic()<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, which is linear growth.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>reserve<bpt i="1" x="1">&lt;w1&gt;</bpt>Capacity(_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を呼び出すことは、<bpt i="2" x="2">&lt;c2&gt;</bpt>values<ept i="2">&lt;/c2&gt;</ept>配列の容量を正確に10要素ずつ<bpt i="3" x="3">&lt;c3&gt;</bpt>add<bpt i="4" x="4">&lt;w4&gt;</bpt>Ten<bpt i="5" x="5">&lt;w5&gt;</bpt>Quadratic()<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が行われる各々で漸増します、それは線形成長です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The callback is disposed of after any terminal state is reached.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コールバックは、何であれ終端状態が到達される後に処理されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The classification of this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値の分類。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The closure is called again repeatedly with the previous call’s return value and each element of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>クロージャは、前の呼び出しの戻り値とシーケンスの各要素とともに繰り返して再び呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The closure is called again repeatedly with the updated accumulating value and each element of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>クロージャは、更新された蓄積値とシーケンスの各要素とともに繰り返して再び呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The closure provided to the <bpt i="4" x="4">&lt;c4&gt;</bpt>compact<bpt i="5" x="5">&lt;w5&gt;</bpt>Map(_:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> method takes each <bpt i="6" x="6">&lt;c6&gt;</bpt>Int<ept i="6">&lt;/c6&gt;</ept> and looks up a corresponding <bpt i="7" x="7">&lt;c7&gt;</bpt>String<ept i="7">&lt;/c7&gt;</ept> from a <bpt i="8" x="8">&lt;c8&gt;</bpt>roman<bpt i="9" x="9">&lt;w9&gt;</bpt>Numeral<bpt i="10" x="10">&lt;w10&gt;</bpt>Dict<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>compact<bpt i="5" x="5">&lt;w5&gt;</bpt>Map(_:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>メソッドに提供されたクロージャは、各<bpt i="6" x="6">&lt;c6&gt;</bpt>Int<ept i="6">&lt;/c6&gt;</ept>をとり、そして対応している<bpt i="7" x="7">&lt;c7&gt;</bpt>String<ept i="7">&lt;/c7&gt;</ept>を<bpt i="8" x="8">&lt;c8&gt;</bpt>roman<bpt i="9" x="9">&lt;w9&gt;</bpt>Numeral<bpt i="10" x="10">&lt;w10&gt;</bpt>Dict<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>辞書から捜します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The closure provided to the <bpt i="4" x="4">&lt;c4&gt;</bpt>map(_:)<ept i="4">&lt;/c4&gt;</ept> method takes each <bpt i="5" x="5">&lt;c5&gt;</bpt>Int<ept i="5">&lt;/c5&gt;</ept> and looks up a corresponding <bpt i="6" x="6">&lt;c6&gt;</bpt>String<ept i="6">&lt;/c6&gt;</ept> from a <bpt i="7" x="7">&lt;c7&gt;</bpt>roman<bpt i="8" x="8">&lt;w8&gt;</bpt>Numeral<bpt i="9" x="9">&lt;w9&gt;</bpt>Dict<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>map(_:)<ept i="4">&lt;/c4&gt;</ept>メソッドに提供されたクロージャは、各<bpt i="5" x="5">&lt;c5&gt;</bpt>Int<ept i="5">&lt;/c5&gt;</ept>をとり、そして対応している<bpt i="6" x="6">&lt;c6&gt;</bpt>String<ept i="6">&lt;/c6&gt;</ept>を<bpt i="7" x="7">&lt;c7&gt;</bpt>roman<bpt i="8" x="8">&lt;w8&gt;</bpt>Numeral<bpt i="9" x="9">&lt;w9&gt;</bpt>Dict<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>辞書から捜します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The closure returns the desired value for the final dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このクロージャは、最終的な辞書に対して望む値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The code sample below declares a dictionary called <bpt i="1" x="1">&lt;c1&gt;</bpt>interesting<bpt i="2" x="2">&lt;w2&gt;</bpt>Numbers<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> with string keys and values that are integer arrays, then sorts each array in-place in descending order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下のコード見本は、<bpt i="1" x="1">&lt;c1&gt;</bpt>interesting<bpt i="2" x="2">&lt;w2&gt;</bpt>Numbers<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>と呼ばれる辞書を文字列キーと整数配列である値で宣言します、それから各配列をその場で降順にソートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The coding path for the returned error is constructed by appending the given container’s current index to its coding path.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>返されるエラーのためのコーディングパスは、与えられたコンテナの持つ現在のインデックスをそれのコーディングパスに加えることで組み立てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The coding path for the returned error is constructed by appending the given key to the given container’s coding path.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>返されるエラーのためのコーディングパスは、与えられたキーをその与えられたコンテナの持つコーディングパスに加えることで組み立てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The coding path for the returned error is the given container’s coding path.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>返されるエラーのためのコーディングパスは、与えられたコンテナの持つコーディングパスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The collection being appended to allocates any additional necessary storage to hold the new elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションは追加されることによって、新しい要素を保有するために何らかの追加的に必要なストレージを割り当てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The collection must not be empty.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションは空であってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The collection of changes passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>changes<ept i="0">&lt;/c0&gt;</ept> must meet these requirements:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>changes<ept i="0">&lt;/c0&gt;</ept>として渡される変更いくつかからなるこのコレクションは、３つの要件に合わなければなりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The collection to evaluate this range expression in relation to.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このコレクションに関して、この範囲式を評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The collection to wrap.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ラップされるコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The collection’s “past the end” position.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このコレクションの「終わりを過ぎた」位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The collection’s “past the end” position—that is, the position one greater than the last valid subscript argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの「終わりを過ぎた」位置—すなわち、最後の有効な添え字引数より１つ大きい位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The compact map sequence produces whatever type of element its transforming closure produces.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コンパクトマップシーケンスは、それの変換クロージャが生み出す要素の型が何であろうとも生み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The compiler automatically synthesizes your custom type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept> and requirements when you declare <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept> conformance in the type’s original declaration and your type meets these criteria:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コンパイラは、自動的にあなたのあつらえの型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept>と要件を、あなたが<bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>準拠をその型の持つ元の宣言において宣言して、あなたの型がそれら基準に合う場合に合成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The compiler can automatically provide an implementation of the <bpt i="0" x="0">&lt;c0&gt;</bpt>Case<bpt i="1" x="1">&lt;w1&gt;</bpt>Iterable<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> requirements for any enumeration without associated values or <bpt i="2" x="2">&lt;c2&gt;</bpt>@available<ept i="2">&lt;/c2&gt;</ept> attributes on its cases.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コンパイラは、自動的に<bpt i="0" x="0">&lt;c0&gt;</bpt>Case<bpt i="1" x="1">&lt;w1&gt;</bpt>Iterable<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>要件の実装を提供することが、関連値または<bpt i="2" x="2">&lt;c2&gt;</bpt>@available<ept i="2">&lt;/c2&gt;</ept>属性をそれのケース節上で持たないあらゆる列挙に対して可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The compiler prevents bridging the <bpt i="9" x="9">&lt;c9&gt;</bpt>more<bpt i="10" x="10">&lt;w10&gt;</bpt>Colors<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> array, on the other hand, because its <bpt i="11" x="11">&lt;c11&gt;</bpt>Element<ept i="11">&lt;/c11&gt;</ept> type is <bpt i="12" x="12">&lt;c12&gt;</bpt>Optional&lt;String&gt;<ept i="12">&lt;/c12&gt;</ept>, which does <bpt i="13" x="13">&lt;e13&gt;</bpt>not<ept i="13">&lt;/e13&gt;</ept> bridge to a Foundation type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コンパイラは、<bpt i="9" x="9">&lt;c9&gt;</bpt>more<bpt i="10" x="10">&lt;w10&gt;</bpt>Colors<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>配列をブリッジすることを妨げます、言い換えれば、それの<bpt i="11" x="11">&lt;c11&gt;</bpt>Element<ept i="11">&lt;/c11&gt;</ept>型が<bpt i="12" x="12">&lt;c12&gt;</bpt>Optional&lt;String&gt;<ept i="12">&lt;/c12&gt;</ept>であるので、それはFoundation型にブリッジ<bpt i="13" x="13">&lt;e13&gt;</bpt>しません<ept i="13">&lt;/e13&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The compiler removes <bpt i="0" x="0">&lt;c0&gt;</bpt>Ref<ept i="0">&lt;/c0&gt;</ept> from the end of each type name because all Swift classes are reference types; therefore, the suffix is redundant.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コンパイラは各型名の終わりから<bpt i="0" x="0">&lt;c0&gt;</bpt>Ref<ept i="0">&lt;/c0&gt;</ept>を削除します、なぜなら全てのスウィフトクラスが参照型であるからです；したがって、この接尾辞は冗長です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The components used for hashing must be the same as the components compared in your type’s <bpt i="1" x="1">&lt;c1&gt;</bpt>==<ept i="1">&lt;/c1&gt;</ept> operator implementation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ハッシュ化に使用される構成要素は、あなたの型のもつ<bpt i="1" x="1">&lt;c1&gt;</bpt>==<ept i="1">&lt;/c1&gt;</ept>演算子実装において比較される構成要素と同じでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The condition to test.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>テストする条件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The contents of the Objective-C files in that framework are automatically available from any Swift file within that framework target, with no import statements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのフレームワークの中のObjective-Cファイルの内容は、自動的にそのフレームワークターゲット内のあらゆるSwiftファイルから、インポート文なしで利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The contents of this sequence, as an asychronous sequence of Unicode scalar values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスの内容、ユニコードスカラー値それらからなる非同期シーケンスとして。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The contents of this sequence, as an asychronous sequence of characters.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスの内容、文字それらからなる非同期シーケンスとして。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The contents of this sequence, as an asychronous sequence of lines of text.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスの内容、テキスト行それらからなるある非同期シーケンスとして。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The context in which the error occurred.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そこにおいてエラーが起こった前後関係。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The conversion of <bpt i="0" x="0">&lt;c0&gt;</bpt>p<ept i="0">&lt;/c0&gt;</ept> to a string in the assignment to <bpt i="1" x="1">&lt;c1&gt;</bpt>s<ept i="1">&lt;/c1&gt;</ept> uses the <bpt i="2" x="2">&lt;c2&gt;</bpt>Point<ept i="2">&lt;/c2&gt;</ept> type’s <bpt i="3" x="3">&lt;c3&gt;</bpt>debug<bpt i="4" x="4">&lt;w4&gt;</bpt>Description<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>p<ept i="0">&lt;/c0&gt;</ept>の文字列への変換は<bpt i="1" x="1">&lt;c1&gt;</bpt>s<ept i="1">&lt;/c1&gt;</ept>への代入において、<bpt i="2" x="2">&lt;c2&gt;</bpt>Point<ept i="2">&lt;/c2&gt;</ept>型のもつ<bpt i="3" x="3">&lt;c3&gt;</bpt>debug<bpt i="4" x="4">&lt;w4&gt;</bpt>Description<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>プロパティを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The conversion of <bpt i="0" x="0">&lt;c0&gt;</bpt>p<ept i="0">&lt;/c0&gt;</ept> to a string in the assignment to <bpt i="1" x="1">&lt;c1&gt;</bpt>s<ept i="1">&lt;/c1&gt;</ept> uses the <bpt i="2" x="2">&lt;c2&gt;</bpt>Point<ept i="2">&lt;/c2&gt;</ept> type’s <bpt i="3" x="3">&lt;c3&gt;</bpt>description<ept i="3">&lt;/c3&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>s<ept i="1">&lt;/c1&gt;</ept>への代入における<bpt i="0" x="0">&lt;c0&gt;</bpt>p<ept i="0">&lt;/c0&gt;</ept>の文字列への変換は、<bpt i="2" x="2">&lt;c2&gt;</bpt>Point<ept i="2">&lt;/c2&gt;</ept>型のもつ<bpt i="3" x="3">&lt;c3&gt;</bpt>description<ept i="3">&lt;/c3&gt;</ept>プロパティを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The correct approach in Swift is to compare the <bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept> value with zero in the <bpt i="1" x="1">&lt;c1&gt;</bpt>while<ept i="1">&lt;/c1&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftにおける正しい取り組みは、<bpt i="1" x="1">&lt;c1&gt;</bpt>while<ept i="1">&lt;/c1&gt;</ept>文において<bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept>値を0と比較することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The corresponding value of the raw type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この生の型の対応している値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The current playground logging implementation logs specialized descriptions of at least the following types:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>現在のプレイグラウンドログ実装は、少なくとも以下の型の特殊化された記述を記録します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The custom mirror for this instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このインスタンスのためのあつらえのミラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The decoder to read data from.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それからデータを読み出すデコーダ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default IEEE 754 behavior of operations involving a signaling NaN is to raise the Invalid flag in the floating-point environment and return a quiet NaN.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シグナルNaNを伴う演算の初期状態のIEEE 754挙動は、無効なフラグを浮動小数点環境において上げて、クワイエットNaNを返すことになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default cancellation thrown when a task is cancelled.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるタスクが取り消される時にスローされる省略時の取り消し。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default implementation of the <bpt i="3" x="3">&lt;c3&gt;</bpt>!=<ept i="3">&lt;/c3&gt;</ept> operator function satisfies this requirement.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>!=<ept i="3">&lt;/c3&gt;</ept>演算子関数の省略時の実装は、この要件を満たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default implementation returns 0.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時の実装は、０を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default is 10.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時は10。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default is <bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時には<bpt i="0" x="0">&lt;c0&gt;</bpt>0<ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default is <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<bpt i="1" x="1">&lt;w1&gt;</bpt>.max<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時には<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<bpt i="1" x="1">&lt;w1&gt;</bpt>.max<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default is <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>初期状態は<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default is <bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時では<bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default is <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時には<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default is a newline (<bpt i="0" x="0">&lt;c0&gt;</bpt>"\n"<ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>初期状態では改行（<bpt i="0" x="0">&lt;c0&gt;</bpt>"\n"<ept i="0">&lt;/c0&gt;</ept>）です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default is a single space (<bpt i="0" x="0">&lt;c0&gt;</bpt>" "<ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>初期状態では、単一の空白（<bpt i="0" x="0">&lt;c0&gt;</bpt>" "<ept i="0">&lt;/c0&gt;</ept>）です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default is an empty string.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>初期状態では空の文字列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default is the file where <bpt i="1" x="1">&lt;c1&gt;</bpt>assert(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>_:<bpt i="3" x="3">&lt;w3&gt;</bpt>file:<bpt i="4" x="4">&lt;w4&gt;</bpt>line:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is called.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>初期状態では、<bpt i="1" x="1">&lt;c1&gt;</bpt>assert(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>_:<bpt i="3" x="3">&lt;w3&gt;</bpt>file:<bpt i="4" x="4">&lt;w4&gt;</bpt>line:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>が呼び出されるところのファイルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default is the file where <bpt i="1" x="1">&lt;c1&gt;</bpt>assertion<bpt i="2" x="2">&lt;w2&gt;</bpt>Failure(_:<bpt i="3" x="3">&lt;w3&gt;</bpt>file:<bpt i="4" x="4">&lt;w4&gt;</bpt>line:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is called.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>初期状態では、<bpt i="1" x="1">&lt;c1&gt;</bpt>assertion<bpt i="2" x="2">&lt;w2&gt;</bpt>Failure(_:<bpt i="3" x="3">&lt;w3&gt;</bpt>file:<bpt i="4" x="4">&lt;w4&gt;</bpt>line:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>が呼び出されたところのファイルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default is the file where <bpt i="1" x="1">&lt;c1&gt;</bpt>fatal<bpt i="2" x="2">&lt;w2&gt;</bpt>Error(_:<bpt i="3" x="3">&lt;w3&gt;</bpt>file:<bpt i="4" x="4">&lt;w4&gt;</bpt>line:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is called.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>初期状態では、<bpt i="1" x="1">&lt;c1&gt;</bpt>fatal<bpt i="2" x="2">&lt;w2&gt;</bpt>Error(_:<bpt i="3" x="3">&lt;w3&gt;</bpt>file:<bpt i="4" x="4">&lt;w4&gt;</bpt>line:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>が呼び出されたところのファイルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default is the file where <bpt i="1" x="1">&lt;c1&gt;</bpt>precondition(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>_:<bpt i="3" x="3">&lt;w3&gt;</bpt>file:<bpt i="4" x="4">&lt;w4&gt;</bpt>line:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is called.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>初期状態では、<bpt i="1" x="1">&lt;c1&gt;</bpt>precondition(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>_:<bpt i="3" x="3">&lt;w3&gt;</bpt>file:<bpt i="4" x="4">&lt;w4&gt;</bpt>line:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>が呼び出されるところのファイルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default is the file where <bpt i="1" x="1">&lt;c1&gt;</bpt>precondition<bpt i="2" x="2">&lt;w2&gt;</bpt>Failure(_:<bpt i="3" x="3">&lt;w3&gt;</bpt>file:<bpt i="4" x="4">&lt;w4&gt;</bpt>line:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is called.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>初期状態では、<bpt i="1" x="1">&lt;c1&gt;</bpt>precondition<bpt i="2" x="2">&lt;w2&gt;</bpt>Failure(_:<bpt i="3" x="3">&lt;w3&gt;</bpt>file:<bpt i="4" x="4">&lt;w4&gt;</bpt>line:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>が呼び出されたところのファイルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default is the line number where <bpt i="1" x="1">&lt;c1&gt;</bpt>assert(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>_:<bpt i="3" x="3">&lt;w3&gt;</bpt>file:<bpt i="4" x="4">&lt;w4&gt;</bpt>line:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is called.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>初期状態では、<bpt i="1" x="1">&lt;c1&gt;</bpt>assert(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>_:<bpt i="3" x="3">&lt;w3&gt;</bpt>file:<bpt i="4" x="4">&lt;w4&gt;</bpt>line:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>が呼び出されるところの行番号です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default is the line number where <bpt i="1" x="1">&lt;c1&gt;</bpt>assertion<bpt i="2" x="2">&lt;w2&gt;</bpt>Failure(_:<bpt i="3" x="3">&lt;w3&gt;</bpt>file:<bpt i="4" x="4">&lt;w4&gt;</bpt>line:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is called.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>初期状態では、<bpt i="1" x="1">&lt;c1&gt;</bpt>assertion<bpt i="2" x="2">&lt;w2&gt;</bpt>Failure(_:<bpt i="3" x="3">&lt;w3&gt;</bpt>file:<bpt i="4" x="4">&lt;w4&gt;</bpt>line:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>が呼び出されたところの行番号です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default is the line number where <bpt i="1" x="1">&lt;c1&gt;</bpt>fatal<bpt i="2" x="2">&lt;w2&gt;</bpt>Error(_:<bpt i="3" x="3">&lt;w3&gt;</bpt>file:<bpt i="4" x="4">&lt;w4&gt;</bpt>line:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is called.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>初期状態では、<bpt i="1" x="1">&lt;c1&gt;</bpt>fatal<bpt i="2" x="2">&lt;w2&gt;</bpt>Error(_:<bpt i="3" x="3">&lt;w3&gt;</bpt>file:<bpt i="4" x="4">&lt;w4&gt;</bpt>line:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>が呼び出されたところの行番号です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default is the line number where <bpt i="1" x="1">&lt;c1&gt;</bpt>precondition(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>_:<bpt i="3" x="3">&lt;w3&gt;</bpt>file:<bpt i="4" x="4">&lt;w4&gt;</bpt>line:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is called.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>初期状態では、<bpt i="1" x="1">&lt;c1&gt;</bpt>precondition(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>_:<bpt i="3" x="3">&lt;w3&gt;</bpt>file:<bpt i="4" x="4">&lt;w4&gt;</bpt>line:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>が呼び出されるところの行番号です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default is the line number where <bpt i="1" x="1">&lt;c1&gt;</bpt>precondition<bpt i="2" x="2">&lt;w2&gt;</bpt>Failure(_:<bpt i="3" x="3">&lt;w3&gt;</bpt>file:<bpt i="4" x="4">&lt;w4&gt;</bpt>line:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is called.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>初期状態では、<bpt i="1" x="1">&lt;c1&gt;</bpt>precondition<bpt i="2" x="2">&lt;w2&gt;</bpt>Failure(_:<bpt i="3" x="3">&lt;w3&gt;</bpt>file:<bpt i="4" x="4">&lt;w4&gt;</bpt>line:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>が呼び出されたところの行番号です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default separator is an empty string.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時の分離子は空の文字列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default type for an otherwise-unconstrained Boolean literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ブールリテラルである他は別途制約されない省略時用の型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default type for an otherwise-unconstrained Unicode extended grapheme cluster literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>別途制約されないユニコード拡張書記素クラスタリテラルのための省略時型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default type for an otherwise-unconstrained floating-point literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>別途制約されない浮動小数点リテラルのための省略時型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default type for an otherwise-unconstrained integer literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>別途制約されない整数リテラルのための省略時型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default type for an otherwise-unconstrained string literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>別途制約されない文字列リテラルのための省略時型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default type for an otherwise-unconstrained unicode scalar literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>別途制約されないユニコードスカラーリテラルのための省略時型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default value for this limit is Int.max.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この限界に対する省略時の値は、Int.maxです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default value is <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時の値は<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default value is <bpt i="4" x="4">&lt;c4&gt;</bpt>Int<bpt i="5" x="5">&lt;w5&gt;</bpt>.max<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時の値は<bpt i="4" x="4">&lt;c4&gt;</bpt>Int<bpt i="5" x="5">&lt;w5&gt;</bpt>.max<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default value is <bpt i="4" x="4">&lt;c4&gt;</bpt>true<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時の値は、<bpt i="4" x="4">&lt;c4&gt;</bpt>true<ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default value is <bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時の値は、<bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default value is <bpt i="6" x="6">&lt;c6&gt;</bpt>true<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時の値は、<bpt i="6" x="6">&lt;c6&gt;</bpt>true<ept i="6">&lt;/c6&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The default value to use if <bpt i="0" x="0">&lt;c0&gt;</bpt>key<ept i="0">&lt;/c0&gt;</ept> doesn’t exist in the dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>key<ept i="0">&lt;/c0&gt;</ept>が辞書の中に存在しないならば使うことになる省略時の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The destination Unicode encoding.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>行き先ユニコードエンコーディング。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The dictionary literal is made up of one or more key-value pairs, separated by commas and surrounded with square brackets.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書リテラルは、コンマで区切られて角括弧で囲まれた１つ以上のキー値ペアで構成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The dictionary wrapped in a data value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>データ値の中にラップされる辞書。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The dictionary’s “past the end” position—that is, the position one greater than the last valid subscript argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書の「終わりを過ぎた」位置—すなわち、最後の有効な添え字引数より１つ大きい位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The difference is that the <bpt i="16" x="16">&lt;c16&gt;</bpt>Async<bpt i="17" x="17">&lt;w17&gt;</bpt>Iterator<ept i="17">&lt;/w17&gt;</ept><ept i="16">&lt;/c16&gt;</ept> defines its <bpt i="18" x="18">&lt;c18&gt;</bpt>next()<ept i="18">&lt;/c18&gt;</ept> method as <bpt i="19" x="19">&lt;c19&gt;</bpt>async<ept i="19">&lt;/c19&gt;</ept>, which requires a caller to wait for the next value with the <bpt i="20" x="20">&lt;c20&gt;</bpt>await<ept i="20">&lt;/c20&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その違いは、<bpt i="16" x="16">&lt;c16&gt;</bpt>Async<bpt i="17" x="17">&lt;w17&gt;</bpt>Iterator<ept i="17">&lt;/w17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>はそれの<bpt i="18" x="18">&lt;c18&gt;</bpt>next()<ept i="18">&lt;/c18&gt;</ept>メソッドを<bpt i="19" x="19">&lt;c19&gt;</bpt>async<ept i="19">&lt;/c19&gt;</ept>として定義することです、それは呼び出し側に次の値を待つように<bpt i="20" x="20">&lt;c20&gt;</bpt>await<ept i="20">&lt;/c20&gt;</ept>キーワードで要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The difference needed to produce the receiver’s state from the parameter’s state.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>レシーバのもつ状態をパラメータのもつ状態から生成するのに必要とされる差異。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The difference needed to produce this collection’s ordered elements from the given collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このコレクションのもつ順番付けられた要素をこの与えられたコレクションから生成するのに必要とされる差異。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The difference of the two arguments must be representable in the arguments’ type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの引数の差は、引数の持つ型において表現可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The difference to be applied.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>適用されることになる差異。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The distance between <bpt i="0" x="0">&lt;c0&gt;</bpt>start<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>end<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>start<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>end<ept i="1">&lt;/c1&gt;</ept>の隔たり。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The distance between two indexes (always zero).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つのインデックスの間の隔たり（常にゼロ）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The distance from this pointer to <bpt i="0" x="0">&lt;c0&gt;</bpt>end<ept i="0">&lt;/c0&gt;</ept>, in strides of the pointer’s <bpt i="1" x="1">&lt;c1&gt;</bpt>Pointee<ept i="1">&lt;/c1&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このポインタから<bpt i="0" x="0">&lt;c0&gt;</bpt>end<ept i="0">&lt;/c0&gt;</ept>までの隔たり、ポインタのもつ<bpt i="1" x="1">&lt;c1&gt;</bpt>Pointee<ept i="1">&lt;/c1&gt;</ept>型のストライドで。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The distance from this value to <bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値から<bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>までの隔たり。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The distance to advance this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値を前進させる距離。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The distance to offset <bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept>を補う間隔。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The division operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>/<ept i="0">&lt;/c0&gt;</ept>) calculates the quotient of the division if <bpt i="1" x="1">&lt;c1&gt;</bpt>rhs<ept i="1">&lt;/c1&gt;</ept> is nonzero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>除算演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>/<ept i="0">&lt;/c0&gt;</ept>）は、<bpt i="1" x="1">&lt;c1&gt;</bpt>rhs<ept i="1">&lt;/c1&gt;</ept>が非ゼロならばその除算の商を計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The double wrapped in a data value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>データ値の中にラップされるdouble。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The drop-first sequence produces whatever type of element its base iterator produces.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>drop-firstシーケンスは、それの基底イテレータが生み出す要素の型が何であろうとも生み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The drop-while sequence produces whatever type of element its base sequence produces.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>drop-whileシーケンスは、それの基底シーケンスが生み出す要素の型が何であろうとも生み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The dynamic type returned from <bpt i="0" x="0">&lt;c0&gt;</bpt>type(of:)<ept i="0">&lt;/c0&gt;</ept> is a <bpt i="1" x="1">&lt;e1&gt;</bpt>concrete metatype<ept i="1">&lt;/e1&gt;</ept> (<bpt i="2" x="2">&lt;c2&gt;</bpt>T<bpt i="3" x="3">&lt;w3&gt;</bpt>.Type<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>) for a class, structure, enumeration, or other nonprotocol type <bpt i="4" x="4">&lt;c4&gt;</bpt>T<ept i="4">&lt;/c4&gt;</ept>, or an <bpt i="5" x="5">&lt;e5&gt;</bpt>existential metatype<ept i="5">&lt;/e5&gt;</ept> (<bpt i="6" x="6">&lt;c6&gt;</bpt>P<bpt i="7" x="7">&lt;w7&gt;</bpt>.Type<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>) for a protocol or protocol composition <bpt i="8" x="8">&lt;c8&gt;</bpt>P<ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>type(of:)<ept i="0">&lt;/c0&gt;</ept>から返される動的型は、クラス、構造体、列挙、または他の非プロトコル型<bpt i="4" x="4">&lt;c4&gt;</bpt>T<ept i="4">&lt;/c4&gt;</ept>に対して<bpt i="1" x="1">&lt;e1&gt;</bpt>具象メタタイプ<ept i="1">&lt;/e1&gt;</ept>（<bpt i="2" x="2">&lt;c2&gt;</bpt>T<bpt i="3" x="3">&lt;w3&gt;</bpt>.Type<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>）、またはプロトコルやプロトコル合成<bpt i="8" x="8">&lt;c8&gt;</bpt>P<ept i="8">&lt;/c8&gt;</ept>に対して<bpt i="5" x="5">&lt;e5&gt;</bpt>存在メタタイプ<ept i="5">&lt;/e5&gt;</ept>（<bpt i="6" x="6">&lt;c6&gt;</bpt>P<bpt i="7" x="7">&lt;w7&gt;</bpt>.Type<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>）です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The dynamic type, which is a metatype instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>動的型、それはメタタイプインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The element at the specified index.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定されたインデックスでの要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The element is the dropped value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この要素は、除外された値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The element that should be split upon.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それで分離されることになる要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The element to append to the array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列に追加されることになる要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The element to check for containment.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この要素が含まれるかを調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The element to find in the asynchronous sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この要素を非同期シーケンスの中で見つけ出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The element to find in the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスにおいて見つける要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The element to repeat.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>繰り返される要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The element to store in the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの中に格納することになる要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The element type of a dictionary: a tuple containing an individual key-value pair.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書の要素型：個々のキー値ペアを含んでいるタプル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The elements at that index and later indices are shifted back to make room.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのインデックスおよび後のインデックスでの要素は、後ろに移って場所をあけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The elements of the range are the consecutive values from its lower bound up to, and including, its upper bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この範囲に属する要素は、それの下側の境界の値から上側の境界まで、そしてそれを含めての連続した値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The elements of the resulting array are ordered according to the given predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果の配列の要素は、与えられた述部にしたがって並べられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The elements of the sequence are obtained by invoking <bpt i="0" x="0">&lt;c0&gt;</bpt>next<ept i="0">&lt;/c0&gt;</ept> with a mutable state.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスの要素は、 <bpt i="0" x="0">&lt;c0&gt;</bpt>next<ept i="0">&lt;/c0&gt;</ept>をある可変の状態とともに発動することによって入手されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The elements of this view are a concatenation of the elements of each sequence in the base.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この見方での要素たちは、その基盤の中の各シーケンスのもつ要素の連結です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The elements to append to the array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列に追加する要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The elements to append to the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これらの要素をコレクションへ追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The encoder to write data to.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>データを書き込むエンコーダ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The end index refers to the position one past the last element of a collection, so it doesn’t correspond with an element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>末尾インデックスは、あるコレクションの最後の要素を１つ過ぎた位置を参照します、それでそれはある要素に対応しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The error to throw from the continuation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その継続からスローされたエラー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The error to throw or nil to signify termination.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>スローするエラーまたは終端を意味するnil。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The escapable copy of <bpt i="0" x="0">&lt;c0&gt;</bpt>closure<ept i="0">&lt;/c0&gt;</ept> passed to <bpt i="1" x="1">&lt;c1&gt;</bpt>body<ept i="1">&lt;/c1&gt;</ept> is only valid during the call to <bpt i="2" x="2">&lt;c2&gt;</bpt>without<bpt i="3" x="3">&lt;w3&gt;</bpt>Actually<bpt i="4" x="4">&lt;w4&gt;</bpt>Escaping(_:<bpt i="5" x="5">&lt;w5&gt;</bpt>do:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>closure<ept i="0">&lt;/c0&gt;</ept>の脱出可能コピーで<bpt i="1" x="1">&lt;c1&gt;</bpt>body<ept i="1">&lt;/c1&gt;</ept>に渡されるものは、<bpt i="2" x="2">&lt;c2&gt;</bpt>without<bpt i="3" x="3">&lt;w3&gt;</bpt>Actually<bpt i="4" x="4">&lt;w4&gt;</bpt>Escaping(_:<bpt i="5" x="5">&lt;w5&gt;</bpt>do:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>への呼び出しの間に有効なだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The example above responds to the property change by printing both the new and old values of the date.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>上の例は、プロパティの変化に、日付の新旧の値の両方をプリントすることによって応答します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The example below adopts the <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>NSWindow<bpt i="2" x="2">&lt;w2&gt;</bpt>Delegate<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> protocol and implements its <bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>window(_:<bpt i="5" x="5">&lt;w5&gt;</bpt>will<bpt i="6" x="6">&lt;w6&gt;</bpt>Use<bpt i="7" x="7">&lt;w7&gt;</bpt>Full<bpt i="8" x="8">&lt;w8&gt;</bpt>Screen<bpt i="9" x="9">&lt;w9&gt;</bpt>Content<bpt i="10" x="10">&lt;w10&gt;</bpt>Size:)<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept> method:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下の例は、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>NSWindow<bpt i="2" x="2">&lt;w2&gt;</bpt>Delegate<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>プロトコルを採用します、そしてそれの<bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>window(_:<bpt i="5" x="5">&lt;w5&gt;</bpt>will<bpt i="6" x="6">&lt;w6&gt;</bpt>Use<bpt i="7" x="7">&lt;w7&gt;</bpt>Full<bpt i="8" x="8">&lt;w8&gt;</bpt>Screen<bpt i="9" x="9">&lt;w9&gt;</bpt>Content<bpt i="10" x="10">&lt;w10&gt;</bpt>Size:)<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>メソッドを実装します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The example below changes the <bpt i="1" x="1">&lt;c1&gt;</bpt>my<bpt i="2" x="2">&lt;w2&gt;</bpt>Date<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> property by calling the <bpt i="3" x="3">&lt;c3&gt;</bpt>update<bpt i="4" x="4">&lt;w4&gt;</bpt>Date<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下の例は、<bpt i="1" x="1">&lt;c1&gt;</bpt>my<bpt i="2" x="2">&lt;w2&gt;</bpt>Date<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>プロパティを、<bpt i="3" x="3">&lt;c3&gt;</bpt>update<bpt i="4" x="4">&lt;w4&gt;</bpt>Date<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>メソッドを呼び出すことによって変更します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The example below creates an <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>NSWindow<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> and uses optional chaining to check that the window's delegate exists before sending a message to the delegate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下の例は、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>NSWindow<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>を作成して、オプショナル連鎖を使うことで、ウインドウの持つ委任先が存在することを、メッセージをその委任先に送る前に確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The example below defines the <bpt i="2" x="2">&lt;c2&gt;</bpt>My<bpt i="3" x="3">&lt;w3&gt;</bpt>Object<bpt i="4" x="4">&lt;w4&gt;</bpt>To<bpt i="5" x="5">&lt;w5&gt;</bpt>Observe<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> class with a property—<bpt i="6" x="6">&lt;c6&gt;</bpt>my<bpt i="7" x="7">&lt;w7&gt;</bpt>Date<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>—that can be observed:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下の例は、<bpt i="2" x="2">&lt;c2&gt;</bpt>My<bpt i="3" x="3">&lt;w3&gt;</bpt>Object<bpt i="4" x="4">&lt;w4&gt;</bpt>To<bpt i="5" x="5">&lt;w5&gt;</bpt>Observe<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>クラスを、監視されることが可能なプロパティ — <bpt i="6" x="6">&lt;c6&gt;</bpt>my<bpt i="7" x="7">&lt;w7&gt;</bpt>Date<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> — で定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The example below uses the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_ERROR<bpt i="2" x="2">&lt;w2&gt;</bpt>_ENUM<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> macro to group error constants:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_ERROR<bpt i="2" x="2">&lt;w2&gt;</bpt>_ENUM<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>マクロを使ってエラー定数をグループにまとめます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The examples below demonstrate how to use <bpt i="0" x="0">&lt;c0&gt;</bpt>without<bpt i="1" x="1">&lt;w1&gt;</bpt>Actually<bpt i="2" x="2">&lt;w2&gt;</bpt>Escaping(_:<bpt i="3" x="3">&lt;w3&gt;</bpt>do:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> in conjunction with two common APIs that use escaping closures: lazy collection views and asynchronous operations.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下の例は、脱出クロージャ：遅延コレクションビューと非同期演算を使う２つのよくあるAPIと連係して、<bpt i="0" x="0">&lt;c0&gt;</bpt>without<bpt i="1" x="1">&lt;w1&gt;</bpt>Actually<bpt i="2" x="2">&lt;w2&gt;</bpt>Escaping(_:<bpt i="3" x="3">&lt;w3&gt;</bpt>do:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使う方法を実演します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The exponent of the floating-point value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>浮動小数点値の指数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The fact that all collections are finite guarantees the safety of many sequence operations, such as using the <bpt i="1" x="1">&lt;c1&gt;</bpt>contains(_:)<ept i="1">&lt;/c1&gt;</ept> method to test whether a collection includes an element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>すべてのコレクションが有限であるという事実は、多くのシーケンス演算、例えば<bpt i="1" x="1">&lt;c1&gt;</bpt>contains(_:)<ept i="1">&lt;/c1&gt;</ept>メソッドを使ってコレクションがある要素を含むかどうかテストすることなどの安全を保証します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The file name to print with <bpt i="0" x="0">&lt;c0&gt;</bpt>message<ept i="0">&lt;/c0&gt;</ept> if the assertion fails.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>表明（アサーション）がうまくいかないならば<bpt i="0" x="0">&lt;c0&gt;</bpt>message<ept i="0">&lt;/c0&gt;</ept>とともに出力するファイル名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The file name to print with <bpt i="0" x="0">&lt;c0&gt;</bpt>message<ept i="0">&lt;/c0&gt;</ept> if the precondition fails.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>前提条件がうまくいかないならば<bpt i="0" x="0">&lt;c0&gt;</bpt>message<ept i="0">&lt;/c0&gt;</ept>とともに出力するファイル名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The file name to print with <bpt i="0" x="0">&lt;c0&gt;</bpt>message<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>message<ept i="0">&lt;/c0&gt;</ept>とともに出力するファイル名。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The filter sequence produces whatever type of element its base sequence produces.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>フィルタシーケンスは、それの基底シーケンスが生み出す要素の型が何であろうとも生み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The final accumulated value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最終的に蓄積された値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The final example passes <bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept> for the <bpt i="1" x="1">&lt;c1&gt;</bpt>omitting<bpt i="2" x="2">&lt;w2&gt;</bpt>Empty<bpt i="3" x="3">&lt;w3&gt;</bpt>Subsequences<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> parameter, so the returned array contains empty strings where spaces were repeated.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最後の例は<bpt i="0" x="0">&lt;c0&gt;</bpt>falseを<ept i="0">&lt;/c0&gt;</ept><bpt i="1" x="1">&lt;c1&gt;</bpt>omitting<bpt i="2" x="2">&lt;w2&gt;</bpt>Empty<bpt i="3" x="3">&lt;w3&gt;</bpt>Subsequences<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>パラメータに渡します、なので返される配列は空白が繰り返されたところで空の文字列を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The final example passes <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> for the <bpt i="1" x="1">&lt;c1&gt;</bpt>allow<bpt i="2" x="2">&lt;w2&gt;</bpt>Empty<bpt i="3" x="3">&lt;w3&gt;</bpt>Slices<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> parameter, so the returned array contains empty strings where spaces were repeated.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最後の例は<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>を<bpt i="1" x="1">&lt;c1&gt;</bpt>allow<bpt i="2" x="2">&lt;w2&gt;</bpt>Empty<bpt i="3" x="3">&lt;w3&gt;</bpt>Slices<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>パラメータに渡します、なので返される配列は空白が繰り返されたところで空の文字列を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first element in the sequence is always <bpt i="0" x="0">&lt;c0&gt;</bpt>first<ept i="0">&lt;/c0&gt;</ept>, and each successive element is the result of invoking <bpt i="1" x="1">&lt;c1&gt;</bpt>next<ept i="1">&lt;/c1&gt;</ept> with the previous element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスでの最初の要素は常に<bpt i="0" x="0">&lt;c0&gt;</bpt>first<ept i="0">&lt;/c0&gt;</ept>です、そして続く要素それぞれは<bpt i="1" x="1">&lt;c1&gt;</bpt>next<ept i="1">&lt;/c1&gt;</ept>を前の要素とともに発動することの結果です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first element of a nonempty array is always at index zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>空でない配列の最初の要素は、常にインデックス０です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first element of the collection if the collection is not empty; otherwise, <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションが空でないならばコレクションの最初の要素；そうでなければ<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first element of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの最初の要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first element of the dictionary is not necessarily the first element added.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書の最初の要素は、必ずしも追加された最初の要素ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first element of the sequence that satisfies <bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>, or <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> if there is no element that satisfies <bpt i="2" x="2">&lt;c2&gt;</bpt>predicate<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>満たすシーケンスの最初の要素、または<bpt i="1" x="1">&lt;c1&gt;</bpt>predicate<ept i="1">&lt;/c1&gt;</ept>を満たす要素が無いならば<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first element to be returned from the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスから返されることになる最初の要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first index where <bpt i="0" x="0">&lt;c0&gt;</bpt>element<ept i="0">&lt;/c0&gt;</ept> is found.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>element<ept i="0">&lt;/c0&gt;</ept>が見つけられたところの最初のインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first key-value pair of the dictionary if the dictionary is not empty; otherwise, <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書が空でないならばこの辞書の最初のキー値ペア；そうでなければ、<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first optional value that isn’t <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> stops the chain and becomes the result of the whole expression.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>でない最初のオプショナル値は、連鎖を停止して、式全体の結果となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first partition, <bpt i="1" x="1">&lt;c1&gt;</bpt>numbers[..&lt;p]<ept i="1">&lt;/c1&gt;</ept>, is made up of the elements that are not greater than 30.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最初の区画、<bpt i="1" x="1">&lt;c1&gt;</bpt>numbers[..&lt;p]<ept i="1">&lt;/c1&gt;</ept>は、30より大きくない要素から構成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first sequence or collection to zip.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>組み合わされる第１のシーケンスまたはコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first use of <bpt i="5" x="5">&lt;c5&gt;</bpt>split<ept i="5">&lt;/c5&gt;</ept> returns each word that was originally separated by one or more spaces.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>split<ept i="5">&lt;/c5&gt;</ept>の最初の利用は、各単語を返します、それはもともと１つ以上の空白で隔てられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first value to add.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>加算する第１の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first value to multiply.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>掛け合わされる第１の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first value to swap.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>交換する１つ目の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first version, <bpt i="0" x="0">&lt;c0&gt;</bpt>present(completion:)<ept i="0">&lt;/c0&gt;</ept>, has a return type of <bpt i="1" x="1">&lt;c1&gt;</bpt>Void<ept i="1">&lt;/c1&gt;</ept> and takes a completion handler.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最初のバージョン、<bpt i="0" x="0">&lt;c0&gt;</bpt>present(completion:)<ept i="0">&lt;/c0&gt;</ept>は、<bpt i="1" x="1">&lt;c1&gt;</bpt>Void<ept i="1">&lt;/c1&gt;</ept>の戻り型を持ち、そしてある完了ハンドラをとります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The flat map sequence produces the type of element in the asynchronous sequence produced by the <bpt i="0" x="0">&lt;c0&gt;</bpt>transform<ept i="0">&lt;/c0&gt;</ept> closure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このフラットマップシーケンスは、<bpt i="0" x="0">&lt;c0&gt;</bpt>transform<ept i="0">&lt;/c0&gt;</ept>クロージャによって生み出される非同期シーケンスの中の要素の型を生み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The flexible behavior of the <bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Object<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol is similar to Objective-C’s <bpt i="2" x="2">&lt;c2&gt;</bpt>id<ept i="2">&lt;/c2&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Object<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルの柔軟な挙動は、Objective-Cのもつ<bpt i="2" x="2">&lt;c2&gt;</bpt>id<ept i="2">&lt;/c2&gt;</ept>型に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The floating-point types in the standard library are <bpt i="0" x="0">&lt;c0&gt;</bpt>Float<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept>, and <bpt i="2" x="2">&lt;c2&gt;</bpt>Float80<ept i="2">&lt;/c2&gt;</ept> where available.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>標準ライブラリにおける浮動小数点型は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Float<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept>、そして利用可能なところでは<bpt i="2" x="2">&lt;c2&gt;</bpt>Float80<ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The floating-point value with the same sign and exponent as this value, but with a significand of 1.0.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値と同じ符号と指数を持つ浮動小数点値、しかし1.0の仮数を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following Objective-C property refers to a view controller that also acts a data source and delegate:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下のObjective-Cプロパティは、あるビューコントローラを参照します、それはまたデータソースと委任先の役割を果たします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following characters are all lowercase:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の文字は全てローワーケースです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following characters are all uppercase:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の文字は全てアッパーケースです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following code declares <bpt i="0" x="0">&lt;c0&gt;</bpt>values<ept i="0">&lt;/c0&gt;</ept>, an array of integers, and the <bpt i="1" x="1">&lt;c1&gt;</bpt>add<bpt i="2" x="2">&lt;w2&gt;</bpt>Ten<bpt i="3" x="3">&lt;w3&gt;</bpt>Quadratic()<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> function, which adds ten more values to the <bpt i="4" x="4">&lt;c4&gt;</bpt>values<ept i="4">&lt;/c4&gt;</ept> array on each call.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下のコードは、整数の配列<bpt i="0" x="0">&lt;c0&gt;</bpt>values<ept i="0">&lt;/c0&gt;</ept>、そして呼び出し毎に10個さらに値を<bpt i="4" x="4">&lt;c4&gt;</bpt>values<ept i="4">&lt;/c4&gt;</ept>配列に加える<bpt i="1" x="1">&lt;c1&gt;</bpt>add<bpt i="2" x="2">&lt;w2&gt;</bpt>Ten<bpt i="3" x="3">&lt;w3&gt;</bpt>Quadratic()<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>関数を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following code declares a <bpt i="0" x="0">&lt;c0&gt;</bpt>perform(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>simultaneously<bpt i="2" x="2">&lt;w2&gt;</bpt>With:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function that uses a dispatch queue to execute two closures concurrently.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下のコードは<bpt i="0" x="0">&lt;c0&gt;</bpt>perform(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>simultaneously<bpt i="2" x="2">&lt;w2&gt;</bpt>With:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数を宣言します、それはあるディスパッチキューを使って２つのクロージャを同時に実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following code declares a method that calculates the total of any sequence with <bpt i="0" x="0">&lt;c0&gt;</bpt>Additive<bpt i="1" x="1">&lt;w1&gt;</bpt>Arithmetic<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下のコードは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Additive<bpt i="1" x="1">&lt;w1&gt;</bpt>Arithmetic<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>要素をもつ何らかのシーケンスの合計を計算するメソッドを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following code declares an <bpt i="0" x="0">&lt;c0&gt;</bpt>all<bpt i="1" x="1">&lt;w1&gt;</bpt>Values(in:<bpt i="2" x="2">&lt;w2&gt;</bpt>match:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function that checks whether all the elements in an array match a predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下のコードは、配列のすべての要素がある述部に合致するかどうかを調べる<bpt i="0" x="0">&lt;c0&gt;</bpt>all<bpt i="1" x="1">&lt;w1&gt;</bpt>Values(in:<bpt i="2" x="2">&lt;w2&gt;</bpt>match:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following code uses this method to test whether all the names in an array have at least five characters:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下のコードは、このメソッドを使って、配列の中の全ての名前が少なくとも５つの文字を含むかどうかを試験します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example accesses an element of an array through its subscript to print its value:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、配列のある要素にそれの添え字によってアクセスしてそれの値を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example appends the elements of a <bpt i="0" x="0">&lt;c0&gt;</bpt>Range&lt;Int&gt;<ept i="0">&lt;/c0&gt;</ept> instance to an array of integers:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Range&lt;Int&gt;<ept i="0">&lt;/c0&gt;</ept>インスタンスからなるいくらかの要素を整数からなる配列に追加します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example calculates the remainder of dividing 8.625 by 0.75:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、8.625を0.75で割ることの余りを計算します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example calculates the truncating remainder of dividing 8.625 by 0.75:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、8.625を0.75で除算することの切り捨てられる余りを計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example checks to see if <bpt i="3" x="3">&lt;c3&gt;</bpt>image<bpt i="4" x="4">&lt;w4&gt;</bpt>Paths<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> contains any paths in the <bpt i="5" x="5">&lt;c5&gt;</bpt>"/glyphs"<ept i="5">&lt;/c5&gt;</ept> directory:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、<bpt i="3" x="3">&lt;c3&gt;</bpt>image<bpt i="4" x="4">&lt;w4&gt;</bpt>Paths<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>が何らかのパスを<bpt i="5" x="5">&lt;c5&gt;</bpt>"/glyphs"<ept i="5">&lt;/c5&gt;</ept>ディレクトリの中に含むかどうかを調べるために検査します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example compares instances of the <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>UInt<ept i="3">&lt;/c3&gt;</ept>, and <bpt i="4" x="4">&lt;c4&gt;</bpt>UInt8<ept i="4">&lt;/c4&gt;</ept> types:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>、<bpt i="3" x="3">&lt;c3&gt;</bpt>UInt<ept i="3">&lt;/c3&gt;</ept>、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>UInt8<ept i="4">&lt;/c4&gt;</ept>型のインスタンスを比較します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example compares the date of the first moon landing with the release of David Bowie’s song “Space Oddity”:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、最初の月面着陸の日付をデビッド・ボウイの歌「Space Oddity」のリリース日と比較します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example compares tuples made up of 2 components:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は２つの構成要素から作り上げられるタプルを比較します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example compares tuples made up of 3 components:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、３つの構成要素で構成されるタプルを比較します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example compares tuples made up of 4 components:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は４つの構成要素から作り上げられるタプルを比較します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example compares tuples made up of 5 components:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は５つの構成要素から作り上げられるタプルを比較します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example compares tuples made up of 6 components:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は６つの構成要素から作り上げられるタプルを比較します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example copies bytes from the <bpt i="0" x="0">&lt;c0&gt;</bpt>byte<bpt i="1" x="1">&lt;w1&gt;</bpt>Values<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> array into <bpt i="2" x="2">&lt;c2&gt;</bpt>numbers<ept i="2">&lt;/c2&gt;</ept>, an array of <bpt i="3" x="3">&lt;c3&gt;</bpt>Int32<ept i="3">&lt;/c3&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、バイトを<bpt i="0" x="0">&lt;c0&gt;</bpt>byte<bpt i="1" x="1">&lt;w1&gt;</bpt>Values<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>配列から、<bpt i="2" x="2">&lt;c2&gt;</bpt>numbers<ept i="2">&lt;/c2&gt;</ept>の配列<bpt i="3" x="3">&lt;c3&gt;</bpt>Int32<ept i="3">&lt;/c3&gt;</ept>へとコピーします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example copies the bytes of the <bpt i="0" x="0">&lt;c0&gt;</bpt>numbers<ept i="0">&lt;/c0&gt;</ept> array into a buffer of <bpt i="1" x="1">&lt;c1&gt;</bpt>UInt8<ept i="1">&lt;/c1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>numbers<ept i="0">&lt;/c0&gt;</ept>配列のバイトを<bpt i="1" x="1">&lt;c1&gt;</bpt>UInt8<ept i="1">&lt;/c1&gt;</ept>のバッファへとコピーします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example creates a <bpt i="0" x="0">&lt;c0&gt;</bpt>Repeated&lt;Int&gt;<ept i="0">&lt;/c0&gt;</ept> collection containing five zeroes:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、５つのゼロを含んでいるある<bpt i="0" x="0">&lt;c0&gt;</bpt>Repeated&lt;Int&gt;<ept i="0">&lt;/c0&gt;</ept>コレクションを作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example creates a <bpt i="0" x="0">&lt;c0&gt;</bpt>first<bpt i="1" x="1">&lt;w1&gt;</bpt>Word<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> constant by using the <bpt i="2" x="2">&lt;c2&gt;</bpt>prefix(while:)<ept i="2">&lt;/c2&gt;</ept> method to get a slice of the <bpt i="3" x="3">&lt;c3&gt;</bpt>text<ept i="3">&lt;/c3&gt;</ept> string.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>first<bpt i="1" x="1">&lt;w1&gt;</bpt>Word<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>定数を<bpt i="2" x="2">&lt;c2&gt;</bpt>prefix(while:)<ept i="2">&lt;/c2&gt;</ept>メソッドを使って<bpt i="3" x="3">&lt;c3&gt;</bpt>text<ept i="3">&lt;/c3&gt;</ept>文字列のスライスを得ることによって作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example creates a new character from the uppercase version of a string that only holds one character.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、１つの文字を保持するだけのある文字列の大文字バージョンから、新しい文字列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example creates a new dictionary and prints the value of a key found in the dictionary (<bpt i="0" x="0">&lt;c0&gt;</bpt>"Coral"<ept i="0">&lt;/c0&gt;</ept>) and a key not found in the dictionary (<bpt i="1" x="1">&lt;c1&gt;</bpt>"Cerise"<ept i="1">&lt;/c1&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は新しい辞書を作成して、辞書に見つかるキー（<bpt i="0" x="0">&lt;c0&gt;</bpt>"Coral"<ept i="0">&lt;/c0&gt;</ept>）と辞書に見つからないキー（<bpt i="1" x="1">&lt;c1&gt;</bpt>"Cerise"<ept i="1">&lt;/c1&gt;</ept>）の値を出力します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example creates a new dictionary using an array of strings as the keys and the integers in a countable range as the values:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、文字列からなる配列をキーとしてそして可付番範囲の中の整数を値として、新しい辞書を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example creates an array of integers from an array literal, then appends the elements of another collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、整数からなるある配列を配列リテラルから作成します、それから別のコレクションの要素を追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example creates an iterator that counts up from the initial value of an integer <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> to 15:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例はあるイテレータを作成します、それは初期値の整数<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>から15まで数え上げます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example declares a function that calculates the length of the hypotenuse of a right triangle given its two perpendicular sides.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例はある関数を宣言します、それは、それの２つの直角側を与えられる直角三角形の斜辺の長さを計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example declares an array of names, and then creates a dictionary from that array by grouping the names by first letter:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、いくらかの名前からなる配列を宣言します、それから名前を最初の文字でグループ分けすることによって、その配列から辞書を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example defines <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> as an instance of <bpt i="1" x="1">&lt;c1&gt;</bpt>UInt8<ept i="1">&lt;/c1&gt;</ept>, an 8-bit, unsigned integer type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>を<bpt i="1" x="1">&lt;c1&gt;</bpt>UInt8<ept i="1">&lt;/c1&gt;</ept>のインスタンス、ある８ビットの、符号なし整数型として定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example defines a <bpt i="0" x="0">&lt;c0&gt;</bpt>print<bpt i="1" x="1">&lt;w1&gt;</bpt>Generic<bpt i="2" x="2">&lt;w2&gt;</bpt>Info(_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function that takes a generic parameter and declares the <bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept> type’s conformance to a new protocol <bpt i="4" x="4">&lt;c4&gt;</bpt>P<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>print<bpt i="1" x="1">&lt;w1&gt;</bpt>Generic<bpt i="2" x="2">&lt;w2&gt;</bpt>Info(_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数を定義します、それは総称体パラメータを取り、<bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>型のもつ準拠を新しいプロトコル<bpt i="4" x="4">&lt;c4&gt;</bpt>P<ept i="4">&lt;/c4&gt;</ept>に宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example defines an <bpt i="0" x="0">&lt;c0&gt;</bpt>Integer<bpt i="1" x="1">&lt;w1&gt;</bpt>Ref<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type, an integer type with reference semantics.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、ある<bpt i="0" x="0">&lt;c0&gt;</bpt>Integer<bpt i="1" x="1">&lt;w1&gt;</bpt>Ref<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型、参照意味論を持つ整数型を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example divides a value that is too large to be represented using a single <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept> instance by another <bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、単一の<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>インスタンスを使って表されるには大きすぎる値を、別の<bpt i="1" x="1">&lt;c1&gt;</bpt>Int<ept i="1">&lt;/c1&gt;</ept>値によって割ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example enumerates the elements of an array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、ある配列の要素を列挙します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example enumerates the elements of an array:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、ある配列の要素を列挙します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example obtains an index advanced four positions from a string’s starting index and then prints the character at that position.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、文字列の開始インデックスから４位置進んだインデックスを取得して、それからその位置の文字を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example obtains an index advanced four positions from an array’s starting index and then prints the element at that position.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、配列の始まりから４位置進んだインデックスを入手して、それからその位置での要素を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example prints a closed range of integers to a string:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>続く例は、整数の完結範囲をある文字列へ出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example prints a string, a closed range of integers, and a group of floating-point values to standard output:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、ある文字列、整数の完結範囲、グループの浮動小数点値を標準出力に出力します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example prints the debugging representation of a string, a closed range of integers, and a group of floating-point values to standard output:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、ある文字列、整数の完結範囲、グループの浮動小数点値のデバッグ表現を標準出力に出力します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example reverses the elements of an array of characters:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、文字列からなる配列の要素を逆順にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example rounds a value using four different rounding rules:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例はある値を４つの丸め規則を使って丸めます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example rounds several values using this default rule:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例はいくつかの値をこの初期設定での規則を使って丸めます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example searches for the index of the number <bpt i="0" x="0">&lt;c0&gt;</bpt>40<ept i="0">&lt;/c0&gt;</ept> in an array of integers, and then prints the suffix of the array starting at that index:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、整数からなる配列において数<bpt i="0" x="0">&lt;c0&gt;</bpt>40<ept i="0">&lt;/c0&gt;</ept>のインデックスを捜して、それからそのインデックスで始まる配列の末尾を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example searches for the index of the number <bpt i="2" x="2">&lt;c2&gt;</bpt>40<ept i="2">&lt;/c2&gt;</ept> in an array of integers, and then prints the prefix of the array up to, and including, that index:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、整数からなる配列において数<bpt i="2" x="2">&lt;c2&gt;</bpt>40<ept i="2">&lt;/c2&gt;</ept>のインデックスを捜して、それからそのインデックスに至るまでの、そしてそれを含めて、配列の冒頭を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example searches for the index of the number <bpt i="2" x="2">&lt;c2&gt;</bpt>40<ept i="2">&lt;/c2&gt;</ept> in an array of integers, and then prints the prefix of the array up to, but not including, that index:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、整数からなる配列において数<bpt i="2" x="2">&lt;c2&gt;</bpt>40<ept i="2">&lt;/c2&gt;</ept>のインデックスを捜して、それからそのインデックスに至るまでの、しかしそれを含めずに、配列の冒頭を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example shows a <bpt i="5" x="5">&lt;c5&gt;</bpt>Counter<ept i="5">&lt;/c5&gt;</ept> type that uses an inner iterator to monotonically generate <bpt i="6" x="6">&lt;c6&gt;</bpt>Int<ept i="6">&lt;/c6&gt;</ept> values until reaching a <bpt i="7" x="7">&lt;c7&gt;</bpt>how<bpt i="8" x="8">&lt;w8&gt;</bpt>High<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、ある<bpt i="5" x="5">&lt;c5&gt;</bpt>Counter<ept i="5">&lt;/c5&gt;</ept>型を示します、それはある内部イテレータを使って<bpt i="6" x="6">&lt;c6&gt;</bpt>Int<ept i="6">&lt;/c6&gt;</ept>値を、<bpt i="7" x="7">&lt;c7&gt;</bpt>how<bpt i="8" x="8">&lt;w8&gt;</bpt>High<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>値に到達するまで単調に生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example shows an <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<bpt i="1" x="1">&lt;w1&gt;</bpt>Parsing<bpt i="2" x="2">&lt;w2&gt;</bpt>Error<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> enumeration that captures two different kinds of errors that can occur when parsing an integer from a string: overflow, where the value represented by the string is too large for the integer data type, and invalid input, where nonnumeric characters are found within the input.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<bpt i="1" x="1">&lt;w1&gt;</bpt>Parsing<bpt i="2" x="2">&lt;w2&gt;</bpt>Error<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>列挙を示します、それが捕える（キャプチャ）のは、文字列から整数を構文解析（パース）する時に起こる可能性のある２つの異なる種類のエラー：文字列によって表される値が整数データ型に対して大きすぎるところのオーバーフロー、そして非数の文字が入力内に見つけられるところの無効な入力です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example shows how NaN values operate in different contexts.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、どのようにNaN値が異なる前後関係において作動するかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example shows how an array of strings can be joined to a single, comma-separated string:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、どのように文字列からなる配列が単一の、コンマ区切りの文字列へと連結できるかを示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example shows how an iterator can be used explicitly to emulate a <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> loop.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の例は、イテレータが明示的に使われて<bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>ループの機能を真似る方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example shows how extending and truncating work for nonnegative integers:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>後に続く例は、非負数整数に対する拡張および切り詰め作業の方法を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example shows how modifying the contents of the <bpt i="0" x="0">&lt;c0&gt;</bpt>Unsafe<bpt i="1" x="1">&lt;w1&gt;</bpt>Mutable<bpt i="2" x="2">&lt;w2&gt;</bpt>Buffer<bpt i="3" x="3">&lt;w3&gt;</bpt>Pointer<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> argument to <bpt i="4" x="4">&lt;c4&gt;</bpt>body<ept i="4">&lt;/c4&gt;</ept> alters the contents of the array:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、<bpt i="4" x="4">&lt;c4&gt;</bpt>body<ept i="4">&lt;/c4&gt;</ept>への<bpt i="0" x="0">&lt;c0&gt;</bpt>Unsafe<bpt i="1" x="1">&lt;w1&gt;</bpt>Mutable<bpt i="2" x="2">&lt;w2&gt;</bpt>Buffer<bpt i="3" x="3">&lt;w3&gt;</bpt>Pointer<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>引数の内容の修正が、配列の内容を改めることを示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example shows how the <bpt i="3" x="3">&lt;c3&gt;</bpt>contains(_:)<ept i="3">&lt;/c3&gt;</ept> method can be used with an array of strings.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、<bpt i="3" x="3">&lt;c3&gt;</bpt>contains(_:)<ept i="3">&lt;/c3&gt;</ept>メソッドが文字列からなる配列で使われるのを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example shows how to choose the first and last values for any duplicate keys:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、あらゆる重複キーに対して最初と最後の値を選択する方法を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example shows how to iterate over <bpt i="6" x="6">&lt;c6&gt;</bpt>Counter<ept i="6">&lt;/c6&gt;</ept>, a custom <bpt i="7" x="7">&lt;c7&gt;</bpt>Async<bpt i="8" x="8">&lt;w8&gt;</bpt>Sequence<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> that produces <bpt i="9" x="9">&lt;c9&gt;</bpt>Int<ept i="9">&lt;/c9&gt;</ept> values from <bpt i="10" x="10">&lt;c10&gt;</bpt>1<ept i="10">&lt;/c10&gt;</ept> up to a <bpt i="11" x="11">&lt;c11&gt;</bpt>how<bpt i="12" x="12">&lt;w12&gt;</bpt>High<ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> value:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、どのように<bpt i="6" x="6">&lt;c6&gt;</bpt>Counter<ept i="6">&lt;/c6&gt;</ept>、あるあつらえの<bpt i="7" x="7">&lt;c7&gt;</bpt>Async<bpt i="8" x="8">&lt;w8&gt;</bpt>Sequence<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>で<bpt i="9" x="9">&lt;c9&gt;</bpt>Int<ept i="9">&lt;/c9&gt;</ept>値を<bpt i="10" x="10">&lt;c10&gt;</bpt>1<ept i="10">&lt;/c10&gt;</ept>から<bpt i="11" x="11">&lt;c11&gt;</bpt>how<bpt i="12" x="12">&lt;w12&gt;</bpt>High<ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>値に至るまで生み出すもの、のすべてにわたって反復するかを示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example shows how you can bridge an <bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept> instance to <bpt i="1" x="1">&lt;c1&gt;</bpt>NSArray<ept i="1">&lt;/c1&gt;</ept> to use the <bpt i="2" x="2">&lt;c2&gt;</bpt>write(to:<bpt i="3" x="3">&lt;w3&gt;</bpt>atomically:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、どのようにあなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept>インスタンスを<bpt i="1" x="1">&lt;c1&gt;</bpt>NSArray<ept i="1">&lt;/c1&gt;</ept>へとブリッジして、<bpt i="2" x="2">&lt;c2&gt;</bpt>write(to:<bpt i="3" x="3">&lt;w3&gt;</bpt>atomically:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドを使うかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example shows how you can iterate over the contents of the buffer pointer:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の例は、どのようにあなたがバッファポインタの内容にわたって反復できるかを示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example shows the array literal initializer for a hypothetical <bpt i="2" x="2">&lt;c2&gt;</bpt>Ordered<bpt i="3" x="3">&lt;w3&gt;</bpt>Set<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type, which has setlike semantics but maintains the order of its elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、仮設的な<bpt i="2" x="2">&lt;c2&gt;</bpt>Ordered<bpt i="3" x="3">&lt;w3&gt;</bpt>Set<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型のための配列リテラルイニシャライザを示します、それは集合的な意味論を持つけれどもそれの要素の順番を維持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example shows the dictionary literal initializer for a hypothetical <bpt i="2" x="2">&lt;c2&gt;</bpt>Counted<bpt i="3" x="3">&lt;w3&gt;</bpt>Set<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type, which uses setlike semantics while keeping track of the count for duplicate elements:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、仮設的な<bpt i="2" x="2">&lt;c2&gt;</bpt>Counted<bpt i="3" x="3">&lt;w3&gt;</bpt>Set<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型のための辞書リテラルイニシャライザを示します、それは集合的な意味論を使う一方で重複する要素に対する総数を追跡し続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example shows the results of rounding numbers using this rule:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、この規則を使っての数の丸めの結果を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example transcodes the UTF-8 representation of the string <bpt i="0" x="0">&lt;c0&gt;</bpt>"Fermata 𝄐"<ept i="0">&lt;/c0&gt;</ept> into UTF-32.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、文字列<bpt i="0" x="0">&lt;c0&gt;</bpt>"Fermata 𝄐"<ept i="0">&lt;/c0&gt;</ept>のUTF-8表現をUTF-32にコード変換（トランスコード）します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example updates the value for the <bpt i="1" x="1">&lt;c1&gt;</bpt>404<ept i="1">&lt;/c1&gt;</ept> code to be simply “Not found” and removes the key-value pair for the <bpt i="2" x="2">&lt;c2&gt;</bpt>500<ept i="2">&lt;/c2&gt;</ept> code entirely.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、<bpt i="1" x="1">&lt;c1&gt;</bpt>404<ept i="1">&lt;/c1&gt;</ept>コードの値を単純に「Not found」に更新して、<bpt i="2" x="2">&lt;c2&gt;</bpt>500<ept i="2">&lt;/c2&gt;</ept>コードに対するキー値ペアをすっかり削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example uses <bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Totally<bpt i="2" x="2">&lt;w2&gt;</bpt>Ordered(below<bpt i="3" x="3">&lt;w3&gt;</bpt>Or<bpt i="4" x="4">&lt;w4&gt;</bpt>Equal<bpt i="5" x="5">&lt;w5&gt;</bpt>To:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to sort an array of floating-point values, including some that are NaN:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Totally<bpt i="2" x="2">&lt;w2&gt;</bpt>Ordered(below<bpt i="3" x="3">&lt;w3&gt;</bpt>Or<bpt i="4" x="4">&lt;w4&gt;</bpt>Equal<bpt i="5" x="5">&lt;w5&gt;</bpt>To:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使って、NaNである何かを含んでいる、浮動小数点値の配列をソートします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example uses a structure to represent an error when parsing an XML document, including the line and column numbers where the error occurred:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、構造体を使ってXML書類をパースする時にエラーを表して、行およびコラム番号をエラーが生じたときに含めます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example uses an enumeration of playing cards ranks, <bpt i="0" x="0">&lt;c0&gt;</bpt>Rank<ept i="0">&lt;/c0&gt;</ept>, which ranges from <bpt i="1" x="1">&lt;c1&gt;</bpt>ace<ept i="1">&lt;/c1&gt;</ept> (low) to <bpt i="2" x="2">&lt;c2&gt;</bpt>king<ept i="2">&lt;/c2&gt;</ept> (high).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、トランプのランクそれらからなるある列挙、<bpt i="0" x="0">&lt;c0&gt;</bpt>Rank<ept i="0">&lt;/c0&gt;</ept>を使います、それは<bpt i="1" x="1">&lt;c1&gt;</bpt>ace<ept i="1">&lt;/c1&gt;</ept>（低）から<bpt i="2" x="2">&lt;c2&gt;</bpt>king<ept i="2">&lt;/c2&gt;</ept>（高）までに及びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example uses indexed subscripting to update an array’s second element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の例は、インデックスでの添え字を使って、配列の２番目の要素を更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example uses the <bpt i="0" x="0">&lt;c0&gt;</bpt>drop(while:)<ept i="0">&lt;/c0&gt;</ept> method to skip over the positive numbers at the beginning of the <bpt i="1" x="1">&lt;c1&gt;</bpt>numbers<ept i="1">&lt;/c1&gt;</ept> array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>drop(while:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使って、正の数を<bpt i="1" x="1">&lt;c1&gt;</bpt>numbers<ept i="1">&lt;/c1&gt;</ept>配列の始まりで省きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example uses the <bpt i="0" x="0">&lt;c0&gt;</bpt>first(where:)<ept i="0">&lt;/c0&gt;</ept> method to find the first negative number in an array of integers:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>first(where:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使って、整数の配列において最初の負数を見つけます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example uses the <bpt i="0" x="0">&lt;c0&gt;</bpt>negate()<ept i="0">&lt;/c0&gt;</ept> method to negate the value of an integer <bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は<bpt i="0" x="0">&lt;c0&gt;</bpt>negate()<ept i="0">&lt;/c0&gt;</ept>メソッドを使って、整数<bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept>の値を負にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example uses the <bpt i="0" x="0">&lt;c0&gt;</bpt>prefix(while:)<ept i="0">&lt;/c0&gt;</ept> method to find the positive numbers at the beginning of the <bpt i="1" x="1">&lt;c1&gt;</bpt>numbers<ept i="1">&lt;/c1&gt;</ept> array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>prefix(while:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使って、正の数を<bpt i="1" x="1">&lt;c1&gt;</bpt>numbers<ept i="1">&lt;/c1&gt;</ept>配列の始まりで見つけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example uses the <bpt i="2" x="2">&lt;c2&gt;</bpt>~=<ept i="2">&lt;/c2&gt;</ept> operator to test whether an integer is included in a range of single-digit numbers:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、<bpt i="2" x="2">&lt;c2&gt;</bpt>~=<ept i="2">&lt;/c2&gt;</ept>演算子を使って、ある整数が一桁の数いくつかからなるある範囲に含まれるかどうか調べます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example uses the <bpt i="3" x="3">&lt;c3&gt;</bpt>zip(_:<bpt i="4" x="4">&lt;w4&gt;</bpt>_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> function to iterate over an array of strings and a countable range at the same time:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は<bpt i="3" x="3">&lt;c3&gt;</bpt>zip(_:<bpt i="4" x="4">&lt;w4&gt;</bpt>_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>関数を使って、同時に文字列からなる配列とある可付番範囲の全体にわたって反復します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example uses this initializer to create a new <bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept> instance with the sign of <bpt i="1" x="1">&lt;c1&gt;</bpt>a<ept i="1">&lt;/c1&gt;</ept> and the magnitude of <bpt i="2" x="2">&lt;c2&gt;</bpt>b<ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、このイニシャライザを使って新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept>インスタンスを<bpt i="1" x="1">&lt;c1&gt;</bpt>a<ept i="1">&lt;/c1&gt;</ept>の符号と<bpt i="2" x="2">&lt;c2&gt;</bpt>b<ept i="2">&lt;/c2&gt;</ept>の規模で作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example uses this initializer to create a new <bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、このイニシャライザを使って新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept>インスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example uses this method to convert a partial range up to <bpt i="1" x="1">&lt;c1&gt;</bpt>4<ept i="1">&lt;/c1&gt;</ept> into a half-open range, using an array instance to add the range’s lower bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、このメソッドを使って、<bpt i="1" x="1">&lt;c1&gt;</bpt>4<ept i="1">&lt;/c1&gt;</ept>までの不完全な範囲を半開範囲へと変換します、配列インスタンスを使って範囲の下側の境界を追加しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example uses this method to multiply two <bpt i="6" x="6">&lt;c6&gt;</bpt>Int8<ept i="6">&lt;/c6&gt;</ept> values that normally overflow when multiplied:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、このメソッドを使って、通常は乗算した時オーバーフローする２つの<bpt i="6" x="6">&lt;c6&gt;</bpt>Int8<ept i="6">&lt;/c6&gt;</ept>値を乗算します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example uses this method to multiply two <bpt i="6" x="6">&lt;c6&gt;</bpt>UInt8<ept i="6">&lt;/c6&gt;</ept> values that normally overflow when multiplied:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、このメソッドを使って、通常は乗算した時オーバーフローする２つの<bpt i="6" x="6">&lt;c6&gt;</bpt>UInt8<ept i="6">&lt;/c6&gt;</ept>値を乗算します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example uses this subscript while counting the occurrences of each letter in a string:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、この添え字を、ある文字列の中の各印字の出現を数える間に使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following examples show the effects of the <bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Splits<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>omitting<bpt i="3" x="3">&lt;w3&gt;</bpt>Empty<bpt i="4" x="4">&lt;w4&gt;</bpt>Subsequences<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> parameters when splitting a string at each space character (” “).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Splits<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>omitting<bpt i="3" x="3">&lt;w3&gt;</bpt>Empty<bpt i="4" x="4">&lt;w4&gt;</bpt>Subsequences<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>パラメータの効果を、各空白文字（” “）で文字列を分割する場合で示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following examples show the effects of the <bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Splits<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>omitting<bpt i="3" x="3">&lt;w3&gt;</bpt>Empty<bpt i="4" x="4">&lt;w4&gt;</bpt>Subsequences<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> parameters when splitting a string using a closure that matches spaces.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Splits<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>omitting<bpt i="3" x="3">&lt;w3&gt;</bpt>Empty<bpt i="4" x="4">&lt;w4&gt;</bpt>Subsequences<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>パラメータの効果を、空白にマッチするクロージャを使って文字列を分割する場合で示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following special cases also apply:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の特別な場合もまた適用されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following tables use <bpt i="0" x="0">&lt;c0&gt;</bpt>Type<ept i="0">&lt;/c0&gt;</ept> as a placeholder type name to indicate syntax for the mappings.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の表は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Type<ept i="0">&lt;/c0&gt;</ept>をプレースホルダー型名として使ってマップのための構文を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The function uses <bpt i="5" x="5">&lt;c5&gt;</bpt>type(of:)<ept i="5">&lt;/c5&gt;</ept> to find the dynamic type of <bpt i="6" x="6">&lt;c6&gt;</bpt>value<ept i="6">&lt;/c6&gt;</ept>, which itself is an instance of the <bpt i="7" x="7">&lt;c7&gt;</bpt>Smiley<bpt i="8" x="8">&lt;w8&gt;</bpt>.Type<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> metatype.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この関数は、<bpt i="5" x="5">&lt;c5&gt;</bpt>type(of:)<ept i="5">&lt;/c5&gt;</ept>を使って<bpt i="6" x="6">&lt;c6&gt;</bpt>value<ept i="6">&lt;/c6&gt;</ept>の動的型を見つけます、それはそれ自身が<bpt i="7" x="7">&lt;c7&gt;</bpt>Smiley<bpt i="8" x="8">&lt;w8&gt;</bpt>.Type<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>メタタイプのインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The function uses the <bpt i="2" x="2">&lt;c2&gt;</bpt>multiplied<bpt i="3" x="3">&lt;w3&gt;</bpt>Reporting<bpt i="4" x="4">&lt;w4&gt;</bpt>Overflow(by:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method to multiply <bpt i="5" x="5">&lt;c5&gt;</bpt>x<ept i="5">&lt;/c5&gt;</ept> by itself and check whether the result is too large to represent in the same type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この関数は、<bpt i="2" x="2">&lt;c2&gt;</bpt>multiplied<bpt i="3" x="3">&lt;w3&gt;</bpt>Reporting<bpt i="4" x="4">&lt;w4&gt;</bpt>Overflow(by:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドを使って、<bpt i="5" x="5">&lt;c5&gt;</bpt>x<ept i="5">&lt;/c5&gt;</ept>をそれ自身で乗算して、結果が同じ型で表現するのに大きすぎないかどうか検査します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The function won’t compile as written, because a lazy collection’s <bpt i="3" x="3">&lt;c3&gt;</bpt>filter(_:)<ept i="3">&lt;/c3&gt;</ept> method requires an escaping closure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この関数は書いた通りにコンパイルしないでしょう、なぜなら遅延コレクションのもつ<bpt i="3" x="3">&lt;c3&gt;</bpt>filter(_:)<ept i="3">&lt;/c3&gt;</ept>メソッドが脱出クロージャを要求するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The given argument without any changes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>何ら変更のない、与えられた引数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The given string may begin with a plus or minus sign character (<bpt i="0" x="0">&lt;c0&gt;</bpt>+<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>-<ept i="1">&lt;/c1&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた文字列は、プラスまたはマイナス符号文字（<bpt i="0" x="0">&lt;c0&gt;</bpt>+<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>-<ept i="1">&lt;/c1&gt;</ept>）で始まっても構いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The global <bpt i="0" x="0">&lt;c0&gt;</bpt>abs(_:)<ept i="0">&lt;/c0&gt;</ept> function provides more familiar syntax when you need to find an absolute value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>グローバル<bpt i="0" x="0">&lt;c0&gt;</bpt>abs(_:)<ept i="0">&lt;/c0&gt;</ept>関数は、あなたが絶対値を見つける必要がある時により親しみやすい構文を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The greater of <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept>, or whichever is a number if the other is NaN.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept>のより大きい方、または他方がNaNならば数である方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The greater of <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept>のうちより大きいもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The greatest finite number representable by this type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型によって表現可能な最も大きな有限数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The greatest of all the arguments.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>すべての引数のうち最も大きいもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The greatest representable value that compares less than this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>表現可能な最も大きい値で、この値と比較してより小さいもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The hash algorithm implemented by <bpt i="1" x="1">&lt;c1&gt;</bpt>Hasher<ept i="1">&lt;/c1&gt;</ept> may itself change between any two versions of the standard library.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Hasher<ept i="1">&lt;/c1&gt;</ept>によって実装されるハッシュアルゴリズムは、標準ライブラリの任意の２つのバージョン間でそれ自体が変化するかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The hash value calculated by the hasher.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ハーシャーによって計算されるハッシュ値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The hash value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ハッシュ値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The hasher to use when combining the components of this instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このインスタンスの構成要素を結合する場合に使うハーシャー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The hasher uses a per-execution seed value that is set during process startup, usually from a high-quality random source.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ハーシャーは実行毎シード値を使います、それはプロセスの立ち上げの間に設定されます、ふつうは高品質の無作為出典から。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The header's name is generated from your product module name, followed by <bpt i="0" x="0">&lt;c0&gt;</bpt>"-Swift<bpt i="1" x="1">&lt;w1&gt;</bpt>.h"<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ヘッダの名前は、あなたの製品モジュール名から、それに<bpt i="0" x="0">&lt;c0&gt;</bpt>"-Swift<bpt i="1" x="1">&lt;w1&gt;</bpt>.h"<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を続けることで生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The identical-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>===<ept i="0">&lt;/c0&gt;</ept>) returns <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept> when comparing two references to different object instances, even if the two instances have the same value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同一性演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>===<ept i="0">&lt;/c0&gt;</ept>）は、２つのインスタンスを比較して異なるオブジェクトインスタンスであるとき<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>を返します、２つのインスタンスが同じ値を持つとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The identity of a class instance is not part of an instance’s value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>クラスインスタンスの同一性は、インスタンスの持つ値の部分のことではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The implementation of the <bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept> function returns the same value whether its two arguments are the same instance or are two different instances with the same integer stored in their <bpt i="1" x="1">&lt;c1&gt;</bpt>value<ept i="1">&lt;/c1&gt;</ept> properties.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept>関数の実装は、それの２つの引数が同じインスタンスであろうと、それらの<bpt i="1" x="1">&lt;c1&gt;</bpt>value<ept i="1">&lt;/c1&gt;</ept>プロハティの中に格納される同じ整数を持つ２つの異なるインスタンスであろうと、同じ値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The imported <bpt i="0" x="0">&lt;c0&gt;</bpt>Cake<ept i="0">&lt;/c0&gt;</ept> structure and its nested types are imported with a memberwise initializer that you can use to initialize the structure with custom values for its fields:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インポートされた<bpt i="0" x="0">&lt;c0&gt;</bpt>Cake<ept i="0">&lt;/c0&gt;</ept>構造体とそれの入れ子にされる型は、あるメンバー関連イニシャライザを使ってインポートされます、それをあなたは使うことで構造体をそれのフィールドにカスタム値を使って初期化できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The imported Swift structure contains a stored property for each C structure field and an initializer whose parameters correspond to the stored properties.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インポートされたSwift構造体は、各C構造体フィールドに対してひとつの格納プロパティを、そしてそれのパラメータが格納プロパティと対応するひとつのイニシャライザを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The index at which to start the resulting subsequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それで結果の下位シーケンスが始まるインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The index for <bpt i="0" x="0">&lt;c0&gt;</bpt>key<ept i="0">&lt;/c0&gt;</ept> and its associated value if <bpt i="1" x="1">&lt;c1&gt;</bpt>key<ept i="1">&lt;/c1&gt;</ept> is in the dictionary; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>key<ept i="0">&lt;/c0&gt;</ept>とそれの結び付けられた値のインデックス、<bpt i="1" x="1">&lt;c1&gt;</bpt>key<ept i="1">&lt;/c1&gt;</ept>が辞書の中にあるならば；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The index immediately after <bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept>の直後のインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The index immediately before <bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept>の直前のインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The index of the element to access.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>アクセスする要素のインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The index of the first element for which <bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept> returns <bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それに対して<bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>が<bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>を返す最初の要素のインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The index of the first element in the reordered collection that matches <bpt i="0" x="0">&lt;c0&gt;</bpt>belongs<bpt i="1" x="1">&lt;w1&gt;</bpt>In<bpt i="2" x="2">&lt;w2&gt;</bpt>Second<bpt i="3" x="3">&lt;w3&gt;</bpt>Partition<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>並べ直されたコレクションの中の最初の要素のインデックス、それは<bpt i="0" x="0">&lt;c0&gt;</bpt>belongs<bpt i="1" x="1">&lt;w1&gt;</bpt>In<bpt i="2" x="2">&lt;w2&gt;</bpt>Second<bpt i="3" x="3">&lt;w3&gt;</bpt>Partition<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に合致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The index of the first value to swap.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>交換する１つ目の値のインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The index of the last element in the collection that matches <bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>, or <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> if no elements match.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>に合致する、コレクションの中の最後の要素のインデックス、または合致する要素がないならば<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The index of the last element to include in the resulting subsequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果の下位シーケンスの中に含まれることになる最後の要素のインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The index of the second value to swap.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>交換する２つ目の値のインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The index type for arrays, <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列のためのインデックス型、<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The index value immediately after <bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept>の直後のインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The index value immediately before <bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>i<ept i="0">&lt;/c0&gt;</ept>の直前のインデックス値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The indices that are valid for subscripting the collection, in ascending order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの添え字に使うのに有効である、昇順でのインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The initial state that will be passed to the closure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>初期状態、それはクロージャに渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The input string to convert to a <bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept>インスタンスへ変換することになる入力文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The input string to convert to a <bpt i="0" x="0">&lt;c0&gt;</bpt>Float16<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Float16<ept i="0">&lt;/c0&gt;</ept>インスタンスへ変換することになる入力文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The input string to convert to a <bpt i="0" x="0">&lt;c0&gt;</bpt>Float80<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Float80<ept i="0">&lt;/c0&gt;</ept>インスタンスへ変換することになる入力文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The input string to convert to a <bpt i="0" x="0">&lt;c0&gt;</bpt>Float<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Float<ept i="0">&lt;/c0&gt;</ept>インスタンスへ変換することになる入力文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The insertions contained by this difference, from lowest offset to highest.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この差異によって含まれる挿入、最も低いオフセットから最も高い方へと。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The instance <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>, cast to type <bpt i="1" x="1">&lt;c1&gt;</bpt>T<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インスタンス<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>、型<bpt i="1" x="1">&lt;c1&gt;</bpt>T<ept i="1">&lt;/c1&gt;</ept>にキャスト済み。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The instance passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept>として渡されるインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The instance passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> must be an instance of type <bpt i="1" x="1">&lt;c1&gt;</bpt>T<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>として渡されるインスタンスは、型<bpt i="1" x="1">&lt;c1&gt;</bpt>T<ept i="1">&lt;/c1&gt;</ept>のインスタンスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The instance to cast to <bpt i="0" x="0">&lt;c0&gt;</bpt>type<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>type<ept i="0">&lt;/c0&gt;</ept>にキャストすることになるインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The instances of <bpt i="8" x="8">&lt;c8&gt;</bpt>NSDictionary<ept i="8">&lt;/c8&gt;</ept> and <bpt i="9" x="9">&lt;c9&gt;</bpt>Dictionary<ept i="9">&lt;/c9&gt;</ept> share buffer using the same copy-on-write optimization that is used when two instances of <bpt i="10" x="10">&lt;c10&gt;</bpt>Dictionary<ept i="10">&lt;/c10&gt;</ept> share buffer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="8" x="8">&lt;c8&gt;</bpt>NSDictionary<ept i="8">&lt;/c8&gt;</ept>と<bpt i="9" x="9">&lt;c9&gt;</bpt>Dictionary<ept i="9">&lt;/c9&gt;</ept>インスタンスは、<bpt i="10" x="10">&lt;c10&gt;</bpt>Dictionary<ept i="10">&lt;/c10&gt;</ept>の２つのインスタンスがバッファを共有するとき使われるのと、同じコピーオンライト最適化を使ってバッファを共有します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The integer encoding of a <bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある<bpt i="0" x="0">&lt;c0&gt;</bpt>Double<ept i="0">&lt;/c0&gt;</ept>インスタンスの整数符号化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The integer encoding of a <bpt i="0" x="0">&lt;c0&gt;</bpt>Float16<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある<bpt i="0" x="0">&lt;c0&gt;</bpt>Float16<ept i="0">&lt;/c0&gt;</ept>インスタンスの整数符号化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The integer encoding of a <bpt i="0" x="0">&lt;c0&gt;</bpt>Float<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある<bpt i="0" x="0">&lt;c0&gt;</bpt>Float<ept i="0">&lt;/c0&gt;</ept>インスタンスの整数符号化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The integer to convert to a floating-point value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>浮動小数点値へ変換されることになる整数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The integer to convert, an instance of type <bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>変換する整数、型<bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept>のあるインスタンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The integer value of the desired key.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>望むキーの整数値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The integer value of the unique identifier wrapped in a data value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>データ値の中にラップされる特有識別子の整数値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The integer wrapped in a data value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるデータ値の中にラップされる整数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The integral value found by rounding using <bpt i="0" x="0">&lt;c0&gt;</bpt>rule<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>rule<ept i="0">&lt;/c0&gt;</ept>を使って丸められることによって見出される整数値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The iterator can choose how to handle and respond to cancellation, including:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>イテレータは、どのように取り消しを処理してそして応答するかを選択できます、それは次を含みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The iterator for <bpt i="0" x="0">&lt;c0&gt;</bpt>Enumerated<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Enumerated<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のためのイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The iterator returns <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> to indicate the end of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>イテレータ（反復子）は、<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>を返すことでシーケンスの終わりを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The iterator that produces elements of the compact map sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コンパクトマップシーケンスの要素それらを生み出すイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The iterator that produces elements of the drop-first sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>drop-firstシーケンスの要素それらを生み出すイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The iterator that produces elements of the drop-while sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>drop-whileシーケンスの要素それらを生み出すイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The iterator that produces elements of the filter sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>フィルタシーケンスの要素それらを生み出すイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The iterator that produces elements of the flat map sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>フラットマップシーケンスの要素それらを生み出すイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The iterator that produces elements of the map sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>マップシーケンスの要素それらを生み出すイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The iterator that produces elements of the prefix sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>prefixシーケンスの要素それらを生み出すイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The iterator that produces elements of the prefix-while sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>prefix-whileシーケンスの要素それらを生み出すイテレータ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The joined sequence of elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>つなぎ合わされたシーケンス要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The key path to append.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>追加することになるキーパス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The key the look up in the dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書の中を検索するキー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The key to associate with <bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept>と結び付けられるキー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The key to compare against.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このキーに対して比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The key to compare with.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このキーと比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The key to find in the dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このキーが辞書において捜されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The key to remove along with its associated value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それの関連する値とともに削除されるキー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The key type of a dictionary literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書リテラルのキー型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The key type to use for the container.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コンテナに対して使うためのキー型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The key-value pair that correspond to <bpt i="0" x="0">&lt;c0&gt;</bpt>index<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>index<ept i="0">&lt;/c0&gt;</ept>に対応するキー値ペア。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The key-value pairs that will make up the new dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい辞書を作り上げるキー値ペア。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The key’s hash value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのキーのもつハッシュ値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The key’s string value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キーのもつ文字列値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The lanewise maximum of two vectors.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つのベクターのレーン単位の最大。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The lanewise minimum of two vectors.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つのベクターのレーン単位最小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The last element of the collection if the collection has one or more elements; otherwise, <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションが１つ以上の要素を持つならばコレクションの最後の要素；そうでなければ<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The last element of the collection if the collection is not empty; otherwise, <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションが空でないならばコレクションの最後の要素；そうでなければ<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The last element of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの最後の要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The last element of the sequence that satisfies <bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>, or <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> if there is no element that satisfies <bpt i="2" x="2">&lt;c2&gt;</bpt>predicate<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>predicate<ept i="0">&lt;/c0&gt;</ept>満たすシーケンスの最後の要素、または<bpt i="1" x="1">&lt;c1&gt;</bpt>predicate<ept i="1">&lt;/c1&gt;</ept>を満たす要素が無いならば<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The last index where <bpt i="0" x="0">&lt;c0&gt;</bpt>element<ept i="0">&lt;/c0&gt;</ept> is found.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そこで<bpt i="0" x="0">&lt;c0&gt;</bpt>element<ept i="0">&lt;/c0&gt;</ept>が見つけられた最後のインデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The lazy collection isn’t persisted, so the <bpt i="4" x="4">&lt;c4&gt;</bpt>predicate<ept i="4">&lt;/c4&gt;</ept> closure won’t actually escape the body of the function; nevertheless, it can’t be used in this way.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>遅延コレクションは持続させられません、それで<bpt i="4" x="4">&lt;c4&gt;</bpt>predicate<ept i="4">&lt;/c4&gt;</ept>クロージャは実際には関数の本文を脱出することはありません；それはこの方法では使用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The least normal exponent for values of the type <bpt i="0" x="0">&lt;c0&gt;</bpt>F<ept i="0">&lt;/c0&gt;</ept> is <bpt i="1" x="1">&lt;c1&gt;</bpt>1 - bias<ept i="1">&lt;/c1&gt;</ept>, and the largest finite exponent is <bpt i="2" x="2">&lt;c2&gt;</bpt>bias<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型<bpt i="0" x="0">&lt;c0&gt;</bpt>F<ept i="0">&lt;/c0&gt;</ept>の最小正規化指数は、<bpt i="1" x="1">&lt;c1&gt;</bpt>1 - bias<ept i="1">&lt;/c1&gt;</ept>です、最大有限指数は<bpt i="2" x="2">&lt;c2&gt;</bpt>bias<ept i="2">&lt;/c2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The least of all the arguments.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>すべての引数のうち最も少ないもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The least positive normal number.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最も小さい正のノーマル数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The least positive number.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最も小さい正の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The least representable value that compares greater than this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>表現可能な最も小さい値で、この値と比較してより大きいもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The left-hand side of the operation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>演算子の左手側。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The lesser of <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept>のうちより小さいもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The line number to print along with <bpt i="0" x="0">&lt;c0&gt;</bpt>message<ept i="0">&lt;/c0&gt;</ept> if the assertion fails.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>表明（アサーション）がうまくいかないならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>message<ept i="0">&lt;/c0&gt;</ept>とともに出力する行番号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The line number to print along with <bpt i="0" x="0">&lt;c0&gt;</bpt>message<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>message<ept i="0">&lt;/c0&gt;</ept>に加えて出力される行番号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The little-endian representation of this integer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この整数のリトルエンディアン表現。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The logical AND operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;&amp;<ept i="0">&lt;/c0&gt;</ept>) combines two Boolean values and returns <bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept> if both of the values are <bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>論理AND演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;&amp;<ept i="0">&lt;/c0&gt;</ept>）は２つのブール値を組み合わせて、<bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>を両方の値が<bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>ならば返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The logical NOT operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>!<ept i="0">&lt;/c0&gt;</ept>) inverts a Boolean value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>論理NOT演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>!<ept i="0">&lt;/c0&gt;</ept>）は、ブール値を逆にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The logical OR operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>||<ept i="0">&lt;/c0&gt;</ept>) combines two Boolean values and returns <bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept> if at least one of the values is <bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>論理OR演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>||<ept i="0">&lt;/c0&gt;</ept>）は、２つのブール値を組み合わせて、<bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>を値の少なくとも１つが<bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>ならば返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The lower bound for the range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲の下側の境界。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The magnitude of a floating-point value <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> of type <bpt i="1" x="1">&lt;c1&gt;</bpt>F<ept i="1">&lt;/c1&gt;</ept> can be calculated by using the following formula, where <bpt i="2" x="2">&lt;c2&gt;</bpt>**<ept i="2">&lt;/c2&gt;</ept> is exponentiation:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型<bpt i="1" x="1">&lt;c1&gt;</bpt>F<ept i="1">&lt;/c1&gt;</ept>の浮動小数点値<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>の規模は、以下の公式を使って計算されることができます、そこで<bpt i="2" x="2">&lt;c2&gt;</bpt>**<ept i="2">&lt;/c2&gt;</ept>は冪演算です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The magnitude of this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値の規模。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The map sequence produces whatever type of element its the transforming closure produces.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>マップシーケンスは、それの変換クロージャが生み出す要素の型が何であろうとも生み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The map sequence produces whatever type of element its transforming closure produces.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>マップシーケンスは、それの変換クロージャが生み出す要素の型が何であろうとも生み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The masking addition assignment operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;+=<ept i="0">&lt;/c0&gt;</ept>) silently wraps any overflow that occurs during the operation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>マスク加算代入演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;+=<ept i="0">&lt;/c0&gt;</ept>）は、演算の間に起こるあらゆるオーバーフローを黙ってラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The masking multiplication assignment operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;*=<ept i="0">&lt;/c0&gt;</ept>) silently wraps any overflow that occurs during the operation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>マスク乗算代入演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;*=<ept i="0">&lt;/c0&gt;</ept>）は、演算の間に起こるあらゆるオーバーフローを黙ってラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The masking subtraction assignment operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;-=<ept i="0">&lt;/c0&gt;</ept>) silently wraps any overflow that occurs during the operation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>マスク減算代入演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;-=<ept i="0">&lt;/c0&gt;</ept>）は、演算の間に起こるあらゆるオーバーフローを黙ってラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The mathematical constant pi.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>数学の定数pi。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The maximum depth to descend when writing the contents of a value that has nested components.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>入れ子になった構成要素を持つ値の内容を書き出す時に下る最大の深さ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The maximum number of elements for which to write the full contents.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>完全な内容を書き出すための最大要素数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The maximum number of elements to hold in the buffer past any checks for continuations being resumed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>継続が再開されるためのあらゆる検査を通過した後にバッファの中に保持する要素の最大数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The maximum number of elements to return.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>返される要素の最大限の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The maximum number of pending elements limited by dropping the oldest value when a new value comes in if the buffer would excede the limit placed upon it.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい値がやって来る時にもしバッファがそれの上に置かれる制限を越えるならば最古の値を除くことによって限界を設けられる未解決要素の最大数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The maximum number of times to split the collection, or one less than the number of subsequences to return.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションを分割する回数の最大限度、または返される下位シーケンスの数より１つ少ないもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The maximum number of times to split the sequence, or one less than the number of subsequences to return.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスを分割する回数の最大限度、または返される下位シーケンスの数より１つ少ないもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The maximum representable integer in this type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型における最大の表現可能な整数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The memory in the range <bpt i="2" x="2">&lt;c2&gt;</bpt>buffer[0..<it pos="begin" x="3">&lt;initialized&lt;w3&gt;</it>Count]<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> must be initialized at the end of the closure’s execution, and the memory in the range <bpt i="4" x="4">&lt;c4&gt;</bpt>buffer[initialized<bpt i="5" x="5">&lt;w5&gt;</bpt>Count...]<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> must be uninitialized.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲<bpt i="2" x="2">&lt;c2&gt;</bpt>buffer[0..<it pos="begin" x="3">&lt;initialized&lt;w3&gt;</it>Count]<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の中のメモリは、クロージャの遂行の終わりで初期化されなければなりません、そして範囲<bpt i="4" x="4">&lt;c4&gt;</bpt>buffer[initialized<bpt i="5" x="5">&lt;w5&gt;</bpt>Count...]<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の中のメモリは、未初期化でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The method has a <bpt i="0" x="0">&lt;c0&gt;</bpt>void<ept i="0">&lt;/c0&gt;</ept> return type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのメソッドは<bpt i="0" x="0">&lt;c0&gt;</bpt>void<ept i="0">&lt;/c0&gt;</ept>戻り型を持つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The method that takes a completion handler must meet the following requirements:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>完了ハンドラをとるメソッドは、以下の要件を満たさなければなりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The minimum number of key-value pairs that the newly created dictionary should be able to store without reallocating its storage buffer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しく作成された辞書がそれのストレージバッファをアロケートし直すことなしに格納できるであろうキー値ペアの最小の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The minimum of <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept>, or whichever is a number if the other is NaN.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept>の最小、または他方がNaNならば数である方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The minimum representable integer in this type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型における最小の表現可能な整数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The modified sequence ends when the predicate closure returns <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept> or throws an error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>修正されたシーケンスは、述部クロージャが<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>を返すかエラーをスローする時に終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The modified sequence ends when the predicate closure returns <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>修正されたシーケンスは、条件クロージャが<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>を返す時に終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The most common way to access values in a dictionary is to use a key as a subscript.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書の中の値にアクセスする最も普通の方法は、キーを添え字として使うことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The most familiar use of relational operators is to compare numbers, as in the following example:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最もよく知られている関係演算子の使用は、数の比較に対してです、以下の例でのように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The multiplication operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>*<ept i="0">&lt;/c0&gt;</ept>) calculates the product of its two arguments.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>乗算演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>*<ept i="0">&lt;/c0&gt;</ept>）は、それの２つの引数の積を計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The name of the Swift method is modified from the Objective-C method as follows:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftメソッドの名前は、Objective-Cメソッドから以下のように修正されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The name “epsilon” suggests that this quantity is a good tolerance to choose for approximate comparisons, but it is almost always unsuitable for that purpose.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>名前 “イプシロン” は、この量がおおよその比較のために選ぶのに良い許容誤差であることを暗示します、しかしそれはほとんど常にその目的のために適しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The naming of those macros is slightly misleading, because <bpt i="4" x="4">&lt;c4&gt;</bpt>infinity<ept i="4">&lt;/c4&gt;</ept> is greater than this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これらのマクロの命名の仕方は少しばかり誤解させます、なぜなら<bpt i="4" x="4">&lt;c4&gt;</bpt>infinity<ept i="4">&lt;/c4&gt;</ept>はこの値より大きいからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The naming of those macros is slightly misleading, because subnormals, zeros, and negative numbers are smaller than this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これらのマクロの命名の仕方は少しばかり誤解させます、なぜならサブノーマル、ゼロ、そして負の数はこの値より小さいからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The nearest integral value, or, if two integral values are equally close, the integral value with greater magnitude.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最も近い整数値、または、２つの整数値が同じくらい近いならば、より大きい規模を持つ整数値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The negation operator (prefix <bpt i="0" x="0">&lt;c0&gt;</bpt>-<ept i="0">&lt;/c0&gt;</ept>) returns the additive inverse of its argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>負にする演算子（前置<bpt i="0" x="0">&lt;c0&gt;</bpt>-<ept i="0">&lt;/c0&gt;</ept>）は、この引数の加法の逆元を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The new <bpt i="0" x="0">&lt;c0&gt;</bpt>students<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>Letter<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> dictionary has three entries, with students’ names grouped by the keys <bpt i="3" x="3">&lt;c3&gt;</bpt>"E"<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>"K"<ept i="4">&lt;/c4&gt;</ept>, and <bpt i="5" x="5">&lt;c5&gt;</bpt>"A"<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>students<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>Letter<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>辞書は、生徒の名前をキー<bpt i="3" x="3">&lt;c3&gt;</bpt>"E"<ept i="3">&lt;/c3&gt;</ept>、<bpt i="4" x="4">&lt;c4&gt;</bpt>"K"<ept i="4">&lt;/c4&gt;</ept>、そして<bpt i="5" x="5">&lt;c5&gt;</bpt>"A"<ept i="5">&lt;/c5&gt;</ept>でグループ分けして、３つの登録項目を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The new array, on the other hand, matches the order and number of elements provided.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>一方、新しい配列は、提供された要素の順番と数に合致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The new element is inserted before the element currently at the specified index.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい要素は、指定されたインデックスでの現在の要素の前に挿入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The new element to insert into the array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列に挿入されることになる新しい要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The new elements are inserted before the element currently at the specified index.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいいくらかの要素が、指定されたインデックスでの現在の要素の前に挿入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The new elements to add to the array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列に加えられることになる新しい要素ら。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The new elements to add to the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションに加える新しいいくらかの要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The new elements to insert into the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションへ挿入される新しいいくらかの要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The new storage is a multiple of the old storage’s size.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいストレージは古いストレージの大きさの倍数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The new value represents the address of the pointer passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>pointer<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい値は、<bpt i="0" x="0">&lt;c0&gt;</bpt>pointer<ept i="0">&lt;/c0&gt;</ept>として渡されるポインタのアドレスを表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The new value to add to the dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この辞書に加える新しい値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The new value’s exponent.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい値の持つ指数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The new value’s significand.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい値の持つ仮数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The next code sample shows a possible extension to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept> type that parses the integer value of a <bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept> instance, throwing an error when there is a problem during parsing.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次のコード例が示すのは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>型に対する１つの可能な拡張で、それは<bpt i="1" x="1">&lt;c1&gt;</bpt>String<ept i="1">&lt;/c1&gt;</ept>インスタンスの整数値をパースして、パースの間に問題がある時はエラーをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The next element in the underlying sequence if a next element exists; otherwise, <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の要素が存在するならば基礎をなすシーケンス中の次の要素；そうでなければ、<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The next element in the underlying sequence, if a next element exists; otherwise, <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の要素が存在するならば、基礎をなすシーケンス中の次の要素；そうでなければ、<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The next element, if it exists, or <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> to signal the end of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の要素、もしそれが存在するならば、またはシーケンスの終わりを合図する<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The next example attempts to retrieve an index six positions from <bpt i="0" x="0">&lt;c0&gt;</bpt>s<bpt i="1" x="1">&lt;w1&gt;</bpt>.start<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> but fails, because that distance is beyond the index passed as <bpt i="3" x="3">&lt;c3&gt;</bpt>limit<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の例は<bpt i="0" x="0">&lt;c0&gt;</bpt>s<bpt i="1" x="1">&lt;w1&gt;</bpt>.start<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から６位置のインデックスをとりだすことを試みます、しかし失敗します、なぜならその間隔は<bpt i="3" x="3">&lt;c3&gt;</bpt>limit<ept i="3">&lt;/c3&gt;</ept>として渡されるインデックスを越えるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The next example attempts to retrieve an index ten positions from <bpt i="0" x="0">&lt;c0&gt;</bpt>numbers<bpt i="1" x="1">&lt;w1&gt;</bpt>.start<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, but fails, because that distance is beyond the index passed as <bpt i="3" x="3">&lt;c3&gt;</bpt>limit<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の例は<bpt i="0" x="0">&lt;c0&gt;</bpt>numbers<bpt i="1" x="1">&lt;w1&gt;</bpt>.start<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から10位置のインデックスをとりだすことを試みます、しかし失敗します、なぜならその間隔は<bpt i="3" x="3">&lt;c3&gt;</bpt>limit<ept i="3">&lt;/c3&gt;</ept>として渡されるインデックスを越えるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The next example creates a slice of <bpt i="4" x="4">&lt;c4&gt;</bpt>numbers<ept i="4">&lt;/c4&gt;</ept> starting at index <bpt i="5" x="5">&lt;c5&gt;</bpt>2<ept i="5">&lt;/c5&gt;</ept>, and then uses the slice with <bpt i="6" x="6">&lt;c6&gt;</bpt>relative(to:)<ept i="6">&lt;/c6&gt;</ept> to convert <bpt i="7" x="7">&lt;c7&gt;</bpt>up<bpt i="8" x="8">&lt;w8&gt;</bpt>To<bpt i="9" x="9">&lt;w9&gt;</bpt>Four<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> to a concrete range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の例は、<bpt i="4" x="4">&lt;c4&gt;</bpt>numbers<ept i="4">&lt;/c4&gt;</ept>のスライスをインデックス<bpt i="5" x="5">&lt;c5&gt;</bpt>2<ept i="5">&lt;/c5&gt;</ept>で開始して作成して、それからそのスライスを<bpt i="6" x="6">&lt;c6&gt;</bpt>relative(to:)<ept i="6">&lt;/c6&gt;</ept>と使うことで<bpt i="7" x="7">&lt;c7&gt;</bpt>up<bpt i="8" x="8">&lt;w8&gt;</bpt>To<bpt i="9" x="9">&lt;w9&gt;</bpt>Four<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>を具体的な範囲へ変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The next example declares a generic <bpt i="0" x="0">&lt;c0&gt;</bpt>squared<ept i="0">&lt;/c0&gt;</ept> function, which accepts an instance <bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept> of any fixed-width integer type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の例は、総称体<bpt i="0" x="0">&lt;c0&gt;</bpt>squared<ept i="0">&lt;/c0&gt;</ept>関数を宣言します、それはどんな固定長整数型の<bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept>インスタンスでも受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The next example tries to find the correct text for a greeting in two separate dictionaries before falling back to a static default.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の例は、挨拶として正しいテキストを２つの独立した辞書から見つけることをある静的な省略時のものに落ち着く前に試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The next example uses key-based subscripting of the <bpt i="0" x="0">&lt;c0&gt;</bpt>response<bpt i="1" x="1">&lt;w1&gt;</bpt>Messages<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> dictionary with two keys that exist in the dictionary and one that does not.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>次の例は、キーに基づく添え字を<bpt i="0" x="0">&lt;c0&gt;</bpt>response<bpt i="1" x="1">&lt;w1&gt;</bpt>Messages<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>辞書に使います、ですが２つのキーは辞書に存在し１つはそうでありません。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The next value from the AsyncStream.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>AsyncStreamからの次の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of bits equal to 1 in this value’s binary representation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値のバイナリ表現の中の１に等しいビットの数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of bits in the binary representation of this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値のバイナリ表現でのビット数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of bits in the current binary representation of this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値の現在のバイナリ表現でのビット数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of bits required to represent the value’s significand.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値の仮数を表すのに必要とされるビットの数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of bits to shift <bpt i="0" x="0">&lt;c0&gt;</bpt>lhs<ept i="0">&lt;/c0&gt;</ept> to the left.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このビット数を<bpt i="0" x="0">&lt;c0&gt;</bpt>lhs<ept i="0">&lt;/c0&gt;</ept>から左へとシフトします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of bits to shift <bpt i="0" x="0">&lt;c0&gt;</bpt>lhs<ept i="0">&lt;/c0&gt;</ept> to the right.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このビット数を<bpt i="0" x="0">&lt;c0&gt;</bpt>lhs<ept i="0">&lt;/c0&gt;</ept>から右へとシフトします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of bits used for the underlying binary representation of values of this type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型の値の基礎をなすバイナリ表現に対して使われるビットの数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of bits used to represent the type’s exponent.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型のもつ指数を表すのに使われるビットの数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of elements (always zero).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要素の数を返します（常にゼロ）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of elements in the array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その配列中の要素の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of elements in the collection, which is always one.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの中の要素数、それは常に１つです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of elements in the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの中の要素の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of elements to allocate space for in the new array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい配列において空間を割り当てる要素の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of elements to drop from the beginning of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの始まりから省く要素の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of elements to drop from the beginning of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスの初めの部分から落とす要素の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of elements to drop off the end of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションの終わりで省く要素の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of elements to drop off the end of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスの末尾から取り除く要素の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of elements to remove from the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションから削除される要素の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of elements to remove.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>削除する要素の数を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要素の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of key-value pairs in the dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書の中のキー値ペアの数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of keys in the dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書の中のキーの数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of leading zeros in this value’s binary representation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値のバイナリ表現における先頭のゼロの数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of new elements need not match the number of elements being removed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい要素の数は、削除される要素の数と一致する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of scalars, or elements, in a vector of this type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型のあるベクターの中のスカラーそれら、または要素それらの数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of scalars, or elements, in the vector.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ベクターの中のスカラー、または要素、の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of spaces to use as an indent for each line of the output.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>出力の各行のひとつの字下げとして使われる空白の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of strides of the pointer’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Pointee<ept i="0">&lt;/c0&gt;</ept> type to offset this pointer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ポインタの<bpt i="0" x="0">&lt;c0&gt;</bpt>Pointee<ept i="0">&lt;/c0&gt;</ept>型のストライドの数、このポインタに補われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of times to repeat <bpt i="0" x="0">&lt;c0&gt;</bpt>element<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>element<ept i="0">&lt;/c0&gt;</ept>を繰り返す回数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of times to repeat the value passed in the <bpt i="0" x="0">&lt;c0&gt;</bpt>repeating<ept i="0">&lt;/c0&gt;</ept> parameter.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>repeating<ept i="0">&lt;/c0&gt;</ept>パラメータで渡された値を繰り返す回数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of trailing zeros in this value’s binary representation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値のバイナリ表現において後に続くゼロの数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The number of values in the dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書の中の値の数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The numeric value this character represents, if it is a hexadecimal digit.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文字が表す数値、もしそれが16進法桁を表すならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The numeric value this character represents, if it represents a whole number.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文字が表す数値、もしそれが整数を表すならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The only valid position in a <bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<bpt i="1" x="1">&lt;w1&gt;</bpt>Of<bpt i="2" x="2">&lt;w2&gt;</bpt>One<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance is <bpt i="3" x="3">&lt;c3&gt;</bpt>0<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<bpt i="1" x="1">&lt;w1&gt;</bpt>Of<bpt i="2" x="2">&lt;w2&gt;</bpt>One<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスの中の唯一の有効な位置は、<bpt i="3" x="3">&lt;c3&gt;</bpt>0<ept i="3">&lt;/c3&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The opaque pointer to convert to a typed pointer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型付ポインタに変換されることになる不透明ポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The operation doesn’t require going beyond the limiting <bpt i="0" x="0">&lt;c0&gt;</bpt>numbers<bpt i="1" x="1">&lt;w1&gt;</bpt>.end<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> value, so it succeeds.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この操作は、限度である<bpt i="0" x="0">&lt;c0&gt;</bpt>numbers<bpt i="1" x="1">&lt;w1&gt;</bpt>.end<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>値を越えることを要求しません、それでそれは成功します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The operation doesn’t require going beyond the limiting <bpt i="0" x="0">&lt;c0&gt;</bpt>s<bpt i="1" x="1">&lt;w1&gt;</bpt>.end<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> value, so it succeeds.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>演算は、限界である<bpt i="0" x="0">&lt;c0&gt;</bpt>s<bpt i="1" x="1">&lt;w1&gt;</bpt>.end<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>値を越えていく必要はありません、それでそれは成功します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The order of key-value pairs in a dictionary is stable between mutations but is otherwise unpredictable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書中のキー値ペアの順番は各変化間は安定しています、しかしそれ以外では予測できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The order of the remaining elements is preserved.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>残っている要素の順番は保全されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The other value to multiply.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>掛け合わされることになるもう一方の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The output from each call to <bpt i="0" x="0">&lt;c0&gt;</bpt>debug<bpt i="1" x="1">&lt;w1&gt;</bpt>Print(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>separator:<bpt i="3" x="3">&lt;w3&gt;</bpt>terminator:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> includes a newline by default.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>debug<bpt i="1" x="1">&lt;w1&gt;</bpt>Print(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>separator:<bpt i="3" x="3">&lt;w3&gt;</bpt>terminator:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>への各呼び出しからの出力は、初期状態では改行を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The output from each call to <bpt i="0" x="0">&lt;c0&gt;</bpt>debug<bpt i="1" x="1">&lt;w1&gt;</bpt>Print(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>separator:<bpt i="3" x="3">&lt;w3&gt;</bpt>terminator:<bpt i="4" x="4">&lt;w4&gt;</bpt>to:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> includes a newline by default.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>debug<bpt i="1" x="1">&lt;w1&gt;</bpt>Print(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>separator:<bpt i="3" x="3">&lt;w3&gt;</bpt>terminator:<bpt i="4" x="4">&lt;w4&gt;</bpt>to:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>への各呼び出しからの出力は、初期状態では改行を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The output from each call to <bpt i="0" x="0">&lt;c0&gt;</bpt>print(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>separator:<bpt i="2" x="2">&lt;w2&gt;</bpt>terminator:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> includes a newline by default.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>print(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>separator:<bpt i="2" x="2">&lt;w2&gt;</bpt>terminator:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>への各呼び出しからの出力は、初期状態では改行を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The output from each call to <bpt i="0" x="0">&lt;c0&gt;</bpt>print(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>separator:<bpt i="2" x="2">&lt;w2&gt;</bpt>terminator:<bpt i="3" x="3">&lt;w3&gt;</bpt>to:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> includes a newline by default.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>print(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>separator:<bpt i="2" x="2">&lt;w2&gt;</bpt>terminator:<bpt i="3" x="3">&lt;w3&gt;</bpt>to:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>への各呼び出しからの出力は、初期状態では改行を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The overflow addition operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;+<ept i="0">&lt;/c0&gt;</ept>) discards any bits that overflow the fixed width of the integer type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オーバーフロー加算演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;+<ept i="0">&lt;/c0&gt;</ept>）は、固定幅の整数型からオーバーフローするあらゆるビットを廃棄します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The overflow multiplication operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;*<ept i="0">&lt;/c0&gt;</ept>) discards any bits that overflow the fixed width of the integer type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オーバーフロー乗算演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;*<ept i="0">&lt;/c0&gt;</ept>）は、固定幅の整数型からオーバーフローするあらゆるビットを廃棄します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The overflow subtraction operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;-<ept i="0">&lt;/c0&gt;</ept>) discards any bits that overflow the fixed width of the integer type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オーバーフロー減算演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;-<ept i="0">&lt;/c0&gt;</ept>）は、固定幅の整数型からオーバーフローするあらゆるビットを廃棄します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The path of coding keys taken to get to the point of the failing decode call.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>失敗しているデコード呼び出しの地点に行くために取られるコーディングキーのパス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The path of coding keys taken to get to the point of the failing encode call.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>失敗しているエンコード呼び出しの地点に行くために取られるコーディングキーのパス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The path of coding keys taken to get to this point in decoding.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>デコーディングのこの時点を得るために取られるコーディングキーのパス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The path of coding keys taken to get to this point in encoding.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>エンコーディングのこの時点を得るために取られるコーディングキーのパス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The path should be relative to your project, similar to the way your <bpt i="0" x="0">&lt;c0&gt;</bpt>Info<bpt i="1" x="1">&lt;w1&gt;</bpt>.plist<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> path is specified in Build Settings.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>パスは、あなたの<bpt i="0" x="0">&lt;c0&gt;</bpt>Info<bpt i="1" x="1">&lt;w1&gt;</bpt>.plist<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>パスがBuild Settingsにおいて指定される方法と同様に、あなたのプロジェクトに対して相対的であるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The pattern-matching operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>~=<ept i="0">&lt;/c0&gt;</ept>) is used internally in <bpt i="1" x="1">&lt;c1&gt;</bpt>case<ept i="1">&lt;/c1&gt;</ept> statements for pattern matching.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>パターンマッチング演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>~=<ept i="0">&lt;/c0&gt;</ept>）は、内部的に<bpt i="1" x="1">&lt;c1&gt;</bpt>case<ept i="1">&lt;/c1&gt;</ept>文の中でパターンマッチングのために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The pattern-matching operator is primarily intended to enable <bpt i="1" x="1">&lt;c1&gt;</bpt>case<ept i="1">&lt;/c1&gt;</ept> statement pattern matching.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>パターンマッチング演算子は、元来<bpt i="1" x="1">&lt;c1&gt;</bpt>case<ept i="1">&lt;/c1&gt;</ept>文パターンマッチングをできるようにすることを意図されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The pattern-matching operator is used internally in <bpt i="1" x="1">&lt;c1&gt;</bpt>case<ept i="1">&lt;/c1&gt;</ept> statements for pattern matching.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>パターンマッチング演算子は、内部的に<bpt i="1" x="1">&lt;c1&gt;</bpt>case<ept i="1">&lt;/c1&gt;</ept>文の中でパターンマッチングのために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The payload consists of a sequence of decimal digits, or the characters <bpt i="1" x="1">&lt;c1&gt;</bpt>0X<ept i="1">&lt;/c1&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt>0x<ept i="2">&lt;/c2&gt;</ept> followed by a sequence of hexadecimal digits.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ペイロードは、一連の10進の桁、または文字<bpt i="1" x="1">&lt;c1&gt;</bpt>0X<ept i="1">&lt;/c1&gt;</ept>か<bpt i="2" x="2">&lt;c2&gt;</bpt>0x<ept i="2">&lt;/c2&gt;</ept>に続く一連の16進の桁から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The payload to use for the new NaN value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいNaN値のために使うためのペイロード。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The performance of some collection operations depends on the type of index that the collection provides.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>いくつかのコレクション演算の性能は、コレクションの提供するインデックスの型に依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The pointer argument is valid only for the duration of the function’s execution.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ポインタ引数は、関数の実行の継続期間に対してだけ有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The pointer argument is valid only for the duration of the method’s execution.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ポインタ引数は、ただメソッドの実行の間に対してのみ有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The pointer argument to <bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept> is valid only during the execution of <bpt i="1" x="1">&lt;c1&gt;</bpt>with<bpt i="2" x="2">&lt;w2&gt;</bpt>Unsafe<bpt i="3" x="3">&lt;w3&gt;</bpt>Mutable<bpt i="4" x="4">&lt;w4&gt;</bpt>Pointer(to:<bpt i="5" x="5">&lt;w5&gt;</bpt>_:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept>へのポインタ引数は、<bpt i="1" x="1">&lt;c1&gt;</bpt>with<bpt i="2" x="2">&lt;w2&gt;</bpt>Unsafe<bpt i="3" x="3">&lt;w3&gt;</bpt>Mutable<bpt i="4" x="4">&lt;w4&gt;</bpt>Pointer(to:<bpt i="5" x="5">&lt;w5&gt;</bpt>_:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の実行の間のみ有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The pointer argument to <bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept> is valid only during the execution of <bpt i="1" x="1">&lt;c1&gt;</bpt>with<bpt i="2" x="2">&lt;w2&gt;</bpt>Unsafe<bpt i="3" x="3">&lt;w3&gt;</bpt>Pointer(to:<bpt i="4" x="4">&lt;w4&gt;</bpt>_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept>へのポインタ引数は、<bpt i="1" x="1">&lt;c1&gt;</bpt>with<bpt i="2" x="2">&lt;w2&gt;</bpt>Unsafe<bpt i="3" x="3">&lt;w3&gt;</bpt>Pointer(to:<bpt i="4" x="4">&lt;w4&gt;</bpt>_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の実行の間のみ有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The pointer passed as an argument to <bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept> is valid only during the execution of <bpt i="1" x="1">&lt;c1&gt;</bpt>with<bpt i="2" x="2">&lt;w2&gt;</bpt>Unsafe<bpt i="3" x="3">&lt;w3&gt;</bpt>Buffer<bpt i="4" x="4">&lt;w4&gt;</bpt>Pointer(_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>引数として<bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept>に渡されるポインタは、<bpt i="1" x="1">&lt;c1&gt;</bpt>with<bpt i="2" x="2">&lt;w2&gt;</bpt>Unsafe<bpt i="3" x="3">&lt;w3&gt;</bpt>Buffer<bpt i="4" x="4">&lt;w4&gt;</bpt>Pointer(_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の実行の間のみ有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The pointer passed as an argument to <bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept> is valid only during the execution of <bpt i="1" x="1">&lt;c1&gt;</bpt>with<bpt i="2" x="2">&lt;w2&gt;</bpt>Unsafe<bpt i="3" x="3">&lt;w3&gt;</bpt>Mutable<bpt i="4" x="4">&lt;w4&gt;</bpt>Buffer<bpt i="5" x="5">&lt;w5&gt;</bpt>Pointer(_:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>引数として<bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept>に渡されるポインタは、<bpt i="1" x="1">&lt;c1&gt;</bpt>with<bpt i="2" x="2">&lt;w2&gt;</bpt>Unsafe<bpt i="3" x="3">&lt;w3&gt;</bpt>Mutable<bpt i="4" x="4">&lt;w4&gt;</bpt>Buffer<bpt i="5" x="5">&lt;w5&gt;</bpt>Pointer(_:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の実行の間のみ有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The pointer passed as an argument to <bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept> is valid only during the execution of <bpt i="1" x="1">&lt;c1&gt;</bpt>with<bpt i="2" x="2">&lt;w2&gt;</bpt>Va<bpt i="3" x="3">&lt;w3&gt;</bpt>List(_:<bpt i="4" x="4">&lt;w4&gt;</bpt>_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>引数として<bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept>に渡されるポインタは、<bpt i="1" x="1">&lt;c1&gt;</bpt>with<bpt i="2" x="2">&lt;w2&gt;</bpt>Va<bpt i="3" x="3">&lt;w3&gt;</bpt>List(_:<bpt i="4" x="4">&lt;w4&gt;</bpt>_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の実行の間のみ有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The pointer passed as an argument to <bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept> is valid only for the lifetime of the closure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>引数として<bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept>に渡されるポインタは、このクロージャの生涯に対してのみ有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The pointer to calculate the distance to.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それへの隔たりを計算されるポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The pointer to use as the source for the new integer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい整数のためのソースとして使う値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The position at which to insert the new element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そこで新しい要素が挿入されることになる位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The position at which to insert the new elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そこで新しいいくらかの要素が挿入されるところの位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The position of a collection difference.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるコレクション差異の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The position of a key-value pair in a dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書の中でのあるキー値ペアの位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The position of the element to access.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>アクセスする要素の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The position of the element to remove.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>削除する要素の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The position of the first element in a non-empty collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>空でないコレクションにおける最初の要素の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The position of the first element in a nonempty array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>空でない集合の中の最初の要素の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The position of the first element in a nonempty collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>空でないコレクションの中の最初の要素の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The position of the first element in a nonempty dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>空でない辞書の中の最初の要素の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The position of the first element in the range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲の中の最初の要素の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The position of the first element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最初の要素の位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The position of the key-value pair to access.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この位置のキー値ペアにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The position of the key-value pair to remove.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>削除されるキー値ペアの位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The positive difference between 1.0 and the next greater representable number.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>1.0と次により大きい表現可能な数との間の正の差異。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The predicate executes each time the asynchronous sequence produces an element, until either the predicate finds a match or the sequence ends.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>述部は、非同期シーケンスがある要素を生み出すたびごとに遂行されます、述部がある合致を見つけるかシーケンスが終わるかどちらかまで。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The predicate executes each time the asynchronous sequence produces an element, until either the predicate returns <bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept> or the sequence ends.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>述部は、非同期シーケンスがある要素を生み出すたびごとに遂行されます、述部が<bpt i="0" x="0">&lt;c0&gt;</bpt>false<ept i="0">&lt;/c0&gt;</ept>を返すかシーケンスが終わるかどちらかまで。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The predicate must be a <bpt i="0" x="0">&lt;e0&gt;</bpt>equivalence relation<ept i="0">&lt;/e0&gt;</ept> over the elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>述部は要素に対して<bpt i="0" x="0">&lt;e0&gt;</bpt>同値関係<ept i="0">&lt;/e0&gt;</ept>でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The predicate must be a <bpt i="0" x="0">&lt;e0&gt;</bpt>strict weak ordering<ept i="0">&lt;/e0&gt;</ept> over the elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>述部は、それら要素に対して<bpt i="0" x="0">&lt;e0&gt;</bpt>厳密弱順序<ept i="0">&lt;/e0&gt;</ept>でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The predicate orders errors before successes and sorts the error responses by their error code.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この述部はエラーを成功の前に並べて、そしてそれらエラー応答をそのエラーコードによってソートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The predicate passed to the <bpt i="4" x="4">&lt;c4&gt;</bpt>drop(while:)<ept i="4">&lt;/c4&gt;</ept> method throws an error if it encounters an even number, and otherwise returns <bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept> while it receives elements less than <bpt i="6" x="6">&lt;c6&gt;</bpt>5<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>drop(while:)<ept i="4">&lt;/c4&gt;</ept>メソッドに渡される述部は、それが偶数に出会うならばエラーをスローします、そしてそうでなければ<bpt i="5" x="5">&lt;c5&gt;</bpt>true<ept i="5">&lt;/c5&gt;</ept>を、それが<bpt i="6" x="6">&lt;c6&gt;</bpt>5<ept i="6">&lt;/c6&gt;</ept>より少ない要素を受けとる間ずっと返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The predicate provided to the <bpt i="5" x="5">&lt;c5&gt;</bpt>max(by:)<ept i="5">&lt;/c5&gt;</ept> method sorts ranks based on their <bpt i="6" x="6">&lt;c6&gt;</bpt>raw<bpt i="7" x="7">&lt;w7&gt;</bpt>Value<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>max(by:)<ept i="5">&lt;/c5&gt;</ept>メソッドに提供された述部は、ランクそれらをそれらの<bpt i="6" x="6">&lt;c6&gt;</bpt>raw<bpt i="7" x="7">&lt;w7&gt;</bpt>Value<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>に基づいて並べ換えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The predicate provided to the <bpt i="5" x="5">&lt;c5&gt;</bpt>min(by:)<ept i="5">&lt;/c5&gt;</ept> method sorts ranks based on their <bpt i="6" x="6">&lt;c6&gt;</bpt>raw<bpt i="7" x="7">&lt;w7&gt;</bpt>Value<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>min(by:)<ept i="5">&lt;/c5&gt;</ept>メソッドに提供された述部は、ランクそれらをそれらの<bpt i="6" x="6">&lt;c6&gt;</bpt>raw<bpt i="7" x="7">&lt;w7&gt;</bpt>Value<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>に基づいて並べ換えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The prefix sequence produces whatever type of element its base iterator produces.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>prefixシーケンスは、それの基底イテレータが生み出す要素の型が何であろうとも生み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The prefix-while sequence produces whatever type of element its base iterator produces.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>prefix-whileシーケンスは、それの基底イテレータが生み出す要素の型が何であろうとも生み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The process for importing Swift declarations into Objective-C code differs slightly depending on whether you’re writing an app or a framework.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swift宣言をObjective-Cコードにインポートする行程は、あなたがアプリを書いているかフレームワークを書いているかに従い、わずかに異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The process for using your Objective-C declarations from your Swift code within mixed-language targets differs slightly depending on whether you’re writing an app or a framework.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのObjective-C宣言をあなたのSwiftコードから混合言語ターゲット内部において使うことに対する行程は、あなたがアプリをまたはフレームワークを書くかによって少しばかり異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The product of <bpt i="0" x="0">&lt;c0&gt;</bpt>lhs<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>rhs<ept i="1">&lt;/c1&gt;</ept>, added to this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値に加えられることになる、<bpt i="0" x="0">&lt;c0&gt;</bpt>lhs<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>rhs<ept i="1">&lt;/c1&gt;</ept>の積。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The product of <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept> is 2000, which is too large to represent in a <bpt i="2" x="2">&lt;c2&gt;</bpt>UInt8<ept i="2">&lt;/c2&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept>の積は2000です、それは<bpt i="2" x="2">&lt;c2&gt;</bpt>UInt8<ept i="2">&lt;/c2&gt;</ept>インスタンスにおいて表すには大きすぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The product of <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept> is <bpt i="2" x="2">&lt;c2&gt;</bpt>-1920<ept i="2">&lt;/c2&gt;</ept>, which is too large to represent in an <bpt i="3" x="3">&lt;c3&gt;</bpt>Int8<ept i="3">&lt;/c3&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept>の積は<bpt i="2" x="2">&lt;c2&gt;</bpt>-1920<ept i="2">&lt;/c2&gt;</ept>です、それは<bpt i="3" x="3">&lt;c3&gt;</bpt>Int8<ept i="3">&lt;/c3&gt;</ept>インスタンスにおいて表すには大きすぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The product of the two arguments must be representable in the arguments’ type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの引数の積は、引数の持つ型において表現可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The protocol defines a single asynchronous method, <bpt i="8" x="8">&lt;c8&gt;</bpt>next()<ept i="8">&lt;/c8&gt;</ept>, which either produces the next element of the sequence, or returns <bpt i="9" x="9">&lt;c9&gt;</bpt>nil<ept i="9">&lt;/c9&gt;</ept> to signal the end of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>プロトコルは、ただ１つの非同期メソッド<bpt i="8" x="8">&lt;c8&gt;</bpt>next()<ept i="8">&lt;/c8&gt;</ept>を定義します、それはシーケンスの次の要素を取り出すか、または<bpt i="9" x="9">&lt;c9&gt;</bpt>nil<ept i="9">&lt;/c9&gt;</ept>を返してシーケンスの終わりを合図するかのどちらかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The protocol to which all class types implicitly conform.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このプロトコルに対して、全てのクラス型は暗黙的に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The protocol to which all classes implicitly conform.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このプロトコルに対して、全てのクラスは暗黙的に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The radix, or base of exponentiation, for a floating-point type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある浮動小数点型の基数、または冪演算の底。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The radix, or base, to use for converting <bpt i="0" x="0">&lt;c0&gt;</bpt>text<ept i="0">&lt;/c0&gt;</ept> to an integer value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>text<ept i="0">&lt;/c0&gt;</ept>を整数値に変換するのに使うための基数、または底。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The random number generator to use when choosing a random element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある無作為な要素を選ぶときに使う無作為数生成子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The random number generator to use when creating the new random value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい無作為値を作成するときに使う無作為数生成子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The random number generator to use when shuffling the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションをシャッフルするときに使う無作為数生成子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The random number generator to use when shuffling the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスをシャッフルするときに使う無作為数生成子。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The range expression is converted to a concrete subrange relative to this collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲式は、このコレクションに関連するある具体的な下位範囲へ変換されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The range in which to create a random value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その中においてある無作為な値が作成される範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The range of the collection to be removed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>削除されることになるコレクションの範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The range to clamp the bounds of this range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この範囲に制限を課すための範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The range’s lower bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その範囲の下方の境界。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The range’s upper bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その範囲の上方の境界。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The range’s “past the end” position—that is, the position one greater than the last valid subscript argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲の「終わりを過ぎた」位置—すなわち、最後の有効な添え字引数より１つ大きい位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The raw encoding of the value’s exponent field.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値のもつ指数部の生のエンコーディング。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The raw encoding of the value’s significand field.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値の仮数フィールドの生のエンコーディング。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The raw type that can be used to represent all values of the conforming type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>準拠している型のすべての値を表すために使われる生の型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The raw value to use for the new instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいインスタンスのために使う生の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The reference writeable key path to append.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>書き込み可能なキーパスの参照、これに対して追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The remainder has the same sign as <bpt i="1" x="1">&lt;c1&gt;</bpt>lhs<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>余りは、<bpt i="1" x="1">&lt;c1&gt;</bpt>lhs<ept i="1">&lt;/c1&gt;</ept>と同じ符号を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The remainder of the relational operator functions are implemented by the standard library for any type that conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>残りの関係演算子関数は、<bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>に準拠するあらゆる型に対して標準ライブラリによって実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The remainder of this value divided by <bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept> using truncating division.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>切り捨て除算を使って<bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>で除算されたこの値の余りを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The remainder of this value divided by <bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>で除算されたこの値の余りを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The removals contained by this difference, from lowest offset to highest.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この差異によって含まれる除去、最も低いオフセットから最も高い方へと。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The removed element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>削除された要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The requested number of elements to store.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>依頼された格納される要素数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The requested number of key-value pairs to store.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>要請された数のキー値ペアを格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The required methods that are suffixed with <bpt i="3" x="3">&lt;c3&gt;</bpt>Reporting<bpt i="4" x="4">&lt;w4&gt;</bpt>Overflow<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> serve as the customization points for arithmetic operations.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>必須メソッドで<bpt i="3" x="3">&lt;c3&gt;</bpt>Reporting<bpt i="4" x="4">&lt;w4&gt;</bpt>Overflow<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>を末尾に付けられるものは、算術演算に対するカスタマイズポイントとして供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The result begins with the first element of <bpt i="2" x="2">&lt;c2&gt;</bpt>numbers<ept i="2">&lt;/c2&gt;</ept> that does not satisfy <bpt i="3" x="3">&lt;c3&gt;</bpt>predicate<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果は、<bpt i="2" x="2">&lt;c2&gt;</bpt>predicate<ept i="2">&lt;/c2&gt;</ept>を満たさない、<bpt i="3" x="3">&lt;c3&gt;</bpt>numbers<ept i="3">&lt;/c3&gt;</ept>の最初の要素で始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The result can be negative only if the collection conforms to the <bpt i="2" x="2">&lt;c2&gt;</bpt>Bidirectional<bpt i="3" x="3">&lt;w3&gt;</bpt>Collection<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果は、そのコレクションが<bpt i="2" x="2">&lt;c2&gt;</bpt>Bidirectional<bpt i="3" x="3">&lt;w3&gt;</bpt>Collection<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルに準拠する場合に限り、負であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The result has the same sign as <bpt i="0" x="0">&lt;c0&gt;</bpt>lhs<ept i="0">&lt;/c0&gt;</ept> and has a magnitude less than <bpt i="1" x="1">&lt;c1&gt;</bpt>rhs<bpt i="2" x="2">&lt;w2&gt;</bpt>.magnitude<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果は、<bpt i="0" x="0">&lt;c0&gt;</bpt>lhs<ept i="0">&lt;/c0&gt;</ept>と同じ符号を持ち、<bpt i="1" x="1">&lt;c1&gt;</bpt>rhs<bpt i="2" x="2">&lt;w2&gt;</bpt>.magnitude<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>より小さい規模を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The result is always exact.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果は常に厳密に正確です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The result of evaluating <bpt i="4" x="4">&lt;c4&gt;</bpt>rhs<ept i="4">&lt;/c4&gt;</ept> is the result of the <bpt i="5" x="5">&lt;c5&gt;</bpt>||<ept i="5">&lt;/c5&gt;</ept> operation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>rhs<ept i="4">&lt;/c4&gt;</ept>を評価することの結果は、<bpt i="5" x="5">&lt;c5&gt;</bpt>||<ept i="5">&lt;/c5&gt;</ept>演算の結果です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The result of evaluating <bpt i="5" x="5">&lt;c5&gt;</bpt>rhs<ept i="5">&lt;/c5&gt;</ept> is the result of the <bpt i="6" x="6">&lt;c6&gt;</bpt>&amp;&amp;<ept i="6">&lt;/c6&gt;</ept> operation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>rhs<ept i="5">&lt;/c5&gt;</ept>を評価することの結果は、<bpt i="6" x="6">&lt;c6&gt;</bpt>&amp;&amp;<ept i="6">&lt;/c6&gt;</ept>演算の結果です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The result of the initializer has the same magnitude as <bpt i="0" x="0">&lt;c0&gt;</bpt>magnitude<bpt i="1" x="1">&lt;w1&gt;</bpt>Of<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>イニシャライザの結果は、<bpt i="0" x="0">&lt;c0&gt;</bpt>magnitude<bpt i="1" x="1">&lt;w1&gt;</bpt>Of<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と同じ規模を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The result of the initializer has the same sign as <bpt i="0" x="0">&lt;c0&gt;</bpt>sign<bpt i="1" x="1">&lt;w1&gt;</bpt>Of<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>イニシャライザの結果は、<bpt i="0" x="0">&lt;c0&gt;</bpt>sign<bpt i="1" x="1">&lt;w1&gt;</bpt>Of<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と同じ符号を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The result of the operation is <bpt i="7" x="7">&lt;c7&gt;</bpt>false<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この演算の結果は、<bpt i="7" x="7">&lt;c7&gt;</bpt>false<ept i="7">&lt;/c7&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The result of the operation is <bpt i="7" x="7">&lt;c7&gt;</bpt>true<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この演算の結果は、<bpt i="7" x="7">&lt;c7&gt;</bpt>true<ept i="7">&lt;/c7&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The result of the remainder operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>%<ept i="0">&lt;/c0&gt;</ept>) has the same sign as <bpt i="1" x="1">&lt;c1&gt;</bpt>lhs<ept i="1">&lt;/c1&gt;</ept> and has a magnitude less than <bpt i="2" x="2">&lt;c2&gt;</bpt>rhs<bpt i="3" x="3">&lt;w3&gt;</bpt>.magnitude<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>剰余演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>%<ept i="0">&lt;/c0&gt;</ept>）の結果は、<bpt i="1" x="1">&lt;c1&gt;</bpt>lhs<ept i="1">&lt;/c1&gt;</ept>と同じ符号を持ち、<bpt i="2" x="2">&lt;c2&gt;</bpt>rhs<bpt i="3" x="3">&lt;w3&gt;</bpt>.magnitude<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>より小さい規模を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The result of this operation will be the same type as its arguments.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この演算の結果は、それの引数と同じ型になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The result of this operation will have the non-optional type of the left-hand side’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この演算の結果は、左手側のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Wrapped<ept i="0">&lt;/c0&gt;</ept>型の非オプショナル型を持つことになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The resulting array consists of at most <bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Splits + 1<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> subsequences.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果の配列は、多くとも<bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Splits + 1<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の下位シーケンスから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The resulting collection has the type of argument on the right-hand side.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果となるコレクションは、右手側の引数の型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The resulting collection has the type of the argument on the left-hand side.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果となるコレクションは、左手側の引数の型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The resulting flattened array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果として生じる平たくされた配列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The resulting instance may not have the same numeric value as <bpt i="0" x="0">&lt;c0&gt;</bpt>bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Pattern<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>—it is only guaranteed to use the same pattern of bits in its binary representation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果のインスタンスは、<bpt i="0" x="0">&lt;c0&gt;</bpt>bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Pattern<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と同じ数値を持たないかもしれません — それは、同じパターンのビットをそれのバイナリ表現において使うことを保証されるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The resulting pointer must be within the bounds of the same allocation as this pointer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果のポインタは、このポインタと同じアロケーションの範囲内でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The resulting quotient must be representable within the bounds of the type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果の商は、この型の境界の内に表現可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The resulting subsequence <bpt i="0" x="0">&lt;e0&gt;</bpt>does not include<ept i="0">&lt;/e0&gt;</ept> the element at the position <bpt i="1" x="1">&lt;c1&gt;</bpt>end<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果となるシーケンスは、位置<bpt i="1" x="1">&lt;c1&gt;</bpt>end<ept i="1">&lt;/c1&gt;</ept>での要素を<bpt i="0" x="0">&lt;e0&gt;</bpt>含みません<ept i="0">&lt;/e0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The resulting subsequence <bpt i="0" x="0">&lt;e0&gt;</bpt>includes<ept i="0">&lt;/e0&gt;</ept> the element at the position <bpt i="1" x="1">&lt;c1&gt;</bpt>end<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果となるシーケンスは、位置<bpt i="1" x="1">&lt;c1&gt;</bpt>end<ept i="1">&lt;/c1&gt;</ept>での要素を<bpt i="0" x="0">&lt;e0&gt;</bpt>含みます<ept i="0">&lt;/e0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The resulting value must be representable in the same type as the argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果の値は、引数と同じ型で表現可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The resulting value must be representable within the value’s type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果の値は、その値の持つ型の内部に表現可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The retrieved slice of <bpt i="0" x="0">&lt;c0&gt;</bpt>text<ept i="0">&lt;/c0&gt;</ept> is equivalent in each of these cases.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>取って来た<bpt i="0" x="0">&lt;c0&gt;</bpt>text<ept i="0">&lt;/c0&gt;</ept>のスライスは、それらの場合それぞれにで同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The return type of functions that do not return normally, that is, a type with no values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>普通に戻らない関数の戻り型、すなわち、値なしでの型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The return value, if any, of the <bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept> closure parameter.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept>クロージャパラメータの戻り値、もしあれば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The return value, if any, of the <bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept> closure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>body<ept i="0">&lt;/c0&gt;</ept>クロージャの、もしあれば、戻り値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The returned <bpt i="0" x="0">&lt;c0&gt;</bpt>Array<bpt i="1" x="1">&lt;w1&gt;</bpt>Slice<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance uses the same indices for the same elements as the original array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>返された<bpt i="0" x="0">&lt;c0&gt;</bpt>Array<bpt i="1" x="1">&lt;w1&gt;</bpt>Slice<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスは、同じ要素に対して元のコレクションと同じインデックスを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The returned range is <bpt i="1" x="1">&lt;e1&gt;</bpt>not<ept i="1">&lt;/e1&gt;</ept> guaranteed to be inside the bounds of <bpt i="2" x="2">&lt;c2&gt;</bpt>collection<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>返される範囲は、<bpt i="2" x="2">&lt;c2&gt;</bpt>collection<ept i="2">&lt;/c2&gt;</ept>の境界内であると保証され<bpt i="1" x="1">&lt;e1&gt;</bpt>ません<ept i="1">&lt;/e1&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The right-hand side of the operation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>演算子の右手側。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The root type for this key path.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このキーパスのためのルート型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The rounding rule to use.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この丸め規則を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The same state is passed to all invocations of <bpt i="1" x="1">&lt;c1&gt;</bpt>next<ept i="1">&lt;/c1&gt;</ept>, so subsequent calls will see any mutations made by previous calls.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その同じ状態は、<bpt i="1" x="1">&lt;c1&gt;</bpt>next<ept i="1">&lt;/c1&gt;</ept>のすべてに呼び出しに対して渡されます、なので続いて起こる呼び出しは前の呼び出しによって為される何らかの変化を見ることになるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The second call to <bpt i="0" x="0">&lt;c0&gt;</bpt>appending(path:)<ept i="0">&lt;/c0&gt;</ept> returns <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> because the root type of <bpt i="2" x="2">&lt;c2&gt;</bpt>array<bpt i="3" x="3">&lt;w3&gt;</bpt>Description<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>Array&lt;Int&gt;<ept i="4">&lt;/c4&gt;</ept>, does not match the value type of <bpt i="5" x="5">&lt;c5&gt;</bpt>string<bpt i="6" x="6">&lt;w6&gt;</bpt>Length<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt>Int<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２番目の<bpt i="0" x="0">&lt;c0&gt;</bpt>appending(path:)<ept i="0">&lt;/c0&gt;</ept>への呼び出しは<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>を返します、なぜなら<bpt i="2" x="2">&lt;c2&gt;</bpt>array<bpt i="3" x="3">&lt;w3&gt;</bpt>Description<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>のルート型、<bpt i="4" x="4">&lt;c4&gt;</bpt>Array&lt;Int&gt;<ept i="4">&lt;/c4&gt;</ept>は、<bpt i="5" x="5">&lt;c5&gt;</bpt>string<bpt i="6" x="6">&lt;w6&gt;</bpt>Length<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>の値型、<bpt i="7" x="7">&lt;c7&gt;</bpt>Int<ept i="7">&lt;/c7&gt;</ept>と合致しないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The second call to <bpt i="0" x="0">&lt;c0&gt;</bpt>appending(path:)<ept i="0">&lt;/c0&gt;</ept> returns <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> because the root type of the <bpt i="2" x="2">&lt;c2&gt;</bpt>path<ept i="2">&lt;/c2&gt;</ept> parameter, <bpt i="3" x="3">&lt;c3&gt;</bpt>Double<ept i="3">&lt;/c3&gt;</ept>, does not match the value type of <bpt i="4" x="4">&lt;c4&gt;</bpt>array<bpt i="5" x="5">&lt;w5&gt;</bpt>Description<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>String<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２番目の<bpt i="0" x="0">&lt;c0&gt;</bpt>appending(path:)<ept i="0">&lt;/c0&gt;</ept>への呼び出しは<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>を返します、なぜなら<bpt i="2" x="2">&lt;c2&gt;</bpt>path<ept i="2">&lt;/c2&gt;</ept>パラメータのルート型、<bpt i="3" x="3">&lt;c3&gt;</bpt>Double<ept i="3">&lt;/c3&gt;</ept>は、<bpt i="4" x="4">&lt;c4&gt;</bpt>array<bpt i="5" x="5">&lt;w5&gt;</bpt>Description<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>の値型、<bpt i="6" x="6">&lt;c6&gt;</bpt>String<ept i="6">&lt;/c6&gt;</ept>と合致しないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The second example passes <bpt i="0" x="0">&lt;c0&gt;</bpt>1<ept i="0">&lt;/c0&gt;</ept> for the <bpt i="1" x="1">&lt;c1&gt;</bpt>max<bpt i="2" x="2">&lt;w2&gt;</bpt>Splits<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> parameter, so the original string is split just once, into two new strings.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２番目の例は<bpt i="0" x="0">&lt;c0&gt;</bpt>1<ept i="0">&lt;/c0&gt;</ept>を<bpt i="1" x="1">&lt;c1&gt;</bpt>max<bpt i="2" x="2">&lt;w2&gt;</bpt>Splits<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>パラメータに渡します、それで元の文字列は一度だけ分割されて、２つの新しい文字列になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The second partition, <bpt i="2" x="2">&lt;c2&gt;</bpt>numbers[p...]<ept i="2">&lt;/c2&gt;</ept>, is made up of the elements that <bpt i="3" x="3">&lt;e3&gt;</bpt>are<ept i="3">&lt;/e3&gt;</ept> greater than 30.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２番目の区画、<bpt i="2" x="2">&lt;c2&gt;</bpt>numbers[p...]<ept i="2">&lt;/c2&gt;</ept>は、30より大きなもの<bpt i="3" x="3">&lt;e3&gt;</bpt>である<ept i="3">&lt;/e3&gt;</ept>要素から構成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The second sequence or collection to zip.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>組み合わされる第２のシーケンスまたはコレクション。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The second value to add.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>加算する第２の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The second value to multiply.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>掛け合わされる第２の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The second value to swap.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>交換する２つ目の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The second version of <bpt i="7" x="7">&lt;c7&gt;</bpt>all<bpt i="8" x="8">&lt;w8&gt;</bpt>Values(in:<bpt i="9" x="9">&lt;w9&gt;</bpt>match:)<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> compiles without error, with the compiler guaranteeing that the <bpt i="10" x="10">&lt;c10&gt;</bpt>escapable<bpt i="11" x="11">&lt;w11&gt;</bpt>Predicate<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> closure doesn’t last beyond the call to <bpt i="12" x="12">&lt;c12&gt;</bpt>without<bpt i="13" x="13">&lt;w13&gt;</bpt>Actually<bpt i="14" x="14">&lt;w14&gt;</bpt>Escaping(_:<bpt i="15" x="15">&lt;w15&gt;</bpt>do:)<ept i="15">&lt;/w15&gt;</ept><ept i="14">&lt;/w14&gt;</ept><ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２番目のバージョンの<bpt i="7" x="7">&lt;c7&gt;</bpt>all<bpt i="8" x="8">&lt;w8&gt;</bpt>Values(in:<bpt i="9" x="9">&lt;w9&gt;</bpt>match:)<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>は、<bpt i="10" x="10">&lt;c10&gt;</bpt>escapable<bpt i="11" x="11">&lt;w11&gt;</bpt>Predicate<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>クロージャが<bpt i="12" x="12">&lt;c12&gt;</bpt>without<bpt i="13" x="13">&lt;w13&gt;</bpt>Actually<bpt i="14" x="14">&lt;w14&gt;</bpt>Escaping(_:<bpt i="15" x="15">&lt;w15&gt;</bpt>do:)<ept i="15">&lt;/w15&gt;</ept><ept i="14">&lt;/w14&gt;</ept><ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>の呼び出しを越えて持ちこたえないことをコンパイラが保証して、エラーなしでコンパイルします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The second version, <bpt i="2" x="2">&lt;c2&gt;</bpt>present()<ept i="2">&lt;/c2&gt;</ept>, returns a Boolean value and is an asynchronous method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２番目のバージョン、<bpt i="2" x="2">&lt;c2&gt;</bpt>present()<ept i="2">&lt;/c2&gt;</ept>は、ブール値を返します、そして非同期メソッドです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The selector piece for the completion handler is removed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>完了ハンドラのセレクタ部分は、取り除かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The sequence ends either when the base sequence ends or when <bpt i="2" x="2">&lt;c2&gt;</bpt>transform<ept i="2">&lt;/c2&gt;</ept> throws an error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスは、基底シーケンスが終わる時かまたは<bpt i="2" x="2">&lt;c2&gt;</bpt>transform<ept i="2">&lt;/c2&gt;</ept>がエラーをスローする時に終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The sequence ends either when the the last sequence created from the last element from base sequence ends, or when <bpt i="1" x="1">&lt;c1&gt;</bpt>transform<ept i="1">&lt;/c1&gt;</ept> throws an error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスは、基底シーケンスからの最後の要素から作成された最後のシーケンスが終わる時、または<bpt i="1" x="1">&lt;c1&gt;</bpt>transform<ept i="1">&lt;/c1&gt;</ept>がエラーをスローする時のどちらかに終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The sequence ends when <bpt i="2" x="2">&lt;c2&gt;</bpt>next<ept i="2">&lt;/c2&gt;</ept> returns <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスは、<bpt i="2" x="2">&lt;c2&gt;</bpt>next<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>を返す時に終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The sequence must be finite.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスは有限でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The sequence of elements for the new collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいコレクションのための要素からなるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The sequence of elements to turn into an array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列になることになる、いくらかの要素からなるシーケンス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The sequence’s maximum element if the sequence is not empty; otherwise, <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスが空でないならばシーケンスの最大の要素；そうでなければ<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The sequence’s maximum element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスの最大の要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The sequence’s minimum element, according to <bpt i="0" x="0">&lt;c0&gt;</bpt>are<bpt i="1" x="1">&lt;w1&gt;</bpt>In<bpt i="2" x="2">&lt;w2&gt;</bpt>Increasing<bpt i="3" x="3">&lt;w3&gt;</bpt>Order<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスの最小の要素、<bpt i="0" x="0">&lt;c0&gt;</bpt>are<bpt i="1" x="1">&lt;w1&gt;</bpt>In<bpt i="2" x="2">&lt;w2&gt;</bpt>Increasing<bpt i="3" x="3">&lt;w3&gt;</bpt>Order<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>による。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The sequence’s minimum element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスの最小の要素。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The set of characters that have an <bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Math<bpt i="2" x="2">&lt;w2&gt;</bpt>Symbol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> value of <bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept> is not a strict subset of those for which <bpt i="4" x="4">&lt;c4&gt;</bpt>is<bpt i="5" x="5">&lt;w5&gt;</bpt>Symbol<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> is <bpt i="6" x="6">&lt;c6&gt;</bpt>true<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Math<bpt i="2" x="2">&lt;w2&gt;</bpt>Symbol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の値に<bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept>を持つ文字の集合は、それらに対して<bpt i="4" x="4">&lt;c4&gt;</bpt>is<bpt i="5" x="5">&lt;w5&gt;</bpt>Symbol<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>が<bpt i="6" x="6">&lt;c6&gt;</bpt>true<ept i="6">&lt;/c6&gt;</ept>であるものの狭義の部分集合ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The shared actor instance that will be used to provide mutually-exclusive access to declarations annotated with the given global actor type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>共有アクターインスタンス、それは与えられたグローバルアクター型で注釈を付けられた宣言への相互排他アクセスを提供するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The shared executor instance that will be used to provide mutually-exclusive access for the global actor.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>共有エグゼキュータ（遂行者）インスタンス、それはグローバルアクターに対する相互排他アクセスを提供するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The shift is performed using this masked value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シフトは、このマスクされた値を使って実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The sign for a negative value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>負の値に対する符号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The sign for a positive value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>正の値に対する符号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The sign of a floating-point value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある浮動小数点値の符号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The sign of the floating-point value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>浮動小数点値の符号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The sign of the new value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい値の符号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The sign of this number, expressed as an integer of the same type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この数の符号、同じ型の整数として表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The sign to use for the new value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい値に対して使うための符号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The significand is frequently also called the <bpt i="0" x="0">&lt;e0&gt;</bpt>mantissa<ept i="0">&lt;/e0&gt;</ept>, but significand is the preferred terminology in the <bpt i="1" x="1">&lt;a1&gt;</bpt>IEEE 754 specification<ept i="1">&lt;/a1&gt;</ept>, to allay confusion with the use of mantissa for the fractional part of a logarithm.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>仮数（significand）はしばしば<bpt i="0" x="0">&lt;e0&gt;</bpt>mantissa<ept i="0">&lt;/e0&gt;</ept>とも呼ばれます、しかし仮数が<bpt i="1" x="1">&lt;a1&gt;</bpt>IEEE 754仕様<ept i="1">&lt;/a1&gt;</ept>において推奨される用語です、対数の小数部分に対する仮数（mantissa）の使用との混同を静めるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The significand may include a decimal point.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>仮数は、小数点を含んでも構いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The significand of <bpt i="5" x="5">&lt;c5&gt;</bpt>y<ept i="5">&lt;/c5&gt;</ept> is therefore 1.34375.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>y<ept i="5">&lt;/c5&gt;</ept>の仮数はしたがって1.34375です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The significand of the floating-point value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>浮動小数点値の仮数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The single <bpt i="4" x="4">&lt;c4&gt;</bpt>Bool<ept i="4">&lt;/c4&gt;</ept> type in Swift guarantees that functions, methods, and properties imported from C and Objective-C have a consistent type interface.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swift保証の単一<bpt i="4" x="4">&lt;c4&gt;</bpt>Bool<ept i="4">&lt;/c4&gt;</ept>型で、関数、メソッド、そしてプロパティがCおよびObjective-Cからインポートしたものは、首尾一貫した型インターフェイスを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The single-character string to convert to a <bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Character<ept i="0">&lt;/c0&gt;</ept>インスタンスへと変換される単一文字文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The sorting algorithm is not guaranteed to be stable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このソートアルゴリズムは、安定であることを保証されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The square root of the value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値の平方根。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The stable identity of the entity associated with this instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このインスタンスと結び付けられた登録項目の安定した同一性。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The standard library floating-point types—<bpt i="0" x="0">&lt;c0&gt;</bpt>Float<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept>, and <bpt i="2" x="2">&lt;c2&gt;</bpt>Float80<ept i="2">&lt;/c2&gt;</ept> where available—all conform to the <bpt i="3" x="3">&lt;c3&gt;</bpt>Expressible<bpt i="4" x="4">&lt;w4&gt;</bpt>By<bpt i="5" x="5">&lt;w5&gt;</bpt>Float<bpt i="6" x="6">&lt;w6&gt;</bpt>Literal<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>標準ライブラリ浮動小数点型—<bpt i="0" x="0">&lt;c0&gt;</bpt>Float<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept>、そして利用可能なところでは<bpt i="2" x="2">&lt;c2&gt;</bpt>Float80<ept i="2">&lt;/c2&gt;</ept>—は、すべて<bpt i="3" x="3">&lt;c3&gt;</bpt>Expressible<bpt i="4" x="4">&lt;w4&gt;</bpt>By<bpt i="5" x="5">&lt;w5&gt;</bpt>Float<bpt i="6" x="6">&lt;w6&gt;</bpt>Literal<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>プロトコルに準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The standard library integer and floating-point types are all valid types for <bpt i="0" x="0">&lt;c0&gt;</bpt>Integer<bpt i="1" x="1">&lt;w1&gt;</bpt>Literal<bpt i="2" x="2">&lt;w2&gt;</bpt>Type<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>標準ライブラリの整数および浮動小数点型は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Integer<bpt i="1" x="1">&lt;w1&gt;</bpt>Literal<bpt i="2" x="2">&lt;w2&gt;</bpt>Type<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対する有効な型のすべてです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The standard library integer and floating-point types, such as <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept>, conform to the <bpt i="2" x="2">&lt;c2&gt;</bpt>Expressible<bpt i="3" x="3">&lt;w3&gt;</bpt>By<bpt i="4" x="4">&lt;w4&gt;</bpt>Integer<bpt i="5" x="5">&lt;w5&gt;</bpt>Literal<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>標準ライブラリの整数および浮動小数点型、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>および<bpt i="1" x="1">&lt;c1&gt;</bpt>Double<ept i="1">&lt;/c1&gt;</ept>は、<bpt i="2" x="2">&lt;c2&gt;</bpt>Expressible<bpt i="3" x="3">&lt;w3&gt;</bpt>By<bpt i="4" x="4">&lt;w4&gt;</bpt>Integer<bpt i="5" x="5">&lt;w5&gt;</bpt>Literal<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルに準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The standard library provides an implementation for the not-equal-to operator (<bpt i="4" x="4">&lt;c4&gt;</bpt>!=<ept i="4">&lt;/c4&gt;</ept>) for any <bpt i="5" x="5">&lt;c5&gt;</bpt>Equatable<ept i="5">&lt;/c5&gt;</ept> type, which calls the custom <bpt i="6" x="6">&lt;c6&gt;</bpt>==<ept i="6">&lt;/c6&gt;</ept> function and negates its result.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>標準ライブラリは、不等演算子（<bpt i="4" x="4">&lt;c4&gt;</bpt>!=<ept i="4">&lt;/c4&gt;</ept>）のある実装をあらゆる<bpt i="5" x="5">&lt;c5&gt;</bpt>Equatable<ept i="5">&lt;/c5&gt;</ept>型に対して実装します、それはあつらえの<bpt i="6" x="6">&lt;c6&gt;</bpt>==<ept i="6">&lt;/c6&gt;</ept>関数を呼び出してそれの結果を逆にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The start and end of a subrange must be valid indices of the array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下位範囲の始まりと終わりは、配列の有効なインデックスでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The starting value to use for the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスに使うための開始値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The stream to use for writing the contents of <bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept>の内容を書き出すために使うことになるストリーム。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The stream was cancelled</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ストリームは取り消されました</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The stream was finished via the <bpt i="0" x="0">&lt;c0&gt;</bpt>finish<ept i="0">&lt;/c0&gt;</ept> method</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ストリームは<bpt i="0" x="0">&lt;c0&gt;</bpt>finish<ept i="0">&lt;/c0&gt;</ept>メソッド経由で終了されました</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The string of characters read from standard input.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>標準入力から読み込まれた一続きの文字。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The string passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>description<ept i="0">&lt;/c0&gt;</ept> may begin with a plus or minus sign character (<bpt i="1" x="1">&lt;c1&gt;</bpt>+<ept i="1">&lt;/c1&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt>-<ept i="2">&lt;/c2&gt;</ept>), followed by one or more numeric digits (<bpt i="3" x="3">&lt;c3&gt;</bpt>0-9<ept i="3">&lt;/c3&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>description<ept i="0">&lt;/c0&gt;</ept>として渡される文字列は、プラスまたはマイナス符号文字（<bpt i="1" x="1">&lt;c1&gt;</bpt>+<ept i="1">&lt;/c1&gt;</ept>または<bpt i="2" x="2">&lt;c2&gt;</bpt>-<ept i="2">&lt;/c2&gt;</ept>）で始まり、１つ以上の数値のアラビア数字（<bpt i="3" x="3">&lt;c3&gt;</bpt>0-9<ept i="3">&lt;/c3&gt;</ept>）が続くことがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The string passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>text<ept i="0">&lt;/c0&gt;</ept> can represent a real number in decimal or hexadecimal format or special floating-point values for infinity and NaN (“not a number”).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>text<ept i="0">&lt;/c0&gt;</ept>として渡される文字列は、10進または16進数形式における実数、または無限大とNaN（「非数」）に対する特別な浮動小数点値を表せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The string passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>text<ept i="0">&lt;/c0&gt;</ept> may begin with a plus or minus sign character (<bpt i="1" x="1">&lt;c1&gt;</bpt>+<ept i="1">&lt;/c1&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt>-<ept i="2">&lt;/c2&gt;</ept>), followed by one or more numeric digits (<bpt i="3" x="3">&lt;c3&gt;</bpt>0-9<ept i="3">&lt;/c3&gt;</ept>) or letters (<bpt i="4" x="4">&lt;c4&gt;</bpt>a-z<ept i="4">&lt;/c4&gt;</ept> or <bpt i="5" x="5">&lt;c5&gt;</bpt>A-Z<ept i="5">&lt;/c5&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>text<ept i="0">&lt;/c0&gt;</ept>として渡される文字列は、プラスまたはマイナス符号文字（<bpt i="1" x="1">&lt;c1&gt;</bpt>+<ept i="1">&lt;/c1&gt;</ept>または<bpt i="2" x="2">&lt;c2&gt;</bpt>-<ept i="2">&lt;/c2&gt;</ept>）で始まり、１つ以上の数値のアラビア数字（<bpt i="3" x="3">&lt;c3&gt;</bpt>0-9<ept i="3">&lt;/c3&gt;</ept>）または文字（<bpt i="4" x="4">&lt;c4&gt;</bpt>a-z<ept i="4">&lt;/c4&gt;</ept> or <bpt i="5" x="5">&lt;c5&gt;</bpt>A-Z<ept i="5">&lt;/c5&gt;</ept>）が続くことがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The string to print after all items have been printed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>すべての項目が出力された後に出力する文字列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The string to print.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>出力するメッセージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The string to use in a named collection (e.g. a string-keyed dictionary).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>文字列を名前付きコレクションで使います（例えば、名前キー付き辞書）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The string value of the desired key.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>望むキーの文字列値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The subrange of the array to replace.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>置き換えられることになる配列の下位範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The subrange of the collection to replace.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>置き換えることになるコレクションの下位範囲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The subscript notation is preferred over <bpt i="1" x="1">&lt;c1&gt;</bpt>prefix(through:)<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>添え字表記法は、<bpt i="1" x="1">&lt;c1&gt;</bpt>prefix(through:)<ept i="1">&lt;/c1&gt;</ept>よりも好まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The subscript notation is preferred over <bpt i="1" x="1">&lt;c1&gt;</bpt>suffix(from:)<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>添え字表記法は、<bpt i="1" x="1">&lt;c1&gt;</bpt>suffix(from:)<ept i="1">&lt;/c1&gt;</ept>よりも好まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The subscript notation is preferred over <bpt i="2" x="2">&lt;c2&gt;</bpt>prefix(up<bpt i="3" x="3">&lt;w3&gt;</bpt>To:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>添え字表記法は、<bpt i="2" x="2">&lt;c2&gt;</bpt>prefix(up<bpt i="3" x="3">&lt;w3&gt;</bpt>To:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>よりも好まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The subtraction operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>-<ept i="0">&lt;/c0&gt;</ept>) calculates the difference of its two arguments.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>減算演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>-<ept i="0">&lt;/c0&gt;</ept>）は、それの２つの引数の差を計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The successor of an index must be well defined.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるインデックスの後に続くものは、よく定義されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The sum of the two arguments must be representable in the arguments’ type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの引数の合計は、引数の持つ型において表現可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The sum of types that can be used as a Quick Look representation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>「クイックルック」表現として使われることのできる型の総和。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The synthesized <bpt i="3" x="3">&lt;c3&gt;</bpt>all<bpt i="4" x="4">&lt;w4&gt;</bpt>Cases<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> collection provides the cases in order of their declaration.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>合成された<bpt i="3" x="3">&lt;c3&gt;</bpt>all<bpt i="4" x="4">&lt;w4&gt;</bpt>Cases<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>コレクションは、ケース節をそれらの宣言の順に提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The task continues executing when its executor is able to reschedule it.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>タスクは、それの遂行者（executor）がそれを予定変更可能である時に遂行を継続します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The tasks are canceled only if <bpt i="0" x="0">&lt;c0&gt;</bpt>cancel<bpt i="1" x="1">&lt;w1&gt;</bpt>All()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> was invoked before returning, if the group’s task was canceled, or if the group’s body throws an error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>タスクそれらが取り消されるのは、復帰する前に<bpt i="0" x="0">&lt;c0&gt;</bpt>cancel<bpt i="1" x="1">&lt;w1&gt;</bpt>All()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が発動された場合にのみです、グループのもつタスクが取り消されたとしても、またはグループのもつ本体がエラーをスローするとしても。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The tasks are canceled only if <bpt i="0" x="0">&lt;c0&gt;</bpt>cancel<bpt i="1" x="1">&lt;w1&gt;</bpt>All()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> was invoked before returning, if the group’s task was canceled.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>タスクそれらが取り消されるのは、復帰する前に<bpt i="0" x="0">&lt;c0&gt;</bpt>cancel<bpt i="1" x="1">&lt;w1&gt;</bpt>All()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が発動された場合にのみです、グループのもつタスクが取り消されたとしても。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The tasks must handle cancellation in some other way, such as returning the work completed so far, returning an empty result, or returning <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>タスクは取り消しを何らかの他の方法で取り扱わなければなりません、たとえばそれまでに完了された仕事を返す、空の結果を返す、または<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>を返すなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The textual representation for each item is the same as that obtained by calling <bpt i="3" x="3">&lt;c3&gt;</bpt>String(item)<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>各項目のテキスト表現は、<bpt i="3" x="3">&lt;c3&gt;</bpt>String(item)<ept i="3">&lt;/c3&gt;</ept>を呼び出すことで得られるものと同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The textual representation for each item is the same as that obtained by calling <bpt i="4" x="4">&lt;c4&gt;</bpt>String(item)<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>各項目のテキスト表現は、<bpt i="4" x="4">&lt;c4&gt;</bpt>String(item)<ept i="4">&lt;/c4&gt;</ept>を呼び出すことで得られるものと同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The textual representation for each item is the same as that obtained by calling <bpt i="4" x="4">&lt;c4&gt;</bpt>String(reflecting: item)<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>各項目のテキスト表現は、<bpt i="4" x="4">&lt;c4&gt;</bpt>String(reflecting: item)<ept i="4">&lt;/c4&gt;</ept>を呼び出すことで得られるものと同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The textual representation for each item is the same as that obtained by calling <bpt i="5" x="5">&lt;c5&gt;</bpt>String(reflecting: item)<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>各項目のテキスト表現は、<bpt i="5" x="5">&lt;c5&gt;</bpt>String(reflecting: item)<ept i="5">&lt;/c5&gt;</ept>を呼び出すことで得られるものと同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The total number of elements that the array can contain without allocating new storage.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その配列が新しいストレージを割り当てることなく含むことができる要素の総数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The total number of key-value pairs that the dictionary can contain without allocating new storage.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その辞書が新しいストレージをアロケートすることなく含むことが可能なキー値ペアの総数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The transforming closure takes the received <bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept> and returns a new <bpt i="5" x="5">&lt;c5&gt;</bpt>Counter<ept i="5">&lt;/c5&gt;</ept> that counts that high.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>変換クロージャは、その受け取った<bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept>をとり、そしてその高さを数える新しい<bpt i="5" x="5">&lt;c5&gt;</bpt>Counter<ept i="5">&lt;/c5&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The two arguments must have the same <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの引数は、同じ<bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>型を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The two arguments must not alias each other.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの値は、互いのエイリアスであってはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The two loops in the following example produce the same output:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>以下の例における２つのループは、同じ出力を生み出します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The type <bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept> to which <bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept> is cast.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型<bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept>、それへと<bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept>がキャストされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The type aliased by <bpt i="0" x="0">&lt;c0&gt;</bpt>Boolean<bpt i="1" x="1">&lt;w1&gt;</bpt>Literal<bpt i="2" x="2">&lt;w2&gt;</bpt>Type<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must conform to the <bpt i="3" x="3">&lt;c3&gt;</bpt>Expressible<bpt i="4" x="4">&lt;w4&gt;</bpt>By<bpt i="5" x="5">&lt;w5&gt;</bpt>Boolean<bpt i="6" x="6">&lt;w6&gt;</bpt>Literal<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Boolean<bpt i="1" x="1">&lt;w1&gt;</bpt>Literal<bpt i="2" x="2">&lt;w2&gt;</bpt>Type<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>によってエイリアス（別名）を付けられる型は、<bpt i="3" x="3">&lt;c3&gt;</bpt>Expressible<bpt i="4" x="4">&lt;w4&gt;</bpt>By<bpt i="5" x="5">&lt;w5&gt;</bpt>Boolean<bpt i="6" x="6">&lt;w6&gt;</bpt>Literal<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>プロトコルに準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The type doesn't meet the criteria listed in the previous section.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その型が以前の節においてリストされる基準に合わない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The type each segment of a string literal containing interpolations should be appended to.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>加えられるべき補間を含んでいる文字列リテラルの各文節の型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The type of asynchronous iterator that produces elements of this asynchronous sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この非同期シーケンスの要素それらを取り出す非同期イテレータの型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The type of element produced by this asynchronous sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この非同期シーケンスによって取り出される要素の型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The type of element returned by <bpt i="0" x="0">&lt;c0&gt;</bpt>next()<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>next()<ept i="0">&lt;/c0&gt;</ept>によって返される要素のもつ型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The type of element traversed by the iterator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイテレータによって辿っていかれる要素の型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The type of elements produced by this iterator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイテレータによって取り出される要素それらの型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The type of iterator that produces elements of the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このシーケンスの要素それらを生み出すイテレータの型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The type of scalars in the vector space.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このベクタースペースの中のスカラーそれらの型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The type of the elements of an array literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列リテラルの要素の型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The type of the shared actor instance that will be used to provide mutually-exclusive access to declarations annotated with the given global actor type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>共有アクターインスタンスの型、それは与えられたグローバルアクター型で注釈を付けられた宣言への相互排他アクセスを提供するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The type that allows iteration over an array’s elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列の持つ要素のすべてにわたる反復を許可する型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The type that represents the indices that are valid for subscripting an array, in ascending order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>昇順での、配列の添え字として有効なインデックスを表す型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The type that should be used for literal segments.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>リテラル文節に対して使われるべき型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The type the AsyncStream will produce.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>AsyncStreamが生み出すだろう型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The type to cast <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> to.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>をこれにキャストすることになる型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The typed pointer to convert.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>変換されることになる型付ポインタ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The types of the two underlying indices must be identical.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの基礎をなすインデックスの型は同一でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The unary minus operator (prefix <bpt i="0" x="0">&lt;c0&gt;</bpt>-<ept i="0">&lt;/c0&gt;</ept>) calculates the negation of its operand.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>単項マイナス演算子（前置<bpt i="0" x="0">&lt;c0&gt;</bpt>-<ept i="0">&lt;/c0&gt;</ept>）は、それの演算数の否定を計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The underlying error which caused this error, if any.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このエラーの元となった基礎をなすエラー、もしあれば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The underlying iterator’s sequence may be infinite.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>基礎をなすイテレータのもつシーケンスは、無限であるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The underlying type a Boolean uses when it wraps itself in a data value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるブールが、それがそれ自身をあるデータ値の中にラップする時に使う、基礎をなす型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The underlying type a dictionary uses when it wraps itself in a data value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある辞書が、それがそれ自身をあるデータ値の中にラップする時に使う、基礎をなす型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The underlying type a double uses when it wraps itself in a data value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるdoubleが、それがそれ自身をあるデータ値の中にラップする時に使う、基礎をなす型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The underlying type an array uses when it wraps itself in a data value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある配列が、それがそれ自身をあるデータ値の中にラップする時に使う、基礎をなす型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The underlying type an integer uses when it wraps itself in a data value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>整数が、それがそれ自身をあるデータ値の中にラップする時に使う、基礎をなす型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The unit in the last place of 1.0.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>1.0の最終桁単位。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The unit in the last place of this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値の最終桁単位。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The universal hash function used by <bpt i="0" x="0">&lt;c0&gt;</bpt>Set<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Dictionary<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Set<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>Dictionary<ept i="1">&lt;/c1&gt;</ept>によって使われる普遍的なハッシュ関数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The upper bound for the range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲の上側の境界。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value associated with <bpt i="0" x="0">&lt;c0&gt;</bpt>key<ept i="0">&lt;/c0&gt;</ept> if <bpt i="1" x="1">&lt;c1&gt;</bpt>key<ept i="1">&lt;/c1&gt;</ept> is in the dictionary; otherwise, <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>key<ept i="0">&lt;/c0&gt;</ept>と結び付けられた値、<bpt i="1" x="1">&lt;c1&gt;</bpt>key<ept i="1">&lt;/c1&gt;</ept>が辞書の中にあるならば；そうでなければ、<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value associated with <bpt i="0" x="0">&lt;c0&gt;</bpt>key<ept i="0">&lt;/c0&gt;</ept> in the dictionary; otherwise, <bpt i="1" x="1">&lt;c1&gt;</bpt>default<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>key<ept i="0">&lt;/c0&gt;</ept>と辞書の中で結びつけられる値；そうでなければ<bpt i="1" x="1">&lt;c1&gt;</bpt>default<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value for which to find the dynamic type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それに対して動的型を見つける値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value of <bpt i="0" x="0">&lt;c0&gt;</bpt>count<ept i="0">&lt;/c0&gt;</ept> must be greater than or equal to zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>count<ept i="0">&lt;/c0&gt;</ept>の値は、ゼロより大きいか等しくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value of <bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Length<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> must be greater than or equal to zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>max<bpt i="1" x="1">&lt;w1&gt;</bpt>Length<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の値は、ゼロより大きいか等しくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value of <bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept> is represented exactly by the new instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>の値は、新しいインスタンスによって正確に表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value of <bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept> is rounded to a representable value, if necessary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>other<ept i="0">&lt;/c0&gt;</ept>の値は、必要ならば、表現可能な値へと丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value of <bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept> is rounded to a representable value, if necessary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>value<ept i="0">&lt;/c0&gt;</ept>の値は、必要ならば、表現可能な値へと丸められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value of <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> converted to type <bpt i="1" x="1">&lt;c1&gt;</bpt>U<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型<bpt i="0" x="0">&lt;c0&gt;</bpt>U<ept i="0">&lt;/c0&gt;</ept>に変換された<bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept>の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value of <bpt i="5" x="5">&lt;c5&gt;</bpt>significand<bpt i="6" x="6">&lt;w6&gt;</bpt>Width<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> is always -1 or between zero and <bpt i="7" x="7">&lt;c7&gt;</bpt>significand<bpt i="8" x="8">&lt;w8&gt;</bpt>Bit<bpt i="9" x="9">&lt;w9&gt;</bpt>Count<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>significand<bpt i="6" x="6">&lt;w6&gt;</bpt>Width<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>の値は、常に-1、もしくはゼロと<bpt i="7" x="7">&lt;c7&gt;</bpt>significand<bpt i="8" x="8">&lt;w8&gt;</bpt>Bit<bpt i="9" x="9">&lt;w9&gt;</bpt>Count<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>の間です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value of the key.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キーの値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value of the new instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいインスタンスのための値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value of this property must always evaluate to the same actor instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このプロパティの値は、同じアクターインスタンスと常に等しくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value of this property must be equivalent to <bpt i="0" x="0">&lt;c0&gt;</bpt>shared<bpt i="1" x="1">&lt;w1&gt;</bpt>.unowned<bpt i="2" x="2">&lt;w2&gt;</bpt>Executor<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このプロパティの値は、<bpt i="0" x="0">&lt;c0&gt;</bpt>shared<bpt i="1" x="1">&lt;w1&gt;</bpt>.unowned<bpt i="2" x="2">&lt;w2&gt;</bpt>Executor<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と等しくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Pattern<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is interpreted in the binary interchange format defined by the <bpt i="2" x="2">&lt;a2&gt;</bpt>IEEE 754 specification<ept i="2">&lt;/a2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Pattern<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>として渡される値は、<bpt i="2" x="2">&lt;a2&gt;</bpt>IEEE 754仕様<ept i="2">&lt;/a2&gt;</ept>で定義されるバイナリ交換フォーマットにおいて解釈されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>distance<ept i="0">&lt;/c0&gt;</ept> must not offset <bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept> beyond the bounds of the collection, unless the index passed as <bpt i="2" x="2">&lt;c2&gt;</bpt>limit<ept i="2">&lt;/c2&gt;</ept> prevents offsetting beyond those bounds.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>distance<ept i="0">&lt;/c0&gt;</ept>として渡される値は、このコレクションの境界を越えて<bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept>を補ってはなりません、<bpt i="2" x="2">&lt;c2&gt;</bpt>limit<ept i="2">&lt;/c2&gt;</ept>として渡されるインデックスがそれら境界を越えて補うのを防止するのでない限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>distance<ept i="0">&lt;/c0&gt;</ept> must not offset <bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept> beyond the bounds of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>distance<ept i="0">&lt;/c0&gt;</ept>として渡される値は、このコレクションの境界を越えて<bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept>を補ってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>n<ept i="0">&lt;/c0&gt;</ept> must not offset <bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept> beyond the bounds of the collection, unless the index passed as <bpt i="2" x="2">&lt;c2&gt;</bpt>limit<ept i="2">&lt;/c2&gt;</ept> prevents offsetting beyond those bounds.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>n<ept i="0">&lt;/c0&gt;</ept>として渡される値は、このコレクションの境界を越えて<bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept>を補ってはなりません、<bpt i="2" x="2">&lt;c2&gt;</bpt>limit<ept i="2">&lt;/c2&gt;</ept>として渡されるインデックスがそれら境界を越えて補うのを防止するのでない限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>n<ept i="0">&lt;/c0&gt;</ept> must not offset <bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept> beyond the bounds of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>n<ept i="0">&lt;/c0&gt;</ept>として渡される値は、このコレクションの境界を越えて<bpt i="1" x="1">&lt;c1&gt;</bpt>i<ept i="1">&lt;/c1&gt;</ept>を補ってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>source<ept i="0">&lt;/c0&gt;</ept> must be representable in this type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>source<ept i="0">&lt;/c0&gt;</ept>として渡される値は、この型において表現可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value passed to the continuation by the closure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>クロージャによって継続へと渡される値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value that was removed, or <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> if the key was not present in the dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>削除された値、またはキーがこの辞書の中に存在しなかったならば<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value that was replaced, or <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> if a new key-value pair was added.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>取って代わられた値、または新しいキー値ペアが加えられたならば<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to add to this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値に加える値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to calculate the distance to.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それへの隔たりを計算される値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to compare with this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値と比較するための値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to create.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>作成されることになる値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to divide <bpt i="0" x="0">&lt;c0&gt;</bpt>lhs<ept i="0">&lt;/c0&gt;</ept> by.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値で<bpt i="0" x="0">&lt;c0&gt;</bpt>lhs<ept i="0">&lt;/c0&gt;</ept>を除算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to divide this value by.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値を除算するための値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to divide.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>除算することになる値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to multiply by this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値と掛け合わせられることになる値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to multiply this value by.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値に掛ける値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to negate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>負にする値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to output to the <bpt i="0" x="0">&lt;c0&gt;</bpt>target<ept i="0">&lt;/c0&gt;</ept> stream.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>target<ept i="0">&lt;/c0&gt;</ept>ストリームに出力することになる値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to return from the continuation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その継続から返す値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to shift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シフトする値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to subtract from <bpt i="0" x="0">&lt;c0&gt;</bpt>lhs<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>lhs<ept i="0">&lt;/c0&gt;</ept>から減じる値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to subtract from this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値から減じる値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to test.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>テストする値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to use as the initial accumulating value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>最初から蓄積されている値として使われる値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to use for the new instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいインスタンスのために使う値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to use in an integer-indexed collection (e.g. an int-keyed dictionary).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>整数インデックスのコレクション（例えば、intキー付き辞書）において使うための値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to use when dividing this value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値を除算するときに使うための値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value to yield from the continuation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その継続から生み出す値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value type for this key path.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このキーパスのための値型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value type of a dictionary literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書リテラルの値型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value types in the table below have the same functionality as their corresponding reference types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>下の表の値型は、それらの対応する参照型と同じ機能性を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value wrapped by this instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このインスタンスによってラップされる値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The value you pass as <bpt i="0" x="0">&lt;c0&gt;</bpt>end<ept i="0">&lt;/c0&gt;</ept> is not guaranteed to be included in the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>end<ept i="0">&lt;/c0&gt;</ept>として渡す値は、シーケンスに含まれることを保証されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The values passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>exponent<bpt i="1" x="1">&lt;w1&gt;</bpt>Bit<bpt i="2" x="2">&lt;w2&gt;</bpt>Pattern<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>significand<bpt i="4" x="4">&lt;w4&gt;</bpt>Bit<bpt i="5" x="5">&lt;w5&gt;</bpt>Pattern<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> are interpreted in the binary interchange format defined by the <bpt i="6" x="6">&lt;a6&gt;</bpt>IEEE 754 specification<ept i="6">&lt;/a6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>exponent<bpt i="1" x="1">&lt;w1&gt;</bpt>Bit<bpt i="2" x="2">&lt;w2&gt;</bpt>Pattern<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>significand<bpt i="4" x="4">&lt;w4&gt;</bpt>Bit<bpt i="5" x="5">&lt;w5&gt;</bpt>Pattern<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に渡される値は、<bpt i="6" x="6">&lt;a6&gt;</bpt>IEEE 754 specification<ept i="6">&lt;/a6&gt;</ept>で定義されるバイナリ交換フォーマットにおいて解釈されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The way these scalar values are grouped is defined by a canonical, localized, or otherwise tailored Unicode segmentation algorithm.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これらのスカラー値が一群にされる方法は、ある正準の、ローカライズされた、ないしは別の方法で仕立てられたユニコード分節アルゴリズムによって定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The work associated with yielding values to the AsyncStream.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>AsyncStreamへと生み出している値と結びつけられた仕事。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The zero value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ゼロ値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The “past the end” index of the resulting subsequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果のシーケンスの「終わりを過ぎた」インデックス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The “past the end” position—that is, the position one greater than the last valid subscript argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>「終わりを過ぎた」位置—すなわち、最後の有効な添え字引数より１つ大きい位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>There are some edge cases to be aware of:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>知られているいくつかの境界事例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>There are two categories of methods: those that return a single value, and those that return another <bpt i="3" x="3">&lt;c3&gt;</bpt>Async<bpt i="4" x="4">&lt;w4&gt;</bpt>Sequence<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つのカテゴリのメソッドがあります：ある単一の値を返すもの、そして別の<bpt i="3" x="3">&lt;c3&gt;</bpt>Async<bpt i="4" x="4">&lt;w4&gt;</bpt>Sequence<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>を返すもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>There may be smaller positive numbers, but they are <bpt i="0" x="0">&lt;e0&gt;</bpt>subnormal<ept i="0">&lt;/e0&gt;</ept>, meaning that they are represented with less precision than normal numbers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>より小さい正の数があるでしょう、しかしそれらは<bpt i="0" x="0">&lt;e0&gt;</bpt>サブノーマル<ept i="0">&lt;/e0&gt;</ept>であり、それらがノーマル数よりより少ない精密さで表現されることを意味しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Therefore, <bpt i="6" x="6">&lt;c6&gt;</bpt>x<bpt i="7" x="7">&lt;w7&gt;</bpt>.binade<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> is equal to <bpt i="8" x="8">&lt;c8&gt;</bpt>1<bpt i="9" x="9">&lt;w9&gt;</bpt>.0 * 2**4<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>, or <bpt i="10" x="10">&lt;c10&gt;</bpt>16<bpt i="11" x="11">&lt;w11&gt;</bpt>.0<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それゆえに、<bpt i="6" x="6">&lt;c6&gt;</bpt>x<bpt i="7" x="7">&lt;w7&gt;</bpt>.binade<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>は<bpt i="8" x="8">&lt;c8&gt;</bpt>1<bpt i="9" x="9">&lt;w9&gt;</bpt>.0 * 2**4<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>、または<bpt i="10" x="10">&lt;c10&gt;</bpt>16<bpt i="11" x="11">&lt;w11&gt;</bpt>.0<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Therefore, a <bpt i="0" x="0">&lt;c0&gt;</bpt>Closed<bpt i="1" x="1">&lt;w1&gt;</bpt>Range<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance cannot represent an empty range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それゆえに、<bpt i="0" x="0">&lt;c0&gt;</bpt>Closed<bpt i="1" x="1">&lt;w1&gt;</bpt>Range<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスは空の範囲として表すことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Therefore, you must only call this function from mutating methods with appropriate thread synchronization.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>したがって、あなたはこの関数を変更メソッドから適切なスレッド同期で呼ぶだけにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These accesses may be merged, eliminated, and rearranged with other work, and they may even be introduced when not strictly required.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これらのアクセスは、他の仕事によって合併、排除、そして再配列されるかもしれません、そしてそれらは厳密には必要とされない時に始められさえするかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These code points are combined by Unicode’s boundary algorithms into extended grapheme clusters.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これらのコード点は、ユニコードの境界アルゴリズムによって拡張書記素クラスタへと組み合わされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These counters can be used as indices only in instances of zero-based, integer-indexed collections, such as <bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Contiguous<bpt i="2" x="2">&lt;w2&gt;</bpt>Array<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これらのカウンタはインデックスとして使われることが、ゼロ基盤の、整数インデックスでのコレクション、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept>そして<bpt i="1" x="1">&lt;c1&gt;</bpt>Contiguous<bpt i="2" x="2">&lt;w2&gt;</bpt>Array<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>などのインスタンスにおいてのみ可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These initializers create an integer with the bit pattern of the memory address of a pointer or class instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これらのイニシャライザは、あるポインタまたはクラスインスタンスのメモリアドレスのビットパターンで整数を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These initializers result in <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> if the value passed can't be represented without any loss of precision.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これらのイニシャライザは、渡された値が何ら精度の損失なしに表現できないならば<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>という結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These initializers result in <bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept> if the value passed can’t be represented without any loss of precision.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これらのイニシャライザは、渡された値が何ら精度の損失なしに表現できないならば<bpt i="0" x="0">&lt;c0&gt;</bpt>nil<ept i="0">&lt;/c0&gt;</ept>という結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These methods return the result of an operation, and a flag indicating whether the operation overflowed the bounds of the type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これらのメソッドは演算の結果、そしてその演算がその型の境界をオーバーフローしたかどうかを示すフラグを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These properties are the same ones used to test for equality in the <bpt i="3" x="3">&lt;c3&gt;</bpt>==<ept i="3">&lt;/c3&gt;</ept> operator function.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これらプロパティは、<bpt i="3" x="3">&lt;c3&gt;</bpt>==<ept i="3">&lt;/c3&gt;</ept>演算子関数において同等性についてテストするために使われるのと同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These returned sequences don’t eagerly await the next member of the sequence, which allows the caller to decide when to start work.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それら返されるシーケンスは、そのシーケンスの次のメンバーを熱心には待ちません、それは呼び出し側にいつ仕事を開始するのか決定するのを許可します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These two operations impose a strict total order on the values of a type, in which exactly one of the following must be true for any two values <bpt i="2" x="2">&lt;c2&gt;</bpt>a<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>b<ept i="3">&lt;/c3&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これら２つの演算子は、ある型の値に全順序を課します、そこにおいて任意の２つの値<bpt i="2" x="2">&lt;c2&gt;</bpt>a<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>b<ept i="3">&lt;/c3&gt;</ept>に対して、厳密に以下のうちの１つが真でなければなりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These types and protocols drop their <bpt i="1" x="1">&lt;c1&gt;</bpt>NS<ept i="1">&lt;/c1&gt;</ept> prefix, with the following exceptions:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これら型およびプロトコルは、それらの<bpt i="1" x="1">&lt;c1&gt;</bpt>NS<ept i="1">&lt;/c1&gt;</ept>接頭辞を外します、以下の例外を除いては：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This <bpt i="0" x="0">&lt;e0&gt;</bpt>key-based<ept i="0">&lt;/e0&gt;</ept> subscript returns the value for the given key if the key is found in the dictionary, or <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> if the key is not found.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この<bpt i="0" x="0">&lt;e0&gt;</bpt>キー基盤<ept i="0">&lt;/e0&gt;</ept>の添え字は、そのキーが辞書において見つけられるならば指定されたキーに対する値を、またはキーが見つからないならば<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This associated type appears as a requirement in the <bpt i="0" x="0">&lt;c0&gt;</bpt>Sequence<ept i="0">&lt;/c0&gt;</ept> protocol, but it is restated here with stricter constraints.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この関連型は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Sequence<ept i="0">&lt;/c0&gt;</ept>プロトコルの中のある要件として現れます、しかしここでより厳格な制約で言い直されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This avoids over-allocation, but can result in insertion not having amortized constant-time performance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これは過度のアロケーションを防ぎます、しかし挿入においてならし定数時間性能を持たない結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This can be called more than once and returns to the caller immediately without blocking for any awaiting consumption from the iteration.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これは一回以上呼び出されることが可能です、そして呼び出し側にすぐに復帰します、その反復からの何らかの待ち受けている消費ために遮断することなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This can be called more than once and returns to the caller immediately without blocking for any awaiting consuption from the iteration.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これは一回以上呼び出されることが可能です、そして呼び出し側にすぐに復帰します、その反復からの何らかの待ち受けている消費ために遮断することなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This capability, as well as the ability to store values in a set or use them as keys in a dictionary, are governed by two related standard library protocols, <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> and <bpt i="2" x="2">&lt;a2&gt;</bpt><bpt i="3" x="3">&lt;c3&gt;</bpt>Hashable<ept i="3">&lt;/c3&gt;</ept><ept i="2">&lt;/a2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これができる力、それだけでなくいくらかの値を集合の中に格納するまたはそれらを辞書においてキーとして使う能力は、２つの関連する標準ライブラリプロトコル、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>と<bpt i="2" x="2">&lt;a2&gt;</bpt><bpt i="3" x="3">&lt;c3&gt;</bpt>Hashable<ept i="3">&lt;/c3&gt;</ept><ept i="2">&lt;/a2&gt;</ept>によって管理されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This chapter describes the global functions defined in the Swift standard library.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この章は、Swift標準ライブラリにおいて定義されるグローバル関数を記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This contrasts with <bpt i="2" x="2">&lt;c2&gt;</bpt>Array<ept i="2">&lt;/c2&gt;</ept>, which can store its elements in either a contiguous region of memory or an <bpt i="3" x="3">&lt;c3&gt;</bpt>NSArray<ept i="3">&lt;/c3&gt;</ept> instance if its <bpt i="4" x="4">&lt;c4&gt;</bpt>Element<ept i="4">&lt;/c4&gt;</ept> type is a class or <bpt i="5" x="5">&lt;c5&gt;</bpt>@objc<ept i="5">&lt;/c5&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これは<bpt i="2" x="2">&lt;c2&gt;</bpt>Array<ept i="2">&lt;/c2&gt;</ept>とは対照的です、それはそれの要素をメモリの隣接領域かもしくは、それの<bpt i="3" x="3">&lt;c3&gt;</bpt>Element<ept i="3">&lt;/c3&gt;</ept>型がクラスまたは<bpt i="4" x="4">&lt;c4&gt;</bpt>@objc<ept i="4">&lt;/c4&gt;</ept>プロトコルならば<bpt i="5" x="5">&lt;c5&gt;</bpt>NSArray<ept i="5">&lt;/c5&gt;</ept>インスタンスのどちらかに格納することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This differs from the operation cooperatively checking for cancellation and reacting to it in that the cancellation handler is <bpt i="0" x="0">&lt;e0&gt;</bpt>always<ept i="0">&lt;/e0&gt;</ept> and <bpt i="1" x="1">&lt;e1&gt;</bpt>immediately<ept i="1">&lt;/e1&gt;</ept> invoked when the task is canceled.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これは、協力して取り消しを調べるそしてそれに反応する演算とは異なります、タスクが取り消される時にある取り消しハンドラが<bpt i="0" x="0">&lt;e0&gt;</bpt>常に<ept i="0">&lt;/e0&gt;</ept>そして<bpt i="1" x="1">&lt;e1&gt;</bpt>直ぐに<ept i="1">&lt;/e1&gt;</ept>発動される点において。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Additive<bpt i="1" x="1">&lt;w1&gt;</bpt>Arithmetic<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Additive<bpt i="1" x="1">&lt;w1&gt;</bpt>Arithmetic<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Async<bpt i="1" x="1">&lt;w1&gt;</bpt>Iterator<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Async<bpt i="1" x="1">&lt;w1&gt;</bpt>Iterator<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Async<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Async<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Bidirectional<bpt i="1" x="1">&lt;w1&gt;</bpt>Collection<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Bidirectional<bpt i="1" x="1">&lt;w1&gt;</bpt>Collection<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Floating<bpt i="2" x="2">&lt;w2&gt;</bpt>Point<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Floating<bpt i="2" x="2">&lt;w2&gt;</bpt>Point<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Integer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Integer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Custom<bpt i="1" x="1">&lt;w1&gt;</bpt>Debug<bpt i="2" x="2">&lt;w2&gt;</bpt>String<bpt i="3" x="3">&lt;w3&gt;</bpt>Convertible<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Custom<bpt i="1" x="1">&lt;w1&gt;</bpt>Debug<bpt i="2" x="2">&lt;w2&gt;</bpt>String<bpt i="3" x="3">&lt;w3&gt;</bpt>Convertible<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Custom<bpt i="1" x="1">&lt;w1&gt;</bpt>Reflectable<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Custom<bpt i="1" x="1">&lt;w1&gt;</bpt>Reflectable<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Custom<bpt i="1" x="1">&lt;w1&gt;</bpt>String<bpt i="2" x="2">&lt;w2&gt;</bpt>Convertible<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Custom<bpt i="1" x="1">&lt;w1&gt;</bpt>String<bpt i="2" x="2">&lt;w2&gt;</bpt>Convertible<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Decodable<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Decodable<ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Encodable<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Encodable<ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>Array<bpt i="3" x="3">&lt;w3&gt;</bpt>Literal<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>Array<bpt i="3" x="3">&lt;w3&gt;</bpt>Literal<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>Boolean<bpt i="3" x="3">&lt;w3&gt;</bpt>Literal<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>Boolean<bpt i="3" x="3">&lt;w3&gt;</bpt>Literal<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>Extended<bpt i="3" x="3">&lt;w3&gt;</bpt>Grapheme<bpt i="4" x="4">&lt;w4&gt;</bpt>Cluster<bpt i="5" x="5">&lt;w5&gt;</bpt>Literal<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>Extended<bpt i="3" x="3">&lt;w3&gt;</bpt>Grapheme<bpt i="4" x="4">&lt;w4&gt;</bpt>Cluster<bpt i="5" x="5">&lt;w5&gt;</bpt>Literal<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>Float<bpt i="3" x="3">&lt;w3&gt;</bpt>Literal<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>Float<bpt i="3" x="3">&lt;w3&gt;</bpt>Literal<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>Integer<bpt i="3" x="3">&lt;w3&gt;</bpt>Literal<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>Integer<bpt i="3" x="3">&lt;w3&gt;</bpt>Literal<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>Unicode<bpt i="3" x="3">&lt;w3&gt;</bpt>Scalar<bpt i="4" x="4">&lt;w4&gt;</bpt>Literal<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>Unicode<bpt i="3" x="3">&lt;w3&gt;</bpt>Scalar<bpt i="4" x="4">&lt;w4&gt;</bpt>Literal<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Fixed<bpt i="1" x="1">&lt;w1&gt;</bpt>Width<bpt i="2" x="2">&lt;w2&gt;</bpt>Integer<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Fixed<bpt i="1" x="1">&lt;w1&gt;</bpt>Width<bpt i="2" x="2">&lt;w2&gt;</bpt>Integer<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Floating<bpt i="1" x="1">&lt;w1&gt;</bpt>Point<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Floating<bpt i="1" x="1">&lt;w1&gt;</bpt>Point<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Global<bpt i="1" x="1">&lt;w1&gt;</bpt>Actor<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Global<bpt i="1" x="1">&lt;w1&gt;</bpt>Actor<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Identifiable<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Identifiable<ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Iterator<bpt i="1" x="1">&lt;w1&gt;</bpt>Protocol<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Iterator<bpt i="1" x="1">&lt;w1&gt;</bpt>Protocol<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Mutable<bpt i="1" x="1">&lt;w1&gt;</bpt>Collection<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Mutable<bpt i="1" x="1">&lt;w1&gt;</bpt>Collection<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Numeric<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Numeric<ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Random<bpt i="1" x="1">&lt;w1&gt;</bpt>Access<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Range<bpt i="1" x="1">&lt;w1&gt;</bpt>Expression<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Range<bpt i="1" x="1">&lt;w1&gt;</bpt>Expression<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Representable<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Raw<bpt i="1" x="1">&lt;w1&gt;</bpt>Representable<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>SIMDStorage<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>SIMDStorage<ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Sequence<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Sequence<ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Strideable<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Strideable<ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>String<bpt i="1" x="1">&lt;w1&gt;</bpt>Interpolation<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>String<bpt i="1" x="1">&lt;w1&gt;</bpt>Interpolation<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Text<bpt i="1" x="1">&lt;w1&gt;</bpt>Output<bpt i="2" x="2">&lt;w2&gt;</bpt>Stream<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Text<bpt i="1" x="1">&lt;w1&gt;</bpt>Output<bpt i="2" x="2">&lt;w2&gt;</bpt>Stream<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation comment was inherited from <bpt i="0" x="0">&lt;c0&gt;</bpt>Text<bpt i="1" x="1">&lt;w1&gt;</bpt>Output<bpt i="2" x="2">&lt;w2&gt;</bpt>Streamable<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書化コメントは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Text<bpt i="1" x="1">&lt;w1&gt;</bpt>Output<bpt i="2" x="2">&lt;w2&gt;</bpt>Streamable<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>から引き継がれました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This documentation contains preliminary information about an API or technology in development.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この文書は、開発でのテクノロジーまたはAPIのための事前の情報を含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This enforces keeping the specified amount of newest values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これは、指定量の最新の値それらを保つことを強要します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This enforces keeping the specified amount of oldest values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これは、指定量の最古の値それらを保つことを強要します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This error is also thrown automatically by <bpt i="0" x="0">&lt;c0&gt;</bpt>Task<bpt i="1" x="1">&lt;w1&gt;</bpt>.check<bpt i="2" x="2">&lt;w2&gt;</bpt>Cancellation()<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, if the current task has been cancelled.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このエラーはまた自動的に<bpt i="0" x="0">&lt;c0&gt;</bpt>Task<bpt i="1" x="1">&lt;w1&gt;</bpt>.check<bpt i="2" x="2">&lt;w2&gt;</bpt>Cancellation()<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>によってスローされます、もし現在のタスクがキャンセルされたならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example appends the elements of a <bpt i="0" x="0">&lt;c0&gt;</bpt>Range&lt;Int&gt;<ept i="0">&lt;/c0&gt;</ept> instance to an array of integers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Range&lt;Int&gt;<ept i="0">&lt;/c0&gt;</ept>インスタンスの要素を整数からなる配列に加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example appends the elements of a <bpt i="1" x="1">&lt;c1&gt;</bpt>Range&lt;Int&gt;<ept i="1">&lt;/c1&gt;</ept> instance to an array of integers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>例えば、あなたはある<bpt i="1" x="1">&lt;c1&gt;</bpt>Range&lt;Int&gt;<ept i="1">&lt;/c1&gt;</ept>インスタンスに属する複数要素を整数の配列に追加することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example checks to see whether a favorite actor is in an array storing a movie’s cast.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、映画出演者を格納する配列の中にお気に入りの俳優がいるかどうか確認するために調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example creates a <bpt i="2" x="2">&lt;c2&gt;</bpt>Closed<bpt i="3" x="3">&lt;w3&gt;</bpt>Range&lt;Character&gt;<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> from “a” up to, and including, “z”.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、「a」から「z」までの、そしてそれを含む<bpt i="2" x="2">&lt;c2&gt;</bpt>Closed<bpt i="3" x="3">&lt;w3&gt;</bpt>Range&lt;Character&gt;<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example creates a <bpt i="2" x="2">&lt;c2&gt;</bpt>Partial<bpt i="3" x="3">&lt;w3&gt;</bpt>Range<bpt i="4" x="4">&lt;w4&gt;</bpt>From&lt;Double&gt;<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance that includes any value greater than or equal to <bpt i="5" x="5">&lt;c5&gt;</bpt>5<bpt i="6" x="6">&lt;w6&gt;</bpt>.0<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、<bpt i="2" x="2">&lt;c2&gt;</bpt>Partial<bpt i="3" x="3">&lt;w3&gt;</bpt>Range<bpt i="4" x="4">&lt;w4&gt;</bpt>From&lt;Double&gt;<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスで<bpt i="5" x="5">&lt;c5&gt;</bpt>5<bpt i="6" x="6">&lt;w6&gt;</bpt>.0<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>より大きいか等しい何らかの値を含むものを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example creates a <bpt i="2" x="2">&lt;c2&gt;</bpt>Partial<bpt i="3" x="3">&lt;w3&gt;</bpt>Range<bpt i="4" x="4">&lt;w4&gt;</bpt>Through&lt;Double&gt;<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance that includes any value less than or equal to <bpt i="5" x="5">&lt;c5&gt;</bpt>5<bpt i="6" x="6">&lt;w6&gt;</bpt>.0<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、<bpt i="2" x="2">&lt;c2&gt;</bpt>Partial<bpt i="3" x="3">&lt;w3&gt;</bpt>Range<bpt i="4" x="4">&lt;w4&gt;</bpt>Through&lt;Double&gt;<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスで<bpt i="5" x="5">&lt;c5&gt;</bpt>5<bpt i="6" x="6">&lt;w6&gt;</bpt>.0<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>より少ないか等しい何らかの値を含むものを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example creates a <bpt i="2" x="2">&lt;c2&gt;</bpt>Partial<bpt i="3" x="3">&lt;w3&gt;</bpt>Range<bpt i="4" x="4">&lt;w4&gt;</bpt>Up<bpt i="5" x="5">&lt;w5&gt;</bpt>To&lt;Double&gt;<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> instance that includes any value less than <bpt i="6" x="6">&lt;c6&gt;</bpt>5<bpt i="7" x="7">&lt;w7&gt;</bpt>.0<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、<bpt i="2" x="2">&lt;c2&gt;</bpt>Partial<bpt i="3" x="3">&lt;w3&gt;</bpt>Range<bpt i="4" x="4">&lt;w4&gt;</bpt>Up<bpt i="5" x="5">&lt;w5&gt;</bpt>To&lt;Double&gt;<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>インスタンスで<bpt i="6" x="6">&lt;c6&gt;</bpt>5<bpt i="7" x="7">&lt;w7&gt;</bpt>.0<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>より少ない何らかの値を含むものを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example creates a <bpt i="2" x="2">&lt;c2&gt;</bpt>Range&lt;Double&gt;<ept i="2">&lt;/c2&gt;</ept> from zero up to, but not including, 5.0.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、ゼロから5.0までの、しかしそれを含めない<bpt i="2" x="2">&lt;c2&gt;</bpt>Range&lt;Double&gt;<ept i="2">&lt;/c2&gt;</ept>を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example creates a key path from <bpt i="2" x="2">&lt;c2&gt;</bpt>Array&lt;Int&gt;<ept i="2">&lt;/c2&gt;</ept> to <bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>, and then tries appending compatible and incompatible key paths:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、<bpt i="2" x="2">&lt;c2&gt;</bpt>Array&lt;Int&gt;<ept i="2">&lt;/c2&gt;</ept>から<bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>へのキーパスを作成して、それから互換および非互換のキーパスをくっつけることを試みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example creates key paths from <bpt i="2" x="2">&lt;c2&gt;</bpt>Array&lt;Int&gt;<ept i="2">&lt;/c2&gt;</ept> to <bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept> and from <bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept> to <bpt i="5" x="5">&lt;c5&gt;</bpt>Int<ept i="5">&lt;/c5&gt;</ept>, and then tries appending each to the other:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、<bpt i="2" x="2">&lt;c2&gt;</bpt>Array&lt;Int&gt;<ept i="2">&lt;/c2&gt;</ept>から<bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>までの、そして<bpt i="4" x="4">&lt;c4&gt;</bpt>String<ept i="4">&lt;/c4&gt;</ept>から<bpt i="5" x="5">&lt;c5&gt;</bpt>Int<ept i="5">&lt;/c5&gt;</ept>までのキーパスを作成して、それからそれぞれを他とくっつけることを試みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example creates three new values in the range <bpt i="0" x="0">&lt;c0&gt;</bpt>1...100<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、３つの新しい値を範囲<bpt i="0" x="0">&lt;c0&gt;</bpt>1...100<ept i="0">&lt;/c0&gt;</ept>において作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example creates three new values in the range <bpt i="0" x="0">&lt;c0&gt;</bpt>1..&lt;100<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、３つの新しい値を範囲<bpt i="0" x="0">&lt;c0&gt;</bpt>1..&lt;100<ept i="0">&lt;/c0&gt;</ept>において作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example creates three new values in the range <bpt i="0" x="0">&lt;c0&gt;</bpt>10<bpt i="1" x="1">&lt;w1&gt;</bpt>.0 ... 20<bpt i="2" x="2">&lt;w2&gt;</bpt>.0<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、３つの新しい値を範囲<bpt i="0" x="0">&lt;c0&gt;</bpt>10<bpt i="1" x="1">&lt;w1&gt;</bpt>.0 ... 20<bpt i="2" x="2">&lt;w2&gt;</bpt>.0<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>において作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example creates three new values in the range <bpt i="0" x="0">&lt;c0&gt;</bpt>10<bpt i="1" x="1">&lt;w1&gt;</bpt>.0 ..&lt; 20<bpt i="2" x="2">&lt;w2&gt;</bpt>.0<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、３つの新しい値を範囲<bpt i="0" x="0">&lt;c0&gt;</bpt>10<bpt i="1" x="1">&lt;w1&gt;</bpt>.0 ..&lt; 20<bpt i="2" x="2">&lt;w2&gt;</bpt>.0<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>において作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example defines an <bpt i="0" x="0">&lt;c0&gt;</bpt>Integer<bpt i="1" x="1">&lt;w1&gt;</bpt>Ref<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type with an <bpt i="2" x="2">&lt;c2&gt;</bpt>@objc<ept i="2">&lt;/c2&gt;</ept> method named <bpt i="3" x="3">&lt;c3&gt;</bpt>get<bpt i="4" x="4">&lt;w4&gt;</bpt>Integer<bpt i="5" x="5">&lt;w5&gt;</bpt>Value()<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は<bpt i="0" x="0">&lt;c0&gt;</bpt>Integer<bpt i="1" x="1">&lt;w1&gt;</bpt>Ref<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型を、<bpt i="2" x="2">&lt;c2&gt;</bpt>@objc<ept i="2">&lt;/c2&gt;</ept>メソッドで<bpt i="3" x="3">&lt;c3&gt;</bpt>get<bpt i="4" x="4">&lt;w4&gt;</bpt>Integer<bpt i="5" x="5">&lt;w5&gt;</bpt>Value()<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>と名付けられるものと共に定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example defines some simple macros in a C header:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、いくつかの単純なマクロをCヘッダにおいて定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example demonstrates getting a slice of an array of strings, finding the index of one of the strings in the slice, and then using that index in the original array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は文字列からなる配列のあるスライスの取得を実演します、スライスの中の文字列の１つのインデックスを見つけて、それからそのインデックスを元の配列において使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example demonstrates that the <bpt i="0" x="0">&lt;c0&gt;</bpt>characters<ept i="0">&lt;/c0&gt;</ept> view of a string returns the same characters in the same order whether the view’s indices or the view itself is being iterated.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、ある文字列の<bpt i="0" x="0">&lt;c0&gt;</bpt>characters<ept i="0">&lt;/c0&gt;</ept>ビューが、そのビューのインデックスであろうとビューそれ自体が反復されていようと同じ文字を同じ順序で返すのを実演します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example enumerates the characters of the string “Swift” and prints each character along with its place in the string.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は文字列「Swift」の文字を列挙します、そして各文字をその文字列でのそれの場所とともに出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example finds the index of the last name that begins with the letter <bpt i="1" x="1">&lt;e1&gt;</bpt>A:<ept i="1">&lt;/e1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、文字<bpt i="1" x="1">&lt;e1&gt;</bpt>A:<ept i="1">&lt;/e1&gt;</ept>で始まる、最後の名前のインデックスを見つけます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example finds the largest value in an array of height measurements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、身長計測の配列の中で最も大きな値を見つけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example finds the smallest value in an array of height measurements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、身長計測の配列の中で最も小さな値を見つけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example iterates over the indices and elements of a set, building a list consisting of indices of names with five or fewer letters.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、ある集合のインデックスと要素のすべてにわたって反復します、５つまたはより少ない文字を持つ名前のインデックスから成るリストを作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example picks a name at random from an array:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、ある名前を無作為に配列から選出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example prints the characters of a string in reverse order:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、ある文字列に属する文字を逆順で出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example removes all the vowels from a string:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、全ての母音を文字列から除去します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example removes three elements from the middle of an array of measurements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、測定結果からなる配列の真ん中から３つの要素を削除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example searches <bpt i="0" x="0">&lt;c0&gt;</bpt>streets<bpt i="1" x="1">&lt;w1&gt;</bpt>Slice<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> for one of the strings in the slice, and then uses that index in the original array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>streets<bpt i="1" x="1">&lt;w1&gt;</bpt>Slice<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をスライスの中の文字列の１つについて検索して、それからそのインデックスを元々の配列において使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example shows how a <bpt i="8" x="8">&lt;c8&gt;</bpt>Collection<bpt i="9" x="9">&lt;w9&gt;</bpt>Of<bpt i="10" x="10">&lt;w10&gt;</bpt>Two<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> instance can be created holding the values of a point, and then iterated over using a <bpt i="11" x="11">&lt;c11&gt;</bpt>for<ept i="11">&lt;/c11&gt;</ept>-<bpt i="12" x="12">&lt;c12&gt;</bpt>in<ept i="12">&lt;/c12&gt;</ept> loop.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、どのように<bpt i="8" x="8">&lt;c8&gt;</bpt>Collection<bpt i="9" x="9">&lt;w9&gt;</bpt>Of<bpt i="10" x="10">&lt;w10&gt;</bpt>Two<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>インスタンスがある地点の値を保持して作成されるか、そしてそれから<bpt i="11" x="11">&lt;c11&gt;</bpt>for<ept i="11">&lt;/c11&gt;</ept>-<bpt i="12" x="12">&lt;c12&gt;</bpt>in<ept i="12">&lt;/c12&gt;</ept>ループを使って全体にわたって繰り返されるかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example shows how an array of <bpt i="0" x="0">&lt;c0&gt;</bpt>[Int]<ept i="0">&lt;/c0&gt;</ept> instances can be joined, using another <bpt i="1" x="1">&lt;c1&gt;</bpt>[Int]<ept i="1">&lt;/c1&gt;</ept> instance as the separator:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、どのようにいくつかの<bpt i="0" x="0">&lt;c0&gt;</bpt>[Int]<ept i="0">&lt;/c0&gt;</ept>インスタンスからなる配列が別の<bpt i="1" x="1">&lt;c1&gt;</bpt>[Int]<ept i="1">&lt;/c1&gt;</ept>インスタンスを分離子として使ってつなぎ合わされるかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example shows how an iterator can be used explicitly to emulate a <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> loop.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、イテレータが明示的に使われて<bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>ループの機能を真似る方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example shows how to build a dictionary of letter frequencies of a string.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、ある文字列の文字頻度の辞書を作り上げる方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example shows how to catch errors from a particular error domain and bring attention to unhandled errors from other error domains:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、特定のエラー領域からのエラーをキャッチする、そして他のエラー領域からの処理できないエラーへの注意をもたらす方法を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example shows how to choose the current or new values for any duplicate keys:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、あらゆる重複キーに対して現在および新規の値を選択する方法を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example shows how to find the sum of an array of numbers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、どのように数からなる配列の合計を見出すかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example shows how to throw errors using that custom error type in Swift:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、そのあつらえのエラー型をSwiftで使って、エラーをスローする方法を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example shows how to use the <bpt i="0" x="0">&lt;c0&gt;</bpt>max(by:)<ept i="0">&lt;/c0&gt;</ept> method on a dictionary to find the key-value pair with the highest value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>max(by:)<ept i="0">&lt;/c0&gt;</ept>メソッドを辞書上で使って、最も高い値を持つキー値ペアを見つける方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example shows how to use the <bpt i="0" x="0">&lt;c0&gt;</bpt>min(by:)<ept i="0">&lt;/c0&gt;</ept> method on a dictionary to find the key-value pair with the lowest value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>min(by:)<ept i="0">&lt;/c0&gt;</ept>メソッドを辞書上で使って、最も低い値を持つキー値ペアを見つける方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example shows how you can check an array for an expense greater than $100.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、どのようにあなたが$100より大きい出費についてある配列を調べるかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example shows how you can modify one of the names in an array of students.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例が示すのは、どうやってあなたが学生らの配列の中の名前の１つを修正できるかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example shows several extending conversions of a negative value—note that negative values are sign-extended even when converting to an unsigned type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、ある負の値のいくつかの拡張変換を示します — 符号なし型へ変換する時でさえ、負の値が符号拡張されることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example shows the behavior on a little-endian platform.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、リトルエンディアンプラットホーム上での挙動を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example shows two overlapping ranges:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は２つの重なった範囲を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example tests whether one countable range begins with the elements of another countable range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、ある可付番範囲が別の可付番範囲の要素で始まるかどうかテストします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example tests whether one countable range shares the same elements as another countable range and an array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、ある可付番範囲が同じ要素を別の可付番範囲とそしてある配列と共有するかどうかをテストします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example uses the <bpt i="0" x="0">&lt;c0&gt;</bpt>last(where:)<ept i="0">&lt;/c0&gt;</ept> method to find the last negative number in an array of integers:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、<bpt i="0" x="0">&lt;c0&gt;</bpt>last(where:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使って、整数の配列において最後の負数を見つけます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example uses the <bpt i="0" x="0">&lt;c0&gt;</bpt>lexicographically<bpt i="1" x="1">&lt;w1&gt;</bpt>Precedes<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method to test which array of integers comes first in a lexicographical ordering.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は<bpt i="0" x="0">&lt;c0&gt;</bpt>lexicographically<bpt i="1" x="1">&lt;w1&gt;</bpt>Precedes<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使って、どの整数配列がある語彙筆記的順序において最初に来るかをテストします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example uses the <bpt i="0" x="0">&lt;c0&gt;</bpt>negate()<ept i="0">&lt;/c0&gt;</ept> method to negate the value of the variable <bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は<bpt i="0" x="0">&lt;c0&gt;</bpt>negate()<ept i="0">&lt;/c0&gt;</ept>メソッドを使って、変数<bpt i="1" x="1">&lt;c1&gt;</bpt>x<ept i="1">&lt;/c1&gt;</ept>の値を負にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example uses the conditional downcast operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>as?<ept i="0">&lt;/c0&gt;</ept>) to conditionally cast the <bpt i="1" x="1">&lt;c1&gt;</bpt>s<ept i="1">&lt;/c1&gt;</ept> constant declared above to an instance of Swift’s <bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、条件ダウンキャスト演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>as?<ept i="0">&lt;/c0&gt;</ept>）を使って、上で定義される<bpt i="1" x="1">&lt;c1&gt;</bpt>s<ept i="1">&lt;/c1&gt;</ept>定数をSwiftの<bpt i="2" x="2">&lt;c2&gt;</bpt>String<ept i="2">&lt;/c2&gt;</ept>型へ条件付きでキャストします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example uses the subscript with a message to use in case an HTTP response code isn’t recognized:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例は、添え字を、HTTP応答コードが識別されない場合に使うあるメッセージとともに使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This exponential growth strategy means that appending an element happens in constant time, averaging the performance of many append operations.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この指数成長戦略は、ある要素を加えることは、多くの追加操作の遂行を平均すると、定数時間に起こることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This file is an Objective-C header that declares the Swift interfaces in your target, and you can think of it as an umbrella header for your Swift code.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このファイルは、Swiftインターフェイスをあなたのターゲットにおいて宣言するObjective-Cヘッダです、そしてあなたはそれをあなたのSwiftコードのためのアンブレラファイルとみなせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This function can be used to replace many cases that were previously handled using C-style <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept> loops.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この関数は、C形式の<bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>ループを使用して前もって取り扱われたケースの多くを置き換えるのに使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This function can be used to replace many instances of <bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Iterator<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> that wrap a closure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この関数は、クロージャをラップする<bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Iterator<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の多くのインスタンスを置き換えるのに使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This function does <bpt i="0" x="0">&lt;e0&gt;</bpt>not<ept i="0">&lt;/e0&gt;</ept> modify <bpt i="1" x="1">&lt;c1&gt;</bpt>object<ept i="1">&lt;/c1&gt;</ept>; the use of <bpt i="2" x="2">&lt;c2&gt;</bpt>inout<ept i="2">&lt;/c2&gt;</ept> is an implementation artifact.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この関数は<bpt i="1" x="1">&lt;c1&gt;</bpt>object<ept i="1">&lt;/c1&gt;</ept>を修正<bpt i="0" x="0">&lt;e0&gt;</bpt>しません<ept i="0">&lt;/e0&gt;</ept>；<bpt i="2" x="2">&lt;c2&gt;</bpt>inout<ept i="2">&lt;/c2&gt;</ept>の使用は、技巧上の実装です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This function does not infer element moves.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この関数は、要素が移動することを推測しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This function is the only requirement of the <bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この関数は、<bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept>プロトコルのただ１つの要件です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This function returns immediately and never suspends.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この関数は、直ぐに返ります、そして決して中断しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This function throws an error if any values are invalid for the given encoder’s format.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この関数は、与えられたエンコーダの形式に対して何らかの値が無効であるならばエラーをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This function trades safety for performance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この関数は性能と安全を交換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This function uses the least specific nonmatching property of the date to determine the result of the comparison.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この関数は、比較の結果を判定するのに、最小量となる特定の不一致日付プロパティを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This function’s effects vary depending on the build flag used:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この関数の効果は使用されるビルドフラグに依存して多様に異なります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This includes characters used both as letters and commonly in mathematical formulas.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これは、表音文字としてそして一般に数学公式においての両方で使われる表意文字を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This information is subject to change, and software implemented according to this documentation should be tested with final operating system software.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この情報は変更される場合があり、この文書に沿って実装されるソフトウェアは最終的なオペレーティングシステム・ソフトウェアでテストされなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This initializer does not perform any range or overflow checking.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザは、全く範囲またはオーバーフロー検査を実行しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This initializer implements the <bpt i="0" x="0">&lt;c0&gt;</bpt>scale<bpt i="1" x="1">&lt;w1&gt;</bpt>B<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> operation defined by the <bpt i="2" x="2">&lt;a2&gt;</bpt>IEEE 754 specification<ept i="2">&lt;/a2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザは、<bpt i="2" x="2">&lt;a2&gt;</bpt>IEEE 754仕様<ept i="2">&lt;/a2&gt;</ept>で定義される<bpt i="0" x="0">&lt;c0&gt;</bpt>scale<bpt i="1" x="1">&lt;w1&gt;</bpt>B<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>演算を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This initializer implements the IEEE 754 <bpt i="0" x="0">&lt;c0&gt;</bpt>copysign<ept i="0">&lt;/c0&gt;</ept> operation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザは、IEEE 754 <bpt i="0" x="0">&lt;c0&gt;</bpt>copysign<ept i="0">&lt;/c0&gt;</ept>演算を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This initializer is case sensitive.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザは、大文字小文字を区別します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This initializer is equivalent to <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>init(from:)<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザは、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>init(from:)<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>に等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This initializer is equivalent to <bpt i="5" x="5">&lt;a5&gt;</bpt><bpt i="6" x="6">&lt;c6&gt;</bpt>init(from:)<ept i="6">&lt;/c6&gt;</ept><ept i="5">&lt;/a5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザは、<bpt i="5" x="5">&lt;a5&gt;</bpt><bpt i="6" x="6">&lt;c6&gt;</bpt>init(from:)<ept i="6">&lt;/c6&gt;</ept><ept i="5">&lt;/a5&gt;</ept>に等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This initializer is equivalent to the following calculation, where <bpt i="0" x="0">&lt;c0&gt;</bpt>**<ept i="0">&lt;/c0&gt;</ept> is exponentiation, computed as if by a single, correctly rounded, floating-point operation:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザは次の計算に相当し、そこで<bpt i="0" x="0">&lt;c0&gt;</bpt>**<ept i="0">&lt;/c0&gt;</ept>は乗算で、まるで単精度の、正しく丸められた、浮動小数点演算のように計算されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This initializer throws an error if reading from the decoder fails, or if the data read is corrupted or otherwise invalid.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザは、デコーダからの読み出しが失敗するならば、または読み込んだデータが不正またはそうでなくとも無効ならば、エラーをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This initializer works with any type, and uses the custom <bpt i="1" x="1">&lt;c1&gt;</bpt>debug<bpt i="2" x="2">&lt;w2&gt;</bpt>Description<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> property for types that conform to <bpt i="3" x="3">&lt;c3&gt;</bpt>Custom<bpt i="4" x="4">&lt;w4&gt;</bpt>Debug<bpt i="5" x="5">&lt;w5&gt;</bpt>String<bpt i="6" x="6">&lt;w6&gt;</bpt>Convertible<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザはどんな型とでも働きます、そしてあつらえの<bpt i="1" x="1">&lt;c1&gt;</bpt>debug<bpt i="2" x="2">&lt;w2&gt;</bpt>Description<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>プロパティを<bpt i="3" x="3">&lt;c3&gt;</bpt>Custom<bpt i="4" x="4">&lt;w4&gt;</bpt>Debug<bpt i="5" x="5">&lt;w5&gt;</bpt>String<bpt i="6" x="6">&lt;w6&gt;</bpt>Convertible<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>に準拠する型に対して使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This initializer works with any type, and uses the custom <bpt i="1" x="1">&lt;c1&gt;</bpt>description<ept i="1">&lt;/c1&gt;</ept> property for types that conform to <bpt i="2" x="2">&lt;c2&gt;</bpt>Custom<bpt i="3" x="3">&lt;w3&gt;</bpt>String<bpt i="4" x="4">&lt;w4&gt;</bpt>Convertible<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザはどんな型とでも働きます、そしてあつらえの<bpt i="1" x="1">&lt;c1&gt;</bpt>description<ept i="1">&lt;/c1&gt;</ept>プロパティを<bpt i="2" x="2">&lt;c2&gt;</bpt>Custom<bpt i="3" x="3">&lt;w3&gt;</bpt>String<bpt i="4" x="4">&lt;w4&gt;</bpt>Convertible<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に準拠する型に対して使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is almost certainly not what you want.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これはほとんど疑いなくあなたが望むことではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is distinct from the Cocoa pattern—described above—that uses a trailing <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>NSError<ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/s3&gt;</ept> parameter to indicate recoverable errors that you plan for during development.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これは、— 上で記述される — Cocoaパターンとは別個のものです、それは後に続く<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>NSError<ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>パラメータを使って、あなたが開発の間に対策を立てる解決可能なエラーを指し示します、</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is equivalent to initializing with an empty array literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これは空の配列リテラルで初期化するのに等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is equivalent to the inverse of a set.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これはある集合の逆と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is inherently unsafe; UnsafeMutablePointer assumes the referenced memory has +1 strong ownership semantics, whereas AutoreleasingUnsafeMutablePointer implies +0 semantics.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これは、本質的に安全ではありません；UnsafeMutablePointerは参照されるメモリが+1の強力な所有権意味論を持つことを仮定します、そういうわけでAutoreleasingUnsafeMutablePointerは必然的に+0意味論です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is itended to be used to allow callback or delegation based APIs to participate with async/await.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これは、API基盤のコールバックまた委任が非同期／待機で参加するのを許可するために使われることを意図されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is the default implementation of the greater-than operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&gt;<ept i="0">&lt;/c0&gt;</ept>) for any type that conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>に準拠するあらゆる型に対して、より大きい演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&gt;<ept i="0">&lt;/c0&gt;</ept>）の初期状態の実装です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is the default implementation of the greater-than-or-equal-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&gt;=<ept i="0">&lt;/c0&gt;</ept>) for any type that conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>に準拠するあらゆる型に対して、より大きいか等しい演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&gt;=<ept i="0">&lt;/c0&gt;</ept>）の初期状態の実装です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is the default implementation of the less-than-or-equal-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;=<ept i="0">&lt;/c0&gt;</ept>) for any type that conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>に準拠するあらゆる型に対して、より少ないか等しい演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;=<ept i="0">&lt;/c0&gt;</ept>）の初期状態の実装です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is the default implementation of the not-equal-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>!=<ept i="0">&lt;/c0&gt;</ept>) for any type that conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>に準拠するあらゆる型に対して、不等演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>!=<ept i="0">&lt;/c0&gt;</ept>）の初期状態の実装です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is the unit of the least significant digit in this value’s significand.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これはこの値の仮数の中の最下位数の単位です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This iterator calls <bpt i="0" x="0">&lt;c0&gt;</bpt>next()<ept i="0">&lt;/c0&gt;</ept> on its base iterator and evaluates the result with the <bpt i="1" x="1">&lt;c1&gt;</bpt>predicate<ept i="1">&lt;/c1&gt;</ept> closure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイテレータは、<bpt i="0" x="0">&lt;c0&gt;</bpt>next()<ept i="0">&lt;/c0&gt;</ept>をそれの基底イテレータ上で呼び出します、そして結果を<bpt i="1" x="1">&lt;c1&gt;</bpt>predicate<ept i="1">&lt;/c1&gt;</ept>クロージャで評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This iterator calls <bpt i="0" x="0">&lt;c0&gt;</bpt>next()<ept i="0">&lt;/c0&gt;</ept> on its base iterator; if this call returns <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>next()<ept i="2">&lt;/c2&gt;</ept> returns <bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイテレータは、<bpt i="0" x="0">&lt;c0&gt;</bpt>next()<ept i="0">&lt;/c0&gt;</ept>をそれの基底イテレータ上で呼び出します；この呼び出しが<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>を返すならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>next()<ept i="2">&lt;/c2&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>nil<ept i="3">&lt;/c3&gt;</ept>を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This iterator calls <bpt i="0" x="0">&lt;c0&gt;</bpt>next()<ept i="0">&lt;/c0&gt;</ept> on its base iterator; if this call returns <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>, <bpt i="2" x="2">&lt;c2&gt;</bpt>next()<ept i="2">&lt;/c2&gt;</ept> returns nil.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイテレータは、<bpt i="0" x="0">&lt;c0&gt;</bpt>next()<ept i="0">&lt;/c0&gt;</ept>をそれの基底イテレータ上で呼び出します；この呼び出しが<bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>を返すならば、<bpt i="2" x="2">&lt;c2&gt;</bpt>next()<ept i="2">&lt;/c2&gt;</ept>はnilを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This iterator forwards its <bpt i="0" x="0">&lt;c0&gt;</bpt>next()<ept i="0">&lt;/c0&gt;</ept> method to an arbitrary underlying iterator having the same <bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept> type, hiding the specifics of the underlying <bpt i="2" x="2">&lt;c2&gt;</bpt>Iterator<bpt i="3" x="3">&lt;w3&gt;</bpt>Protocol<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイテレータは、それの<bpt i="0" x="0">&lt;c0&gt;</bpt>next()<ept i="0">&lt;/c0&gt;</ept>メソッドを同じ<bpt i="1" x="1">&lt;c1&gt;</bpt>Element<ept i="1">&lt;/c1&gt;</ept>型を持っている随意の基盤をなすイテレータに転送して、特定の基盤をなす<bpt i="2" x="2">&lt;c2&gt;</bpt>Iterator<bpt i="3" x="3">&lt;w3&gt;</bpt>Protocol<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を隠しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This magnitude calculation takes the following form for a floating-point value <bpt i="5" x="5">&lt;c5&gt;</bpt>x<ept i="5">&lt;/c5&gt;</ept> of type <bpt i="6" x="6">&lt;c6&gt;</bpt>F<ept i="6">&lt;/c6&gt;</ept>, where <bpt i="7" x="7">&lt;c7&gt;</bpt>**<ept i="7">&lt;/c7&gt;</ept> is exponentiation:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この規模計算は、型<bpt i="6" x="6">&lt;c6&gt;</bpt>F<ept i="6">&lt;/c6&gt;</ept>の浮動小数点値<bpt i="5" x="5">&lt;c5&gt;</bpt>x<ept i="5">&lt;/c5&gt;</ept>に対して以下の形式をとります、そこで<bpt i="7" x="7">&lt;c7&gt;</bpt>**<ept i="7">&lt;/c7&gt;</ept>は冪演算です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This makes creating mixed-language app and framework targets as straightforward as creating an app or framework target written in a single language.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これは、混合言語のアプリとフレームワーク・ターゲットを作成することを、単一の言語で書かれるアプリまたはフレームワーク・ターゲットをつくるのと同じくらいわかりやすいものにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This means that any cleanup state can be emitted accordingly in the cancellation handler</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これは、あらゆるクリーンアップ状態が取り消しハンドラの中でふさわしく発布されることが可能なことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This means that any cleanup state can be emitted accordingly in the cancellation handler.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これは、あらゆるクリーンアップ状態が取り消しハンドラの中でふさわしく発布されることが可能なことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This means that if an array is sharing storage with other copies, the first mutating operation on that array incurs the cost of copying the array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これが意味するのは、ある配列がストレージを他のコピーと共有するならば、その配列上での最初の変更操作は、配列をコピーするコストを招くということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This means that when two different class instances have the same value for each of their stored properties, they're still considered to be different by the identity operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>===<ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これは、２つの異なるクラスインスタンスが同じ値をそれらの格納プロパティの各々に対して持つ場合に、それらはまだ異なっていると同一性演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>===<ept i="0">&lt;/c0&gt;</ept>）によってみなされることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This means the outer <bpt i="10" x="10">&lt;c10&gt;</bpt>for await in<ept i="10">&lt;/c10&gt;</ept> loop iterates over <bpt i="11" x="11">&lt;c11&gt;</bpt>String<ept i="11">&lt;/c11&gt;</ept> instances instead of the underlying <bpt i="12" x="12">&lt;c12&gt;</bpt>Int<ept i="12">&lt;/c12&gt;</ept> values that <bpt i="13" x="13">&lt;c13&gt;</bpt>Counter<ept i="13">&lt;/c13&gt;</ept> produces.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これは、外側の<bpt i="10" x="10">&lt;c10&gt;</bpt>for await in<ept i="10">&lt;/c10&gt;</ept>ループが<bpt i="11" x="11">&lt;c11&gt;</bpt>String<ept i="11">&lt;/c11&gt;</ept>インスタンスそれらのすべてにわたって反復することを意味します、<bpt i="13" x="13">&lt;c13&gt;</bpt>Counter<ept i="13">&lt;/c13&gt;</ept>が生み出す基礎をなす<bpt i="12" x="12">&lt;c12&gt;</bpt>Int<ept i="12">&lt;/c12&gt;</ept>それらではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This means the outer <bpt i="10" x="10">&lt;c10&gt;</bpt>for await in<ept i="10">&lt;/c10&gt;</ept> loop iterates over <bpt i="11" x="11">&lt;c11&gt;</bpt>String<ept i="11">&lt;/c11&gt;</ept> instances instead of the underlying <bpt i="12" x="12">&lt;c12&gt;</bpt>Int<ept i="12">&lt;/c12&gt;</ept> values that <bpt i="13" x="13">&lt;c13&gt;</bpt>Counter<ept i="13">&lt;/c13&gt;</ept> produces:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これは、外側の<bpt i="10" x="10">&lt;c10&gt;</bpt>for await in<ept i="10">&lt;/c10&gt;</ept>ループが<bpt i="11" x="11">&lt;c11&gt;</bpt>String<ept i="11">&lt;/c11&gt;</ept>インスタンスそれらのすべてにわたって反復することを意味します、<bpt i="13" x="13">&lt;c13&gt;</bpt>Counter<ept i="13">&lt;/c13&gt;</ept>が生み出す基礎をなす<bpt i="12" x="12">&lt;c12&gt;</bpt>Int<ept i="12">&lt;/c12&gt;</ept>それらではなく：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method ensures that the array has unique, mutable, contiguous storage, with space allocated for at least the requested number of elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、配列が、少なくとも要請された数の要素に割り当てられた空間とともに、固有な、可変の、隣接するストレージを持つことを保証します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method ensures that the dictionary has unique, mutable, contiguous storage, with space allocated for at least the requested number of key-value pairs.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、辞書が、少なくとも要請された数のキー値ペアに割り当てられた空間とともに、固有な、可変の、隣接するストレージを持つことを保証します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method has the effect of removing the specified range of elements from the array and inserting the new elements at the same location.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、指定された範囲の要素を配列から取り除き、そして新しい要素を同じ場所に挿入する効果を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method has the effect of removing the specified range of elements from the collection and inserting the new elements at the same location.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、指定された範囲の要素をコレクションから取り除き、そして新しい要素を同じ場所に挿入する効果を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method implements the mathematical notion of lexicographical ordering, which has no connection to Unicode.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、語彙筆記的順序の数学的概念を実装します、それはユニコードに関係はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method implements the remainder operation defined by the <bpt i="4" x="4">&lt;a4&gt;</bpt>IEEE 754 specification<ept i="4">&lt;/a4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、<bpt i="4" x="4">&lt;a4&gt;</bpt>IEEE 754 仕様<ept i="4">&lt;/a4&gt;</ept>によって定義される剰余演算を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method is equivalent to calling <bpt i="0" x="0">&lt;c0&gt;</bpt>Bool<bpt i="1" x="1">&lt;w1&gt;</bpt>.random(using:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, passing in the system’s default random generator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Bool<bpt i="1" x="1">&lt;w1&gt;</bpt>.random(using:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を、システムの持つ省略時の無作為生成子を渡して呼び出すことに相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method is equivalent to calling <bpt i="0" x="0">&lt;c0&gt;</bpt>random(in:<bpt i="1" x="1">&lt;w1&gt;</bpt>using:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, passing in the system’s default random generator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、<bpt i="0" x="0">&lt;c0&gt;</bpt>random(in:<bpt i="1" x="1">&lt;w1&gt;</bpt>using:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を、システムの持つ省略時の無作為生成子を渡して呼び出すことに相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method is equivalent to calling <bpt i="0" x="0">&lt;c0&gt;</bpt>random<bpt i="1" x="1">&lt;w1&gt;</bpt>Element(using:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, passing in the system’s default random generator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、<bpt i="0" x="0">&lt;c0&gt;</bpt>random<bpt i="1" x="1">&lt;w1&gt;</bpt>Element(using:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を、システムの持つ省略時の無作為生成子を渡して呼び出すことに相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method is equivalent to calling <bpt i="0" x="0">&lt;c0&gt;</bpt>shuffle(using:)<ept i="0">&lt;/c0&gt;</ept>, passing in the system’s default random generator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、<bpt i="0" x="0">&lt;c0&gt;</bpt>shuffle(using:)<ept i="0">&lt;/c0&gt;</ept>を、システムの持つ省略時の無作為生成子を渡して呼び出すことに相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method is equivalent to calling <bpt i="0" x="0">&lt;c0&gt;</bpt>shuffled(using:)<ept i="0">&lt;/c0&gt;</ept>, passing in the system’s default random generator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、<bpt i="0" x="0">&lt;c0&gt;</bpt>shuffled(using:)<ept i="0">&lt;/c0&gt;</ept>を、システムの持つ省略時の無作為生成子を渡して呼び出すことに相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method is equivalent to calling the version that takes a generator, passing in the system’s default random generator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、ある生成子をとるバージョンを、システムの持つ省略時の無作為生成子を渡して呼び出すことに相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method is equivalent to the C <bpt i="0" x="0">&lt;c0&gt;</bpt>fma<ept i="0">&lt;/c0&gt;</ept> function and implements the <bpt i="1" x="1">&lt;c1&gt;</bpt>fused<bpt i="2" x="2">&lt;w2&gt;</bpt>Multiply<bpt i="3" x="3">&lt;w3&gt;</bpt>Add<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> operation defined by the <bpt i="4" x="4">&lt;a4&gt;</bpt>IEEE 754 specification<ept i="4">&lt;/a4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、C <bpt i="0" x="0">&lt;c0&gt;</bpt>fma<ept i="0">&lt;/c0&gt;</ept>関数の等価物です、そして<bpt i="1" x="1">&lt;c1&gt;</bpt>fused<bpt i="2" x="2">&lt;w2&gt;</bpt>Multiply<bpt i="3" x="3">&lt;w3&gt;</bpt>Add<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>演算を実装し、それは<bpt i="4" x="4">&lt;a4&gt;</bpt>IEEE 754仕様<ept i="4">&lt;/a4&gt;</ept>によって定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method is preferred over <bpt i="0" x="0">&lt;c0&gt;</bpt>reduce(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> for efficiency when the result is a copy-on-write type, for example an Array or a Dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、効率のために<bpt i="0" x="0">&lt;c0&gt;</bpt>reduce(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>より好まれます、その結果がコピーオンライト型である場合、例えばArrayまたは辞書に対しては。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method must not be called after a call to <bpt i="0" x="0">&lt;c0&gt;</bpt>container(keyed<bpt i="1" x="1">&lt;w1&gt;</bpt>By:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> or after encoding a value through a call to <bpt i="2" x="2">&lt;c2&gt;</bpt>single<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<bpt i="4" x="4">&lt;w4&gt;</bpt>Container()<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、<bpt i="0" x="0">&lt;c0&gt;</bpt>container(keyed<bpt i="1" x="1">&lt;w1&gt;</bpt>By:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>への呼び出しの後、または<bpt i="2" x="2">&lt;c2&gt;</bpt>single<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<bpt i="4" x="4">&lt;w4&gt;</bpt>Container()<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>への呼び出しを通して値をエンコードする後に呼び出されてはなりません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method must not be called after a call to <bpt i="0" x="0">&lt;c0&gt;</bpt>unkeyed<bpt i="1" x="1">&lt;w1&gt;</bpt>Container()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> or <bpt i="2" x="2">&lt;c2&gt;</bpt>container(keyed<bpt i="3" x="3">&lt;w3&gt;</bpt>By:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, or after encoding a value through a call to <bpt i="4" x="4">&lt;c4&gt;</bpt>single<bpt i="5" x="5">&lt;w5&gt;</bpt>Value<bpt i="6" x="6">&lt;w6&gt;</bpt>Container()<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、<bpt i="0" x="0">&lt;c0&gt;</bpt>unkeyed<bpt i="1" x="1">&lt;w1&gt;</bpt>Container()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>や<bpt i="2" x="2">&lt;c2&gt;</bpt>container(keyed<bpt i="3" x="3">&lt;w3&gt;</bpt>By:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>への呼び出しの後、または<bpt i="4" x="4">&lt;c4&gt;</bpt>single<bpt i="5" x="5">&lt;w5&gt;</bpt>Value<bpt i="6" x="6">&lt;w6&gt;</bpt>Container()<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>への呼び出しを通して値をエンコードする後に呼び出されてはなりません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method must not be called after a call to <bpt i="0" x="0">&lt;c0&gt;</bpt>unkeyed<bpt i="1" x="1">&lt;w1&gt;</bpt>Container()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> or after encoding a value through a call to <bpt i="2" x="2">&lt;c2&gt;</bpt>single<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<bpt i="4" x="4">&lt;w4&gt;</bpt>Container()<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、<bpt i="0" x="0">&lt;c0&gt;</bpt>unkeyed<bpt i="1" x="1">&lt;w1&gt;</bpt>Container()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>への呼び出しの後、または<bpt i="2" x="2">&lt;c2&gt;</bpt>single<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<bpt i="4" x="4">&lt;w4&gt;</bpt>Container()<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>への呼び出しを通して値をエンコードする後に呼び出されてはなりません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method returns <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept> with equal probability.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>を等しい確率で返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method returns the maximum of two values, preserving order and eliminating NaN when possible.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、２つの値のうち最大を返します、可能な場合は桁数の保全およびNaNの排除をします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method returns the minimum of two values, preserving order and eliminating NaN when possible.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、２つの値のうち最小を返します、可能な場合は桁数の保全およびNaNの排除をします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method returns the value with greater magnitude of the two given values, preserving order and eliminating NaN when possible.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、２つの与えられた値のうちより大きい規模を持つ値を返します、可能な場合は桁数の保全およびNaNの排除をします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method returns the value with lesser magnitude of the two given values, preserving order and eliminating NaN when possible.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、２つの与えられた値のうちより小さい規模を持つ値を返します、可能な場合は桁数の保全およびNaNの排除をします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method serves as the basis for the equal-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept>) for floating-point values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、浮動小数点値のための同等演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept>）の基盤としての機能を果たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method serves as the basis for the less-than operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;<ept i="0">&lt;/c0&gt;</ept>) for floating-point values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、浮動小数点値のためのより少ない演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;<ept i="0">&lt;/c0&gt;</ept>）の基盤としての機能を果たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This method serves as the basis for the less-than-or-equal-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;=<ept i="0">&lt;/c0&gt;</ept>) for floating-point values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドは、浮動小数点値のためのより少ないか等しい演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;=<ept i="0">&lt;/c0&gt;</ept>）の基盤としての機能を果たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This operator tests whether two instances have different identities, not different values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この演算子は、２つのインスタンスが異なる正体を持つ（異なる同一性を持つ）かどうかをテストします、異なる値をではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This operator tests whether two instances have the same identity, not the same value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この演算子は、２つのインスタンスが同じ正体を持つ（同一性を持つ）かどうかをテストします、同じ値をではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This operator uses short-circuit evaluation: <bpt i="0" x="0">&lt;c0&gt;</bpt>optional<ept i="0">&lt;/c0&gt;</ept> is checked first, and <bpt i="1" x="1">&lt;c1&gt;</bpt>default<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> is evaluated only if <bpt i="3" x="3">&lt;c3&gt;</bpt>optional<ept i="3">&lt;/c3&gt;</ept> is <bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この演算子は、短絡評価を使います：<bpt i="0" x="0">&lt;c0&gt;</bpt>optional<ept i="0">&lt;/c0&gt;</ept>が最初に調べられます、そして<bpt i="1" x="1">&lt;c1&gt;</bpt>default<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>optional<ept i="3">&lt;/c3&gt;</ept>が<bpt i="4" x="4">&lt;c4&gt;</bpt>nil<ept i="4">&lt;/c4&gt;</ept>である場合にのみ評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This operator uses short-circuit evaluation: The left-hand side (<bpt i="0" x="0">&lt;c0&gt;</bpt>lhs<ept i="0">&lt;/c0&gt;</ept>) is evaluated first, and the right-hand side (<bpt i="1" x="1">&lt;c1&gt;</bpt>rhs<ept i="1">&lt;/c1&gt;</ept>) is evaluated only if <bpt i="2" x="2">&lt;c2&gt;</bpt>lhs<ept i="2">&lt;/c2&gt;</ept> evaluates to <bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この演算子は、短絡評価を使います：左手側（<bpt i="0" x="0">&lt;c0&gt;</bpt>lhs<ept i="0">&lt;/c0&gt;</ept>）が最初に評価されます、そして右手側（<bpt i="1" x="1">&lt;c1&gt;</bpt>rhs<ept i="1">&lt;/c1&gt;</ept>）は<bpt i="2" x="2">&lt;c2&gt;</bpt>lhs<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>に評価する場合にのみ評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This operator uses short-circuit evaluation: The left-hand side (<bpt i="0" x="0">&lt;c0&gt;</bpt>lhs<ept i="0">&lt;/c0&gt;</ept>) is evaluated first, and the right-hand side (<bpt i="1" x="1">&lt;c1&gt;</bpt>rhs<ept i="1">&lt;/c1&gt;</ept>) is evaluated only if <bpt i="2" x="2">&lt;c2&gt;</bpt>lhs<ept i="2">&lt;/c2&gt;</ept> evaluates to <bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この演算子は、短絡評価を使います：左手側（<bpt i="0" x="0">&lt;c0&gt;</bpt>lhs<ept i="0">&lt;/c0&gt;</ept>）が最初に評価されます、そして右手側（<bpt i="1" x="1">&lt;c1&gt;</bpt>rhs<ept i="1">&lt;/c1&gt;</ept>）は<bpt i="2" x="2">&lt;c2&gt;</bpt>lhs<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept>に評価する場合にのみ評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This postcondition must hold even if the <bpt i="6" x="6">&lt;c6&gt;</bpt>initializer<ept i="6">&lt;/c6&gt;</ept> closure throws an error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この事後条件は、たとえ<bpt i="6" x="6">&lt;c6&gt;</bpt>initializer<ept i="6">&lt;/c6&gt;</ept>クロージャがエラーをスローするとしても保持されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This property corresponds to the “Math” property in the <bpt i="0" x="0">&lt;a0&gt;</bpt>Unicode Standard<ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このプロパティは、<bpt i="0" x="0">&lt;a0&gt;</bpt>ユニコード標準<ept i="0">&lt;/a0&gt;</ept>における “Math” に相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This property has the same value as the <bpt i="0" x="0">&lt;c0&gt;</bpt>description<ept i="0">&lt;/c0&gt;</ept> property, except that NaN values are printed in an extended format.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このプロパティは、<bpt i="0" x="0">&lt;c0&gt;</bpt>description<ept i="0">&lt;/c0&gt;</ept>プロパティと同じ値を持ちます、NaN値が拡張フォーマットにおいて出力されることを除いて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This property implements the <bpt i="0" x="0">&lt;c0&gt;</bpt>log<bpt i="1" x="1">&lt;w1&gt;</bpt>B<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> operation defined by the <bpt i="2" x="2">&lt;a2&gt;</bpt>IEEE 754 specification<ept i="2">&lt;/a2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このプロパティは、<bpt i="2" x="2">&lt;a2&gt;</bpt>IEEE 754仕様<ept i="2">&lt;/a2&gt;</ept>で定義される<bpt i="0" x="0">&lt;c0&gt;</bpt>log<bpt i="1" x="1">&lt;w1&gt;</bpt>B<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>演算を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This property is <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> for both quiet and signaling NaNs.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このプロパティは、クワイエットおよびシグナルNaNの両方に対して<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This property is <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> only for characters composed of scalars in the “Math_Symbol”, “Currency_Symbol”, “Modifier_Symbol”, or “Other_Symbol” categories in the <bpt i="1" x="1">&lt;a1&gt;</bpt>Unicode Standard<ept i="1">&lt;/a1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このプロパティが<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>であるのは、<bpt i="1" x="1">&lt;a1&gt;</bpt>Unicode Standard<ept i="1">&lt;/a1&gt;</ept>における “Math_Symbol”、“Currency_Symbol”、“Modifier_Symbol”、または“Other_Symbol” カテゴリの中のスカラーから構成される文字に対してのみです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This property is a constant for instances of fixed-width integer types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このプロパティは、固定長整数型のインスタンスのための定数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This property is a “past the end” index that does not correspond with any element of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このプロパティは「終わりを過ぎた」インデックスで、それはコレクションのどの要素にも対応しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This property is always <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> for signed integer types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このプロパティは、符号付き整数型に対して常に<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This property must always evaluate to the same executor for a given actor instance, and holding on to the actor must keep the executor alive.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このプロパティは、与えられたアクターインスタンスに対して常に同じエグゼキュータに評価されなければなりません、そしてアクターを手放さないことはエグゼキュータを存続させる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This property will be implicitly accessed when work needs to be scheduled onto this actor.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このプロパティは、仕事がこのアクター上に予定を組まれる必要がある時に、暗黙的にアクセスされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This relation is a refinement of the less-than-or-equal-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;=<ept i="0">&lt;/c0&gt;</ept>) that provides a total order on all values of the type, including signed zeros and NaNs.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この関係は、より少ないか等しい演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;=<ept i="0">&lt;/c0&gt;</ept>の改良版です、それは、符号付きゼロとNaNを含む、その型のすべての値に関する全順序を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This returns an instance of type <bpt i="8" x="8">&lt;c8&gt;</bpt>Async<bpt i="9" x="9">&lt;w9&gt;</bpt>Iterator<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これは、型<bpt i="8" x="8">&lt;c8&gt;</bpt>Async<bpt i="9" x="9">&lt;w9&gt;</bpt>Iterator<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>のあるインスタンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This rounding rule is also known as “bankers rounding,” and is the default IEEE 754 rounding mode for arithmetic.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この丸め規則はまた「銀行家の丸め」としても知られます、そして算術に対する省略時のIEEE 754丸め方式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This rounding rule is also known as “schoolbook rounding.” The following example shows the results of rounding numbers using this rule:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この丸め規則はまた「教科書丸め」としても知られます。以下の例は、この規則を使っての数の丸めの結果を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This rule implements the <bpt i="0" x="0">&lt;c0&gt;</bpt>round<bpt i="1" x="1">&lt;w1&gt;</bpt>To<bpt i="2" x="2">&lt;w2&gt;</bpt>Integral<bpt i="3" x="3">&lt;w3&gt;</bpt>Ties<bpt i="4" x="4">&lt;w4&gt;</bpt>To<bpt i="5" x="5">&lt;w5&gt;</bpt>Even<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> operation defined by the <bpt i="6" x="6">&lt;a6&gt;</bpt>IEEE 754 specification<ept i="6">&lt;/a6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この規則は、<bpt i="6" x="6">&lt;a6&gt;</bpt>IEEE 754仕様<ept i="6">&lt;/a6&gt;</ept>で定義される<bpt i="0" x="0">&lt;c0&gt;</bpt>round<bpt i="1" x="1">&lt;w1&gt;</bpt>To<bpt i="2" x="2">&lt;w2&gt;</bpt>Integral<bpt i="3" x="3">&lt;w3&gt;</bpt>Ties<bpt i="4" x="4">&lt;w4&gt;</bpt>To<bpt i="5" x="5">&lt;w5&gt;</bpt>Even<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>演算を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This rule is equivalent to the C <bpt i="0" x="0">&lt;c0&gt;</bpt>ceil<ept i="0">&lt;/c0&gt;</ept> function and implements the <bpt i="1" x="1">&lt;c1&gt;</bpt>round<bpt i="2" x="2">&lt;w2&gt;</bpt>To<bpt i="3" x="3">&lt;w3&gt;</bpt>Integral<bpt i="4" x="4">&lt;w4&gt;</bpt>Toward<bpt i="5" x="5">&lt;w5&gt;</bpt>Positive<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> operation defined by the <bpt i="6" x="6">&lt;a6&gt;</bpt>IEEE 754 specification<ept i="6">&lt;/a6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この規則は、C <bpt i="0" x="0">&lt;c0&gt;</bpt>ceil<ept i="0">&lt;/c0&gt;</ept>関数の等価物です、そして<bpt i="6" x="6">&lt;a6&gt;</bpt>IEEE 754仕様<ept i="6">&lt;/a6&gt;</ept>によって定義される<bpt i="1" x="1">&lt;c1&gt;</bpt>round<bpt i="2" x="2">&lt;w2&gt;</bpt>To<bpt i="3" x="3">&lt;w3&gt;</bpt>Integral<bpt i="4" x="4">&lt;w4&gt;</bpt>Toward<bpt i="5" x="5">&lt;w5&gt;</bpt>Positive<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>演算を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This rule is equivalent to the C <bpt i="0" x="0">&lt;c0&gt;</bpt>floor<ept i="0">&lt;/c0&gt;</ept> function and implements the <bpt i="1" x="1">&lt;c1&gt;</bpt>round<bpt i="2" x="2">&lt;w2&gt;</bpt>To<bpt i="3" x="3">&lt;w3&gt;</bpt>Integral<bpt i="4" x="4">&lt;w4&gt;</bpt>Toward<bpt i="5" x="5">&lt;w5&gt;</bpt>Negative<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> operation defined by the <bpt i="6" x="6">&lt;a6&gt;</bpt>IEEE 754 specification<ept i="6">&lt;/a6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この規則は、C <bpt i="0" x="0">&lt;c0&gt;</bpt>floor<ept i="0">&lt;/c0&gt;</ept>関数の等価物です、そして<bpt i="1" x="1">&lt;c1&gt;</bpt>round<bpt i="2" x="2">&lt;w2&gt;</bpt>To<bpt i="3" x="3">&lt;w3&gt;</bpt>Integral<bpt i="4" x="4">&lt;w4&gt;</bpt>Toward<bpt i="5" x="5">&lt;w5&gt;</bpt>Negative<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>演算を実装し、それは<bpt i="6" x="6">&lt;a6&gt;</bpt>IEEE 754仕様<ept i="6">&lt;/a6&gt;</ept>によって定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This rule is equivalent to the C <bpt i="0" x="0">&lt;c0&gt;</bpt>round<ept i="0">&lt;/c0&gt;</ept> function and implements the <bpt i="1" x="1">&lt;c1&gt;</bpt>round<bpt i="2" x="2">&lt;w2&gt;</bpt>To<bpt i="3" x="3">&lt;w3&gt;</bpt>Integral<bpt i="4" x="4">&lt;w4&gt;</bpt>Ties<bpt i="5" x="5">&lt;w5&gt;</bpt>To<bpt i="6" x="6">&lt;w6&gt;</bpt>Away<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> operation defined by the <bpt i="7" x="7">&lt;a7&gt;</bpt>IEEE 754 specification<ept i="7">&lt;/a7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この規則は、C <bpt i="0" x="0">&lt;c0&gt;</bpt>round<ept i="0">&lt;/c0&gt;</ept>関数の等価物です、そして<bpt i="7" x="7">&lt;a7&gt;</bpt>IEEE 754仕様<ept i="7">&lt;/a7&gt;</ept>によって定義される<bpt i="1" x="1">&lt;c1&gt;</bpt>round<bpt i="2" x="2">&lt;w2&gt;</bpt>To<bpt i="3" x="3">&lt;w3&gt;</bpt>Integral<bpt i="4" x="4">&lt;w4&gt;</bpt>Ties<bpt i="5" x="5">&lt;w5&gt;</bpt>To<bpt i="6" x="6">&lt;w6&gt;</bpt>Away<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>演算を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This rule is equivalent to the C <bpt i="0" x="0">&lt;c0&gt;</bpt>trunc<ept i="0">&lt;/c0&gt;</ept> function and implements the <bpt i="1" x="1">&lt;c1&gt;</bpt>round<bpt i="2" x="2">&lt;w2&gt;</bpt>To<bpt i="3" x="3">&lt;w3&gt;</bpt>Integral<bpt i="4" x="4">&lt;w4&gt;</bpt>Toward<bpt i="5" x="5">&lt;w5&gt;</bpt>Zero<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> operation defined by the <bpt i="6" x="6">&lt;a6&gt;</bpt>IEEE 754 specification<ept i="6">&lt;/a6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この規則は、C <bpt i="0" x="0">&lt;c0&gt;</bpt>trunc<ept i="0">&lt;/c0&gt;</ept>関数の等価物です、そして<bpt i="1" x="1">&lt;c1&gt;</bpt>round<bpt i="2" x="2">&lt;w2&gt;</bpt>To<bpt i="3" x="3">&lt;w3&gt;</bpt>Integral<bpt i="4" x="4">&lt;w4&gt;</bpt>Toward<bpt i="5" x="5">&lt;w5&gt;</bpt>Zero<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>演算を実装し、それは<bpt i="6" x="6">&lt;a6&gt;</bpt>IEEE 754仕様<ept i="6">&lt;/a6&gt;</ept>によって定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This subscript takes an index into the dictionary, instead of a key, and returns the corresponding key-value pair as a tuple.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この添え字は辞書に対してのインデックスをとります、キーではなく、そして該当するキー値ペアをタプルとして返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This type does not carry an owner pointer unlike the other C*Pointer types because it only needs to reference the results of inout conversions, which already have writeback-scoped lifetime.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型は、他のC*Pointer型と違って所有ポインタを持ち運びません、なぜならそれはただインアウト変換の結果を参照する必要があるだけだからです、そしてそれは既にライトバックスコープの寿命を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This type has implicit conversions to allow passing any of the following to a C or ObjC API:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型は暗黙的な変換を持ち、それによって以下のことをCまたはObjC APIへ渡すことを可能にされます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This type is specificially not Sendable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型は、はっきりとSendableではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This type must conform to <bpt i="4" x="4">&lt;c4&gt;</bpt>String<bpt i="5" x="5">&lt;w5&gt;</bpt>Interpolation<bpt i="6" x="6">&lt;w6&gt;</bpt>Protocol<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> and have a matching <bpt i="7" x="7">&lt;c7&gt;</bpt>String<bpt i="8" x="8">&lt;w8&gt;</bpt>Literal<bpt i="9" x="9">&lt;w9&gt;</bpt>Type<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この型は、<bpt i="4" x="4">&lt;c4&gt;</bpt>String<bpt i="5" x="5">&lt;w5&gt;</bpt>Interpolation<bpt i="6" x="6">&lt;w6&gt;</bpt>Protocol<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>に準拠する、そして適合する<bpt i="7" x="7">&lt;c7&gt;</bpt>String<bpt i="8" x="8">&lt;w8&gt;</bpt>Literal<bpt i="9" x="9">&lt;w9&gt;</bpt>Type<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>を持つ必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This unexpected result occurs because the call to <bpt i="0" x="0">&lt;c0&gt;</bpt>type(of: value)<ept i="0">&lt;/c0&gt;</ept> inside <bpt i="1" x="1">&lt;c1&gt;</bpt>print<bpt i="2" x="2">&lt;w2&gt;</bpt>Generic<bpt i="3" x="3">&lt;w3&gt;</bpt>Info(_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> must return a metatype that is an instance of <bpt i="4" x="4">&lt;c4&gt;</bpt>T<bpt i="5" x="5">&lt;w5&gt;</bpt>.Type<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, but <bpt i="6" x="6">&lt;c6&gt;</bpt>String<bpt i="7" x="7">&lt;w7&gt;</bpt>.self<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> (the expected dynamic type) is not an instance of <bpt i="8" x="8">&lt;c8&gt;</bpt>P<bpt i="9" x="9">&lt;w9&gt;</bpt>.Type<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> (the concrete metatype of <bpt i="10" x="10">&lt;c10&gt;</bpt>value<ept i="10">&lt;/c10&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この予期しない結果は、<bpt i="0" x="0">&lt;c0&gt;</bpt>type(of: value)<ept i="0">&lt;/c0&gt;</ept>への呼び出しが<bpt i="1" x="1">&lt;c1&gt;</bpt>print<bpt i="2" x="2">&lt;w2&gt;</bpt>Generic<bpt i="3" x="3">&lt;w3&gt;</bpt>Info(_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>内部において、<bpt i="4" x="4">&lt;c4&gt;</bpt>T<bpt i="5" x="5">&lt;w5&gt;</bpt>.Type<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>のインスタンスであるメタタイプを返さなければならない、しかし<bpt i="6" x="6">&lt;c6&gt;</bpt>String<bpt i="7" x="7">&lt;w7&gt;</bpt>.self<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>（期待された動的型）は<bpt i="8" x="8">&lt;c8&gt;</bpt>P<bpt i="9" x="9">&lt;w9&gt;</bpt>.Type<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>（<bpt i="10" x="10">&lt;c10&gt;</bpt>value<ept i="10">&lt;/c10&gt;</ept>の具象メタタイプ）のインスタンスでないことから起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This value compares greater than or equal to all finite numbers, but less than <bpt i="0" x="0">&lt;c0&gt;</bpt>infinity<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値は、すべての有限数、しかし<bpt i="0" x="0">&lt;c0&gt;</bpt>無限大<ept i="0">&lt;/c0&gt;</ept>より少ないものに対してより大きいか等しいと比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This value compares less than or equal to all positive normal numbers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値は、すべての正のノーマル数に対してより少ないか等しいと比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This value compares less than or equal to all positive numbers, but greater than zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値は、すべての正の数、しかしゼロより大きいものに対してより少ないか等しいと比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This value corresponds to type-specific C macros such as <bpt i="0" x="0">&lt;c0&gt;</bpt>FLT<bpt i="1" x="1">&lt;w1&gt;</bpt>_MAX<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>DBL<bpt i="3" x="3">&lt;w3&gt;</bpt>_MAX<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値は、型固有のCマクロ、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>FLT<bpt i="1" x="1">&lt;w1&gt;</bpt>_MAX<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>および<bpt i="2" x="2">&lt;c2&gt;</bpt>DBL<bpt i="3" x="3">&lt;w3&gt;</bpt>_MAX<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This value corresponds to type-specific C macros such as <bpt i="0" x="0">&lt;c0&gt;</bpt>FLT<bpt i="1" x="1">&lt;w1&gt;</bpt>_MIN<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>DBL<bpt i="3" x="3">&lt;w3&gt;</bpt>_MIN<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値は、型固有のCマクロ、例えば<bpt i="0" x="0">&lt;c0&gt;</bpt>FLT<bpt i="1" x="1">&lt;w1&gt;</bpt>_MIN<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>および<bpt i="2" x="2">&lt;c2&gt;</bpt>DBL<bpt i="3" x="3">&lt;w3&gt;</bpt>_MIN<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This value is unadjusted by the type’s exponent bias.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これは、この型のもつ指数バイアスによって未調整のものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This value should be rounded toward zero to keep user computations with angles from inadvertently ending up in the wrong quadrant.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この値は、角度を伴うユーザ計算がうっかりして間違った象限に終わらないようにゼロへと丸められるべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This will be the same as either <bpt i="0" x="0">&lt;c0&gt;</bpt>CSigned<bpt i="1" x="1">&lt;w1&gt;</bpt>Char<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> (in the common case) or <bpt i="2" x="2">&lt;c2&gt;</bpt>CUnsigned<bpt i="3" x="3">&lt;w3&gt;</bpt>Char<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, depending on the platform.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これは、プラットホーム次第で、<bpt i="0" x="0">&lt;c0&gt;</bpt>CSigned<bpt i="1" x="1">&lt;w1&gt;</bpt>Char<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>（一般的な場合）または<bpt i="2" x="2">&lt;c2&gt;</bpt>CUnsigned<bpt i="3" x="3">&lt;w3&gt;</bpt>Char<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>のどちらかに同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Throw Errors</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>エラーをスローする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Throw and Catch Errors from Custom Error Domains</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あつらえのエラー領域からエラーをスローおよびキャッチする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Throw and catch errors that use Cocoa's error types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Cocoaのエラー型を使うエラーをスローおよびキャッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Throwing an error in one of the tasks of a task group doesn’t immediately cancel the other tasks in that group.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるエラーをタスクグループのタスクそれらの１つにおいてスローすることは、直ぐにそのグループの中の他のタスクを取り消しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To access a slice of a collection using a range expression, use the collection’s generic subscript that uses a range expression as its parameter.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>範囲式を使ってコレクションのスライスにアクセスするには、そのコレクションの持つ総称体添え字で、範囲式をそれのパラメータとして使うものを使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To access the stride, use <bpt i="1" x="1">&lt;c1&gt;</bpt>Memory<bpt i="2" x="2">&lt;w2&gt;</bpt>Layout&lt;Pointee&gt;.stride<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ストライドにアクセスするには、<bpt i="1" x="1">&lt;c1&gt;</bpt>Memory<bpt i="2" x="2">&lt;w2&gt;</bpt>Layout&lt;Pointee&gt;.stride<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To access the stride, use <bpt i="2" x="2">&lt;c2&gt;</bpt>Memory<bpt i="3" x="3">&lt;w3&gt;</bpt>Layout&lt;Pointee&gt;.stride<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ストライドにアクセスするには、<bpt i="2" x="2">&lt;c2&gt;</bpt>Memory<bpt i="3" x="3">&lt;w3&gt;</bpt>Layout&lt;Pointee&gt;.stride<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To add <bpt i="0" x="0">&lt;c0&gt;</bpt>Additive<bpt i="1" x="1">&lt;w1&gt;</bpt>Arithmetic<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol conformance to your own custom type, implement the required operators, and provide a static <bpt i="2" x="2">&lt;c2&gt;</bpt>zero<ept i="2">&lt;/c2&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Additive<bpt i="1" x="1">&lt;w1&gt;</bpt>Arithmetic<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコル準拠をあなた自身のあつらえの型に加えるには、必要とされる演算子を実装してください、そしてある静的<bpt i="2" x="2">&lt;c2&gt;</bpt>zero<ept i="2">&lt;/c2&gt;</ept>プロパティを提供してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To add <bpt i="0" x="0">&lt;c0&gt;</bpt>Bidirectional<bpt i="1" x="1">&lt;w1&gt;</bpt>Protocol<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance to your custom types, implement the <bpt i="2" x="2">&lt;c2&gt;</bpt>index(before:)<ept i="2">&lt;/c2&gt;</ept> method in addition to the requirements of the <bpt i="3" x="3">&lt;c3&gt;</bpt>Collection<ept i="3">&lt;/c3&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Bidirectional<bpt i="1" x="1">&lt;w1&gt;</bpt>Protocol<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠をあなたのあつらえの型に加えるには、<bpt i="2" x="2">&lt;c2&gt;</bpt>index(before:)<ept i="2">&lt;/c2&gt;</ept>メソッドを、<bpt i="3" x="3">&lt;c3&gt;</bpt>Collection<ept i="3">&lt;/c3&gt;</ept>プロトコルの要件に加えて実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To add <bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept> conformance to <bpt i="1" x="1">&lt;c1&gt;</bpt>Date<ept i="1">&lt;/c1&gt;</ept>, first declare conformance to <bpt i="2" x="2">&lt;c2&gt;</bpt>Comparable<ept i="2">&lt;/c2&gt;</ept> and implement the <bpt i="3" x="3">&lt;c3&gt;</bpt>&lt;<ept i="3">&lt;/c3&gt;</ept> operator function.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept>準拠を<bpt i="1" x="1">&lt;c1&gt;</bpt>Date<ept i="1">&lt;/c1&gt;</ept>に加えるには、最初に<bpt i="2" x="2">&lt;c2&gt;</bpt>Comparable<ept i="2">&lt;/c2&gt;</ept>への準拠を宣言して、<bpt i="3" x="3">&lt;c3&gt;</bpt>&lt;<ept i="3">&lt;/c3&gt;</ept>演算子関数を実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To add <bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept> conformance to your custom types, define the <bpt i="1" x="1">&lt;c1&gt;</bpt>&lt;<ept i="1">&lt;/c1&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>==<ept i="2">&lt;/c2&gt;</ept> operators as static methods of your types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept>準拠をあなたのあつらえの型に加えるには、<bpt i="1" x="1">&lt;c1&gt;</bpt>&lt;<ept i="1">&lt;/c1&gt;</ept>および<bpt i="2" x="2">&lt;c2&gt;</bpt>==<ept i="2">&lt;/c2&gt;</ept>演算子をあなたの型の静的メソッドとして定義してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To add <bpt i="0" x="0">&lt;c0&gt;</bpt>Custom<bpt i="1" x="1">&lt;w1&gt;</bpt>Playground<bpt i="2" x="2">&lt;w2&gt;</bpt>Display<bpt i="3" x="3">&lt;w3&gt;</bpt>Convertible<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance to your custom type, implement the <bpt i="4" x="4">&lt;c4&gt;</bpt>playground<bpt i="5" x="5">&lt;w5&gt;</bpt>Description<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Custom<bpt i="1" x="1">&lt;w1&gt;</bpt>Playground<bpt i="2" x="2">&lt;w2&gt;</bpt>Display<bpt i="3" x="3">&lt;w3&gt;</bpt>Convertible<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠をあなたのあつらえの型に加えるには、<bpt i="4" x="4">&lt;c4&gt;</bpt>playground<bpt i="5" x="5">&lt;w5&gt;</bpt>Description<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>プロパティを実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To add <bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>Boolean<bpt i="3" x="3">&lt;w3&gt;</bpt>Literal<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance to your custom type, implement the <bpt i="4" x="4">&lt;c4&gt;</bpt>init(boolean<bpt i="5" x="5">&lt;w5&gt;</bpt>Literal:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> initializer that creates an instance of your type with the given Boolean value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>Boolean<bpt i="3" x="3">&lt;w3&gt;</bpt>Literal<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠をあなたのあつらえの型に加えるには<bpt i="4" x="4">&lt;c4&gt;</bpt>init(boolean<bpt i="5" x="5">&lt;w5&gt;</bpt>Literal:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>イニシャライザを加えてください、それはあなたの型のインスタンスを、与えられたブール値とともに作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To add <bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>Extended<bpt i="3" x="3">&lt;w3&gt;</bpt>Grapheme<bpt i="4" x="4">&lt;w4&gt;</bpt>Cluster<bpt i="5" x="5">&lt;w5&gt;</bpt>Literal<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance to your custom type, implement the required initializer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>Extended<bpt i="3" x="3">&lt;w3&gt;</bpt>Grapheme<bpt i="4" x="4">&lt;w4&gt;</bpt>Cluster<bpt i="5" x="5">&lt;w5&gt;</bpt>Literal<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠をあなたのあつらえの型に加えるには、必須イニシャライザを実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To add <bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>Float<bpt i="3" x="3">&lt;w3&gt;</bpt>Literal<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance to your custom type, implement the required initializer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>Float<bpt i="3" x="3">&lt;w3&gt;</bpt>Literal<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠をあなたのあつらえの型に加えるには、必須イニシャライザを実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To add <bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>Integer<bpt i="3" x="3">&lt;w3&gt;</bpt>Literal<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance to your custom type, implement the required initializer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>Integer<bpt i="3" x="3">&lt;w3&gt;</bpt>Literal<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠をあなたのあつらえの型に加えるには、必須イニシャライザを実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To add <bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>String<bpt i="3" x="3">&lt;w3&gt;</bpt>Literal<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance to your custom type, implement the required initializer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>String<bpt i="3" x="3">&lt;w3&gt;</bpt>Literal<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠をあなたのあつらえの型に加えるには、必須イニシャライザを実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To add <bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>Unicode<bpt i="3" x="3">&lt;w3&gt;</bpt>Scalar<bpt i="4" x="4">&lt;w4&gt;</bpt>Literal<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance to your custom type, implement the required initializer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>Unicode<bpt i="3" x="3">&lt;w3&gt;</bpt>Scalar<bpt i="4" x="4">&lt;w4&gt;</bpt>Literal<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠をあなたのあつらえの型に加えるには、必須イニシャライザを実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To add <bpt i="1" x="1">&lt;c1&gt;</bpt>Collection<ept i="1">&lt;/c1&gt;</ept> conformance to your type, you must declare at least the following requirements:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>Collection<ept i="1">&lt;/c1&gt;</ept>準拠をあなたの型に加えるには、あなたは少なくとも以下の要件を宣言しなければなりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To add <bpt i="2" x="2">&lt;c2&gt;</bpt>Hashable<ept i="2">&lt;/c2&gt;</ept> conformance, provide an <bpt i="3" x="3">&lt;c3&gt;</bpt>==<ept i="3">&lt;/c3&gt;</ept> operator function and implement the <bpt i="4" x="4">&lt;c4&gt;</bpt>hash(into:)<ept i="4">&lt;/c4&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Hashable<ept i="2">&lt;/c2&gt;</ept>準拠を加えるには、<bpt i="3" x="3">&lt;c3&gt;</bpt>==<ept i="3">&lt;/c3&gt;</ept>演算子関数を提供して、<bpt i="4" x="4">&lt;c4&gt;</bpt>hash(into:)<ept i="4">&lt;/c4&gt;</ept>メソッドを実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To add a new key-value pair, assign a value to a key that isn’t yet a part of the dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しいキー値ペアを加えるには、ある値を、まだ辞書の一部ではないキーに対して割り当ててください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To add single elements to the end of an array, use the <bpt i="0" x="0">&lt;c0&gt;</bpt>append(_:)<ept i="0">&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>単一の要素を配列に加えるには、<bpt i="0" x="0">&lt;c0&gt;</bpt>append(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To add the capability to be initialized with a dictionary literal to your own custom types, declare an <bpt i="0" x="0">&lt;c0&gt;</bpt>init(dictionary<bpt i="1" x="1">&lt;w1&gt;</bpt>Literal:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initializer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書リテラルで初期化される能力をあなた独自のあつらえの型に加えるには、<bpt i="0" x="0">&lt;c0&gt;</bpt>init(dictionary<bpt i="1" x="1">&lt;w1&gt;</bpt>Literal:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>イニシャライザを宣言してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To add values of different types, convert one of the values to the other value’s type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>異なる型の値を加算するには、それらの値の一方を、他方の値の型へと変換してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To avoid the unexpected copy, use the <bpt i="1" x="1">&lt;c1&gt;</bpt>index(after:)<ept i="1">&lt;/c1&gt;</ept> method starting with <bpt i="2" x="2">&lt;c2&gt;</bpt>start<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> to produce indices instead.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>予期されないコピーを避けるために、代わりに<bpt i="1" x="1">&lt;c1&gt;</bpt>index(after:)<ept i="1">&lt;/c1&gt;</ept>メソッドを使って<bpt i="2" x="2">&lt;c2&gt;</bpt>start<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>で始めることで、インデックスを生成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To avoid this behavior, swap the call <bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Known<bpt i="2" x="2">&lt;w2&gt;</bpt>Uniquely<bpt i="3" x="3">&lt;w3&gt;</bpt>Referenced(_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to the left-hand side or store the result of the first expression in a local constant:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この挙動を防ぐために、左手側への呼び出し<bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Known<bpt i="2" x="2">&lt;w2&gt;</bpt>Uniquely<bpt i="3" x="3">&lt;w3&gt;</bpt>Referenced(_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を交換するか、最初の式の結果をローカル定数の中に格納してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To avoid this, use a forward declaration of the Swift class or protocol to reference it in an Objective-C interface.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これを防ぐために、Swiftクラスまたはプロトコルの前方宣言を使うことで、それをObjective-Cインターフェイスにおいて参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To check for invalid usage in Release builds, see <bpt i="0" x="0">&lt;c0&gt;</bpt>precondition(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>_:<bpt i="2" x="2">&lt;w2&gt;</bpt>file:<bpt i="3" x="3">&lt;w3&gt;</bpt>line:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>「リリース」ビルドにおける無効な使用法を調べるには、<bpt i="0" x="0">&lt;c0&gt;</bpt>precondition(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>_:<bpt i="2" x="2">&lt;w2&gt;</bpt>file:<bpt i="3" x="3">&lt;w3&gt;</bpt>line:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To check whether a collection is empty, use its <bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Empty<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property instead of comparing <bpt i="2" x="2">&lt;c2&gt;</bpt>count<ept i="2">&lt;/c2&gt;</ept> to zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるコレクションが空かどうか調べるには、それの<bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Empty<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティを使ってください、<bpt i="2" x="2">&lt;c2&gt;</bpt>count<ept i="2">&lt;/c2&gt;</ept>をゼロと比較するのでなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To collect the results of tasks that were added to the group, you can use the following pattern:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>グループに追加されたいくつかのタスクの結果それらを収集するには、あなたは以下の手本を使用できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To conform to <bpt i="3" x="3">&lt;c3&gt;</bpt>Hashable<ept i="3">&lt;/c3&gt;</ept>, implement the <bpt i="4" x="4">&lt;c4&gt;</bpt>hash(into:)<ept i="4">&lt;/c4&gt;</ept> requirement instead.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>Hashable<ept i="3">&lt;/c3&gt;</ept>に準拠するには、<bpt i="4" x="4">&lt;c4&gt;</bpt>hash(into:)<ept i="4">&lt;/c4&gt;</ept>要件を代わりに実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To create a continuation in asynchronous code, call the <bpt i="1" x="1">&lt;c1&gt;</bpt>with<bpt i="2" x="2">&lt;w2&gt;</bpt>Unsafe<bpt i="3" x="3">&lt;w3&gt;</bpt>Continuation(function:<bpt i="4" x="4">&lt;w4&gt;</bpt>_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> or <bpt i="5" x="5">&lt;c5&gt;</bpt>with<bpt i="6" x="6">&lt;w6&gt;</bpt>Unsafe<bpt i="7" x="7">&lt;w7&gt;</bpt>Throwing<bpt i="8" x="8">&lt;w8&gt;</bpt>Continuation(function:<bpt i="9" x="9">&lt;w9&gt;</bpt>_:)<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある継続を非同期コードにおいて作成するには、<bpt i="1" x="1">&lt;c1&gt;</bpt>with<bpt i="2" x="2">&lt;w2&gt;</bpt>Unsafe<bpt i="3" x="3">&lt;w3&gt;</bpt>Continuation(function:<bpt i="4" x="4">&lt;w4&gt;</bpt>_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>または<bpt i="5" x="5">&lt;c5&gt;</bpt>with<bpt i="6" x="6">&lt;w6&gt;</bpt>Unsafe<bpt i="7" x="7">&lt;w7&gt;</bpt>Throwing<bpt i="8" x="8">&lt;w8&gt;</bpt>Continuation(function:<bpt i="9" x="9">&lt;w9&gt;</bpt>_:)<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>関数を呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To create a dictionary with no key-value pairs, use an empty dictionary literal (<bpt i="0" x="0">&lt;c0&gt;</bpt>[:]<ept i="0">&lt;/c0&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キー値ペアを持たない辞書を作成するには、空の辞書リテラル（<bpt i="0" x="0">&lt;c0&gt;</bpt>[:]<ept i="0">&lt;/c0&gt;</ept>）を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To create a new type that supports string literals and interpolation, but that doesn’t need any custom behavior, conform the type to <bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>String<bpt i="3" x="3">&lt;w3&gt;</bpt>Interpolation<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and implement the <bpt i="4" x="4">&lt;c4&gt;</bpt>init(string<bpt i="5" x="5">&lt;w5&gt;</bpt>Literal: String)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> initializer declared by the <bpt i="6" x="6">&lt;c6&gt;</bpt>Expressible<bpt i="7" x="7">&lt;w7&gt;</bpt>By<bpt i="8" x="8">&lt;w8&gt;</bpt>String<bpt i="9" x="9">&lt;w9&gt;</bpt>Literal<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>文字列リテラルと補間をサポートする、しかし何らかのあつらえの挙動を必要としない新しい型を作成するには、その型を<bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>String<bpt i="3" x="3">&lt;w3&gt;</bpt>Interpolation<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠させて、そして<bpt i="6" x="6">&lt;c6&gt;</bpt>Expressible<bpt i="7" x="7">&lt;w7&gt;</bpt>By<bpt i="8" x="8">&lt;w8&gt;</bpt>String<bpt i="9" x="9">&lt;w9&gt;</bpt>Literal<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>プロトコルによって宣言される<bpt i="4" x="4">&lt;c4&gt;</bpt>init(string<bpt i="5" x="5">&lt;w5&gt;</bpt>Literal: String)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>イニシャライザを実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To create a wrapper for the <bpt i="0" x="0">&lt;c0&gt;</bpt>c<bpt i="1" x="1">&lt;w1&gt;</bpt>_api<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function, write a function that takes <bpt i="2" x="2">&lt;c2&gt;</bpt>CVar<bpt i="3" x="3">&lt;w3&gt;</bpt>Arg<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> arguments, and then call the imported C function using the <bpt i="4" x="4">&lt;c4&gt;</bpt>with<bpt i="5" x="5">&lt;w5&gt;</bpt>Va<bpt i="6" x="6">&lt;w6&gt;</bpt>List(_:<bpt i="7" x="7">&lt;w7&gt;</bpt>_:)<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> function:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>c<bpt i="1" x="1">&lt;w1&gt;</bpt>_api<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数に対するラッパーを作成するには、<bpt i="2" x="2">&lt;c2&gt;</bpt>CVar<bpt i="3" x="3">&lt;w3&gt;</bpt>Arg<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>引数をとる関数を書いて、それからインポートされたC関数を<bpt i="4" x="4">&lt;c4&gt;</bpt>with<bpt i="5" x="5">&lt;w5&gt;</bpt>Va<bpt i="6" x="6">&lt;w6&gt;</bpt>List(_:<bpt i="7" x="7">&lt;w7&gt;</bpt>_:)<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>関数を使って呼び出してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To create an instance of <bpt i="0" x="0">&lt;c0&gt;</bpt>Enumerated<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, call <bpt i="2" x="2">&lt;c2&gt;</bpt>enumerated()<ept i="2">&lt;/c2&gt;</ept> on a sequence or collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Enumerated<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>のインスタンスを作成するには、<bpt i="2" x="2">&lt;c2&gt;</bpt>enumerated()<ept i="2">&lt;/c2&gt;</ept>をシーケンスまたはコレクション上で呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To create an instance, call <bpt i="0" x="0">&lt;c0&gt;</bpt>enumerated().make<bpt i="1" x="1">&lt;w1&gt;</bpt>Iterator()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> on a sequence or collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インスタンスを作成するには、<bpt i="0" x="0">&lt;c0&gt;</bpt>enumerated().make<bpt i="1" x="1">&lt;w1&gt;</bpt>Iterator()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をシーケンスまたはコレクション上で呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To customize that representation, make your type conform to the <bpt i="3" x="3">&lt;c3&gt;</bpt>Custom<bpt i="4" x="4">&lt;w4&gt;</bpt>Debug<bpt i="5" x="5">&lt;w5&gt;</bpt>String<bpt i="6" x="6">&lt;w6&gt;</bpt>Convertible<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この表現をカスタマイズするには、あなたの型を<bpt i="3" x="3">&lt;c3&gt;</bpt>Custom<bpt i="4" x="4">&lt;w4&gt;</bpt>Debug<bpt i="5" x="5">&lt;w5&gt;</bpt>String<bpt i="6" x="6">&lt;w6&gt;</bpt>Convertible<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>プロトコルに準拠させてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To customize your type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept> conformance, to adopt <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept> in a type that doesn’t meet the criteria listed above, or to extend an existing type to conform to <bpt i="2" x="2">&lt;c2&gt;</bpt>Equatable<ept i="2">&lt;/c2&gt;</ept>, implement the equal-to operator (<bpt i="3" x="3">&lt;c3&gt;</bpt>==<ept i="3">&lt;/c3&gt;</ept>) as a static method of your type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたの型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Equatableable<ept i="0">&lt;/c0&gt;</ept>準拠をカスタマイズするため、<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>を上でリストされる基準に沿わない型において採用するため、または既存の型を拡張して<bpt i="2" x="2">&lt;c2&gt;</bpt>Equatable<ept i="2">&lt;/c2&gt;</ept>に準拠するためには、同等演算子（<bpt i="3" x="3">&lt;c3&gt;</bpt>==<ept i="3">&lt;/c3&gt;</ept>）をあなたの型の静的メソッドとして実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To customize your type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept> conformance, to adopt <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept> in a type that doesn’t meet the criteria listed above, or to extend an existing type to conform to <bpt i="2" x="2">&lt;c2&gt;</bpt>Hashable<ept i="2">&lt;/c2&gt;</ept>, implement the <bpt i="3" x="3">&lt;c3&gt;</bpt>hash(into:)<ept i="3">&lt;/c3&gt;</ept> method in your custom type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたの型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept>準拠をカスタマイズするために、<bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>を上でリストされる基準に沿わない型において採用するために、または既存の型を拡張して<bpt i="2" x="2">&lt;c2&gt;</bpt>Hashable<ept i="2">&lt;/c2&gt;</ept>に準拠するためには、<bpt i="3" x="3">&lt;c3&gt;</bpt>hash(into:)<ept i="3">&lt;/c3&gt;</ept>メソッドをあなたのあつらえの型において実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To declare a dictionary, assign a dictionary literal to a variable or constant:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書を宣言するには、辞書リテラルを変数または定数に割り当ててください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To do so, start by creating two slices of the <bpt i="0" x="0">&lt;c0&gt;</bpt>absences<ept i="0">&lt;/c0&gt;</ept> array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それをするには、<bpt i="0" x="0">&lt;c0&gt;</bpt>absences<ept i="0">&lt;/c0&gt;</ept>配列の２つのスライスを作成することで始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To do this, enclose a comma-separated list of values in square brackets.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これをするには、コンマ区切りの値のリストを角括弧で囲んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To ensure that your type meets the semantic requirements of the <bpt i="3" x="3">&lt;c3&gt;</bpt>Hashable<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>Equatable<ept i="4">&lt;/c4&gt;</ept> protocols, it’s a good idea to also customize your type’s <bpt i="5" x="5">&lt;c5&gt;</bpt>Equatable<ept i="5">&lt;/c5&gt;</ept> conformance to match.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたの型が<bpt i="3" x="3">&lt;c3&gt;</bpt>Hashable<ept i="3">&lt;/c3&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>Equatable<ept i="4">&lt;/c4&gt;</ept>プロトコルの意味論的要件に沿うことを確実にするために、あなたの型のもつ<bpt i="5" x="5">&lt;c5&gt;</bpt>Equatable<ept i="5">&lt;/c5&gt;</ept>準拠が合致するように同様にカスタマイズすることは良い考えです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To find the difference between two collections, use the <bpt i="0" x="0">&lt;c0&gt;</bpt>difference(from:)<ept i="0">&lt;/c0&gt;</ept> method declared on the <bpt i="1" x="1">&lt;c1&gt;</bpt>Bidirectional<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つのコレクションの間の差異を見つけるには、<bpt i="1" x="1">&lt;c1&gt;</bpt>Bidirectional<bpt i="2" x="2">&lt;w2&gt;</bpt>Collection<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>プロトコル上で宣言される<bpt i="0" x="0">&lt;c0&gt;</bpt>difference(from:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To find the distance in bytes between two pointers, convert them to <bpt i="3" x="3">&lt;c3&gt;</bpt>Unsafe<bpt i="4" x="4">&lt;w4&gt;</bpt>Raw<bpt i="5" x="5">&lt;w5&gt;</bpt>Pointer<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> instances before calling <bpt i="6" x="6">&lt;c6&gt;</bpt>distance(to:)<ept i="6">&lt;/c6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つのポインタの間の隔たりをバイトで知るには、それらを<bpt i="3" x="3">&lt;c3&gt;</bpt>Unsafe<bpt i="4" x="4">&lt;w4&gt;</bpt>Raw<bpt i="5" x="5">&lt;w5&gt;</bpt>Pointer<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>インスタンスに、<bpt i="6" x="6">&lt;c6&gt;</bpt>distance(to:)<ept i="6">&lt;/c6&gt;</ept>を呼ぶ前に変換してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To find the index of the day in question, follow these steps:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>質問の日付のインデックスを見つけるには、これらの手順に従ってください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To find the indices of the two days in question, follow these steps:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>当該の２つの日付のインデックスを見つけるには、これらの手順を踏んでください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To get the character’s value, use the <bpt i="0" x="0">&lt;c0&gt;</bpt>hex<bpt i="1" x="1">&lt;w1&gt;</bpt>Digit<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>文字のもつ値を取得するには、<bpt i="0" x="0">&lt;c0&gt;</bpt>hex<bpt i="1" x="1">&lt;w1&gt;</bpt>Digit<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To get the dynamic type inside <bpt i="11" x="11">&lt;c11&gt;</bpt>value<ept i="11">&lt;/c11&gt;</ept> in this generic context, cast the parameter to <bpt i="12" x="12">&lt;c12&gt;</bpt>Any<ept i="12">&lt;/c12&gt;</ept> when calling <bpt i="13" x="13">&lt;c13&gt;</bpt>type(of:)<ept i="13">&lt;/c13&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="11" x="11">&lt;c11&gt;</bpt>value<ept i="11">&lt;/c11&gt;</ept>内部の動的型をこの総称体の文脈において得るには、このパラメータを<bpt i="12" x="12">&lt;c12&gt;</bpt>Any<ept i="12">&lt;/c12&gt;</ept>へと<bpt i="13" x="13">&lt;c13&gt;</bpt>type(of:)<ept i="13">&lt;/c13&gt;</ept>を呼び出す時にキャストしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To handle Objective-C exceptions, write Objective-C code that catches exceptions before they reach any Swift code.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-C例外を取り扱うには、それら例外をそれらが何らかのスウィフトコードに届く前に捕まえるObjective-Cコードを書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To implement your own <bpt i="0" x="0">&lt;c0&gt;</bpt>Async<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, implement a wrapped type that conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt>Async<bpt i="3" x="3">&lt;w3&gt;</bpt>Iterator<bpt i="4" x="4">&lt;w4&gt;</bpt>Protocol<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなた独自の<bpt i="0" x="0">&lt;c0&gt;</bpt>Async<bpt i="1" x="1">&lt;w1&gt;</bpt>Sequence<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を実装するには、<bpt i="2" x="2">&lt;c2&gt;</bpt>Async<bpt i="3" x="3">&lt;w3&gt;</bpt>Iterator<bpt i="4" x="4">&lt;w4&gt;</bpt>Protocol<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に準拠するあるラップ型を実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To import a set of Objective-C files into Swift code within the same app target, you rely on an Objective-C bridging header file to expose those files to Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>一揃いのObjective-CファイルをSwiftコードへと同じアプリターゲット内でインポートするには、あなたはObjective-Cブリッジヘッダファイルを頼ることで、それらファイルをSwiftへと露出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To import a set of Swift files in the same framework target as your Objective-C code, import the Xcode-generated header for your Swift code into any Objective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept> file where you want to use your Swift code.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>一揃いのSwiftファイルをあなたのObjective-Cコードと同じフレームワークターゲットの中でインポートするために、あなたのSwiftコードに対するXcode生成のヘッダを、そこにおいてあなたがあなたのSwiftコードを使うことを望む何らかのObjective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept>ファイルの中へとインポートしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To iterate over the elements of a collection with its indices, use the <bpt i="3" x="3">&lt;c3&gt;</bpt>zip(_:<bpt i="4" x="4">&lt;w4&gt;</bpt>_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるコレクションの要素すべてにわたってそれのインデックスで反復するには、<bpt i="3" x="3">&lt;c3&gt;</bpt>zip(_:<bpt i="4" x="4">&lt;w4&gt;</bpt>_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>関数を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To learn more about the open source Swift project and community, visit <bpt i="0" x="0">&lt;a0&gt;</bpt>Swift.org<ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オープンソースSwiftプロジェクトおよびコミュニティについてもっと知るには、<bpt i="0" x="0">&lt;a0&gt;</bpt>Swift.org<ept i="0">&lt;/a0&gt;</ept>を訪れてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To learn which half had more absences, use the <bpt i="1" x="1">&lt;c1&gt;</bpt>reduce(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> method to calculate each sum.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>前半後半のどちらがより多くの欠席者がいるか突き止めるには、<bpt i="1" x="1">&lt;c1&gt;</bpt>reduce(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>メソッドを使ってそれぞれ総計を計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To maintain substitutability, the <bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept> operator should take into account all visible aspects of an <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>代替可能性を維持するために、<bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept>演算子はある<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>型の全ての目に見える面を考慮しなければならないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To make <bpt i="0" x="0">&lt;c0&gt;</bpt>Player<ept i="0">&lt;/c0&gt;</ept> conform to the <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept> protocol, declare conformance in another extension and implement the <bpt i="2" x="2">&lt;c2&gt;</bpt>hash(into:)<ept i="2">&lt;/c2&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Player<ept i="0">&lt;/c0&gt;</ept>を<bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>プロトコルに準拠させるには、準拠を別の拡張において宣言して、<bpt i="2" x="2">&lt;c2&gt;</bpt>hash(into:)<ept i="2">&lt;/c2&gt;</ept>メソッドを実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To make this class conform to the <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept> protocol, declare conformance in an extension and implement the  static <bpt i="4" x="4">&lt;c4&gt;</bpt>==<ept i="4">&lt;/c4&gt;</ept> operator method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このクラスを<bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>プロトコルに準拠させるには、準拠をある拡張において宣言して、静的<bpt i="4" x="4">&lt;c4&gt;</bpt>==<ept i="4">&lt;/c4&gt;</ept>演算子メソッドを実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To make your own custom type conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Fixed<bpt i="1" x="1">&lt;w1&gt;</bpt>Width<bpt i="2" x="2">&lt;w2&gt;</bpt>Integer<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol, declare the required initializers, properties, and methods.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなた独自のあつらえの型を<bpt i="0" x="0">&lt;c0&gt;</bpt>Fixed<bpt i="1" x="1">&lt;w1&gt;</bpt>Width<bpt i="2" x="2">&lt;w2&gt;</bpt>Integer<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠させるには、必須イニシャライザ、プロパティ、そしてメソッドを宣言してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To multiply values of different types, convert one of the values to the other value’s type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>異なる型の値を乗算するには、それらの値の一方を、他方の値の型へと変換してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To prevent infinite loops, playground logging implementations can place a reasonable limit on this kind of chaining.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>無限ループを防ぐには、プレイグラウンドログ実装はこの種の連鎖に関して妥当な制限を置くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To print the items separated by something other than a space, pass a string as <bpt i="0" x="0">&lt;c0&gt;</bpt>separator<ept i="0">&lt;/c0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>空白以外の何かによって区切られる項目を出力するには、ある文字列を<bpt i="0" x="0">&lt;c0&gt;</bpt>separator<ept i="0">&lt;/c0&gt;</ept>として渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To print the items without a trailing newline, pass an empty string as <bpt i="3" x="3">&lt;c3&gt;</bpt>terminator<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>後に続く改行なしで項目を出力するには、空の文字列を<bpt i="3" x="3">&lt;c3&gt;</bpt>terminator<ept i="3">&lt;/c3&gt;</ept>として渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To print the items without a trailing newline, pass an empty string as <bpt i="4" x="4">&lt;c4&gt;</bpt>terminator<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>後に続く改行なしで項目を出力するには、空の文字列を<bpt i="4" x="4">&lt;c4&gt;</bpt>terminator<ept i="4">&lt;/c4&gt;</ept>として渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To print the items without a trailing newline, pass an empty string as <bpt i="5" x="5">&lt;c5&gt;</bpt>terminator<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>後に続く改行なしで項目を出力するには、空の文字列を<bpt i="5" x="5">&lt;c5&gt;</bpt>terminator<ept i="5">&lt;/c5&gt;</ept>として渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To protect code from invalid usage in Release builds, see <bpt i="2" x="2">&lt;c2&gt;</bpt>precondition<bpt i="3" x="3">&lt;w3&gt;</bpt>Failure(_:<bpt i="4" x="4">&lt;w4&gt;</bpt>file:<bpt i="5" x="5">&lt;w5&gt;</bpt>line:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>「リリース」ビルドにおける無効な使用法を調べるには、<bpt i="2" x="2">&lt;c2&gt;</bpt>precondition<bpt i="3" x="3">&lt;w3&gt;</bpt>Failure(_:<bpt i="4" x="4">&lt;w4&gt;</bpt>file:<bpt i="5" x="5">&lt;w5&gt;</bpt>line:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To remove elements from an array, use the <bpt i="0" x="0">&lt;c0&gt;</bpt>remove(at:)<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>remove<bpt i="2" x="2">&lt;w2&gt;</bpt>Subrange(_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>, and <bpt i="3" x="3">&lt;c3&gt;</bpt>remove<bpt i="4" x="4">&lt;w4&gt;</bpt>Last()<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> methods.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列から要素を取り除くには、<bpt i="0" x="0">&lt;c0&gt;</bpt>remove(at:)<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>remove<bpt i="2" x="2">&lt;w2&gt;</bpt>Subrange(_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>、そして<bpt i="3" x="3">&lt;c3&gt;</bpt>remove<bpt i="4" x="4">&lt;w4&gt;</bpt>Last()<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>メソッドを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To remove the last element of a collection that might be empty, use the <bpt i="0" x="0">&lt;c0&gt;</bpt>pop<bpt i="1" x="1">&lt;w1&gt;</bpt>Last()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method instead.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>空であるかもしれないあるコレクションの最後の要素を削除するには、<bpt i="0" x="0">&lt;c0&gt;</bpt>pop<bpt i="1" x="1">&lt;w1&gt;</bpt>Last()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To resolve these errors, you can use <bpt i="8" x="8">&lt;c8&gt;</bpt>without<bpt i="9" x="9">&lt;w9&gt;</bpt>Actually<bpt i="10" x="10">&lt;w10&gt;</bpt>Escaping(_:<bpt i="11" x="11">&lt;w11&gt;</bpt>do:)<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept> to get copies of <bpt i="12" x="12">&lt;c12&gt;</bpt>f<ept i="12">&lt;/c12&gt;</ept> and <bpt i="13" x="13">&lt;c13&gt;</bpt>g<ept i="13">&lt;/c13&gt;</ept> that can be passed to <bpt i="14" x="14">&lt;c14&gt;</bpt>async(execute:)<ept i="14">&lt;/c14&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>これらのエラーを解決するために、あなたは<bpt i="8" x="8">&lt;c8&gt;</bpt>without<bpt i="9" x="9">&lt;w9&gt;</bpt>Actually<bpt i="10" x="10">&lt;w10&gt;</bpt>Escaping(_:<bpt i="11" x="11">&lt;w11&gt;</bpt>do:)<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>を使って、<bpt i="12" x="12">&lt;c12&gt;</bpt>f<ept i="12">&lt;/c12&gt;</ept>と<bpt i="13" x="13">&lt;c13&gt;</bpt>g<ept i="13">&lt;/c13&gt;</ept>のコピーを取得します、それは<bpt i="14" x="14">&lt;c14&gt;</bpt>async(execute:)<ept i="14">&lt;/c14&gt;</ept>に渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To resume the asynchronous task, call the <bpt i="10" x="10">&lt;c10&gt;</bpt>resume(returning:)<ept i="10">&lt;/c10&gt;</ept>, <bpt i="11" x="11">&lt;c11&gt;</bpt>resume(throwing:)<ept i="11">&lt;/c11&gt;</ept>, <bpt i="12" x="12">&lt;c12&gt;</bpt>resume(with:)<ept i="12">&lt;/c12&gt;</ept>, or <bpt i="13" x="13">&lt;c13&gt;</bpt>resume()<ept i="13">&lt;/c13&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>非同期タスクを再開するには、<bpt i="10" x="10">&lt;c10&gt;</bpt>resume(returning:)<ept i="10">&lt;/c10&gt;</ept>、<bpt i="11" x="11">&lt;c11&gt;</bpt>resume(throwing:)<ept i="11">&lt;/c11&gt;</ept>、<bpt i="12" x="12">&lt;c12&gt;</bpt>resume(with:)<ept i="12">&lt;/c12&gt;</ept>、または<bpt i="13" x="13">&lt;c13&gt;</bpt>resume()<ept i="13">&lt;/c13&gt;</ept>メソッドを呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To round a value using the default “schoolbook rounding”, you can use the shorter <bpt i="4" x="4">&lt;c4&gt;</bpt>round()<ept i="4">&lt;/c4&gt;</ept> method instead.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時の「教科書丸め」を使って値を丸めるには、あなたはより短い<bpt i="4" x="4">&lt;c4&gt;</bpt>round()<ept i="4">&lt;/c4&gt;</ept>メソッドを代わりに使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To round a value using the default “schoolbook rounding”, you can use the shorter <bpt i="4" x="4">&lt;c4&gt;</bpt>rounded()<ept i="4">&lt;/c4&gt;</ept> method instead.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>省略時の「教科書丸め」を使って値を丸めるには、あなたはより短い<bpt i="4" x="4">&lt;c4&gt;</bpt>rounded()<ept i="4">&lt;/c4&gt;</ept>メソッドを代わりに使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To safely reference the starting and ending indices of a slice, always use the <bpt i="0" x="0">&lt;c0&gt;</bpt>start<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>end<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> properties instead of specific values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるスライスの最初と最後のインデックスを安全に参照するために、常に<bpt i="0" x="0">&lt;c0&gt;</bpt>start<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>end<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロパティを特定の値の代わりに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To sort the elements of your collection in descending order, pass the greater-than operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&gt;<ept i="0">&lt;/c0&gt;</ept>) to the <bpt i="1" x="1">&lt;c1&gt;</bpt>sort(by:)<ept i="1">&lt;/c1&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのコレクションの要素を降順にソートするには、より大きい演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&gt;<ept i="0">&lt;/c0&gt;</ept>）を<bpt i="1" x="1">&lt;c1&gt;</bpt>sort(by:)<ept i="1">&lt;/c1&gt;</ept>メソッドに渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To sort the elements of your sequence in descending order, pass the greater-than operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&gt;<ept i="0">&lt;/c0&gt;</ept>) to the <bpt i="1" x="1">&lt;c1&gt;</bpt>sorted(by:)<ept i="1">&lt;/c1&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのシーケンスの要素を降順にソートするには、より大きい演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&gt;<ept i="0">&lt;/c0&gt;</ept>）を<bpt i="1" x="1">&lt;c1&gt;</bpt>sorted(by:)<ept i="1">&lt;/c1&gt;</ept>メソッドに渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To sort your sequence in descending order, pass the greater-than operator (<bpt i="1" x="1">&lt;c1&gt;</bpt>&gt;<ept i="1">&lt;/c1&gt;</ept>) as the <bpt i="2" x="2">&lt;c2&gt;</bpt>are<bpt i="3" x="3">&lt;w3&gt;</bpt>In<bpt i="4" x="4">&lt;w4&gt;</bpt>Increasing<bpt i="5" x="5">&lt;w5&gt;</bpt>Order<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> parameter.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのシーケンスを降順にソートするには、より大きい演算子（<bpt i="1" x="1">&lt;c1&gt;</bpt>&gt;<ept i="1">&lt;/c1&gt;</ept>）を<bpt i="2" x="2">&lt;c2&gt;</bpt>are<bpt i="3" x="3">&lt;w3&gt;</bpt>In<bpt i="4" x="4">&lt;w4&gt;</bpt>Increasing<bpt i="5" x="5">&lt;w5&gt;</bpt>Order<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>パラメータとして渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To specify an alternative rule for rounding, use the <bpt i="0" x="0">&lt;c0&gt;</bpt>round(_:)<ept i="0">&lt;/c0&gt;</ept> method instead.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>丸めのための代替の規則を指定するには、<bpt i="0" x="0">&lt;c0&gt;</bpt>round(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドを代わりに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To specify an alternative rule for rounding, use the <bpt i="0" x="0">&lt;c0&gt;</bpt>rounded(_:)<ept i="0">&lt;/c0&gt;</ept> method instead.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>丸めのための代替の規則を指定するには、<bpt i="0" x="0">&lt;c0&gt;</bpt>rounded(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドを代わりに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To start using the object, you use the <bpt i="1" x="1">&lt;c1&gt;</bpt>take<bpt i="2" x="2">&lt;w2&gt;</bpt>Unretained<bpt i="3" x="3">&lt;w3&gt;</bpt>Value()<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのオブジェクトの使用を開始するには、あなたは<bpt i="1" x="1">&lt;c1&gt;</bpt>take<bpt i="2" x="2">&lt;w2&gt;</bpt>Unretained<bpt i="3" x="3">&lt;w3&gt;</bpt>Value()<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>関数を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To subtract values of different types, convert one of the values to the other value’s type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>異なる型の値を減算するには、それらの値の一方を、他方の値の型へと変換してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To swap two elements of a mutable collection, use the <bpt i="0" x="0">&lt;c0&gt;</bpt>swap<bpt i="1" x="1">&lt;w1&gt;</bpt>At(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method of that collection instead of this function.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある可変のコレクションの２つの要素を交換するには、そのコレクションの<bpt i="0" x="0">&lt;c0&gt;</bpt>swap<bpt i="1" x="1">&lt;w1&gt;</bpt>At(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを、この関数の代わりに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To use a dictionary literal as the initial value of a dictionary, enclose a comma-separated list of key-value pairs in square brackets.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書リテラルをある辞書の初期値として使うには、キー値ペアのコンマ区切りリストを角括弧で囲んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To use the <bpt i="0" x="0">&lt;c0&gt;</bpt>contains(_:)<ept i="0">&lt;/c0&gt;</ept> method without including a closure in each call, extend the <bpt i="1" x="1">&lt;c1&gt;</bpt>Street<bpt i="2" x="2">&lt;w2&gt;</bpt>Address<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> type to conform to <bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>contains(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドを各呼び出しにクロージャを含めることなく使うには、<bpt i="1" x="1">&lt;c1&gt;</bpt>Street<bpt i="2" x="2">&lt;w2&gt;</bpt>Address<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>型を<bpt i="3" x="3">&lt;c3&gt;</bpt>Equatable<ept i="3">&lt;/c3&gt;</ept>に準拠するように拡張してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To use the Objective-C declarations in files in the same framework target as your Swift code, configure an umbrella header as follows:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-C宣言をあなたのSwiftコードと同じフレームワークターゲットの中のファイルにおいて使うには、アンブレラヘッダを以下のように構成設定してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To use your own custom type in a set or as the key type of a dictionary, add <bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept> conformance to your type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなた独自のあつらえの型を集合でまたは辞書のキー型として使うには、<bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept>準拠をあなたの型に加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Toggles the Boolean variable’s value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ブール変数の持つ値を切り替えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Topics</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>話題</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Tranforming a Range's Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある範囲の持つ要素を変換する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Transforming a Boolean</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ブールを変換する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Transforming a Dictionary</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書の変形</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Transforming a Dictionary's Elements</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書の要素の変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Transforming a Sequence</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスを変形する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Transforming an Array</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列の変形</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Translates the given input from one Unicode encoding to another by calling the given closure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>指定された入力をあるユニコード符号化から別のものへと指定されたクロージャを呼び出すことによって翻訳します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Traversing a Collection</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションを辿っていく</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Treat identity with care.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>同一性を注意して取り扱ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>True if any lane of mask is true.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>マスクのどんなレーンもtrueならば、true。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>True if every lane of mask is true.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>マスクのあらゆるレーンがtrueならば、true。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Tuple Comparison</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>タプル比較</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Two <bpt i="0" x="0">&lt;c0&gt;</bpt>Date<ept i="0">&lt;/c0&gt;</ept> instances are equal if each of their corresponding properties is equal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの<bpt i="0" x="0">&lt;c0&gt;</bpt>Date<ept i="0">&lt;/c0&gt;</ept>インスタンスは、それらの対応するプロパティの各々が等しいならば等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Two edge cases are worth particular attention:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの境界事例は特別な注意を払う価値があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Two elements are <bpt i="0" x="0">&lt;e0&gt;</bpt>incomparable<ept i="0">&lt;/e0&gt;</ept> if neither is ordered before the other according to the predicate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの要素は、述部によるとどちらもが他の前に並べられるならば<bpt i="0" x="0">&lt;e0&gt;</bpt>比較できない<ept i="0">&lt;/e0&gt;</ept>。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Two instances that are equal must feed the same values to <bpt i="2" x="2">&lt;c2&gt;</bpt>Hasher<ept i="2">&lt;/c2&gt;</ept> in <bpt i="3" x="3">&lt;c3&gt;</bpt>hash(into:)<ept i="3">&lt;/c3&gt;</ept>, in the same order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>等しい２つのインスタンスは、同じ値を<bpt i="2" x="2">&lt;c2&gt;</bpt>Hasher<ept i="2">&lt;/c2&gt;</ept>へと<bpt i="3" x="3">&lt;c3&gt;</bpt>hash(into:)<ept i="3">&lt;/c3&gt;</ept>において、同じ順序で与えなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Two ranges are equal when they have the same lower and upper bounds.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの範囲は、それらが同じ下方および上方境界を持つとき等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Type Aliases</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型エイリアス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Type Casting and Existential Types</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型キャストと存在型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Type Inference of Array Literals</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列リテラルの型推論</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Type Method</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Type Methods</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Type Properties</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型プロパティ </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Type Property</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Type-Erasing Wrappers</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型消去ラッパー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Typed pointers are required to be properly aligned for their <bpt i="0" x="0">&lt;c0&gt;</bpt>Pointee<ept i="0">&lt;/c0&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>型付ポインタは、適切にそれらの<bpt i="0" x="0">&lt;c0&gt;</bpt>Pointee<ept i="0">&lt;/c0&gt;</ept>型にアラインされることを要求されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Types conforming to <bpt i="0" x="0">&lt;c0&gt;</bpt>Async<bpt i="1" x="1">&lt;w1&gt;</bpt>Iterator<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> should use the cancellation primitives provided by Swift’s <bpt i="3" x="3">&lt;c3&gt;</bpt>Task<ept i="3">&lt;/c3&gt;</ept> API.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Async<bpt i="1" x="1">&lt;w1&gt;</bpt>Iterator<bpt i="2" x="2">&lt;w2&gt;</bpt>Protocol<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に準拠する型は、Swiftのもつ<bpt i="3" x="3">&lt;c3&gt;</bpt>Task<ept i="3">&lt;/c3&gt;</ept> APIによって提供される取り消し原始関数を使うべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Types that are not able to guarantee this performance must document the departure, because many collection operations depend on O(1) subscripting performance for their own performance guarantees.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この性能を保証することが可能でない型は、その逸脱を文書化されなければなりません、なぜなら多くのコレクション演算はそれら自身の性能保証としてO(1)添え字操作性能に依存するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Types that conform to <bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<ept i="0">&lt;/c0&gt;</ept> are expected to provide the <bpt i="1" x="1">&lt;c1&gt;</bpt>start<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>end<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> properties and subscript access to elements as O(1) operations.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<ept i="0">&lt;/c0&gt;</ept>に準拠する型は、<bpt i="1" x="1">&lt;c1&gt;</bpt>start<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>および<bpt i="3" x="3">&lt;c3&gt;</bpt>end<bpt i="4" x="4">&lt;w4&gt;</bpt>Index<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>プロパティと要素への添え字アクセスをO(1)演算として提供することを期待されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Types that conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Case<bpt i="1" x="1">&lt;w1&gt;</bpt>Iterable<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol are typically enumerations without associated values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Case<bpt i="1" x="1">&lt;w1&gt;</bpt>Iterable<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する型は、概して関連値を持たない列挙です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Types that conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Custom<bpt i="1" x="1">&lt;w1&gt;</bpt>String<bpt i="2" x="2">&lt;w2&gt;</bpt>Convertible<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol can provide their own representation to be used when converting an instance to a string.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Custom<bpt i="1" x="1">&lt;w1&gt;</bpt>String<bpt i="2" x="2">&lt;w2&gt;</bpt>Convertible<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する型は、それら独自の表現を提供して、インスタンスが文字列に変換されるときに使われるようにできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Types that conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept> protocol can be compared for equality using the equal-to operator (<bpt i="1" x="1">&lt;c1&gt;</bpt>==<ept i="1">&lt;/c1&gt;</ept>) or inequality using the not-equal-to operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>!=<ept i="2">&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する型は、同等性を同等演算子（<bpt i="1" x="1">&lt;c1&gt;</bpt>==<ept i="1">&lt;/c1&gt;</ept>）を使って、または不等性を不等演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>!=<ept i="2">&lt;/c2&gt;</ept>）を使って比較されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Types that conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Floating<bpt i="1" x="1">&lt;w1&gt;</bpt>Point<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol provide most basic (clause 5) operations of the <bpt i="2" x="2">&lt;a2&gt;</bpt>IEEE 754 specification<ept i="2">&lt;/a2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Floating<bpt i="1" x="1">&lt;w1&gt;</bpt>Point<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する型は、<bpt i="2" x="2">&lt;a2&gt;</bpt>IEEE 754仕様<ept i="2">&lt;/a2&gt;</ept>の最も基本的な演算（５項）を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Types that implement alternative behaviors for a signaling NaN must document the departure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シグナルNaNに対する代替の挙動を実装する型は、その逸脱を文書化しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Types with Comparable conformance implement the less-than operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;<ept i="0">&lt;/c0&gt;</ept>) and the equal-to operator (<bpt i="1" x="1">&lt;c1&gt;</bpt>==<ept i="1">&lt;/c1&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Comparable準拠を持つ型は、より少ない演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;<ept i="0">&lt;/c0&gt;</ept>）と同等演算子（<bpt i="1" x="1">&lt;c1&gt;</bpt>==<ept i="1">&lt;/c1&gt;</ept>）を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Typically, you use this to transform from one type of element to another.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>概して、あなたはこれを使ってある型の要素から別のものへと変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Typically, you’ll iterate over these sequences with <bpt i="11" x="11">&lt;c11&gt;</bpt>for await<ept i="11">&lt;/c11&gt;</ept>-<bpt i="12" x="12">&lt;c12&gt;</bpt>in<ept i="12">&lt;/c12&gt;</ept>, like the base <bpt i="13" x="13">&lt;c13&gt;</bpt>Async<bpt i="14" x="14">&lt;w14&gt;</bpt>Sequence<ept i="14">&lt;/w14&gt;</ept><ept i="13">&lt;/c13&gt;</ept> you started with.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>概して、あなたはそれらシーケンスのすべてにわたって<bpt i="11" x="11">&lt;c11&gt;</bpt>for await<ept i="11">&lt;/c11&gt;</ept>-<bpt i="12" x="12">&lt;c12&gt;</bpt>in<ept i="12">&lt;/c12&gt;</ept>で反復処理をするでしょう、あなたがそれで始めた基本的な<bpt i="13" x="13">&lt;c13&gt;</bpt>Async<bpt i="14" x="14">&lt;w14&gt;</bpt>Sequence<ept i="14">&lt;/w14&gt;</ept><ept i="13">&lt;/c13&gt;</ept>のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Unconditionally prints a given message and stops execution.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>無条件に与えられたメッセージを出力して実行を停止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Under Build Settings, in Packaging, make sure the Defines Module setting for that framework target is set to Yes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>「Build Settings」の下、「Packaging」の中で、そのフレームワークターゲットのための「Defines Module」設定が「Yes」に設定されることを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Under Build Settings, in Packaging, make sure the Defines Module setting for the framework target is set to Yes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Build Settingsの下、Packagingにおいて、フレームワークターゲットに対するDefines Module設定がYesに設定されることを確実にしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Understand How Error Parameters Are Imported</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>どのようにエラーパラメータがインポートされるか理解する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Understand How Swift Imports Completion Handlers</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>どのようにSwiftが完了ハンドラをインポートするか理解する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Understand how different API calls to your closures can affect your app.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのクロージャに対する異なるAPI呼び出しがどのようにあなたのアプリに影響を与えられるかを理解します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Understand the Conversion Rules</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>変換規則を理解する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Understand the constraints of imported Obj-C lightweight generic type declarations.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インポートされたObj-C軽量総称体型宣言の制約を理解します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Unicode</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ユニコード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Unions</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>共用体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Unique for the lifetime of a process (e.g. global incrementing integers).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるプロセスの存続期間に対して特有（たとえば、グローバルに漸増している整数）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Unique for the lifetime of an object (e.g. object identifiers).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるオブジェクトの存続期間に対して特有（たとえば、オブジェクト識別子）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Unique within the current collection (e.g. collection index).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>現在のコレクション内で特有（たとえば、コレクションインデックス）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Uniqueness Checking</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>特有性の検査</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Unless the collection conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Bidirectional<bpt i="1" x="1">&lt;w1&gt;</bpt>Collection<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol, <bpt i="2" x="2">&lt;c2&gt;</bpt>start<ept i="2">&lt;/c2&gt;</ept> must be less than or equal to <bpt i="3" x="3">&lt;c3&gt;</bpt>end<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>コレクションが<bpt i="0" x="0">&lt;c0&gt;</bpt>Bidirectional<bpt i="1" x="1">&lt;w1&gt;</bpt>Collection<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠しない場合は、<bpt i="2" x="2">&lt;c2&gt;</bpt>start<ept i="2">&lt;/c2&gt;</ept>は<bpt i="3" x="3">&lt;c3&gt;</bpt>end<ept i="3">&lt;/c3&gt;</ept>より少ないか等しくなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Unless the collection guarantees random-access performance, calculating <bpt i="3" x="3">&lt;c3&gt;</bpt>count<ept i="3">&lt;/c3&gt;</ept> can be an O(<bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept>) operation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのコレクションが無作為アクセス性能を保証しない限り、<bpt i="3" x="3">&lt;c3&gt;</bpt>count<ept i="3">&lt;/c3&gt;</ept>の算出は、O(<bpt i="4" x="4">&lt;e4&gt;</bpt>n<ept i="4">&lt;/e4&gt;</ept>)演算であるはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Unlike <bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Contiguous<bpt i="2" x="2">&lt;w2&gt;</bpt>Array<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>, the starting index for an <bpt i="3" x="3">&lt;c3&gt;</bpt>Array<bpt i="4" x="4">&lt;w4&gt;</bpt>Slice<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> instance isn’t always zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Array<ept i="0">&lt;/c0&gt;</ept>および<bpt i="1" x="1">&lt;c1&gt;</bpt>Contiguous<bpt i="2" x="2">&lt;w2&gt;</bpt>Array<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>とは違い、<bpt i="3" x="3">&lt;c3&gt;</bpt>Array<bpt i="4" x="4">&lt;w4&gt;</bpt>Slice<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>インスタンスのインデックスの始まりは必ずしもゼロではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Unlike <bpt i="0" x="0">&lt;c0&gt;</bpt>Unsafe<bpt i="1" x="1">&lt;w1&gt;</bpt>Mutable<bpt i="2" x="2">&lt;w2&gt;</bpt>Pointer&lt;Pointee&gt;<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, <bpt i="3" x="3">&lt;c3&gt;</bpt>Autoreleasing<bpt i="4" x="4">&lt;w4&gt;</bpt>Unsafe<bpt i="5" x="5">&lt;w5&gt;</bpt>Mutable<bpt i="6" x="6">&lt;w6&gt;</bpt>Pointer&lt;Pointee&gt;<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> must reference storage that does not own a reference count to the referenced value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Unsafe<bpt i="1" x="1">&lt;w1&gt;</bpt>Mutable<bpt i="2" x="2">&lt;w2&gt;</bpt>Pointer&lt;Pointee&gt;<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>とは違い、<bpt i="3" x="3">&lt;c3&gt;</bpt>Autoreleasing<bpt i="4" x="4">&lt;w4&gt;</bpt>Unsafe<bpt i="5" x="5">&lt;w5&gt;</bpt>Mutable<bpt i="6" x="6">&lt;w6&gt;</bpt>Pointer&lt;Pointee&gt;<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>は、参照される値への参照カウントを保有しないストレージを参照しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Unlike in other programming languages, in Swift, integers and strings cannot be used where a Boolean value is required.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>他のプログラミング言語とは違い、Swiftではブール値が必要とされるところで整数と文字列は使用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Unlike the key-based subscript, the index-based subscript returns the corresponding key-value pair as a non-optional tuple.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キー基盤の添え字と違い、インデックス基盤の添え字は該当するキー値ペアを非オプショナルのタプルとして返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Unlike traditional truncating multiplication, the <bpt i="0" x="0">&lt;c0&gt;</bpt>multiplied<bpt i="1" x="1">&lt;w1&gt;</bpt>Full<bpt i="2" x="2">&lt;w2&gt;</bpt>Width(by:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method returns a tuple containing both the <bpt i="3" x="3">&lt;c3&gt;</bpt>high<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>low<ept i="4">&lt;/c4&gt;</ept> parts of the product of this value and <bpt i="5" x="5">&lt;c5&gt;</bpt>other<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>従来的な切り詰め乗算と違って、<bpt i="0" x="0">&lt;c0&gt;</bpt>multiplied<bpt i="1" x="1">&lt;w1&gt;</bpt>Full<bpt i="2" x="2">&lt;w2&gt;</bpt>Width(by:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドは、この値と<bpt i="3" x="3">&lt;c3&gt;</bpt>other<ept i="3">&lt;/c3&gt;</ept>の積の<bpt i="4" x="4">&lt;c4&gt;</bpt>high<ept i="4">&lt;/c4&gt;</ept>および<bpt i="5" x="5">&lt;c5&gt;</bpt>low<ept i="5">&lt;/c5&gt;</ept>部分の両方を含んでいるタプルを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Unnamed Structure and Union Fields</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>無名の構造体および共用体のフィールド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Unnamed fields consist of a nested <bpt i="2" x="2">&lt;c2&gt;</bpt>struct<ept i="2">&lt;/c2&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt>union<ept i="3">&lt;/c3&gt;</ept> type with named fields.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>無名フィールドは、入れ子にされた<bpt i="2" x="2">&lt;c2&gt;</bpt>struct<ept i="2">&lt;/c2&gt;</ept>または<bpt i="3" x="3">&lt;c3&gt;</bpt>union<ept i="3">&lt;/c3&gt;</ept>で名前付きフィールドを持つものから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>UnsafeMutablePointer’s operations, by contrast, assume that the referenced storage owns values loaded from or stored to it.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>UnsafeMutablePointerの行う操作は、対照的に、参照されるストレージがそれからロードされたりそれへと格納される値を所有すると仮定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Unsigned<bpt i="0" x="0">&lt;w0&gt;</bpt>Integer Implementations <ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>符号なし<bpt i="0" x="0">&lt;w0&gt;</bpt>整数実装<ept i="0">&lt;/w0&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Unstructured Concurrency</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>構造化されない並行性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Until reaching the number of elements to drop, this iterator calls <bpt i="0" x="0">&lt;c0&gt;</bpt>next()<ept i="0">&lt;/c0&gt;</ept> on its base iterator and discards the result.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>抜かす要素の数に到達するまで、このイテレータは、<bpt i="0" x="0">&lt;c0&gt;</bpt>next()<ept i="0">&lt;/c0&gt;</ept>をそれの基底イテレータ上で呼び出します、そして結果を廃棄します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Until reaching the number of elements to include, this iterator calls <bpt i="0" x="0">&lt;c0&gt;</bpt>next()<ept i="0">&lt;/c0&gt;</ept> on its base iterator and passes through the result.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>抜かす要素の数に到達するまで、このイテレータは、<bpt i="0" x="0">&lt;c0&gt;</bpt>next()<ept i="0">&lt;/c0&gt;</ept>をそれの基底イテレータ上で呼び出します、そして結果を廃棄します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Update an existing value by assigning a new value to a key that already exists in the dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>すでに辞書に存在するキーに新しい値を割り当てることで、既存の値を更新してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Updates the value stored in the dictionary for the given key, or adds a new key-value pair if the key does not exist.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書に格納される値を指定されたキーに対して更新します、またはそのキーが存在しないならば新しいキー値ペアを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Upon reaching <bpt i="7" x="7">&lt;c7&gt;</bpt>6<ept i="7">&lt;/c7&gt;</ept>, the sequence ends:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="7" x="7">&lt;c7&gt;</bpt>6<ept i="7">&lt;/c7&gt;</ept>に到達することで、そのシーケンスは終わります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Uppercase characters vary under case-conversion to lowercase, but not when converted to uppercase.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>アッパーケース文字は、ローワーケースへのケース変換のもとでは変動します、しかしアッパーケースに変換される時はそうではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use <bpt i="0" x="0">&lt;c0&gt;</bpt>drop(while:)<ept i="0">&lt;/c0&gt;</ept> to omit elements from an asynchronous sequence until the element received meets a condition you specify.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>drop(while:)<ept i="0">&lt;/c0&gt;</ept>を使うことで要素を非同期シーケンスから、その受け取った要素があなたが指定する条件に合うまで省いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use <bpt i="0" x="0">&lt;c0&gt;</bpt>drop<bpt i="1" x="1">&lt;w1&gt;</bpt>First(_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> when you want to drop the first <bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept> elements from the base sequence and pass through the remaining elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>drop<bpt i="1" x="1">&lt;w1&gt;</bpt>First(_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使ってください、あなたが最初の<bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept>要素を基底シーケンスから抜かす、そして残っている要素をずっと渡したい場合は。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use <bpt i="0" x="0">&lt;c0&gt;</bpt>prefix(_:)<ept i="0">&lt;/c0&gt;</ept> to reduce the number of elements produced by the asynchronous sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>prefix(_:)<ept i="0">&lt;/c0&gt;</ept>を使って非同期シーケンスによって生み出された要素の数を減らしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use <bpt i="0" x="0">&lt;c0&gt;</bpt>prefix(while:)<ept i="0">&lt;/c0&gt;</ept> to produce values while elements from the base sequence meet a condition you specify.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>prefix(while:)<ept i="0">&lt;/c0&gt;</ept>を使うことで、基底シーケンスからの要素があなたが指定する条件に合う間ずっと値を生み出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use <bpt i="0" x="0">&lt;c0&gt;</bpt>unsafe<bpt i="1" x="1">&lt;w1&gt;</bpt>Downcast(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>to:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> only when you are confident that <bpt i="3" x="3">&lt;c3&gt;</bpt>x is T<ept i="3">&lt;/c3&gt;</ept> always evaluates to <bpt i="4" x="4">&lt;c4&gt;</bpt>true<ept i="4">&lt;/c4&gt;</ept>, and only after <bpt i="5" x="5">&lt;c5&gt;</bpt>x as! T<ept i="5">&lt;/c5&gt;</ept> has proven to be a performance problem.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>unsafe<bpt i="1" x="1">&lt;w1&gt;</bpt>Downcast(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>to:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>は、あなたが<bpt i="3" x="3">&lt;c3&gt;</bpt>x is T<ept i="3">&lt;/c3&gt;</ept>は常に<bpt i="4" x="4">&lt;c4&gt;</bpt>true<ept i="4">&lt;/c4&gt;</ept>に評価されることを確信している場合にのみ、そして<bpt i="5" x="5">&lt;c5&gt;</bpt>x as! T<ept i="5">&lt;/c5&gt;</ept>が性能問題をもつと証明された後にのみ使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use <bpt i="2" x="2">&lt;c2&gt;</bpt>start<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>end<bpt i="5" x="5">&lt;w5&gt;</bpt>Index<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> as the bounds for any element access, instead of <bpt i="6" x="6">&lt;c6&gt;</bpt>0<ept i="6">&lt;/c6&gt;</ept> and <bpt i="7" x="7">&lt;c7&gt;</bpt>count<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>start<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>および<bpt i="4" x="4">&lt;c4&gt;</bpt>end<bpt i="5" x="5">&lt;w5&gt;</bpt>Index<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>をその境界としてあらゆる要素アクセスのために使ってください、<bpt i="6" x="6">&lt;c6&gt;</bpt>0<ept i="6">&lt;/c6&gt;</ept>および<bpt i="7" x="7">&lt;c7&gt;</bpt>count<ept i="7">&lt;/c7&gt;</ept>ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use All Significant Properties for Equatable and Hashable</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>すべての重要プロパティをequatableとhashableに対して使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use Classes When You Need Objective-C Interoperability</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>クラスをあなたがObjective-C互換性を必要とする場合に使ってください</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use Classes When You Need to Control Identity</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが同一性を制御する必要がある場合はクラスを使ってください</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use Functions and Generics Instead of Complex Macros</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>関数と総称体を複雑なマクロの代わりに使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use Memory Managed Objects</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>メモリ管理オブジェクトを使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use Structures When You Don't Control Identity</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが同一性を制御しない場合は構造体を使ってください</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use Structures and Protocols to Model Inheritance and Share Behavior</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>構造体とプロトコルを使って挙動の継承と共有をモデル化してください</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use a CVaListPointer to Call Variadic Functions</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>CVaListPointerを使って可変長引数関数を呼び出す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use bridged Foundation types in your Swift codebase to work with dates, times, and other values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ブリッジされたFoundation型をあなたのSwiftコード基盤において使って、日付、時刻、および他の値を扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use bridged reference types when you need reference semantics or Foundation-specific behavior.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ブリッジされた参照型を、あなたが参照意味論またはFoundation特有の挙動を必要とする場合に使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use care when calling <bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Known<bpt i="2" x="2">&lt;w2&gt;</bpt>Uniquely<bpt i="3" x="3">&lt;w3&gt;</bpt>Referenced(_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> from within a Boolean expression.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Known<bpt i="2" x="2">&lt;w2&gt;</bpt>Uniquely<bpt i="3" x="3">&lt;w3&gt;</bpt>Referenced(_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をブール式の内部から呼び出すとき注意を払ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use classes and other declarations from your Objective-C code with the same Swift syntax you use for system classes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>クラスと他の宣言をあなたのObjective-Cコードからあなたがシステムクラスに使うのと同じSwift構文で使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use classes and other declarations from your custom Objective-C code with the same Swift syntax you use for system classes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>クラスと他の宣言をあなたのあつらえのObjective-Cコードからあなたがシステムクラスに使うのと同じSwift構文で使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use classes when you need Objective-C interoperability.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>クラスを、あなたがObjective-C互換性を必要とする場合に使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use classes when you need to control the identity of the data you're modeling.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>クラスを、あなたがモデル化しているデータの同一性を制御する必要がある場合に使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use classes when you need your instances to have this kind of identity.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのインスタンスがその種の同一性を持つことをあなたが必要とする場合は、クラスを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use enumerations to capture and track the state of your app.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>列挙を使ってあなたのアプリの状態をキャプチャおよび追跡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use imported C-defined macros as constants.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インポートされたC定義のマクロを定数として使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use native Swift syntax to interoperate with types and functions in C and Objective-C.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>本来のSwift構文を使ってCおよびObjective-Cでの型および関数と相互作用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use selectors and key paths to interact with dynamic Objective-C APIs.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>セレクタとキーパスを使って動的Objective-C APIと相互作用してます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use string interpolation to include one or more expressions in a string literal, wrapped in a set of parentheses and prefixed by a backslash.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>文字列補間を使って文字列リテラルの中に１つ以上の式を、一組の丸括弧に包んでひとつのバックスラッシュを前に置いて、含めてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use structures along with protocols to adopt behavior by sharing implementations.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>構造体をそれだけでなくプロトコルと一緒に使うことで、実装を共有することによる挙動を取り入れてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use structures by default.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>構造体を、通常は使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use structures to represent common kinds of data.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>構造体を使って、通常の種類のデータを表してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use structures when you're modeling data that contains information about an entity with an identity that you don't control.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが制御を行わない同一性をもつある存在についての情報を含むデータをあなたがモデル化する場合は、構造体を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>Fixed<bpt i="1" x="1">&lt;w1&gt;</bpt>Width<bpt i="2" x="2">&lt;w2&gt;</bpt>Integer<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol as a constraint or extension point when writing operations that depend on bit shifting, performing bitwise operations, catching overflows, or having access to the maximum or minimum representable value of a type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ビットシフト、ビット単位演算の実行、オーバーフローのキャッチ、またはある型の最大限または最小限表現可能な値へのアクセスに依存する演算を記述する場合に、<bpt i="0" x="0">&lt;c0&gt;</bpt>Fixed<bpt i="1" x="1">&lt;w1&gt;</bpt>Width<bpt i="2" x="2">&lt;w2&gt;</bpt>Integer<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルを制約または拡張ポイントとして使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>Identifiable<ept i="0">&lt;/c0&gt;</ept> protocol to provide a stable notion of identity to a class or value type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Identifiable<ept i="0">&lt;/c0&gt;</ept>プロトコルを使って、ある安定した同一性の概念をあるクラスまたは値型に提供してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>advanced(by:)<ept i="0">&lt;/c0&gt;</ept> method in generic code to offset a value by a specified distance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>advanced(by:)<ept i="0">&lt;/c0&gt;</ept>メソッドを総称体コードにおいて使用して、ある値を指定された隔たりだけオフセットしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>combine<ept i="0">&lt;/c0&gt;</ept> closure to select a value to use in the returned dictionary, or to combine existing and new values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>combine<ept i="0">&lt;/c0&gt;</ept>クロージャを使ってある値を選択することで、返される辞書において使ってください、または既存および新規の値を結合してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>combine<ept i="0">&lt;/c0&gt;</ept> closure to select a value to use in the updated dictionary, or to combine existing and new values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>combine<ept i="0">&lt;/c0&gt;</ept>クロージャを使ってある値を選択することで更新された辞書において使ってください、または既存のものと新しい値を結合してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>compact<bpt i="1" x="1">&lt;w1&gt;</bpt>Map(_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method to transform every element received from a base asynchronous sequence, while also discarding any <bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept> results from the closure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>compact<bpt i="1" x="1">&lt;w1&gt;</bpt>Map(_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使うことで、基底非同期シーケンスから受け取ったあらゆる要素を変換してください、そして一方でまたあらゆる<bpt i="2" x="2">&lt;c2&gt;</bpt>nil<ept i="2">&lt;/c2&gt;</ept>結果をクロージャから廃棄して。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>first<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>last<ept i="1">&lt;/c1&gt;</ept> properties for safe access to the value of the array’s first and last elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列の最初と最後の要素の値に対する安全なアクセスのために<bpt i="0" x="0">&lt;c0&gt;</bpt>first<ept i="0">&lt;/c0&gt;</ept>および<bpt i="1" x="1">&lt;c1&gt;</bpt>last<ept i="1">&lt;/c1&gt;</ept>プロパティを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>init(bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Pattern:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initializer for the destination type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>行き先の型のための<bpt i="0" x="0">&lt;c0&gt;</bpt>init(bit<bpt i="1" x="1">&lt;w1&gt;</bpt>Pattern:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>イニシャライザを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>init(clamping:)<ept i="0">&lt;/c0&gt;</ept> initializer to create a new instance of a binary integer type where out-of-range values are clamped to the representable range of the type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>init(clamping:)<ept i="0">&lt;/c0&gt;</ept>イニシャライザを使って、バイナリ整数型の新しいインスタンスを作成してください、そこにおいて範囲外の値はその型の表現可能な範囲に固定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>init(truncating<bpt i="1" x="1">&lt;w1&gt;</bpt>If<bpt i="2" x="2">&lt;w2&gt;</bpt>Needed:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initializer to create a new instance with the same bit pattern as the passed value, extending or truncating the value’s representation as necessary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>init(truncating<bpt i="1" x="1">&lt;w1&gt;</bpt>If<bpt i="2" x="2">&lt;w2&gt;</bpt>Needed:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>イニシャライザを使って、渡された値と同じビットパターンを持つ新しいインスタンスを、必要ならばその値の表現を拡張または切り詰めて作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>init?(exactly:)<ept i="0">&lt;/c0&gt;</ept> initializer to create a new instance after checking whether the passed value is representable.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>init?(exactly:)<ept i="0">&lt;/c0&gt;</ept>イニシャライザを使うことで、その渡された値が表現可能であるかどうか調べた後に新しいインスタンスを作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Empty<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property to check quickly whether an array has any elements, or use the <bpt i="2" x="2">&lt;c2&gt;</bpt>count<ept i="2">&lt;/c2&gt;</ept> property to find the number of elements in the array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Empty<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティを使って、ある配列が要素を持つかどうか素早く確認してください、または<bpt i="2" x="2">&lt;c2&gt;</bpt>count<ept i="2">&lt;/c2&gt;</ept>を使うことで配列中の要素の数を調べてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>map(_:)<ept i="0">&lt;/c0&gt;</ept> method to transform every element received from a base asynchronous sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>map(_:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使うことで、基底非同期シーケンスから受け取ったあらゆる要素を変換してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>max(by:)<ept i="0">&lt;/c0&gt;</ept> method to determine the index of the day with the most absences.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>max(by:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使って最も欠席者の多い日付のインデックスを判定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>reduce(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method to produce a single value from the elements of an entire sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>reduce(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使って、あるシーケンス全体の要素それらからある単一の値を生成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>reduce(into:<bpt i="1" x="1">&lt;w1&gt;</bpt>_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method to produce a single value from the elements of an entire sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>reduce(into:<bpt i="1" x="1">&lt;w1&gt;</bpt>_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使って、あるシーケンス全体の要素それらからある単一の値を生成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="0" x="0">&lt;c0&gt;</bpt>shuffle()<ept i="0">&lt;/c0&gt;</ept> method to randomly reorder the elements of an array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>shuffle()<ept i="0">&lt;/c0&gt;</ept>メソッドを使って、配列の要素を無作為に再配列してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the <bpt i="2" x="2">&lt;c2&gt;</bpt>capacity<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>count<ept i="3">&lt;/c3&gt;</ept> properties to determine how many more elements the array can store without allocating larger storage.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>capacity<ept i="2">&lt;/c2&gt;</ept>や<bpt i="3" x="3">&lt;c3&gt;</bpt>count<ept i="3">&lt;/c3&gt;</ept>プロパティを使って、より大きなストレージに割り当てることなく更にどのくらいの要素をその配列が格納できるか判定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the array’s <bpt i="0" x="0">&lt;c0&gt;</bpt>capacity<ept i="0">&lt;/c0&gt;</ept> property to determine the size of the new storage.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列の<bpt i="0" x="0">&lt;c0&gt;</bpt>capacity<ept i="0">&lt;/c0&gt;</ept>プロパティを使って新しいストレージの大きさを特定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the casting operators (<bpt i="0" x="0">&lt;c0&gt;</bpt>as<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>as!<ept i="1">&lt;/c1&gt;</ept>, or <bpt i="2" x="2">&lt;c2&gt;</bpt>as?<ept i="2">&lt;/c2&gt;</ept>) or the <bpt i="3" x="3">&lt;c3&gt;</bpt>unsafe<bpt i="4" x="4">&lt;w4&gt;</bpt>Downcast(_:<bpt i="5" x="5">&lt;w5&gt;</bpt>to:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>キャスト演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>as<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>as!<ept i="1">&lt;/c1&gt;</ept>、または<bpt i="2" x="2">&lt;c2&gt;</bpt>as?<ept i="2">&lt;/c2&gt;</ept>）または<bpt i="3" x="3">&lt;c3&gt;</bpt>unsafe<bpt i="4" x="4">&lt;w4&gt;</bpt>Downcast(_:<bpt i="5" x="5">&lt;w5&gt;</bpt>to:)<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>関数を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the closed range operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>...<ept i="0">&lt;/c0&gt;</ept>) to create a closed range of any type that conforms to the <bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>完結範囲演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>...<ept i="0">&lt;/c0&gt;</ept>）を使って<bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>プロトコルに準拠する何らかの型の配列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the destination type’s <bpt i="0" x="0">&lt;c0&gt;</bpt>init(truncating<bpt i="1" x="1">&lt;w1&gt;</bpt>If<bpt i="2" x="2">&lt;w2&gt;</bpt>Needed:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> or <bpt i="3" x="3">&lt;c3&gt;</bpt>init(bit<bpt i="4" x="4">&lt;w4&gt;</bpt>Pattern:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> initializer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>行き先の型のもつ<bpt i="0" x="0">&lt;c0&gt;</bpt>init(truncating<bpt i="1" x="1">&lt;w1&gt;</bpt>If<bpt i="2" x="2">&lt;w2&gt;</bpt>Needed:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>または<bpt i="3" x="3">&lt;c3&gt;</bpt>init(bit<bpt i="4" x="4">&lt;w4&gt;</bpt>Pattern:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>イニシャライザを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the destination type’s initializer or the <bpt i="0" x="0">&lt;c0&gt;</bpt>numeric<bpt i="1" x="1">&lt;w1&gt;</bpt>Cast(_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>行き先の型のもつイニシャライザまたは<bpt i="0" x="0">&lt;c0&gt;</bpt>numeric<bpt i="1" x="1">&lt;w1&gt;</bpt>Cast(_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the half-open range operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>..&lt;<ept i="0">&lt;/c0&gt;</ept>) to create a range of any type that conforms to the <bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>半開範囲演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>..&lt;<ept i="0">&lt;/c0&gt;</ept>）を使って<bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>プロトコルに準拠する何らかの型の配列を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the masking left shift operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;&lt;&lt;<ept i="0">&lt;/c0&gt;</ept>) when you need to perform a shift and are sure that the shift amount is in the range <bpt i="1" x="1">&lt;c1&gt;</bpt>0..<it pos="begin" x="2">&lt;lhs&lt;w2&gt;</it>.bit<bpt i="3" x="3">&lt;w3&gt;</bpt>Width<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>マスク左シフト演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;&lt;&lt;<ept i="0">&lt;/c0&gt;</ept>）を、あなたがあるシフトを実行する、そしてシフト量が範囲<bpt i="1" x="1">&lt;c1&gt;</bpt>0..<it pos="begin" x="2">&lt;lhs&lt;w2&gt;</it>.bit<bpt i="3" x="3">&lt;w3&gt;</bpt>Width<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の中であるのを確実にする必要がある場合に使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the masking right shift operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;&gt;&gt;<ept i="0">&lt;/c0&gt;</ept>) when you need to perform a shift and are sure that the shift amount is in the range <bpt i="1" x="1">&lt;c1&gt;</bpt>0..<it pos="begin" x="2">&lt;lhs&lt;w2&gt;</it>.bit<bpt i="3" x="3">&lt;w3&gt;</bpt>Width<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>マスク右シフト演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&amp;&gt;&gt;<ept i="0">&lt;/c0&gt;</ept>）を、あなたがあるシフトを実行する、そしてシフト量が範囲<bpt i="1" x="1">&lt;c1&gt;</bpt>0..<it pos="begin" x="2">&lt;lhs&lt;w2&gt;</it>.bit<bpt i="3" x="3">&lt;w3&gt;</bpt>Width<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>の中であるのを確実にする必要がある場合に使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the postfix range operator (postfix <bpt i="0" x="0">&lt;c0&gt;</bpt>...<ept i="0">&lt;/c0&gt;</ept>) to create a partial range of any type that conforms to the <bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>後置完結範囲演算子（後置<bpt i="0" x="0">&lt;c0&gt;</bpt>...<ept i="0">&lt;/c0&gt;</ept>）を使うことで何らかの型の部分的な範囲で<bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>プロトコルに準拠するものを作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the prefix closed range operator (prefix <bpt i="0" x="0">&lt;c0&gt;</bpt>...<ept i="0">&lt;/c0&gt;</ept>) to create a partial range of any type that conforms to the <bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>前置完結範囲演算子（前置<bpt i="0" x="0">&lt;c0&gt;</bpt>...<ept i="0">&lt;/c0&gt;</ept>）を使うことで何らかの型の部分的な範囲で<bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>プロトコルに準拠するものを作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use the prefix half-open range operator (prefix <bpt i="0" x="0">&lt;c0&gt;</bpt>..&lt;<ept i="0">&lt;/c0&gt;</ept>) to create a partial range of any type that conforms to the <bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>前置半開範囲演算子（前置<bpt i="0" x="0">&lt;c0&gt;</bpt>..&lt;<ept i="0">&lt;/c0&gt;</ept>）を使うことで何らかの型の部分的な範囲で<bpt i="1" x="1">&lt;c1&gt;</bpt>Comparable<ept i="1">&lt;/c1&gt;</ept>プロトコルに準拠するものを作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this function for internal sanity checks that are active during testing but do not impact performance of shipping code.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この関数を本質的な正常性確認のために使ってください、それはテストの間は活動的ですが出荷コードの性能に影響はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this function instead of <bpt i="0" x="0">&lt;c0&gt;</bpt>unsafe<bpt i="1" x="1">&lt;w1&gt;</bpt>Bitcast(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>to:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> because this function is more restrictive and still performs a check in debug builds.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この関数を<bpt i="0" x="0">&lt;c0&gt;</bpt>unsafe<bpt i="1" x="1">&lt;w1&gt;</bpt>Bitcast(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>to:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>の代わりに使ってください、なぜならこの関数はより制限的で依然としてデバッグビルドにおいて検査を実行するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this function only to convert the instance passed as <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> to a layout-compatible type when conversion through other means is not possible.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この関数を<bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>として渡されるインスタンスをレイアウト互換の型へと、その変換が他の手段では可能でない場合に、変換するのにだけ使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this function to detect conditions that must prevent the program from proceeding, even in shipping code.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この関数を使って、続行することからプログラムを妨げなければならない条件を突き止めてください、出荷コードにおいてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this function to stop the program when control flow can only reach the call if your API was improperly used.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのAPIが誤って使われた場合にその呼び出しに制御の流れが届く時にだけこの関数を使ってプログラムを停止してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this function to stop the program, without impacting the performance of shipping code, when control flow is not expected to reach the call—for example, in the <bpt i="0" x="0">&lt;c0&gt;</bpt>default<ept i="0">&lt;/c0&gt;</ept> case of a <bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept> where you have knowledge that one of the other cases must be satisfied.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この関数を使って、制御の流れが呼び出しに届くと予想されない場合に、出荷コードの性能に影響を与えることなく、プログラムを停止してください—例えば、<bpt i="1" x="1">&lt;c1&gt;</bpt>switch<ept i="1">&lt;/c1&gt;</ept>の<bpt i="0" x="0">&lt;c0&gt;</bpt>default<ept i="0">&lt;/c0&gt;</ept>ケース節において、そこにおいてあなたはそれ以前のケース節の１つが満たされなければならないことがわかっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this initializer around a range instead of typing all those numbers in an array literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それらの数をすべて配列リテラルの中にタイプするの代わりに、ある範囲を取り囲むようにこのイニシャライザを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this initializer to avoid intermediate reallocations of a dictionary’s storage buffer when you know how many key-value pairs you are adding to a dictionary after creation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>どのくらい多くのキー値ペアをあなたが辞書に加えることになるかあなたが知っている場合は、このイニシャライザを使ってある辞書の持つストレージバッファの幾度もの中間的な再割り当てを回避してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this initializer to convert from another integer type when you know the value is within the bounds of this type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザを使って別の整数型から変換してください、値がこの型の境界の内部であるのをあなたが知っている場合は。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this initializer to create a Boolean by converting an <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> with an underlying type of <bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザを使ってブールを作成してください、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>をある基礎をなす型の<bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>で変換することによって</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this initializer to create a double by converting an <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> with an underlying type of <bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>Double<ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザを使ってdoubleを作成してください、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>をある基礎をなす型の<bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>Double<ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>で変換することによって</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this initializer to create an array by converting an <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> with an underlying type of <bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>MLData<bpt i="5" x="5">&lt;w5&gt;</bpt>Value<bpt i="6" x="6">&lt;w6&gt;</bpt>.Dictionary<bpt i="7" x="7">&lt;w7&gt;</bpt>Type<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザを使って配列を作成してください、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>をある基礎をなす型の<bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>MLData<bpt i="5" x="5">&lt;w5&gt;</bpt>Value<bpt i="6" x="6">&lt;w6&gt;</bpt>.Dictionary<bpt i="7" x="7">&lt;w7&gt;</bpt>Type<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>で変換することによって。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this initializer to create an array by converting an <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> with an underlying type of <bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>MLData<bpt i="5" x="5">&lt;w5&gt;</bpt>Value<bpt i="6" x="6">&lt;w6&gt;</bpt>.Sequence<bpt i="7" x="7">&lt;w7&gt;</bpt>Type<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザを使って配列を作成してください、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>をある基礎をなす型の<bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>MLData<bpt i="5" x="5">&lt;w5&gt;</bpt>Value<bpt i="6" x="6">&lt;w6&gt;</bpt>.Sequence<bpt i="7" x="7">&lt;w7&gt;</bpt>Type<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>で変換することによって</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this initializer to create an array by converting an <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<bpt i="3" x="3">&lt;w3&gt;</bpt>.Dictionary<bpt i="4" x="4">&lt;w4&gt;</bpt>Type<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザを使って配列を作成してください、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<bpt i="3" x="3">&lt;w3&gt;</bpt>.Dictionary<bpt i="4" x="4">&lt;w4&gt;</bpt>Type<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>を変換することによって。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this initializer to create an integer by converting an <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept> with an underlying type of <bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザを使って整数を作成してください、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>MLData<bpt i="2" x="2">&lt;w2&gt;</bpt>Value<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>をある基礎をなす型の<bpt i="3" x="3">&lt;a3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>Int<ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/a3&gt;</ept>で変換することによって</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method instead of key-based subscripting when you need to know whether the new value supplants the value of an existing key.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>新しい値が既存のキーの値に取って代わるかどうかをあなたが知る必要がある場合は、キーに基づく添え字を使うのではなくこのメソッドを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method only if you need the concrete range it produces.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それが生成する具体的な範囲をあなたが必要とする場合にのみ、このメソッドを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method to append a single element to the end of a mutable array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを使ってある単一の要素を可変の配列の終わりに加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method to append the elements of a sequence to the end of this array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを使うことで、あるシーケンスに属する要素をこの配列の終わりに追加してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method to calculate the full result of a product that would otherwise overflow.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを使うことで、そうしなければオーバーフローするであろう積の完全な結果を計算してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method to calculate the quotient and remainder of a division at the same time.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを使って、除算の商と余りを同時に計算してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method to extend this key path to the value type of another key path.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを使うことで、このキーパスを別のキーパスの値型にまで広げてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method to generate a floating-point value within a specific range when you are using a custom random number generator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを使って、あなたがあつらえの無作為数生成子を使っている場合に、特定の範囲の内のある浮動小数点値を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method to generate a floating-point value within a specific range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを使って、特定の範囲の内のある浮動小数点値を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method to generate a random Boolean value when you are using a custom random number generator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはこのメソッドを使って、あなたがあつらえの無作為数生成子を使っている場合に、無作為なブール値を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method to generate an integer within a specific range when you are using a custom random number generator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを使って、あなたがあつらえの無作為数生成子を使っている場合に、特定の範囲の内のある整数を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method to generate an integer within a specific range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを使って、特定の範囲の内のある整数を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method to receive a dictionary with non-optional values when your transformation produces optional values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを使うことで非オプショナル値での辞書を受け取ってください、あなたの変換がオプショナル値を生成する時に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method to receive a single-level asynchronous sequence when your transformation produces an asynchronous sequence for each element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを使って、単一階層の非同期シーケンスを受け取ってください、あなたの変換が各要素に対してひとつの非同期シーケンスを生み出す時は。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method to receive a single-level collection when your transformation produces a sequence or collection for each element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたの変換が各要素に対してひとつのシーケンスまたはコレクションを生成する場合に、このメソッドを使って単一水準コレクションを受け取ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method to receive an array of non-optional values when your transformation produces an optional value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを使うことで非オプショナル値の配列を受け取ってください、あなたの変換がオプショナル値を生成する時に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method to receive an array of nonoptional values when your transformation produces an optional value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたの変換がオプショナル値を生成する場合に、このメソッドを使って非オプショナル値からなる配列を受け取ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method to remove every element in a collection that meets particular criteria.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを使って、コレクションの中の、特定の基準に合うすべての要素を除去してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method to toggle a Boolean value from <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> to <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept> or from <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept> to <bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを使って、ブール値を<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>から<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>へとまたは<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>から<bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept>へと切り替えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this method when the asynchronous sequence’s values don’t conform to <bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept>, or when you want to apply a custom ordering to the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを、非同期シーケンスのもつ値それらが<bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept>に準拠しない時に、またはあなたがあるあつらえの順序付けをそのシーケンスに適用したい時に使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this operator to append the elements of a sequence to the end of range-replaceable collection with same <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この演算子を使って、あるシーケンスに属するいくらかの要素を同じ<bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>型を持つ範囲置換可能なコレクションの終わりに加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use this subscript when you want either the value for a particular key or, when that key is not present in the dictionary, a default value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが特定のキーに対する値または、そのキーが辞書の中に存在しない時、省略時の値のどちらかを望む場合は、この添え字を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>User-Relevant Errors</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ユーザ関連のエラー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using Delegates to Customize Object Behavior</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>委任先を使ってオブジェクト挙動をカスタマイズする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using Enumerations as Errors</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>列挙をエラーとして使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using Imported Boolean values</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インポートされたブール値を使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using Imported C Functions in Swift</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インポートされたC関数をSwiftで使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using Imported C Macros in Swift</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インポートされたCマクロをSwiftで使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using Imported C Structs and Unions in Swift</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インポートされたC構造体と共用体をSwiftで使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using Imported Lightweight Generics in Swift</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インポートされた軽量総称体をSwiftにおいて使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using Imported Protocol-Qualified Classes in Swift</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>インポートされたプロトコル適格クラスをSwiftにおいて使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using Key-Value Observing in Swift</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftにおいてキー値監視を使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using Objective-C Runtime Features in Swift</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-Cランタイム機能をSwiftで使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using a Boolean as a Data Value</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ブール値をデータ値として使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using a Closed Range as a Collection of Consecutive Values</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>完結範囲を隣接値のコレクションとして使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using a Dictionary as a Data Value</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書をデータ値として使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using a Double as a Data Value</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>不動小数点数をデータ値として使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using a negative number or an index equal to or greater than <bpt i="0" x="0">&lt;c0&gt;</bpt>count<ept i="0">&lt;/c0&gt;</ept> triggers a runtime error.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>負数をまたは<bpt i="0" x="0">&lt;c0&gt;</bpt>count<ept i="0">&lt;/c0&gt;</ept>と等しいかより大きいインデックスを使うことは、実行時エラーを引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using a negative value as <bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept> is the same as performing a left shift using <bpt i="1" x="1">&lt;c1&gt;</bpt>abs(rhs)<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept>として負の値を使うことは、<bpt i="1" x="1">&lt;c1&gt;</bpt>abs(rhs)<ept i="1">&lt;/c1&gt;</ept>を使って左シフトを実行するのと同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using a negative value as <bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept> is the same as performing a right shift with <bpt i="1" x="1">&lt;c1&gt;</bpt>abs(rhs)<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>負の値を<bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept>として使うことは、<bpt i="1" x="1">&lt;c1&gt;</bpt>abs(rhs)<ept i="1">&lt;/c1&gt;</ept>を使って右シフトを実行するのと同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using a negative value for <bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept> performs a left shift using <bpt i="1" x="1">&lt;c1&gt;</bpt>abs(rhs)<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept>に負の値を使うことは、<bpt i="1" x="1">&lt;c1&gt;</bpt>abs(rhs)<ept i="1">&lt;/c1&gt;</ept>を使って左シフトを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using a negative value for <bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept> performs a right shift using <bpt i="1" x="1">&lt;c1&gt;</bpt>abs(rhs)<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept>に負の値を使うことは、<bpt i="1" x="1">&lt;c1&gt;</bpt>abs(rhs)<ept i="1">&lt;/c1&gt;</ept>を使って右シフトを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using a value for <bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept> that is greater than or equal to the bit width of <bpt i="1" x="1">&lt;c1&gt;</bpt>lhs<ept i="1">&lt;/c1&gt;</ept> is an <bpt i="2" x="2">&lt;e2&gt;</bpt>overshift<ept i="2">&lt;/e2&gt;</ept>, resulting in zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept>に<bpt i="1" x="1">&lt;c1&gt;</bpt>lhs<ept i="1">&lt;/c1&gt;</ept>のビット幅より大きいか等しい値を使うことは、<bpt i="2" x="2">&lt;e2&gt;</bpt>オーバーシフト<ept i="2">&lt;/e2&gt;</ept>、ゼロという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using a value for <bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept> that is greater than or equal to the bit width of <bpt i="1" x="1">&lt;c1&gt;</bpt>lhs<ept i="1">&lt;/c1&gt;</ept> is an <bpt i="2" x="2">&lt;e2&gt;</bpt>overshift<ept i="2">&lt;/e2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept>に<bpt i="1" x="1">&lt;c1&gt;</bpt>lhs<ept i="1">&lt;/c1&gt;</ept>のビット幅より大きいか等しい値を使うことは、<bpt i="2" x="2">&lt;e2&gt;</bpt>オーバーシフト<ept i="2">&lt;/e2&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using an Integer as a Data Value</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>整数をデータ値として使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using any other value for <bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept> performs a left shift on <bpt i="1" x="1">&lt;c1&gt;</bpt>lhs<ept i="1">&lt;/c1&gt;</ept> by that amount.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept>に何か他の値を使うことは、左シフトを<bpt i="1" x="1">&lt;c1&gt;</bpt>lhs<ept i="1">&lt;/c1&gt;</ept>上でその量だけ行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using any other value for <bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept> performs a right shift on <bpt i="1" x="1">&lt;c1&gt;</bpt>lhs<ept i="1">&lt;/c1&gt;</ept> by that amount.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>rhs<ept i="0">&lt;/c0&gt;</ept>に何か他の値を使うことは、右シフトを<bpt i="1" x="1">&lt;c1&gt;</bpt>lhs<ept i="1">&lt;/c1&gt;</ept>上でその量だけ行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using different groups of properties in the two methods can lead to unexpected behavior or performance when using your custom type in sets and dictionaries.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>異なるプロパティのグループを２つのメソッドにおいて使うことは、あなたのカスタム型を集合および辞書で使う場合に、予期しない挙動または性能に導きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using structures makes it easier to reason about a portion of your code without needing to consider the whole state of your app.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>構造体を使うことは、あなたのアプリの全体の状態を考える必要なしに、あなたのコードの一部について結論を下すことを簡単にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using the <bpt i="0" x="0">&lt;c0&gt;</bpt>for<bpt i="1" x="1">&lt;w1&gt;</bpt>Each<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method is distinct from a <bpt i="2" x="2">&lt;c2&gt;</bpt>for<ept i="2">&lt;/c2&gt;</ept>-<bpt i="3" x="3">&lt;c3&gt;</bpt>in<ept i="3">&lt;/c3&gt;</ept> loop in two important ways:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>for<bpt i="1" x="1">&lt;w1&gt;</bpt>Each<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使うことは、<bpt i="2" x="2">&lt;c2&gt;</bpt>for<ept i="2">&lt;/c2&gt;</ept>-<bpt i="3" x="3">&lt;c3&gt;</bpt>in<ept i="3">&lt;/c3&gt;</ept>ループとは２つの重要なやり方においてまったく異なります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using the <bpt i="0" x="0">&lt;c0&gt;</bpt>prefix(through:)<ept i="0">&lt;/c0&gt;</ept> method is equivalent to using a partial closed range as the collection’s subscript.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>prefix(through:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使うことは、部分的な完結範囲をコレクションのもつ添え字として使うことと同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using the <bpt i="0" x="0">&lt;c0&gt;</bpt>prefix(up<bpt i="1" x="1">&lt;w1&gt;</bpt>To:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method is equivalent to using a partial half-open range as the collection’s subscript.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>prefix(up<bpt i="1" x="1">&lt;w1&gt;</bpt>To:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使うことは、部分的な半開範囲をコレクションのもつ添え字として使うことと同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using the <bpt i="0" x="0">&lt;c0&gt;</bpt>return<ept i="0">&lt;/c0&gt;</ept> statement in the <bpt i="1" x="1">&lt;c1&gt;</bpt>body<ept i="1">&lt;/c1&gt;</ept> closure will exit only from the current call to <bpt i="2" x="2">&lt;c2&gt;</bpt>body<ept i="2">&lt;/c2&gt;</ept>, not from any outer scope, and won’t skip subsequent calls.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>return<ept i="0">&lt;/c0&gt;</ept>文を<bpt i="1" x="1">&lt;c1&gt;</bpt>body<ept i="1">&lt;/c1&gt;</ept>クロージャにおいて使うことは、ただ現在の<bpt i="2" x="2">&lt;c2&gt;</bpt>body<ept i="2">&lt;/c2&gt;</ept>への呼び出しから抜け出すだけです、全く外側のスコープからではなくて、そして続いて起こる呼び出しを飛ばしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using the <bpt i="0" x="0">&lt;c0&gt;</bpt>suffix(from:)<ept i="0">&lt;/c0&gt;</ept> method is equivalent to using a partial range from the index as the collection’s subscript.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>suffix(from:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使うことは、インデックスからの部分的範囲をコレクションのもつ添え字として使うことと同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using the closed range operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>...<ept i="2">&lt;/c2&gt;</ept>) to form <bpt i="3" x="3">&lt;c3&gt;</bpt>Closed<bpt i="4" x="4">&lt;w4&gt;</bpt>Range<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> instances is preferred.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>完結範囲演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>...<ept i="2">&lt;/c2&gt;</ept>）を使って<bpt i="3" x="3">&lt;c3&gt;</bpt>Closed<bpt i="4" x="4">&lt;w4&gt;</bpt>Range<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>インスタンスを形成することが推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using this method with types that have a noninteger <bpt i="9" x="9">&lt;c9&gt;</bpt>Stride<ept i="9">&lt;/c9&gt;</ept> may result in an approximation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このメソッドを非整数<bpt i="9" x="9">&lt;c9&gt;</bpt>Stride<ept i="9">&lt;/c9&gt;</ept>を持つ型とともに使うことは、近似値という結果になるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Valid indices consist of the position of every element and a “past the end” position that’s not valid for use as a subscript argument.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>有効なインデックスは、各要素の位置、および添え字引数として使うのに有効でない“終わりを過ぎた”位置から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Valid indices consist of the position of every element and a “past the end” position that’s not valid for use as a subscript.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>有効なインデックスは、各要素の位置、および添え字として使うのに有効でない“終わりを過ぎた”位置から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Valid types for <bpt i="0" x="0">&lt;c0&gt;</bpt>Extended<bpt i="1" x="1">&lt;w1&gt;</bpt>Grapheme<bpt i="2" x="2">&lt;w2&gt;</bpt>Cluster<bpt i="3" x="3">&lt;w3&gt;</bpt>Literal<bpt i="4" x="4">&lt;w4&gt;</bpt>Type<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> are <bpt i="5" x="5">&lt;c5&gt;</bpt>Character<ept i="5">&lt;/c5&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>String<ept i="6">&lt;/c6&gt;</ept>, and <bpt i="7" x="7">&lt;c7&gt;</bpt>Static<bpt i="8" x="8">&lt;w8&gt;</bpt>String<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Extended<bpt i="1" x="1">&lt;w1&gt;</bpt>Grapheme<bpt i="2" x="2">&lt;w2&gt;</bpt>Cluster<bpt i="3" x="3">&lt;w3&gt;</bpt>Literal<bpt i="4" x="4">&lt;w4&gt;</bpt>Type<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して有効な型は、<bpt i="5" x="5">&lt;c5&gt;</bpt>Character<ept i="5">&lt;/c5&gt;</ept>、<bpt i="6" x="6">&lt;c6&gt;</bpt>String<ept i="6">&lt;/c6&gt;</ept>、そして<bpt i="7" x="7">&lt;c7&gt;</bpt>Static<bpt i="8" x="8">&lt;w8&gt;</bpt>String<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Valid types for <bpt i="0" x="0">&lt;c0&gt;</bpt>Float<bpt i="1" x="1">&lt;w1&gt;</bpt>Literal<bpt i="2" x="2">&lt;w2&gt;</bpt>Type<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> are <bpt i="3" x="3">&lt;c3&gt;</bpt>Float<ept i="3">&lt;/c3&gt;</ept>, <bpt i="4" x="4">&lt;c4&gt;</bpt>Double<ept i="4">&lt;/c4&gt;</ept>, and <bpt i="5" x="5">&lt;c5&gt;</bpt>Float80<ept i="5">&lt;/c5&gt;</ept> where available.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Float<bpt i="1" x="1">&lt;w1&gt;</bpt>Literal<bpt i="2" x="2">&lt;w2&gt;</bpt>Type<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対して有効な型は、<bpt i="3" x="3">&lt;c3&gt;</bpt>Float<ept i="3">&lt;/c3&gt;</ept>、<bpt i="4" x="4">&lt;c4&gt;</bpt>Double<ept i="4">&lt;/c4&gt;</ept>、そして利用可能なところでは<bpt i="5" x="5">&lt;c5&gt;</bpt>Float80<ept i="5">&lt;/c5&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Valid types for <bpt i="0" x="0">&lt;c0&gt;</bpt>String<bpt i="1" x="1">&lt;w1&gt;</bpt>Literal<bpt i="2" x="2">&lt;w2&gt;</bpt>Type<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> are <bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>Static<bpt i="5" x="5">&lt;w5&gt;</bpt>String<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>String<bpt i="1" x="1">&lt;w1&gt;</bpt>Literal<bpt i="2" x="2">&lt;w2&gt;</bpt>Type<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対する有効な型は、<bpt i="3" x="3">&lt;c3&gt;</bpt>String<ept i="3">&lt;/c3&gt;</ept>と<bpt i="4" x="4">&lt;c4&gt;</bpt>Static<bpt i="5" x="5">&lt;w5&gt;</bpt>String<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Valid types for <bpt i="0" x="0">&lt;c0&gt;</bpt>Unicode<bpt i="1" x="1">&lt;w1&gt;</bpt>Scalar<bpt i="2" x="2">&lt;w2&gt;</bpt>Literal<bpt i="3" x="3">&lt;w3&gt;</bpt>Type<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> are <bpt i="4" x="4">&lt;c4&gt;</bpt>Unicode<bpt i="5" x="5">&lt;w5&gt;</bpt>.Scalar<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>, <bpt i="6" x="6">&lt;c6&gt;</bpt>Character<ept i="6">&lt;/c6&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt>String<ept i="7">&lt;/c7&gt;</ept>, and <bpt i="8" x="8">&lt;c8&gt;</bpt>Static<bpt i="9" x="9">&lt;w9&gt;</bpt>String<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Unicode<bpt i="1" x="1">&lt;w1&gt;</bpt>Scalar<bpt i="2" x="2">&lt;w2&gt;</bpt>Literal<bpt i="3" x="3">&lt;w3&gt;</bpt>Type<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>に対する有効な型は、<bpt i="4" x="4">&lt;c4&gt;</bpt>Unicode<bpt i="5" x="5">&lt;w5&gt;</bpt>.Scalar<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>、<bpt i="6" x="6">&lt;c6&gt;</bpt>Character<ept i="6">&lt;/c6&gt;</ept>、<bpt i="7" x="7">&lt;c7&gt;</bpt>String<ept i="7">&lt;/c7&gt;</ept>、そして<bpt i="8" x="8">&lt;c8&gt;</bpt>Static<bpt i="9" x="9">&lt;w9&gt;</bpt>String<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/c8&gt;</ept>です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Value</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Value Literals</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値リテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Value conversion from one integer type to another.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある整数型から別のものへの値変換。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Values can be yielded in case to the continuation passed into the build closure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値それらは、ビルドクロージャに渡される継続に備えて生み出されることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Visible side effects are therefore strongly discouraged within this property.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>目に見える副作用は、それゆえにこのプロパティ内では強く反対されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Warning</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>警告</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When <bpt i="0" x="0">&lt;c0&gt;</bpt>error<ept i="0">&lt;/c0&gt;</ept> is an empty string, <bpt i="1" x="1">&lt;c1&gt;</bpt>lhs<ept i="1">&lt;/c1&gt;</ept> evaluates to <bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>rhs<ept i="3">&lt;/c3&gt;</ept> is not evaluated, skipping the call to <bpt i="4" x="4">&lt;c4&gt;</bpt>major<bpt i="5" x="5">&lt;w5&gt;</bpt>Errors<bpt i="6" x="6">&lt;w6&gt;</bpt>.contains(_:)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>error<ept i="0">&lt;/c0&gt;</ept>が空の文字列である時、<bpt i="1" x="1">&lt;c1&gt;</bpt>lhs<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>true<ept i="2">&lt;/c2&gt;</ept>に評価して、<bpt i="3" x="3">&lt;c3&gt;</bpt>rhs<ept i="3">&lt;/c3&gt;</ept>は評価されず、<bpt i="4" x="4">&lt;c4&gt;</bpt>major<bpt i="5" x="5">&lt;w5&gt;</bpt>Errors<bpt i="6" x="6">&lt;w6&gt;</bpt>.contains(_:)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>への呼び出しを省きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When <bpt i="0" x="0">&lt;c0&gt;</bpt>error<ept i="0">&lt;/c0&gt;</ept> is not an empty string, <bpt i="1" x="1">&lt;c1&gt;</bpt>lhs<ept i="1">&lt;/c1&gt;</ept> evaluates to <bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>rhs<ept i="3">&lt;/c3&gt;</ept> is evaluated.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>error<ept i="0">&lt;/c0&gt;</ept>が空の文字列ではない時、<bpt i="1" x="1">&lt;c1&gt;</bpt>lhs<ept i="1">&lt;/c1&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>false<ept i="2">&lt;/c2&gt;</ept>に評価して、<bpt i="3" x="3">&lt;c3&gt;</bpt>rhs<ept i="3">&lt;/c3&gt;</ept>は評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When <bpt i="0" x="0">&lt;c0&gt;</bpt>letter<bpt i="1" x="1">&lt;w1&gt;</bpt>Counts[letter, default: 0] += 1<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is executed with a value of <bpt i="2" x="2">&lt;c2&gt;</bpt>letter<ept i="2">&lt;/c2&gt;</ept> that isn’t already a key in <bpt i="3" x="3">&lt;c3&gt;</bpt>letter<bpt i="4" x="4">&lt;w4&gt;</bpt>Counts<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>, the specified default value (<bpt i="5" x="5">&lt;c5&gt;</bpt>0<ept i="5">&lt;/c5&gt;</ept>) is returned from the subscript, incremented, and then added to the dictionary under that key.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>letter<bpt i="1" x="1">&lt;w1&gt;</bpt>Counts[letter, default: 0] += 1<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が<bpt i="2" x="2">&lt;c2&gt;</bpt>letter<ept i="2">&lt;/c2&gt;</ept>の値でまだ<bpt i="3" x="3">&lt;c3&gt;</bpt>letter<bpt i="4" x="4">&lt;w4&gt;</bpt>Counts<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>の中のキーでないものと実行される場合、指定された値（<bpt i="5" x="5">&lt;c5&gt;</bpt>0<ept i="5">&lt;/c5&gt;</ept>）が添え字から返されて、漸増されて、それから辞書へとそのキーのもと追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When <bpt i="0" x="0">&lt;c0&gt;</bpt>letters<bpt i="1" x="1">&lt;w1&gt;</bpt>.reduce(into:<bpt i="2" x="2">&lt;w2&gt;</bpt>_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is called, the following steps occur:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>letters<bpt i="1" x="1">&lt;w1&gt;</bpt>.reduce(into:<bpt i="2" x="2">&lt;w2&gt;</bpt>_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が呼び出される時、以下の段階が生じます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When <bpt i="0" x="0">&lt;c0&gt;</bpt>measurements<bpt i="1" x="1">&lt;w1&gt;</bpt>.count<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is equal to zero, <bpt i="2" x="2">&lt;c2&gt;</bpt>lhs<ept i="2">&lt;/c2&gt;</ept> evaluates to <bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>rhs<ept i="4">&lt;/c4&gt;</ept> is not evaluated, preventing a divide-by-zero error in the expression <bpt i="5" x="5">&lt;c5&gt;</bpt>sum / Double(measurements<bpt i="6" x="6">&lt;w6&gt;</bpt>.count)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>measurements<bpt i="1" x="1">&lt;w1&gt;</bpt>.count<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>がゼロに等しい時、<bpt i="2" x="2">&lt;c2&gt;</bpt>lhs<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>false<ept i="3">&lt;/c3&gt;</ept>に評価して、<bpt i="4" x="4">&lt;c4&gt;</bpt>rhs<ept i="4">&lt;/c4&gt;</ept>は評価されず、式<bpt i="5" x="5">&lt;c5&gt;</bpt>sum / Double(measurements<bpt i="6" x="6">&lt;w6&gt;</bpt>.count)<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>でのゼロによる除算を防ぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When <bpt i="0" x="0">&lt;c0&gt;</bpt>measurements<bpt i="1" x="1">&lt;w1&gt;</bpt>.count<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is greater than zero, <bpt i="2" x="2">&lt;c2&gt;</bpt>lhs<ept i="2">&lt;/c2&gt;</ept> evaluates to <bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept> and <bpt i="4" x="4">&lt;c4&gt;</bpt>rhs<ept i="4">&lt;/c4&gt;</ept> is evaluated.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>measurements<bpt i="1" x="1">&lt;w1&gt;</bpt>.count<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>がゼロより大きい時、<bpt i="2" x="2">&lt;c2&gt;</bpt>lhs<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>true<ept i="3">&lt;/c3&gt;</ept>に評価して、<bpt i="4" x="4">&lt;c4&gt;</bpt>rhs<ept i="4">&lt;/c4&gt;</ept>は評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When <bpt i="0" x="0">&lt;c0&gt;</bpt>numbers<bpt i="1" x="1">&lt;w1&gt;</bpt>.reduce(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> is called, the following steps occur:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>numbers<bpt i="1" x="1">&lt;w1&gt;</bpt>.reduce(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>_:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>が呼び出される時、以下の段階が生じます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When <bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept> is passed, the label is omitted.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="1" x="1">&lt;c1&gt;</bpt>nil<ept i="1">&lt;/c1&gt;</ept>が渡される場合、ラベルは省かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When <bpt i="2" x="2">&lt;c2&gt;</bpt>count<ept i="2">&lt;/c2&gt;</ept> is passed to the <bpt i="3" x="3">&lt;c3&gt;</bpt>print<bpt i="4" x="4">&lt;w4&gt;</bpt>Info(_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> function, however, the <bpt i="5" x="5">&lt;c5&gt;</bpt>value<ept i="5">&lt;/c5&gt;</ept> parameter has a static type of <bpt i="6" x="6">&lt;c6&gt;</bpt>Any<ept i="6">&lt;/c6&gt;</ept> (the type declared for the parameter) and a dynamic type of <bpt i="7" x="7">&lt;c7&gt;</bpt>Int<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>count<ept i="2">&lt;/c2&gt;</ept>が<bpt i="3" x="3">&lt;c3&gt;</bpt>print<bpt i="4" x="4">&lt;w4&gt;</bpt>Info(_:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>関数に渡される場合は、しかしながら、<bpt i="5" x="5">&lt;c5&gt;</bpt>value<ept i="5">&lt;/c5&gt;</ept>パラメータは<bpt i="6" x="6">&lt;c6&gt;</bpt>Any<ept i="6">&lt;/c6&gt;</ept>の静的型（このパラメータに対して宣言された型）そして<bpt i="7" x="7">&lt;c7&gt;</bpt>Int<ept i="7">&lt;/c7&gt;</ept>の動的型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When <bpt i="4" x="4">&lt;c4&gt;</bpt>id<ept i="4">&lt;/c4&gt;</ept> values are imported into Swift as <bpt i="5" x="5">&lt;c5&gt;</bpt>Any<ept i="5">&lt;/c5&gt;</ept>, the runtime automatically handles bridging back to either class references or value types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="4" x="4">&lt;c4&gt;</bpt>id<ept i="4">&lt;/c4&gt;</ept>値がスウィフトへ<bpt i="5" x="5">&lt;c5&gt;</bpt>Any<ept i="5">&lt;/c5&gt;</ept>としてインポートされる時、ランタイムはクラス参照または値型のどちらかへの逆のブリッジを自動的に取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When <bpt i="5" x="5">&lt;c5&gt;</bpt>not<bpt i="6" x="6">&lt;w6&gt;</bpt>So<bpt i="7" x="7">&lt;w7&gt;</bpt>Good<bpt i="8" x="8">&lt;w8&gt;</bpt>Number<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> is initialized, <bpt i="9" x="9">&lt;c9&gt;</bpt>Int("invalid-input")<ept i="9">&lt;/c9&gt;</ept> fails and returns <bpt i="10" x="10">&lt;c10&gt;</bpt>nil<ept i="10">&lt;/c10&gt;</ept>, and so <bpt i="11" x="11">&lt;c11&gt;</bpt>Int("42")<ept i="11">&lt;/c11&gt;</ept> is called to supply a default value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>not<bpt i="6" x="6">&lt;w6&gt;</bpt>So<bpt i="7" x="7">&lt;w7&gt;</bpt>Good<bpt i="8" x="8">&lt;w8&gt;</bpt>Number<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>が初期化されるとき、<bpt i="9" x="9">&lt;c9&gt;</bpt>Int("invalid-input")<ept i="9">&lt;/c9&gt;</ept>は失敗して<bpt i="10" x="10">&lt;c10&gt;</bpt>nil<ept i="10">&lt;/c10&gt;</ept>を返します、そうすると<bpt i="11" x="11">&lt;c11&gt;</bpt>Int("42")<ept i="11">&lt;/c11&gt;</ept>が呼び出されて省略時の値を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When <bpt i="5" x="5">&lt;c5&gt;</bpt>not<bpt i="6" x="6">&lt;w6&gt;</bpt>So<bpt i="7" x="7">&lt;w7&gt;</bpt>Good<bpt i="8" x="8">&lt;w8&gt;</bpt>Number<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> is initialized, <bpt i="9" x="9">&lt;c9&gt;</bpt>Int("invalid-input")<ept i="9">&lt;/c9&gt;</ept> fails and returns <bpt i="10" x="10">&lt;c10&gt;</bpt>nil<ept i="10">&lt;/c10&gt;</ept>, and so the <bpt i="11" x="11">&lt;c11&gt;</bpt>get<bpt i="12" x="12">&lt;w12&gt;</bpt>Default()<ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> method is called to supply a default value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>not<bpt i="6" x="6">&lt;w6&gt;</bpt>So<bpt i="7" x="7">&lt;w7&gt;</bpt>Good<bpt i="8" x="8">&lt;w8&gt;</bpt>Number<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>が初期化されるとき、<bpt i="9" x="9">&lt;c9&gt;</bpt>Int("invalid-input")<ept i="9">&lt;/c9&gt;</ept>は失敗して<bpt i="10" x="10">&lt;c10&gt;</bpt>nil<ept i="10">&lt;/c10&gt;</ept>を返します、そうすると<bpt i="11" x="11">&lt;c11&gt;</bpt>get<bpt i="12" x="12">&lt;w12&gt;</bpt>Default()<ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>メソッドが呼び出されて省略時の値を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When <bpt i="5" x="5">&lt;c5&gt;</bpt>print<bpt i="6" x="6">&lt;w6&gt;</bpt>Generic<bpt i="7" x="7">&lt;w7&gt;</bpt>Info(_:)<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> is called with a string that has <bpt i="8" x="8">&lt;c8&gt;</bpt>P<ept i="8">&lt;/c8&gt;</ept> as its static type, the call to <bpt i="9" x="9">&lt;c9&gt;</bpt>type(of:)<ept i="9">&lt;/c9&gt;</ept> returns <bpt i="10" x="10">&lt;c10&gt;</bpt>P<bpt i="11" x="11">&lt;w11&gt;</bpt>.self<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept> instead of <bpt i="12" x="12">&lt;c12&gt;</bpt>String<bpt i="13" x="13">&lt;w13&gt;</bpt>.self<ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/c12&gt;</ept> (the dynamic type inside the parameter).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="5" x="5">&lt;c5&gt;</bpt>print<bpt i="6" x="6">&lt;w6&gt;</bpt>Generic<bpt i="7" x="7">&lt;w7&gt;</bpt>Info(_:)<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>が、<bpt i="8" x="8">&lt;c8&gt;</bpt>P<ept i="8">&lt;/c8&gt;</ept>をそれの静的型として持つ文字列とともに呼ばれる時、<bpt i="9" x="9">&lt;c9&gt;</bpt>type(of:)<ept i="9">&lt;/c9&gt;</ept>への呼び出しは<bpt i="10" x="10">&lt;c10&gt;</bpt>P<bpt i="11" x="11">&lt;w11&gt;</bpt>.self<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept>を返します、<bpt i="12" x="12">&lt;c12&gt;</bpt>String<bpt i="13" x="13">&lt;w13&gt;</bpt>.self<ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/c12&gt;</ept>（パラメータの内部の動的型）ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When Swift code imports Objective-C APIs, the importer replaces Foundation reference types with their corresponding value types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>SwiftコードがObjective-C APIをインポートする場合、インポータはFoundation参照型をそれらの対応する値型で置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When Swift imports APIs that have not been annotated, the compiler cannot automatically memory-manage the returned Core Foundation objects.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>注釈をつけられなかったAPIをSwiftがインポートする場合、コンパイラは返されたCore Foundationオブジェクトを自動的にメモリ管理できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When Swift imports Core Foundation types, the compiler remaps the names of these types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>スウィフトがCore Foundation型をインポートするとき、コンパイラはこれらの型の名前をリマップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When a closed range uses integers as its lower and upper bounds, or any other type that conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Strideable<ept i="0">&lt;/c0&gt;</ept> protocol with an integer stride, you can use that range in a <bpt i="1" x="1">&lt;c1&gt;</bpt>for<ept i="1">&lt;/c1&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt>in<ept i="2">&lt;/c2&gt;</ept> loop or with any sequence or collection method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある完結範囲がそれの下側および上側の境界として整数を使う、または整数歩幅を使う<bpt i="0" x="0">&lt;c0&gt;</bpt>Strideable<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する何らかの他の型を使う場合、あなたはその範囲を<bpt i="1" x="1">&lt;c1&gt;</bpt>for<ept i="1">&lt;/c1&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt>in<ept i="2">&lt;/c2&gt;</ept>ループにおいて、または何らかのシーケンスまたはコレクションのメソッドで使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When a dictionary outgrows its buffer, existing indices may be invalidated without any notification.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書がそれのバッファより大きくなる時、既存のインデックスは何の通知もなしに無効にされるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When a dictionary’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Value<ept i="0">&lt;/c0&gt;</ept> type has value semantics, you can use this subscript to perform in-place operations on values in the dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある辞書の持つ<bpt i="0" x="0">&lt;c0&gt;</bpt>Value<ept i="0">&lt;/c0&gt;</ept>型が値意味論を持つ場合、あなたはこの添え字を使うことで、辞書の中の値の上でその場での演算を実行できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When a value is successfully enqueued, either buffered or immediately consumed to resume a pending call to next and a count of remaining slots available in the buffer at the point in time of yielding.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある値が成功裏に待ち行列に入れられる時、nextへの未解決の呼び出しを再開するためにバッファしたか直ちに消費したかどちらか、そして生み出す時点でバッファにおいて利用可能な残りの投入口の総数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When accessing a computed property corresponding to a bit field, Swift automatically converts the value to and from compatible Swift types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるビットフィールドに対応している計算プロパティにアクセスするとき、スウィフトはその値を自動的に互換性のあるスウィフト型へと、またはそれから、変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When an array has additional capacity and is not sharing its storage with another instance, appending an element is O(1).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列がさらなる容量を持っていてそれのストレージを別のインスタンスと共有していない場合、ある要素を追加することはO(1)です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When an array needs to reallocate storage before appending or its storage is shared with another copy, appending is O(<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>), where <bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept> is the length of the array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>配列が追加の前にストレージの際割り当てを必要とするかそれのストレージを別のコピーと共有する場合、追加作業はO(<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>)です、そこで<bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept>は配列の長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When an event occurs—such as a user resizing a window—a class that's a delegator will detect the event and call delegate methods on the class you specify as the delegate.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>イベントが発生する場合 — 例えばユーザがウインドウをリサイズするなど — 委任元であるクラスはイベントを検出します、そしてあなたが委任先として指定するクラス上で委任先メソッドを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When building an app target, you can provide a custom name for the product module by changing the Product Module Name build setting.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>アプリターゲットをビルドする場合、あなたはあつらえの名前を製品モジュールに提供することがProduct Module Name build設定を変更することによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When calling the new <bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept> initializer within a <bpt i="1" x="1">&lt;c1&gt;</bpt>do<ept i="1">&lt;/c1&gt;</ept> statement, you can use pattern matching to match specific cases of your custom error type and access their associated values, as in the example below.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この新しい<bpt i="0" x="0">&lt;c0&gt;</bpt>Int<ept i="0">&lt;/c0&gt;</ept>イニシャライザを<bpt i="1" x="1">&lt;c1&gt;</bpt>do<ept i="1">&lt;/c1&gt;</ept>文内部で呼び出すとき、あなたはパターンマッチを使ってあなたのあつらえのエラー型のそれぞれ詳述なケース節と照合して、それらの関連値にアクセスします、下の例でのように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When comparing two values with this method, <bpt i="1" x="1">&lt;c1&gt;</bpt>-0<ept i="1">&lt;/c1&gt;</ept> is equal to <bpt i="2" x="2">&lt;c2&gt;</bpt>+0<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>２つの値をこのメソッドで比較する場合、<bpt i="1" x="1">&lt;c1&gt;</bpt>-0<ept i="1">&lt;/c1&gt;</ept>は<bpt i="2" x="2">&lt;c2&gt;</bpt>+0<ept i="2">&lt;/c2&gt;</ept>と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When converting floating-point values, the <bpt i="0" x="0">&lt;c0&gt;</bpt>init?(exactly:)<ept i="0">&lt;/c0&gt;</ept> initializer checks both that the passed value has no fractional part and that the value is representable in the resulting type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>浮動小数点値を変換するとき、<bpt i="0" x="0">&lt;c0&gt;</bpt>init?(exactly:)<ept i="0">&lt;/c0&gt;</ept>イニシャライザは、渡された値が小数部を持たないこと、そしてその値が結果となる型の中に表現可能であることの両方を検査します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When creating a custom collection type, add the minimal requirements of the <bpt i="4" x="4">&lt;c4&gt;</bpt>Collection<ept i="4">&lt;/c4&gt;</ept> protocol: starting and ending indices and a subscript for accessing elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あつらえのコレクション型を作成する場合、<bpt i="4" x="4">&lt;c4&gt;</bpt>Collection<ept i="4">&lt;/c4&gt;</ept>プロトコルの最小限の要件：始まりと終わりのインデックスおよび要素にアクセスするための添え字、を加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When declarations in an Objective-C header file refer to a Swift class or protocol that comes from the same target, importing the generated header creates a cyclical reference.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Objective-Cヘッダファイルの中の宣言がその同じターゲットからやってくるSwiftクラスまたはプロトコルを参照する場合、生成ヘッダのインポートは循環参照を生み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When implementing an <bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>String<bpt i="3" x="3">&lt;w3&gt;</bpt>Interpolation<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> conformance, set the <bpt i="4" x="4">&lt;c4&gt;</bpt>String<bpt i="5" x="5">&lt;w5&gt;</bpt>Interpolation<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> associated type to <bpt i="6" x="6">&lt;c6&gt;</bpt>Default<bpt i="7" x="7">&lt;w7&gt;</bpt>String<bpt i="8" x="8">&lt;w8&gt;</bpt>Interpolation<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> to get the same interpolation behavior as Swift’s built-in <bpt i="9" x="9">&lt;c9&gt;</bpt>String<ept i="9">&lt;/c9&gt;</ept> type and construct a <bpt i="10" x="10">&lt;c10&gt;</bpt>String<ept i="10">&lt;/c10&gt;</ept> with the results.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>String<bpt i="3" x="3">&lt;w3&gt;</bpt>Interpolation<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>準拠を実装する場合は、<bpt i="4" x="4">&lt;c4&gt;</bpt>String<bpt i="5" x="5">&lt;w5&gt;</bpt>Interpolation<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>関連型を<bpt i="6" x="6">&lt;c6&gt;</bpt>Default<bpt i="7" x="7">&lt;w7&gt;</bpt>String<bpt i="8" x="8">&lt;w8&gt;</bpt>Interpolation<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>に設定することで、Swiftの組込み<bpt i="9" x="9">&lt;c9&gt;</bpt>String<ept i="9">&lt;/c9&gt;</ept>型と同じ補間挙動を取得してください、そしてある<bpt i="10" x="10">&lt;c10&gt;</bpt>String<ept i="10">&lt;/c10&gt;</ept>をその結果で組み立ててください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When implementing the <bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept> method and the <bpt i="1" x="1">&lt;c1&gt;</bpt>hash(into:)<ept i="1">&lt;/c1&gt;</ept> method, use all the properties that affect whether two instances of your custom type are considered equal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept>メソッドと<bpt i="1" x="1">&lt;c1&gt;</bpt>hash(into:)<ept i="1">&lt;/c1&gt;</ept>メソッドを実装する場合、あなたのカスタム型の２つのインスタンスが等しいと考えられるどうかに影響するすべてのプロパティを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When imported into Swift, the macros in the above example are equivalent to these constant declarations:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftへとインポートされる場合、上の例でのマクロは、これら定数宣言に相当します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When importing C function parameters, however, Swift maps pointer parameters to standard library pointer types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>C関数パラメータをインポートする場合、しかしながら、Swiftはポインタパラメータを標準ライブラリのポインタ型へとマップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When importing the Foundation framework, the Swift overlay provides value types for many bridged reference types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Foundationフレームワークをインポートする場合、Swiftオーバーレイは値型を多くのブリッジされる参照型に対して提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When importing these types, Swift moves them to be nested types of their related types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それらの型をインポートするとき、スウィフトはそれらを移動して、それらの関連型の入れ子にされた型にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When iterated over, keys appear in this collection in the same order as they occur in the dictionary’s key-value pairs.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>すべてにわたって反復した場合、それらが辞書のキー値ペアにおいて現れるのと同じ順序で、キーはこのコレクションにおいて現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When iterated over, values appear in this collection in the same order as they occur in the dictionary’s key-value pairs.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>すべてにわたって反復した場合、それらが辞書のキー値ペアにおいて現れるのと同じ順序で、値はこのコレクションにおいて現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When negative integers are extended, the result is padded with ones.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>負整数が拡張される時、結果は１で詰め物をされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When next returns nil this signifies the end of the AsyncStream.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>nextがnilを返す場合これはAsyncStreamの終わりを知らせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When nonnegative integers are extended, the result is padded with zeroes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>非負整数が拡張される時、結果はゼロで詰め物をされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When performing collection-based operations that return an index into a dictionary, use this subscript with the resulting value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ある辞書に対してのコレクション基盤インデックスを返す演算を実行する時、この添え字を結果の値とともに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When placed next to each other in a string literal, these two scalar values are combined into a single grapheme cluster, represented by a <bpt i="2" x="2">&lt;c2&gt;</bpt>Character<ept i="2">&lt;/c2&gt;</ept> instance in Swift.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるSwift文字列リテラルにおいて互いに隣り合わせに置かれる時、これら２つのスカラー値は、Swiftでは１つの<bpt i="2" x="2">&lt;c2&gt;</bpt>Character<ept i="2">&lt;/c2&gt;</ept>インスタンスによって表される、単一の書記素クラスタへと一体化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When that happens, the array being modified replaces its storage with a uniquely owned copy of itself, which is then modified in place.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それが起こる場合、修正されている配列はそれのストレージを独自な自分だけの自身のコピーと置き換え、それはそれからそこで修正されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the bit width of <bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept> (the type of <bpt i="1" x="1">&lt;c1&gt;</bpt>source<ept i="1">&lt;/c1&gt;</ept>) is equal to or greater than this type’s bit width, the result is the truncated least-significant bits of <bpt i="2" x="2">&lt;c2&gt;</bpt>source<ept i="2">&lt;/c2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept>（<bpt i="1" x="1">&lt;c1&gt;</bpt>source<ept i="1">&lt;/c1&gt;</ept>の型）のビット幅がこの型のもつビット幅と等しいかより大きいならば、結果は<bpt i="2" x="2">&lt;c2&gt;</bpt>source<ept i="2">&lt;/c2&gt;</ept>の先端を切った最下位ビットです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the bit width of <bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept> is less than this type’s bit width, the result is <bpt i="1" x="1">&lt;e1&gt;</bpt>sign-extended<ept i="1">&lt;/e1&gt;</ept> to fill the remaining bits.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>T<ept i="0">&lt;/c0&gt;</ept>のビット幅がこの型のもつビット幅より小さいならば、結果は残りのビットを満たすように<bpt i="1" x="1">&lt;e1&gt;</bpt>符号拡張<ept i="1">&lt;/e1&gt;</ept>されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the buffer is full, discard the newly received element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>バッファがいっぱいである時、新しく受け取った要素を廃棄します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the buffer is full, discard the oldest element in the buffer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>バッファがいっぱいである時、バッファにおいて最古の要素を廃棄します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the collection passed to <bpt i="3" x="3">&lt;c3&gt;</bpt>relative(to:)<ept i="3">&lt;/c3&gt;</ept> starts with a different index, that index is used as the lower bound instead.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="3" x="3">&lt;c3&gt;</bpt>relative(to:)<ept i="3">&lt;/c3&gt;</ept>に渡されるコレクションが異なるインデックスで始まる場合、そのインデックスは代わりに下側の境界として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the context provides enough type information, you can use a special form of the dictionary literal, square brackets surrounding a single colon, to initialize an empty dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>文脈が十分な型情報を提供する場合、あなたは特別な形式の辞書リテラル、ただ１つのコロンを囲んでいる角括弧、を使って空の辞書を初期化することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the destination array’s element type is a class or an <bpt i="0" x="0">&lt;c0&gt;</bpt>@objc<ept i="0">&lt;/c0&gt;</ept> protocol, bridging from <bpt i="1" x="1">&lt;c1&gt;</bpt>NSArray<ept i="1">&lt;/c1&gt;</ept> to <bpt i="2" x="2">&lt;c2&gt;</bpt>Array<ept i="2">&lt;/c2&gt;</ept> first calls the <bpt i="3" x="3">&lt;c3&gt;</bpt>copy(with:)<ept i="3">&lt;/c3&gt;</ept> (<bpt i="4" x="4">&lt;c4&gt;</bpt>- copy<bpt i="5" x="5">&lt;w5&gt;</bpt>With<bpt i="6" x="6">&lt;w6&gt;</bpt>Zone:<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> in Objective-C) method on the array to get an immutable copy and then performs additional Swift bookkeeping work that takes O(1) time.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>行き先配列の持つ要素型があるクラスまたはある<bpt i="0" x="0">&lt;c0&gt;</bpt>@objc<ept i="0">&lt;/c0&gt;</ept>プロトコルである場合、<bpt i="1" x="1">&lt;c1&gt;</bpt>NSArray<ept i="1">&lt;/c1&gt;</ept>から<bpt i="2" x="2">&lt;c2&gt;</bpt>Array<ept i="2">&lt;/c2&gt;</ept>へのブリッジはまず<bpt i="3" x="3">&lt;c3&gt;</bpt>copy(with:)<ept i="3">&lt;/c3&gt;</ept>（Objective-Cでの<bpt i="4" x="4">&lt;c4&gt;</bpt>- copy<bpt i="5" x="5">&lt;w5&gt;</bpt>With<bpt i="6" x="6">&lt;w6&gt;</bpt>Zone:<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>）メソッドをその配列上で呼び出すことである不変のコピーを取得します、そしてそれから追加のSwift簿記作業を実行します、それはO(1)時間をとります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the destination array’s element type is a nonclass type that bridges to a Foundation type, bridging from <bpt i="0" x="0">&lt;c0&gt;</bpt>NSArray<ept i="0">&lt;/c0&gt;</ept> to <bpt i="1" x="1">&lt;c1&gt;</bpt>Array<ept i="1">&lt;/c1&gt;</ept> performs a bridging copy of the elements to contiguous storage in O(<bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept>) time.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>行き先配列の持つ要素型が非クラス型でFoundation型にブリッジする場合、<bpt i="0" x="0">&lt;c0&gt;</bpt>NSArray<ept i="0">&lt;/c0&gt;</ept>から<bpt i="1" x="1">&lt;c1&gt;</bpt>Array<ept i="1">&lt;/c1&gt;</ept>へのブリッジはそれら要素のコピーを隣接ストレージにブリッジすることをO(<bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept>)時間で実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the dictionary’s <bpt i="2" x="2">&lt;c2&gt;</bpt>Key<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>Value<ept i="3">&lt;/c3&gt;</ept> types are neither classes nor <bpt i="4" x="4">&lt;c4&gt;</bpt>@objc<ept i="4">&lt;/c4&gt;</ept> protocols, any required bridging of elements occurs at the first access of each element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書の<bpt i="2" x="2">&lt;c2&gt;</bpt>Key<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>Value<ept i="3">&lt;/c3&gt;</ept>型がクラスでも<bpt i="4" x="4">&lt;c4&gt;</bpt>@objc<ept i="4">&lt;/c4&gt;</ept>プロトコルでもない場合、それら要素のブリッジに必要とされるあらゆることが各要素の最初のアクセスで起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the group returns, it implicitly waits for all child tasks to complete.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>グループが復帰する時、それは暗黙的に全ての子タスクが完了するのを待ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the original <bpt i="1" x="1">&lt;c1&gt;</bpt>numbers<ept i="1">&lt;/c1&gt;</ept> array is modified, it makes a unique copy of its storage before making the modification.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>オリジナルの<bpt i="1" x="1">&lt;c1&gt;</bpt>numbers<ept i="1">&lt;/c1&gt;</ept>配列が修正されるとき、それはそれのストレージの特有なコピーをその修正がなされる前に行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the return value is <bpt i="5" x="5">&lt;c5&gt;</bpt>false<ept i="5">&lt;/c5&gt;</ept>, the value of <bpt i="6" x="6">&lt;c6&gt;</bpt>i<ept i="6">&lt;/c6&gt;</ept> is equal to <bpt i="7" x="7">&lt;c7&gt;</bpt>limit<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>戻り値が<bpt i="5" x="5">&lt;c5&gt;</bpt>false<ept i="5">&lt;/c5&gt;</ept>の場合、<bpt i="6" x="6">&lt;c6&gt;</bpt>i<ept i="6">&lt;/c6&gt;</ept>の値は<bpt i="7" x="7">&lt;c7&gt;</bpt>limit<ept i="7">&lt;/c7&gt;</ept>に等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the sequence is exhausted, the accumulating value is returned to the caller.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスが使い尽くされる時、蓄積値が呼び出し側へ返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the sequence is exhausted, the last value returned from the closure is returned to the caller.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>シーケンスが使い尽くされる時、クロージャから返される最後の値が呼び出し側へ返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the static type of the value passed to <bpt i="9" x="9">&lt;c9&gt;</bpt>type(of:)<ept i="9">&lt;/c9&gt;</ept> is constrained to a class or protocol, you can use that metatype to access initializers or other static members of the class or protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="9" x="9">&lt;c9&gt;</bpt>type(of:)<ept i="9">&lt;/c9&gt;</ept>に渡される値の静的型があるクラスまたはプロトコルに制約される場合、あなたはそのメタタイプを使うことでイニシャライザやそのクラスまたはプロトコルの他の静的メンバーにアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the value is <bpt i="15" x="15">&lt;c15&gt;</bpt>5<ept i="15">&lt;/c15&gt;</ept>, the closure throws <bpt i="16" x="16">&lt;c16&gt;</bpt>My<bpt i="17" x="17">&lt;w17&gt;</bpt>Error<ept i="17">&lt;/w17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>, terminating the sequence.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値が<bpt i="15" x="15">&lt;c15&gt;</bpt>5<ept i="15">&lt;/c15&gt;</ept>である場合、クロージャは<bpt i="16" x="16">&lt;c16&gt;</bpt>My<bpt i="17" x="17">&lt;w17&gt;</bpt>Error<ept i="17">&lt;/w17&gt;</ept><ept i="16">&lt;/c16&gt;</ept>をスローして、シーケンスを終端しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When these invalid strings are parsed by the <bpt i="2" x="2">&lt;c2&gt;</bpt>Double<ept i="2">&lt;/c2&gt;</ept> failable initializer, the example uses the nil-coalescing operator (<bpt i="3" x="3">&lt;c3&gt;</bpt>??<ept i="3">&lt;/c3&gt;</ept>) to provide NaN as a fallback value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>それら無効な文字列が<bpt i="2" x="2">&lt;c2&gt;</bpt>Double<ept i="2">&lt;/c2&gt;</ept>の失敗できるイニシャライザによって解析される場合のため、この例はnil合体演算子（<bpt i="3" x="3">&lt;c3&gt;</bpt>??<ept i="3">&lt;/c3&gt;</ept>）を使ってNaNをフォールバック（頼みの綱の、予備の）値として提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When this initializer finds a key in <bpt i="0" x="0">&lt;c0&gt;</bpt>container<ept i="0">&lt;/c0&gt;</ept> that doesn’t exist in <bpt i="1" x="1">&lt;c1&gt;</bpt>scope<ept i="1">&lt;/c1&gt;</ept>, it casts the key to <bpt i="2" x="2">&lt;c2&gt;</bpt>Any<bpt i="3" x="3">&lt;w3&gt;</bpt>Object<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> when adding it to the dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このイニシャライザが、あるキーを<bpt i="0" x="0">&lt;c0&gt;</bpt>container<ept i="0">&lt;/c0&gt;</ept>の中で見つけるそれが<bpt i="1" x="1">&lt;c1&gt;</bpt>scope<ept i="1">&lt;/c1&gt;</ept>の中に存在しない時、それは、そのキーを<bpt i="2" x="2">&lt;c2&gt;</bpt>Any<bpt i="3" x="3">&lt;w3&gt;</bpt>Object<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>へとキャストします、それを辞書へと加える時に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When using a <bpt i="2" x="2">&lt;c2&gt;</bpt>Case<bpt i="3" x="3">&lt;w3&gt;</bpt>Iterable<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> type, you can access a collection of all of the type’s cases by using the type’s <bpt i="4" x="4">&lt;c4&gt;</bpt>all<bpt i="5" x="5">&lt;w5&gt;</bpt>Cases<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="2" x="2">&lt;c2&gt;</bpt>Case<bpt i="3" x="3">&lt;w3&gt;</bpt>Iterable<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>型を使う場合、あなたはその型のもつケース節の全てからなるコレクションにアクセスすることが、その型のもつ<bpt i="4" x="4">&lt;c4&gt;</bpt>all<bpt i="5" x="5">&lt;w5&gt;</bpt>Cases<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>プロパティを使うことで可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When using an empty array literal, specify the type of the variable or constant.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>空の配列リテラルを使う時は、変数または定数の型を指定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When using custom types to model data in your programs, you may frequently need to check whether two values are the same or different, or whether a particular value is included in a list of values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あつらえの型を使ってあなたのプログラムにおいてデータをモデル化する場合、あなたは２つの値が同じか異なるか、または特定の値が値のリストに含まれるかどうかを調べる必要がしばしばあるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When using such a declaration from another actor (or from nonisolated code), synchronization is performed through the \c shared actor instance to ensure mutually-exclusive access to the declaration.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>そのようなある宣言を別のアクターから（または非分離コードから）使う場合、同期は共有アクターインスタンスを通して実行されることで、その宣言への相互排他アクセスを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When values are produced from a non async/await source there is a consideration that must be made on behavioral characteristics of how that production of values interacts with the iteration.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>値それらが非同期／待機ではないあるソースから生み出される場合は、どのように値それらの生産が反復と相互作用するかの行動的特徴の上にそれが作られなければならないというある考慮すべき点があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you add elements to an array and that array begins to exceed its reserved capacity, the array allocates a larger region of memory and copies its elements into the new storage.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがいくらかの要素を配列に加えてその配列がそれの確保した容量を越え始める時、配列はより大きなメモリ領域を割り当てて、それの要素をその新しいストレージ（貯蔵場所）にコピーします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you are operating on many values, this behavior is valuable because operations on NaN simply forward the value and don’t cause runtime errors.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが沢山の値に演算を行っている時、この挙動は有益です、なぜならNaNに関する演算は単にその値を次に伝えて実行時エラーを起こさないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you assign a value for a key and that key already exists, the dictionary overwrites the existing value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがある値をあるキーに割り当てるそしてそのキーが既に存在する場合、辞書は既存の値を上書きします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you call <bpt i="0" x="0">&lt;c0&gt;</bpt>drop<bpt i="1" x="1">&lt;w1&gt;</bpt>First(_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> on an asynchronous sequence that is already an <bpt i="2" x="2">&lt;c2&gt;</bpt>Async<bpt i="3" x="3">&lt;w3&gt;</bpt>Drop<bpt i="4" x="4">&lt;w4&gt;</bpt>First<bpt i="5" x="5">&lt;w5&gt;</bpt>Sequence<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>, the returned sequence simply adds the new drop count to the current drop count.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>drop<bpt i="1" x="1">&lt;w1&gt;</bpt>First(_:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>をある非同期シーケンスで既に<bpt i="2" x="2">&lt;c2&gt;</bpt>Async<bpt i="3" x="3">&lt;w3&gt;</bpt>Drop<bpt i="4" x="4">&lt;w4&gt;</bpt>First<bpt i="5" x="5">&lt;w5&gt;</bpt>Sequence<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>であるものの上で呼び出す時、返されるシーケンスは単純に新しい除外総数を現在の除外総数に加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you call a function that does not fully specify its parameters’ types, use the type-cast operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>as<ept i="0">&lt;/c0&gt;</ept>) to specify the type of an array literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが完全にそれのパラメータの型を指定しない関数を呼び出す場合は、型キャスト演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>as<ept i="0">&lt;/c0&gt;</ept>）を使って配列リテラルの型を指定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you create a binary integer from a floating-point value using the default initializer, the value is rounded toward zero before the range is checked.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがバイナリ整数をある浮動小数点力省略時のイニシャライザを使って作成するとき、その値は範囲が検査される前にゼロへの丸めをされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you create a constant or variable using one of the Boolean literals <bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>, the resulting type is determined by the <bpt i="2" x="2">&lt;c2&gt;</bpt>Boolean<bpt i="3" x="3">&lt;w3&gt;</bpt>Literal<bpt i="4" x="4">&lt;w4&gt;</bpt>Type<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> alias.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが定数や変数をブールリテラル<bpt i="0" x="0">&lt;c0&gt;</bpt>true<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>false<ept i="1">&lt;/c1&gt;</ept>を使って作成するとき、結果の型は<bpt i="2" x="2">&lt;c2&gt;</bpt>Boolean<bpt i="3" x="3">&lt;w3&gt;</bpt>Literal<bpt i="4" x="4">&lt;w4&gt;</bpt>Type<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>エイリアスによって決定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you create an observer, you start observation by calling the <bpt i="0" x="0">&lt;c0&gt;</bpt>observe(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>options:<bpt i="2" x="2">&lt;w2&gt;</bpt>change<bpt i="3" x="3">&lt;w3&gt;</bpt>Handler:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method with a key path that refers to the property you want to observe.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがオブザーバを作成する場合、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>observe(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>options:<bpt i="2" x="2">&lt;w2&gt;</bpt>change<bpt i="3" x="3">&lt;w3&gt;</bpt>Handler:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを、あなたが監視したいプロパティを参照するキーパスとともに呼び出すことによって監視を開始します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you define an enumeration without associated values, it gains <bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept> conformance automatically, and you can add <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept> conformance to your other custom types by implementing the <bpt i="2" x="2">&lt;c2&gt;</bpt>hash(into:)<ept i="2">&lt;/c2&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが列挙を関連値なしで定義するとき、それは<bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept>準拠を自動的に手に入れます、そしてあなたは<bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>準拠をあなたの他のあつらえの型に加えることが、<bpt i="2" x="2">&lt;c2&gt;</bpt>hash(into:)<ept i="2">&lt;/c2&gt;</ept>メソッドを実装することによって行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you do, all known <bpt i="2" x="2">&lt;c2&gt;</bpt>@objc<ept i="2">&lt;/c2&gt;</ept> class methods and properties are available as implicitly unwrapped optional methods and properties, respectively.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがそうする場合、全ての既知の<bpt i="2" x="2">&lt;c2&gt;</bpt>@objc<ept i="2">&lt;/c2&gt;</ept>クラスのメソッドおよびプロパティは、暗黙的にアンラップされるオプショナルのメソッドおよびプロパティとしてそれぞれが利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you do, use a structure to represent errors.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがそうする場合は、構造体を使ってエラーを表してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you enumerate a collection, the integer part of each pair is a counter for the enumeration, but is not necessarily the index of the paired value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがあるコレクションを列挙するとき、各ペアの整数部分は列挙のためのカウンタです、しかし必ずしもペアにされた値のインデックスではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you import it, here's the Swift interface:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがそれをインポートする場合、ここにSwiftインターフェイスがあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you import the Color structure, the Swift version is equivalent to the following:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがColor構造体をインポートする場合、Swift版は以下に相当します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you import the Core Foundation framework, its types are imported as Swift classes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがCore Foundationフレームワークをインポートする場合、それの型は、Swiftクラスとしてインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you import these declarations into Swift, the <bpt i="0" x="0">&lt;c0&gt;</bpt>NSCopying<ept i="0">&lt;/c0&gt;</ept> protocol qualification of the <bpt i="1" x="1">&lt;c1&gt;</bpt>List<ept i="1">&lt;/c1&gt;</ept> type and the <bpt i="2" x="2">&lt;c2&gt;</bpt>NSValue<ept i="2">&lt;/c2&gt;</ept> class qualification of the <bpt i="3" x="3">&lt;c3&gt;</bpt>list<bpt i="4" x="4">&lt;w4&gt;</bpt>Of<bpt i="5" x="5">&lt;w5&gt;</bpt>Values<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept> method are preserved.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがそれら宣言をSwiftへとインポートする場合、<bpt i="0" x="0">&lt;c0&gt;</bpt>NSCopying<ept i="0">&lt;/c0&gt;</ept>プロトコル適格が<bpt i="1" x="1">&lt;c1&gt;</bpt>List<ept i="1">&lt;/c1&gt;</ept>型に対して、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>NSValue<ept i="2">&lt;/c2&gt;</ept>適格が<bpt i="3" x="3">&lt;c3&gt;</bpt>list<bpt i="4" x="4">&lt;w4&gt;</bpt>Of<bpt i="5" x="5">&lt;w5&gt;</bpt>Values<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/c3&gt;</ept>メソッドに対して、保存されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you know how many new values you’re adding to a dictionary, use the <bpt i="0" x="0">&lt;c0&gt;</bpt>init(minimum<bpt i="1" x="1">&lt;w1&gt;</bpt>Capacity:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> initializer to allocate the correct amount of buffer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>どのくらい多くの新しい値をあなたが辞書に加えることになるかあなたが知っている場合は、<bpt i="0" x="0">&lt;c0&gt;</bpt>init(minimum<bpt i="1" x="1">&lt;w1&gt;</bpt>Capacity:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>イニシャライザを使って正確な量のバッファを割り当ててください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you match against an <bpt i="2" x="2">&lt;c2&gt;</bpt>Equatable<ept i="2">&lt;/c2&gt;</ept> value in a <bpt i="3" x="3">&lt;c3&gt;</bpt>case<ept i="3">&lt;/c3&gt;</ept> statement, this operator is called behind the scenes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが<bpt i="2" x="2">&lt;c2&gt;</bpt>Equatable<ept i="2">&lt;/c2&gt;</ept>値に対して<bpt i="3" x="3">&lt;c3&gt;</bpt>case<ept i="3">&lt;/c3&gt;</ept>文でマッチを行うとき、この演算子が舞台裏で呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you need a range that includes the last element of a collection, use the half-open range operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>..&lt;<ept i="0">&lt;/c0&gt;</ept>) with <bpt i="1" x="1">&lt;c1&gt;</bpt>end<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがコレクションの最後の要素を含むある範囲を必要とする時は、半開範囲演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>..&lt;<ept i="0">&lt;/c0&gt;</ept>）を<bpt i="1" x="1">&lt;c1&gt;</bpt>end<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>とともに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you need a range that includes the last element of an array, use the half-open range operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>..&lt;<ept i="0">&lt;/c0&gt;</ept>) with <bpt i="1" x="1">&lt;c1&gt;</bpt>end<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが配列の最後の要素を含む範囲を必要とするならば、半開範囲演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>..&lt;<ept i="0">&lt;/c0&gt;</ept>）を<bpt i="1" x="1">&lt;c1&gt;</bpt>end<bpt i="2" x="2">&lt;w2&gt;</bpt>Index<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>とともに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you need to access APIs that require data in an <bpt i="0" x="0">&lt;c0&gt;</bpt>NSArray<ept i="0">&lt;/c0&gt;</ept> instance instead of <bpt i="1" x="1">&lt;c1&gt;</bpt>Array<ept i="1">&lt;/c1&gt;</ept>, use the type-cast operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>as<ept i="2">&lt;/c2&gt;</ept>) to bridge your instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>NSArray<ept i="0">&lt;/c0&gt;</ept>インスタンスでのデータを<bpt i="1" x="1">&lt;c1&gt;</bpt>Array<ept i="1">&lt;/c1&gt;</ept>の代わりに期待するAPIにあなたがアクセスする必要がある場合、型キャスト演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>as<ept i="2">&lt;/c2&gt;</ept>）を使ってあなたのインスタンスをブリッジしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you need to check whether your collection is empty, use the <bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Empty<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property instead of checking that the <bpt i="2" x="2">&lt;c2&gt;</bpt>count<ept i="2">&lt;/c2&gt;</ept> property is equal to zero.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのコレクションが空かどうか確認する必要がある場合、<bpt i="0" x="0">&lt;c0&gt;</bpt>is<bpt i="1" x="1">&lt;w1&gt;</bpt>Empty<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティを使ってください、<bpt i="2" x="2">&lt;c2&gt;</bpt>count<ept i="2">&lt;/c2&gt;</ept>プロパティがゼロと等しいのを調べるのではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you need to perform an operation on all of an array’s elements, use a <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> loop to iterate through the array’s contents.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがある配列の要素のすべてである演算を実行することを必要とするならば、<bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>を使って配列の内容の始めから終わりまで反復適用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you pass a Swift instance to an Objective-C API, it's bridged as an <bpt i="3" x="3">&lt;c3&gt;</bpt>id<ept i="3">&lt;/c3&gt;</ept> parameter so that it's usable in the API as an Objective-C object.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがSwiftインスタンスをあるObjective-C APIに渡す場合、それは<bpt i="3" x="3">&lt;c3&gt;</bpt>id<ept i="3">&lt;/c3&gt;</ept>パラメータとしてブリッジされます、それでそれはそのAPIにおいてObjective-Cオブジェクトとして利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you provide just those methods, the standard library provides default implementations for all other arithmetic methods and operators.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが単にそれらのメソッドだけを提供する場合、標準ライブラリが省略時の実装をすべての他の算術演算メソッドと演算子に提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you receive an unmanaged object from an unannotated API, immediately convert it to a memory-managed object before you work with it.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが注釈をつけられないAPIから管理されないオブジェクトを受け取るとき、あなたがそれを扱う前に、直ちにそれをメモリ管理されたオブジェクトに変換してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you use <bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Object<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> as a concrete type, you have at your disposal every <bpt i="2" x="2">&lt;c2&gt;</bpt>@objc<ept i="2">&lt;/c2&gt;</ept> method and property—that is, methods and properties imported from Objective-C or marked with the <bpt i="3" x="3">&lt;c3&gt;</bpt>@objc<ept i="3">&lt;/c3&gt;</ept> attribute.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Object<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を具体的な型として使うとき、すべての<bpt i="2" x="2">&lt;c2&gt;</bpt>@objc<ept i="2">&lt;/c2&gt;</ept>メソッドやプロパティ — すなわち、Objective-Cからインポートされるか、<bpt i="3" x="3">&lt;c3&gt;</bpt>@objc<ept i="3">&lt;/c3&gt;</ept>属性で印されるメソッドとプロパティ — があなたの自由になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you use <bpt i="3" x="3">&lt;c3&gt;</bpt>Codable<ept i="3">&lt;/c3&gt;</ept> as a type or a generic constraint, it matches any type that conforms to both protocols.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが<bpt i="3" x="3">&lt;c3&gt;</bpt>Codable<ept i="3">&lt;/c3&gt;</ept>をある型またはある総称体制約として使う場合、それはプロトコル両方に準拠するあらゆる型に適合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you use arrays, dictionaries, and other collections, you benefit from the operations that the <bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<ept i="0">&lt;/c0&gt;</ept> protocol declares and implements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが配列、辞書、および他のコレクションを使うとき、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<ept i="0">&lt;/c0&gt;</ept>プロトコルが宣言および実装する演算からの恩恵を受けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you want to sort a collection of elements that don’t conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept> protocol, pass a closure to this method that returns <bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept> when the first element should be ordered before the second.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠しない要素からなるコレクションをソートしたい場合、最初の要素が２番目の前に並べられるべき場合は<bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>を返すクロージャをこのメソッドに渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you want to sort a sequence of elements that don’t conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept> protocol, pass a predicate to this method that returns <bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept> when the first element should be ordered before the second.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠しない要素からなるシーケンスをソートしたい場合、最初の要素が２番目の前に並べられるべき時は<bpt i="1" x="1">&lt;c1&gt;</bpt>true<ept i="1">&lt;/c1&gt;</ept>を返す述部をこのメソッドに渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you work with objects of type <bpt i="0" x="0">&lt;c0&gt;</bpt>Any<ept i="0">&lt;/c0&gt;</ept> where you know the underlying type, it's often useful to downcast those objects to the underlying type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが基盤型を知っているところの型<bpt i="0" x="0">&lt;c0&gt;</bpt>Any<ept i="0">&lt;/c0&gt;</ept>のオブジェクトを扱う場合、しばしば役立つのはそれらオブジェクトを基盤型へとダウンキャストすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you're building an app target, you can import your Swift code into any Objective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept> file within that same target using this syntax and substituting the appropriate name:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがアプリターゲットをビルドしている場合、あなたはあなたのSwiftコードをインポートすることが、あらゆるObjective-C <bpt i="0" x="0">&lt;c0&gt;</bpt>.m<ept i="0">&lt;/c0&gt;</ept>ファイルへと、その同じターゲット内で、この構文を使ってそして適切な名前を代わりに使って、行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you're choosing how to model your data, try building the hierarchy of data types using protocol inheritance first, then adopt those protocols in your structures.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたのデータをモデル化する方法をあなたが選ぶ時、データ型の階層の構築を最初にプロトコル継承を使って試みてください、それからそれらのプロトコルをあなたの構造体において採用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you’ve finished feeding the hasher, the hash value can be retrieved by calling <bpt i="2" x="2">&lt;c2&gt;</bpt>finalize()<ept i="2">&lt;/c2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがハーシャーに入力を完了する時、ハッシュ値は<bpt i="2" x="2">&lt;c2&gt;</bpt>finalize()<ept i="2">&lt;/c2&gt;</ept>を呼び出すことで取り出せます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Whenever possible, Swift avoids giving you direct access to pointers.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>可能なときはいつでも、スウィフトはあなたにポインターへの直接のアクセスを与えることを避けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Whenever possible, Swift’s compiler infers the full intended type of your array literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>可能な時はいつでも、Swiftのコンパイラはあなたの配列リテラルの完全な意図される型を推論します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Where conversion using <bpt i="0" x="0">&lt;c0&gt;</bpt>as<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>as?<ept i="1">&lt;/c1&gt;</ept> is possible between two types (such as <bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept> and <bpt i="3" x="3">&lt;c3&gt;</bpt>NSNumber<ept i="3">&lt;/c3&gt;</ept>), <bpt i="4" x="4">&lt;c4&gt;</bpt>Any<bpt i="5" x="5">&lt;w5&gt;</bpt>Hashable<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept> uses a canonical representation of the type-erased value so that instances wrapping the same value of either type compare as equal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>as<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>as?<ept i="1">&lt;/c1&gt;</ept>を使う変換が、２つの型の間（たとえば<bpt i="2" x="2">&lt;c2&gt;</bpt>Int<ept i="2">&lt;/c2&gt;</ept>と<bpt i="3" x="3">&lt;c3&gt;</bpt>NSNumber<ept i="3">&lt;/c3&gt;</ept>）で可能であるところでは、<bpt i="4" x="4">&lt;c4&gt;</bpt>Any<bpt i="5" x="5">&lt;w5&gt;</bpt>Hashable<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>はその型消去値のある正準表現を使います、それでどちらかの型での同じ値をラップしているインスタンスそれらは等しいとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Where in some languages you might pass a starting index into an <bpt i="2" x="2">&lt;c2&gt;</bpt>index<bpt i="3" x="3">&lt;w3&gt;</bpt>Of<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> method to find the second day, in Swift you perform the same operation on a slice of the original array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>何らかの言語ではあなたはある開始インデックスを<bpt i="2" x="2">&lt;c2&gt;</bpt>index<bpt i="3" x="3">&lt;w3&gt;</bpt>Of<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>メソッドに渡して２つ目の日付を見つけるかもしれないところで、Swiftではあなたは同じ演算をオリジナル配列のスライス上で実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Wherever memory management annotations are provided, Swift automatically manages the memory of Core Foundation objects, including Core Foundation objects that you instantiate yourself.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>メモリ管理注釈が提供されるどこででも、あなた自身でインスタンス化するCore Foundationオブジェクトを含めて、スウィフトは自動的にCore Foundationオブジェクトのメモリを管理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Whether the dictionary should keep its underlying buffer.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>辞書がそれの基礎をなすバッファを保つべきかどうか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Whichever of <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept> has greater magnitude, or whichever is a number if the other is NaN.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept>のどちらがより大きい規模を持つか、または他方がNaNならば数である方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Whichever of <bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept> has lesser magnitude, or whichever is a number if the other is NaN.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>x<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>y<ept i="1">&lt;/c1&gt;</ept>のどちらがより小さい規模を持つか、または他方がNaNならば数である方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>While the resulting array may have a capacity larger than the requested amount, the buffer passed to the closure will cover exactly the requested number of elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>結果配列が要請された量より大きい収容能力を持つかもしれない一方で、クロージャに渡されるバッファは、正確に要請された数の要素に及びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>While this example isn’t itself asychronous, it shows the shape of a custom sequence and iterator, and how to use it as if it were asynchronous:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>この例はそれ自体は非同期でない一方で、それはあるあつらえのシーケンスとイテレータの輪郭、そしてまるでそれが非同期だったかのようにそれを使う方法を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>With <bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept> conformance, you can use the equal-to operator (<bpt i="1" x="1">&lt;c1&gt;</bpt>==<ept i="1">&lt;/c1&gt;</ept>) or the not-equal-to operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>!=<ept i="2">&lt;/c2&gt;</ept>) with any two instances of the <bpt i="3" x="3">&lt;c3&gt;</bpt>Position<ept i="3">&lt;/c3&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept>準拠で、あなたは同等演算子（<bpt i="1" x="1">&lt;c1&gt;</bpt>==<ept i="1">&lt;/c1&gt;</ept>）または不等演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>!=<ept i="2">&lt;/c2&gt;</ept>）を<bpt i="3" x="3">&lt;c3&gt;</bpt>Position<ept i="3">&lt;/c3&gt;</ept>型の任意の２つのインスタンスで使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>With either function, you pass the resulting <bpt i="26" x="26">&lt;c26&gt;</bpt>CVa<bpt i="27" x="27">&lt;w27&gt;</bpt>List<bpt i="28" x="28">&lt;w28&gt;</bpt>Pointer<ept i="28">&lt;/w28&gt;</ept><ept i="27">&lt;/w27&gt;</ept><ept i="26">&lt;/c26&gt;</ept> value as the <bpt i="29" x="29">&lt;c29&gt;</bpt>va<bpt i="30" x="30">&lt;w30&gt;</bpt>_list<ept i="30">&lt;/w30&gt;</ept><ept i="29">&lt;/c29&gt;</ept> argument of the C variadic function.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>どちらの関数でも、あなたは結果の<bpt i="26" x="26">&lt;c26&gt;</bpt>CVa<bpt i="27" x="27">&lt;w27&gt;</bpt>List<bpt i="28" x="28">&lt;w28&gt;</bpt>Pointer<ept i="28">&lt;/w28&gt;</ept><ept i="27">&lt;/w27&gt;</ept><ept i="26">&lt;/c26&gt;</ept>値を、C可変長引数関数の<bpt i="29" x="29">&lt;c29&gt;</bpt>va<bpt i="30" x="30">&lt;w30&gt;</bpt>_list<ept i="30">&lt;/w30&gt;</ept><ept i="29">&lt;/c29&gt;</ept>引数として渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>With pointer <bpt i="0" x="0">&lt;c0&gt;</bpt>p<ept i="0">&lt;/c0&gt;</ept> and distance <bpt i="1" x="1">&lt;c1&gt;</bpt>n<ept i="1">&lt;/c1&gt;</ept>, the result of <bpt i="2" x="2">&lt;c2&gt;</bpt>p<bpt i="3" x="3">&lt;w3&gt;</bpt>.advanced(by: n)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is equivalent to <bpt i="4" x="4">&lt;c4&gt;</bpt>p + n<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ポインタ<bpt i="0" x="0">&lt;c0&gt;</bpt>p<ept i="0">&lt;/c0&gt;</ept>と隔たり<bpt i="1" x="1">&lt;c1&gt;</bpt>n<ept i="1">&lt;/c1&gt;</ept>では、<bpt i="2" x="2">&lt;c2&gt;</bpt>p<bpt i="3" x="3">&lt;w3&gt;</bpt>.advanced(by: n)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の結果は<bpt i="4" x="4">&lt;c4&gt;</bpt>p + n<ept i="4">&lt;/c4&gt;</ept>と同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>With pointers <bpt i="0" x="0">&lt;c0&gt;</bpt>p<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>q<ept i="1">&lt;/c1&gt;</ept>, the result of <bpt i="2" x="2">&lt;c2&gt;</bpt>p<bpt i="3" x="3">&lt;w3&gt;</bpt>.distance(to: q)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> is equivalent to <bpt i="4" x="4">&lt;c4&gt;</bpt>q - p<ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ポインタ<bpt i="0" x="0">&lt;c0&gt;</bpt>p<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>q<ept i="1">&lt;/c1&gt;</ept>では、<bpt i="2" x="2">&lt;c2&gt;</bpt>p<bpt i="3" x="3">&lt;w3&gt;</bpt>.distance(to: q)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>の結果は<bpt i="4" x="4">&lt;c4&gt;</bpt>q - p<ept i="4">&lt;/c4&gt;</ept>と同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>With those elements defined, the inherited <bpt i="5" x="5">&lt;c5&gt;</bpt>make<bpt i="6" x="6">&lt;w6&gt;</bpt>Iterator()<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept> method satisfies the requirements of the <bpt i="7" x="7">&lt;c7&gt;</bpt>Sequence<ept i="7">&lt;/c7&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>定義されるそれらの要素とともに、継承される<bpt i="5" x="5">&lt;c5&gt;</bpt>make<bpt i="6" x="6">&lt;w6&gt;</bpt>Iterator()<ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept>メソッドが<bpt i="7" x="7">&lt;c7&gt;</bpt>Sequence<ept i="7">&lt;/c7&gt;</ept>プロトコルの要件を満たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Within the execution of a Swift program, <bpt i="0" x="0">&lt;c0&gt;</bpt>Hasher<ept i="0">&lt;/c0&gt;</ept> guarantees that finalizing it will always produce the same hash value as long as it is fed the exact same sequence of bytes.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あるSwiftプログラムの実行の範囲内で、<bpt i="0" x="0">&lt;c0&gt;</bpt>Hasher<ept i="0">&lt;/c0&gt;</ept>は、それをファイナライズすることは常に同じハッシュ値を生成することを、それが正確に同じバイト列を供給される限り保証します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Without any other information, Swift creates an array that includes the specified values, automatically inferring the array’s <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>何らかの他の情報なしでは、Swiftは指定された値を含んでいる配列を、自動的にその配列の<bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>型を推論して作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Work directly with memory-managed Core Foundation types in your Swift code, and manually handle retains as needed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>メモリ管理されたCore Foundation型をあなたのSwiftコードにおいて直接に扱い、そして必要に応じて手動でリテインを処理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Working with Binary Representation</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>バイナリ表現を扱う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Working with Byte Order</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>バイト順を扱う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Working with Core Foundation Types</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Core Foundation型を扱う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Working with Foundation Types</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Foundation型を扱う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Working with Memory Addresses</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>メモリアドレスを扱う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Working with a Character’s Unicode Values</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>文字のユニコード値を扱う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Wrappers for Algorithms</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>アルゴリズムに対するラッパー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Writes a textual representation of this instance into the given output stream.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>このインスタンスのテキスト表現を与えられた出力ストリームへ書き出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Writes the character into the given output stream.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>その文字を与えられた出力ストリームへと書き出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Writes the textual representations of the given items into the given output stream.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた要素のテキスト表現を与えられた出力ストリームに書き出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Writes the textual representations of the given items into the standard output.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた項目のテキスト表現を標準出力に書き出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Writes the textual representations of the given items most suitable for debugging into the given output stream.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた項目の、デバッグに最も適するテキスト表現を、与えられた出力ストリームに書き出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Writes the textual representations of the given items most suitable for debugging into the standard output.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>与えられた項目の、デバッグに最も適するテキスト表現を、標準出力に書き出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Writing Swift code is interactive and fun in Swift Playgrounds, playgrounds in Xcode, and REPL.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Swiftコード記述は、Swift Playgrounds、Xcodeのplaygrounds、およびREPLにおいて対話的で楽しいものとなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Writing is O(1) unless the array’s storage is shared with another array or uses a bridged <bpt i="0" x="0">&lt;c0&gt;</bpt>NSArray<ept i="0">&lt;/c0&gt;</ept> instance as its storage, in which case writing is O(<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>), where <bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept> is the length of the array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>書き込みはO(1)です、配列のストレージが他の配列と共有するかブリッジされた<bpt i="0" x="0">&lt;c0&gt;</bpt>NSArray<ept i="0">&lt;/c0&gt;</ept>インスタンスをそれのストレージとして使うのでない限りは、その場合には書き込みはO(<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>)です、そこで<bpt i="2" x="2">&lt;e2&gt;</bpt>n<ept i="2">&lt;/e2&gt;</ept>は配列の長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Writing is O(1) unless the array’s storage is shared with another array, in which case writing is O(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>), where <bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept> is the length of the array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>書き込みはO(1)です、配列のストレージが他の配列と共有されない限りは、その場合には書き込みはO(<bpt i="0" x="0">&lt;e0&gt;</bpt>n<ept i="0">&lt;/e0&gt;</ept>)です、そこで<bpt i="1" x="1">&lt;e1&gt;</bpt>n<ept i="1">&lt;/e1&gt;</ept>は配列の長さです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Writing to a Text Stream</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>テキストストリームを書き出す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Xcode offers to create this header when you add a Swift file to an existing Objective-C app, or an Objective-C file to an existing Swift app.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Xcodeは、このヘッダファイルを作成することをあなたがSwiftファイルを既存のObjective-Cアプリに、またはObjective-Cファイルを既存のSwiftアプリに加える場合に提案します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Xcode uses this name when naming the generated header file.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>Xcodeは、生成ヘッダファイルに名前を付けるときにこの名前を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Yielding resulted in not buffering an element because the buffer was full.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>生み出しはある要素をバッファしないという結果になりました、バッファが一杯だったため。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You access the number of cases and the cases themselves through <bpt i="4" x="4">&lt;c4&gt;</bpt>Compass<bpt i="5" x="5">&lt;w5&gt;</bpt>Direction<bpt i="6" x="6">&lt;w6&gt;</bpt>.all<bpt i="7" x="7">&lt;w7&gt;</bpt>Cases<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、ケース節の数およびケース節それ自体にアクセスすることが<bpt i="4" x="4">&lt;c4&gt;</bpt>Compass<bpt i="5" x="5">&lt;w5&gt;</bpt>Direction<bpt i="6" x="6">&lt;w6&gt;</bpt>.all<bpt i="7" x="7">&lt;w7&gt;</bpt>Cases<ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/c4&gt;</ept>を通して可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You also use this method to sort elements that conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept> protocol in descending order.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはまた、このメソッドを使って<bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する要素を降順でソートすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You associate the property you want to observe with its observer by passing the object to the initializer of the observer:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、あなたが監視を望むプロパティをそれのオブザーバと、オブジェクトをオブザーバのイニシャライザを渡すことによって結びつけます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can access a slice of a collection through its ranged subscript or by calling methods like <bpt i="0" x="0">&lt;c0&gt;</bpt>prefix(while:)<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>suffix(_:)<ept i="1">&lt;/c1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、あるコレクションのあるスライスにそれの範囲指定された添え字を通して、または<bpt i="0" x="0">&lt;c0&gt;</bpt>prefix(while:)<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>suffix(_:)<ept i="1">&lt;/c1&gt;</ept>のようなメソッドを呼び出すことによってアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can access an element of a collection through its subscript by using any valid index except the collection’s <bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、コレクションの要素にそれの添え字を通してアクセスすることが、そのコレクションの<bpt i="0" x="0">&lt;c0&gt;</bpt>end<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティを除くあらゆる有効なインデックスを使って行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can access and use pieces of code written in C and Objective-C from within your Swift code.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、CおよびObjective-Cで書かれるコードの断片にアクセスおよび利用することがあなたのSwiftコード内部から可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can access individual array elements through a subscript.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは個々の配列要素に添え字を通してアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can add new elements in the middle of an array by using the <bpt i="0" x="0">&lt;c0&gt;</bpt>insert(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>at:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> method for single elements and by using <bpt i="2" x="2">&lt;c2&gt;</bpt>insert(contents<bpt i="3" x="3">&lt;w3&gt;</bpt>Of:<bpt i="4" x="4">&lt;w4&gt;</bpt>at:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> to insert multiple elements from another collection or array literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、新しい要素を配列の中ほどに追加することが、単一の項目には<bpt i="0" x="0">&lt;c0&gt;</bpt>insert(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>at:)<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>メソッドを使って、そして別のコレクションや配列リテラルから複数の項目を挿入するには<bpt i="2" x="2">&lt;c2&gt;</bpt>insert(contents<bpt i="3" x="3">&lt;w3&gt;</bpt>Of:<bpt i="4" x="4">&lt;w4&gt;</bpt>at:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を使って行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also bridge some toll-free bridged Core Foundation types to Swift standard library types if you cast to a bridging Foundation type first.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはまた、いくつかのトールフリーブリッジされたCore Foundation型をSwift標準ライブラリ型にブリッジすることが、ブリッジしているFoundation型にあなたが最初にキャストするならば、可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also invoke the <bpt i="0" x="0">&lt;c0&gt;</bpt>retain()<ept i="0">&lt;/c0&gt;</ept>, <bpt i="1" x="1">&lt;c1&gt;</bpt>release()<ept i="1">&lt;/c1&gt;</ept>, and <bpt i="2" x="2">&lt;c2&gt;</bpt>autorelease()<ept i="2">&lt;/c2&gt;</ept> methods on unmanaged objects, but this approach is not recommended.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはまた、管理されないオブジェクト上で<bpt i="0" x="0">&lt;c0&gt;</bpt>retain()<ept i="0">&lt;/c0&gt;</ept>、<bpt i="1" x="1">&lt;c1&gt;</bpt>release()<ept i="1">&lt;/c1&gt;</ept>、そして<bpt i="2" x="2">&lt;c2&gt;</bpt>autorelease()<ept i="2">&lt;/c2&gt;</ept>メソッドを呼び出すことができます、しかしこの取り組みは勧められません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also update, modify, or remove keys and values from a dictionary using the key-based subscript.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはまた、辞書のキーと値の更新、修正、または削除をキー基盤の添え字を使って可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also use the <bpt i="0" x="0">&lt;c0&gt;</bpt>do<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept> statement to match on specific Cocoa error codes to differentiate possible failure conditions:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはまた、<bpt i="0" x="0">&lt;c0&gt;</bpt>do<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>catch<ept i="1">&lt;/c1&gt;</ept>文を使って、特定のCocoaエラーコードそれらに関して照合して、可能な失敗状況を区別できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also use the <bpt i="7" x="7">&lt;c7&gt;</bpt>CF<bpt i="8" x="8">&lt;w8&gt;</bpt>_IMPLICIT<bpt i="9" x="9">&lt;w9&gt;</bpt>_BRIDGING<bpt i="10" x="10">&lt;w10&gt;</bpt>_ENABLED<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept> and <bpt i="11" x="11">&lt;c11&gt;</bpt>CF<bpt i="12" x="12">&lt;w12&gt;</bpt>_IMPLICIT<bpt i="13" x="13">&lt;w13&gt;</bpt>_BRIDGING<bpt i="14" x="14">&lt;w14&gt;</bpt>_DISABLED<ept i="14">&lt;/w14&gt;</ept><ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> macros to enclose C function declarations that follow the policy for Core Foundation ownership naming, in order to infer memory management.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはまた、メモリ管理を推論する目的で、<bpt i="7" x="7">&lt;c7&gt;</bpt>CF<bpt i="8" x="8">&lt;w8&gt;</bpt>_IMPLICIT<bpt i="9" x="9">&lt;w9&gt;</bpt>_BRIDGING<bpt i="10" x="10">&lt;w10&gt;</bpt>_ENABLED<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>および<bpt i="11" x="11">&lt;c11&gt;</bpt>CF<bpt i="12" x="12">&lt;w12&gt;</bpt>_IMPLICIT<bpt i="13" x="13">&lt;w13&gt;</bpt>_BRIDGING<bpt i="14" x="14">&lt;w14&gt;</bpt>_DISABLED<ept i="14">&lt;/w14&gt;</ept><ept i="13">&lt;/w13&gt;</ept><ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>マクロを使って、Core Foundation所有者命名の方針に従うC関数宣言を囲むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also use this initializer to convert a complex sequence or collection type back to an array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはまたこのイニシャライザを使って、逆に複雑なシーケンスまたはコレクション型を配列へと変換することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can assign a dictionary literal to a variable or constant or pass it to a function that expects a dictionary.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、辞書リテラルを変数や定数に代入したり、それを辞書を予期する関数に渡したりできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can bridge between <bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>NSDictionary<ept i="1">&lt;/c1&gt;</ept> using the <bpt i="2" x="2">&lt;c2&gt;</bpt>as<ept i="2">&lt;/c2&gt;</ept> operator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Dictionary<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>NSDictionary<ept i="1">&lt;/c1&gt;</ept>の間をブリッジすることが<bpt i="2" x="2">&lt;c2&gt;</bpt>as<ept i="2">&lt;/c2&gt;</ept>演算子を使って行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can call any method on the slices that you might have called on the <bpt i="0" x="0">&lt;c0&gt;</bpt>absences<ept i="0">&lt;/c0&gt;</ept> array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはどんなメソッドでもそれらスライス上で呼び出すことができます、それはあなたが<bpt i="0" x="0">&lt;c0&gt;</bpt>absences<ept i="0">&lt;/c0&gt;</ept>配列上で呼び出すであろうものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can check the equality of instances of any <bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Integer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> types using the equal-to operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>==<ept i="2">&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、何らかの<bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Integer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のインスタンスの同等性を同等演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>==<ept i="2">&lt;/c2&gt;</ept>）使って確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can check the inequality of instances of any <bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Integer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> types using the not-equal-to operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>!=<ept i="2">&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、何らかの<bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Integer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のインスタンスの不等性を不等演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>!=<ept i="2">&lt;/c2&gt;</ept>）使って確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can compare instances of an <bpt i="0" x="0">&lt;e0&gt;</bpt>equatable<ept i="0">&lt;/e0&gt;</ept> type by using the equal-to (<bpt i="1" x="1">&lt;c1&gt;</bpt>==<ept i="1">&lt;/c1&gt;</ept>) and not-equal-to (<bpt i="2" x="2">&lt;c2&gt;</bpt>!=<ept i="2">&lt;/c2&gt;</ept>) operators.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="0" x="0">&lt;e0&gt;</bpt>equatable<ept i="0">&lt;/e0&gt;</ept>型のインスタンスを比較することが、同等（<bpt i="1" x="1">&lt;c1&gt;</bpt>==<ept i="1">&lt;/c1&gt;</ept>）および不等（<bpt i="2" x="2">&lt;c2&gt;</bpt>!=<ept i="2">&lt;/c2&gt;</ept>）演算子によって行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can compare instances of any <bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Integer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> types using the greater-than operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>&gt;<ept i="2">&lt;/c2&gt;</ept>), even if the two instances are of different types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、何らかの<bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Integer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のインスタンスをより大きい演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>&gt;<ept i="2">&lt;/c2&gt;</ept>）を使って比較できます、２つのインスタンスが異なる型であるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can compare instances of any <bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Integer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> types using the greater-than-or-equal-to operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>&gt;=<ept i="2">&lt;/c2&gt;</ept>), even if the two instances are of different types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、何らかの<bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Integer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のインスタンスをより大きいか等しい演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>&gt;=<ept i="2">&lt;/c2&gt;</ept>）使って比較できます、２つのインスタンスが異なる型であるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can compare instances of any <bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Integer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> types using the less-than operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>&lt;<ept i="2">&lt;/c2&gt;</ept>), even if the two instances are of different types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、何らかの<bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Integer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のインスタンスをより小さい演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>&lt;<ept i="2">&lt;/c2&gt;</ept>）を使って比較できます、２つのインスタンスが異なる型であるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can compare instances of any <bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Integer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> types using the less-than-or-equal-to operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>&lt;=<ept i="2">&lt;/c2&gt;</ept>), even if the two instances are of different types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、何らかの<bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Integer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型のインスタンスをより小さいか等しい演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>&lt;=<ept i="2">&lt;/c2&gt;</ept>）使って比較できます、２つのインスタンスが異なる型であるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can confirm the data value’s underlying type by retrieving a non-<bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept> value from <bpt i="6" x="6">&lt;a6&gt;</bpt><bpt i="7" x="7">&lt;c7&gt;</bpt>double<bpt i="8" x="8">&lt;w8&gt;</bpt>Value<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept><ept i="6">&lt;/a6&gt;</ept> or by inspecting the <bpt i="9" x="9">&lt;a9&gt;</bpt><bpt i="10" x="10">&lt;c10&gt;</bpt>type<ept i="10">&lt;/c10&gt;</ept><ept i="9">&lt;/a9&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、データ値のもつ基礎をなす型を確認することが、非<bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept>値を<bpt i="6" x="6">&lt;a6&gt;</bpt><bpt i="7" x="7">&lt;c7&gt;</bpt>double<bpt i="8" x="8">&lt;w8&gt;</bpt>Value<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept><ept i="6">&lt;/a6&gt;</ept>から回収することによって、または<bpt i="9" x="9">&lt;a9&gt;</bpt><bpt i="10" x="10">&lt;c10&gt;</bpt>type<ept i="10">&lt;/c10&gt;</ept><ept i="9">&lt;/a9&gt;</ept>プロパティを調査することによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can confirm the data value’s underlying type by retrieving a non-<bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept> value from <bpt i="6" x="6">&lt;a6&gt;</bpt><bpt i="7" x="7">&lt;c7&gt;</bpt>int<bpt i="8" x="8">&lt;w8&gt;</bpt>Value<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept><ept i="6">&lt;/a6&gt;</ept> or by inspecting the <bpt i="9" x="9">&lt;a9&gt;</bpt><bpt i="10" x="10">&lt;c10&gt;</bpt>type<ept i="10">&lt;/c10&gt;</ept><ept i="9">&lt;/a9&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、データ値のもつ基礎をなす型を確認することが、非<bpt i="5" x="5">&lt;c5&gt;</bpt>nil<ept i="5">&lt;/c5&gt;</ept>値を<bpt i="6" x="6">&lt;a6&gt;</bpt><bpt i="7" x="7">&lt;c7&gt;</bpt>int<bpt i="8" x="8">&lt;w8&gt;</bpt>Value<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept><ept i="6">&lt;/a6&gt;</ept>から回収することによって、または<bpt i="9" x="9">&lt;a9&gt;</bpt><bpt i="10" x="10">&lt;c10&gt;</bpt>type<ept i="10">&lt;/c10&gt;</ept><ept i="9">&lt;/a9&gt;</ept>プロパティを調査することによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can confirm the data value’s underlying type by retrieving a non-<bpt i="8" x="8">&lt;c8&gt;</bpt>nil<ept i="8">&lt;/c8&gt;</ept> value from <bpt i="9" x="9">&lt;a9&gt;</bpt><bpt i="10" x="10">&lt;c10&gt;</bpt>dictionary<bpt i="11" x="11">&lt;w11&gt;</bpt>Value<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept><ept i="9">&lt;/a9&gt;</ept> or by inspecting the <bpt i="12" x="12">&lt;a12&gt;</bpt><bpt i="13" x="13">&lt;c13&gt;</bpt>type<ept i="13">&lt;/c13&gt;</ept><ept i="12">&lt;/a12&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、データ値のもつ基礎をなす型を確認することが、非<bpt i="8" x="8">&lt;c8&gt;</bpt>nil<ept i="8">&lt;/c8&gt;</ept>値を<bpt i="9" x="9">&lt;a9&gt;</bpt><bpt i="10" x="10">&lt;c10&gt;</bpt>dictionary<bpt i="11" x="11">&lt;w11&gt;</bpt>Value<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept><ept i="9">&lt;/a9&gt;</ept>から回収することによって、または<bpt i="12" x="12">&lt;a12&gt;</bpt><bpt i="13" x="13">&lt;c13&gt;</bpt>type<ept i="13">&lt;/c13&gt;</ept><ept i="12">&lt;/a12&gt;</ept>プロパティを調査することによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can confirm the data value’s underlying type by retrieving a non-<bpt i="8" x="8">&lt;c8&gt;</bpt>nil<ept i="8">&lt;/c8&gt;</ept> value from <bpt i="9" x="9">&lt;a9&gt;</bpt><bpt i="10" x="10">&lt;c10&gt;</bpt>sequence<bpt i="11" x="11">&lt;w11&gt;</bpt>Value<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept><ept i="9">&lt;/a9&gt;</ept> or by inspecting the <bpt i="12" x="12">&lt;a12&gt;</bpt><bpt i="13" x="13">&lt;c13&gt;</bpt>type<ept i="13">&lt;/c13&gt;</ept><ept i="12">&lt;/a12&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、データ値のもつ基礎をなす型を確認することが、非<bpt i="8" x="8">&lt;c8&gt;</bpt>nil<ept i="8">&lt;/c8&gt;</ept>値を<bpt i="9" x="9">&lt;a9&gt;</bpt><bpt i="10" x="10">&lt;c10&gt;</bpt>sequence<bpt i="11" x="11">&lt;w11&gt;</bpt>Value<ept i="11">&lt;/w11&gt;</ept><ept i="10">&lt;/c10&gt;</ept><ept i="9">&lt;/a9&gt;</ept>から回収することによって、または<bpt i="12" x="12">&lt;a12&gt;</bpt><bpt i="13" x="13">&lt;c13&gt;</bpt>type<ept i="13">&lt;/c13&gt;</ept><ept i="12">&lt;/a12&gt;</ept>プロパティを調査することによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can create a mirror for any type using the <bpt i="0" x="0">&lt;c0&gt;</bpt>Mirror(reflecting:)<ept i="0">&lt;/c0&gt;</ept> initializer, but if you are not satisfied with the mirror supplied for your type by default, you can make it conform to <bpt i="1" x="1">&lt;c1&gt;</bpt>Custom<bpt i="2" x="2">&lt;w2&gt;</bpt>Reflectable<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> and return a custom <bpt i="3" x="3">&lt;c3&gt;</bpt>Mirror<ept i="3">&lt;/c3&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、任意の型に対してミラーを作成することが<bpt i="0" x="0">&lt;c0&gt;</bpt>Mirror(reflecting:)<ept i="0">&lt;/c0&gt;</ept>イニシャライザを使って可能です、しかしあなたの型に対して初期状態で提供されるミラーに満足しないならば、あなたはそれを<bpt i="1" x="1">&lt;c1&gt;</bpt>Custom<bpt i="2" x="2">&lt;w2&gt;</bpt>Reflectable<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠させてあつらえの<bpt i="3" x="3">&lt;c3&gt;</bpt>Mirror<ept i="3">&lt;/c3&gt;</ept>を返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can create an empty array by specifying the <bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept> type of your array in the declaration.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは空の配列を、あなたの配列の<bpt i="0" x="0">&lt;c0&gt;</bpt>Element<ept i="0">&lt;/c0&gt;</ept>型をその宣言において指定することで作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can create new instances of a type that conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Integer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol from a floating-point number or another binary integer of any type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、ある型の新しいインスタンスで<bpt i="0" x="0">&lt;c0&gt;</bpt>Binary<bpt i="1" x="1">&lt;w1&gt;</bpt>Integer<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠するものを、浮動小数点数またはどんな型であれ別のバイナリ整数から作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can create your own singletons as a way to provide a unified access point to a resource or service that’s shared across an app, like an audio channel to play sound effects or a network manager to make HTTP requests.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、サウンドエフェクトを再生するオーディオチャンネルやHTTPリクエストを行うネットワークマネージャのような、あるアプリ全体で共有されるリソースやサービスへの一本化されたアクセスポイントを提供する方法として、あなた自身のシングルトンを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can decompose the tuple in a <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> loop, which calls <bpt i="2" x="2">&lt;c2&gt;</bpt>make<bpt i="3" x="3">&lt;w3&gt;</bpt>Iterator()<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> behind the scenes, or when calling the iterator’s <bpt i="4" x="4">&lt;c4&gt;</bpt>next()<ept i="4">&lt;/c4&gt;</ept> method directly.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはこのタプルを分解することが、<bpt i="2" x="2">&lt;c2&gt;</bpt>make<bpt i="3" x="3">&lt;w3&gt;</bpt>Iterator()<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>を各場面の裏側で呼ぶ<bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> ループにおいて、またはイテレータの持つ<bpt i="4" x="4">&lt;c4&gt;</bpt>next()<ept i="4">&lt;/c4&gt;</ept>メソッドを直に呼び出すときに行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can expect faster execution when the collections share many common elements, or if <bpt i="6" x="6">&lt;c6&gt;</bpt>Element<ept i="6">&lt;/c6&gt;</ept> conforms to <bpt i="7" x="7">&lt;c7&gt;</bpt>Hashable<ept i="7">&lt;/c7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはより速い遂行を予想できます、コレクションそれらが多くの普通の要素を共有する場合は、またはもし<bpt i="6" x="6">&lt;c6&gt;</bpt>Element<ept i="6">&lt;/c6&gt;</ept>が<bpt i="7" x="7">&lt;c7&gt;</bpt>Hashable<ept i="7">&lt;/c7&gt;</ept>に準拠するならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can expect faster execution when the collections share many common elements.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはより速い遂行を予想できます、コレクションそれらが多くの普通の要素を共有する場合は。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can feed data to the hasher using a series of calls to mutating <bpt i="1" x="1">&lt;c1&gt;</bpt>combine<ept i="1">&lt;/c1&gt;</ept> methods.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、データをハーシャーに送り込むのに、一連の変更<bpt i="1" x="1">&lt;c1&gt;</bpt>combine<ept i="1">&lt;/c1&gt;</ept>メソッド呼び出しを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can find a complete set of a collection’s valid indices by starting with the collection’s <bpt i="0" x="0">&lt;c0&gt;</bpt>start<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> property and finding every successor up to, and including, the <bpt i="2" x="2">&lt;c2&gt;</bpt>end<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> property.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはコレクションの有効なインデックスの完全な一揃いを見つけることが、そのコレクションの<bpt i="0" x="0">&lt;c0&gt;</bpt>start<bpt i="1" x="1">&lt;w1&gt;</bpt>Index<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロパティで開始して、すべての後に続くものを<bpt i="2" x="2">&lt;c2&gt;</bpt>end<bpt i="3" x="3">&lt;w3&gt;</bpt>Index<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロパティまで、それを含めて、見つけ出すことによって行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can initialize a variable of any of these types using a string literal that holds a single Unicode scalar.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、これらのいずれかの型の変数を初期化することが、単一のユニコードスカラーを保持する文字列リテラルを使って行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can initialize a variable or constant of any of these types by assigning a floating-point literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、これらの型どれかの変数または定数を、浮動小数点リテラルを割り当てることによって初期化できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can initialize a variable or constant of any of these types by assigning an integer literal.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、それらの型のどれかの変数や定数を初期化することが、整数リテラルを割り当てることによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can initialize a variable or constant of any of these types using a string literal that holds a single character.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、これらの型のどれかの変数または定数を、単一の文字を保持する文字列リテラルを使って初期化できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can initialize a variable or constant of either of these types using a string literal of any length.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、それらの型のいずれかの変数や定数を初期化することが随意の長さの文字列リテラルを使って行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can iterate over a dictionary using a <bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept> loop, decomposing each key-value pair into the elements of a tuple.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは辞書全体にわたって反復適用していくことが、<bpt i="0" x="0">&lt;c0&gt;</bpt>for<ept i="0">&lt;/c0&gt;</ept>-<bpt i="1" x="1">&lt;c1&gt;</bpt>in<ept i="1">&lt;/c1&gt;</ept>ループを使うことで、各キー値ペアをタプルの要素へと分解しながら可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can make many custom types equatable and hashable by simply declaring these protocol conformances in the same file as the type's original declaration.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、多くのあつらえの型をequatableおよびhashableにすることが、単にそれらプロトコル準拠をその型の原型の宣言と同じファイルにおいて宣言することによって行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can only use key-value observing with classes that inherit from <bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>NSObject<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはキー値監視を、<bpt i="0" x="0">&lt;a0&gt;</bpt><bpt i="1" x="1">&lt;c1&gt;</bpt>NSObject<ept i="1">&lt;/c1&gt;</ept><ept i="0">&lt;/a0&gt;</ept>から継承するクラスでのみ使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can pass only valid indices to collection operations.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは有効なインデックスだけをコレクション演算子に渡せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can pass zero or more items to the <bpt i="0" x="0">&lt;c0&gt;</bpt>debug<bpt i="1" x="1">&lt;w1&gt;</bpt>Print(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>separator:<bpt i="3" x="3">&lt;w3&gt;</bpt>terminator:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、ゼロ個以上の項目を<bpt i="0" x="0">&lt;c0&gt;</bpt>debug<bpt i="1" x="1">&lt;w1&gt;</bpt>Print(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>separator:<bpt i="3" x="3">&lt;w3&gt;</bpt>terminator:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数に渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can pass zero or more items to the <bpt i="0" x="0">&lt;c0&gt;</bpt>debug<bpt i="1" x="1">&lt;w1&gt;</bpt>Print(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>separator:<bpt i="3" x="3">&lt;w3&gt;</bpt>terminator:<bpt i="4" x="4">&lt;w4&gt;</bpt>to:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、ゼロ個以上の項目を<bpt i="0" x="0">&lt;c0&gt;</bpt>debug<bpt i="1" x="1">&lt;w1&gt;</bpt>Print(_:<bpt i="2" x="2">&lt;w2&gt;</bpt>separator:<bpt i="3" x="3">&lt;w3&gt;</bpt>terminator:<bpt i="4" x="4">&lt;w4&gt;</bpt>to:)<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数に渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can pass zero or more items to the <bpt i="0" x="0">&lt;c0&gt;</bpt>print(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>separator:<bpt i="2" x="2">&lt;w2&gt;</bpt>terminator:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、ゼロ個以上の項目を<bpt i="0" x="0">&lt;c0&gt;</bpt>print(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>separator:<bpt i="2" x="2">&lt;w2&gt;</bpt>terminator:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数に渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can pass zero or more items to the <bpt i="0" x="0">&lt;c0&gt;</bpt>print(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>separator:<bpt i="2" x="2">&lt;w2&gt;</bpt>terminator:<bpt i="3" x="3">&lt;w3&gt;</bpt>to:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、ゼロ個以上の項目を<bpt i="0" x="0">&lt;c0&gt;</bpt>print(_:<bpt i="1" x="1">&lt;w1&gt;</bpt>separator:<bpt i="2" x="2">&lt;w2&gt;</bpt>terminator:<bpt i="3" x="3">&lt;w3&gt;</bpt>to:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>関数に渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can rely on automatic synthesis of the <bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept> protocol’s requirements for a custom type when you declare <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept> conformance in the type’s original declaration and your type meets these criteria:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept>プロトコルの要件の自動合成をあつらえの型のために当てにすることが、あなたが<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>準拠をその型のもつ元々の宣言において宣言してあなたの型がそれらの基準に沿う場合に可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can replace an existing element with a new value by assigning the new value to the subscript.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、既存の要素を新しい値で置き換えることが、新しい値をその添え字に代入することで行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can retrieve the same slice using the string’s ranged subscript, which takes a range expression.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、同じスライスを文字列の範囲指定された添え字を使って取って来ることができます、それは範囲式をとっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can reverse a collection without allocating new space for its elements by calling this <bpt i="0" x="0">&lt;c0&gt;</bpt>reversed()<ept i="0">&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、あるコレクションを逆順にすることがそれの要素に対して新しい空間を割り当てることなく<bpt i="0" x="0">&lt;c0&gt;</bpt>reversed()<ept i="0">&lt;/c0&gt;</ept>メソッドによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can search a dictionary’s contents for a particular value using the <bpt i="0" x="0">&lt;c0&gt;</bpt>contains(where:)<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>first<bpt i="2" x="2">&lt;w2&gt;</bpt>Index(where:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> methods supplied by default implementation.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、ある特定の値を求めて辞書の持つ内容を検索することが、省略時の実装で提供される<bpt i="0" x="0">&lt;c0&gt;</bpt>contains(where:)<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>first<bpt i="2" x="2">&lt;w2&gt;</bpt>Index(where:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>メソッドを使って可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can sort any mutable collection of elements that conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept> protocol by calling this method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する要素からなるあらゆる可変の配列をこのメソッドを呼び出すことによってソートできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can sort any sequence of elements that conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept> protocol by calling this method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはいくらかの要素からなる何らかのシーケンスで<bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠するものをこのメソッドを呼び出すことによってソートする（並び替える）ことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can store indices in variables, and pass them to collection algorithms or use them later to access the corresponding element.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはこのようなインデックスを変数に格納して、それらを幾つかあるコレクションアルゴリズムに渡すことや、相当する要素にアクセスするためにそれらを後で使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can store mixed-type keys in dictionaries and other collections that require <bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept> conformance by wrapping mixed-type keys in <bpt i="1" x="1">&lt;c1&gt;</bpt>Any<bpt i="2" x="2">&lt;w2&gt;</bpt>Hashable<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> instances:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは混成型のキーを様々な辞書や他のコレクションに格納できます、それらは混成型キーを<bpt i="1" x="1">&lt;c1&gt;</bpt>Any<bpt i="2" x="2">&lt;w2&gt;</bpt>Hashable<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>インスタンスの中へのラップする<bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept>準拠を必要とします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can subscript a collection with any valid index other than the collection’s end index.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、そのコレクションの末尾インデックスの以外のあらゆる有効なインデックスで、コレクションに対して添え字を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can subscript an array with any integer from zero up to, but not including, the count of the array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、ゼロから配列の総数まで、しかしそれを含めず、任意の整数で添え字を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can take advantage of this compiler support when defining your own custom enumeration by declaring conformance to <bpt i="0" x="0">&lt;c0&gt;</bpt>Case<bpt i="1" x="1">&lt;w1&gt;</bpt>Iterable<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> in the enumeration’s original declaration.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはこのコンパイラサポートを、あなた独自のあつらえの列挙を<bpt i="0" x="0">&lt;c0&gt;</bpt>Case<bpt i="1" x="1">&lt;w1&gt;</bpt>Iterable<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>への準拠をその列挙の元の宣言において宣言することによって定義する場合に利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use <bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Iterator<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to hide the type signature of a more complex iterator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Iterator<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使って、あるより複雑なイテレータの型シグネチャを隠すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use <bpt i="0" x="0">&lt;c0&gt;</bpt>pop<bpt i="1" x="1">&lt;w1&gt;</bpt>Last()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to remove the last element of a collection that might be empty.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>pop<bpt i="1" x="1">&lt;w1&gt;</bpt>Last()<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使って、空であるかもしれないコレクションの最後の要素を削除できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use <bpt i="0" x="0">&lt;c0&gt;</bpt>stride(from:<bpt i="1" x="1">&lt;w1&gt;</bpt>through:<bpt i="2" x="2">&lt;w2&gt;</bpt>by:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to create a sequence that strides upward or downward.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>stride(from:<bpt i="1" x="1">&lt;w1&gt;</bpt>through:<bpt i="2" x="2">&lt;w2&gt;</bpt>by:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使って上向きまたは下向きにまたいで越えるシーケンスを作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use <bpt i="0" x="0">&lt;c0&gt;</bpt>stride(from:<bpt i="1" x="1">&lt;w1&gt;</bpt>to:<bpt i="2" x="2">&lt;w2&gt;</bpt>by:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> to create a sequence that strides upward or downward.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>stride(from:<bpt i="1" x="1">&lt;w1&gt;</bpt>to:<bpt i="2" x="2">&lt;w2&gt;</bpt>by:)<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使って上向きまたは下向きにまたいで越えるシーケンスを作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use <bpt i="3" x="3">&lt;c3&gt;</bpt>==<ept i="3">&lt;/c3&gt;</ept> to check for equality between any two instances or call the <bpt i="4" x="4">&lt;c4&gt;</bpt>Equatable<ept i="4">&lt;/c4&gt;</ept>-constrained <bpt i="5" x="5">&lt;c5&gt;</bpt>contains(_:)<ept i="5">&lt;/c5&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは<bpt i="3" x="3">&lt;c3&gt;</bpt>==<ept i="3">&lt;/c3&gt;</ept>を使って何でも２つのインスタンス間の同等性を調べたり、<bpt i="4" x="4">&lt;c4&gt;</bpt>Equatable<ept i="4">&lt;/c4&gt;</ept>制約の<bpt i="5" x="5">&lt;c5&gt;</bpt>contains(_:)<ept i="5">&lt;/c5&gt;</ept>メソッドを呼び出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use Objective-C and Swift files together in a single project, no matter which language the project used originally.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはObjective-CおよびSwiftファイルを一緒にしてある単一のプロジェクトの中で使うことができます、どちらの言語をそのプロジェクトが最初に使用しようとも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use a <bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<bpt i="1" x="1">&lt;w1&gt;</bpt>Of<bpt i="2" x="2">&lt;w2&gt;</bpt>One<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance when you need to efficiently represent a single value as a collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Collection<bpt i="1" x="1">&lt;w1&gt;</bpt>Of<bpt i="2" x="2">&lt;w2&gt;</bpt>One<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを、あなたが単一の値をコレクションとして効率的に表す必要がある場合に使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use an array literal anywhere an instance of an <bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>Array<bpt i="3" x="3">&lt;w3&gt;</bpt>Literal<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> type is expected: as a value assigned to a variable or constant, as a parameter to a method or initializer, or even as the subject of a nonmutating operation like <bpt i="4" x="4">&lt;c4&gt;</bpt>map(_:)<ept i="4">&lt;/c4&gt;</ept> or <bpt i="5" x="5">&lt;c5&gt;</bpt>filter(_:)<ept i="5">&lt;/c5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは配列リテラルを<bpt i="0" x="0">&lt;c0&gt;</bpt>Expressible<bpt i="1" x="1">&lt;w1&gt;</bpt>By<bpt i="2" x="2">&lt;w2&gt;</bpt>Array<bpt i="3" x="3">&lt;w3&gt;</bpt>Literal<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>型が予期されるところはどこででも使うことができます：変数や定数に割り当てられる値として、メソッドやイニシャライザへのパラメータとして、または<bpt i="4" x="4">&lt;c4&gt;</bpt>map(_:)<ept i="4">&lt;/c4&gt;</ept>や<bpt i="5" x="5">&lt;c5&gt;</bpt>filter(_:)<ept i="5">&lt;/c5&gt;</ept>のような非変更の操作のサブジェクトとしてさえも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use any type that conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept> protocol in a set or as a dictionary key.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>Hashable<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠するあらゆる型を集合においてまたは辞書キーとして使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use optional chaining to call the <bpt i="5" x="5">&lt;c5&gt;</bpt>@objc<ept i="5">&lt;/c5&gt;</ept> method <bpt i="6" x="6">&lt;c6&gt;</bpt>get<bpt i="7" x="7">&lt;w7&gt;</bpt>Integer<bpt i="8" x="8">&lt;w8&gt;</bpt>Value()<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept> on <bpt i="9" x="9">&lt;c9&gt;</bpt>obj<ept i="9">&lt;/c9&gt;</ept> safely.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、オプショナル連鎖を使って、<bpt i="5" x="5">&lt;c5&gt;</bpt>@objc<ept i="5">&lt;/c5&gt;</ept>メソッド<bpt i="6" x="6">&lt;c6&gt;</bpt>get<bpt i="7" x="7">&lt;w7&gt;</bpt>Integer<bpt i="8" x="8">&lt;w8&gt;</bpt>Value()<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/c6&gt;</ept>を<bpt i="9" x="9">&lt;c9&gt;</bpt>obj<ept i="9">&lt;/c9&gt;</ept>上で安全に呼び出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use relational operators, such as the less-than and equal-to operators (<bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>==<ept i="1">&lt;/c1&gt;</ept>), to compare instances of different binary integer types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、関係演算子、例えばより小さいそして同等演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>&lt;<ept i="0">&lt;/c0&gt;</ept>そして<bpt i="1" x="1">&lt;c1&gt;</bpt>==<ept i="1">&lt;/c1&gt;</ept>）などを使って、異なるバイナリ整数型のインスタンス同士を比較できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use special versions of some sequence and collection operations when working with a <bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept> type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、特別版のなんらかのシーケンスやコレクション演算をある<bpt i="0" x="0">&lt;c0&gt;</bpt>Comparable<ept i="0">&lt;/c0&gt;</ept>型を扱うときに使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use the <bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Class<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> protocol as the concrete type for an instance of any class.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Class<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>プロトコルをあらゆるクラスのインスタンスに対して具象型として使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use the <bpt i="0" x="0">&lt;c0&gt;</bpt>relative(to:)<ept i="0">&lt;/c0&gt;</ept> method to convert a range expression, which could be missing one or both of its endpoints, into a concrete range that is bounded on both sides.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>relative(to:)<ept i="0">&lt;/c0&gt;</ept>メソッドを使うことによって、それの端点の両方または１つを抜かすことができる範囲式を、両方の側で閉ざされた具体的な範囲へと変換できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use the <bpt i="0" x="0">&lt;c0&gt;</bpt>type(of:)<ept i="0">&lt;/c0&gt;</ept> function to find the dynamic type of a value, particularly when the dynamic type is different from the static type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>type(of:)<ept i="0">&lt;/c0&gt;</ept>を使うことである値の動的型を見つけることができます、とりわけ動的型が静的型と異なる場合に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use the <bpt i="4" x="4">&lt;c4&gt;</bpt>magnitude<ept i="4">&lt;/c4&gt;</ept> property in operations that are simpler to implement in terms of unsigned values, such as printing the value of an integer, which is just printing a ‘-’ character in front of an absolute value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="4" x="4">&lt;c4&gt;</bpt>magnitude<ept i="4">&lt;/c4&gt;</ept>プロパティを、ずっと単純に符号なしの値に関して実装する演算において使用できます、例えば整数の値を印字することなど、それはちょっと「-」文字を絶対値の前に印字しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use the conditional type cast operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>as?<ept i="0">&lt;/c0&gt;</ept>), which returns an optional value of the type you are trying to downcast to:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、条件付き型キャスト演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>as?<ept i="0">&lt;/c0&gt;</ept>）を使うことができます、それはあなたがそれへとダウンキャストを試みる型のオプショナル値を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use the equal-to operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept>) to compare any two arrays that store the same, <bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>-conforming element type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、同等演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>==<ept i="0">&lt;/c0&gt;</ept>）を使って同じ、<bpt i="1" x="1">&lt;c1&gt;</bpt>Equatable<ept i="1">&lt;/c1&gt;</ept>準拠の、要素型を格納する任意の２つの配列を比較できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use the pattern-matching operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>~=<ept i="0">&lt;/c0&gt;</ept>) to test whether a value is included in a range.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、このパターンマッチング演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>~=<ept i="0">&lt;/c0&gt;</ept>）を使うことで、ある値がある範囲に含まれるかどうか検査できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use the predicate to check for an element of a type that doesn’t conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept> protocol, or to find an element that satisfies a general condition.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは述部を使うことで、<bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠しない型の要素を調べること、またはある一般的条件を満たす要素を見つけることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use the predicate to check for an element of a type that doesn’t conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept> protocol, such as the <bpt i="1" x="1">&lt;c1&gt;</bpt>HTTPResponse<ept i="1">&lt;/c1&gt;</ept> enumeration in this example.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは述部を使って、<bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠しない型、例えばこの例での<bpt i="1" x="1">&lt;c1&gt;</bpt>HTTPResponse<ept i="1">&lt;/c1&gt;</ept>列挙などの要素に対して調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use the predicate to find an element of a type that doesn’t conform to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept> protocol or to find an element that matches particular criteria.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは述部を使って、<bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠しない型の要素を見つける、または特定の基準に合致する要素を見つけることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use the unary plus operator (<bpt i="0" x="0">&lt;c0&gt;</bpt>+<ept i="0">&lt;/c0&gt;</ept>) to provide symmetry in your code for positive numbers when also using the unary minus operator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、単行プラス演算子（<bpt i="0" x="0">&lt;c0&gt;</bpt>+<ept i="0">&lt;/c0&gt;</ept>）を使うことで、均整美をあなたのコードにおいて正の数に対して単行マイナス演算子もまた使う場合に提供できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use this function to call an API that takes an escaping closure in a way that doesn’t allow the closure to escape in practice.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはこの関数を使うことで、クロージャが脱出するのを実際には許可されないある方法において脱出クロージャをとるAPIを呼び出せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use this function to stride over values of any type that conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Strideable<ept i="0">&lt;/c0&gt;</ept> protocol, such as integers or floating-point types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、この関数を使って<bpt i="0" x="0">&lt;c0&gt;</bpt>Strideable<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する任意の型、例えば整数や浮動小数点型の値いくつかをまたいで越すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use this initializer to create an array from any other type that conforms to the <bpt i="0" x="0">&lt;c0&gt;</bpt>Sequence<ept i="0">&lt;/c0&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはこのイニシャライザを使って、<bpt i="0" x="0">&lt;c0&gt;</bpt>Sequence<ept i="0">&lt;/c0&gt;</ept>プロトコルに準拠する何か他の型から配列を作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、あるコレクションのインデックスからなる、この型の部分的範囲を使うことで、その部分的な範囲の下側の境界からそのコレクションの終わりまでの範囲を表すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、あるコレクションのインデックスからなる、この型の部分的範囲を使うことで、コレクションの始まりからその部分的な範囲の上側の境界までの、そしてそれを含んでいる範囲を表すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、あるコレクションのインデックスからなる、この型の部分的範囲を使うことで、コレクションの始まりからその部分的な範囲の上側の境界までの、しかしそれを含んでいない範囲を表すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use your own custom types as dictionary keys by making them conform to the <bpt i="2" x="2">&lt;c2&gt;</bpt>Hashable<ept i="2">&lt;/c2&gt;</ept> protocol.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、あなた独自のあつらえの型を辞書のキーとして使うことがそれらを<bpt i="2" x="2">&lt;c2&gt;</bpt>Hashable<ept i="2">&lt;/c2&gt;</ept>プロトコルに準拠させることによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can work with types declared in Swift from within the Objective-C code in your project by importing an Xcode-generated header file.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、Swiftにおいて宣言される型をあなたのプロジェクトの中のObjective-Cコード内から扱うことが、Xcode生成のヘッダファイルをインポートすることによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can write generic methods that operate on any numeric type in the standard library by using the <bpt i="2" x="2">&lt;c2&gt;</bpt>Additive<bpt i="3" x="3">&lt;w3&gt;</bpt>Arithmetic<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> protocol as a generic constraint.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="2" x="2">&lt;c2&gt;</bpt>Additive<bpt i="3" x="3">&lt;w3&gt;</bpt>Arithmetic<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロトコルを総称体制約として使うことで、標準ライブラリのあらゆる数値型上で作用する総称体メソッドを書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You cannot use <bpt i="0" x="0">&lt;c0&gt;</bpt>*<ept i="0">&lt;/c0&gt;</ept> with arguments of different types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>*<ept i="0">&lt;/c0&gt;</ept>をそれぞれが異なる型である引数で使うことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You cannot use <bpt i="0" x="0">&lt;c0&gt;</bpt>+<ept i="0">&lt;/c0&gt;</ept> with arguments of different types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>+<ept i="0">&lt;/c0&gt;</ept>をそれぞれが異なる型である引数で使うことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You cannot use <bpt i="0" x="0">&lt;c0&gt;</bpt>-<ept i="0">&lt;/c0&gt;</ept> with arguments of different types.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>-<ept i="0">&lt;/c0&gt;</ept>をそれぞれが異なる型である引数で使うことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You cannot use a <bpt i="0" x="0">&lt;c0&gt;</bpt>break<ept i="0">&lt;/c0&gt;</ept> or <bpt i="1" x="1">&lt;c1&gt;</bpt>continue<ept i="1">&lt;/c1&gt;</ept> statement to exit the current call of the <bpt i="2" x="2">&lt;c2&gt;</bpt>body<ept i="2">&lt;/c2&gt;</ept> closure or skip subsequent calls.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>break<ept i="0">&lt;/c0&gt;</ept>または<bpt i="1" x="1">&lt;c1&gt;</bpt>continue<ept i="1">&lt;/c1&gt;</ept>文を使って、<bpt i="2" x="2">&lt;c2&gt;</bpt>body<ept i="2">&lt;/c2&gt;</ept>クロージャの現在の呼び出しを抜け出したり、または続いて起こる呼び出しを飛ばしたりできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can’t initialize a type that conforms to <bpt i="1" x="1">&lt;c1&gt;</bpt>Expressible<bpt i="2" x="2">&lt;w2&gt;</bpt>By<bpt i="3" x="3">&lt;w3&gt;</bpt>Array<bpt i="4" x="4">&lt;w4&gt;</bpt>Literal<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept> simply by assigning an existing array.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、既存の配列を割り当てることで<bpt i="1" x="1">&lt;c1&gt;</bpt>Expressible<bpt i="2" x="2">&lt;w2&gt;</bpt>By<bpt i="3" x="3">&lt;w3&gt;</bpt>Array<bpt i="4" x="4">&lt;w4&gt;</bpt>Literal<ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/c1&gt;</ept>に準拠する型を初期化することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can’t initialize a type that conforms to <bpt i="2" x="2">&lt;c2&gt;</bpt>Expressible<bpt i="3" x="3">&lt;w3&gt;</bpt>By<bpt i="4" x="4">&lt;w4&gt;</bpt>Dictionary<bpt i="5" x="5">&lt;w5&gt;</bpt>Literal<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> simply by assigning an instance of <bpt i="6" x="6">&lt;c6&gt;</bpt>Dictionary<ept i="6">&lt;/c6&gt;</ept>, <bpt i="7" x="7">&lt;c7&gt;</bpt>Key<bpt i="8" x="8">&lt;w8&gt;</bpt>Value<bpt i="9" x="9">&lt;w9&gt;</bpt>Pairs<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>, or similar.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="2" x="2">&lt;c2&gt;</bpt>Expressible<bpt i="3" x="3">&lt;w3&gt;</bpt>By<bpt i="4" x="4">&lt;w4&gt;</bpt>Dictionary<bpt i="5" x="5">&lt;w5&gt;</bpt>Literal<ept i="5">&lt;/w5&gt;</ept><ept i="4">&lt;/w4&gt;</ept><ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>に準拠する型を単純に<bpt i="6" x="6">&lt;c6&gt;</bpt>Dictionary<ept i="6">&lt;/c6&gt;</ept>、<bpt i="7" x="7">&lt;c7&gt;</bpt>Key<bpt i="8" x="8">&lt;w8&gt;</bpt>Value<bpt i="9" x="9">&lt;w9&gt;</bpt>Pairs<ept i="9">&lt;/w9&gt;</ept><ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/c7&gt;</ept>、または似たものを割り当てることによって初期化できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You choose which method to use based on whether the API you are invoking returns an unretained or a retained object.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはどちらかのメソッドを、あなたが呼んでいるAPIが、リテイン（保有）されないまたはリテインされるオブジェクトを返すのかに基づき選択して使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You could use the <bpt i="3" x="3">&lt;c3&gt;</bpt>id<ept i="3">&lt;/c3&gt;</ept> property to identify a particular user even if other data fields change, such as the user’s name.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、その<bpt i="3" x="3">&lt;c3&gt;</bpt>id<ept i="3">&lt;/c3&gt;</ept>プロパティを使って、特定のユーザを識別できます、たとえ他のデータフィールド、たとえばそのユーザのもつ名前などが変わるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You create a <bpt i="0" x="0">&lt;c0&gt;</bpt>Closed<bpt i="1" x="1">&lt;w1&gt;</bpt>Range<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instance by using the closed range operator (<bpt i="2" x="2">&lt;c2&gt;</bpt>...<ept i="2">&lt;/c2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="0" x="0">&lt;c0&gt;</bpt>Closed<bpt i="1" x="1">&lt;w1&gt;</bpt>Range<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>インスタンスを完結範囲演算子（<bpt i="2" x="2">&lt;c2&gt;</bpt>...<ept i="2">&lt;/c2&gt;</ept>）を使って作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You create simple singletons using a static type property, which is guaranteed to be lazily initialized only once, even when accessed across multiple threads simultaneously:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは単純なシングルトンをstatic型プロパティを使って作成できます、それはただ一度だけ遅延初期化されることを保証されます、たとえ複数のスレッドから同時にアクセスされる場合でさえもです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You don’t need to do anything special to create the generated header—just import it to use its contents in your Objective-C code.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、生成ヘッダを作成するために特に何もする必要はありません ― あなたは、ただ単にそれをインポートしてそれの内容をあなたのObjective-Cコードにおいて使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You might not anticipate the consequences of changing a heavily shared instance, so it's more work to write such code correctly.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、重く共有されるインスタンスの変更の帰着を見越して備えられないかもしれません、それでそのようなコードを正しく書くためにさらに仕事が増えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You must call a resume method exactly once on every execution path throughout the program.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、ある再開メソッドをあらゆる遂行経路上でそのプログラムの間を通して厳密に一度だけ呼び出さなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You must not call this method if any other copy of this iterator has been advanced with a call to its <bpt i="0" x="0">&lt;c0&gt;</bpt>next()<ept i="0">&lt;/c0&gt;</ept> method.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、このイテレータの何か他のコピーがそれの<bpt i="0" x="0">&lt;c0&gt;</bpt>next()<ept i="0">&lt;/c0&gt;</ept>メソッドを呼び出すことで前に進められるならば、このメソッドを呼び出す必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You must resume the continuation exactly once.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、厳密に一度だけ継続を再開しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You must use only one kind of top-level encoding container.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、ある種のトップレベルのエンコーディングコンテナのみを使う必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You need to manually implement <bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept> and <bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept> conformance for a type in these cases:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、手動で<bpt i="0" x="0">&lt;c0&gt;</bpt>Equatable<ept i="0">&lt;/c0&gt;</ept>と<bpt i="1" x="1">&lt;c1&gt;</bpt>Hashable<ept i="1">&lt;/c1&gt;</ept>準拠をある型に対して実装する必要がこれらの場合には必要です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You only need to initialize your own <bpt i="9" x="9">&lt;c9&gt;</bpt>Checked<bpt i="10" x="10">&lt;w10&gt;</bpt>Continuation&lt;T, E&gt;<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/c9&gt;</ept> if you already have an <bpt i="11" x="11">&lt;c11&gt;</bpt>Unsafe<bpt i="12" x="12">&lt;w12&gt;</bpt>Continuation<ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/c11&gt;</ept> you want to impose checking on.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが唯一必要とするのはあなた独自の<bpt i="9" x="9">&lt;c9&gt;</bpt>Checked<bpt i="10" x="10">&lt;w10&gt;</bpt>Continuation&lt;T, E&gt;<ept i="10">&lt;/w10&gt;</ept><ept i="9">&lt;/c9&gt;</ept>です、もしあなたがそれの上に検査を課したい<bpt i="11" x="11">&lt;c11&gt;</bpt>Unsafe<bpt i="12" x="12">&lt;w12&gt;</bpt>Continuation<ept i="12">&lt;/w12&gt;</ept><ept i="11">&lt;/c11&gt;</ept>をあなたが既に持つならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You should prefer <bpt i="0" x="0">&lt;c0&gt;</bpt>with<bpt i="1" x="1">&lt;w1&gt;</bpt>Va<bpt i="2" x="2">&lt;w2&gt;</bpt>List(_:<bpt i="3" x="3">&lt;w3&gt;</bpt>_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> instead of this function.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはこの関数よりも<bpt i="0" x="0">&lt;c0&gt;</bpt>with<bpt i="1" x="1">&lt;w1&gt;</bpt>Va<bpt i="2" x="2">&lt;w2&gt;</bpt>List(_:<bpt i="3" x="3">&lt;w3&gt;</bpt>_:)<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を選ぶべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You throw Cocoa errors by initializing a Cocoa error type and passing in the relevant error domain and code:</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、Cocoaエラーのスローを、あるCocoaエラー型を初期化して、関連エラー領域およびコードを渡すことによって行います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You use <bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Object<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> when you need the flexibility of an untyped object or when you use bridged Objective-C methods and properties that return an untyped result.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが型付けされないオブジェクトの柔軟性を必要とするとき、または型付けされない結果を返すブリッジされたObjective-Cメソッドやプロパティを使用するとき、あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>Any<bpt i="1" x="1">&lt;w1&gt;</bpt>Object<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You use Swift's <bpt i="0" x="0">&lt;c0&gt;</bpt>throw<ept i="0">&lt;/c0&gt;</ept> statement and <bpt i="1" x="1">&lt;c1&gt;</bpt>do<ept i="1">&lt;/c1&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt>catch<ept i="2">&lt;/c2&gt;</ept> statement to throw and catch errors from Cocoa APIs.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、Swiftの持つ<bpt i="0" x="0">&lt;c0&gt;</bpt>throw<ept i="0">&lt;/c0&gt;</ept>文と<bpt i="1" x="1">&lt;c1&gt;</bpt>do<ept i="1">&lt;/c1&gt;</ept>-<bpt i="2" x="2">&lt;c2&gt;</bpt>catch<ept i="2">&lt;/c2&gt;</ept>文を使って、Cocoa APIからのエラーをスローおよびキャッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You use arrays to organize your app’s data.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは配列を使ってあなたのアプリのデータを整理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You use complex macros in C and Objective-C to avoid type-checking constraints or to avoid retyping large amounts of boilerplate code.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、複雑なマクロをCとObjective-Cにおいて型チェック制約を避けたり、常用文コードの大きな塊を繰り返しタイピングすることを避けるために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You use custom error domains in Cocoa to group related categories of errors.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、あつらえのエラー領域をCocoaにおいて使用して、関連するエラーのカテゴリをグループにまとめます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You use delegates to interact with Cocoa objects that inform you of events in an app.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは委任先を使って、あるアプリの中のイベントについてあなたに告知するCocoaオブジェクトと相互作用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You use singletons to provide a globally accessible, shared instance of a class.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはシングルトンを使って、グローバルにアクセス可能な、あるクラスの共有インスタンスを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You use that key to retrieve the corresponding value, which can be any object.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはこのキーを使ってその対応している値を取り出すことができ、その値はあらゆるオブジェクトであることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You use the <bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_SWIFT<bpt i="2" x="2">&lt;w2&gt;</bpt>_NOTHROW<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> macro on Objective-C method declarations that produce an <bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>NSError<ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/s3&gt;</ept> to prevent it from being imported by Swift as a method that throws.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは<bpt i="0" x="0">&lt;c0&gt;</bpt>NS<bpt i="1" x="1">&lt;w1&gt;</bpt>_SWIFT<bpt i="2" x="2">&lt;w2&gt;</bpt>_NOTHROW<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>マクロを、<bpt i="3" x="3">&lt;s3&gt;</bpt><bpt i="4" x="4">&lt;c4&gt;</bpt>NSError<ept i="4">&lt;/c4&gt;</ept><ept i="3">&lt;/s3&gt;</ept>を生成するObjective-Cメソッド宣言上で使って、それがスローするメソッドとしてSwiftによってインポートされるのを防止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You use the <bpt i="0" x="0">&lt;c0&gt;</bpt>old<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept> and <bpt i="2" x="2">&lt;c2&gt;</bpt>new<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept> properties of the <bpt i="4" x="4">&lt;a4&gt;</bpt><bpt i="5" x="5">&lt;c5&gt;</bpt>NSKey<bpt i="6" x="6">&lt;w6&gt;</bpt>Value<bpt i="7" x="7">&lt;w7&gt;</bpt>Observed<bpt i="8" x="8">&lt;w8&gt;</bpt>Change<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept><ept i="4">&lt;/a4&gt;</ept> instance to see what's changed about the property you're observing.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、<bpt i="4" x="4">&lt;a4&gt;</bpt><bpt i="5" x="5">&lt;c5&gt;</bpt>NSKey<bpt i="6" x="6">&lt;w6&gt;</bpt>Value<bpt i="7" x="7">&lt;w7&gt;</bpt>Observed<bpt i="8" x="8">&lt;w8&gt;</bpt>Change<ept i="8">&lt;/w8&gt;</ept><ept i="7">&lt;/w7&gt;</ept><ept i="6">&lt;/w6&gt;</ept><ept i="5">&lt;/c5&gt;</ept><ept i="4">&lt;/a4&gt;</ept>インスタンスの<bpt i="0" x="0">&lt;c0&gt;</bpt>old<bpt i="1" x="1">&lt;w1&gt;</bpt>Value<ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>と<bpt i="2" x="2">&lt;c2&gt;</bpt>new<bpt i="3" x="3">&lt;w3&gt;</bpt>Value<ept i="3">&lt;/w3&gt;</ept><ept i="2">&lt;/c2&gt;</ept>プロパティを使って、あなたが監視しているプロパティについて変更されるのが何か見ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You use the default <bpt i="0" x="0">&lt;c0&gt;</bpt>init(_:)<ept i="0">&lt;/c0&gt;</ept> initializer to create a new instance when you’re sure that the value passed is representable in the new type.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、省略時の<bpt i="0" x="0">&lt;c0&gt;</bpt>init(_:)<ept i="0">&lt;/c0&gt;</ept>イニシャライザを使って新しいインスタンスを作成するのは、渡される値が新しい型において表現可能であるとあなたが確信する場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You use this initializer to create a dictionary when you have a sequence of key-value tuples that might have duplicate keys.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、重複キーを持つかもしれないキー値タプルのシーケンスをあなたが持つ場合、このイニシャライザを使って辞書を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You use this initializer to create a dictionary when you have a sequence of key-value tuples with unique keys.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>特有なキーをもつキー値タプルのシーケンスをあなたが持つ場合、あなたはこのイニシャライザを使って辞書を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You use this method to randomize the elements of a collection when you are using a custom random number generator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはこのメソッドを使って、あなたがあつらえの無作為数生成子を使っている場合に、あるコレクションの要素を無作為化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You use this method to randomize the elements of a sequence when you are using a custom random number generator.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはこのメソッドを使って、あなたがあつらえの無作為数生成子を使っている場合に、あるシーケンスの要素を無作為化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You use this protocol to present a native Swift interface to a C “varargs” API.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、このプロトコルを使ってSwift固有のインターフェースをC「varags」APIに贈呈します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You want to compare the absences in the first half of the session with those in the second half.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、前学期の欠席者を後半のそれと比較したいと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You want to customize the type's conformance.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたがその型の持つ準拠をカスタマイズしたい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You want to extend a type declared in another file or module to conform.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたが別のファイルまたはモジュールにおいて宣言される型を拡張することで準拠したい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You write each key-value pair with a colon (<bpt i="0" x="0">&lt;c0&gt;</bpt>:<ept i="0">&lt;/c0&gt;</ept>) separating the key and the value.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、各キー値ペアをコロン（<bpt i="0" x="0">&lt;c0&gt;</bpt>:<ept i="0">&lt;/c0&gt;</ept>）で区切るキーと値で書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Your own custom types can be hashable as well.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなた独自のあつらえの型も同様にハッシュ化されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You’d like to create a set of the grid points where a user has already tapped.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたは、ユーザがすでにタップしたところの格子点ひとそろいを作成したいでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You’re tasked with finding the day with the most absences in the second half of the session.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>あなたはこの学期の後半において最も多く欠席者がいる日付を見つける任務を負います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Zero is a multiple of everything because <bpt i="9" x="9">&lt;e9&gt;</bpt>0 = 0*x<ept i="9">&lt;/e9&gt;</ept> for any integer <bpt i="10" x="10">&lt;e10&gt;</bpt>x<ept i="10">&lt;/e10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ゼロはあらゆるものの倍数です、なぜなら<bpt i="9" x="9">&lt;e9&gt;</bpt>0 = 0*x<ept i="9">&lt;/e9&gt;</ept>なので、どんな整数<bpt i="10" x="10">&lt;e10&gt;</bpt>x<ept i="10">&lt;/e10&gt;</ept>に対してもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Zero is neither a normal nor a subnormal number.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ゼロは、ノーマルでもサブノーマル数でもありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Zero is the identity element for addition.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ゼロは加算に対する単位元です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Zero or more additional values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>ゼロ以上の追加の値。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Zero or more items to print.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>出力するゼロ個以上の項目</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>an <bpt i="0" x="0">&lt;c0&gt;</bpt>Unsafe<bpt i="1" x="1">&lt;w1&gt;</bpt>Mutable<bpt i="2" x="2">&lt;w2&gt;</bpt>Pointer&lt;Pointee&gt;<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>, which is passed as-is.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg><bpt i="0" x="0">&lt;c0&gt;</bpt>Unsafe<bpt i="1" x="1">&lt;w1&gt;</bpt>Mutable<bpt i="2" x="2">&lt;w2&gt;</bpt>Pointer&lt;Pointee&gt;<ept i="2">&lt;/w2&gt;</ept><ept i="1">&lt;/w1&gt;</ept><ept i="0">&lt;/c0&gt;</ept>、それは現品で渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>an inout argument of the referenced type, which gets passed as a pointer to a writeback temporary with autoreleasing ownership semantics,</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>参照される型のインアウト引数、それはオートリリース所有権意味論を持つライトバックテンポラリへのポインタとして渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>param container: The container in which the corrupted data was accessed.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>param container: そこで破壊されたデータがアクセスされたところのコンテナ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>param debugDescription: A description of the error to aid in debugging.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>param debugDescription: デバッグにおいて支援する目的のエラー解説。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>param key: The key which caused the failure.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>param key: 失敗を引き起こしたキー。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>“Pseudo-NaNs”, “pseudo-infinities”, and “unnormals” are interpreted as non-canonical NaN encodings.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>“Pseudo-NaN”、“pseudo-infinitie”、そして“unnormal”は、非正準NaNエンコーディングとして解釈されます。.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>“Pseudo-denormals” are interpreted as non-canonical encodings of subnormal values.</seg>
      </tuv>
      <tuv xml:lang="ja">
        <seg>“Pseudo-denormal”は、非正規化数値の非正準エンコーディングとして解釈されます。</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
