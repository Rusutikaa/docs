<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="4.3.0_0_e0e1b4cc8" segtype="sentence" srclang="EN-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv lang="EN-US">
        <seg>(A generic version of these functions is defined below.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これらの関数の総称体版は、下で定義されます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(A literal value is a value that appears directly in your source code, such as &lt;c2&gt;&lt;s3&gt;42&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;3.14159&lt;/s5&gt;&lt;/c4&gt; in the examples below.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（リテラル値「文字通りの値」は、直接あなたのソース・コードで見かける値です、例えば下の例での&lt;c2&gt;&lt;s3&gt;42&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;3.14159&lt;/s5&gt;&lt;/c4&gt;）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(For more information about capturing values in a closure, see &lt;a11&gt;&lt;s12&gt;Capturing Values&lt;/s12&gt;&lt;/a11&gt;.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（クロージャにおいて値を捕獲することに関する詳細は、&lt;a11&gt;&lt;s12&gt;値を捕獲する&lt;/s12&gt;&lt;/a11&gt;を見てください。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(In the &lt;c7&gt;&lt;s8&gt;swapTwoValues(_:_:)&lt;/s8&gt;&lt;/c7&gt; example above, &lt;c9&gt;&lt;s10&gt;T&lt;/s10&gt;&lt;/c9&gt; was replaced with &lt;c11&gt;&lt;s12&gt;Int&lt;/s12&gt;&lt;/c11&gt; the first time the function was called, and was replaced with &lt;c13&gt;&lt;s14&gt;String&lt;/s14&gt;&lt;/c13&gt; the second time it was called.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（上の&lt;c7&gt;&lt;s8&gt;swapTwoValues(_:_:)&lt;/s8&gt;&lt;/c7&gt;の例では、&lt;c9&gt;&lt;s10&gt;T&lt;/s10&gt;&lt;/c9&gt;は関数が呼ばれた最初の時に&lt;c11&gt;&lt;s12&gt;Int&lt;/s12&gt;&lt;/c11&gt;と取り替えられて、それが呼ばれた２番目の時に&lt;c13&gt;&lt;s14&gt;String&lt;/s14&gt;&lt;/c13&gt;と取り替えられました）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(It can’t contain anything else, such as a &lt;c15&gt;&lt;s16&gt;Bool&lt;/s16&gt;&lt;/c15&gt; value or a &lt;c17&gt;&lt;s18&gt;String&lt;/s18&gt;&lt;/c17&gt; value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg> （それは、他の何か、例えば&lt;c15&gt;&lt;s16&gt;Bool&lt;/s16&gt;&lt;/c15&gt;値または&lt;c17&gt;&lt;s18&gt;String&lt;/s18&gt;&lt;/c17&gt;値などを含むことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(It is assumed that all media items, including all movies and songs, will have a name.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（全ての映画と歌を含む、全てのメディア項目が名前を持つと仮定されます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Neither stylistic technique is strictly necessary, but they lead to neater code.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（文体上の技巧は絶対に必要な訳ではありません、しかしそれはすっきりしたコードにつながります。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Nested tuples are allowed.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（入れ子にされたタプルは、認められます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Note that these type methods can access the &lt;c12&gt;&lt;s13&gt;highestUnlockedLevel&lt;/s13&gt;&lt;/c12&gt; type property without your needing to write it as &lt;c14&gt;&lt;s15&gt;LevelTracker.highestUnlockedLevel&lt;/s15&gt;&lt;/c14&gt;.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これらの型メソッドは、あなたがそれを&lt;c14&gt;&lt;s15&gt;LevelTracker.highestUnlockedLevel&lt;/s15&gt;&lt;/c14&gt;と書かなくても、&lt;c12&gt;&lt;s13&gt;highestUnlockedLevel&lt;/s13&gt;&lt;/c12&gt;型プロパティにアクセスできる点に注意してください）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Strings have a similar optimization, but if two strings share memory, they are equal.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（文字列は同様な最適化を待ちます、しかし２つの文字列がメモリを共有するならば、それらは等しいです。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Swift reports an error at compile-time if a protocol requirement is not fulfilled.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（プロトコル要件が満たされないならば、スウィフトは実行時にエラーを報告します）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The &lt;c4&gt;&lt;s5&gt;name&lt;/s5&gt;&lt;/c4&gt; property is an optional &lt;c6&gt;&lt;s7&gt;String&lt;/s7&gt;&lt;/c6&gt; property, and so it automatically receives a default value of &lt;c8&gt;&lt;s9&gt;nil&lt;/s9&gt;&lt;/c8&gt;, even though this value is not written in the code.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（&lt;c4&gt;&lt;s5&gt;name&lt;/s5&gt;&lt;/c4&gt;プロパティはオプショナルの&lt;c6&gt;&lt;s7&gt;String&lt;/s7&gt;&lt;/c6&gt;プロパティです、なのでそれは自動的に省略時の値の&lt;c8&gt;&lt;s9&gt;nil&lt;/s9&gt;&lt;/c8&gt;を受け取ります、たとえこの値がそのコードに書かれないとしてもです。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The &lt;c8&gt;&lt;s9&gt;dice&lt;/s9&gt;&lt;/c8&gt; property is declared as a constant property because it doesn’t need to change after initialization, and the protocol only requires that it must be gettable.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（&lt;c8&gt;&lt;s9&gt;dice&lt;/s9&gt;&lt;/c8&gt;プロパティは定数プロパティとして宣言されます、なぜなら、それが初期化の後に変化する必要がなく、そして、プロトコルはそれが取得可能なことを必要とするだけであるからです）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The Boolean return value of &lt;c6&gt;&lt;s7&gt;advance(to:)&lt;/s7&gt;&lt;/c6&gt; is ignored, because the level is known to have been unlocked by the call to &lt;c8&gt;&lt;s9&gt;LevelTracker.unlock(_:)&lt;/s9&gt;&lt;/c8&gt; on the previous line.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（&lt;c6&gt;&lt;s7&gt;advance(to:)&lt;/s7&gt;&lt;/c6&gt;のブールの戻り値は無視されます、なぜなら、このレベルは前の行で&lt;c8&gt;&lt;s9&gt;LevelTracker.unlock(_:)&lt;/s9&gt;&lt;/c8&gt;呼び出しによってすでに錠を開けられていると分かるからです）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The examples below are based on 8-bit signed integers for simplicity, but the same principles apply for signed integers of any size.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（下の例は、単純さのために8ビット符号つき整数に基づきます、しかし同じ原理はあらゆるサイズの符号つき整数に当てはまります）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The examples of modifying an inherited property’s default value in a subclass initializer have been moved to the &lt;a6&gt;&lt;s7&gt;Initialization&lt;/s7&gt;&lt;/a6&gt; chapter.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（サブクラスのイニシャライザの継承されたプロパティの省略時の値を修正する例は章&lt;a6&gt;&lt;s7&gt;初期化&lt;/s7&gt;&lt;/a6&gt;に移動されました。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The expression &lt;c5&gt;&lt;s6&gt;number&lt;/s6&gt; &lt;s7&gt;%&lt;/s7&gt; &lt;s8&gt;10&lt;/s8&gt;&lt;/c5&gt; gives a value of &lt;c9&gt;&lt;s10&gt;6&lt;/s10&gt;&lt;/c9&gt; for &lt;c11&gt;&lt;s12&gt;16&lt;/s12&gt;&lt;/c11&gt;, &lt;c13&gt;&lt;s14&gt;8&lt;/s14&gt;&lt;/c13&gt; for &lt;c15&gt;&lt;s16&gt;58&lt;/s16&gt;&lt;/c15&gt;, and &lt;c17&gt;&lt;s18&gt;0&lt;/s18&gt;&lt;/c17&gt; for &lt;c19&gt;&lt;s20&gt;510&lt;/s20&gt;&lt;/c19&gt;.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（式数&lt;c5&gt;&lt;s6&gt;number&lt;/s6&gt; &lt;s7&gt;%&lt;/s7&gt; &lt;s8&gt;10&lt;/s8&gt;&lt;/c5&gt;は、&lt;c11&gt;&lt;s12&gt;16&lt;/s12&gt;&lt;/c11&gt;のために&lt;c9&gt;&lt;s10&gt;6&lt;/s10&gt;&lt;/c9&gt;、&lt;c15&gt;&lt;s16&gt;58&lt;/s16&gt;&lt;/c15&gt;のために&lt;c13&gt;&lt;s14&gt;8&lt;/s14&gt;&lt;/c13&gt;、&lt;c19&gt;&lt;s20&gt;510&lt;/s20&gt;&lt;/c19&gt;のために&lt;c17&gt;&lt;s18&gt;0&lt;/s18&gt;&lt;/c17&gt;の値を与えます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The parameters to functions and closures are always constants.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（関数およびクロージャに対するパラメータは常に定数です。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The property wrapper is responsible for storing the wrapped value, so there’s no synthesized code for that.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（プロパティラッパーは、ラップ値を格納することに責任があります、それでそれに対する合成コードはありません。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(The same isn’t true for structures and enumerations, because they are always copied when they are assigned to a constant or variable, or passed to a function.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（同じことは構造体と列挙にあてはまりません、なぜなら、それらが値型であって、それらが定数または変数に代入されるか関数に渡される時に、常にコピーされるからです）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This raw &lt;c4&gt;&lt;s5&gt;Int&lt;/s5&gt;&lt;/c4&gt; value is not used for the Jack, Queen, King, and Ace cards.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（この生の&lt;c4&gt;&lt;s5&gt;Int&lt;/s5&gt;&lt;/c4&gt;値は、ジャック、クイーン、キング、そしてエース・カードには使われません）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Unlike Objective-C categories, Swift extensions do not have names.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（Objective-Cカテゴリーとは異なり、スウィフト拡張には、名前がありません。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// "Apple International" is not the real airport for APL, so delete it</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「アップル・インターナショナル」は、APLのための本当の空港ではないので、それを削除します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// "Imagination is more important than knowledge" - Einstein</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「想像は知識より重要です」 - アインシュタイン）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// "Maple Syrup" is now the first item in the list</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「メープルシロップ」が、現在はリストの最初の項目です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// "Voulez-vous un café?" using LATIN SMALL LETTER E WITH ACUTE</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「Voulez-vous un café?」は揚音付きラテン小文字eを使用している）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// "Voulez-vous un café?" using LATIN SMALL LETTER E and COMBINING ACUTE ACCENT</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「Voulez-vous un café?」はラテン小文字eと揚音アクセント結合を使用している）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// "required" from SomeProtocol conformance; "override" from SomeSuperClass</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（SomeProtocol準拠からの「required」；SomeSuperClasからの「override」）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// 1 times 5 is 5</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（１かける５は、５です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// 2 times 5 is 10</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（２かける５は、10です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// 3 times 5 is 15</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（３かける５は、15です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// 4 times 5 is 20</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（４かける５は、20です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// 5 times 5 is 25</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（５かける５は、25です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// A 12-sided dice</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（ひとつの12面のさいころ遊び）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// A game of Snakes and Ladders with 25 squares</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（25ますのヘビとはしごのゲーム）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// A game of Snakes and Ladders with 25 squares:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（25ますのヘビとはしごのゲーム：）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// A hamster named Simon</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（サイモンという名前のハムスター）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// A read access from the memory where one is stored.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（oneが格納されるところのメモリから読み出しアクセス。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// A write access to the memory where one is stored.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（oneが格納されるところのメモリに対する書き込みアクセス。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// APL has now been removed from the dictionary</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（APLは、現在この辞書から削除されました）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// About to set totalSteps to 200</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（totalStepsを200に設定している）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// About to set totalSteps to 360</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（totalStepsを360に設定している）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// About to set totalSteps to 896</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（totalStepsを896に設定している）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Added 160 steps</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（160の歩数が加えられた）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Added 200 steps</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（200の歩数が加えられた）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Added 536 steps</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（536の歩数が加えられた）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// All items match, so return true.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（全ての項目が合致、なのでtrueを返す。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Apply f to create an array of Number instances with integer values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（fを適用して整数値を持つNumberインスタンスからなる配列を作成する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Area is 12.5663708</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（面積は、12.5663708です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Area is 243610.0</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（面積は、243610.0です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// AutomaticCar: traveling at 35.0 miles per hour in gear 4</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（AutomaticCar: 時速35.0マイル、４速ギアで運行中）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Baking Powder</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（膨らし粉）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Bananas</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（バナナ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Because 'fn' closes over 'index', it uses the new value</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（'fn'が'index'をしっかり掴むので、それは新しい値を使います）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Bicycle: 2 wheel(s)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（自転車: ２輪）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Bicycle: traveling at 15.0 miles per hour</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（自転車：時速15マイルで運行中）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Bind x and y to the elements of point.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（xとyをpointの要素へ束縛します。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// BlackjackCard properties and methods</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（BlackjackCardのプロパティとメソッド）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Both approaches below are equivalent.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（下の両方の取り組みは等しいです。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Call the underlying method directly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（基礎をなすメソッドを直接に呼び出します。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Call the underlying subscript directly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（基礎をなす添え字を直接に呼び出す。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Car: traveling at 25.0 miles per hour in gear 3</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（Car: ３速ギアで時速25.0マイルで運行中）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Check each pair of items to see if they're equivalent.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（各項目の対をそれらが等しいかどうか見るため調べる。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Check that both containers contain the same number of items.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（両方のコンテナが同じ数の項目を含むことを確認する。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Convert the result to a String for long-term storage.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（結果を長期保管のためのStringへ変換する。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Counting to zero:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「ゼロまで数えます：」）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Do something three times.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（３回何かをします。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Do the same thing using a key path.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（同じことをキーパスを使って行う。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Equivalent to compoundValue = (a: 10, b: 20)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（compoundValue = (a: 10, b: 20) に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Error: Not enough information to infer C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（Error: Cを推論するための情報が十分でない。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Error: Protocol with associated types can't be used as a return type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（Error: 関連型を持つプロトコルは戻り型として使われることができません。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Error: conflicting access to properties of playerInformation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（エラー：playerInformationのプロパティに対するアクセス衝突）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Error: conflicting accesses to oscar</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（エラー：oscarに対するアクセス衝突）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Error: conflicting accesses to playerOneScore</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（エラー：playerOneScoreに対するアクセス衝突）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Error: conflicting accesses to stepSize</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（エラー：stepSizeに対するアクセス衝突）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Error: redundant conformance of 'Array&lt;Element&gt;' to protocol 'Loggable'</seg>
      </tuv>
      <tuv lang="JA">
        <seg>// エラー: プロトコル 'Loggable' に対しての 'Array&lt;Element&gt;' の冗長な準拠</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Error: redundant conformance of 'Array&lt;Element&gt;' to protocol 'Serializable'</seg>
      </tuv>
      <tuv lang="JA">
        <seg>// エラー: プロトコル 'Serializable' に対しての 'Array&lt;Element&gt;' の冗長な準拠</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Fall back to earlier iOS and macOS APIs</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（以前のiOSとmacOS APIに後退する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// First release</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（最初のリリース）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Flour</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（小麦粉）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Hello, Alex!</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（よろしく、アレックス！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Hello, Anna!</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（よろしく、アンナ！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Hello, Brian!</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（よろしく、ブライアン！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Hello, Jack!</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（よろしく、ジャック！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Hello, Michael</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（こんにちは、マイケル）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Here's how you call this function with a trailing closure instead:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（あなたが代わりに後付クロージャでどのようにこの関数を呼ぶのかがここにあります：）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Here's how you call this function without using a trailing closure:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（あなたが後付クロージャを使うことなくどのようにこの関数を呼ぶのかがここにあります：）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Hoverboard: 0 wheel(s) in a beautiful silver</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（ホバーボード: ０個の車輪、美しい銀色で）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// If you omit the second argument when calling this function, then</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（あなたが２番目の引数をこの関数を呼び出すときに省略したならば、その時）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// In the function body, firstParameterName and secondParameterName</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（関数本文において、firstParameterNameとsecondParameterNameは、）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// In the function body, parameterName refers to the argument value</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（関数本文において、parameterNameは）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// In the implementation of a subscript...</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（ある添え字の実装において...）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Inferred that Suffix is Stack.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（SuffixはStackであると推論される。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Inferred that Suffix is Stack&lt;Int&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（Suffix は Stack&lt;Int&gt;であると推論される。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Int8 cannot store a number larger than its maximum value,</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（Int8はその最大の値より大きい数を格納することができません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Item 1: Six eggs</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（項目１：６つの卵）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Item 2: Milk</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（項目２：牛乳）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Item 3: Flour</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（項目３：小麦粉）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Item 4: Baking Powder</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（項目４：膨らし粉）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Item 5: Bananas</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（項目５：バナナ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Make a local copy and manually copy it back.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（ローカルコピーを作って手動でそれを元へコピーする。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Make an explicit copy.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（明示的なコピーを作る。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Match only non-nil values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（nilでない値にのみマッチする。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Match using an enumeration case pattern.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（列挙ケース節パターンを使っているマッチ。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Match using an optional pattern.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（オプショナルパターンを使っているマッチ。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Milk</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（牛乳）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Movie: Casablanca, dir. Michael Curtiz</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（映画：『カサブランカ』（監）マイケル・カーティス）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Movie: Citizen Kane, dir. Orson Welles</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（映画：『市民ケーン』（監）オーソン・ウェルズ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Now t is (20, 20, 30)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（tは、現在 (20, 20, 30)です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Operate on localX asynchronously, then wait before returning.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（非同期にlocalXを処理を施す、それから返すまえに待機する。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Overload the ~= operator to match a string with an integer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（~=演算子をオーバーロードして文字列を整数と照合するようにする。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Perform a suitable setting action here.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（ふさわしい設定動作をここで行う。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Person 1 is called Anna</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（人物は１、アンナと呼ばれる）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Person 2 is called Alex</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（人物２は、アレックスと呼ばれる）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Person 3 is called Brian</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（人物３は、ブライアンと呼ばれる）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Person 4 is called Jack</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（人物４は、ジャックと呼ばれる）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "(1, -1) is on the line x == -y"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「(1, -1)は、x == -yの線上にある」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "(1, 1) is inside the box"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「(1, 1）は、この四角の中にあります」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "(1, 2) is near the origin."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「（1, 2）は原点に近いです。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "0"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「0」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "10"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「10」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "12"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「12」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "2"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「2」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "27"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「27」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "3 to the power of 10 is 59049"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「３の10乗は、59049です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "325"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（ "325" を出力する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "6 mansion scenes; 2 cell scenes"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「６つの邸宅場面；２つの僧房場面」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "6"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「6」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "64"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「64」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "7"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「７」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "&lt;h1&gt;some default text&lt;/h1&gt;"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「&lt;h1&gt;some default text&lt;/h1&gt;」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "&lt;p&gt;hello, world&lt;/p&gt;"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「&lt;p&gt;よろしく、世界&lt;/p&gt;」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "A 12-sided dice"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「ひとつの12面さいころ」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "A game of Snakes and Ladders with 25 squares"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「25ますのヘビとはしごのゲーム」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "A hamster named Simon"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「サイモンという名前のハムスター」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "A marathon is 42195.0 meters long"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「マラソンは、42195.0メートルの長さです」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "A new player has joined the game with 100 coins"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「新しいプレーヤーが、100のコインを持ってゲームに参加しました」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "ACCESS DENIED"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「アクセス拒否」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "All items match."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「全ての項目が一致する」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "An animal was initialized with a species of Giraffe"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「一匹の動物がキリンの種族で初期化された」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "An implicitly unwrapped optional string."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「暗黙的にアンラップされるオプショナルの文字列。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "And another one: 0.729023776863283"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「さらにもう１つ：0.729023776863283」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "And here's a random Boolean: true"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「そしてここに任意のブール: trueがあります」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Another value."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「別の値。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Apartment 4A is being deinitialized"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「アパート4Aは、デイニシャライズされた」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Bonjour!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「Bonjour!」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Canada's capital city is called Ottawa"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「カナダの首都はオタワです」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Card #1234567890123456 is being deinitialized"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「カード#1234567890123456は、デイニシャライズされた」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Choo Choo"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「シュッシュッ」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Collected 2 closures."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「２つのクロージャが集められた。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Do you like cheese?"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「あなたはチーズが好きですか？」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Eww, turnips are horrible."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「うー、カブ怖い。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Happy birthday, Malcolm, you're 21!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「誕生日おめでとうマルコム、あなたは21です！」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Hello Jane!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「こんにちはジェーン！」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Hello John!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「こんにちはジョン！」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Hello again, Anna!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「またあったね、アンナ！」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Hello again, Tim!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「またあったね、ティム！」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Hello, Anna!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「こんにちは、アンナ！」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Hello, Brian!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「こんにちは、ブライアン！」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "How about beets?"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「赤かぶはどう？」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "I have 3 favorite music genres."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「私には大好きな音楽ジャンルが３つあります。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "I have particular music preferences."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「私には特定の音楽の好みがあります。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "I hope the weather is nice in Cupertino."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「クパチーノの天気がいいことを望むよ」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "I hope the weather is nice near you."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「あなたの近くの天気がいいといいね」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Insufficient funds. Please insert an additional 2 coins."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「金額が不足しています。さらに２コイン入れてください。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Int"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「Int」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "It was not possible to print the number of rooms."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「部屋の数を出力することは、可能ではありませんでした。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "It was not possible to set the address."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「住所を設定することは、可能ではありませんでした。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "It's not that cold. Wear a t-shirt."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「そんなに寒くありません。Tシャツを着てください。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "It's really warm. Don't forget to wear sunscreen."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「非常に暖かいです。日焼け止めを塗るのを忘れないでください。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "It's too funky in here."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「そりゃここじゃfunkyすぎる。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "It's very cold. Consider wearing a scarf."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「非常に寒いです。スカーフを巻くことを考えてください。 」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Item: sock, quantity: 2"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「項目：靴下、数量：２」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "John Appleseed is being deinitialized"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「John Appleseedは、デイニシャライズされた」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "John Appleseed is being initialized"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「John Appleseedは、初期化された」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "John's building identifier begins with "The"."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「ジョンの建物名は「月」で始まります」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "John's building identifier is The Larches."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「ジョンの建物名は月桂樹です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "John's residence has 1 room(s)."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「ジョンの邸宅には１部屋ある」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "John's street name is Laurel Street."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「ジョンの街路名は月桂樹通りです」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Made an index"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（"Made an index" を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Media library contains 2 movies and 3 songs"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「情報媒体書庫は、２つの映画と３つの歌を含みます」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Mostly harmless"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「おおむね無害」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Nothing to see here"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「ここで見るものは何も無し」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Now serving Alex!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（今アレックスに対応中！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Now serving Barry!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（今バリーに対応中！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Now serving Daniella!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（今ダニエラに対応中！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Now serving Ewa!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（今エヴァに対応中！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "On an axis, 9 from the origin"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「ある軸上で、原点から９」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "One inch is 0.0254 meters"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「１インチは、0.0254メートルです」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "PlayerOne has left the game"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「PlayerOneは、ゲームを離れました」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "PlayerOne won 2000 coins &amp; now has 2100 coins"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「PlayerOneは2000のコインを獲得＆現在2100のコインを持ちます」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "QR code: ABCDEFGHIJKLMNOP."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「QRコード：ABCDEFGHIJKLMNOP。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Result: 5"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「結果：５」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Result: 6"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「結果：６」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Result: 8"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「結果：８」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Rock? I'm over it."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「Rock？ もう済んだことさ（曲名？）。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Some value."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「ある値。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "SomeSubClass"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「 SomeSubClass 」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The airports dictionary contains 2 items."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「airports辞書は２項目を含む。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The airports dictionary is not empty."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「airports辞書は空ではない。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The anonymous creature could not be initialized"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「不明な生き物は初期化されることができませんでした」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The bank now has 10000 coins"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「胴元には現在10000コインがあります」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The bank now only has 7900 coins left"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「胴元には現在7900個のコインだけが残っています」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The current value of friendlyWelcome is Bonjour!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「The current value of friendlyWelcome is Bonjour!」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The default temperature is 32.0° Fahrenheit"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「省略時の温度は華氏32.0°です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The first number is 10."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「最初の数は、10です。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The first room name is Living Room."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「最初の部屋名は、居間です。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The frameRate property of tenEighty is now 30.0"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「tenEightyのframeRateプロパティは、現在は30.0です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The index of llama is 2"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「ラマのインデックスは、２です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The integer value of 三 is 3."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「三の整数値は３です。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The name of the airport is Dublin Airport."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「空港名は「ダブリン空港です。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The number 5 is a prime number, and also an integer."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「数５は素数で、そのうえ整数です。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The number of edits is 3"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「編集数は、３です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The old value for DUB was Dublin."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「DUBの古い値は「ダブリンでした。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The point is at (1, 2)."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「pointは（1, 2）です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The point is at (3, 2)."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「pointは（3, 2）です。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The point is now at (3.0, 4.0)"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「ポイントは現在は(3.0, 4.0)です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The removed airport's name is Dublin Airport."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「削除された空港の名前はダブリンです。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The second number is 42."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（２番目の数は、42です。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The shopping list contains 2 items."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「買い物リストは２つの項目を含みます。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The shopping list is not empty."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「買い物リストは空ではありません。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The status code is 200"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「状態コードは200です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The status code is 404"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「状態コードは404です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The status message is Not Found"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「状態メッセージが見つかりません」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The status message is OK"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「状態メッセージはOKです」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The top item on the stack is tres."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「このスタックの一番上の項目はtresです」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The width of someResolution is 0"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「someResolutionの幅は0です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The width of someVideoMode is 0"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「someVideoModeの幅は0です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "The width of someVideoMode is now 1280"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「someVideoModeの幅は、現在は1280です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "There are 5 scenes in Act 1"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「５つの場面が一幕にあります」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "There are dozens of moons orbiting Saturn."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「土星の軌道を回るたくさんの月がある。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "There are now 9900 coins left in the bank"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「現在9900個のコインが胴元に残されます」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "There isn't a planet at position 11"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「位置11に惑星は存在しない」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "These two characters are not equivalent."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「これら２つの文字列は等しくない。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "These two strings are considered equal"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「これら２つの文字列は等しいと考えられる」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "These two vectors are also equivalent."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「これらの２つのベクトルはまた等しいです。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "These two vectors are equivalent."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「これらの２つのベクトルは等しいです。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "This is a defined temperature unit, so initialization succeeded."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「これは定義済み温度単位です、なので初期化は成功しました。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "This is not a defined temperature unit, so initialization failed."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「これは定義済み温度単位ではありません、なので初期化は失敗しました。」を出力します」）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "This point is to the right of the line where x == 1.0"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「この点は線x == 1.0の右にある」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Three feet is 0.914399970739201 meters"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「３フィートは、0.914399970739201メートルです」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Unable to initialize one unnamed product"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「１個の名前のない製品を初期化できません」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Unable to initialize zero shirts"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「０個のシャツを初期化できません」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Unable to retrieve the address."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「住所を取り出すことができない」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Unable to retrieve the first room name."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「最初の部屋名を取り戻すことができない」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Unable to retrieve the number of rooms."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「部屋の数を取り出すことができない」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Watch out for penguins"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「ペンギンに気をつけろ」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "Welcome!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「歓迎します！」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "cinema is now 2048 pixels wide"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「cinemaは、現在2048のピクセルの幅です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "convertedNumber contains some integer value."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「convertedNumberは、何らかの整数値を持ちます」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "convertedNumber has an integer value of 123."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「convertedNumberは、整数値123を持ちます」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "data.txt"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「data.txt」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "e is a vowel"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「eは、母音です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "false"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「false」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "hd is still 1920 pixels wide"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「hdは、依然として1920のピクセルの幅です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "hello, world"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「よろしく、世界」を出力ます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "hello, world", because name is indeed equal to "world".</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「hello, world」を出力します、nameが確かに「world」と等しいので。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "highest unlocked level is now 2"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「最も高い鍵の開いたレベルは現在２です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "letters is of type Set&lt;Character&gt; with 0 items."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「lettersは型Set&lt;Character&gt;で０項目を持ちます。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "level 6 has not yet been unlocked"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「レベル６はまだ開錠されていません」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "min is -6 and max is 109"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「最小は-6で、最大は109です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "on the x-axis with an x value of 2"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「２のxの値でx-軸の上」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "p is being deinitialized"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「pは、デイニシャライズされている」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "six times three is 18"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「６かける３は18です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "someInt is now 107, and anotherInt is now 3"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「someIntは今は107、anotherIntは今は３です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "someInts is of type [Int] with 0 items."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「someIntsは型[Int]で0項目を持ちます。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "square.origin is now at (10.0, 10.0)"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「square.originは、現在(10.0, 10.0)です」を出力します））</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "tenEighty and alsoTenEighty refer to the same VideoMode instance."</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「tenEightyとalsoTenEightyは、同じVideoModeインスタンスに言及します。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "the number of characters in cafe is 4"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「cafeの文字数は4です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "the number of characters in café is 4"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「caféの文字数は4です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "the volume of fourByFiveByTwo is 40.0"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「fourByFiveByTwoのボリュームは、40.0です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "theAceOfSpades: suit is ♠, value is 1 or 11"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「theAceOfSpades: 組み札は♠、値は１または11です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "true"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「true」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Prints "unusualMenagerie has 40 characters"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「unusualMenagerieは、40の文字を持ちます」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Random dice roll is 3</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（無作為にさいころを転がして、３です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Random dice roll is 4</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（無作為にさいころを転がして、４です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Random dice roll is 5</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（無作為にさいころを転がして、５です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Reimplement the Swift standard library's optional type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（スウィフト標準ライブラリのオプショナル型の再実装）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Return an appropriate subscript value here.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（適切な添え字値をここで返す。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Return the appropriate value</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（適切な値を返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Rolled a 3</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（３を出した）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Rolled a 4</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（４を出した）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Rolled a 5</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（５を出した）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Setting 'index' to a new value doesn't affect 'path'</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（'index'を新しい値に設定することは、'path'に影響を与えない）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Six eggs</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（卵６つ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Something that doesn't have an area</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（面積を持たない何か）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Song: Blue Suede Shoes, by Elvis Presley</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（歌：『青い裏革靴』、エルヴィス・プレスリー）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Song: Never Gonna Give You Up, by Rick Astley</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（歌：『諦めないで』、リック・アストリー）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Song: The One And Only, by Chesney Hawkes</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（歌：『唯一無二の』、チェズニー・ホークス）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Started a new game of Snakes and Ladders</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（ヘビとはしごの新しいゲームを始める）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Subsequent release renames MyProtocol</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（続くリリースでMyProtocolに改名する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Tandem: traveling at 22.0 miles per hour</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（２人乗り：時速22.0マイルで運行中）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// The compile-time type of someInstance is SomeBaseClass,</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（someInstanceのコンパイル時での型は、SomeBaseClassです、）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// The following dictionaries have the same type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（以下の辞書は同じ型を持ちます。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// The game is using a 6-sided dice</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（ゲームは、６面のさいころを使っています）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// The game lasted for 4 turns</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（ゲームは、４回続きました）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// The line below calls makeIndex().</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（下の行は makeIndex() を呼び出します。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// The type of optionalString is "String?" and assumedString isn't force-unwrapped.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（optionalString の型は "String?" です、そして assumedString は強制アンラップされません。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// This assertion fails because -3 is not &gt;= 0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（この表明は失敗する、なぜなら-3 は &gt;= 0 ではないから。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// This code isn't valid.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（このコードは有効ではありません。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// This is a comment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これはコメントです。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// This is a compile-time error: languageName cannot be changed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これはコンパイル時エラーです：anguageNameは変わることができません。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// This is not valid, because x = y does not return a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これは有効ではありません、x = yが値を返さないので。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// This syntax is preferred.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（この構文はより好まれます。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// This syntax produces a warning.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（この構文は警告を生成します。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// This triggers an assert, because [2, 2] is outside of the matrix bounds.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これはある表明の引き金となります、なぜなら [2, 2] はマトリックス境界の外であるからです。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// This will report a compile-time error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これは、コンパイル時エラーを報告します。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Type annotation is required because String has multiple initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（型注釈は必須です、なぜならStringは複数のイニシャライザを持つからです。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// UInt8 cannot store negative numbers, and so this will report an error</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（UInt8は負の数を格納することができません、それでこれはエラーを報告します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Update the original.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（元のものを更新する。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Use a dynamic method call.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（動的メソッド呼び出しを使います。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Use iOS 10 APIs on iOS, and use macOS 10.12 APIs on macOS</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（iOS 10 APIをiOSで、macOS 10.12 APIをmacOSで使う）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Using taskKeyPath doesn't call makeIndex() again.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（ taskKeyPath を使うことは、 makeIndex() を再び呼び出しません。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Vehicle: 0 wheel(s)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（乗り物: ０輪）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Vehicle: traveling at 0.0 miles per hour</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（Vehicle: 時速0.0マイルで運行中）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Weak capture of "self.parent" as "parent"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「parent」としての弱いキャプチャ「self.parent」）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// Work with the file.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（ファイル処理。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// a is "test", b is 12, c is 3, and 9.45 is ignored</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（aは「test」です、bは12です、cは３です、そして9.45は無視されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// a is now equal to 10</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（aは今は10と等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// a is now equal to 3</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（aは現在、３と等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// a movie called Ghostbusters, dir. Ivan Reitman</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（『ゴーストバスターズ』と呼ばれる映画、監督アイヴァン・ライトマン）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// a positive double value of 3.14159</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（正の浮動小数点の値の3.14159）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// a string value of "hello"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（文字列値の「よろしく」）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// afterDoubling also has values of (2.0, 8.0)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（afterDoublingも(2.0, 8.0)の値を持ちます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// alsoPositive is a Vector2D instance with values of (3.0, 4.0)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（alsoPositiveは、値(-3.0, -4.0)をもつVector2Dインスタンです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// an (x, y) point at 3.0, 5.0</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（3.0、5.0の(x, y)座標点）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// an error was thrown</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（エラーがスローされた）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// an integer value of 42</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（整数値の42）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// and so this will also report an error</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（それでこれも同様にエラーを報告します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// and the runtime type of someInstance is SomeSubClass</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（そしてsomeInstanceの実行時での型は、SomeSubClassです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// anonymousCreature is of type Animal?, not Animal</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（anonymousCreatureは、型Animal?です、Animalではなく）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// anotherMathFunction is inferred to be of type (Int, Int) -&gt; Int</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（anotherMathFunctionは、型(Int, Int) -&gt; Intであると推論されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// anotherPi is also inferred to be of type Double</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（anotherPiもまたDouble型であると推論されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// anotherThreeDoubles is of type [Double], and equals [2.5, 2.5, 2.5]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（anotherThreeDoublesは、型[Double]で、[2.5, 2.5, 2.5]に等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// ants have 6 legs</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（蟻は、６本の足を持っています）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// basicRect's origin is (0.0, 0.0) and its size is (0.0, 0.0)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（centerRectの原点は(0.0, 0.0)、そのサイズは(0.0, 0.0)です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// beginning is "Hello"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（beginningは "Hello" です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// bodyTemperature.temperatureInCelsius is 37.0</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（bodyTemperature.temperatureInCelsius は 37.0 です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// boilingPointOfWater.temperatureInCelsius is 100.0</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（boilingPointOfWater.temperatureInCelsiusは、100.0です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// cap the new audio level to the threshold level</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（新しい音声レベルを限界レベルに制限する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// cats have 4 legs</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（猫は、４本の足を持っています）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（centerRectの原点は(2.5, 2.5)、そのサイズは(3.0, 3.0)です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// class definition goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（クラス定義が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// class-only protocol definition goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（クラス専用プロトコル定義が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// close(file) is called here, at the end of the scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（close(file)がここで呼ばれます、このスコープの終わりで。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// closure body goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（クロージャ本文が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// closure's body goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（クロージャの本文がここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// combinedVector is a Vector2D instance with values of (5.0, 5.0)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（combinedVectorは(5.0, 5.0)の値をもつVector2Dインスタンスです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// conformance to the Container protocol</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（Containerプロトコルに準拠）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// convertedNumber is inferred to be of type "Int?", or "optional Int"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（convertedNumberは、型「Int?」または「オプショナルのInt」であると推論されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// create a default value for someProperty inside this closure</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（このクロージャの内側でsomePropertyのための省略時の値をつくる）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// customersInLine is ["Alex", "Ewa", "Barry", "Daniella"]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（customersInLine（並んでいる顧客）は、["Alex", "Ewa", "Barry", "Daniella"]です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// customersInLine is ["Barry", "Daniella"]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（customersInLine（並んでいる顧客）は、["Barry", "Daniella"]です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// customersInLine is ["Ewa", "Barry", "Daniella"]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（customersInLine（並んでいる顧客）は、["Ewa", "Barry", "Daniella"]です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// diceRoll will move us beyond the final square, so roll again</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（diceRollは私たちを最後の正方形を越えて動かします、それで再度転がします）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// diceRoll will move us to the final square, so the game is over</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（diceRollは私たちを最後の正方形に動かします、なのでゲームは終わりです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// discard 'self' and return 'nil'</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「self」を廃棄して「nil」を返します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// do nothing - an arbitrary vehicle doesn't necessarily make a noise</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（何もしない - ある任意の乗り物が必ず音を出すわけではない）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// do something with the instance of 'SomeStruct'</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「SomeStruct」のインスタンスで何か行う）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// doubleIndex is an optional Int with no value, because 9.3 isn't in the array</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（9.3がこの配列の中にはないので、doubleIndexは値のないオプショナルのIntです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// eAcute is é, combinedEAcute is é</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（eAcuteはéです、combinedEAcuteはéです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// earthsOrder is 3</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（earthsOrderは、３です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// enclosedEAcute is é⃝</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（enclosedEAcute は é⃝ です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// enumeration definition goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（列挙定義がここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// f is a function of type (Int) -&gt; Number</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（fは型(Int) -&gt; Numberの関数です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// favoriteGenres has been initialized with three initial items</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（favoriteGenresは３つの初期項目で初期化されています）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// favoriteGenres now contains 4 items</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（favoriteGenresは現在４項目を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// firstItem is equal to "Eggs"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（firstItemは、「Eggs」と等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// firstItem is now equal to "Six eggs"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（firstItemは、現在「６つの卵」と等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// for that parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（そのパラメータのための引数値に言及することができます。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// freezingPointOfWater.temperatureInCelsius is 0.0</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（freezingPointOfWater.temperatureInCelsiusは、0.0です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// friendlyWelcome is now "Bonjour!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（friendlyWelcomeは、現在「Bonjour!」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// fromTheTop is equal to "cuatro", and the stack now contains 3 strings</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（fromTheTopは「cuatro」と等しいです、そしてスタックは現在は３つの文字列を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// function body goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（関数本文が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// function implementation goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（関数実装が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// heartsSymbol is "♡"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（heartsSymbol は "♡" です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// http404Error is of type (Int, String), and equals (404, "Not Found")</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（http404Errorは、型が(Int, String)です、そして(404, "Not Found")と等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// if we're still on the board, move up or down for a snake or a ladder</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（私達がまだ盤上ならば、ヘビまたははしごに対して上／下に移動する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// implementation of protocol requirements goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（プロトコル要件の実装が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// initialization of 'SomeStruct' failed and the initializer returned 'nil'</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「SomeStruct」の初期化は失敗したのでイニシャライザは「nil」を返した）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// initializer implementation goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（イニシャライザ実装がここに来ます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// instruction now equals "look over there"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（instructionは、現在「あそこを見て」に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// integerPi equals 3, and is inferred to be of type Int</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（integerPiは、３に等しく、型Intであると推測されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// its value is ["OneSix", "FiveEight", "FiveOneZero"]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（その値は["OneSix", "FiveEight", "FiveOneZero"]です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// john.fullName is "John Appleseed"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（john.fullNameは、「John Appleseed」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// letters is now an empty set, but is still of type Set&lt;Character&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（lettersは現在空の集合です、しかし依然として型Set&lt;Character&gt;です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// letters now contains 1 value of type Character</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（lettersは型Characterの値を１つ持ちます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// lightSwitch is now equal to .on</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（lightSwitchは、現在.onと等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// maxAmplitudeFound is now 0</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（maxAmplitudeFoundは、現在0です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// meaningOfLife is inferred to be of type Int</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（meaningOfLifeはInt型であると推測されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// message is "3 times 2.5 is 7.5"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（messageは、「３かける2.５は7.５」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// move by the rolled amount</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（振られた量だけ移動）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// move up or down for a snake or ladder</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（ヘビまたははしごのための上下移動）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// moveNearerToZero now refers to the nested stepForward() function</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（moveNearerToZeroは、現在は入れ子にされたstepForward()関数に言及します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// moveNearerToZero now refers to the stepBackward() function</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（moveNearerToZeroは、現在はstepBackward()関数に言及します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// myGreeting is 'hola'</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（myGreeting は 'hola' です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// mysteryMeat's name is "[Unnamed]"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（nameMeatの名前は「[Unnamed]」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// namedMeat's name is "Bacon"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（nameMeatの名前は「ベーコン」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// namesOfIntegers is an empty [Int: String] dictionary</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（namesOfIntegersは、空の[Int: String]の辞書です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// namesOfIntegers is once again an empty dictionary of type [Int: String]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（namesOfIntegersは、またもとのように型[Int: String]の空の辞書です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// namesOfIntegers now contains 1 key-value pair</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（namesOfIntegersは、現在は１つの「キーと値」の対を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// ncc1701.fullName is "USS Enterprise"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（ncc1701.fullNameは、USSエンタープライズです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// negative is a Vector2D instance with values of (-3.0, -4.0)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（negativeは、値(-3.0, -4.0)をもつVector2Dインスタンです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// nested Rank enumeration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（入れ子にされたRank列挙）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// nested Suit enumeration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（入れ子にされたSuit列挙）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// nestedValue is 24</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（nestedValue は 24 です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// new functionality to add to SomeType goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（SomeTypeに加える新しい機能性が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// no error was thrown</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（エラーはスローされなかった）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// originRect's origin is (2.0, 2.0) and its size is (5.0, 5.0)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（centerRectの原点は (2.0, 2.0)、そのサイズは(5.0, 5.0)です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// original IntStack implementation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（元々のIntStack実施）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// original Stack&lt;Element&gt; implementation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（元々のStack&lt;Element&gt;実装）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// original now has values of (4.0, 6.0)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（originalは、現在(4.0, 6.0)の値を持ちます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// ovenLight is now equal to .high</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（ovenLightは現在.hightと等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// ovenLight is now equal to .off</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（ovenLightは現在.lowと等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// perform some initialization here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（ここで何らかの初期化を行う）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// perform the deinitialization</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（デイニシャライズを実行する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// pi equals 3.14159, and is inferred to be of type Double</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（piは、3.14159に等しく、型Doubleであると推論されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// pi is inferred to be of type Double</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（パイはDouble型であると推測されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// plusMinusVector is a Vector2D instance with values of (4.0, -2.0)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（plusMinusVectorはVector2Dインスタンスで(4.0, -2.0)の値をもちます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// possiblePlanet is of type Planet? and equals Planet.uranus</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（possiblePlanetは、型Planet?で、Planet.uranusに等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// potentialOverflow equals 32767, which is the maximum value an Int16 can hold</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（potentialOverflowは32767と等しく、それはInt16が持つことができる最大限の値です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// precomposed is 한, decomposed is 한</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（合成済は「한」, 分解したものは「한」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// print(protocolValue.anotherProperty)  // Uncomment to see the error</seg>
      </tuv>
      <tuv lang="JA">
        <seg>// print(protocolValue.anotherProperty)  // コメントを外すとエラー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// prints "hello, world" and returns a value of 12</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「よろしく、世界」を出力して値12を返します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// prints "hello, world" but does not return a value</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「よろしく、世界」を出力しますが値を返しません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// produces an optional instance of 'SomeStruct'</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「SomeStruct」のオプショナルインスタンスを生成します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// protocol definition</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（プロトコル定義）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// protocol definition goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（プロトコル定義が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// refer to the argument values for the first and second parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（最初と２番目のパラメーターに対する引き数の値を参照します。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// regionalIndicatorForUS is 🇺🇸</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（regionalIndicatorForUS は 🇺🇸 です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// render the tick mark each minute (60 times)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（各分に目盛りを描画する（60回））</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// render the tick mark every 3 hours (3, 6, 9, 12)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（３時間ごとに目盛りを描画する（3, 6, 9, 12））</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// render the tick mark every 5 minutes (0, 5, 10, 15 ... 45, 50, 55)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（５分毎に目盛りを描画する（0, 5, 10, 15 ... 45, 50, 55））</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// returns 0, as if you had requested:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（まるであなたが次のように要請したかのように、0を返します：）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// returns 10.0, which is the arithmetic mean of these three numbers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（10.0を返します、それはこれら３つの数の算術平均です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// returns 2</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（2を返します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// returns 3.0, which is the arithmetic mean of these five numbers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（3.0を返します、それはこれら５つの数の算術平均です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// returns 5</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（5を返します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// returns 7</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（7を返します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// returns 9</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（9を返します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// returns a value of 10</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（値10を返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// returns a value of 20</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（値20を返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// returns a value of 30</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（値30を返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// returns a value of 40</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（値40を返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// returns a value of 50</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（値50を返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// returns a value of 60</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（値60を返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// returns a value of 7</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（値7を返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// reversedNames is equal to ["Ewa", "Daniella", "Chris", "Barry", "Alex"]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（reversedNamesは["Ewa", "Daniella", "Chris", "Barry", "Alex"]に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// roll the dice</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（さいころを振る）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// rowHeight is equal to 90</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（rowHeightは、90と等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// serverResponseCode contains an actual Int value of 404</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（serverResponseCodeは、実際にあるInt値404を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// serverResponseCode now contains no value</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（serverResponseCodeは、現在は値を含みません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// shoppingList has been initialized with two initial items</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（shoppingListが、２つの最初の項目で初期化された）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// shoppingList now contains 3 items, and someone is making pancakes</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（shoppingListは現在３つの項目を含みます、そして誰かはパンケーキを作っています）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// shoppingList now contains 4 items</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（shoppingListは、現在４つの項目を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// shoppingList now contains 5 items, and no apples</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（shoppingListは現在は５つの項目を含みます、そして「リンゴ」は含みません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// shoppingList now contains 6 items</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（shoppingListは、現在６つの項目を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// shoppingList now contains 6 items, and no Maple Syrup</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（shoppingListは、現在６つの項目、メープルシロップ以外を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// shoppingList now contains 7 items</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（shoppingListは、現在７つの項目を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// signedOverflow equals -128, which is the minimum value an Int8 can hold</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（signedOverflowは-128と等しく、それはInt8が持つことができる最小限の値です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// signedOverflow is now equal to 127</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（signedOverflowは、現在127と等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// sixDoubles is inferred as [Double], and equals [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（sixDoublesは、[Double]と推論され、 [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]に等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// someCreature is of type Animal?, not Animal</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（someCreatureは、型Animal?です、Animalではなく）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// someDictionary is now ["a": [100, 2, 3], "b": [10, 20]]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（someDictionary は、現在 ["a": [100, 2, 3], "b": [10, 20]] です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// someDictionary is now ["a": [42, 2, 3], "b": [10, 20]]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（omeDictionary は、現在 ["a": [42, 2, 3], "b": [10, 20]] です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// someDictionary is still ["a": [1, 2, 3], "b": [10, 20]]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（someDictionary は、まだ ["a": [1, 2, 3], "b": [10, 20]] です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// someFunction takes an integer and a closure as its arguments</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（someFunctionは、その引数として整数とクロージャをとります）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// someFunctionWithSideEffects is evaluated and returns 42</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（someFunctionWithSideEffectsは、評価されて42を返します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// someFunctionWithSideEffects is not evaluated</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（someFunctionWithSideEffectsは、評価されません。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// someInt is now 107, and anotherInt is now 3</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（someIntは今は107、anotherIntは今は３です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// someInt is now 9</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（someIntは、現在９です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// someInts is now an empty array, but is still of type [Int]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（someIntsは、現在は空の配列です、しかし依然として型[Int]です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// someInts now contains 1 value of type Int</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（someIntsは、現在は型Intの値ひとつを含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// someMethod takes a closure as its only argument</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（someMethodは、そのただ１つの引数としてクロージャをとります）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// someString is now "world", and anotherString is now "hello"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（someStringは今は「world」、anotherStringは今は「hello」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// someValue must be of the same type as SomeType</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（someValueは、SomeTypeと同じ型でなければなりません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// spiders have 8 legs</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（蜘蛛は、８本の足を持っています）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// stepSize is now 2</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（stepSize は現在 2 です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// store this as the new overall maximum input level</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これを新しい全体で最大の入力レベルとして格納する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// stringIndex is an optional Int containing a value of 2</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（stringIndexは、オプショナルのIntで値２を含んでいます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// strings is inferred to be of type [String]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（stringsは型[String]と推論されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// structure definition goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（構造体定義が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// subclass definition goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（サブクラス定義がここに来ます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// subclass implementation of the required initializer goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（必須イニシャライザのサブクラス実装がここに来ます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// subclass initialization goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（サブクラスの初期化が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// suffix contains 20 and 30</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（suffix は 20 と 30を含む）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// sunsetDirection is "west"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（sunsetDirectionは、「west」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// super.init() implicitly called here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（super.init() が暗黙的にここで呼び出されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// surveyAnswer is automatically set to nil</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（surveyAnswerは、自動的にnilに設定されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the "Dave" array is now [91, 82, 84] and the "Bev" array is now [80, 94, 81]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「Dave」配列は現在[91, 82, 84]です、そして「Bev」配列は現在[80, 94, 81]です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the DataImporter class would provide data importing functionality here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（DataImporterクラスは、データをインポートする機能性をここで提供します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the DataImporter instance for the importer property has not yet been created</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（importerプロパティのためのDataImporterインスタンスは、まだ作成されていません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the DataImporter instance for the importer property has now been created</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（importerプロパティのためのDataImporterインスタンスが、今つくられました）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the DataManager class would provide data management functionality here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（DataManagerクラスは、データ管理の機能性をここで提供します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the airports dictionary now contains 3 items</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（airports辞書は、現在３つの項目を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the apples constant is now equal to the removed "Apples" string</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（apples定数は、現在は削除された文字列「リンゴ」と等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the counter's value is now 0</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（counterの値は、いま0です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the counter's value is now 1</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（counterの値は、いま１です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the counter's value is now 6</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（counterの値は、いま６です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the first item in the list is now equal to "Six eggs" rather than "Eggs"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（リストの中の最初の項目は、現在「６つの卵」と等しいです、「卵」ではなく）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the initial counter value is 0</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（counterの最初の値は、0です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the item that was at index 0 has just been removed</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（インデックス0であった項目が、ちょうど今取り除かれました）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the last item in the array has just been removed</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（配列での最後の項目が、ちょうど今取り除かれました）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the mapleSyrup constant is now equal to the removed "Maple Syrup" string</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（定数mapleSyrupは、現在は削除された「メープルシロップ」文字列と等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the range now represents integer values 6, 7, and 8</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（範囲は、現在は整数値６、７、そして８を表します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the range represents integer values 0, 1, and 2</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（範囲は、整数値０、１、そして２を表します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the stack now contains 4 strings</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（スタックは、現在４つの文字列を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the type of "library" is inferred to be [MediaItem]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「library」の型は、[MediaItem]であると推測されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the value for "LHR" has been changed to "London Heathrow"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（「LHR」に対する値は、「ロンドン・ヒースロー」に変えられました）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// the value of parameterWithDefault is 12 inside the function body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（parameterWithDefaultの値はこの関数本文の内部で12です。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// these two strings are both empty, and are equivalent to each other</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これらの２つの文字列は両方とも空で、お互いに等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// this causes an error</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これは、エラーを引き起こします）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// this equals 17</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これは17に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// this example will compile successfully</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（この例は、うまくコンパイルします）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// this example will not compile, and will report an error</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（この例はコンパイルせず、エラーを報告します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// this function may or may not throw an error</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（この関数はエラーをスローするかもしれないししないかもしれない）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// this initializer creates a document with a nil name value</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（このイニシャライザはnilのname値を使って書類を作成します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// this initializer creates a document with a nonempty name value</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（このイニシャライザは空でないname値を使って書類を作成します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// this is a valid move, so find out its effect</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これは有効な動きです、それでその効果を調べます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// this range represents integer values 0, 1, 2, and 3</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（この範囲構造体、整数値０、１、２、そして３を表します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// this reports a compile-time error - a constant string cannot be modified</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これはコンパイル時エラー - 定数文字列は修正できません、を報告します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// this reports a compile-time error - argument labels are required</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これはコンパイル時エラーを報告します - 引数ラベルが必要とされます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// this triggers a runtime error</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これは、実行時エラーの引き金となります）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// this will report an error</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これは、エラーを報告します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// this will report an error, even though firstValue is a variable property</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これはエラーを報告します、たとえfirstValueが変数プロパティであるとしてもです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// threeDoubles is of type [Double], and equals [0.0, 0.0, 0.0]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（threeDoublesは、型[Double]で、 [0.0, 0.0, 0.0]に等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// toBeDoubled now has values of (2.0, 8.0)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（toBeDoubledは、現在(2.0, 8.0)の値を持ちます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// trailing closure's body goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（後付クロージャの本文がここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// type method implementation goes here</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（型メソッドの実施が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// unsignedOverflow equals 0, which is the minimum value a UInt8 can hold</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（unsignedOverflowは0と等しく、それはUInt8が持つことができる最小限の値です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// unsignedOverflow equals 255, which is the maximum value a UInt8 can hold</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（unsignedOverflowは255に等しく、それはUInt８が持つことができる最大限の値です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// unsignedOverflow is now equal to 0</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（unsignedOverflowは、現在0と等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// unsignedOverflow is now equal to 255</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（unsignedOverflowは、現在255と等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// userDefinedColorName is nil, so colorNameToUse is set to the default of "red"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（userDefinedColorNameはnilです、なのでcolorNameToUseは省略時の「赤」に設定されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// userDefinedColorName is not nil, so colorNameToUse is set to "green"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これはnilではありません、それでcolorNameToUseは「緑」に設定されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// value is 12</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（valueは12です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// valueChanged is of type Int?, not Int</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（valueChanged は、型 Int? のものです、Int ではなく）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// variableString is now "Horse and carriage"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（variableStringは、現在「馬と馬車」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// welcome now equals "hello there!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（welcomeは、現在「やあ！、こんにちは」に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// welcome now equals "hello there"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（welcomeは、現在「やあ、こんにちは」に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// welcome now equals "hello!"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（welcomeは、現在「こんにちは！」に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// welcome now equals "hello"</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（welcomeは、現在「こんにちは」に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// x is 10, and 20 is ignored</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（xは10です、そして20は無視されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// x is equal to 1, and y is equal to 2</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（xは１と等しい、そしてyは２と等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// x is now 1</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（x は、現在 1 です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// zero as a Double</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（浮動小数点のゼロ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>// zero as an Int</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（整数のゼロ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;&lt;s1&gt;Advanced Operators&lt;/s1&gt;&lt;/a0&gt; covers Swift’s advanced operators, and describes how to define your own custom operators and implement the standard operators for your own custom types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;先進の演算子&lt;/s1&gt;&lt;/a0&gt;では、スウィフトの先進の演算子を取り扱い、加えてあなた独自のあつらえの演算子を定義する方法、そしてあなた独自のあつらえの型のために標準の演算子を実装する方法を解説します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;&lt;s1&gt;Array Type Shorthand Syntax&lt;/s1&gt;&lt;/a0&gt; is now written as &lt;c2&gt;&lt;s3&gt;[SomeType]&lt;/s3&gt;&lt;/c2&gt; rather than &lt;c4&gt;&lt;s5&gt;SomeType[]&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;配列型の短縮形構文&lt;/s1&gt;&lt;/a0&gt;は、現在は&lt;c2&gt;&lt;s3&gt;[SomeType]&lt;/s3&gt;&lt;/c2&gt;のように書かれます、&lt;c4&gt;&lt;s5&gt;SomeType[]&lt;/s5&gt;&lt;/c4&gt;ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;&lt;s1&gt;Assertions and Preconditions&lt;/s1&gt;&lt;/a0&gt; can now use string interpolation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;表明と前提条件&lt;/s1&gt;&lt;/a0&gt;は今では文字列補間を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;&lt;s1&gt;Optionals&lt;/s1&gt;&lt;/a0&gt; no longer implicitly evaluate to &lt;c2&gt;&lt;s3&gt;true&lt;/s3&gt;&lt;/c2&gt; when they have a value and &lt;c4&gt;&lt;s5&gt;false&lt;/s5&gt;&lt;/c4&gt; when they do not, to avoid confusion when working with optional &lt;c6&gt;&lt;s7&gt;Bool&lt;/s7&gt;&lt;/c6&gt; values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;オプショナル&lt;/s1&gt;&lt;/a0&gt;はもはや暗黙的に、それが値を持つとき&lt;c2&gt;&lt;s3&gt;true&lt;/s3&gt;&lt;/c2&gt;に、そしてそれがそうしないとき&lt;c4&gt;&lt;s5&gt;false&lt;/s5&gt;&lt;/c4&gt;に評価されません、それによってオプショナル&lt;c6&gt;&lt;s7&gt;Bool&lt;/s7&gt;&lt;/c6&gt;を扱うときの混乱を防ぐためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;(3&lt;/s1&gt; &lt;s2&gt;%&lt;/s2&gt; &lt;s3&gt;4)&lt;/s3&gt;&lt;/c0&gt; is &lt;c4&gt;&lt;s5&gt;3&lt;/s5&gt;&lt;/c4&gt;, so this is equivalent to:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;(3&lt;/s1&gt; &lt;s2&gt;%&lt;/s2&gt; &lt;s3&gt;4)&lt;/s3&gt;&lt;/c0&gt;は&lt;c4&gt;&lt;s5&gt;3&lt;/s5&gt;&lt;/c4&gt;なので、これは以下に等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;(3&lt;/s1&gt; &lt;s2&gt;*&lt;/s2&gt; &lt;s3&gt;5)&lt;/s3&gt;&lt;/c0&gt; is &lt;c4&gt;&lt;s5&gt;15&lt;/s5&gt;&lt;/c4&gt;, so this is equivalent to:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;(3&lt;/s1&gt; &lt;s2&gt;*&lt;/s2&gt; &lt;s3&gt;5)&lt;/s3&gt;&lt;/c0&gt;は&lt;c4&gt;&lt;s5&gt;15&lt;/s5&gt;&lt;/c4&gt;なので、これは以下に等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;0xFp-2&lt;/s1&gt;&lt;/c0&gt; means 15 x 2&lt;s2&gt;-2&lt;/s2&gt;, or &lt;c3&gt;&lt;s4&gt;3.75&lt;/s4&gt;&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;0xFp-2&lt;/s1&gt;&lt;/c0&gt;は、15 × 2&lt;s2&gt;-2&lt;/s2&gt;、または&lt;c3&gt;&lt;s4&gt;3.75&lt;/s4&gt;&lt;/c3&gt;を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;0xFp2&lt;/s1&gt;&lt;/c0&gt; means 15 x 2&lt;s2&gt;2&lt;/s2&gt;, or &lt;c3&gt;&lt;s4&gt;60.0&lt;/s4&gt;&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;0xFp2&lt;/s1&gt;&lt;/c0&gt;は、15 × 2&lt;s2&gt;2&lt;/s2&gt;、または&lt;c3&gt;&lt;s4&gt;60.0&lt;/s4&gt;&lt;/c3&gt;を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;1.25e-2&lt;/s1&gt;&lt;/c0&gt; means 1.25 x 10&lt;s2&gt;-2&lt;/s2&gt;, or &lt;c3&gt;&lt;s4&gt;0.0125&lt;/s4&gt;&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;1.25e-2&lt;/s1&gt;&lt;/c0&gt;は、1.25 × 10&lt;s2&gt;-2&lt;/s2&gt;、または&lt;c3&gt;&lt;s4&gt;0.0125&lt;/s4&gt;&lt;/c3&gt;を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;1.25e2&lt;/s1&gt;&lt;/c0&gt; means 1.25 x 10&lt;s2&gt;2&lt;/s2&gt;, or &lt;c3&gt;&lt;s4&gt;125.0&lt;/s4&gt;&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;1.25e2&lt;/s1&gt;&lt;/c0&gt;は、1.25 × 10&lt;s2&gt;2&lt;/s2&gt;、または&lt;c3&gt;&lt;s4&gt;125.0&lt;/s4&gt;&lt;/c3&gt;を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;123456789[0]&lt;/s1&gt;&lt;/c0&gt; returns &lt;c2&gt;&lt;s3&gt;9&lt;/s3&gt;&lt;/c2&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;123456789[0]&lt;/s1&gt;&lt;/c0&gt;は&lt;c2&gt;&lt;s3&gt;9&lt;/s3&gt;&lt;/c2&gt;を返します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;123456789[1]&lt;/s1&gt;&lt;/c0&gt; returns &lt;c2&gt;&lt;s3&gt;8&lt;/s3&gt;&lt;/c2&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;123456789[1]&lt;/s1&gt;&lt;/c0&gt;は&lt;c2&gt;&lt;s3&gt;8&lt;/s3&gt;&lt;/c2&gt;を返します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;1&lt;/s1&gt;&lt;/c0&gt; times &lt;c2&gt;&lt;s3&gt;5&lt;/s3&gt;&lt;/c2&gt; equals &lt;c4&gt;&lt;s5&gt;5&lt;/s5&gt;&lt;/c4&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;1&lt;/s1&gt;&lt;/c0&gt;掛ける&lt;c2&gt;&lt;s3&gt;5&lt;/s3&gt;&lt;/c2&gt;は&lt;c4&gt;&lt;s5&gt;5&lt;/s5&gt;&lt;/c4&gt;に等しい</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;2&lt;/s1&gt;&lt;/c0&gt; plus &lt;c2&gt;&lt;s3&gt;3&lt;/s3&gt;&lt;/c2&gt; equals &lt;c4&gt;&lt;s5&gt;5&lt;/s5&gt;&lt;/c4&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;2&lt;/s1&gt;&lt;/c0&gt;足す&lt;c2&gt;&lt;s3&gt;3&lt;/s3&gt;&lt;/c2&gt;は&lt;c4&gt;&lt;s5&gt;5&lt;/s5&gt;&lt;/c4&gt;に等しい</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;5&lt;/s1&gt;&lt;/c0&gt; remainder &lt;c2&gt;&lt;s3&gt;4&lt;/s3&gt;&lt;/c2&gt; equals &lt;c4&gt;&lt;s5&gt;1&lt;/s5&gt;&lt;/c4&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;5&lt;/s1&gt;&lt;/c0&gt;割る&lt;c2&gt;&lt;s3&gt;4&lt;/s3&gt;&lt;/c2&gt;の余りは&lt;c4&gt;&lt;s5&gt;1&lt;/s5&gt;&lt;/c4&gt;に等しい</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;&gt;=&lt;/s1&gt;&lt;/c0&gt; or &lt;c2&gt;&lt;s3&gt;&lt;&lt;/s3&gt;&lt;/c2&gt; followed by a version number</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;&gt;=&lt;/s1&gt;&lt;/c0&gt;または&lt;c2&gt;&lt;s3&gt;&lt;&lt;/s3&gt;&lt;/c2&gt;にバージョン番号が続きます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;@autoclosure&lt;/s1&gt;&lt;/c0&gt; is now an attribute of the parameter declaration, not its type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;@autoclosure&lt;/s1&gt;&lt;/c0&gt;は今ではパラメーター宣言の属性です、それの型ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;Any&lt;/s1&gt;&lt;/c0&gt; can represent an instance of any type at all, including function types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Any&lt;/s1&gt;&lt;/c0&gt;は、関数型を含めて、ともかくどんな型のインスタンスでも表すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;AnyObject&lt;/s1&gt;&lt;/c0&gt; can represent an instance of any class type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;AnyObject&lt;/s1&gt;&lt;/c0&gt;は、どんなクラス型のインスタンスでも表すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;Bank&lt;/s1&gt;&lt;/c0&gt; keeps track of the current number of coins it holds with its &lt;c2&gt;&lt;s3&gt;coinsInBank&lt;/s3&gt;&lt;/c2&gt; property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Bank&lt;/s1&gt;&lt;/c0&gt;は、それがその&lt;c2&gt;&lt;s3&gt;coinsInBank&lt;/s3&gt;&lt;/c2&gt;プロパティで保持するコインの現在の数の情報を得続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;C1&lt;/s1&gt;&lt;/c0&gt; must conform to the &lt;c2&gt;&lt;s3&gt;Container&lt;/s3&gt;&lt;/c2&gt; protocol (written as &lt;c4&gt;&lt;s5&gt;C1:&lt;/s5&gt; &lt;s6&gt;Container&lt;/s6&gt;&lt;/c4&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;C1&lt;/s1&gt;&lt;/c0&gt;は、&lt;c2&gt;&lt;s3&gt;Container&lt;/s3&gt;&lt;/c2&gt;プロトコルに準拠しなければなりません（&lt;c4&gt;&lt;s5&gt;C1:&lt;/s5&gt; &lt;s6&gt;Container&lt;/s6&gt;&lt;/c4&gt;のように書かれます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;C2&lt;/s1&gt;&lt;/c0&gt; must also conform to the &lt;c2&gt;&lt;s3&gt;Container&lt;/s3&gt;&lt;/c2&gt; protocol (written as &lt;c4&gt;&lt;s5&gt;C2:&lt;/s5&gt; &lt;s6&gt;Container&lt;/s6&gt;&lt;/c4&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;C2&lt;/s1&gt;&lt;/c0&gt;もまた、&lt;c2&gt;&lt;s3&gt;Container&lt;/s3&gt;&lt;/c2&gt;プロトコルに準拠しなければなりません（&lt;c4&gt;&lt;s5&gt;C2:&lt;/s5&gt; &lt;s6&gt;Container&lt;/s6&gt;&lt;/c4&gt;のように書かれます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;Color&lt;/s1&gt;&lt;/c0&gt; provides an initializer with three appropriately named parameters of type &lt;c2&gt;&lt;s3&gt;Double&lt;/s3&gt;&lt;/c2&gt; for its red, green, and blue components.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Color&lt;/s1&gt;&lt;/c0&gt;はイニシャライザに、それの赤、緑、および青の構成要素に対する３つの適切に命名された型&lt;c2&gt;&lt;s3&gt;Double&lt;/s3&gt;&lt;/c2&gt;のパラメータを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;Dice&lt;/s1&gt;&lt;/c0&gt; also has an initializer, to set up its initial state.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Dice&lt;/s1&gt;&lt;/c0&gt;はまた、その最初の状態を設定するために、イニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;Dice&lt;/s1&gt;&lt;/c0&gt; provides one instance method, &lt;c2&gt;&lt;s3&gt;roll&lt;/s3&gt;&lt;/c2&gt;, which returns an integer value between 1 and the number of sides on the dice.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Dice&lt;/s1&gt;&lt;/c0&gt;は１つのインスタンスメソッド、&lt;c2&gt;&lt;s3&gt;roll&lt;/s3&gt;&lt;/c2&gt;を提供します、それは、１とさいころ上の面の数との間の整数値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;DiceGameDelegate&lt;/s1&gt;&lt;/c0&gt; provides three methods for tracking the progress of a game.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;DiceGameDelegate&lt;/s1&gt;&lt;/c0&gt;は、３つのメソッドをゲームの進捗を追うために提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;DiceGameTracker&lt;/s1&gt;&lt;/c0&gt; implements all three methods required by &lt;c2&gt;&lt;s3&gt;DiceGameDelegate&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;DiceGameTracker&lt;/s1&gt;&lt;/c0&gt;は、&lt;c2&gt;&lt;s3&gt;DiceGameDelegate&lt;/s3&gt;&lt;/c2&gt;によって要求される３つのメソッド全てを実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;Double&lt;/s1&gt;&lt;/c0&gt; has a precision of at least 15 decimal digits, whereas the precision of &lt;c2&gt;&lt;s3&gt;Float&lt;/s3&gt;&lt;/c2&gt; can be as little as 6 decimal digits.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Double&lt;/s1&gt;&lt;/c0&gt;は少なくとも10進数で15桁の精度を持ちます、一方で&lt;c2&gt;&lt;s3&gt;Float&lt;/s3&gt;&lt;/c2&gt;の精度は10進数で６桁ほどです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;Double&lt;/s1&gt;&lt;/c0&gt; represents a 64-bit floating-point number.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Double&lt;/s1&gt;&lt;/c0&gt;は、64ビットの浮動小数点数を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;Element&lt;/s1&gt;&lt;/c0&gt; defines a placeholder name for a type to be provided later.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Element&lt;/s1&gt;&lt;/c0&gt;は、プレースホルダ名を、後で提供されることになるある型に対して定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;Float&lt;/s1&gt;&lt;/c0&gt; represents a 32-bit floating-point number.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Float&lt;/s1&gt;&lt;/c0&gt;は、32ビットの浮動小数点数を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;LevelTracker&lt;/s1&gt;&lt;/c0&gt; also defines two type functions to work with the &lt;c2&gt;&lt;s3&gt;highestUnlockedLevel&lt;/s3&gt;&lt;/c2&gt; property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;LevelTracker&lt;/s1&gt;&lt;/c0&gt;はまた、２つの型関数を定義して&lt;c2&gt;&lt;s3&gt;highestUnlockedLevel&lt;/s3&gt;&lt;/c2&gt;プロパティを取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;Matrix&lt;/s1&gt;&lt;/c0&gt; provides an initializer that takes two parameters called &lt;c2&gt;&lt;s3&gt;rows&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;columns&lt;/s5&gt;&lt;/c4&gt;, and creates an array that is large enough to store &lt;c6&gt;&lt;s7&gt;rows&lt;/s7&gt; &lt;s8&gt;*&lt;/s8&gt; &lt;s9&gt;columns&lt;/s9&gt;&lt;/c6&gt; values of type &lt;c10&gt;&lt;s11&gt;Double&lt;/s11&gt;&lt;/c10&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Matrix&lt;/s1&gt;&lt;/c0&gt;はひとつのイニシャライザを提供します、それは&lt;c2&gt;&lt;s3&gt;rows&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;columns&lt;/s5&gt;&lt;/c4&gt;と呼ばれる２つのパラメータをとり、型&lt;c10&gt;&lt;s11&gt;Double&lt;/s11&gt;&lt;/c10&gt;で個数&lt;c6&gt;&lt;s7&gt;rows&lt;/s7&gt; &lt;s8&gt;*&lt;/s8&gt; &lt;s9&gt;columns&lt;/s9&gt;&lt;/c6&gt;の値を格納するのに十分大きい配列をつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;Point&lt;/s1&gt;&lt;/c0&gt; encapsulates the x- and y-coordinate of a point.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Point&lt;/s1&gt;&lt;/c0&gt;は、ある地点のxおよひy座標をカプセル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;Rank&lt;/s1&gt;&lt;/c0&gt; also defines a computed property, &lt;c2&gt;&lt;s3&gt;values&lt;/s3&gt;&lt;/c2&gt;, which returns an instance of the &lt;c4&gt;&lt;s5&gt;Values&lt;/s5&gt;&lt;/c4&gt; structure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Rank&lt;/s1&gt;&lt;/c0&gt;はまた、ある計算プロパティ、&lt;c2&gt;&lt;s3&gt;values&lt;/s3&gt;&lt;/c2&gt;を定義します、それは、&lt;c4&gt;&lt;s5&gt;Values&lt;/s5&gt;&lt;/c4&gt;構造体のインスタンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;RecipeIngredient&lt;/s1&gt;&lt;/c0&gt; also defines a convenience initializer, &lt;c2&gt;&lt;s3&gt;init(name:&lt;/s3&gt; &lt;s4&gt;String)&lt;/s4&gt;&lt;/c2&gt;, which is used to create a &lt;c5&gt;&lt;s6&gt;RecipeIngredient&lt;/s6&gt;&lt;/c5&gt; instance by name alone.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;RecipeIngredient&lt;/s1&gt;&lt;/c0&gt;はまた、便宜イニシャライザ、&lt;c2&gt;&lt;s3&gt;init(name:&lt;/s3&gt; &lt;s4&gt;String)&lt;/s4&gt;&lt;/c2&gt;を定義します、それは、名前だけで&lt;c5&gt;&lt;s6&gt;RecipeIngredient&lt;/s6&gt;&lt;/c5&gt;インスタンスを作成するのに使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;Rect&lt;/s1&gt;&lt;/c0&gt; defines a rectangle by an origin point and a size.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Rect&lt;/s1&gt;&lt;/c0&gt;は、原点と大きさによって長方形を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;Residence&lt;/s1&gt;&lt;/c0&gt; instances have a single &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt; property called &lt;c4&gt;&lt;s5&gt;numberOfRooms&lt;/s5&gt;&lt;/c4&gt;, with a default value of &lt;c6&gt;&lt;s7&gt;1&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Residence&lt;/s1&gt;&lt;/c0&gt;インスタンスは、&lt;c4&gt;&lt;s5&gt;numberOfRooms&lt;/s5&gt;&lt;/c4&gt;と呼ばれる省略時の値&lt;c6&gt;&lt;s7&gt;1&lt;/s7&gt;&lt;/c6&gt;を持つ&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;プロパティただひとつを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;ShoppingListItem&lt;/s1&gt;&lt;/c0&gt; does not define an initializer to provide an initial value for &lt;c2&gt;&lt;s3&gt;purchased&lt;/s3&gt;&lt;/c2&gt;, because items in a shopping list (as modeled here) always start out unpurchased.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;ShoppingListItem&lt;/s1&gt;&lt;/c0&gt;は&lt;c2&gt;&lt;s3&gt;purchased&lt;/s3&gt;&lt;/c2&gt;に初期値を用意するイニシャライザを定義しません、なぜなら、購入品目リストの項目が（ここでモデル化されるように）常に未購入で始められるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;Size&lt;/s1&gt;&lt;/c0&gt; encapsulates a &lt;c2&gt;&lt;s3&gt;width&lt;/s3&gt;&lt;/c2&gt; and a &lt;c4&gt;&lt;s5&gt;height&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Size&lt;/s1&gt;&lt;/c0&gt;は、&lt;c2&gt;&lt;s3&gt;width&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;height&lt;/s5&gt;&lt;/c4&gt;をカプセル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;SomeType(ofInitialValue)&lt;/s1&gt;&lt;/c0&gt; is the default way to call the initializer of a Swift type and pass in an initial value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;SomeType(ofInitialValue)&lt;/s1&gt;&lt;/c0&gt;は、あるスウィフト型のイニシャライザを呼んで、初期値を渡すために通常使う方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; values can be added together (or &lt;e2&gt;concatenated&lt;/e2&gt;) with the addition operator (&lt;c3&gt;&lt;s4&gt;+&lt;/s4&gt;&lt;/c3&gt;) to create a new &lt;c5&gt;&lt;s6&gt;String&lt;/s6&gt;&lt;/c5&gt; value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;値は、新しい&lt;c5&gt;&lt;s6&gt;String&lt;/s6&gt;&lt;/c5&gt;値をつくるために加算演算子（&lt;c3&gt;&lt;s4&gt;+&lt;/s4&gt;&lt;/c3&gt;）を使って１つに足し合わされる（または&lt;e2&gt;連結される&lt;/e2&gt;）ことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; values can be constructed by passing an array of &lt;c2&gt;&lt;s3&gt;Character&lt;/s3&gt;&lt;/c2&gt; values as an argument to its initializer:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;値は、&lt;c2&gt;&lt;s3&gt;Character&lt;/s3&gt;&lt;/c2&gt;値の配列をそれのイニシャライザへの引数として渡すことによって組み立てられることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;Tandem&lt;/s1&gt;&lt;/c0&gt; inherits all of the properties and methods from &lt;c2&gt;&lt;s3&gt;Bicycle&lt;/s3&gt;&lt;/c2&gt;, which in turn inherits all of the properties and methods from &lt;c4&gt;&lt;s5&gt;Vehicle&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Tandem&lt;/s1&gt;&lt;/c0&gt;は、すべてのプロパティとメソッドを&lt;c2&gt;&lt;s3&gt;Bicycle&lt;/s3&gt;&lt;/c2&gt;から継承します、そして今度はそれがすべてのプロパティとメソッドを&lt;c4&gt;&lt;s5&gt;Vehicle&lt;/s5&gt;&lt;/c4&gt;から継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;UInt8&lt;/s1&gt;&lt;/c0&gt; integers have eight bits and can store any value between &lt;c2&gt;&lt;s3&gt;0&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;255&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;UInt8&lt;/s1&gt;&lt;/c0&gt;整数は、８ビットを持ち、&lt;c2&gt;&lt;s3&gt;0&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;255&lt;/s5&gt;&lt;/c4&gt;の間でのどんな値でも格納することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt; &lt;s2&gt;==&lt;/s2&gt; &lt;s3&gt;a&lt;/s3&gt;&lt;/c0&gt; (Reflexivity)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt; &lt;s2&gt;==&lt;/s2&gt; &lt;s3&gt;a&lt;/s3&gt;&lt;/c0&gt;（反射性）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt; &lt;s2&gt;==&lt;/s2&gt; &lt;s3&gt;b&lt;/s3&gt;&lt;/c0&gt; implies &lt;c4&gt;&lt;s5&gt;b&lt;/s5&gt; &lt;s6&gt;==&lt;/s6&gt; &lt;s7&gt;a&lt;/s7&gt;&lt;/c4&gt; (Symmetry)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt; &lt;s2&gt;==&lt;/s2&gt; &lt;s3&gt;b&lt;/s3&gt;&lt;/c0&gt;が&lt;c4&gt;&lt;s5&gt;b&lt;/s5&gt; &lt;s6&gt;==&lt;/s6&gt; &lt;s7&gt;a&lt;/s7&gt;&lt;/c4&gt;を意味する（対称性）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;anotherContainer&lt;/s1&gt;&lt;/c0&gt; is a container of type &lt;c2&gt;&lt;s3&gt;C2&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;anotherContainer&lt;/s1&gt;&lt;/c0&gt;は、型&lt;c2&gt;&lt;s3&gt;C2&lt;/s3&gt;&lt;/c2&gt;のコンテナです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;board[0]&lt;/s1&gt;&lt;/c0&gt; always equals &lt;c2&gt;&lt;s3&gt;0&lt;/s3&gt;&lt;/c2&gt; and has no effect.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;board[0]&lt;/s1&gt;&lt;/c0&gt;は、常に&lt;c2&gt;&lt;s3&gt;0&lt;/s3&gt;&lt;/c2&gt;に等しくて、効果を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;didSet&lt;/s1&gt;&lt;/c0&gt; is called immediately after the new value is stored.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;didSet&lt;/s1&gt;&lt;/c0&gt;は、新しい値が格納された直後に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;first&lt;/s1&gt;&lt;/c0&gt;, of type &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;first&lt;/s1&gt;&lt;/c0&gt;、型&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;のもの</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;increment()&lt;/s1&gt;&lt;/c0&gt; increments the counter by &lt;c2&gt;&lt;s3&gt;1&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;increment()&lt;/s1&gt;&lt;/c0&gt;は、&lt;c2&gt;&lt;s3&gt;1&lt;/s3&gt;&lt;/c2&gt;だけカウンターを増加させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;increment(by:&lt;/s1&gt; &lt;s2&gt;Int)&lt;/s2&gt;&lt;/c0&gt; increments the counter by a specified integer amount.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;increment(by:&lt;/s1&gt; &lt;s2&gt;Int)&lt;/s2&gt;&lt;/c0&gt;は、指定された量の整数でカウンターを増加させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;item&lt;/s1&gt; &lt;s2&gt;is&lt;/s2&gt; &lt;s3&gt;Movie&lt;/s3&gt;&lt;/c0&gt; returns &lt;c4&gt;&lt;s5&gt;true&lt;/s5&gt;&lt;/c4&gt; if the current &lt;c6&gt;&lt;s7&gt;MediaItem&lt;/s7&gt;&lt;/c6&gt; is a &lt;c8&gt;&lt;s9&gt;Movie&lt;/s9&gt;&lt;/c8&gt; instance and &lt;c10&gt;&lt;s11&gt;false&lt;/s11&gt;&lt;/c10&gt; if it is not.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;item&lt;/s1&gt; &lt;s2&gt;is&lt;/s2&gt; &lt;s3&gt;Movie&lt;/s3&gt;&lt;/c0&gt;は、現在の&lt;c6&gt;&lt;s7&gt;MediaItem&lt;/s7&gt;&lt;/c6&gt;が&lt;c8&gt;&lt;s9&gt;Movie&lt;/s9&gt;&lt;/c8&gt;インスタンスであるならば&lt;c4&gt;&lt;s5&gt;true&lt;/s5&gt;&lt;/c4&gt;を、そうでないならば&lt;c10&gt;&lt;s11&gt;false&lt;/s11&gt;&lt;/c10&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;john.residence&lt;/s1&gt;&lt;/c0&gt; now contains an actual &lt;c2&gt;&lt;s3&gt;Residence&lt;/s3&gt;&lt;/c2&gt; instance, rather than &lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;john.residence&lt;/s1&gt;&lt;/c0&gt;は、今では実際の&lt;c2&gt;&lt;s3&gt;Residence&lt;/s3&gt;&lt;/c2&gt;インスタンスを含みます、&lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt; and the Booleans &lt;c2&gt;&lt;s3&gt;true&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;false&lt;/s5&gt;&lt;/c4&gt; are now &lt;a6&gt;&lt;s7&gt;Literals&lt;/s7&gt;&lt;/a6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;とブールの&lt;c2&gt;&lt;s3&gt;true&lt;/s3&gt;&lt;/c2&gt;および&lt;c4&gt;&lt;s5&gt;false&lt;/s5&gt;&lt;/c4&gt;は現在&lt;a6&gt;&lt;s7&gt;リテラル&lt;/s7&gt;&lt;/a6&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;number.kind&lt;/s1&gt;&lt;/c0&gt; is already known to be of type &lt;c2&gt;&lt;s3&gt;Int.Kind&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;number.kind&lt;/s1&gt;&lt;/c0&gt;は、既に型&lt;c2&gt;&lt;s3&gt;Int.Kind&lt;/s3&gt;&lt;/c2&gt;であると知られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;repeat&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;while&lt;/s3&gt;&lt;/c2&gt; evaluates its condition at the end of each pass through the loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;repeat&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;while&lt;/s3&gt;&lt;/c2&gt;は、その条件を、ループを通り抜けるそれぞれの終わりで評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;reset()&lt;/s1&gt;&lt;/c0&gt; resets the counter to zero.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;reset()&lt;/s1&gt;&lt;/c0&gt;は、カウンターをゼロに再設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;second&lt;/s1&gt;&lt;/c0&gt;, of type &lt;c2&gt;&lt;s3&gt;Int?&lt;/s3&gt;&lt;/c2&gt;, or “optional &lt;c4&gt;&lt;s5&gt;Int&lt;/s5&gt;&lt;/c4&gt;”</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;second&lt;/s1&gt;&lt;/c0&gt;、型&lt;c2&gt;&lt;s3&gt;Int?&lt;/s3&gt;&lt;/c2&gt;、つまり「オプショナルの&lt;c4&gt;&lt;s5&gt;Int&lt;/s5&gt;&lt;/c4&gt;」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;someContainer&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;anotherContainer&lt;/s3&gt;&lt;/c2&gt; contain the same type of items.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;someContainer&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;anotherContainer&lt;/s3&gt;&lt;/c2&gt;は、同じ型の項目を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;someContainer&lt;/s1&gt;&lt;/c0&gt; is a container of type &lt;c2&gt;&lt;s3&gt;C1&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;someContainer&lt;/s1&gt;&lt;/c0&gt;は、型&lt;c2&gt;&lt;s3&gt;C1&lt;/s3&gt;&lt;/c2&gt;のコンテナです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;while&lt;/s1&gt;&lt;/c0&gt; evaluates its condition at the start of each pass through the loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;while&lt;/s1&gt;&lt;/c0&gt;は、その条件を、ループを通り抜けるそれぞれの始まりで評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c0&gt;&lt;s1&gt;willSet&lt;/s1&gt;&lt;/c0&gt; is called just before the value is stored.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;willSet&lt;/s1&gt;&lt;/c0&gt;は、値が格納される直前に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c10&gt;&lt;s11&gt;HTMLElement&lt;/s11&gt;&lt;/c10&gt; also defines an optional &lt;c12&gt;&lt;s13&gt;text&lt;/s13&gt;&lt;/c12&gt; property, which you can set to a string that represents the text to be rendered within that HTML element.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c10&gt;&lt;s11&gt;HTMLElement&lt;/s11&gt;&lt;/c10&gt;はまた、オプショナルの&lt;c12&gt;&lt;s13&gt;text&lt;/s13&gt;&lt;/c12&gt;プロパティを定義します、それは、あなたはそれをテキストがそのHTML要素の範囲内で提出されると述べる文字列に設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c13&gt;&lt;s14&gt;tenEighty&lt;/s14&gt;&lt;/c13&gt; and &lt;c15&gt;&lt;s16&gt;alsoTenEighty&lt;/s16&gt;&lt;/c15&gt; themselves don’t “store” the &lt;c17&gt;&lt;s18&gt;VideoMode&lt;/s18&gt;&lt;/c17&gt; instance—instead, they both &lt;e19&gt;refer&lt;/e19&gt; to a &lt;c20&gt;&lt;s21&gt;VideoMode&lt;/s21&gt;&lt;/c20&gt; instance behind the scenes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c13&gt;&lt;s14&gt;tenEighty&lt;/s14&gt;&lt;/c13&gt;および&lt;c15&gt;&lt;s16&gt;alsoTenEighty&lt;/s16&gt;&lt;/c15&gt;それら自身は&lt;c17&gt;&lt;s18&gt;VideoMode&lt;/s18&gt;&lt;/c17&gt;インスタンスを格納しません ― そうではなく、それらが両方とも&lt;e19&gt;言及する&lt;/e19&gt;のは舞台裏で&lt;c20&gt;&lt;s21&gt;VideoMode&lt;/s21&gt;&lt;/c20&gt;インスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c2&gt;&lt;s3&gt;currentValue&lt;/s3&gt;&lt;/c2&gt; has an initial value of &lt;c4&gt;&lt;s5&gt;3&lt;/s5&gt;&lt;/c4&gt;, which means that &lt;c6&gt;&lt;s7&gt;currentValue&lt;/s7&gt; &lt;s8&gt;&gt;&lt;/s8&gt; &lt;s9&gt;0&lt;/s9&gt;&lt;/c6&gt; returns &lt;c10&gt;&lt;s11&gt;true&lt;/s11&gt;&lt;/c10&gt;, causing &lt;c12&gt;&lt;s13&gt;chooseStepFunction(backward:)&lt;/s13&gt;&lt;/c12&gt; to return the &lt;c14&gt;&lt;s15&gt;stepBackward(_:)&lt;/s15&gt;&lt;/c14&gt; function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;currentValue&lt;/s3&gt;&lt;/c2&gt;は&lt;c4&gt;&lt;s5&gt;3&lt;/s5&gt;&lt;/c4&gt;の初期値を持ちます、そしてそれは、&lt;c6&gt;&lt;s7&gt;currentValue&lt;/s7&gt; &lt;s8&gt;&gt;&lt;/s8&gt; &lt;s9&gt;0&lt;/s9&gt;&lt;/c6&gt;が&lt;c10&gt;&lt;s11&gt;true&lt;/s11&gt;&lt;/c10&gt;を返して、&lt;c12&gt;&lt;s13&gt;chooseStepFunction(backward:)&lt;/s13&gt;&lt;/c12&gt;が&lt;c14&gt;&lt;s15&gt;stepBackward(_:)&lt;/s15&gt;&lt;/c14&gt;関数を返すことを引き起こすのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c3&gt;&lt;s4&gt;Dice&lt;/s4&gt;&lt;/c3&gt; instances have an integer property called &lt;c5&gt;&lt;s6&gt;sides&lt;/s6&gt;&lt;/c5&gt;, which represents how many sides they have, and a property called &lt;c7&gt;&lt;s8&gt;generator&lt;/s8&gt;&lt;/c7&gt;, which provides a random number generator from which to create dice roll values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c3&gt;&lt;s4&gt;Dice&lt;/s4&gt;&lt;/c3&gt;インスタンスは、それがどれくらいの面を持つのかを表す&lt;c5&gt;&lt;s6&gt;sides&lt;/s6&gt;&lt;/c5&gt;と呼ばれる整数プロパティ、そしてそこからさいころを振った値を作成する乱数生成器を提供する&lt;c7&gt;&lt;s8&gt;generator&lt;/s8&gt;&lt;/c7&gt;と呼ばれるプロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c4&gt;&lt;s5&gt;Character&lt;/s5&gt;&lt;/c4&gt; values are described in &lt;a6&gt;&lt;s7&gt;Strings and Characters&lt;/s7&gt;&lt;/a6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;Character&lt;/s5&gt;&lt;/c4&gt;値は&lt;a6&gt;&lt;s7&gt;文字列と文字&lt;/s7&gt;&lt;/a6&gt;で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c4&gt;&lt;s5&gt;Color&lt;/s5&gt;&lt;/c4&gt; also provides a second initializer with a single &lt;c6&gt;&lt;s7&gt;white&lt;/s7&gt;&lt;/c6&gt; parameter, which is used to provide the same value for all three color components.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;Color&lt;/s5&gt;&lt;/c4&gt;はまた、ただ１つの&lt;c6&gt;&lt;s7&gt;white&lt;/s7&gt;&lt;/c6&gt;パラメータを持つ第２のイニシャライザを提供します、それは３つの色構成要素すべてに同じ値を提供するのに使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c4&gt;&lt;s5&gt;Stack&lt;/s5&gt;&lt;/c4&gt; provides two methods, &lt;c6&gt;&lt;s7&gt;push&lt;/s7&gt;&lt;/c6&gt; and &lt;c8&gt;&lt;s9&gt;pop&lt;/s9&gt;&lt;/c8&gt;, to push and pop values on and off the stack.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;Stack&lt;/s5&gt;&lt;/c4&gt;は２つのメソッド、&lt;c6&gt;&lt;s7&gt;push&lt;/s7&gt;&lt;/c6&gt;と&lt;c8&gt;&lt;s9&gt;pop&lt;/s9&gt;&lt;/c8&gt;を提供します、それでスタック上に値を押し込んだり飛び出させたりします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c5&gt;&lt;s6&gt;Dictionary&lt;/s6&gt;&lt;/c5&gt; needs its keys to be hashable so that it can check whether it already contains a value for a particular key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c5&gt;&lt;s6&gt;Dictionary&lt;/s6&gt;&lt;/c5&gt;は、それが特定のキーのためにすでに値を含むかどうか確認できるように、そのキーにハッシュ化できることを必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c5&gt;&lt;s6&gt;if&lt;/s6&gt;&lt;/c5&gt; and &lt;c7&gt;&lt;s8&gt;while&lt;/s8&gt;&lt;/c7&gt; statements are described in more detail in &lt;a9&gt;&lt;s10&gt;Control Flow&lt;/s10&gt;&lt;/a9&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c5&gt;&lt;s6&gt;if&lt;/s6&gt;&lt;/c5&gt;および&lt;c7&gt;&lt;s8&gt;while&lt;/s8&gt;&lt;/c7&gt;文は更に詳細に&lt;a9&gt;&lt;s10&gt;「制御の流れ」&lt;/s10&gt;&lt;/a9&gt;で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c6&gt;&lt;s7&gt;CartItem&lt;/s7&gt;&lt;/c6&gt; introduces a stored constant property called &lt;c8&gt;&lt;s9&gt;quantity&lt;/s9&gt;&lt;/c8&gt; and ensures that this property always has a value of at least &lt;c10&gt;&lt;s11&gt;1&lt;/s11&gt;&lt;/c10&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;CartItem&lt;/s7&gt;&lt;/c6&gt;は&lt;c8&gt;&lt;s9&gt;quantity&lt;/s9&gt;&lt;/c8&gt;と呼ばれる格納定数プロパティを導入します、そしてこのプロパティが常に少なくとも&lt;c10&gt;&lt;s11&gt;1&lt;/s11&gt;&lt;/c10&gt;の値を持つことを確実にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c6&gt;&lt;s7&gt;ShoppingListItem&lt;/s7&gt;&lt;/c6&gt; also adds a computed &lt;c8&gt;&lt;s9&gt;description&lt;/s9&gt;&lt;/c8&gt; property, which provides a textual description of a &lt;c10&gt;&lt;s11&gt;ShoppingListItem&lt;/s11&gt;&lt;/c10&gt; instance:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;ShoppingListItem&lt;/s7&gt;&lt;/c6&gt;はまた、計算される&lt;c8&gt;&lt;s9&gt;description&lt;/s9&gt;&lt;/c8&gt;プロパティを加えます、それは、&lt;c10&gt;&lt;s11&gt;ShoppingListItem&lt;/s11&gt;&lt;/c10&gt;インスタンスのテキストでの解説を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c6&gt;&lt;s7&gt;Suffix&lt;/s7&gt;&lt;/c6&gt; has two constraints: It must conform to the &lt;c8&gt;&lt;s9&gt;SuffixableContainer&lt;/s9&gt;&lt;/c8&gt; protocol (the protocol currently being defined), and its &lt;c10&gt;&lt;s11&gt;Item&lt;/s11&gt;&lt;/c10&gt; type must be the same as the container’s &lt;c12&gt;&lt;s13&gt;Item&lt;/s13&gt;&lt;/c12&gt; type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;Suffix&lt;/s7&gt;&lt;/c6&gt;は、２つの制約を持ちます：それは&lt;c8&gt;&lt;s9&gt;SuffixableContainer&lt;/s9&gt;&lt;/c8&gt;プロトコル（そのプロトコルはいま定義されるところです）に準拠しなければなりません、そしてそれの&lt;c10&gt;&lt;s11&gt;Item&lt;/s11&gt;&lt;/c10&gt;型はコンテナのもつ&lt;c12&gt;&lt;s13&gt;Item&lt;/s13&gt;&lt;/c12&gt;型と同じでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;c8&gt;&lt;s9&gt;Person&lt;/s9&gt;&lt;/c8&gt; instances have an optional &lt;c10&gt;&lt;s11&gt;residence&lt;/s11&gt;&lt;/c10&gt; property of type &lt;c12&gt;&lt;s13&gt;Residence?&lt;/s13&gt;&lt;/c12&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c8&gt;&lt;s9&gt;Person&lt;/s9&gt;&lt;/c8&gt;インスタンスは、型&lt;c12&gt;&lt;s13&gt;Residence?&lt;/s13&gt;&lt;/c12&gt;のオプショナル&lt;c10&gt;&lt;s11&gt;residence&lt;/s11&gt;&lt;/c10&gt;プロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Access control&lt;/e0&gt; restricts access to parts of your code from code in other source files and modules.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;アクセス制御&lt;/e0&gt;は、あなたのコードの各部への他のソースファイルとモジュールの中のコードからのアクセスを制限します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Assertions&lt;/e0&gt; and &lt;e1&gt;preconditions&lt;/e1&gt; are checks that happen at runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;表明&lt;/e0&gt;と&lt;e1&gt;前提条件&lt;/e1&gt;は、起こることを実行時で調べられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Binary expressions&lt;/e0&gt; combine an infix binary operator with the expression that it takes as its left-hand and right-hand arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;二項式&lt;/e0&gt;は、接中辞二進数演算子を、それがその左手側と右手側の引数としてとる式と組み合わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Binary&lt;/e0&gt; operators operate on two targets (such as &lt;c1&gt;&lt;s2&gt;2&lt;/s2&gt; &lt;s3&gt;+&lt;/s3&gt; &lt;s4&gt;3&lt;/s4&gt;&lt;/c1&gt;) and are &lt;e5&gt;infix&lt;/e5&gt; because they appear in between their two targets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;二項&lt;/e0&gt;演算子は、２つの目標に作用します（例えば&lt;c1&gt;&lt;s2&gt;2&lt;/s2&gt; &lt;s3&gt;+&lt;/s3&gt; &lt;s4&gt;3&lt;/s4&gt;&lt;/c1&gt;のように）、そしてそれがそれら２つの目標の間に現れるので&lt;e5&gt;接中辞&lt;/e5&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Bitwise operators&lt;/e0&gt; enable you to manipulate the individual raw data bits within a data structure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;ビット単位演算子&lt;/e0&gt;は、あなたにあるデータ構造内の個々の生のデータ・ビットを操作することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Closure expressions&lt;/e0&gt; are a way to write inline closures in a brief, focused syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;クロージャ式&lt;/e0&gt;は、簡潔な、焦点のあった構文で、処理の流れに組み込まれた（行内の、インラインの）クロージャを書く方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Closures&lt;/e0&gt; are self-contained blocks of functionality that can be passed around and used in your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;クロージャ&lt;/e0&gt;は、機能性の完全独立のブロック、かたまりです、それは、あなたのコードにおいてあちこちに渡され使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Compound assignment operators&lt;/e0&gt; combine assignment (&lt;c1&gt;&lt;s2&gt;=&lt;/s2&gt;&lt;/c1&gt;) with another operation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;複合代入演算子&lt;/e0&gt;は、代入（&lt;c1&gt;&lt;s2&gt;=&lt;/s2&gt;&lt;/c1&gt;）を別の操作と組み合わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Control transfer statements&lt;/e0&gt; change the order in which your code is executed, by transferring control from one piece of code to another.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;制御移動文&lt;/e0&gt;は、制御をコードのひとつの部分から別のものまで移すことによって、あなたのコードが実行される順番を変えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Convenience initializers&lt;/e0&gt; are secondary, supporting initializers for a class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;便宜イニシャライザ&lt;/e0&gt;は副次的なもので、あるクラスのためのイニシャライザを支援します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Declaration modifiers&lt;/e0&gt; are keywords or context-sensitive keywords that modify the behavior or meaning of a declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;宣言修飾子&lt;/e0&gt;は、キーワードまたは文脈依存キーワードです、それは宣言のふるまいや意味することを修正します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Delegation&lt;/e0&gt; is a design pattern that enables a class or structure to hand off (or &lt;e1&gt;delegate&lt;/e1&gt;) some of its responsibilities to an instance of another type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;委任&lt;/e0&gt;は、クラスまたは構造体にそれのもつ責務の一部を別の型のインスタンスへと手渡す（または&lt;e1&gt;委任する&lt;/e1&gt;）ことを可能にするデザイン・パターンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Designated initializers&lt;/e0&gt; are the primary initializers for a class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;指定イニシャライザ&lt;/e0&gt;は、あるクラスのための主要なイニシャライザです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Error handling&lt;/e0&gt; is the process of responding to and recovering from error conditions in your program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;エラー処理&lt;/e0&gt;は、あなたのプログラムにおいてエラー状態へ応答してそこから復旧する過程です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Extensions&lt;/e0&gt; add new functionality to an existing class, structure, enumeration, or protocol type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;拡張&lt;/e0&gt;は、新しい機能性を既存のクラス、構造体、列挙、またはプロトコル型に加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;File-private access&lt;/e0&gt; restricts the use of an entity to its own defining source file.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;ファイル外非公開アクセス（ファイル私用）&lt;/e0&gt;は、ある実在の使用をそれ自身の定義ソースファイルに制限します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Floating-point literals&lt;/e0&gt; represent floating-point values of unspecified precision.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;浮動小数点リテラル&lt;/e0&gt;は、不特定精度の浮動小数点値を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Floating-point numbers&lt;/e0&gt; are numbers with a fractional component, such as &lt;c1&gt;&lt;s2&gt;3.14159&lt;/s2&gt;&lt;/c1&gt;, &lt;c3&gt;&lt;s4&gt;0.1&lt;/s4&gt;&lt;/c3&gt;, and &lt;c5&gt;&lt;s6&gt;-273.15&lt;/s6&gt;&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;浮動小数点数&lt;/e0&gt;は小数部を持つ数です、例えば&lt;c1&gt;&lt;s2&gt;3.14159&lt;/s2&gt;&lt;/c1&gt;、&lt;c3&gt;&lt;s4&gt;0.1&lt;/s4&gt;&lt;/c3&gt;、そして&lt;c5&gt;&lt;s6&gt;-273.15&lt;/s6&gt;&lt;/c5&gt;など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Functions&lt;/e0&gt; are self-contained chunks of code that perform a specific task.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;関数&lt;/e0&gt;は、特定の作業を実行する完全独立の大きな塊のコードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Generic code&lt;/e0&gt; enables you to write flexible, reusable functions and types that can work with any type, subject to requirements that you define.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;総称体コード&lt;/e0&gt;は、あなたに柔軟な、再使用できる関数と型を書くことを可能にします、それは、あなたが定義する要件を満たした場合に限り、あらゆる型を扱うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Generic functions&lt;/e0&gt; can work with any type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;総称体関数&lt;/e0&gt;は、どんな型でも扱うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Identifiers&lt;/e0&gt; begin with an uppercase or lowercase letter A through Z, an underscore (&lt;c1&gt;&lt;s2&gt;_&lt;/s2&gt;&lt;/c1&gt;), a noncombining alphanumeric Unicode character in the Basic Multilingual Plane, or a character outside the Basic Multilingual Plane that isn’t in a Private Use Area.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;識別子&lt;/e0&gt;は、大文字または小文字のAからZ、アンダースコア（&lt;c1&gt;&lt;s2&gt;_&lt;/s2&gt;&lt;/c1&gt;）、基本多言語面の非合成英数字のUnicode文字、または基本他言語面の外側ての使用領域の中でない文字で始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Initialization&lt;/e0&gt; is the process of preparing an instance of a class, structure, or enumeration for use.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;初期化&lt;/e0&gt;は、クラス、構造体、または列挙のインスタンスを使用するために前準備する処理です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Initializers&lt;/e0&gt; are called to create a new instance of a particular type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;イニシャライザ&lt;/e0&gt;は、特定の型の新しいインスタンスをつくるために呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Instance methods&lt;/e0&gt; are functions that belong to instances of a particular class, structure, or enumeration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;インスタンスメソッド&lt;/e0&gt;は、特定のクラス、構造体、または列挙のインスタンスに属している機能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Integer literals&lt;/e0&gt; represent integer values of unspecified precision.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;整数リテラル&lt;/e0&gt;は、無限精度の整数値を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Integers&lt;/e0&gt; are whole numbers with no fractional component, such as &lt;c1&gt;&lt;s2&gt;42&lt;/s2&gt;&lt;/c1&gt; and &lt;c3&gt;&lt;s4&gt;-23&lt;/s4&gt;&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;整数&lt;/e0&gt;は、小数部分のない数すべてです、例えば&lt;c1&gt;&lt;s2&gt;42&lt;/s2&gt;&lt;/c1&gt;や&lt;c3&gt;&lt;s4&gt;-23&lt;/s4&gt;&lt;/c3&gt;など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Internal access&lt;/e0&gt; enables entities to be used within any source file from their defining module, but not in any source file outside of that module.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;内部アクセス（内部用）&lt;/e0&gt;は、実在たちが、それらの定義モジュールからのあらゆるソースファイル内で使われることを可能にします、しかし、そのモジュールの外側のいかなるソースファイルの中も除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Logical operators&lt;/e0&gt; modify or combine the Boolean logic values &lt;c1&gt;&lt;s2&gt;true&lt;/s2&gt;&lt;/c1&gt; and &lt;c3&gt;&lt;s4&gt;false&lt;/s4&gt;&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;論理演算子&lt;/e0&gt;は、ブールの論理値&lt;c1&gt;&lt;s2&gt;true&lt;/s2&gt;&lt;/c1&gt;および&lt;c3&gt;&lt;s4&gt;false&lt;/s4&gt;&lt;/c3&gt;を修正または結合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Methods&lt;/e0&gt; are functions that are associated with a particular type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;メソッド&lt;/e0&gt;は、特定の型と結び付けられる関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Open access&lt;/e0&gt; and &lt;e1&gt;public access&lt;/e1&gt; enable entities to be used within any source file from their defining module, and also in a source file from another module that imports the defining module.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;開放アクセス&lt;/e0&gt;と&lt;e1&gt;公開アクセス（公開用）&lt;/e1&gt;は、実在たちが、それらの定義モジュールからのあらゆるソースファイル内で、そのうえに、定義モジュールをインポートする別のモジュールからのソースファイルの中で、使われることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Optional chaining&lt;/e0&gt; is a process for querying and calling properties, methods, and subscripts on an optional that might currently be &lt;c1&gt;&lt;s2&gt;nil&lt;/s2&gt;&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;オプショナル連鎖&lt;/e0&gt;は、現時点で&lt;c1&gt;&lt;s2&gt;nil&lt;/s2&gt;&lt;/c1&gt;であるかもしれないオプショナル上での、プロパティ、メソッド、および添え字への問い合わせや呼び出しのための処理です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Postfix expressions&lt;/e0&gt; are formed by applying a postfix operator or other postfix syntax to an expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;接尾辞式&lt;/e0&gt;は、接尾辞演算子または他の接尾辞構文を式に適用することによって作り上げられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Prefix expressions&lt;/e0&gt; combine an optional prefix operator with an expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;接頭辞式&lt;/e0&gt;では、ある任意の接頭辞演算子をひとつの式と組み合わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Primary expressions&lt;/e0&gt; are the most basic kind of expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;基本式&lt;/e0&gt;は、最も基本的な種類の式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Private access&lt;/e0&gt; restricts the use of an entity to the enclosing declaration, and to extensions of that declaration that are in the same file.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;非公開アクセス（私用）&lt;/e0&gt;は、ある実在の使用をそれを囲んでいる宣言に、そしてその宣言の拡張で同じファイル中のものに制限します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Properties&lt;/e0&gt; associate values with a particular class, structure, or enumeration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;プロパティ&lt;/e0&gt;は、いくつかの値を特定のクラス、構造体、または列挙と結びつけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;String interpolation&lt;/e0&gt; is a way to construct a new &lt;c1&gt;&lt;s2&gt;String&lt;/s2&gt;&lt;/c1&gt; value from a mix of constants, variables, literals, and expressions by including their values inside a string literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;文字列補間&lt;/e0&gt;は、定数、変数、リテラル、および式の混合から、それらの値をひとつのリテラル文字列に含めることで、新しい&lt;c1&gt;&lt;s2&gt;String&lt;/s2&gt;&lt;/c1&gt;値を造る方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Structures&lt;/e0&gt; and &lt;e1&gt;classes&lt;/e1&gt; are general-purpose, flexible constructs that become the building blocks of your program’s code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;構造体&lt;/e0&gt;および&lt;e1&gt;クラス&lt;/e1&gt;は、あなたのプログラムのコードの建築ブロックになる、万能で、柔軟な構造物です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Subclassing&lt;/e0&gt; is the act of basing a new class on an existing class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;サブクラスをつくる&lt;/e0&gt;ことは、既存のクラスをもとに新しいクラスを構築する行為です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Ternary&lt;/e0&gt; operators operate on three targets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;三項&lt;/e0&gt;演算子は、３つの目標に作用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Tuples&lt;/e0&gt; group multiple values into a single compound value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;タプル&lt;/e0&gt;は、複数の値を１つの複合値にまとめます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Type aliases&lt;/e0&gt; define an alternative name for an existing type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;型エイリアス&lt;/e0&gt;は、既存の型の代替の名前を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Type casting&lt;/e0&gt; is a way to check the type of an instance, or to treat that instance as a different superclass or subclass from somewhere else in its own class hierarchy.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;型キャスト&lt;/e0&gt;は、あるインスタンスの型を調べるための、またはそのインスタンスを、それ自身のクラス階層中のどこか他の別のスーパークラスやサブクラスとして扱うための方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Unary&lt;/e0&gt; operators operate on a single target (such as &lt;c1&gt;&lt;s2&gt;-a&lt;/s2&gt;&lt;/c1&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;単項&lt;/e0&gt;演算子は、１つだけの目標に作用します（例えば&lt;c1&gt;&lt;s2&gt;-a&lt;/s2&gt;&lt;/c1&gt;など）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e0&gt;Unicode&lt;/e0&gt; is an international standard for encoding, representing, and processing text in different writing systems.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;ユニコード&lt;/e0&gt;は、異なる表記体系のテキストを符号化、表現、そして処理するための国際的な基準です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e6&gt;Identical to&lt;/e6&gt; means that two constants or variables of class type refer to exactly the same class instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e6&gt;同一&lt;/e6&gt;は、クラス型の２つの定数または変数が、正確に同じクラスインスタンスに言及することを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;e7&gt;Equal to&lt;/e7&gt; means that two instances are considered equal or equivalent in value, for some appropriate meaning of &lt;e8&gt;equal&lt;/e8&gt;, as defined by the type’s designer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e7&gt;同等&lt;/e7&gt;は、２つのインスタンスが、値で「等しい」あるいは「相当する」と、ある適切な&lt;e8&gt;等しい&lt;/e8&gt;の意味で、型の設計者によって定義されたとおりに、考慮されることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s1&gt;// Boolean literal&lt;/s1&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s1&gt;（ブールのリテラル）&lt;/s1&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s1&gt;// Floating-point literal&lt;/s1&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s1&gt;（リテラル浮動小数点）&lt;/s1&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s1&gt;// Integer literal&lt;/s1&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s1&gt;（リテラル整数）&lt;/s1&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s1&gt;// String literal&lt;/s1&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s1&gt;（リテラル文字列）&lt;/s1&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s1&gt;// Valid, uses default value&lt;/s1&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s1&gt;（有効、省略時の値を使う）&lt;/s1&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s2&gt;// COMBINING ACUTE ACCENT, U+0301&lt;/s2&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s2&gt;（アキュート・アクセント、U+0301を追加する）&lt;/s2&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s2&gt;// Error: return types don't match&lt;/s2&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s2&gt;（エラー：戻り型は一致しません）&lt;/s2&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s2&gt;// Error&lt;/s2&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s2&gt;（エラー）&lt;/s2&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s2&gt;// Invalid, alwaysThrows() isn't a throwing parameter&lt;/s2&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s2&gt;（無効、alwaysThrows()はスローパラメータではありません）&lt;/s2&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s2&gt;// Invalid, missing argument label&lt;/s2&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s2&gt;（無効、引数ラベルが欠けている）&lt;/s2&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s2&gt;// Invalid, the case has an empty body&lt;/s2&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s2&gt;（無効、このケース節は空の本文を持ちます）&lt;/s2&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s2&gt;// No actual side effects.&lt;/s2&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s2&gt;（実際の副作用なし）&lt;/s2&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s2&gt;// equals "hello, world"&lt;/s2&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s2&gt;（「こんにちは、世界よ」に等しい）&lt;/s2&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s2&gt;// equals -1&lt;/s2&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s2&gt;（-１に等しい）&lt;/s2&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s2&gt;// equals 1&lt;/s2&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s2&gt;（１に等しい）&lt;/s2&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s2&gt;// equals 2&lt;/s2&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s2&gt;（２に等しい）&lt;/s2&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s2&gt;// equals 3&lt;/s2&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s2&gt;（３に等しい）&lt;/s2&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s2&gt;// equals 4.0&lt;/s2&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s2&gt;（4.0に等しい）&lt;/s2&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s2&gt;// equals 6&lt;/s2&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s2&gt;（６に等しい）&lt;/s2&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s2&gt;// false because 2 is not less than or equal to 1&lt;/s2&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s2&gt;（２が１以下でないので偽）&lt;/s2&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s2&gt;// implicitly file-private class member&lt;/s2&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s2&gt;（暗黙的にファイル外非公開のクラス・メンバー）&lt;/s2&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s2&gt;// implicitly internal class&lt;/s2&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s2&gt;（暗黙的に内部のクラス）&lt;/s2&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s2&gt;// implicitly internal&lt;/s2&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s2&gt;（暗黙的に内部です）&lt;/s2&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s2&gt;// implicitly private class member&lt;/s2&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s2&gt;（暗黙のうちに非公開のクラス・メンバー）&lt;/s2&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s2&gt;// true because 1 is equal to 1&lt;/s2&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s2&gt;（１が1と同等なので真）&lt;/s2&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s2&gt;// true because 1 is greater than or equal to 1&lt;/s2&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s2&gt;（１が１以上なので真）&lt;/s2&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s2&gt;// true because 1 is less than 2&lt;/s2&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s2&gt;（１が２より小さいので真）&lt;/s2&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s2&gt;// true because 2 is greater than 1&lt;/s2&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s2&gt;（２が１より大きいので真）&lt;/s2&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s2&gt;// true because 2 is not equal to 1&lt;/s2&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s2&gt;（２が１と同等でないので真）&lt;/s2&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s3&gt;// 17 in binary notation&lt;/s3&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s3&gt;（２進法での17）&lt;/s3&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s3&gt;// 17 in hexadecimal notation&lt;/s3&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s3&gt;（16進法での17）&lt;/s3&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s3&gt;// 17 in octal notation&lt;/s3&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s3&gt;（８進法での17）&lt;/s3&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s3&gt;// OK: names are inferred&lt;/s3&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s3&gt;（OK: 名前は推論されます）&lt;/s3&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s3&gt;// T is inferred to be Double&lt;/s3&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s3&gt;（TはDoubleであると推論されます）&lt;/s3&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s3&gt;// T is inferred to be Int&lt;/s3&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s3&gt;（Tは、Intであると推論されます）&lt;/s3&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s3&gt;// The type of e is inferred to be Double.&lt;/s3&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s3&gt;（eの型は、Doubleであると推測されます。&lt;/s3&gt;）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s3&gt;// The type of f is (Int, Int) -&gt; Void, not (left: Int, right: Int) -&gt; Void.&lt;/s3&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s3&gt;（ f の型は (Int, Int) -&gt; Void です、 (left: Int, right: Int) -&gt; Void ではなく）&lt;/s3&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s3&gt;// Valid, uses the value provided&lt;/s3&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s3&gt;（有効、提供された値を使う）&lt;/s3&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s3&gt;// Warning&lt;/s3&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s3&gt;（警告）&lt;/s3&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s3&gt;// alsoMinusSix equals -6&lt;/s3&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s3&gt;（alsoMinusSixは、-6に等しい）&lt;/s3&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s3&gt;// empty string literal&lt;/s3&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s3&gt;（空の文字列リテラル）&lt;/s3&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s3&gt;// equals 11110000&lt;/s3&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s3&gt;（11110000に等しい）&lt;/s3&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s3&gt;// explicitly file-private class member&lt;/s3&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s3&gt;（明示的にファイル外非公開のクラス・メンバー）&lt;/s3&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s3&gt;// explicitly file-private class&lt;/s3&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s3&gt;（明示的にファイル外非公開のクラス）&lt;/s3&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s3&gt;// explicitly private class member&lt;/s3&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s3&gt;（明示的に非公開のクラス・メンバー）&lt;/s3&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s3&gt;// explicitly private class&lt;/s3&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s3&gt;（明示的に非公開のクラス）&lt;/s3&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s3&gt;// explicitly public class&lt;/s3&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s3&gt;（明示的に公開のクラス）&lt;/s3&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s3&gt;// implicitly internal class member&lt;/s3&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s3&gt;（暗黙的に内部のクラス・メンバー）&lt;/s3&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s3&gt;// implicitly internal&lt;/s3&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s3&gt;（暗黙的に内部です）&lt;/s3&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s3&gt;// initializer syntax&lt;/s3&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s3&gt;（イニシャライザ構文）&lt;/s3&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s3&gt;// minusThree equals -3&lt;/s3&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s3&gt;（minusThreeは、-3に等しい）&lt;/s3&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s3&gt;// plusThree equals 3, or "minus minus three"&lt;/s3&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s3&gt;（plusThreeは、3に、または「マイナス マイナス three」に等しい）&lt;/s3&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s4&gt;//  count is labeled, greeting is not&lt;/s4&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s4&gt;（countはラベルを付けられます、greetingは違います）&lt;/s4&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s4&gt;// 00000100 in binary&lt;/s4&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s4&gt;（２進数での00000100）&lt;/s4&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s4&gt;// Ambiguous&lt;/s4&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s4&gt;（あいまい）&lt;/s4&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s4&gt;// Chinese symbol for the number 3&lt;/s4&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s4&gt;（数３に対する中国語記号）&lt;/s4&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s4&gt;// Error because &lt; can't compare Boolean values&lt;/s4&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s4&gt;（エラー、なぜなら &lt; がブール値を比較できないため）&lt;/s4&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s4&gt;// Error: return types don't match&lt;/s4&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s4&gt;（エラー：戻り型は一致しません）&lt;/s4&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s4&gt;// Error: try applies only to the first function call&lt;/s4&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s4&gt;（エラー：tryは、最初の関数呼び出しだけに適用されます）&lt;/s4&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s4&gt;// OK, evaluates to true&lt;/s4&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s4&gt;（OK、trueと評価します）&lt;/s4&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s4&gt;// The type of eFloat is Float.&lt;/s4&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s4&gt;（eFloatの型はFloatです。）&lt;/s4&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s4&gt;// blueComponent is 0x99, or 153&lt;/s4&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s4&gt;（blueComponent は 0x99 または 153 です）&lt;/s4&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s4&gt;// e followed by ́&lt;/s4&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s4&gt;// e に続けて ́&lt;/s4&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s4&gt;// equals 00010001&lt;/s4&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s4&gt;（00010001に等しい）&lt;/s4&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s4&gt;// equals 00111100&lt;/s4&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s4&gt;（00111100に等しい）&lt;/s4&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s4&gt;// equals 11111110&lt;/s4&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s4&gt;（11111110に等しい）&lt;/s4&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s4&gt;// explicitly public class member&lt;/s4&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s4&gt;（明示的に公開のクラス・メンバー）&lt;/s4&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s4&gt;// maxValue is equal to 255, and is of type UInt8&lt;/s4&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s4&gt;（maxValuesは255に等しく、そしてUInt8型です）&lt;/s4&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s4&gt;// minValue is equal to 0, and is of type UInt8&lt;/s4&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s4&gt;（minValuesは0に等しく、そしてUInt8型です）&lt;/s4&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s4&gt;// no need for an exclamation point&lt;/s4&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s1&gt;（感嘆符の必要はありません）&lt;/s1&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s4&gt;// requires an exclamation point&lt;/s4&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s1&gt;（感嘆符が要求されます）&lt;/s1&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s4&gt;// true because 1 is less than 2; "zebra" and "apple" are not compared&lt;/s4&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s4&gt;// １は２より少ないので真；「zebra」と「apple」は比較されません&lt;/s4&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s4&gt;// true because 3 is equal to 3, and "apple" is less than "bird"&lt;/s4&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s4&gt;（３は３と等しく、「apple」は「bird」より少ないので真）&lt;/s4&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s4&gt;// true because 4 is equal to 4, and "dog" is equal to "dog"&lt;/s4&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s4&gt;（４は４と等しく、「dog」は「dog」と等しいので真）&lt;/s4&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s4&gt;// try applies to both function calls&lt;/s4&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s4&gt;（tryは、両方の関数呼び出しに適用されます）&lt;/s4&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s5&gt;// Error: names don't match&lt;/s5&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s5&gt;（エラー: 名前が一致しない）&lt;/s5&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s5&gt;// No warning&lt;/s5&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s5&gt;（警告なし）&lt;/s5&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s5&gt;// OK: names match&lt;/s5&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s5&gt;（OK: 名前が一致）&lt;/s5&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s5&gt;// both x and y are labeled&lt;/s5&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s5&gt;（xとyの両方ともラベルをつけられます）&lt;/s5&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s5&gt;// greenComponent is 0x66, or 102&lt;/s5&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s5&gt;（greenComponent は 0x66 または 102 です）&lt;/s5&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s5&gt;// redComponent is 0xCC, or 204&lt;/s5&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s5&gt;（redComponent は 0xCC または 204 です）&lt;/s5&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s6&gt;// Still ambiguous&lt;/s6&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s6&gt;（依然あいまい）&lt;/s6&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s6&gt;// Unambiguous&lt;/s6&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s6&gt;（あいまいさ無し）&lt;/s6&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s6&gt;// someTuple is of type (top: Int, bottom: Int)&lt;/s6&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s6&gt;（someTupleは型 (top: Int, bottom: Int) です）&lt;/s6&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s7&gt;// unowned capture&lt;/s7&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s7&gt;（非所有キャプチャ）&lt;/s7&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s7&gt;// weak capture&lt;/s7&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;s7&gt;（弱いキャプチャ）&lt;/s7&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;break&lt;/s1&gt;&lt;/c0&gt; statement ends program execution of a loop, an &lt;c2&gt;&lt;s3&gt;if&lt;/s3&gt;&lt;/c2&gt; statement, or a &lt;c4&gt;&lt;s5&gt;switch&lt;/s5&gt;&lt;/c4&gt; statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;break&lt;/s1&gt;&lt;/c0&gt;文は、ループ、&lt;c2&gt;&lt;s3&gt;if&lt;/s3&gt;&lt;/c2&gt;文、または&lt;c4&gt;&lt;s5&gt;switch&lt;/s5&gt;&lt;/c4&gt;文のプログラム実行を終えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;continue&lt;/s1&gt;&lt;/c0&gt; statement ends program execution of the current iteration of a loop statement but does not stop execution of the loop statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;continue&lt;/s1&gt;&lt;/c0&gt;文は、ループ文の現在の繰り返しのプログラム実行を終了しますが、ループ文の実行は止めません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;defer&lt;/s1&gt;&lt;/c0&gt; statement defers execution until the current scope is exited.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;defer&lt;/s1&gt;&lt;/c0&gt;文は、現在のスコープが終了されるまで実行を延期します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;defer&lt;/s1&gt;&lt;/c0&gt; statement has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;defer&lt;/s1&gt;&lt;/c0&gt;文は以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;defer&lt;/s1&gt;&lt;/c0&gt; statement is used for executing code just before transferring program control outside of the scope that the &lt;c2&gt;&lt;s3&gt;defer&lt;/s3&gt;&lt;/c2&gt; statement appears in.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;defer&lt;/s1&gt;&lt;/c0&gt;文は、&lt;c2&gt;&lt;s3&gt;defer&lt;/s3&gt;&lt;/c2&gt;文が現れるスコープの外側にプログラムの制御を移す直前でのコード実行のために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;do&lt;/s1&gt;&lt;/c0&gt; statement creates a new containing scope, which allows errors to be propagated to one or more &lt;c2&gt;&lt;s3&gt;catch&lt;/s3&gt;&lt;/c2&gt; clauses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;do&lt;/s1&gt;&lt;/c0&gt;文はひとつの新しく取り囲んでいるスコープを作成します、それはエラーに１つ以上の&lt;c2&gt;&lt;s3&gt;catch&lt;/s3&gt;&lt;/c2&gt;節に伝えられることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;do&lt;/s1&gt;&lt;/c0&gt; statement has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;do&lt;/s1&gt;&lt;/c0&gt;文は以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;do&lt;/s1&gt;&lt;/c0&gt; statement in Swift is similar to curly braces (&lt;c2&gt;&lt;s3&gt;{}&lt;/s3&gt;&lt;/c2&gt;) in C used to delimit a code block, and does not incur a performance cost at runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの&lt;c0&gt;&lt;s1&gt;do&lt;/s1&gt;&lt;/c0&gt;文は、Cにおいてひとつのコードのブロックの境界を定めるために使われる波括弧（&lt;c2&gt;&lt;s3&gt;{}&lt;/s3&gt;&lt;/c2&gt;）に似ていて、実行時に性能上の損失を被りません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;fallthrough&lt;/s1&gt;&lt;/c0&gt; statement can appear anywhere inside a &lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt; statement, not just as the last statement of a case block, but it can’t be used in the final case block.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;fallthrough&lt;/s1&gt;&lt;/c0&gt;文は、&lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt;文のどこにでも現れることができます、あるケース節ブロックの最後の文としてだけではなく、しかしそれは最後のケース節ブロックにおいては使われることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;fallthrough&lt;/s1&gt;&lt;/c0&gt; statement consists of the &lt;c2&gt;&lt;s3&gt;fallthrough&lt;/s3&gt;&lt;/c2&gt; keyword and occurs only in a case block of a &lt;c4&gt;&lt;s5&gt;switch&lt;/s5&gt;&lt;/c4&gt; statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;fallthrough&lt;/s1&gt;&lt;/c0&gt;文は、&lt;c2&gt;&lt;s3&gt;fallthrough&lt;/s3&gt;&lt;/c2&gt;キーワードから成って、&lt;c4&gt;&lt;s5&gt;switch&lt;/s5&gt;&lt;/c4&gt;文のケース節ブロックだけに現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt; statement allows a block of code to be executed once for each item in a collection (or any type) that conforms to the &lt;a4&gt;&lt;c5&gt;&lt;s6&gt;Sequence&lt;/s6&gt;&lt;/c5&gt;&lt;/a4&gt;&lt;s7&gt; [https://developer.apple.com/documentation/swift/sequence]&lt;/s7&gt; protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt;文は、コードの１ブロックを&lt;a4&gt;&lt;c5&gt;&lt;s6&gt;Sequence&lt;/s6&gt;&lt;/c5&gt;&lt;/a4&gt;&lt;s7&gt; [https://developer.apple.com/documentation/swift/sequence]&lt;/s7&gt;プロトコルに準拠するあるコレクション（または何らかの型）の中のそれぞれの項目に対して一度だけ実行されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt; statement has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt;文は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;guard&lt;/s1&gt;&lt;/c0&gt; statement has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;guard&lt;/s1&gt;&lt;/c0&gt;文は以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;guard&lt;/s1&gt;&lt;/c0&gt; statement is used to transfer program control out of a scope if one or more conditions aren’t met.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;guard&lt;/s1&gt;&lt;/c0&gt;文は、１つ以上の条件が満たされないならば、プログラムの制御をあるスコープの外に転移させるために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;guard&lt;/s1&gt;&lt;/c0&gt; statement, like an &lt;c2&gt;&lt;s3&gt;if&lt;/s3&gt;&lt;/c2&gt; statement, executes statements depending on the Boolean value of an expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;guard&lt;/s1&gt;&lt;/c0&gt;文は、&lt;c2&gt;&lt;s3&gt;if&lt;/s3&gt;&lt;/c2&gt;文と同じく、ある式のブール値に基づいて他の文を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;repeat&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;while&lt;/s3&gt;&lt;/c2&gt; statement allows a block of code to be executed one or more times, as long as a condition remains true.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;repeat&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;while&lt;/s3&gt;&lt;/c2&gt;文は、ある条件が真のままである限り、ひとかたまりのコードを一回以上実行されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;repeat&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;while&lt;/s3&gt;&lt;/c2&gt; statement has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;repeat&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;while&lt;/s3&gt;&lt;/c2&gt;文は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;repeat&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;while&lt;/s3&gt;&lt;/c2&gt; statement is executed as follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;repeat&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;while&lt;/s3&gt;&lt;/c2&gt;文は、次のように実行されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;return&lt;/s1&gt;&lt;/c0&gt; statement can consist of only the &lt;c2&gt;&lt;s3&gt;return&lt;/s3&gt;&lt;/c2&gt; keyword, or it can consist of the &lt;c4&gt;&lt;s5&gt;return&lt;/s5&gt;&lt;/c4&gt; keyword followed by an expression, as shown below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;return&lt;/s1&gt;&lt;/c0&gt;文はキーワード&lt;c2&gt;&lt;s3&gt;return&lt;/s3&gt;&lt;/c2&gt;だけから成ることができます、あるいはそれは、以下に示すように、キーワード&lt;c4&gt;&lt;s5&gt;return&lt;/s5&gt;&lt;/c4&gt;とそれに続く式から成ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;return&lt;/s1&gt;&lt;/c0&gt; statement occurs in the body of a function or method definition and causes program execution to return to the calling function or method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;return&lt;/s1&gt;&lt;/c0&gt;文は、関数またはメソッド定義の本文に現れて、プログラム実行を関数またはメソッド呼んでいるところに戻るようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; case can name the value or values it matches to temporary constants or variables, for use in the body of the case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;ケース節は、それがマッチする値または複数の値に名前を付けて一時的な定数や変数に束縛することが、そのケース節の本文で使うために行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; case can optionally contain a &lt;c2&gt;&lt;s3&gt;where&lt;/s3&gt;&lt;/c2&gt; clause after each pattern.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;ケース節は、各パターンの後に随意に&lt;c2&gt;&lt;s3&gt;where&lt;/s3&gt;&lt;/c2&gt;節を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; case can use a &lt;c2&gt;&lt;s3&gt;where&lt;/s3&gt;&lt;/c2&gt; clause to check for additional conditions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;ケース節は、&lt;c2&gt;&lt;s3&gt;where&lt;/s3&gt;&lt;/c2&gt;節を、追加の条件で調べるために使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; case that contains only a comment is reported as a compile-time error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>１つのコメントだけを含む&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;ケース節は、コンパイル時エラーとして報告されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; statement allows certain blocks of code to be executed depending on the value of a control expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;文は、コードの特定のブロックをある制御式の値に従って実行されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; statement can also include a default case, introduced by the &lt;c2&gt;&lt;s3&gt;default&lt;/s3&gt;&lt;/c2&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;文はまた、キーワード&lt;c2&gt;&lt;s3&gt;default&lt;/s3&gt;&lt;/c2&gt;によって導入される、省略時のケース節を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; statement considers a value and compares it against several possible matching patterns.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;文は、ある値について考察して、それをいくつかの候補のマッチングパターンと比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; statement has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;文は以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;throw&lt;/s1&gt;&lt;/c0&gt; statement causes a program to end execution of the current scope and begin error propagation to its enclosing scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;throw&lt;/s1&gt;&lt;/c0&gt;文は、プログラムに現在のスコープの実行を終了させます、そしてそれを囲んでいるスコープにエラーの伝達を始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;throw&lt;/s1&gt;&lt;/c0&gt; statement consists of the &lt;c2&gt;&lt;s3&gt;throw&lt;/s3&gt;&lt;/c2&gt; keyword followed by an expression, as shown below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;throw&lt;/s1&gt;&lt;/c0&gt;文は、以下のように、&lt;c2&gt;&lt;s3&gt;throw&lt;/s3&gt;&lt;/c2&gt;キーワードとそれに続くひとつの式から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;throw&lt;/s1&gt;&lt;/c0&gt; statement occurs in the body of a throwing function or method, or in the body of a closure expression whose type is marked with the &lt;c2&gt;&lt;s3&gt;throws&lt;/s3&gt;&lt;/c2&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;throw&lt;/s1&gt;&lt;/c0&gt;文はスロー関数やメソッドの本文中に、または&lt;c2&gt;&lt;s3&gt;throws&lt;/s3&gt;&lt;/c2&gt;キーワードで印される型のクロージャ式の中に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;try&lt;/s1&gt;&lt;/c0&gt; expression can’t appear on the right-hand side of a binary operator, unless the binary operator is the assignment operator or the &lt;c2&gt;&lt;s3&gt;try&lt;/s3&gt;&lt;/c2&gt; expression is enclosed in parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;try&lt;/s1&gt;&lt;/c0&gt;式が二項演算子の右手側に現れることは、その二項演算子が代入演算子であるか&lt;c2&gt;&lt;s3&gt;try&lt;/s3&gt;&lt;/c2&gt;式が丸括弧の中に入れられるかしない限りはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;while&lt;/s1&gt;&lt;/c0&gt; loop is appropriate in this case, because the length of the game is not clear at the start of the &lt;c2&gt;&lt;s3&gt;while&lt;/s3&gt;&lt;/c2&gt; loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;while&lt;/s1&gt;&lt;/c0&gt;ループはこの場合に適切なものです、なぜならゲームの長さは&lt;c2&gt;&lt;s3&gt;while&lt;/s3&gt;&lt;/c2&gt;ループの開始時点ではっきりしないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;while&lt;/s1&gt;&lt;/c0&gt; loop performs a set of statements until a condition becomes &lt;c2&gt;&lt;s3&gt;false&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;while&lt;/s1&gt;&lt;/c0&gt;ループは、ひとまとめにした文を、ある条件が&lt;c2&gt;&lt;s3&gt;false&lt;/s3&gt;&lt;/c2&gt;になるまで実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;while&lt;/s1&gt;&lt;/c0&gt; loop starts by evaluating a single condition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;while&lt;/s1&gt;&lt;/c0&gt;ループは、１つだけ条件を評価することによって始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;while&lt;/s1&gt;&lt;/c0&gt; statement allows a block of code to be executed repeatedly, as long as a condition remains true.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;while&lt;/s1&gt;&lt;/c0&gt;文は、条件が真のままである限り、コードの１ブロックを繰り返して実行されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;while&lt;/s1&gt;&lt;/c0&gt; statement has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;while&lt;/s1&gt;&lt;/c0&gt;文は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;while&lt;/s1&gt;&lt;/c0&gt; statement is executed as follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;while&lt;/s1&gt;&lt;/c0&gt;文は、次のように実行されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c0&gt;&lt;s1&gt;willSet&lt;/s1&gt;&lt;/c0&gt; observer is called just before the value of the variable or property is set.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;willSet&lt;/s1&gt;&lt;/c0&gt;オブザーバーは、変数またはプロパティの値が設定される直前に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c2&gt;&lt;s3&gt;continue&lt;/s3&gt;&lt;/c2&gt; statement can consist of only the &lt;c4&gt;&lt;s5&gt;continue&lt;/s5&gt;&lt;/c4&gt; keyword, or it can consist of the &lt;c6&gt;&lt;s7&gt;continue&lt;/s7&gt;&lt;/c6&gt; keyword followed by the name of a statement label, as shown below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;continue&lt;/s3&gt;&lt;/c2&gt;文は、以下に示すように、キーワード&lt;c4&gt;&lt;s5&gt;continue&lt;/s5&gt;&lt;/c4&gt;だけから成ることができます、また、それはキーワード&lt;c6&gt;&lt;s7&gt;continue&lt;/s7&gt;&lt;/c6&gt;とそれに続く文ラベルから成ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt; statement provides an alternative to the &lt;c4&gt;&lt;s5&gt;if&lt;/s5&gt;&lt;/c4&gt; statement for responding to multiple potential states.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt;文は、複数の起こりうる状況に応答するために&lt;c4&gt;&lt;s5&gt;if&lt;/s5&gt;&lt;/c4&gt;文に代わるものを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c4&gt;&lt;s5&gt;switch&lt;/s5&gt;&lt;/c4&gt; statement can include only one default case, which must appear at the end of the &lt;c6&gt;&lt;s7&gt;switch&lt;/s7&gt;&lt;/c6&gt; statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;switch&lt;/s5&gt;&lt;/c4&gt;文は１つの省略時のケース節だけを含むことができます、それは、&lt;c6&gt;&lt;s7&gt;switch&lt;/s7&gt;&lt;/c6&gt;文の終わりに現れなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c6&gt;&lt;s7&gt;break&lt;/s7&gt;&lt;/c6&gt; statement can consist of only the &lt;c8&gt;&lt;s9&gt;break&lt;/s9&gt;&lt;/c8&gt; keyword, or it can consist of the &lt;c10&gt;&lt;s11&gt;break&lt;/s11&gt;&lt;/c10&gt; keyword followed by the name of a statement label, as shown below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;break&lt;/s7&gt;&lt;/c6&gt;文はキーワード&lt;c8&gt;&lt;s9&gt;break&lt;/s9&gt;&lt;/c8&gt;だけから成ることができます、あるいは、それは、以下に示すように、キーワード&lt;c10&gt;&lt;s11&gt;break&lt;/s11&gt;&lt;/c10&gt;とそれに続く文ラベルの名前から成ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c6&gt;&lt;s7&gt;fallthrough&lt;/s7&gt;&lt;/c6&gt; statement causes program execution to continue from one case in a &lt;c8&gt;&lt;s9&gt;switch&lt;/s9&gt;&lt;/c8&gt; statement to the next case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;fallthrough&lt;/s7&gt;&lt;/c6&gt;文によって、プログラム実行が&lt;c8&gt;&lt;s9&gt;switch&lt;/s9&gt;&lt;/c8&gt;文の１つのケース節から次のケース節に続くようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;c9&gt;&lt;s10&gt;CreditCard&lt;/s10&gt;&lt;/c9&gt; instance never outlives the &lt;c11&gt;&lt;s12&gt;Customer&lt;/s12&gt;&lt;/c11&gt; that it refers to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c9&gt;&lt;s10&gt;CreditCard&lt;/s10&gt;&lt;/c9&gt;インスタンスは、それが参照する&lt;c11&gt;&lt;s12&gt;Customer&lt;/s12&gt;&lt;/c11&gt;より決して長生きしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;binary&lt;/e0&gt; number, with a &lt;c1&gt;&lt;s2&gt;0b&lt;/s2&gt;&lt;/c1&gt; prefix</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;２進&lt;/e0&gt;数は、接頭辞&lt;c1&gt;&lt;s2&gt;0b&lt;/s2&gt;&lt;/c1&gt;つきで</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;class declaration&lt;/e0&gt; introduces a named class type into your program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;クラス宣言&lt;/e0&gt;は、名前をつけられたクラス型をあなたのプログラムに導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;closure expression&lt;/e0&gt; creates a closure, also known as a &lt;e1&gt;lambda&lt;/e1&gt; or an &lt;e2&gt;anonymous function&lt;/e2&gt; in other programming languages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;クロージャ式&lt;/e0&gt;はクロージャ、他のプログラミング言語ではまた&lt;e1&gt;lambda&lt;/e1&gt;または&lt;e2&gt;匿名関数&lt;/e2&gt;として知られるものをつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;code block&lt;/e0&gt; is used by a variety of declarations and control structures to group statements together.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;コード・ブロック&lt;/e0&gt;は、いくつかの文をまとめるために、いろいろな宣言や制御構造で使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;compound type&lt;/e0&gt; is a type without a name, defined in the Swift language itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;複合の型&lt;/e0&gt;は名前のない型です、そしてスウィフト言語自身によって定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;constant declaration&lt;/e0&gt; introduces a constant named value into your program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;定数宣言&lt;/e0&gt;は、名前をつけられた一定不変の値をあなたのプログラムにもたらします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;decimal&lt;/e0&gt; number, with no prefix</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;10進&lt;/e0&gt;数は、接頭辞なしで</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;declaration&lt;/e0&gt; introduces a new name or construct into your program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;宣言&lt;/e0&gt;は、新しい名前または構造物をあなたのプログラムに導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;deinitializer declaration&lt;/e0&gt; declares a deinitializer for a class type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;デイニシャライザ宣言&lt;/e0&gt;は、クラス型のためにデイニシャライザを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;deinitializer&lt;/e0&gt; is called immediately before a class instance is deallocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;デイニシャライザ&lt;/e0&gt;は、クラスインスタンスが割り当て解除される直前に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;dictionary literal&lt;/e0&gt; is an unordered collection of key-value pairs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;辞書リテラル&lt;/e0&gt;は、「キーと値」の対の順序付けされないコレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;dictionary&lt;/e0&gt; stores associations between keys of the same type and values of the same type in a collection with no defined ordering.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;辞書は&lt;/e0&gt;、同じ型のキーと同じ型の値との間の関連性をあるコレクションの中に順序を定義しないでしまっておきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;failable initializer&lt;/e0&gt; is a type of initializer that produces an optional instance or an implicitly unwrapped optional instance of the type the initializer is declared on.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;失敗できるイニシャライザ&lt;/e0&gt;は、イニシャライザの一種で、そのイニシャライザが宣言されている型の、オプショナルのインスタンスまたは暗黙的にアンラップされるオプショナルのインスタンスを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;forced-try expression&lt;/e0&gt; consists of the &lt;c1&gt;&lt;s2&gt;try!&lt;/s2&gt;&lt;/c1&gt; operator followed by an expression that can throw an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;強制try式&lt;/e0&gt;は、&lt;c1&gt;&lt;s2&gt;try!&lt;/s2&gt;&lt;/c1&gt;演算子と後につづくエラーをスローできる１つの式から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;forced-value expression&lt;/e0&gt; unwraps an optional value that you are certain is not &lt;c1&gt;&lt;s2&gt;nil&lt;/s2&gt;&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;強制された値式&lt;/e0&gt;は、あなたが&lt;c1&gt;&lt;s2&gt;nilで&lt;/s2&gt;&lt;/c1&gt;ないことを確信しているオプショナルの値をアンラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;function call expression&lt;/e0&gt; consists of a function name followed by a comma-separated list of the function’s arguments in parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;関数呼び出し式&lt;/e0&gt;は、関数名の後にその関数の引数のコンマ区切りのリストを丸括弧の中に続けることから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;function declaration&lt;/e0&gt; introduces a function or method into your program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;関数宣言&lt;/e0&gt;は、あなたのプログラムに関数またはメソッドをもたらします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;function type&lt;/e0&gt; represents the type of a function, method, or closure and consists of a parameter and return type separated by an arrow (&lt;c1&gt;&lt;s2&gt;-&gt;&lt;/s2&gt;&lt;/c1&gt;):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;関数型&lt;/e0&gt;は、ある関数、メソッド、またはクロージャの型を表して、矢印（&lt;c1&gt;&lt;s2&gt;-&gt;&lt;/s2&gt;&lt;/c1&gt;）で区切られたパラメータと戻り型から成ります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;generic argument clause&lt;/e0&gt; specifies the type arguments of a generic type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;総称体引数節&lt;/e0&gt;は、総称体型の型引数を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;generic parameter clause&lt;/e0&gt; specifies the type parameters of a generic type or function, along with any associated constraints and requirements on those parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;総称体パラメータ節&lt;/e0&gt;は、総称体の型や関数の型パラメータを、それらのパラメータに関するあらゆる付随する制約と要件と一緒に指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;hexadecimal&lt;/e0&gt; number, with a &lt;c1&gt;&lt;s2&gt;0x&lt;/s2&gt;&lt;/c1&gt; prefix</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;16進&lt;/e0&gt;数は、接頭辞&lt;c1&gt;&lt;s2&gt;0x&lt;/s2&gt;&lt;/c1&gt;つきで</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;key-path expression&lt;/e0&gt; refers to a property or subscript of a type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;キーパス式&lt;/e0&gt;は、ある型のプロパティまたは添え字を参照します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;key-value pair&lt;/e0&gt; is a combination of a key and a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;「キーと値」&lt;/e0&gt;の対は、ひとつのキーとひとつの値の組合せです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;lazy stored property&lt;/e0&gt; is a property whose initial value is not calculated until the first time it is used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;遅延格納プロパティ&lt;/e0&gt;は、初めてそれが使われるまで、初期値が計算されないプロパティです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;literal expression&lt;/e0&gt; consists of either an ordinary literal (such as a string or a number), an array or dictionary literal, a playground literal, or one of the following special literals:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;リテラル式&lt;/e0&gt;は、普通のリテラル（例えば、ある文字列または数）、配列または辞書リテラル、プレイグラウンドリテラル、または以下の特別なリテラルのうちの１つから成ります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;literal&lt;/e0&gt; is the source code representation of a value of a type, such as a number or string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;リテラル&lt;/e0&gt;は、ある型のある値をソースコードに表わしたものです、例えばある数や文字列など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;metatype type&lt;/e0&gt; refers to the type of any type, including class types, structure types, enumeration types, and protocol types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある&lt;e0&gt;メタタイプ型&lt;/e0&gt;は、クラス型、構造体型、列挙型、そしてプロトコル型を含む、何らかの型のその型に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;module&lt;/e0&gt; is a single unit of code distribution—a framework or application that is built and shipped as a single unit and that can be imported by another module with Swift’s &lt;c1&gt;&lt;s2&gt;import&lt;/s2&gt;&lt;/c1&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;モジュール&lt;/e0&gt;は、コード分類の１つの単位 ― フレームワークまたはアプリケーションです、それは、単一の構成単位として構築され出荷されて、スウィフトのimportキーワードを使って別のモジュールによって&lt;c1&gt;&lt;s2&gt;インポート&lt;/s2&gt;&lt;/c1&gt;されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;named type&lt;/e0&gt; is a type that can be given a particular name when it’s defined.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;名前付きの型&lt;/e0&gt;は、それが定義される時に特定の名前を与えられることができる型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;nonfrozen enumeration&lt;/e0&gt; is a special kind of enumeration that may gain new enumeration cases in the future—even after you compile and ship an app.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;非凍結列挙&lt;/e0&gt;は特別な種類の列挙です、それは新しい列挙ケース節を将来に — あなたがアプリをコンパイルおよび出荷する後でさえ、手に入れるかもしれないものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;parenthesized expression&lt;/e0&gt; consists of an expression surrounded by parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;括弧に入れられた式&lt;/e0&gt;は、丸括弧で囲まれたある式から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;pattern&lt;/e0&gt; represents the structure of a single value or a composite value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある&lt;e0&gt;パターン&lt;/e0&gt;は、ある単一の値または複合の値の構造を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;playground literal&lt;/e0&gt; is used by Xcode to create an interactive representation of a color, file, or image within the program editor.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;プレイグラウンドリテラル&lt;/e0&gt;は、Xcodeによって使われて、プログラムエディタ内でいろ、ファイル、または画像の双方向の表現を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;postfix operator&lt;/e0&gt; is a unary operator that is written immediately after its operand, such as the postfix forced-unwrap operator (&lt;c1&gt;&lt;s2&gt;!&lt;/s2&gt;&lt;/c1&gt;) in the expression &lt;c3&gt;&lt;s4&gt;a!&lt;/s4&gt;&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;接尾辞演算子&lt;/e0&gt;は単項演算子です、それはその演算数の直後に書かれます、例えば式&lt;c3&gt;&lt;s4&gt;a!&lt;/s4&gt;&lt;/c3&gt;での論理否定演算子（&lt;c1&gt;&lt;s2&gt;!&lt;/s2&gt;&lt;/c1&gt;）など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;precedence group declaration&lt;/e0&gt; introduces a new grouping for infix operator precedence into your program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;優先順位グループ&lt;/e0&gt;は、接中辞演算子優先順位に対する新しいグループをあなたのプログラムへ導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;prefix operator&lt;/e0&gt; is a unary operator that is written immediately before its operand, such as the prefix logical NOT operator (&lt;c1&gt;&lt;s2&gt;!&lt;/s2&gt;&lt;/c1&gt;) in the expression &lt;c3&gt;&lt;s4&gt;!a&lt;/s4&gt;&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;接頭辞演算子&lt;/e0&gt;は単項演算子です、それはその演算数の直前に書かれます、例えば式&lt;c3&gt;&lt;s4&gt;!a&lt;/s4&gt;&lt;/c3&gt;での論理否定演算子（&lt;c1&gt;&lt;s2&gt;!&lt;/s2&gt;&lt;/c1&gt;）など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;protocol composition type&lt;/e0&gt; defines a type that conforms to each protocol in a list of specified protocols, or a type that is a subclass of a given class and conforms to each protocol in a list of specified protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;プロトコル合成型&lt;/e0&gt;が定義するのは、指定されたプロトコルのリストの中の各プロトコルに準拠する型、または指定されたクラスのサブクラスであるそして指定されたプロトコルのリストの中の各プロトコルに準拠する型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;protocol declaration&lt;/e0&gt; introduces a named protocol type into your program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;プロトコル宣言&lt;/e0&gt;は、名前をつけられたプロトコル型をあなたのプログラムに導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;protocol&lt;/e0&gt; defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある&lt;e0&gt;プロトコル&lt;/e0&gt;（規約）は、メソッド、プロパティ、そして他の要件からなるひとつの青写真を定義します、それは、ある特定の作業またはある機能性断片にふさわしくするものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;recursive enumeration&lt;/e0&gt; is an enumeration that has another instance of the enumeration as the associated value for one or more of the enumeration cases.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;再帰列挙&lt;/e0&gt;は、１つ以上の列挙ケース節のための関連値としてその列挙の別のインスタンスを持つ列挙です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;set&lt;/e0&gt; stores distinct values of the same type in a collection with no defined ordering.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;集合&lt;/e0&gt;は、同じ型の異なった値をひとつのコレクションの中に決まった順序なしで格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;source file&lt;/e0&gt; is a single Swift source code file within a module (in effect, a single file within an app or framework).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;ソースファイル&lt;/e0&gt;は、あるモジュール内の単一のスウィフトソースコード・ファイルです（実質的には、アプリまたはフレームワーク内の単一のファイル）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;string&lt;/e0&gt; is a series of characters, such as &lt;c1&gt;&lt;s2&gt;"hello,&lt;/s2&gt; &lt;s3&gt;world"&lt;/s3&gt;&lt;/c1&gt; or &lt;c4&gt;&lt;s5&gt;"albatross"&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとつの&lt;e0&gt;文字列&lt;/e0&gt;は、一連なりの文字です、例えば&lt;c1&gt;&lt;s2&gt;"hello,&lt;/s2&gt; &lt;s3&gt;world"&lt;/s3&gt;&lt;/c1&gt;または&lt;c4&gt;&lt;s5&gt;"albatross"&lt;/s5&gt;&lt;/c4&gt;など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;structure declaration&lt;/e0&gt; introduces a named structure type into your program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;構造体宣言&lt;/e0&gt;は、名前をつけられた構造体型をあなたのプログラムに導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;subscript expression&lt;/e0&gt; provides subscript access using the getter and setter of the corresponding subscript declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;添え字式&lt;/e0&gt;は、対応する添え字宣言のゲッターとセッターを使用して、添え字アクセスを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;subscript&lt;/e0&gt; declaration allows you to add subscripting support for objects of a particular type and are typically used to provide a convenient syntax for accessing the elements in a collection, list, or sequence.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;添え字宣言&lt;/e0&gt;は、特定の型のオブジェクトに対する添え字サポートを付け加えることをあなたに可能にして、コレクション、リスト、またはシーケンスの中の要素にアクセスするための便利な構文を提供するために概して使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;superclass expression&lt;/e0&gt; lets a class interact with its superclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;スーパークラス式&lt;/e0&gt;は、あるクラスをそのスーパークラスと相互に作用させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;try expression&lt;/e0&gt; consists of the &lt;c1&gt;&lt;s2&gt;try&lt;/s2&gt;&lt;/c1&gt; operator followed by an expression that can throw an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;try式&lt;/e0&gt;は、&lt;c1&gt;&lt;s2&gt;try&lt;/s2&gt;&lt;/c1&gt;演算子と後につづくエラーをスローできる１つの式から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;tuple expression&lt;/e0&gt; consists of a comma-separated list of expressions surrounded by parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;タプル式&lt;/e0&gt;は、丸括弧に囲まれているコンマ区切りの式のリストから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;tuple pattern&lt;/e0&gt; is a comma-separated list of zero or more patterns, enclosed in parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;タプルパターン&lt;/e0&gt;は、丸括弧で囲まれた、０個以上のパターンのコンマ区切りのリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;tuple type&lt;/e0&gt; is a comma-separated list of types, enclosed in parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;タプル型&lt;/e0&gt;は、丸括弧で囲まれた、いくつかの型からなるコンマ区切りのリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;type alias declaration&lt;/e0&gt; introduces a named alias of an existing type into your program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;型エイリアス宣言&lt;/e0&gt;は、あなたのプログラムに既存の型の名前をつけられたエイリアスを導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;type annotation&lt;/e0&gt; explicitly specifies the type of a variable or expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある&lt;e0&gt;型注釈&lt;/e0&gt;は、明確に変数または式の型を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;type identifier&lt;/e0&gt; refers to either a named type or a type alias of a named or compound type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;型識別子&lt;/e0&gt;は、名前付きの型か、名前付きまたは複合の型の型エイリアスに言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;type inheritance clause&lt;/e0&gt; is used to specify which class a named type inherits from and which protocols a named type conforms to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある&lt;e0&gt;型継承節&lt;/e0&gt;は、ある名前付きの型が継承するのはどのクラスからか、およびある名前付きの型が準拠するのはどのプロトコルに対してかを指定するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;value type&lt;/e0&gt; is a type whose value is &lt;e1&gt;copied&lt;/e1&gt; when it’s assigned to a variable or constant, or when it’s passed to a function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;値型&lt;/e0&gt;は、それが変数または定数に代入される時に、あるいは、それが関数に渡されるときに、値が&lt;e1&gt;コピー&lt;/e1&gt;される型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;value-binding pattern&lt;/e0&gt; binds matched values to variable or constant names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;値束縛パターン&lt;/e0&gt;は、マッチした値を変数または定数の名前に縛り付けてひとつに束ねます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;variable declaration&lt;/e0&gt; introduces a variable named value into your program and is declared using the &lt;c1&gt;&lt;s2&gt;var&lt;/s2&gt;&lt;/c1&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;変数宣言&lt;/e0&gt;は、名前をつけられた変えられる値をあなたのプログラムにもたらします、そしてキーワード&lt;c1&gt;&lt;s2&gt;var&lt;/s2&gt;&lt;/c1&gt;を使って宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;variadic parameter&lt;/e0&gt; accepts zero or more values of a specified type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;可変長パラメータ&lt;/e0&gt;は、指定された型の０個以上の値を受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;weak reference&lt;/e0&gt; is a reference that does not keep a strong hold on the instance it refers to, and so does not stop ARC from disposing of the referenced instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;弱い参照&lt;/e0&gt;は、それが言及するインスタンスに対する強い支配力を保たない参照です、なのでARCは参照をつけられたインスタンスを処分するのを止めません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;wildcard expression&lt;/e0&gt; is used to explicitly ignore a value during an assignment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;ワイルドカード式&lt;/e0&gt;は、代入の間に明示的に値を無視するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e0&gt;wildcard pattern&lt;/e0&gt; matches and ignores any value and consists of an underscore (&lt;c1&gt;&lt;s2&gt;_&lt;/s2&gt;&lt;/c1&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;ワイルドカード・パターン&lt;/e0&gt;は、どんな値にでもマッチして無視します、そしてアンダースコア（&lt;c1&gt;&lt;s2&gt;_&lt;/s2&gt;&lt;/c1&gt;）から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e1&gt;type argument&lt;/e1&gt; is the name of an actual concrete type that replaces a corresponding type parameter in the generic parameter clause of a generic type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e1&gt;型引数&lt;/e1&gt;は実際の具象型の名前です、それは、ある総称体型のもつ総称体パラメータ節の中の対応する型パラメータを置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e2&gt;type parameter&lt;/e2&gt; is simply the name of a placeholder type (for example, &lt;c3&gt;&lt;s4&gt;T&lt;/s4&gt;&lt;/c3&gt;, &lt;c5&gt;&lt;s6&gt;U&lt;/s6&gt;&lt;/c5&gt;, &lt;c7&gt;&lt;s8&gt;V&lt;/s8&gt;&lt;/c7&gt;, &lt;c9&gt;&lt;s10&gt;Key&lt;/s10&gt;&lt;/c9&gt;, &lt;c11&gt;&lt;s12&gt;Value&lt;/s12&gt;&lt;/c11&gt;, and so on).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e2&gt;型パラメータ&lt;/e2&gt;は、単にプレースホルダ型の名前です（たとえば&lt;c3&gt;&lt;s4&gt;T&lt;/s4&gt;&lt;/c3&gt;、&lt;c5&gt;&lt;s6&gt;U&lt;/s6&gt;&lt;/c5&gt;、&lt;c7&gt;&lt;s8&gt;V&lt;/s8&gt;&lt;/c7&gt;、&lt;c9&gt;&lt;s10&gt;Key&lt;/s10&gt;&lt;/c9&gt;、&lt;c11&gt;&lt;s12&gt;Value&lt;/s12&gt;&lt;/c11&gt;など）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &lt;e4&gt;where clause&lt;/e4&gt; is introduced by the &lt;c5&gt;&lt;s6&gt;where&lt;/s6&gt;&lt;/c5&gt; keyword followed by an expression, and is used to provide an additional condition before a pattern in a case is considered matched to the &lt;e7&gt;control expression&lt;/e7&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e4&gt;where節&lt;/e4&gt;は、キーワード&lt;c5&gt;&lt;s6&gt;where&lt;/s6&gt;&lt;/c5&gt;のあとにひとつの式を続けることによって導入されます、そしてケース節の中のあるパターンがその&lt;e7&gt;制御式&lt;/e7&gt;にマッチしたと考えられるより前に更なる条件を与えるために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Swift Tour</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトツアー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Swift constant or variable that refers to an instance of some reference type is similar to a pointer in C, but isn’t a direct pointer to an address in memory, and doesn’t require you to write an asterisk (&lt;c1&gt;&lt;s2&gt;*&lt;/s2&gt;&lt;/c1&gt;) to indicate that you are creating a reference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある参照型のインスタンスに言及するスウィフト定数または変数はCの中のポインターに似ています、しかしメモリ中のアドレスへの直接のポインターでなくて、あなたに参照をつくっていることを示すために星印（&lt;c1&gt;&lt;s2&gt;*&lt;/s2&gt;&lt;/c1&gt;）を書くことを要求しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Swift property does not have a corresponding instance variable, and the backing store for a property is not accessed directly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのプロパティには対応するインスタンス変数がありません、そしてプロパティのための支援外部記憶は直接にアクセスされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Unicode scalar value is a unique 21-bit number for a character or modifier, such as &lt;c3&gt;&lt;s4&gt;U+0061&lt;/s4&gt;&lt;/c3&gt; for &lt;c5&gt;&lt;s6&gt;LATIN&lt;/s6&gt; &lt;s7&gt;SMALL&lt;/s7&gt; &lt;s8&gt;LETTER&lt;/s8&gt; &lt;s9&gt;A&lt;/s9&gt;&lt;/c5&gt; (&lt;c10&gt;&lt;s11&gt;"a"&lt;/s11&gt;&lt;/c10&gt;), or &lt;c12&gt;&lt;s13&gt;U+1F425&lt;/s13&gt;&lt;/c12&gt; for &lt;c14&gt;&lt;s15&gt;FRONT-FACING&lt;/s15&gt; &lt;s16&gt;BABY&lt;/s16&gt; &lt;s17&gt;CHICK&lt;/s17&gt;&lt;/c14&gt; (&lt;c18&gt;&lt;s19&gt;"🐥"&lt;/s19&gt;&lt;/c18&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるユニコードスカラー値は、ある文字または修飾子のための固有な21ビットの数字です、例えば&lt;c3&gt;&lt;s4&gt;U+0061&lt;/s4&gt;&lt;/c3&gt;は&lt;c5&gt;&lt;s6&gt;LATIN&lt;/s6&gt; &lt;s7&gt;SMALL&lt;/s7&gt; &lt;s8&gt;LETTER&lt;/s8&gt; &lt;s9&gt;A&lt;/s9&gt;&lt;/c5&gt;（&lt;c10&gt;&lt;s11&gt;"a"&lt;/s11&gt;&lt;/c10&gt;）に対して、または&lt;c12&gt;&lt;s13&gt;U+1F425&lt;/s13&gt;&lt;/c12&gt;は&lt;c14&gt;&lt;s15&gt;FRONT-FACING&lt;/s15&gt; &lt;s16&gt;BABY&lt;/s16&gt; &lt;s17&gt;CHICK&lt;/s17&gt;&lt;/c14&gt;（&lt;c18&gt;&lt;s19&gt;"🐥"&lt;/s19&gt;&lt;/c18&gt;）に対してなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A capture list defines the rules to use when capturing one or more reference types within the closure’s body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>捕獲リストは、クロージャの本文内で１つ以上の参照型を捕獲するとき使用する規則を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A capture list is written as a comma-separated list of expressions surrounded by square brackets, before the list of parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キャプチャリストは、角括弧に囲まれたいくらかの式からなる「コンマ区切り」のリストとして、パラメータのリストの前に書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class can &lt;e0&gt;inherit&lt;/e0&gt; methods, properties, and other characteristics from another class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスは、メソッド、プロパティ、および他の特徴を別のクラスから&lt;e0&gt;継承&lt;/e0&gt;することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class can override properties, methods, subscripts, and initializers of its superclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスは、それのスーパークラスのプロパティ、メソッド、添え字、そしてイニシャライザをオーバーライドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class or structure can provide as many subscript implementations as it needs, and the appropriate subscript to be used will be inferred based on the types of the value or values that are contained within the subscript brackets at the point that the subscript is used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスや構造体はそれが必要とする多くの添え字実装を提供することが可能です、そして使用されるのに適切な添え字が、添え字が使われる時点でその添え字角括弧内に含まれる値または複数の値の型に基づいて、推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class type can inherit from only one parent class, its &lt;e0&gt;superclass&lt;/e0&gt;, but can adopt any number of protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス型は、ただ１つの親クラス、それの&lt;e0&gt;スーパークラス&lt;/e0&gt;から継承することだけが許されます、しかし随意の数のプロトコルに準拠することはできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class type method marked with the &lt;c6&gt;&lt;s7&gt;class&lt;/s7&gt;&lt;/c6&gt; declaration modifier can be overridden by a subclass implementation; a class type method marked with &lt;c8&gt;&lt;s9&gt;class&lt;/s9&gt; &lt;s10&gt;final&lt;/s10&gt;&lt;/c8&gt; or &lt;c11&gt;&lt;s12&gt;static&lt;/s12&gt;&lt;/c11&gt; can’t be overridden.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;class&lt;/s7&gt;&lt;/c6&gt;宣言修飾子で印されるクラス型メソッドは、サブクラス実装によってオーバーライドされることができます；&lt;c8&gt;&lt;s9&gt;class&lt;/s9&gt; &lt;s10&gt;final&lt;/s10&gt;&lt;/c8&gt;または&lt;c11&gt;&lt;s12&gt;static&lt;/s12&gt;&lt;/c11&gt;で印されるクラス型メソッドはオーバーライドされることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class, structure, or enumeration type can enable syntactic sugar for function call syntax by declaring one of several methods, as described in &lt;a0&gt;&lt;s1&gt;Methods with Special Names&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス、構造体、または列挙型は、構文糖を関数呼び出し構文に対して可能にすることが、幾つかのメソッドの１つを宣言することによって可能です、&lt;a0&gt;&lt;s1&gt;特殊名を持つメソッド&lt;/s1&gt;&lt;/a0&gt;で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class, structure, or enumeration type can support function call syntax by defining a &lt;c0&gt;&lt;s1&gt;dynamicallyCall(withArguments:)&lt;/s1&gt;&lt;/c0&gt; method or a &lt;c2&gt;&lt;s3&gt;dynamicallyCall(withKeywordArguments:)&lt;/s3&gt;&lt;/c2&gt; method, as described in &lt;a4&gt;&lt;s5&gt;dynamicCallable&lt;/s5&gt;&lt;/a4&gt;, or by defining a call-as-function method, as described below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス、構造体、または列挙は、関数呼び出し構文をサポートできます。&lt;c0&gt;&lt;s1&gt;dynamicallyCall(withArguments:)&lt;/s1&gt;&lt;/c0&gt;メソッドまたは&lt;c2&gt;&lt;s3&gt;dynamicallyCall(withKeywordArguments:)&lt;/s3&gt;&lt;/c2&gt;メソッドを定義することによって、&lt;a4&gt;&lt;s5&gt;dynamicCallable&lt;/s5&gt;&lt;/a4&gt;において記述されるように、またはcall-as-functionメソッドを定義することによって、下で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class-only protocol is marked by its inheritance from &lt;c8&gt;&lt;s9&gt;AnyObject&lt;/s9&gt;&lt;/c8&gt;, as discussed in &lt;a10&gt;&lt;s11&gt;Class-Only Protocols&lt;/s11&gt;&lt;/a10&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス専用プロトコルは、&lt;c8&gt;&lt;s9&gt;AnyObject&lt;/s9&gt;&lt;/c8&gt;からのそれの継承によって印されます、&lt;a10&gt;&lt;s11&gt;クラス専用プロトコル&lt;/s11&gt;&lt;/a10&gt;において議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A closure can &lt;e0&gt;capture&lt;/e0&gt; constants and variables from the surrounding context in which it is defined.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャは、それが定義される周囲の前後関係から、定数と変数を&lt;e0&gt;捕獲（キャプチャ）&lt;/e0&gt;できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A closure can omit the types of its parameters, its return type, or both.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャは、そのパラメータの型、その戻り型、または両方を省略することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A closure expression is nonescaping if it is called immediately or passed as a nonescaping function argument.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャ式は、もしそれが直接に呼び出されるか、または非脱出関数引数として渡されるならば非脱出です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A closure is said to &lt;e0&gt;escape&lt;/e0&gt; a function when the closure is passed as an argument to the function, but is called after the function returns.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャが引数として関数に渡される、しかしその関数が戻った後に呼び出されるとき、クロージャは関数を&lt;e0&gt;脱出する&lt;/e0&gt;と言われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A closure may omit names for its parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャは、そのパラメータの名前を省略することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A closure or nested function that captures an in-out parameter must be nonescaping.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>in-outパラメータをキャプチャするクロージャまたは入れ子にされた関数は、非脱出でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A closure passed as the last argument to a function can appear immediately after the parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最後の引数として関数に渡されるクロージャは、丸括弧の直後に現れることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A closure that consists of only a single expression is understood to return the value of that expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>１つの式だけから成るクロージャは、その式の値を返すと理解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A collection of 21-bit Unicode scalar values, equivalent to the string’s UTF-32 encoding form (accessed with the string’s &lt;c0&gt;&lt;s1&gt;unicodeScalars&lt;/s1&gt;&lt;/c0&gt; property)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>21ビットのUnicodeスカラー値の集まり、その文字列のUTF-32符号化方式と等しい（文字列の&lt;c0&gt;&lt;s1&gt;unicodeScalars&lt;/s1&gt;&lt;/c0&gt;プロパティでアクセスされます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A collection of UTF-16 code units (accessed with the string’s &lt;c0&gt;&lt;s1&gt;utf16&lt;/s1&gt;&lt;/c0&gt; property)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>UTF-16符号単位の集まり（文字列の&lt;c0&gt;&lt;s1&gt;utf16&lt;/s1&gt;&lt;/c0&gt;プロパティでアクセスされます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A collection of UTF-8 code units (accessed with the string’s &lt;c0&gt;&lt;s1&gt;utf8&lt;/s1&gt;&lt;/c0&gt; property)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>UTF-８符号単位の集まり（文字列の&lt;c0&gt;&lt;s1&gt;utf8&lt;/s1&gt;&lt;/c0&gt;プロパティでアクセスされます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A comma is allowed after the last element.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとつのコンマが最後の要素のあとに許容されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A compile-time diagnostic statement causes the compiler to emit an error or a warning during compilation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイル時診断文は、コンパイラにエラーまたは警告をコンパイルの間に発せさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A compile-time diagnostic statement has the following forms:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイル時診断文は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A compound type may contain named types and other compound types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとつの複合の型は、名前付きの型や他の複合の型を含むかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A computed property with a getter but no setter is known as a &lt;e0&gt;read-only computed property&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ゲッターを持つ、しかしセッターはない計算プロパティは、&lt;e0&gt;読み出し専用の計算プロパティ&lt;/e0&gt;として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A concrete type can conform to a particular protocol only once.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある具象型は、特定のプロトコルにただ一度だけ準拠できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A conditional compilation block allows code to be conditionally compiled depending on the value of one or more compilation conditions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>条件コンパイルブロックは、１つ以上のコンパイル条件の値に依存してコードが条件付きでコンパイルされるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A conflicting access to memory can occur when different parts of your code are trying to access the same location in memory at the same time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メモリアクセスの衝突は、あなたのコードの異なる部分がメモリの同じ位置に同じ時にアクセスしようとする場合に生じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A conforming type can provide additional functionality, as long as it satisfies these three requirements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それに準拠している型は、それがこれらの３つの要件を満たす限り、追加の機能性を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A conforming type can satisfy a failable protocol initializer requirement by implementing any kind of initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある準拠している型は、失敗できるプロトコルイニシャライザ要件を満たすことが、どんな種類のイニシャライザを実装することによっても可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A conforming type can satisfy a nonfailable protocol initializer requirement by implementing a nonfailable initializer or an &lt;c0&gt;&lt;s1&gt;init!&lt;/s1&gt;&lt;/c0&gt; failable initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある準拠している型は、失敗できないプロトコルイニシャライザ要件を満たすことが、失敗できないイニシャライザまたは&lt;c0&gt;&lt;s1&gt;init!&lt;/s1&gt;&lt;/c0&gt;失敗できるイニシャライザを実装することによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A consistent use of &lt;c4&gt;&lt;s5&gt;Int&lt;/s5&gt;&lt;/c4&gt; for integer values aids code interoperability, avoids the need to convert between different number types, and matches integer type inference, as described in &lt;a6&gt;&lt;s7&gt;Type Safety and Type Inference&lt;/s7&gt;&lt;/a6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数値のための&lt;c4&gt;&lt;s5&gt;Int&lt;/s5&gt;&lt;/c4&gt;の一貫した使用は、コードの相互運用性を支援して、異なる数の型の間で変換する必要を避けて、&lt;a6&gt;&lt;s7&gt;「型安全と型推論」&lt;/s7&gt;&lt;/a6&gt;で記述されるように、整数型推論に合致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A constant declaration defines an immutable binding between the &lt;e0&gt;constant name&lt;/e0&gt; and the value of the initializer &lt;e1&gt;expression&lt;/e1&gt;; after the value of a constant is set, it cannot be changed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数宣言は、&lt;e0&gt;定数名&lt;/e0&gt;とイニシャライザ&lt;e1&gt;式&lt;/e1&gt;の値の間の不変の束縛を定義します；定数の値が設定されたあと、それは変わることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A constant or variable must have the same type as the value you want to assign to it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数または変数は、あなたがそれに代入したい値と同じ型を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A constant or variable of a certain class type may actually refer to an instance of a subclass behind the scenes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特定のクラス型の定数または変数は、舞台裏で実際にはあるサブクラスのインスタンスを参照するかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A constant type property of a class is always implicitly final; you can’t mark it with the &lt;c2&gt;&lt;s3&gt;class&lt;/s3&gt;&lt;/c2&gt; or &lt;c4&gt;&lt;s5&gt;final&lt;/s5&gt;&lt;/c4&gt; declaration modifier to allow or disallow overriding by subclasses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるクラスの定数型プロパティは、常に暗黙的に最終的なものです；あなたはそれを&lt;c2&gt;&lt;s3&gt;class&lt;/s3&gt;&lt;/c2&gt;または&lt;c4&gt;&lt;s5&gt;final&lt;/s5&gt;&lt;/c4&gt;宣言修飾子で印できません、またはサブクラスによるオーバーライドを許可したり不許可にしたりできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A constant, variable, or property can’t be more public than its type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数、変数、またはプロパティは、その型よりもより公開であることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A convenience initializer must call another initializer from the &lt;e0&gt;same&lt;/e0&gt; class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>便宜イニシャライザは、別のイニシャライザを&lt;e0&gt;同じ&lt;/e0&gt;クラスから呼ばなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A convenience initializer must delegate to another initializer before assigning a value to &lt;e0&gt;any&lt;/e0&gt; property (including properties defined by the same class).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>便宜イニシャライザは、値を&lt;e0&gt;何らかの&lt;/e0&gt;プロパティ（同じクラスによって定義されるプロパティを含む）に代入する前に、別のイニシャライザに委任しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A convenience initializer must ultimately call a designated initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>便宜イニシャライザは、最終的に指定イニシャライザを呼ばなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A custom infix operator that is not explicitly placed into a precedence group is given a default precedence group with a precedence immediately higher than the precedence of the ternary conditional operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある優先順位グループの中に明示的に置かれないあつらえの接中辞演算子は、三項条件演算子の優先順位のすぐ上の優先順位を持つ省略時の優先順位グループを与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A decimal integer greater than zero</seg>
      </tuv>
      <tuv lang="JA">
        <seg>０より大きい10進法整数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A default initializer has the same access level as the type it initializes, unless that type is defined as &lt;c0&gt;&lt;s1&gt;public&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時のイニシャライザは、それが初期化する型と同じアクセス水準を持ちます、その型が&lt;c0&gt;&lt;s1&gt;public&lt;/s1&gt;&lt;/c0&gt;として宣言される場合を除いて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A default parameter called &lt;c4&gt;&lt;s5&gt;newValue&lt;/s5&gt;&lt;/c4&gt; is provided to your setter if you do not provide one yourself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが独自のものを提供しないならば、&lt;c4&gt;&lt;s5&gt;newValue&lt;/s5&gt;&lt;/c4&gt;と呼ばれる省略時のパラメータがあなたのセッターに提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A deinitializer can be declared only in the body of a class declaration—but not in an extension of a class—and each class can have at most one.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デイニシャライザは、クラス宣言の本文においてのみ ― しかしクラスの拡張においてではなく ― 宣言されることができます、そして各クラスが多くとも１つしか持つことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A deinitializer is called automatically when there are no longer any references to a class object, just before the class object is deallocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デイニシャライザは、あるクラスオブジェクトに対するいかなる参照ももはやない時、そのクラスオブジェクトが割り当て解除される直前に、自動的に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A designated initializer for that class confirms that all stored properties introduced by that class have a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのクラスのための指定イニシャライザは、そのクラスによって導入される全ての格納プロパティが値を持つことを確かめます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A designated initializer fully initializes all properties introduced by that class and calls an appropriate superclass initializer to continue the initialization process up the superclass chain.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定イニシャライザは、そのクラスによって導入される全てのプロパティを完全に初期化して、適切なスーパークラスのイニシャライザを呼んで初期化プロセスを続けていきスーパークラス連鎖を上っていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A designated initializer must call a designated initializer from its immediate superclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定イニシャライザは、その直接のスーパークラスから指定イニシャライザを呼ばなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A designated initializer must delegate up to a superclass initializer before assigning a value to an inherited property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定イニシャライザは、継承されたプロパティに代入する前にスーパークラスのイニシャライザへ委任しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A designated initializer must ensure that all of the properties introduced by its class are initialized before it delegates up to a superclass initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定イニシャライザは、それがスーパークラスのイニシャライザへと委任する前に、そのクラスによって導入されるプロパティの全てが初期化されることを確実にしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A designated initializer of a class initializes all of the class’s properties directly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるクラスの指定イニシャライザは、直接そのクラスのプロパティの全てを初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A designated or convenience initializer is called on a class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定または便宜イニシャライザが、あるクラスで呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A dictionary &lt;c0&gt;&lt;s1&gt;Key&lt;/s1&gt;&lt;/c0&gt; type must conform to the &lt;c2&gt;&lt;s3&gt;Hashable&lt;/s3&gt;&lt;/c2&gt; protocol, like a set’s value type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある辞書の&lt;c0&gt;&lt;s1&gt;Key&lt;/s1&gt;&lt;/c0&gt;型は、集合の持つ値型のように、&lt;c2&gt;&lt;s3&gt;Hashable&lt;/s3&gt;&lt;/c2&gt;プロトコルに準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A dictionary literal is a shorthand way to write one or more key-value pairs as a &lt;c1&gt;&lt;s2&gt;Dictionary&lt;/s2&gt;&lt;/c1&gt; collection.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書リテラルは、&lt;c1&gt;&lt;s2&gt;Dictionary&lt;/s2&gt;&lt;/c1&gt;コレクションとして１つ以上の「キーと値」の対を書く簡便な方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A different function with the same matching type can be assigned to the same variable, in the same way as for nonfunction types:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じ適合型を持つ異なる関数は、同じ変数に代入されることが可能です、それは非関数型に対するのと同じ方法で行えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A failable designated initializer can be overridden in a subclass by any kind of designated initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できる指定イニシャライザは、サブクラスにおいて任意の種類の指定イニシャライザでオーバーライドされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A failable initializer can also delegate to a nonfailable initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できるイニシャライザは、また、失敗できないイニシャライザへと委任することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A failable initializer can delegate to any kind of initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できるイニシャライザは、あらゆる種類のイニシャライザへ委任することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A failable initializer can return &lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt; at any point in the implementation of the initializer’s body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できるイニシャライザは、そのイニシャライザの本文の中の任意の地点で&lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;を返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A failable initializer creates an &lt;e0&gt;optional&lt;/e0&gt; value of the type it initializes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できるイニシャライザは、そのイニシャライザの型の&lt;e0&gt;オプショナル&lt;/e0&gt;の値を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A failable initializer is used to find an appropriate enumeration case for a &lt;c8&gt;&lt;s9&gt;Character&lt;/s9&gt;&lt;/c8&gt; value representing a temperature symbol:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できるイニシャライザは、ある温度記号で表されている&lt;c8&gt;&lt;s9&gt;Character&lt;/s9&gt;&lt;/c8&gt;値に対して適切な列挙ケース節を見つけるために使用されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A failable initializer of a class, structure, or enumeration can delegate across to another failable initializer from the same class, structure, or enumeration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス、構造体、または列挙のための失敗できるイニシャライザは、同じクラス、構造体、または列挙からの別の失敗できるイニシャライザに横つながりに委任することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A failable initializer requirement can be satisfied by a failable or nonfailable initializer on a conforming type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できるイニシャライザ要件は、準拠している型上の失敗できるもしくは失敗できないイニシャライザによって満たされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A fourth value is pushed onto the top of the stack.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第４の値がスタックのてっぺんに押し込まれ（プッシュされ）ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function call expression can include a trailing closure in the form of a closure expression immediately after the closing parenthesis.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数呼び出し式は、終わりの括弧の直後にクロージャ式の形で後付クロージャを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function can have at most one variadic parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数は最大で１つの可変長パラメータしか持つことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function can take another function as one of its arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある関数は、その引数の１つとして別の関数をとることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function can’t have a higher access level than its parameter types and return type, because the function could be used in situations where its constituent types are unavailable to the surrounding code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数は、そのパラメータ型および戻り型より高いアクセス水準を持つことができません、なぜなら、その関数は、それの組成の型が周囲のコードに利用できない状況において使われることができるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function declaration whose &lt;e0&gt;statements&lt;/e0&gt; include only a single expression is understood to return the value of that expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それの&lt;e0&gt;statements&lt;/e0&gt;がただ１つの式だけを含む関数宣言は、その式の値を返すものと理解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function declared in the context of class, structure, enumeration, or protocol is referred to as a &lt;e1&gt;method&lt;/e1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス、構造体、列挙、またはプロトコルの文脈において宣言される関数は、&lt;e1&gt;メソッド&lt;/e1&gt;として言及されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function definition can appear inside another function declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数定義は、別の関数宣言の内部に現れることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function has long-term write access to all of its in-out parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある関数は長期書き込みアクセスをそれのin-outパラメータの全てに対して持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function indicates that it can throw an error by including the &lt;c0&gt;&lt;s1&gt;throws&lt;/s1&gt;&lt;/c0&gt; keyword in its declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある関数は、それがエラーをスローできることを&lt;c0&gt;&lt;s1&gt;throws&lt;/s1&gt;&lt;/c0&gt;キーワードをそれの宣言に含めることによって示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function marked with &lt;c2&gt;&lt;s3&gt;throws&lt;/s3&gt;&lt;/c2&gt; is called a &lt;e4&gt;throwing function&lt;/e4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;throws&lt;/s3&gt;&lt;/c2&gt;で印された関数は、&lt;e4&gt;スロー関数&lt;/e4&gt;と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function may have at most one variadic parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数は、最大で１つの可変長パラメータしか持つことが出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function or method can be declared with the &lt;c0&gt;&lt;s1&gt;rethrows&lt;/s1&gt;&lt;/c0&gt; keyword to indicate that it throws an error only if one of its function parameters throws an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数またはメソッドは、&lt;c0&gt;&lt;s1&gt;rethrows&lt;/s1&gt;&lt;/c0&gt;キーワードとともに宣言されて、それの関数パラメータの１つがエラーをスローする場合にのみそれがエラーをスローすることを指し示すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function or method with an opaque return type hides its return value’s type information.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>不透明戻り型をもつ関数またはメソッドは、それの戻り値のもつ型情報を隠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function that tries to retrieve a web page might return the &lt;c0&gt;&lt;s1&gt;(Int,&lt;/s1&gt; &lt;s2&gt;String)&lt;/s2&gt;&lt;/c0&gt; tuple type to describe the success or failure of the page retrieval.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ウェブ・ページを探してくるある関数は、ページ検索の成功または失敗を記述するために&lt;c0&gt;&lt;s1&gt;(Int,&lt;/s1&gt; &lt;s2&gt;String)&lt;/s2&gt;&lt;/c0&gt;のタプル型を返すかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function that uses an opaque type as its return type must return values that share a single underlying type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>不透明型をそれの戻り型として使う関数は、ある単一の基礎をなす型を共有する値を返さなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function type can have a variadic parameter in its &lt;e0&gt;parameter type&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数型は、その&lt;e0&gt;パラメータ型&lt;/e0&gt;において可変長パラメータを持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function with a defined return type cannot allow control to fall out of the bottom of the function without returning a value, and attempting to do so will result in a compile-time error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある定義された戻り型を持つ関数は、値を返すことなく関数の底を抜け落ちるように制御されることができません、そしてそうしようとすることはコンパイル時エラーに終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function with the Objective-C block calling convention can’t be converted to the C calling convention.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cブロック呼出規約での関数は、C呼出規約に変換されることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A function’s arguments must always be provided in the same order as the function’s parameter list.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数の引数は、常にその関数のパラメータ一覧と同じ順序で提供されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A generic &lt;c1&gt;&lt;s2&gt;where&lt;/s2&gt;&lt;/c1&gt; clause enables you to require that an associated type must conform to a certain protocol, or that certain type parameters and associated types must be the same.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体&lt;c1&gt;&lt;s2&gt;where&lt;/s2&gt;&lt;/c1&gt;節は、ある関連型が特定のプロトコルに準拠しなければならないこと、または特定の型パラメータおよび関連型が同じでなければならないことをあなたが要求できるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A generic &lt;c2&gt;&lt;s3&gt;where&lt;/s3&gt;&lt;/c2&gt; clause consists of the &lt;c4&gt;&lt;s5&gt;where&lt;/s5&gt;&lt;/c4&gt; keyword, followed by a comma-separated list of one or more &lt;e6&gt;requirements&lt;/e6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体&lt;c2&gt;&lt;s3&gt;where&lt;/s3&gt;&lt;/c2&gt;節は、&lt;c4&gt;&lt;s5&gt;where&lt;/s5&gt;&lt;/c4&gt;キーワード、それに続けてコンマ区切りのリストのひとつ以上の&lt;e6&gt;要件（requirements）&lt;/e6&gt;から構成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A generic &lt;c3&gt;&lt;s4&gt;where&lt;/s4&gt;&lt;/c3&gt; clause starts with the &lt;c5&gt;&lt;s6&gt;where&lt;/s6&gt;&lt;/c5&gt; keyword, followed by constraints for associated types or equality relationships between types and associated types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体&lt;c3&gt;&lt;s4&gt;where&lt;/s4&gt;&lt;/c3&gt;節は、&lt;c5&gt;&lt;s6&gt;where&lt;/s6&gt;&lt;/c5&gt;キーワードで始まり、関連型に対する制約がいくつか、または型と関連型の間の同等関係性がいくつか続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A generic argument clause is enclosed in angle brackets (&lt;&gt;) and has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体引数節は、山形括弧（&lt;&gt;）に囲まれて、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A generic parameter clause is enclosed in angle brackets (&lt;&gt;) and has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体パラメータ節は、山形括弧（&lt;&gt;）において囲まれて、以下の書式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A generic parameter consists of a &lt;e0&gt;type parameter&lt;/e0&gt; followed by an optional &lt;e1&gt;constraint&lt;/e1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体パラメータは、&lt;e0&gt;型パラメータ&lt;/e0&gt;とそれに続く任意の&lt;e1&gt;制約&lt;/e1&gt;から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A generic type may be able to satisfy the requirements of a protocol only under certain conditions, such as when the type’s generic parameter conforms to the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体型は、あるプロトコルの要件を満たすことが一定の条件の下でのみ可能でしょう、例えばその型のもつ総称体パラメータがそのプロトコルに準拠する場合など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A hash value is an &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt; value that is the same for all objects that compare equally, such that if &lt;c4&gt;&lt;s5&gt;a&lt;/s5&gt; &lt;s6&gt;==&lt;/s6&gt; &lt;s7&gt;b&lt;/s7&gt;&lt;/c4&gt;, it follows that &lt;c8&gt;&lt;s9&gt;a.hashValue&lt;/s9&gt; &lt;s10&gt;==&lt;/s10&gt; &lt;s11&gt;b.hashValue&lt;/s11&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるハッシュ値はあるひとつの&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;値です、それは同等とみなされるすべてのオブジェクトに対して同じものです、たとえば&lt;c4&gt;&lt;s5&gt;a&lt;/s5&gt; &lt;s6&gt;==&lt;/s6&gt; &lt;s7&gt;b&lt;/s7&gt;&lt;/c4&gt;のように、それは&lt;c8&gt;&lt;s9&gt;a.hashValue&lt;/s9&gt; &lt;s10&gt;==&lt;/s10&gt; &lt;s11&gt;b.hashValue&lt;/s11&gt;&lt;/c8&gt;で導き出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A key-path string expression lets you access the string used to refer to a property in Objective-C, for use in key-value coding and key-value observing APIs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キーパス文字列式は、あなたにObjective-Cでのプロパティを参照するために使われる文字列にアクセスさせます、キー値コーディングとキー値監視APIで使用するために。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A labeled statement is indicated by placing a label on the same line as the statement’s introducer keyword, followed by a colon.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ラベルをつけられた文は、あるラベルをその文の導入子キーワードとして、コロンをその後に続けて同じ行に置くことによって示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A line control statement has the following forms:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>行制御文は以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A line control statement is used to specify a line number and filename that can be different from the line number and filename of the source code being compiled.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>行制御文は、行番号とファイル名を指定するために使われます、それはコンパイルされているソースコードの行番号とファイル名とは異なっていることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A literal doesn’t have a type on its own.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リテラルはそれ独自の型を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A long-term access can overlap with other long-term accesses and instantaneous accesses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>長期アクセスは、他の長期アクセスおよび即時アクセスでオーバーラップ可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A method marked with the &lt;c0&gt;&lt;s1&gt;nonobjc&lt;/s1&gt;&lt;/c0&gt; attribute can’t override a method marked with the &lt;c2&gt;&lt;s3&gt;objc&lt;/s3&gt;&lt;/c2&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;nonobjc&lt;/s1&gt;&lt;/c0&gt;属性で印されるメソッドは、&lt;c2&gt;&lt;s3&gt;objc&lt;/s3&gt;&lt;/c2&gt;属性で印されるメソッドをオーバーライドできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A module name</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるモジュール名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A multiline string can be indented to match the surrounding code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数行文字列は、字下げされることによって、囲んでいるコードに調和します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A multiline string literal can be indented using any combination of spaces and tabs; this indentation is not included in the string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数行文字列リテラルは、空白とタブの任意の組み合わせを使って字下げできます；この字下げはその文字列に含まれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A multiline string literal includes all of the lines between its opening and closing quotation marks.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数行文字列リテラルは、それの開始および終了引用符の間のすべての行を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A multiline string literal is surrounded by three double quotation marks and has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数行の文字列リテラルは、３つの二重引用符によって囲まれて、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A mutating method on a structure has write access to &lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt; for the duration of the method call.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある構造体での変更メソッドは、&lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;に対する書き込みアクセスをそのメソッド呼び出しの継続期間にわたって持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A name before the parameter name gives the parameter an explicit argument label, which can be different from the parameter name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータ名の前の名前は、そのパラメータに明示的な引数ラベルを与えます、それはパラメーター名と異なるものにできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A nested function can capture any of its outer function’s arguments and can also capture any constants and variables defined within the outer function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>入れ子にされた関数は、その外側の関数の持つ引数の何でも捕獲することができ、また外側の関数の範囲内で定義されるどんな定数や変数でも捕獲することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A nested function is nonescaping if it captures a value that is guaranteed to never escape—such as an in-out parameter—or passed as a nonescaping function argument.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>入れ子にされた関数は、決して脱出しないことを保証される値 — 例えばin-outパラメータ — を、または非脱出関数引数として渡される値を、もしそれがキャプチャするならば非脱出です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A new &lt;c0&gt;&lt;s1&gt;Player&lt;/s1&gt;&lt;/c0&gt; instance is created, with a request for 100 coins if they are available.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい&lt;c0&gt;&lt;s1&gt;Player&lt;/s1&gt;&lt;/c0&gt;インスタンスが、それが可能ならば100のコインを要請して作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A nonfailable designated initializer can be overridden in a subclass by a nonfailable designated initializer only.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できない指定イニシャライザは、サブクラスにおいて失敗できない指定イニシャライザでのみオーバーライドされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A nonfailable initializer can delegate to an &lt;c2&gt;&lt;s3&gt;init?&lt;/s3&gt;&lt;/c2&gt; failable initializer by force-unwrapping the result of the superclass’s initializer—for example, by writing &lt;c4&gt;&lt;s5&gt;super.init()!&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できないイニシャライザは、&lt;c2&gt;&lt;s3&gt;init?&lt;/s3&gt;&lt;/c2&gt;失敗できるイニシャライザに委任することが、スーパークラスのイニシャライザの結果を強制アンラップすることによって可能です ― 例えば、&lt;c4&gt;&lt;s5&gt;super.init()!&lt;/s5&gt;&lt;/c4&gt;と書くことによって。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A nonfailable initializer can delegate to another nonfailable initializer or to an &lt;c0&gt;&lt;s1&gt;init!&lt;/s1&gt;&lt;/c0&gt; failable initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できないイニシャライザは、別の失敗できないイニシャライザへ、または失敗できるイニシャライザ&lt;c0&gt;&lt;s1&gt;init!&lt;/s1&gt;&lt;/c0&gt;へ委任することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A nonfailable initializer requirement can be satisfied by a nonfailable initializer or an implicitly unwrapped failable initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できないイニシャライザ要件は、失敗できないイニシャライザまたは暗黙的にアンラップされる失敗できるイニシャライザによって満たされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A nongeneric global function, a local function that doesn’t capture any local variables or a closure that doesn’t capture any local variables can be converted to the C calling convention.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非総称体グローバル関数、何らローカル変数をキャプチャしないローカル関数または何らローカル変数をキャプチャしないクロージャは、C呼出規約に変換されることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A nonreturning function or method can be called to conclude the &lt;c0&gt;&lt;s1&gt;else&lt;/s1&gt;&lt;/c0&gt; clause of a guard statement, as discussed in &lt;a2&gt;&lt;s3&gt;Guard Statement&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非復帰関数およびメソッドは、guard文の&lt;c0&gt;&lt;s1&gt;else&lt;/s1&gt;&lt;/c0&gt;節で終わるために呼び出されることができます、&lt;a2&gt;&lt;s3&gt;guard文&lt;/s3&gt;&lt;/a2&gt;で議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A number that won’t fit into a constant or variable of a sized integer type is reported as an error when your code is compiled:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのコードがコンパイルされるとき、ある大きさを設定された整数型の定数または変数に収まらない数はエラーとして報告されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A pair of parentheses still wrap the entire argument for the method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一対の丸括弧は、依然としてこのメソッドに対する引数をすべて包みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A parameter has a name, which is used within the function body, as well as an argument label, which is used when calling the function or method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータは名前を持ちます、それは関数本文内部で使われます、それだけでなく引数ラベルも、それは関数やメソッドが呼ばれる時に使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A parameter of the function type &lt;c0&gt;&lt;s1&gt;()&lt;/s1&gt; &lt;s2&gt;-&gt;&lt;/s2&gt; &lt;s3&gt;T&lt;/s3&gt;&lt;/c0&gt; (where &lt;c4&gt;&lt;s5&gt;T&lt;/s5&gt;&lt;/c4&gt; is any type) can apply the &lt;c6&gt;&lt;s7&gt;autoclosure&lt;/s7&gt;&lt;/c6&gt; attribute to implicitly create a closure at its call sites.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数型&lt;c0&gt;&lt;s1&gt;()&lt;/s1&gt; &lt;s2&gt;-&gt;&lt;/s2&gt; &lt;s3&gt;T&lt;/s3&gt;&lt;/c0&gt;（ここで&lt;c4&gt;&lt;s5&gt;T&lt;/s5&gt;&lt;/c4&gt;はどんな型でも）のあるパラメータは、&lt;c6&gt;&lt;s7&gt;autoclosure&lt;/s7&gt;&lt;/c6&gt;属性を適用することによって、あるクロージャを暗黙的にそれの呼び出し領域で作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A parameter that’s a nonescaping function can’t be passed as an argument to another nonescaping function parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非脱出関数であるパラメータは、別の非脱出関数パラメータに引数として渡されることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A parameter that’s a nonescaping function can’t be stored in a property, variable, or constant of type &lt;c0&gt;&lt;s1&gt;Any&lt;/s1&gt;&lt;/c0&gt;, because that might allow the value to escape.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非脱出関数であるパラメータは、型&lt;c0&gt;&lt;s1&gt;Any&lt;/s1&gt;&lt;/c0&gt;のプロパティ、変数、または定数に格納できません、なぜならそれは値を脱出させることを許可するかもしれないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A parameter with a base type name followed immediately by three dots (&lt;c0&gt;&lt;s1&gt;...&lt;/s1&gt;&lt;/c0&gt;) is understood as a variadic parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>基本の型の名前に直ちに３つの点（&lt;c0&gt;&lt;s1&gt;...&lt;/s1&gt;&lt;/c0&gt;）が続くパラメータは、可変長パラメータとして理解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A parameter with an equals sign (&lt;c0&gt;&lt;s1&gt;=&lt;/s1&gt;&lt;/c0&gt;) and an expression after its type is understood to have a default value of the given expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その型の後に等号（&lt;c0&gt;&lt;s1&gt;=&lt;/s1&gt;&lt;/c0&gt;）と式をもつパラメータは、与えられた式からなる省略時の値を持つと理解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A postfix &lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt; expression consists of an expression or the name of a type, immediately followed by &lt;c2&gt;&lt;s3&gt;.self&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接尾辞&lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;式は、ある式または型の名前と、それに直ちに続く&lt;c2&gt;&lt;s3&gt;.self&lt;/s3&gt;&lt;/c2&gt;から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A precedence group declaration has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>優先順位グループ定義は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A precedence group specifies an operator’s precedence relative to other infix operators, as well as the operator’s associativity.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>優先順位グループは、他の接中辞演算子と相対的にある演算子の優先順位を、それだけでなく演算子の結合性も指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A property declaration in a class is written the same way as a constant or variable declaration, except that it is in the context of a class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスの中のプロパティ宣言は、定数または変数の宣言と同じ方法で書かれます、ただしそれはクラスの前後関係の中にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A property that has a property wrapper can include &lt;c0&gt;&lt;s1&gt;willSet&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;didSet&lt;/s3&gt;&lt;/c2&gt; blocks, but it can’t override the compiler-synthesized &lt;c4&gt;&lt;s5&gt;get&lt;/s5&gt;&lt;/c4&gt; or &lt;c6&gt;&lt;s7&gt;set&lt;/s7&gt;&lt;/c6&gt; blocks.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティラッパーを持つプロパティは、&lt;c0&gt;&lt;s1&gt;willSet&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;didSet&lt;/s3&gt;&lt;/c2&gt;ブロックを含むことができます、しかしそれはコンパイラが合成した&lt;c4&gt;&lt;s5&gt;get&lt;/s5&gt;&lt;/c4&gt;または&lt;c6&gt;&lt;s7&gt;set&lt;/s7&gt;&lt;/c6&gt;ブロックをオーバーライドできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A property that normally returns an &lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt; will return an &lt;c2&gt;&lt;s3&gt;Int?&lt;/s3&gt;&lt;/c2&gt; when accessed through optional chaining.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>通常は&lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt;を返すプロパティは、オプショナル連鎖を通してアクセスされるとき&lt;c2&gt;&lt;s3&gt;Int?&lt;/s3&gt;&lt;/c2&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A property wrapper adds a layer of separation between code that manages how a property is stored and the code that defines a property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティラッパーは、プロパティが格納される方法を管理するコードとプロパティを定義するコードとの間に分離のレイヤー（層）を加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A property wrapper can return a value of any type as its projected value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティラッパーは、あらゆる型の値をそれの予測値として返せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A protocol can &lt;e0&gt;inherit&lt;/e0&gt; one or more other protocols and can add further requirements on top of the requirements it inherits.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは、１つ以上の他のプロトコルを&lt;e0&gt;継承する&lt;/e0&gt;ことができて、それが継承する要件の上に、更なる要件を加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A protocol can appear as part of its own requirements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロトコルは、それ自身の要件の一部として現れることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A protocol can be used as the type to be stored in a collection such as an array or a dictionary, as mentioned in &lt;a0&gt;&lt;s1&gt;Protocols as Types&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;型としてのプロトコル&lt;/s1&gt;&lt;/a0&gt;で言及されるように、プロトコルは型として使われることで、コレクション、例えば配列や辞書などに保管されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A protocol can require any conforming type to provide an instance property or type property with a particular name and type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロトコルは、あらゆる準拠型に、特定の名前と型をもつインスタンスプロパティまたは型プロパティを提供するように要求することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A protocol composition type allows you to specify a value whose type conforms to the requirements of multiple protocols without explicitly defining a new, named protocol that inherits from each protocol you want the type to conform to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル合成型は、あなたにそれの型が複数のプロトコルに属する要件に準拠するある値を、あなたがその型に準拠して欲しいプロトコル各々から継承する名前をつけられたある新しいプロトコルを明示的に定義する必要なしに指定させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A public type defaults to having internal members, not public members.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>公開の型は特に何もしない状態では内部のメンバーを持ちます、公開のメンバーではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A public variable can’t be defined as having an internal, file-private, or private type, because the type might not be available everywhere that the public variable is used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>公開の変数は、内部、ファイル外非公開、または非公開の型のものを持つように定義されることができません、なぜなら、その型は公開の変数が使われるあらゆる所で利用可能ではないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A read-only computed property always returns a value, and can be accessed through dot syntax, but cannot be set to a different value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>読み出し専用の計算プロパティは常にある値を返します、そしてドット構文を通してアクセスされることができますが、異なる値に設定されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A recursive function is a straightforward way to work with data that has a recursive structure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>再帰関数は、率直な方法で再帰構造を持つデータを扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A reference to the returned function is stored in a constant called &lt;c16&gt;&lt;s17&gt;moveNearerToZero&lt;/s17&gt;&lt;/c16&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>返された関数への参照は、&lt;c16&gt;&lt;s17&gt;moveNearerToZero&lt;/s17&gt;&lt;/c16&gt;と呼ばれる定数に格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A required initializer must have the same access level as the class it belongs to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>必須イニシャライザは、それが属しているクラスと同じアクセス水準を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A rethrowing function or method can contain a &lt;c0&gt;&lt;s1&gt;throw&lt;/s1&gt;&lt;/c0&gt; statement only inside a &lt;c2&gt;&lt;s3&gt;catch&lt;/s3&gt;&lt;/c2&gt; clause.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>再度スローする関数やメソッドは、&lt;c0&gt;&lt;s1&gt;throw&lt;/s1&gt;&lt;/c0&gt;文を&lt;c2&gt;&lt;s3&gt;catch&lt;/s3&gt;&lt;/c2&gt;節の内部にのみ含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A selector expression lets you access the selector used to refer to a method or to a property’s getter or setter in Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セレクタ式は、あなたに、Objective-Cにおけるあるメソッドをまたはあるプロパティの持つゲッターやセッターを参照するために使われるセレクタにアクセスをさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A semicolon (&lt;c0&gt;&lt;s1&gt;;&lt;/s1&gt;&lt;/c0&gt;) can optionally appear after any statement and is used to separate multiple statements if they appear on the same line.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セミコロン（&lt;c0&gt;&lt;s1&gt;;&lt;/s1&gt;&lt;/c0&gt;）はあらゆる文の後に任意に現れることができて、複数の文をそれらが同じ行に現れる場合に別々に分けるために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A set type cannot be inferred from an array literal alone, so the type &lt;c0&gt;&lt;s1&gt;Set&lt;/s1&gt;&lt;/c0&gt; must be explicitly declared.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>集合の型は配列リテラルのみでは推論されることができません、それで型&lt;c0&gt;&lt;s1&gt;Set&lt;/s1&gt;&lt;/c0&gt;が明示的に宣言されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A sign bit of &lt;c1&gt;&lt;s2&gt;0&lt;/s2&gt;&lt;/c1&gt; means positive, and a sign bit of &lt;c3&gt;&lt;s4&gt;1&lt;/s4&gt;&lt;/c3&gt; means negative.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c1&gt;&lt;s2&gt;0&lt;/s2&gt;&lt;/c1&gt;の符号ビットは正を意味します、そして、&lt;c3&gt;&lt;s4&gt;1&lt;/s4&gt;&lt;/c3&gt;の符号ビットは負であることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A similar principle is used to check for &lt;c6&gt;&lt;s7&gt;Song&lt;/s7&gt;&lt;/c6&gt; instances, and to print an appropriate description (including &lt;c8&gt;&lt;s9&gt;artist&lt;/s9&gt;&lt;/c8&gt; name) whenever a &lt;c10&gt;&lt;s11&gt;Song&lt;/s11&gt;&lt;/c10&gt; is found in the library.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>類似した原則が使用されて、&lt;c6&gt;&lt;s7&gt;Song&lt;/s7&gt;&lt;/c6&gt;インスタンスか確認して、そして&lt;c10&gt;&lt;s11&gt;Song&lt;/s11&gt;&lt;/c10&gt;がlibraryで見つけられるときはいつでも、適切な説明（&lt;c8&gt;&lt;s9&gt;artist&lt;/s9&gt;&lt;/c8&gt;名を含む）を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A simple conditional compilation block has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単純な条件コンパイルブロックは、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A simple way to remember this is:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これを覚えている単純な方法は、以下の通りです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A single expression inside parentheses is a parenthesized expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>丸括弧で囲まれたただ１つだけの式は、括弧で囲まれた式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A single-line string literal is surrounded by double quotation marks and has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単一行の文字列リテラルは、二重引用符によって囲まれて、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A speed of &lt;c14&gt;&lt;s15&gt;35.0&lt;/s15&gt;&lt;/c14&gt; produces a gear of &lt;c16&gt;&lt;s17&gt;4&lt;/s17&gt;&lt;/c16&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>速度&lt;c14&gt;&lt;s15&gt;35.0&lt;/s15&gt;&lt;/c14&gt;はギア&lt;c16&gt;&lt;s17&gt;4&lt;/s17&gt;&lt;/c16&gt;を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stack is a useful collection model whenever you need a strict “last in, first out” approach to managing a collection.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スタックは、厳格に「最後に入れたものが、最初に取り出される」取り組みをコレクションを管理するために必要とするときはいつでも、役に立つコレクション・モデルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stack is an ordered set of values, similar to an array, but with a more restricted set of operations than Swift’s &lt;c2&gt;&lt;s3&gt;Array&lt;/s3&gt;&lt;/c2&gt; type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スタックは、順序付けられたいくつかの値の集合であり、配列に似ています、しかしスウィフトの&lt;c2&gt;&lt;s3&gt;Array&lt;/s3&gt;&lt;/c2&gt;型より制限された操作具合を持つものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stack, however, allows new items to be appended only to the end of the collection (known as &lt;e4&gt;pushing&lt;/e4&gt; a new value on to the stack).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スタックは、しかし、新しい項目をコレクション終わりにのみ追加されることが許されます（新しい値をスタックに&lt;e4&gt;プッシュ&lt;/e4&gt;するとして知られます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A status code of &lt;c5&gt;&lt;s6&gt;404&lt;/s6&gt; &lt;s7&gt;Not&lt;/s7&gt; &lt;s8&gt;Found&lt;/s8&gt;&lt;/c5&gt; is returned if you request a webpage that doesn’t exist.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>状態コード&lt;c5&gt;&lt;s6&gt;404&lt;/s6&gt; &lt;s7&gt;Not&lt;/s7&gt; &lt;s8&gt;Found&lt;/s8&gt;&lt;/c5&gt;は、あなたが存在しないウェブ・ページを要請するならば返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A stored variable or property declared with observers has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オブザーバーとともに宣言される格納変数やプロパティは、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A string delimited by extended delimiters has the following forms:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張区切り記号によって区切られた文字列は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A string delimited by extended delimiters is a sequence of characters surrounded by quotation marks and a balanced set of one or more number signs (&lt;c0&gt;&lt;s1&gt;#&lt;/s1&gt;&lt;/c0&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張区切り記号によって区切られる文字列は、引用符そして均衡のとれたひとまとめの１つ以上のシャープ記号（&lt;c0&gt;&lt;s1&gt;#&lt;/s1&gt;&lt;/c0&gt;）によって囲まれる一連の文字です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A string literal is a sequence of characters surrounded by double quotation marks (&lt;c3&gt;&lt;s4&gt;"&lt;/s4&gt;&lt;/c3&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列リテラルは、二重引用符（&lt;c3&gt;&lt;s4&gt;"&lt;/s4&gt;&lt;/c3&gt;）によって囲まれた一連の文字です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A string literal is a sequence of characters surrounded by quotation marks.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列リテラルは、引用符によって囲まれた一連の文字です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A strong reference cycle can also occur if you assign a closure to a property of a class instance, and the body of that closure captures the instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>強い参照循環はまた、あなたがあるクロージャをクラスインスタンスのプロパティに代入して、そのクロージャの本文がそのインスタンスを捕獲するならば、起こることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A strong reference cycle is created between the two.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>強い参照循環は、２つ作られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A structure or class marked &lt;c2&gt;&lt;s3&gt;usableFromInline&lt;/s3&gt;&lt;/c2&gt; can use only types that are public or &lt;c4&gt;&lt;s5&gt;usableFromInline&lt;/s5&gt;&lt;/c4&gt; for its properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;usableFromInline&lt;/s3&gt;&lt;/c2&gt;で印される構造体またはクラスは、それのプロパティに対してパブリックまたは&lt;c4&gt;&lt;s5&gt;usableFromInline&lt;/s5&gt;&lt;/c4&gt;である型のみに使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A subclass can implement a superclass designated initializer as a subclass convenience initializer as part of satisfying rule 2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブクラスは、規則２を満たすことの一部として、スーパークラスの指定イニシャライザをサブクラスの便宜イニシャライザとして実装することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A subclass can provide its own custom implementation of an instance method, type method, instance property, type property, or subscript that it would otherwise inherit from a superclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブクラスは、それ独自のあつらえの実装のインスタンスメソッド、型メソッド、インスタンスプロパティ、型プロパティ、または添え字を提供することができます、それらはそれがそうしなければスーパークラスから継承するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A subclass can’t have a higher access level than its superclass—for example, you can’t write a public subclass of an internal superclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブクラスには、そのスーパークラスより高いアクセス水準があることができません ― 例えば、あなたは内部のスーパークラスに属する公開のサブクラスを書くことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A subclass inherits its superclass’s deinitializer, which is implicitly called just before the subclass object is deallocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブクラスはそのスーパークラスのデイニシャライザを継承します、それは、サブクラスオブジェクトが割り当て解除される直前に、暗黙のうちに呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A subclass’s implementation of that initializer must also be marked with the &lt;c2&gt;&lt;s3&gt;required&lt;/s3&gt;&lt;/c2&gt; declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのイニシャライザのサブクラスでの実装は、また、&lt;c2&gt;&lt;s3&gt;required&lt;/s3&gt;&lt;/c2&gt;宣言修飾子で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A subscript parameter can have a default value, using the syntax described in &lt;a0&gt;&lt;s1&gt;Special Kinds of Parameters&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字バラメータは省略時の値を持つことができます、&lt;a0&gt;&lt;s1&gt;特別な種類のパラメータ&lt;/s1&gt;&lt;/a0&gt;で記述される構文を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A switch statement over a frozen enumeration doesn’t require a &lt;c0&gt;&lt;s1&gt;default&lt;/s1&gt;&lt;/c0&gt; case, as discussed in &lt;a2&gt;&lt;s3&gt;Switching Over Future Enumeration Cases&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>凍結列挙に対するスイッチ文は、&lt;c0&gt;&lt;s1&gt;default&lt;/s1&gt;&lt;/c0&gt;ケース節を必要しません、&lt;a2&gt;&lt;s3&gt;未来列挙ケース節に対してスイッチする&lt;/s3&gt;&lt;/a2&gt;で議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A target written in Swift 5.2 can depend on a target that’s written in Swift 4.2 or Swift 4, and vice versa.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Swift 5.2で記述されるターゲットは、Swift 4.2またはSwift 4で記述されるターゲットを頼りにできます、そして逆も同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A throwing function propagates errors that are thrown inside of it to the scope from which it’s called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スロー関数は、それの内部でスローされるエラーを、そこからそれが呼び出されるスコープへと伝えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A throwing method can’t override a nonthrowing method, and a throwing method can’t satisfy a protocol requirement for a nonthrowing method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スローメソッドは、非スローメソッドをオーバーライドすることができません、そしてスローメソッドは、非スローメソッド用のプロトコル要件を満たすことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A throwing method can’t override a rethrowing method, and a throwing method can’t satisfy a protocol requirement for a rethrowing method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スローメソッドは、再スローメソッドをオーバーライドできません、そしてスローメソッドは再スローメソッド用のプロトコル要件を満たすことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A token consists of an identifier, keyword, punctuation, literal, or operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるトークンは１つの識別子、キーワード、句読点、リテラル、または演算子からなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A trailing closure is written after the function call’s parentheses, even though it is still an argument to the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>後付クロージャは、関数呼び出しの丸括弧の後に書かれます、それでもそれはまだその関数に対する引数であるけれども。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A tuple expression can contain zero expressions, or it can contain two or more expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプル式はゼロ個の式を含むことができます、またはそれは２つまたはそれ以上の式を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A tuple type’s access level is determined automatically from the types that make up the tuple type, and can’t be specified explicitly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるタプル型のアクセス水準は、そのタプル型を作り上げる型から自動的に決定されます、したがって明示的に指定されることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A type alias can forward an existing type’s generic parameters by omitting all generic parameters from the declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型エイリアスは、既存の型の持つ総称体パラメータを、全ての総称体パラメータを宣言から省略することによって、転送できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A type alias can have an access level less than or equal to the access level of the type it aliases.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型エイリアスは、それがエイリアスする型のアクセス水準と同等またはそれより下のアクセス水準を持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A type alias declaration can use generic parameters to give a name to an existing generic type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型エイリアス宣言は、総称体パラメータを使ってある名前を既存の総称体型に与えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A type alias whose underlying type is a protocol composition type, a protocol, or a class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それの基礎をなす型がプロトコル合成型、プロトコル、またはクラスである型エイリアス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A type can conform to a protocol with a lower access level than the type itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型は、その型自体よりも低いアクセス水準を持つプロトコルに準拠することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A type inheritance clause begins with a colon (&lt;c1&gt;&lt;s2&gt;:&lt;/s2&gt;&lt;/c1&gt;), followed by a list of type identifiers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型継承節はコロン（&lt;c1&gt;&lt;s2&gt;:&lt;/s2&gt;&lt;/c1&gt;）で始まり、型識別子のリストが続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A type inheritance clause in an enumeration definition can be either a list of protocols, or in the case of an enumeration that assigns raw values to its cases, a single, named type that specifies the type of those raw values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙定義における型継承節は、プロトコルのリスト、または生の値をそれのケース節に割り当てる列挙のケース節においては、それらの生の値を指定する単一の名前付き型、このどちらかであることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A type method can call another type method with the other method’s name, without needing to prefix it with the type name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型メソッドは、別の型メソッドを他のメソッドの名前を使って呼ぶことができます、その型名をそれの前に置く必要なしに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A type must be &lt;e0&gt;hashable&lt;/e0&gt; in order to be stored in a set—that is, the type must provide a way to compute a &lt;e1&gt;hash value&lt;/e1&gt; for itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型は、集合のキー型として使われるために&lt;e0&gt;ハッシュ化される&lt;/e0&gt;必要があります ― すなわち、その型はそれ自身で&lt;e1&gt;ハッシュ値&lt;/e1&gt;を計算するためのある方法を提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A type safe language encourages you to be clear about the types of values your code can work with.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型安全な言語は、あなたのコードが扱うことができる値の型について、あなたが確信を持つように促します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A value can be used as an instance of the opaque type only if it’s an instance of a type that conforms to the listed protocol or protocol composition, or inherits from the listed class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値は、不透明型のインスタンスとして使われることが、それが、そのリストされたプロトコルまたはプロトコル合成に準拠する、またはリストされたクラスから継承するある型のインスタンスである場合にのみ、可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A value of &lt;c6&gt;&lt;s7&gt;true&lt;/s7&gt;&lt;/c6&gt; in the array represents a black square and a value of &lt;c8&gt;&lt;s9&gt;false&lt;/s9&gt;&lt;/c8&gt; represents a white square.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この配列の中の&lt;c6&gt;&lt;s7&gt;true&lt;/s7&gt;&lt;/c6&gt;の値は黒の正方形を表します、そして&lt;c8&gt;&lt;s9&gt;false&lt;/s9&gt;&lt;/c8&gt;の値は白い正方形を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A variadic parameter is treated as an array that contains elements of the base type name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>可変長パラメータは、基本の型の名前の要素たちが入っている配列とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A wrapper that needs to expose more information can return an instance of some other data type, or it can return &lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt; to expose the instance of the wrapper as its projected value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらに情報を露出する必要があるラッパーは、何らかの他のデータ型のインスタンスを返せます、またはそれは、&lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;を返すことでラッパーのインスタンスをそれの予測値として露出できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ARC automatically frees up the memory used by class instances when those instances are no longer needed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ARCはクラスインスタンスによって使われるメモリを、それらのインスタンスがもはや必要でないとき、自動的に自由にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ARC does not deallocate the &lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt; instance until the third and final strong reference is broken, at which point it’s clear that you are no longer using the &lt;c2&gt;&lt;s3&gt;Person&lt;/s3&gt;&lt;/c2&gt; instance:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ARCは、&lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt;インスタンスの割り当て解除を３番目で最後に残ったの強い参照が壊れるまで行いません、その時点では、あなたがもはや&lt;c2&gt;&lt;s3&gt;Person&lt;/s3&gt;&lt;/c2&gt;インスタンスを使っていないことは明白です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ARC in Action</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ARCの動作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ARC will not deallocate an instance as long as at least one active reference to that instance still exists.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ARCは、そのインスタンスへの少なくとも１つの活発な参照がまだ存在する限り、インスタンスの割り当て解除をしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>About Swift</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトについて</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>About the Language Reference</seg>
      </tuv>
      <tuv lang="JA">
        <seg>言語リファレンスについて</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Abstract concepts like &lt;c0&gt;&lt;s1&gt;Hashable&lt;/s1&gt;&lt;/c0&gt; characterize types in terms of their conceptual characteristics, rather than their concrete type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Hashable&lt;/s1&gt;&lt;/c0&gt;のような抽象的な概念たちは、それらの概念上の特徴の観点から型を特徴づけます、その具象型そのものではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Access Control</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アクセス制御</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Access Control Levels</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アクセス制御水準</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Access Control Syntax</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アクセス制御構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Access Levels</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アクセス水準</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Access Levels for Frameworks</seg>
      </tuv>
      <tuv lang="JA">
        <seg>フレームワークのためのアクセス水準</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Access Levels for Single-Target Apps</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単一ターゲットアプリのためのアクセス水準</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Access Levels for Unit Test Targets</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユニットテストターゲットのためのアクセス水準</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Access control is discussed in detail in &lt;a0&gt;&lt;s1&gt;Access Control&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アクセス制御は、&lt;a0&gt;&lt;s1&gt;アクセス制御&lt;/s1&gt;&lt;/a0&gt;で詳細に議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Access levels in Swift follow an overall guiding principle: &lt;e0&gt;No entity can be defined in terms of another entity that has a lower (more restrictive) access level.&lt;/e0&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの中のアクセス水準は、以下の全体的な原理指針に従います：&lt;e0&gt;実在は、より低い（制限のより多い）アクセス水準をもつ別の実在の観点から定義されることができない。&lt;/e0&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Access properties of a class instance with dot (&lt;c0&gt;&lt;s1&gt;.&lt;/s1&gt;&lt;/c0&gt;) syntax, as described in &lt;a2&gt;&lt;s3&gt;Accessing Properties&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスインスタンスのプロパティにドット（&lt;c0&gt;&lt;s1&gt;.&lt;/s1&gt;&lt;/c0&gt;）構文でアクセスしてください、&lt;a2&gt;&lt;s3&gt;プロパティにアクセスする&lt;/s3&gt;&lt;/a2&gt;で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Access to memory happens in your code when you do things like set the value of a variable or pass an argument to a function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メモリへのアクセスは、あなたが変数の値を設定するまたは関数に引数を渡すといったような事を行う時にあなたのコードで起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Access to that member is never inlined or devirtualized by the compiler.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのメンパーに対するアクセスは、決してコンパイラによってインラインまたはデバーチャライズされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing Enumeration Cases</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙ケース節にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing Properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティにアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing Properties Through Optional Chaining</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖を通してプロパティにアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing Subscripts Through Optional Chaining</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖を通して添え字にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing Subscripts of Optional Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル型の添え字にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing Superclass Methods, Properties, and Subscripts</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラスメソッド、プロパティ、そして添え字へのアクセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing and Modifying a Dictionary</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書へのアクセスと変更</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing and Modifying a Set</seg>
      </tuv>
      <tuv lang="JA">
        <seg>集合へのアクセスと変更</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing and Modifying a String</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列へのアクセスと修正</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing and Modifying an Array</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列へのアクセスと変更</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing the original is a simultaneous access of the value, which violates Swift’s memory exclusivity guarantee.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>元のものにアクセスすることは、その値に対する同時的なアクセスです、それはスウィフトのメモリ排他保証を破ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Add a &lt;c0&gt;&lt;s1&gt;color()&lt;/s1&gt;&lt;/c0&gt; method to &lt;c2&gt;&lt;s3&gt;Suit&lt;/s3&gt;&lt;/c2&gt; that returns “black” for spades and clubs, and returns “red” for hearts and diamonds.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;color()&lt;/s1&gt;&lt;/c0&gt;メソッドを&lt;c2&gt;&lt;s3&gt;Suit&lt;/s3&gt;&lt;/c2&gt;に加えてください、それはスペードとクラブのために「黒」を、そしてハートとダイヤのために「赤」を返すものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Add a constant property with &lt;c0&gt;&lt;s1&gt;let&lt;/s1&gt;&lt;/c0&gt;, and add another method that takes an argument.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数プロパティを&lt;c0&gt;&lt;s1&gt;let&lt;/s1&gt;&lt;/c0&gt;を使って１つ加えてください、そして１つの引数をとる別のメソッドを加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Add a parameter to include today’s lunch special in the greeting.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>今日のスペシャル・ランチをこの挨拶に含めるために、パラメータをひとつ加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Add a third case to &lt;c0&gt;&lt;s1&gt;ServerResponse&lt;/s1&gt;&lt;/c0&gt; and to the switch.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第３の場合を&lt;c0&gt;&lt;s1&gt;ServerResponse&lt;/s1&gt;&lt;/c0&gt;に、そしてスイッチに加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Add an &lt;c4&gt;&lt;s5&gt;else&lt;/s5&gt;&lt;/c4&gt; clause that sets a different greeting if &lt;c6&gt;&lt;s7&gt;optionalName&lt;/s7&gt;&lt;/c6&gt; is &lt;c8&gt;&lt;s9&gt;nil&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;optionalName&lt;/s7&gt;&lt;/c6&gt;が&lt;c8&gt;&lt;s9&gt;nil&lt;/s9&gt;&lt;/c8&gt;ならば異なる挨拶を設定する&lt;c4&gt;&lt;s5&gt;else&lt;/s5&gt;&lt;/c4&gt;節を加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Add another requirement to &lt;c0&gt;&lt;s1&gt;ExampleProtocol&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>別の要件を&lt;c0&gt;&lt;s1&gt;ExampleProtocol&lt;/s1&gt;&lt;/c0&gt;に加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Add another variable to keep track of which kind of number was the largest, as well as what that largest number was.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最も大きい数が何であったかだけでなく、どの種類の数が最も大きいものであったかについて情報を把握するために、もう１つの変数を加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Add code to throw an error inside the &lt;c0&gt;&lt;s1&gt;do&lt;/s1&gt;&lt;/c0&gt; block.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コードを加えてエラーを&lt;c0&gt;&lt;s1&gt;do&lt;/s1&gt;&lt;/c0&gt;ブロック内部でスローしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Add computed instance properties and computed type properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>計算インスタンスプロパティと計算型プロパティを加える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added &lt;c0&gt;&lt;s1&gt;macCatalyst&lt;/s1&gt;&lt;/c0&gt; to the list of target environments in &lt;a2&gt;&lt;s3&gt;Conditional Compilation Block&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;macCatalyst&lt;/s1&gt;&lt;/c0&gt;をターゲット環境のリストに加えました、&lt;a2&gt;&lt;s3&gt;条件コンパイルブロック&lt;/s3&gt;&lt;/a2&gt;において。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a description of &lt;a0&gt;&lt;s1&gt;Failable Initializer Requirements&lt;/s1&gt;&lt;/a0&gt; for protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティのための&lt;a0&gt;&lt;s1&gt;失敗できるイニシャライザ要件&lt;/s1&gt;&lt;/a0&gt;の説明を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a full guide to &lt;a0&gt;&lt;s1&gt;Failable Initializers&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>完全なガイドを&lt;a0&gt;&lt;s1&gt;失敗できるイニシャライザ&lt;/s1&gt;&lt;/a0&gt;に加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a new chapter about &lt;a0&gt;&lt;s1&gt;Access Control&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい章を&lt;a0&gt;&lt;s1&gt;アクセス制御&lt;/s1&gt;&lt;/a0&gt;について加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a new guide section about &lt;a0&gt;&lt;s1&gt;String Indices&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;文字列インデックス&lt;/s1&gt;&lt;/a0&gt;についての新しいガイド節を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a new reference section about &lt;a0&gt;&lt;s1&gt;Failable Initializers&lt;/s1&gt;&lt;/a0&gt;, which can trigger initialization failure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しいリファレンス節を&lt;a0&gt;&lt;s1&gt;失敗できるイニシャライザ&lt;/s1&gt;&lt;/a0&gt;について加えました、それは初期化失敗を起こすことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a new section about &lt;a0&gt;&lt;s1&gt;Accessing Subscripts of Optional Type&lt;/s1&gt;&lt;/a0&gt; through optional chaining.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖を通して&lt;a0&gt;&lt;s1&gt;オプショナル型の添え字にアクセスする&lt;/s1&gt;&lt;/a0&gt;ことについての新しい節を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a new section about &lt;a0&gt;&lt;s1&gt;Class-Only Protocols&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;クラス専用プロトコル&lt;/s1&gt;&lt;/a0&gt;についての新しい節を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a new section about &lt;a0&gt;&lt;s1&gt;Dictionary Type Shorthand Syntax&lt;/s1&gt;&lt;/a0&gt;, which is written as &lt;c2&gt;&lt;s3&gt;[KeyType:&lt;/s3&gt; &lt;s4&gt;ValueType]&lt;/s4&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;辞書型の略記構文&lt;/s1&gt;&lt;/a0&gt;についての新しい節を加えました、それは&lt;c2&gt;&lt;s3&gt;[KeyType:&lt;/s3&gt; &lt;s4&gt;ValueType]&lt;/s4&gt;&lt;/c2&gt;のように書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a new section about &lt;a0&gt;&lt;s1&gt;Hash Values for Set Types&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;Set型のためのハッシュ値&lt;/s1&gt;&lt;/a0&gt;についての新しい節を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a new section about &lt;a0&gt;&lt;s1&gt;Initializer Parameters Without Argument Labels&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;引数ラベルなしのイニシャライザ・パラメーター&lt;/s1&gt;&lt;/a0&gt;についての新しい節を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a new section about &lt;a0&gt;&lt;s1&gt;Initializer Requirements&lt;/s1&gt;&lt;/a0&gt; in protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルに&lt;a0&gt;&lt;s1&gt;イニシャライザ要件&lt;/s1&gt;&lt;/a0&gt;についての新しい節を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a new section about &lt;a0&gt;&lt;s1&gt;Optional Tuple Return Types&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;オプショナルタプルの戻り型&lt;/s1&gt;&lt;/a0&gt;についての新しい節を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a new section about &lt;a0&gt;&lt;s1&gt;Required Initializers&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;必須イニシャライザ&lt;/s1&gt;&lt;/a0&gt;についての新しい節を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a note about the order in which &lt;a0&gt;&lt;s1&gt;Prefix and Postfix Operators&lt;/s1&gt;&lt;/a0&gt; are applied when both a prefix and a postfix operator are applied to the same operand.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;接頭辞および接尾辞演算子&lt;/s1&gt;&lt;/a0&gt;の両方が同じ演算数に適用される時に、接頭辞および接尾辞演算子が適用される順番についての注記を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a note that the start value &lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt;&lt;/c0&gt; for the &lt;a2&gt;&lt;s3&gt;Range Operators&lt;/s3&gt;&lt;/a2&gt; &lt;c4&gt;&lt;s5&gt;a...b&lt;/s5&gt;&lt;/c4&gt; and &lt;c6&gt;&lt;s7&gt;a..&lt;b&lt;/s7&gt;&lt;/c6&gt; must not be greater than the end value &lt;c8&gt;&lt;s9&gt;b&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>開始値&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt;&lt;/c0&gt;は&lt;a2&gt;&lt;s3&gt;範囲演算子&lt;/s3&gt;&lt;/a2&gt;の&lt;c4&gt;&lt;s5&gt;a...b&lt;/s5&gt;&lt;/c4&gt;と&lt;c6&gt;&lt;s7&gt;a..&lt;b&lt;/s7&gt;&lt;/c6&gt;に対して、終了値&lt;c8&gt;&lt;s9&gt;b&lt;/s9&gt;&lt;/c8&gt;より大きくてはならないことの注意を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a note to the &lt;a0&gt;&lt;s1&gt;Access Levels&lt;/s1&gt;&lt;/a0&gt; section with information about the scope of &lt;c2&gt;&lt;s3&gt;private&lt;/s3&gt;&lt;/c2&gt; access.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節&lt;a0&gt;&lt;s1&gt;アクセス水準&lt;/s1&gt;&lt;/a0&gt;に&lt;c2&gt;&lt;s3&gt;private&lt;/s3&gt;&lt;/c2&gt;アクセスのスコープについての情報の注意書きを加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a note to the &lt;a0&gt;&lt;s1&gt;Debugging with Assertions&lt;/s1&gt;&lt;/a0&gt; section about when user-defined assertions are disabled.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;表明を使ってデバッグする&lt;/s1&gt;&lt;/a0&gt;節に、ユーザ定義の表明が使用不能にされた時についての注を加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a note to the &lt;a0&gt;&lt;s1&gt;Handling Errors&lt;/s1&gt;&lt;/a0&gt; section about the performance of executing a &lt;c2&gt;&lt;s3&gt;throw&lt;/s3&gt;&lt;/c2&gt; statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;エラーを処理する&lt;/s1&gt;&lt;/a0&gt;節に&lt;c2&gt;&lt;s3&gt;throw&lt;/s3&gt;&lt;/c2&gt;文の実行性能について注意を追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a note to the &lt;a0&gt;&lt;s1&gt;Metatype Type&lt;/s1&gt;&lt;/a0&gt; section about constructing class instances from metatype values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メタタイプ値からクラスインスタンスを構成することについての注を&lt;a0&gt;&lt;s1&gt;メタタイプ型&lt;/s1&gt;&lt;/a0&gt;節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a note to the &lt;a0&gt;&lt;s1&gt;Property Observers&lt;/s1&gt;&lt;/a0&gt; section about property observers being called when you pass a property as an in-out parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある注意を&lt;a0&gt;&lt;s1&gt;プロパティオブザーバー&lt;/s1&gt;&lt;/a0&gt;節に加えました、あなたがあるプロパティをin-outパラメータとして渡すとき呼び出されているプロパティオブザーバーについて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a note to the &lt;a0&gt;&lt;s1&gt;Rethrowing Functions and Methods&lt;/s1&gt;&lt;/a0&gt; section that rethrowing functions can’t directly throw errors.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある注意を&lt;a0&gt;&lt;s1&gt;再スローを行う関数とメソッド&lt;/s1&gt;&lt;/a0&gt;節に加えた、それは再スロー関数が直接にエラーをスローできないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a note to the &lt;a0&gt;&lt;s1&gt;Type Casting for Any and AnyObject&lt;/s1&gt;&lt;/a0&gt; section about using an optional value when a value of type &lt;c2&gt;&lt;s3&gt;Any&lt;/s3&gt;&lt;/c2&gt; is expected.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとつの注を&lt;a0&gt;&lt;s1&gt;AnyおよびAnyObjectに対する型キャスト&lt;/s1&gt;&lt;/a0&gt;の節へ型&lt;c2&gt;&lt;s3&gt;Any&lt;/s3&gt;&lt;/c2&gt;の値が期待される時にオプショナル値を使うことについて加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a note to the &lt;a0&gt;&lt;s1&gt;Weak References&lt;/s1&gt;&lt;/a0&gt; section about the differences in weak references between garbage collected systems and ARC.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節&lt;a0&gt;&lt;s1&gt;弱い参照&lt;/s1&gt;&lt;/a0&gt;にガベージコレクトシステムとARCとの間の弱い参照における違いについての情報の注意書きを加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a note to the &lt;a0&gt;&lt;s1&gt;Weak References&lt;/s1&gt;&lt;/a0&gt; section about weak references being unsuitable for caching.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キャッシュするのにふさわしくない弱い参照についての注を&lt;a0&gt;&lt;s1&gt;弱い参照&lt;/s1&gt;&lt;/a0&gt;節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added a section about error handling to the &lt;a0&gt;&lt;s1&gt;A Swift Tour&lt;/s1&gt;&lt;/a0&gt; chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラー処理についての節を&lt;a0&gt;&lt;s1&gt;スウィフトツアー&lt;/s1&gt;&lt;/a0&gt;章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added an example of &lt;a0&gt;&lt;s1&gt;Extending a Generic Type&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;総称体型を拡張する&lt;/s1&gt;&lt;/a0&gt;の例を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added an example of failable numeric conversions to the &lt;a0&gt;&lt;s1&gt;Failable Initializers&lt;/s1&gt;&lt;/a0&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できる数値変換の例を、&lt;a0&gt;&lt;s1&gt;失敗できるイニシャライザ&lt;/s1&gt;&lt;/a0&gt;の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added an example of using multiple optional bindings with a &lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt; clause to the &lt;a2&gt;&lt;s3&gt;Optional Binding&lt;/s3&gt;&lt;/a2&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数のオプショナル束縛を&lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt;節とともに使う例を&lt;a2&gt;&lt;s3&gt;オプショナルの束縛&lt;/s3&gt;&lt;/a2&gt;節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added an example that uses the &lt;c0&gt;&lt;s1&gt;??&lt;/s1&gt;&lt;/c0&gt; operator to the &lt;a2&gt;&lt;s3&gt;A Swift Tour&lt;/s3&gt;&lt;/a2&gt; chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;??&lt;/s1&gt;&lt;/c0&gt;演算子を使う例を&lt;a2&gt;&lt;s3&gt;スウィフトツアー&lt;/s3&gt;&lt;/a2&gt;節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added examples of iterating over a range to the &lt;a0&gt;&lt;s1&gt;For-In Loops&lt;/s1&gt;&lt;/a0&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある範囲のすべてにわたって反復する例を&lt;a0&gt;&lt;s1&gt;for-inループ&lt;/s1&gt;&lt;/a0&gt;の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about &lt;c0&gt;&lt;s1&gt;#dsohandle&lt;/s1&gt;&lt;/c0&gt; to the &lt;a2&gt;&lt;s3&gt;Literal Expression&lt;/s3&gt;&lt;/a2&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;#dsohandle&lt;/s1&gt;&lt;/c0&gt;についての情報を&lt;a2&gt;&lt;s3&gt;リテラル式&lt;/s3&gt;&lt;/a2&gt;の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about &lt;c0&gt;&lt;s1&gt;#error&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;#warning&lt;/s3&gt;&lt;/c2&gt; to the &lt;a4&gt;&lt;s5&gt;Compile-Time Diagnostic Statement&lt;/s5&gt;&lt;/a4&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;#error&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;#warning&lt;/s3&gt;&lt;/c2&gt;についての情報を&lt;a4&gt;&lt;s5&gt;コンパイル時診断文&lt;/s5&gt;&lt;/a4&gt;の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about API availability checking to the &lt;a0&gt;&lt;s1&gt;Checking API Availability&lt;/s1&gt;&lt;/a0&gt; section of the &lt;a2&gt;&lt;s3&gt;Control Flow&lt;/s3&gt;&lt;/a2&gt; chapter and the &lt;a4&gt;&lt;s5&gt;Availability Condition&lt;/s5&gt;&lt;/a4&gt; section of the &lt;a6&gt;&lt;s7&gt;Statements&lt;/s7&gt;&lt;/a6&gt; chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>API有効性確認についての情報を節&lt;a0&gt;&lt;s1&gt;API有効性の確認&lt;/s1&gt;&lt;/a0&gt;に章&lt;a2&gt;&lt;s3&gt;制御の流れ&lt;/s3&gt;&lt;/a2&gt;で、そして節&lt;a4&gt;&lt;s5&gt;有効性条件&lt;/s5&gt;&lt;/a4&gt;に章&lt;a6&gt;&lt;s7&gt;文&lt;/s7&gt;&lt;/a6&gt;で追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about access control for unit testing to the &lt;a0&gt;&lt;s1&gt;Access Levels for Unit Test Targets&lt;/s1&gt;&lt;/a0&gt; section of the &lt;a2&gt;&lt;s3&gt;Access Control&lt;/s3&gt;&lt;/a2&gt; chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユニットテストのためのアクセス制御についての情報を&lt;a0&gt;&lt;s1&gt;ユニットテストターゲットのためのアクセス水準&lt;/s1&gt;&lt;/a0&gt;の節に&lt;a2&gt;&lt;s3&gt;アクセス制御&lt;/s3&gt;&lt;/a2&gt;の章で追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about accessing all of an enumeration’s cases to the &lt;a0&gt;&lt;s1&gt;Iterating over Enumeration Cases&lt;/s1&gt;&lt;/a0&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙の持つケース節の全てにアクセスすることについての情報を&lt;a0&gt;&lt;s1&gt;列挙ケース節の全てにわたって反復する&lt;/s1&gt;&lt;/a0&gt;の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about accessing the selector of an Objective-C property’s getter or setter to the &lt;a0&gt;&lt;s1&gt;Selector Expression&lt;/s1&gt;&lt;/a0&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cプロパティのゲッターやセッターのセレクタにアクセスすることについての情報を&lt;a0&gt;&lt;s1&gt;セレクタ式&lt;/s1&gt;&lt;/a0&gt;の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about build configuration and line control statements to the &lt;a0&gt;&lt;s1&gt;Compiler Control Statements&lt;/s1&gt;&lt;/a0&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビルド設定および行制御文についての情報を&lt;a0&gt;&lt;s1&gt;コンパイラ制御文&lt;/s1&gt;&lt;/a0&gt;節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about comparing tuples to the &lt;a0&gt;&lt;s1&gt;Comparison Operators&lt;/s1&gt;&lt;/a0&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプルの比較についての情報を&lt;a0&gt;&lt;s1&gt;比較演算子&lt;/s1&gt;&lt;/a0&gt;節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about conditional protocol conformance to the &lt;a0&gt;&lt;s1&gt;Extension Declaration&lt;/s1&gt;&lt;/a0&gt; section of the &lt;a2&gt;&lt;s3&gt;Declarations&lt;/s3&gt;&lt;/a2&gt; chapter, and to the &lt;a4&gt;&lt;s5&gt;Conditionally Conforming to a Protocol&lt;/s5&gt;&lt;/a4&gt; section of the &lt;a6&gt;&lt;s7&gt;Protocols&lt;/s7&gt;&lt;/a6&gt; chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>条件プロトコル準拠についての情報を&lt;a0&gt;&lt;s1&gt;拡張宣言&lt;/s1&gt;&lt;/a0&gt;の節に&lt;a2&gt;&lt;s3&gt;宣言&lt;/s3&gt;&lt;/a2&gt;章で、そして&lt;a4&gt;&lt;s5&gt;あるプロトコルに条件付きで準拠する&lt;/s5&gt;&lt;/a4&gt;の節に&lt;a6&gt;&lt;s7&gt;プロトコル&lt;/s7&gt;&lt;/a6&gt;章で加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about dynamic members that are looked up by key path at runtime to the &lt;a0&gt;&lt;s1&gt;dynamicMemberLookup&lt;/s1&gt;&lt;/a0&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実行時にキーパスによって検索される動的メンバーについての情報を&lt;a0&gt;&lt;s1&gt;dynamicMemberLookup&lt;/s1&gt;&lt;/a0&gt;の節に加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about error handling to the &lt;a0&gt;&lt;s1&gt;Error Handling&lt;/s1&gt;&lt;/a0&gt; chapter, the &lt;a2&gt;&lt;s3&gt;Do Statement&lt;/s3&gt;&lt;/a2&gt; section, the &lt;a4&gt;&lt;s5&gt;Throw Statement&lt;/s5&gt;&lt;/a4&gt; section, the &lt;a6&gt;&lt;s7&gt;Defer Statement&lt;/s7&gt;&lt;/a6&gt; section, and the &lt;a8&gt;&lt;s9&gt;Try Operator&lt;/s9&gt;&lt;/a8&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラー処理についての情報を章&lt;a0&gt;&lt;s1&gt;エラー処理&lt;/s1&gt;&lt;/a0&gt;、節&lt;a2&gt;&lt;s3&gt;do文&lt;/s3&gt;&lt;/a2&gt;、節&lt;a4&gt;&lt;s5&gt;throw文&lt;/s5&gt;&lt;/a4&gt;、節&lt;a6&gt;&lt;s7&gt;defer文&lt;/s7&gt;&lt;/a6&gt;、そして節&lt;a8&gt;&lt;s9&gt;try演算子&lt;/s9&gt;&lt;/a8&gt;に追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about exclusive access to memory to the &lt;a0&gt;&lt;s1&gt;Memory Safety&lt;/s1&gt;&lt;/a0&gt; chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メモリに対する排他アクセスについての情報を&lt;a0&gt;&lt;s1&gt;メモリ安全&lt;/s1&gt;&lt;/a0&gt;の章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about explicitly referencing an initializer to the &lt;a0&gt;&lt;s1&gt;Initializer Expression&lt;/s1&gt;&lt;/a0&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>明示的にあるイニシャライザを参照することについての情報を&lt;a0&gt;&lt;s1&gt;イニシャライザ式&lt;/s1&gt;&lt;/a0&gt;節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about functions that specify a protocol that their return value conforms to, instead of providing a specific named return type, to the &lt;a0&gt;&lt;s1&gt;Opaque Types&lt;/s1&gt;&lt;/a0&gt; chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある指定された名前付き戻り型を提供する代わりに、それらの戻り値が準拠するあるプロトコルを指定する関数それらについての情報を&lt;a0&gt;&lt;s1&gt;不透明型&lt;/s1&gt;&lt;/a0&gt;の章へ加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about how to conditionally compile code depending on the Swift compiler version being used to the &lt;a0&gt;&lt;s1&gt;Conditional Compilation Block&lt;/s1&gt;&lt;/a0&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>使われているスウィフトコンパイラバージョンに基づいて条件付きでコードをコンパイルする方法についての情報を&lt;a0&gt;&lt;s1&gt;条件コンパイルブロック&lt;/s1&gt;&lt;/a0&gt;の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about how to conditionally compile code depending on the version of Swift being used to the &lt;a0&gt;&lt;s1&gt;Conditional Compilation Block&lt;/s1&gt;&lt;/a0&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>使われているスウィフトのバージョンに基づいて条件付きでコードをコンパイルする方法についての情報を&lt;a0&gt;&lt;s1&gt;条件コンパイルブロック&lt;/s1&gt;&lt;/a0&gt;節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about how to distinguish between methods or initializers whose names differ only by the names of their arguments to the &lt;a0&gt;&lt;s1&gt;Explicit Member Expression&lt;/s1&gt;&lt;/a0&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの名前がそれらの引数の名前でだけ異なるところのメソッド間またはイニシャライザ間で区別をする方法についての情報を&lt;a0&gt;&lt;s1&gt;明示的メンバー式&lt;/s1&gt;&lt;/a0&gt;節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about how type inference works with &lt;a0&gt;&lt;s1&gt;Literals&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型推論が&lt;a0&gt;&lt;s1&gt;リテラル&lt;/s1&gt;&lt;/a0&gt;で働く方法についての情報を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about inlining to the &lt;a0&gt;&lt;s1&gt;Declaration Attributes&lt;/s1&gt;&lt;/a0&gt; section under the &lt;c2&gt;&lt;s3&gt;inlinable&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;usableFromInline&lt;/s5&gt;&lt;/c4&gt; attributes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インラインについての情報を&lt;a0&gt;&lt;s1&gt;宣言属性&lt;/s1&gt;&lt;/a0&gt;の節に&lt;c2&gt;&lt;s3&gt;inlinable&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;usableFromInline&lt;/s5&gt;&lt;/c4&gt;属性の下で加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about members that are looked up by name at runtime to the &lt;a0&gt;&lt;s1&gt;Declaration Attributes&lt;/s1&gt;&lt;/a0&gt; section under the &lt;c2&gt;&lt;s3&gt;dynamicMemberLookup&lt;/s3&gt;&lt;/c2&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実行時に名前によって捜されるメンバについての情報を&lt;a0&gt;&lt;s1&gt;宣言属性&lt;/s1&gt;&lt;/a0&gt;の節に&lt;c2&gt;&lt;s3&gt;dynamicMemberLookup&lt;/s3&gt;&lt;/c2&gt;属性の下で加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about multiline string literals to the &lt;a0&gt;&lt;s1&gt;String Literals&lt;/s1&gt;&lt;/a0&gt; section of the &lt;a2&gt;&lt;s3&gt;Strings and Characters&lt;/s3&gt;&lt;/a2&gt; chapter, and to the &lt;a4&gt;&lt;s5&gt;String Literals&lt;/s5&gt;&lt;/a4&gt; section of the &lt;a6&gt;&lt;s7&gt;Lexical Structure&lt;/s7&gt;&lt;/a6&gt; chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数行文字列リテラルについての情報を&lt;a0&gt;&lt;s1&gt;文字列リテラル&lt;/s1&gt;&lt;/a0&gt;の節へ&lt;a2&gt;&lt;s3&gt;文字列と文字&lt;/s3&gt;&lt;/a2&gt;の章で、そして&lt;a4&gt;&lt;s5&gt;文字列リテラル&lt;/s5&gt;&lt;/a4&gt;の節へ&lt;a6&gt;&lt;s7&gt;語彙の構造&lt;/s7&gt;&lt;/a6&gt;の章で加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about operator precedence groups to the &lt;a0&gt;&lt;s1&gt;Precedence for Custom Infix Operators&lt;/s1&gt;&lt;/a0&gt; section of the &lt;a2&gt;&lt;s3&gt;Advanced Operators&lt;/s3&gt;&lt;/a2&gt; chapter, and to the &lt;a4&gt;&lt;s5&gt;Precedence Group Declaration&lt;/s5&gt;&lt;/a4&gt; section of the &lt;a6&gt;&lt;s7&gt;Declarations&lt;/s7&gt;&lt;/a6&gt; chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子優先順位グループについての情報を&lt;a0&gt;&lt;s1&gt;あつらえの演算子に対する優先順位&lt;/s1&gt;&lt;/a0&gt;の節に&lt;a2&gt;&lt;s3&gt;先進の演算子&lt;/s3&gt;&lt;/a2&gt;の章で、そして&lt;a4&gt;&lt;s5&gt;優先順位グループ定義&lt;/s5&gt;&lt;/a4&gt;の節に&lt;a6&gt;&lt;s7&gt;宣言&lt;/s7&gt;&lt;/a6&gt;の章で加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about passing a key path instead of a closure to the &lt;a0&gt;&lt;s1&gt;Key-Path Expression&lt;/s1&gt;&lt;/a0&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キーパスをクロージャの代わりに渡すことについての情報を&lt;a0&gt;&lt;s1&gt;キーパス式&lt;/s1&gt;&lt;/a0&gt;の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about playground literals to the &lt;a0&gt;&lt;s1&gt;Literal Expression&lt;/s1&gt;&lt;/a0&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プレイグラウンドリテラルについての情報を&lt;a0&gt;&lt;s1&gt;リテラル式&lt;/s1&gt;&lt;/a0&gt;の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about preconditions and fatal errors to the &lt;a0&gt;&lt;s1&gt;Assertions and Preconditions&lt;/s1&gt;&lt;/a0&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>前提条件と致命的なエラーについての情報を&lt;a0&gt;&lt;s1&gt;表明と前提条件&lt;/s1&gt;&lt;/a0&gt;の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about property wrappers to the &lt;a0&gt;&lt;s1&gt;Property Wrappers&lt;/s1&gt;&lt;/a0&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティラッパーについての情報を&lt;a0&gt;&lt;s1&gt;プロパティラッパー&lt;/s1&gt;&lt;/a0&gt;の節に加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about protocol extensions to the &lt;a0&gt;&lt;s1&gt;Protocol Extensions&lt;/s1&gt;&lt;/a0&gt; section of the &lt;a2&gt;&lt;s3&gt;Protocols&lt;/s3&gt;&lt;/a2&gt; chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル拡張についての情報を&lt;a0&gt;&lt;s1&gt;プロトコル拡張&lt;/s1&gt;&lt;/a0&gt;の節に&lt;a2&gt;&lt;s3&gt;プロトコル&lt;/s3&gt;&lt;/a2&gt;の章で追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about recursive enumerations to the &lt;a0&gt;&lt;s1&gt;Recursive Enumerations&lt;/s1&gt;&lt;/a0&gt; section of the &lt;a2&gt;&lt;s3&gt;Enumerations&lt;/s3&gt;&lt;/a2&gt; chapter and the &lt;a4&gt;&lt;s5&gt;Enumerations with Cases of Any Type&lt;/s5&gt;&lt;/a4&gt; section of the &lt;a6&gt;&lt;s7&gt;Declarations&lt;/s7&gt;&lt;/a6&gt; chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>再帰列挙についての情報を&lt;a0&gt;&lt;s1&gt;再帰列挙&lt;/s1&gt;&lt;/a0&gt;節に&lt;a2&gt;&lt;s3&gt;列挙&lt;/s3&gt;&lt;/a2&gt;章で、そして&lt;a4&gt;&lt;s5&gt;随意の型のケース節をもつ列挙&lt;/s5&gt;&lt;/a4&gt;節に&lt;a6&gt;&lt;s7&gt;宣言&lt;/s7&gt;&lt;/a6&gt;章で加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about recursive protocol constraints to the &lt;a0&gt;&lt;s1&gt;Using a Protocol in Its Associated Type’s Constraints&lt;/s1&gt;&lt;/a0&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>再帰的プロトコル制約についての情報を&lt;a0&gt;&lt;s1&gt;あるプロトコルをその関連型のもつ制約において使用する&lt;/s1&gt;&lt;/a0&gt;の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about switch cases that have multiple patterns to the &lt;a0&gt;&lt;s1&gt;Switch&lt;/s1&gt;&lt;/a0&gt; section of the &lt;a2&gt;&lt;s3&gt;Control Flow&lt;/s3&gt;&lt;/a2&gt; chapter and the &lt;a4&gt;&lt;s5&gt;Switch Statement&lt;/s5&gt;&lt;/a4&gt; section of the &lt;a6&gt;&lt;s7&gt;Statements&lt;/s7&gt;&lt;/a6&gt; chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数のパターンを持つスイッチケース節についての情報を、節&lt;a0&gt;&lt;s1&gt;スイッチ&lt;/s1&gt;&lt;/a0&gt;に章&lt;a2&gt;&lt;s3&gt;制御の流れ&lt;/s3&gt;&lt;/a2&gt;で、そして節&lt;a4&gt;&lt;s5&gt;スイッチ文&lt;/s5&gt;&lt;/a4&gt;に章&lt;a6&gt;&lt;s7&gt;文&lt;/s7&gt;&lt;/a6&gt;で加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about synthesized implementations of equivalence operators to the &lt;a0&gt;&lt;s1&gt;Equivalence Operators&lt;/s1&gt;&lt;/a0&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>等価演算子の合成実装についての情報を&lt;a0&gt;&lt;s1&gt;等価演算子&lt;/s1&gt;&lt;/a0&gt;の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the &lt;c0&gt;&lt;s1&gt;#selector&lt;/s1&gt;&lt;/c0&gt; syntax for Objective-C selectors to the &lt;a2&gt;&lt;s3&gt;Selector Expression&lt;/s3&gt;&lt;/a2&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cセレクタのための&lt;c0&gt;&lt;s1&gt;#selector&lt;/s1&gt;&lt;/c0&gt;構文についての情報を&lt;a2&gt;&lt;s3&gt;セレクタ式&lt;/s3&gt;&lt;/a2&gt;節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the &lt;c0&gt;&lt;s1&gt;@GKInspectable&lt;/s1&gt;&lt;/c0&gt; attribute to the &lt;a2&gt;&lt;s3&gt;Declaration Attributes&lt;/s3&gt;&lt;/a2&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;@GKInspectable&lt;/s1&gt;&lt;/c0&gt;属性についての情報を&lt;a2&gt;&lt;s3&gt;宣言属性&lt;/s3&gt;&lt;/a2&gt;節に加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the &lt;c0&gt;&lt;s1&gt;@autoclosure&lt;/s1&gt;&lt;/c0&gt; attribute—including its &lt;c2&gt;&lt;s3&gt;@autoclosure(escaping)&lt;/s3&gt;&lt;/c2&gt; form—to the &lt;a4&gt;&lt;s5&gt;Autoclosures&lt;/s5&gt;&lt;/a4&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;@autoclosure&lt;/s1&gt;&lt;/c0&gt;属性についての情報を ― それの&lt;c2&gt;&lt;s3&gt;@autoclosure(escaping)&lt;/s3&gt;&lt;/c2&gt;形式を含めて ― &lt;a4&gt;&lt;s5&gt;自動クロージャ&lt;/s5&gt;&lt;/a4&gt;節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the &lt;c0&gt;&lt;s1&gt;availability&lt;/s1&gt;&lt;/c0&gt; attribute to the &lt;a2&gt;&lt;s3&gt;Declaration Attributes&lt;/s3&gt;&lt;/a2&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;availability&lt;/s1&gt;&lt;/c0&gt;属性についての情報を&lt;a2&gt;&lt;s3&gt;宣言属性&lt;/s3&gt;&lt;/a2&gt;節に加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the &lt;c0&gt;&lt;s1&gt;canImport()&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;targetEnvironment()&lt;/s3&gt;&lt;/c2&gt; platform conditions to &lt;a4&gt;&lt;s5&gt;Conditional Compilation Block&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;canImport()&lt;/s1&gt;&lt;/c0&gt;および&lt;c2&gt;&lt;s3&gt;targetEnvironment()&lt;/s3&gt;&lt;/c2&gt;プラットホーム条件についての情報を&lt;a4&gt;&lt;s5&gt;条件コンパイルブロック&lt;/s5&gt;&lt;/a4&gt;に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the &lt;c0&gt;&lt;s1&gt;dynamic&lt;/s1&gt;&lt;/c0&gt; declaration modifier in &lt;a2&gt;&lt;s3&gt;Declaration Modifiers&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a2&gt;&lt;s3&gt;宣言修飾子&lt;/s3&gt;&lt;/a2&gt;において&lt;c0&gt;&lt;s1&gt;dynamic&lt;/s1&gt;&lt;/c0&gt;宣言修飾子についての情報を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the &lt;c0&gt;&lt;s1&gt;open&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;fileprivate&lt;/s3&gt;&lt;/c2&gt; access-level modifiers to the &lt;a4&gt;&lt;s5&gt;Access Control&lt;/s5&gt;&lt;/a4&gt; chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;open&lt;/s1&gt;&lt;/c0&gt;および&lt;c2&gt;&lt;s3&gt;fileprivate&lt;/s3&gt;&lt;/c2&gt;アクセス水準修飾子についての情報を&lt;a4&gt;&lt;s5&gt;アクセス制御&lt;/s5&gt;&lt;/a4&gt;の章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the &lt;c0&gt;&lt;s1&gt;requires_stored_property_inits&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;warn_unqualified_access&lt;/s3&gt;&lt;/c2&gt; attributes to the &lt;a4&gt;&lt;s5&gt;Declaration Attributes&lt;/s5&gt;&lt;/a4&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;requires_stored_property_inits&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;warn_unqualified_access&lt;/s3&gt;&lt;/c2&gt;属性についての情報を&lt;a4&gt;&lt;s5&gt;属性宣言&lt;/s5&gt;&lt;/a4&gt;の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the &lt;c0&gt;&lt;s1&gt;unowned&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;unowned(safe)&lt;/s3&gt;&lt;/c2&gt;, and &lt;c4&gt;&lt;s5&gt;unowned(unsafe)&lt;/s5&gt;&lt;/c4&gt; declaration modifiers in the &lt;a6&gt;&lt;s7&gt;Declaration Modifiers&lt;/s7&gt;&lt;/a6&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;unowned&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;unowned(safe)&lt;/s3&gt;&lt;/c2&gt;、そして&lt;c4&gt;&lt;s5&gt;unowned(unsafe)&lt;/s5&gt;&lt;/c4&gt;宣言修飾子についての情報を&lt;a6&gt;&lt;s7&gt;宣言修飾子&lt;/s7&gt;&lt;/a6&gt;の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the behavior of enumeration cases with &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; raw values to the &lt;a2&gt;&lt;s3&gt;Implicitly Assigned Raw Values&lt;/s3&gt;&lt;/a2&gt; section of the &lt;a4&gt;&lt;s5&gt;Enumerations&lt;/s5&gt;&lt;/a4&gt; chapter and the &lt;a6&gt;&lt;s7&gt;Enumerations with Cases of a Raw-Value Type&lt;/s7&gt;&lt;/a6&gt; section of the &lt;a8&gt;&lt;s9&gt;Declarations&lt;/s9&gt;&lt;/a8&gt; chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;の生の値を持つ列挙ケース節の挙動についての情報を&lt;a2&gt;&lt;s3&gt;暗黙的に割り当てられる生の値&lt;/s3&gt;&lt;/a2&gt;節に&lt;a4&gt;&lt;s5&gt;列挙&lt;/s5&gt;&lt;/a4&gt;章でそして&lt;a6&gt;&lt;s7&gt;「生の値」型のケース節を持つ列挙&lt;/s7&gt;&lt;/a6&gt;節に&lt;a8&gt;&lt;s9&gt;宣言&lt;/s9&gt;&lt;/a8&gt;章で追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the behavior of in-out parameters to the &lt;a0&gt;&lt;s1&gt;In-Out Parameters&lt;/s1&gt;&lt;/a0&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>in-outパラメータの挙動についての情報を&lt;a0&gt;&lt;s1&gt;in-outパラメータ&lt;/s1&gt;&lt;/a0&gt;節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the identity key path (&lt;c0&gt;&lt;s1&gt;\.self&lt;/s1&gt;&lt;/c0&gt;) to the &lt;a2&gt;&lt;s3&gt;Key-Path Expression&lt;/s3&gt;&lt;/a2&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同一性キーパス（&lt;c0&gt;&lt;s1&gt;\.self&lt;/s1&gt;&lt;/c0&gt;）についての情報を&lt;a2&gt;&lt;s3&gt;キーパス式&lt;/s3&gt;&lt;/a2&gt;の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the new &lt;c0&gt;&lt;s1&gt;guard&lt;/s1&gt;&lt;/c0&gt; statement to the &lt;a2&gt;&lt;s3&gt;Early Exit&lt;/s3&gt;&lt;/a2&gt; section of the &lt;a4&gt;&lt;s5&gt;Control Flow&lt;/s5&gt;&lt;/a4&gt; chapter and the &lt;a6&gt;&lt;s7&gt;Guard Statement&lt;/s7&gt;&lt;/a6&gt; section of the &lt;a8&gt;&lt;s9&gt;Statements&lt;/s9&gt;&lt;/a8&gt; chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい&lt;c0&gt;&lt;s1&gt;guard&lt;/s1&gt;&lt;/c0&gt;文についての情報を節&lt;a2&gt;&lt;s3&gt;早期退出&lt;/s3&gt;&lt;/a2&gt;に章&lt;a4&gt;&lt;s5&gt;制御の流れ&lt;/s5&gt;&lt;/a4&gt;で、そして節&lt;a6&gt;&lt;s7&gt;guard文&lt;/s7&gt;&lt;/a6&gt;に章&lt;a8&gt;&lt;s9&gt;文&lt;/s9&gt;&lt;/a8&gt;で追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the new &lt;c0&gt;&lt;s1&gt;try?&lt;/s1&gt;&lt;/c0&gt; keyword to the &lt;a2&gt;&lt;s3&gt;Converting Errors to Optional Values&lt;/s3&gt;&lt;/a2&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい&lt;c0&gt;&lt;s1&gt;try?&lt;/s1&gt;&lt;/c0&gt;キーワードについての情報を&lt;a2&gt;&lt;s3&gt;エラーをオプショナルの値に変換する&lt;/s3&gt;&lt;/a2&gt;節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the new Swift standard library &lt;c0&gt;&lt;s1&gt;print(_:separator:terminator)&lt;/s1&gt;&lt;/c0&gt; function to the &lt;a2&gt;&lt;s3&gt;Printing Constants and Variables&lt;/s3&gt;&lt;/a2&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しいスウィフト標準ライブラリ&lt;c0&gt;&lt;s1&gt;print(_:separator:terminator)&lt;/s1&gt;&lt;/c0&gt;関数についての情報を&lt;a2&gt;&lt;s3&gt;定数と変数を出力する&lt;/s3&gt;&lt;/a2&gt;節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about the new optional pattern to the &lt;a0&gt;&lt;s1&gt;Optional Pattern&lt;/s1&gt;&lt;/a0&gt; section of the &lt;a2&gt;&lt;s3&gt;Patterns&lt;/s3&gt;&lt;/a2&gt; chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しいオプショナルパターンについての情報を節&lt;a0&gt;&lt;s1&gt;オプショナルパターン&lt;/s1&gt;&lt;/a0&gt;に章&lt;a2&gt;&lt;s3&gt;パターン&lt;/s3&gt;&lt;/a2&gt;で追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about throwing an error inside the catch block of a rethrowing function to the &lt;a0&gt;&lt;s1&gt;Rethrowing Functions and Methods&lt;/s1&gt;&lt;/a0&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>再スロー関数のcatchブロック内部でエラーをスローすることについての情報を、節&lt;a0&gt;&lt;s1&gt;再スローを行う関数とメソッド&lt;/s1&gt;&lt;/a0&gt;に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about using enumeration cases as functions to the &lt;a0&gt;&lt;s1&gt;Enumerations with Cases of Any Type&lt;/s1&gt;&lt;/a0&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙ケース節を関数として使うことについての情報を&lt;a0&gt;&lt;s1&gt;随意の型のケース節をもつ列挙&lt;/s1&gt;&lt;/a0&gt;節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about using keywords as external parameter names to the &lt;a0&gt;&lt;s1&gt;Keywords and Punctuation&lt;/s1&gt;&lt;/a0&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キーワードを外部パラメータ名として使うことについての情報を&lt;a0&gt;&lt;s1&gt;キーワードと句読点&lt;/s1&gt;&lt;/a0&gt;節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about using subscripts on types to the &lt;a0&gt;&lt;s1&gt;Type Subscripts&lt;/s1&gt;&lt;/a0&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型の上で添え字を使うことについての情報を&lt;a0&gt;&lt;s1&gt;型添え字&lt;/s1&gt;&lt;/a0&gt;の節に加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information about using the less than (&lt;c0&gt;&lt;s1&gt;&lt;&lt;/s1&gt;&lt;/c0&gt;) operator in platform conditions to the &lt;a2&gt;&lt;s3&gt;Conditional Compilation Block&lt;/s3&gt;&lt;/a2&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より小さい（&lt;c0&gt;&lt;s1&gt;&lt;&lt;/s1&gt;&lt;/c0&gt;）演算子をプラットホーム条件において使うことについての情報を&lt;a2&gt;&lt;s3&gt;条件コンパイルブロック&lt;/s3&gt;&lt;/a2&gt;の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information enumerations and structures that are frozen for library evolution to the &lt;a0&gt;&lt;s1&gt;frozen&lt;/s1&gt;&lt;/a0&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ライブラリ進化に対して凍結される列挙と構造体の情報を&lt;a0&gt;&lt;s1&gt;frozen&lt;/s1&gt;&lt;/a0&gt;の節に加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information to the &lt;a0&gt;&lt;s1&gt;Capture Lists&lt;/s1&gt;&lt;/a0&gt; section about how values specified in closure capture lists are captured.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どのようにクロージャキャプチャリストにおいて指定された値がキャプチャされるかについて情報を&lt;a0&gt;&lt;s1&gt;キャプチャリスト&lt;/s1&gt;&lt;/a0&gt;節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information to the &lt;a0&gt;&lt;s1&gt;Declaration Attributes&lt;/s1&gt;&lt;/a0&gt; section about using the &lt;c2&gt;&lt;s3&gt;available&lt;/s3&gt;&lt;/c2&gt; attribute with a Swift language version.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;宣言属性&lt;/s1&gt;&lt;/a0&gt;節に、スウィフト言語版での&lt;c2&gt;&lt;s3&gt;available&lt;/s3&gt;&lt;/c2&gt;属性を使うことについて情報を加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information to the &lt;a0&gt;&lt;s1&gt;Metatype Type&lt;/s1&gt;&lt;/a0&gt; section about comparing metatype values and using them to construct instances with initializer expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;メタタイプ型&lt;/s1&gt;&lt;/a0&gt;節に、メタタイプ値の比較と、それらをインスタンスを作り上げるためにイニシャライザ式とともに使う事についての情報を加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information to the &lt;a0&gt;&lt;s1&gt;Overriding a Failable Initializer&lt;/s1&gt;&lt;/a0&gt; section about how a nonfailable initializer can delegate up to a failable initializer by force-unwrapping the result of the superclass’s initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;失敗できるイニシャライザのオーバーライド&lt;/s1&gt;&lt;/a0&gt;節に失敗できないイニシャライザが失敗できるイニシャライザにまで委任することを、スーパークラスのイニシャライザの結果を強制アンラップすることでできる方法についての情報を加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information to the &lt;a0&gt;&lt;s1&gt;String Literals&lt;/s1&gt;&lt;/a0&gt; section about how concatenating string literals using the &lt;c2&gt;&lt;s3&gt;+&lt;/s3&gt;&lt;/c2&gt; operator happens at compile time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;文字列リテラル&lt;/s1&gt;&lt;/a0&gt;節に、どのように&lt;c2&gt;&lt;s3&gt;+&lt;/s3&gt;&lt;/c2&gt;演算子を使った文字列リテラルの連結がコンパイル時に起こるかについての情報を加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added information to the &lt;a0&gt;&lt;s1&gt;Type Alias Declaration&lt;/s1&gt;&lt;/a0&gt; section about generic type aliases and using type aliases inside of protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>情報を&lt;a0&gt;&lt;s1&gt;型エイリアス宣言&lt;/s1&gt;&lt;/a0&gt;の節に加えた、プロトコルの内部での総称体型エイリアスと型エイリアス利用について。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added more information about curried functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>カリー化関数についての更なる情報を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added similar information about the &lt;c4&gt;&lt;s5&gt;do&lt;/s5&gt;&lt;/c4&gt; statement in the &lt;a6&gt;&lt;s7&gt;Do Statement&lt;/s7&gt;&lt;/a6&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;do&lt;/s5&gt;&lt;/c4&gt;文について同様の情報を&lt;a6&gt;&lt;s7&gt;do文&lt;/s7&gt;&lt;/a6&gt;の節において追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the &lt;a0&gt;&lt;s1&gt;Associated Types with a Generic Where Clause&lt;/s1&gt;&lt;/a0&gt; section, now that you can use generic &lt;c2&gt;&lt;s3&gt;where&lt;/s3&gt;&lt;/c2&gt; clauses to constrain associated types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;総称体where節を持つ関連型&lt;/s1&gt;&lt;/a0&gt;の節を加えた、今ではあなたは総称体&lt;c2&gt;&lt;s3&gt;where&lt;/s3&gt;&lt;/c2&gt;節を使って関連型を制約できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the &lt;a0&gt;&lt;s1&gt;Escaping Closures&lt;/s1&gt;&lt;/a0&gt; section with information about the &lt;c2&gt;&lt;s3&gt;@noescape&lt;/s3&gt;&lt;/c2&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;脱出クロージャ&lt;/s1&gt;&lt;/a0&gt;の節を&lt;c2&gt;&lt;s3&gt;@noescape&lt;/s3&gt;&lt;/c2&gt;属性についての情報とともに加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the &lt;a0&gt;&lt;s1&gt;Extended String Delimiters&lt;/s1&gt;&lt;/a0&gt; section and updated the &lt;a2&gt;&lt;s3&gt;String Literals&lt;/s3&gt;&lt;/a2&gt; section with information about extended string delimiters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;拡張文字列区切り記号&lt;/s1&gt;&lt;/a0&gt;の節を加えて&lt;a2&gt;&lt;s3&gt;文字列リテラル&lt;/s3&gt;&lt;/a2&gt;の節を拡張文字列区切り記号についての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the &lt;a0&gt;&lt;s1&gt;Extensions with a Generic Where Clause&lt;/s1&gt;&lt;/a0&gt; section with information about extensions that include requirements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;総称体where節を持つ拡張&lt;/s1&gt;&lt;/a0&gt;の節を、要件を含む拡張についての情報とともに加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the &lt;a0&gt;&lt;s1&gt;Functions With an Implicit Return&lt;/s1&gt;&lt;/a0&gt; and &lt;a2&gt;&lt;s3&gt;Shorthand Getter Declaration&lt;/s3&gt;&lt;/a2&gt; sections with information about functions that omit &lt;c4&gt;&lt;s5&gt;return&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;暗黙的returnを持つ関数&lt;/s1&gt;&lt;/a0&gt;と &lt;a2&gt;&lt;s3&gt;略記ゲッター宣言&lt;/s3&gt;&lt;/a2&gt;の節を&lt;c4&gt;&lt;s5&gt;return&lt;/s5&gt;&lt;/c4&gt;を省略する関数についての情報とともに加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the &lt;a0&gt;&lt;s1&gt;Generic Subscripts&lt;/s1&gt;&lt;/a0&gt; section, now that subscripts can be generic.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;総称体添え字&lt;/s1&gt;&lt;/a0&gt;の節を追加した、今では添え字は総称体にできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the &lt;a0&gt;&lt;s1&gt;Methods with Special Names&lt;/s1&gt;&lt;/a0&gt; section with information about syntactic sugar the lets instances of classes, structures, and enumerations be used with function call syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;特殊名を持つメソッド&lt;/s1&gt;&lt;/a0&gt;の節を、クラス、構造体、そして列挙のインスタンスが関数呼び出し構文で使われるようにする構文糖についての情報とともに加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the &lt;a0&gt;&lt;s1&gt;dynamicCallable&lt;/s1&gt;&lt;/a0&gt; section with information about dynamically calling instances as functions using the &lt;c2&gt;&lt;s3&gt;dynamicCallable&lt;/s3&gt;&lt;/c2&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg> &lt;a0&gt;&lt;s1&gt;dynamicCallable&lt;/s1&gt;&lt;/a0&gt;の節を、動的にインスタンスを関数として&lt;c2&gt;&lt;s3&gt;dynamicCallable&lt;/s3&gt;&lt;/c2&gt;属性を使って呼び出すことについての情報とともに加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Added the &lt;a0&gt;&lt;s1&gt;unknown&lt;/s1&gt;&lt;/a0&gt; and &lt;a2&gt;&lt;s3&gt;Switching Over Future Enumeration Cases&lt;/s3&gt;&lt;/a2&gt; sections with information about handling future enumeration cases in switch statements using the &lt;c4&gt;&lt;s5&gt;unknown&lt;/s5&gt;&lt;/c4&gt; switch case attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;unknown&lt;/s1&gt;&lt;/a0&gt;と&lt;a2&gt;&lt;s3&gt;未来列挙ケース節にわたってスイッチする&lt;/s3&gt;&lt;/a2&gt;の節をスイッチ文において未来列挙ケース節を&lt;c4&gt;&lt;s5&gt;unknown&lt;/s5&gt;&lt;/c4&gt;スイッチケース節属性を使って取り扱うことについての情報とともに加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Adding Constraints to Protocol Extensions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル拡張に制約を加える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Adding Constraints to an Associated Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連型に制約を加える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Adding Protocol Conformance with an Extension</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張を使ってプロトコル準拠を加える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Adding protocol conformance in this way is described in &lt;a0&gt;&lt;s1&gt;Adding Protocol Conformance with an Extension&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この方法でプロトコル準拠を加えることは&lt;a0&gt;&lt;s1&gt;拡張を使ってプロトコル準拠を加える&lt;/s1&gt;&lt;/a0&gt;で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Addition (&lt;c0&gt;&lt;s1&gt;+&lt;/s1&gt;&lt;/c0&gt;)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>加算（&lt;c0&gt;&lt;s1&gt;+&lt;/s1&gt;&lt;/c0&gt;）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, although operators can contain an exclamation point (&lt;c2&gt;&lt;s3&gt;!&lt;/s3&gt;&lt;/c2&gt;), postfix operators can’t begin with either a question mark or an exclamation point.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それに加えて、演算子は感嘆符（&lt;c2&gt;&lt;s3&gt;!&lt;/s3&gt;&lt;/c2&gt;）を含むことができますが、接尾辞演算子は、疑問符または感嘆符のどちらかで始まることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, when an instance is no longer needed, ARC frees up the memory used by that instance so that the memory can be used for other purposes instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その上に、インスタンスがもはや必要でないとき、ARCはそのインスタンスによって使われるメモリを開放します、それでメモリが代わりに他の目的のために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Advanced Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>先進の演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After a type alias is declared, the aliased &lt;e0&gt;name&lt;/e0&gt; can be used instead of the &lt;e1&gt;existing type&lt;/e1&gt; everywhere in your program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型エイリアスが宣言されたあと、エイリアス（別名）にされた&lt;e0&gt;名前&lt;/e0&gt;は、あなたのプログラムの至る所で&lt;e1&gt;既存の型&lt;/e1&gt;の代わりに使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After applying the provided closure to each array element, the &lt;c0&gt;&lt;s1&gt;map(_:)&lt;/s1&gt;&lt;/c0&gt; method returns a new array containing all of the new mapped values, in the same order as their corresponding values in the original array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>提供されたクロージャを各配列要素に適用した後に、&lt;c0&gt;&lt;s1&gt;map(_:)&lt;/s1&gt;&lt;/c0&gt;メソッドは、新しい対応付けられる値の全てを、もとの配列のそれらの対応する値と同じ順序で含んでいる新しい配列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After calling &lt;c0&gt;&lt;s1&gt;increment(forCount:)&lt;/s1&gt;&lt;/c0&gt;, the optional &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt; that it returns is unwrapped into a constant called &lt;c4&gt;&lt;s5&gt;amount&lt;/s5&gt;&lt;/c4&gt;, using optional binding.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;increment(forCount:)&lt;/s1&gt;&lt;/c0&gt;呼び出しの後、それが返すオプショナルの&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;は、オプショナル束縛を使って、&lt;c4&gt;&lt;s5&gt;amount&lt;/s5&gt;&lt;/c4&gt;と呼ばれる定数へとアンラップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After calling &lt;c16&gt;&lt;s17&gt;super.init()&lt;/s17&gt;&lt;/c16&gt;, the original value of &lt;c18&gt;&lt;s19&gt;numberOfWheels&lt;/s19&gt;&lt;/c18&gt; is replaced with a new value of &lt;c20&gt;&lt;s21&gt;2&lt;/s21&gt;&lt;/c20&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c16&gt;&lt;s17&gt;super.init()&lt;/s17&gt;&lt;/c16&gt;の呼び出しの後、&lt;c18&gt;&lt;s19&gt;numberOfWheels&lt;/s19&gt;&lt;/c18&gt;のもとの値は新しい値の&lt;c20&gt;&lt;s21&gt;2&lt;/s21&gt;&lt;/c20&gt;で置き換えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After capturing these values, &lt;c10&gt;&lt;s11&gt;incrementer&lt;/s11&gt;&lt;/c10&gt; is returned by &lt;c12&gt;&lt;s13&gt;makeIncrementer&lt;/s13&gt;&lt;/c12&gt; as a closure that increments &lt;c14&gt;&lt;s15&gt;runningTotal&lt;/s15&gt;&lt;/c14&gt; by &lt;c16&gt;&lt;s17&gt;amount&lt;/s17&gt;&lt;/c16&gt; each time it is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの値を捕獲した後に、&lt;c10&gt;&lt;s11&gt;incrementer&lt;/s11&gt;&lt;/c10&gt;は&lt;c12&gt;&lt;s13&gt;makeIncrementer&lt;/s13&gt;&lt;/c12&gt;によって、それが呼ばれるたびに&lt;c14&gt;&lt;s15&gt;runningTotal&lt;/s15&gt;&lt;/c14&gt;を&lt;c16&gt;&lt;s17&gt;amount&lt;/s17&gt;&lt;/c16&gt;によって増加させるクロージャとして返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After creating the dictionary, this example uses subscript assignment to add a &lt;c7&gt;&lt;s8&gt;String&lt;/s8&gt;&lt;/c7&gt; key of &lt;c9&gt;&lt;s10&gt;"bird"&lt;/s10&gt;&lt;/c9&gt; and an &lt;c11&gt;&lt;s12&gt;Int&lt;/s12&gt;&lt;/c11&gt; value of &lt;c13&gt;&lt;s14&gt;2&lt;/s14&gt;&lt;/c13&gt; to the dictionary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書を作成した後に、この例は、辞書に&lt;c7&gt;&lt;s8&gt;String&lt;/s8&gt;&lt;/c7&gt;キーの&lt;c9&gt;&lt;s10&gt;"bird"&lt;/s10&gt;&lt;/c9&gt;と&lt;c11&gt;&lt;s12&gt;Int&lt;/s12&gt;&lt;/c11&gt;値の&lt;c13&gt;&lt;s14&gt;2&lt;/s14&gt;&lt;/c13&gt;を加えるために添え字代入を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After declaring a new operator, you implement it by declaring a static method that has the same name as the operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある新しい演算子を宣言した後に、あなたはその演算子と同じ名前を持つ静的メソッドを宣言することによってそれを実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After defining this extension, you can call the &lt;c0&gt;&lt;s1&gt;repetitions(task:)&lt;/s1&gt;&lt;/c0&gt; method on any integer to perform a task that many number of times:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この拡張を定義した後、あなたは&lt;c0&gt;&lt;s1&gt;repetitions(task:)&lt;/s1&gt;&lt;/c0&gt;メソッドをあらゆる整数上で呼び出して、ある作業をそれだけ多くの回数実行できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After defining this extension, you can use any &lt;c6&gt;&lt;s7&gt;Array&lt;/s7&gt;&lt;/c6&gt; as a &lt;c8&gt;&lt;s9&gt;Container&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この拡張を定義した後に、あなたはどんな&lt;c6&gt;&lt;s7&gt;Array&lt;/s7&gt;&lt;/c6&gt;でも&lt;c8&gt;&lt;s9&gt;Container&lt;/s9&gt;&lt;/c8&gt;として使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After doing so, the initializer delegates up to the &lt;c15&gt;&lt;s16&gt;init(name:&lt;/s16&gt; &lt;s17&gt;String)&lt;/s17&gt;&lt;/c15&gt; initializer of the &lt;c18&gt;&lt;s19&gt;Food&lt;/s19&gt;&lt;/c18&gt; class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうした後に、イニシャライザは上って&lt;c18&gt;&lt;s19&gt;Food&lt;/s19&gt;&lt;/c18&gt;クラスの&lt;c15&gt;&lt;s16&gt;init(name:&lt;/s16&gt; &lt;s17&gt;String)&lt;/s17&gt;&lt;/c15&gt;イニシャライザに委任します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After executing the code inside the switch case that matched, the program exits from the switch statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>合致したスイッチのケース節（case）の内部のコードを実行した後に、プログラムはスイッチ文から出ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After making this check, the function iterates over all of the items in &lt;c0&gt;&lt;s1&gt;someContainer&lt;/s1&gt;&lt;/c0&gt; with a &lt;c2&gt;&lt;s3&gt;for&lt;/s3&gt;&lt;/c2&gt;-&lt;c4&gt;&lt;s5&gt;in&lt;/s5&gt;&lt;/c4&gt; loop and the half-open range operator (&lt;c6&gt;&lt;s7&gt;..&lt;&lt;/s7&gt;&lt;/c6&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この確認の後、関数は&lt;c0&gt;&lt;s1&gt;someContainer&lt;/s1&gt;&lt;/c0&gt;の項目の全てに渡って&lt;c2&gt;&lt;s3&gt;for&lt;/s3&gt;&lt;/c2&gt;-&lt;c4&gt;&lt;s5&gt;in&lt;/s5&gt;&lt;/c4&gt;ループと半開範囲演算子（&lt;c6&gt;&lt;s7&gt;..&lt;&lt;/s7&gt;&lt;/c6&gt;）を使って繰り返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After popping a value, the stack once again holds three values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値をポップした後では、スタックは再び３つの値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After rolling the dice, the player moves forward by &lt;c0&gt;&lt;s1&gt;diceRoll&lt;/s1&gt;&lt;/c0&gt; squares.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さいころを転がした後、プレーヤーは正方形を&lt;c0&gt;&lt;s1&gt;diceRoll&lt;/s1&gt;&lt;/c0&gt;分だけ前進します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After storing a small number like four, the value of &lt;c2&gt;&lt;s3&gt;someStructure.$someNumber&lt;/s3&gt;&lt;/c2&gt; is &lt;c4&gt;&lt;s5&gt;false&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>４のような小さい値を格納後、&lt;c2&gt;&lt;s3&gt;someStructure.$someNumber&lt;/s3&gt;&lt;/c2&gt;の値は&lt;c4&gt;&lt;s5&gt;false&lt;/s5&gt;&lt;/c4&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After the &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; statement completes its execution, the example uses optional binding to determine whether a value was found.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;文がその実行を完了したあと、この例は値が見つけられたかどうか決定するためにオプショナル束縛を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After the &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; statement has finished executing, the number’s description is printed using the &lt;c2&gt;&lt;s3&gt;print(_:separator:terminator:)&lt;/s3&gt;&lt;/c2&gt; function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;文が実行を終えたあと、その数の解説は&lt;c2&gt;&lt;s3&gt;print(_:separator:terminator:)&lt;/s3&gt;&lt;/c2&gt;関数を使用して出力されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After the array is created, the name of the &lt;c6&gt;&lt;s7&gt;ShoppingListItem&lt;/s7&gt;&lt;/c6&gt; at the start of the array is changed from &lt;c8&gt;&lt;s9&gt;"[Unnamed]"&lt;/s9&gt;&lt;/c8&gt; to &lt;c10&gt;&lt;s11&gt;"Orange&lt;/s11&gt; &lt;s12&gt;juice"&lt;/s12&gt;&lt;/c10&gt; and it is marked as having been purchased.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列がつくられたあと、配列の始めの&lt;c6&gt;&lt;s7&gt;ShoppingListItem&lt;/s7&gt;&lt;/c6&gt;の名前は、&lt;c8&gt;&lt;s9&gt;"[Unnamed]"&lt;/s9&gt;&lt;/c8&gt;から&lt;c10&gt;&lt;s11&gt;"Orange&lt;/s11&gt; &lt;s12&gt;juice"&lt;/s12&gt;&lt;/c10&gt;へ変えられます、そしてそれは購入済みとして印されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After the code checks for snakes and ladders, the dice is rolled and the player is moved forward by &lt;c0&gt;&lt;s1&gt;diceRoll&lt;/s1&gt;&lt;/c0&gt; squares.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コードがヘビとはしごについて調べた後、さいころが振られてプレーヤーは&lt;c0&gt;&lt;s1&gt;diceRoll&lt;/s1&gt;&lt;/c0&gt;だけの正方形を前進させられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After the code within a matched case has finished executing, the program exits from the &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>マッチされたケース節内のコードが実行を終えたあと、プログラムは&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;文から出ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After the first character, combining Unicode characters are also allowed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の文字の後は、合成ユニコード文字もまた許されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After the first character, digits and combining Unicode characters are also allowed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の文字の後は、桁および合成Unicode文字もまた、許されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After the statement is executed, the value of &lt;c12&gt;&lt;s13&gt;index&lt;/s13&gt;&lt;/c12&gt; is updated to contain the second value in the range (&lt;c14&gt;&lt;s15&gt;2&lt;/s15&gt;&lt;/c14&gt;), and the &lt;c16&gt;&lt;s17&gt;print(_:separator:terminator:)&lt;/s17&gt;&lt;/c16&gt; function is called again.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文が実行されたあと、&lt;c12&gt;&lt;s13&gt;index&lt;/s13&gt;&lt;/c12&gt;の値は範囲の２番目の値（&lt;c14&gt;&lt;s15&gt;2&lt;/s15&gt;&lt;/c14&gt;）を含むように更新されます、そして&lt;c16&gt;&lt;s17&gt;print(_:separator:terminator:)&lt;/s17&gt;&lt;/c16&gt;関数が再び呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After the temporary constants are declared, they can be used within the case’s code block.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一時的な定数が宣言された後、それらはケース節のもつコードのかたまり内で使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After this happens, there are no more strong references to the &lt;c2&gt;&lt;s3&gt;CreditCard&lt;/s3&gt;&lt;/c2&gt; instance, and it too is deallocated:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これが起こったあと、&lt;c2&gt;&lt;s3&gt;CreditCard&lt;/s3&gt;&lt;/c2&gt;インスタンスへの強い参照はもうありません、そして、それも割り当て解除されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Again, the first three &lt;c0&gt;&lt;s1&gt;codeUnit&lt;/s1&gt;&lt;/c0&gt; values (&lt;c2&gt;&lt;s3&gt;68&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;111&lt;/s5&gt;&lt;/c4&gt;, &lt;c6&gt;&lt;s7&gt;103&lt;/s7&gt;&lt;/c6&gt;) represent the characters &lt;c8&gt;&lt;s9&gt;D&lt;/s9&gt;&lt;/c8&gt;, &lt;c10&gt;&lt;s11&gt;o&lt;/s11&gt;&lt;/c10&gt;, and &lt;c12&gt;&lt;s13&gt;g&lt;/s13&gt;&lt;/c12&gt;, whose UTF-16 code units have the same values as in the string’s UTF-8 representation (because these Unicode scalars represent ASCII characters).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>再び、最初の３つの&lt;c0&gt;&lt;s1&gt;codeUnit&lt;/s1&gt;&lt;/c0&gt;値（&lt;c2&gt;&lt;s3&gt;68&lt;/s3&gt;&lt;/c2&gt;、&lt;c4&gt;&lt;s5&gt;111&lt;/s5&gt;&lt;/c4&gt;、&lt;c6&gt;&lt;s7&gt;103&lt;/s7&gt;&lt;/c6&gt;）は文字&lt;c8&gt;&lt;s9&gt;D&lt;/s9&gt;&lt;/c8&gt;、&lt;c10&gt;&lt;s11&gt;o&lt;/s11&gt;&lt;/c10&gt;、そして&lt;c12&gt;&lt;s13&gt;g&lt;/s13&gt;&lt;/c12&gt;を表します、これらのUTF-16符号単位はこの文字列のUTF-８叙述の場合と同じ値を持ちます（なぜなら、これらのユニコード・スカラーがASCII文字を表わすからです）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All addition and subtraction for signed integers is performed in bitwise fashion, with the sign bit included as part of the numbers being added or subtracted, as described in &lt;a0&gt;&lt;s1&gt;Bitwise Left and Right Shift Operators&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>符号つき整数に対する全ての加算と減算は、&lt;a0&gt;&lt;s1&gt;ビット単位の左および右シフト演算子&lt;/s1&gt;&lt;/a0&gt;で記述されるように、加算または減算される数の一部として含めらる符号ビットとともに、ビット単位流儀で実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All entities in your code (with a few specific exceptions, as described later in this chapter) have a default access level of internal if you don’t specify an explicit access level yourself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのコードの中の全ての実在は（この章の後刻に記述されるように、２、３の特定の例外を除いて）、あなたが明示的に独自にアクセス水準を指定しないならば、省略時のアクセス水準である内部を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All game logic is moved into the protocol’s &lt;c3&gt;&lt;s4&gt;play&lt;/s4&gt;&lt;/c3&gt; method, which uses the protocol’s required &lt;c5&gt;&lt;s6&gt;dice&lt;/s6&gt;&lt;/c5&gt; property to provide its dice roll values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全てのゲーム論理は、プロトコルの&lt;c3&gt;&lt;s4&gt;play&lt;/s4&gt;&lt;/c3&gt;メソッドに引っ越します、それは、プロトコルの要求する&lt;c5&gt;&lt;s6&gt;dice&lt;/s6&gt;&lt;/c5&gt;プロパティを使ってそれのさいころ振りの値を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All information about the property—including its name, type, and memory management characteristics—is defined in a single location as part of the type’s definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティに関する全ての情報は ― その名前、型、そしてメモリ管理などの特徴を含めて ― その型の定義の一部として１つの場所で定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All is not lost, however.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、道がないわけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of Swift’s basic types (such as &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;Double&lt;/s5&gt;&lt;/c4&gt;, and &lt;c6&gt;&lt;s7&gt;Bool&lt;/s7&gt;&lt;/c6&gt;) are hashable by default, and can be used as set value types or dictionary key types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの基本の型の全て（&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;、&lt;c4&gt;&lt;s5&gt;Double&lt;/s5&gt;&lt;/c4&gt;、そして&lt;c6&gt;&lt;s7&gt;Bool&lt;/s7&gt;&lt;/c6&gt;など）は、特に何もしなくてもハッシュ化されます、そして集合の値型または辞書のキー型として使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of Swift’s basic types (such as &lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt;, &lt;c6&gt;&lt;s7&gt;Int&lt;/s7&gt;&lt;/c6&gt;, &lt;c8&gt;&lt;s9&gt;Double&lt;/s9&gt;&lt;/c8&gt;, and &lt;c10&gt;&lt;s11&gt;Bool&lt;/s11&gt;&lt;/c10&gt;) are hashable by default.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの基本の型（例えば&lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt;、&lt;c6&gt;&lt;s7&gt;Int&lt;/s7&gt;&lt;/c6&gt;、&lt;c8&gt;&lt;s9&gt;Double&lt;/s9&gt;&lt;/c8&gt;、そして&lt;c10&gt;&lt;s11&gt;Bool&lt;/s11&gt;&lt;/c10&gt;）の全ては、初期状態でハッシュ化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of Swift’s standard types automatically support the &lt;c6&gt;&lt;s7&gt;Equatable&lt;/s7&gt;&lt;/c6&gt; protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの標準の型の全ては、自動的に&lt;c6&gt;&lt;s7&gt;Equatable&lt;/s7&gt;&lt;/c6&gt;プロトコルをサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of a class’s stored properties—including any properties the class inherits from its superclass—&lt;e0&gt;must&lt;/e0&gt; be assigned an initial value during initialization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるクラスの全ての格納プロパティは ― そのクラスがそれのスーパークラスから継承するあらゆるプロパティを含めて ― 初期化の間に初期値を代入される&lt;e0&gt;必要があります&lt;/e0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of the functions you have encountered so far in this chapter have been examples of &lt;e0&gt;global functions&lt;/e0&gt;, which are defined at a global scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがこの章においてこれまで遭遇した関数の全ては&lt;e0&gt;グローバルな関数&lt;/e0&gt;の例でした、そしてそれは、グローバルなスコープで定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of the game’s levels (apart from level one) are locked when the game is first played.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ゲームが最初にプレイされるとき、ゲームのレベルの全ては鍵をかけられます（レベル１は別として）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of the other bits in &lt;c8&gt;&lt;s9&gt;firstBits&lt;/s9&gt;&lt;/c8&gt; and &lt;c10&gt;&lt;s11&gt;otherBits&lt;/s11&gt;&lt;/c10&gt; match and are set to &lt;c12&gt;&lt;s13&gt;0&lt;/s13&gt;&lt;/c12&gt; in the output value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c8&gt;&lt;s9&gt;firstBits&lt;/s9&gt;&lt;/c8&gt;と&lt;c10&gt;&lt;s11&gt;otherBits&lt;/s11&gt;&lt;/c10&gt;での他の全てのビットは一致していて、出力値において&lt;c12&gt;&lt;s13&gt;0&lt;/s13&gt;&lt;/c12&gt;に設定されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of the patterns of a compound case have to include the same set of value bindings, and each binding has to get a value of the same type from all of the patterns in the compound case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある複合ケース節のパターンのすべては、同じひとそろいの値束縛を含まなければなりません、そしてそれぞれの束縛は同じ型の値をその複合ケース節のパターンのすべてから得なければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of these floating-point literals have a decimal value of &lt;c0&gt;&lt;s1&gt;12.1875&lt;/s1&gt;&lt;/c0&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の浮動小数点リテラルの全ては、10進の値で&lt;c0&gt;&lt;s1&gt;12.1875&lt;/s1&gt;&lt;/c0&gt;を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of these integer literals have a decimal value of &lt;c0&gt;&lt;s1&gt;17&lt;/s1&gt;&lt;/c0&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の整数リテラルの全ては、10進の値で&lt;c0&gt;&lt;s1&gt;17&lt;/s1&gt;&lt;/c0&gt;を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of these overflow operators begin with an ampersand (&lt;c2&gt;&lt;s3&gt;&amp;&lt;/s3&gt;&lt;/c2&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのオーバフロー演算子の全ては、アンパサンド（&lt;c2&gt;&lt;s3&gt;&amp;&lt;/s3&gt;&lt;/c2&gt;）から始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of this information is rolled up into the function’s &lt;e0&gt;definition&lt;/e0&gt;, which is prefixed with the &lt;c1&gt;&lt;s2&gt;func&lt;/s2&gt;&lt;/c1&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この情報の全ては、&lt;c1&gt;&lt;s2&gt;func&lt;/s2&gt;&lt;/c1&gt;キーワードを前に置かれる、関数の&lt;e0&gt;定義&lt;/e0&gt;にまとめ上げられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of this means that you can create the &lt;c0&gt;&lt;s1&gt;Country&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;City&lt;/s3&gt;&lt;/c2&gt; instances in a single statement, without creating a strong reference cycle, and the &lt;c4&gt;&lt;s5&gt;capitalCity&lt;/s5&gt;&lt;/c4&gt; property can be accessed directly, without needing to use an exclamation point to unwrap its optional value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これの全ては、あなたが&lt;c0&gt;&lt;s1&gt;Country&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;City&lt;/s3&gt;&lt;/c2&gt;インスタンスを１つの文において、強い参照循環をつくることなく作成できることを意味します、そして、&lt;c4&gt;&lt;s5&gt;capitalCity&lt;/s5&gt;&lt;/c4&gt;プロパティはそのオプショナルの値をアンラップするために感嘆符を使う必要なしに直接にアクセスされることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All options you can use with string interpolation are described in &lt;a0&gt;&lt;s1&gt;String Interpolation&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが文字列補間で使うことができるオプション全ては、&lt;a0&gt;&lt;s1&gt;「文字列補間」&lt;/s1&gt;&lt;/a0&gt;で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All parameters must have unique names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべてのパラメーターは、特有な名前を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All structures and enumerations are value types in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全ての構造体と列挙は、スウィフトでは値型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All structures have an automatically generated &lt;e0&gt;memberwise initializer&lt;/e0&gt;, which you can use to initialize the member properties of new structure instances.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全ての構造体は自動的に生成される&lt;e0&gt;メンバー関連イニシャライザ&lt;/e0&gt;を持ちます、それはあなたが新しい構造体インスタンスのメンバープロパティを初期化するために使うことが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All three of these initializers can be used to create new &lt;c0&gt;&lt;s1&gt;RecipeIngredient&lt;/s1&gt;&lt;/c0&gt; instances:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのイニシャライザの３つ全てが、新しい&lt;c0&gt;&lt;s1&gt;RecipeIngredient&lt;/s1&gt;&lt;/c0&gt;インスタンスを作るために使用されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All tuple types contain two or more types, except for &lt;c0&gt;&lt;s1&gt;Void&lt;/s1&gt;&lt;/c0&gt; which is a type alias for the empty tuple type, &lt;c2&gt;&lt;s3&gt;()&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべてのタプル型は２つまたはそれ以上の型を含みます、しかし空のタプル型、&lt;c2&gt;&lt;s3&gt;()&lt;/s3&gt;&lt;/c2&gt;に対する型エイリアスである&lt;c0&gt;&lt;s1&gt;Void&lt;/s1&gt;&lt;/c0&gt;を除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also clarified the assignment and copy behavior for strings arrays and dictionaries.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>また「文字列、配列、および辞書のための代入およびコピーの挙動」がわかりやすくされました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternative grammar productions are separated by vertical bars (|).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代替の文法導出は、垂直バー（|）で区別されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, a type that conforms to &lt;c10&gt;&lt;s11&gt;SuffixableContainer&lt;/s11&gt;&lt;/c10&gt; can have a &lt;c12&gt;&lt;s13&gt;Suffix&lt;/s13&gt;&lt;/c12&gt; type that’s different from itself—meaning the suffix operation can return a different type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるいはまた、&lt;c10&gt;&lt;s11&gt;SuffixableContainer&lt;/s11&gt;&lt;/c10&gt;に準拠する型は、それ自身とは異なる&lt;c12&gt;&lt;s13&gt;Suffix&lt;/s13&gt;&lt;/c12&gt;型を持つことができます—suffix演算は異なる型を返すことができることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, access a &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; value in one of three other Unicode-compliant representations:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるいは代わりに、３つの他のUnicode対応の表現の１つで&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;値にアクセスしてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, access the individual element values in a tuple using index numbers starting at zero:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるいは、ゼロから始まっているインデックス番号を使ってタプルの個々の要素の値にアクセスしてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, all items in a set can be removed with its &lt;c4&gt;&lt;s5&gt;removeAll()&lt;/s5&gt;&lt;/c4&gt; method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるいはまた、集合の全ての項目は&lt;c4&gt;&lt;s5&gt;removeAll()&lt;/s5&gt;&lt;/c4&gt;メソッドを使って取り除かれることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, append an array of one or more compatible items with the addition assignment operator (&lt;c0&gt;&lt;s1&gt;+=&lt;/s1&gt;&lt;/c0&gt;):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるいはまた、互換性を持つ１つ以上の項目からなる配列を、追加代入演算子（&lt;c0&gt;&lt;s1&gt;+=&lt;/s1&gt;&lt;/c0&gt;）を使って加えることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, enumeration cases can specify associated values of &lt;e0&gt;any&lt;/e0&gt; type to be stored along with each different case value, much as unions or variants do in other languages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代わりに、列挙ケース節は、ほとんど他の言語における共用体型やバリアント型がするように、それぞれ異なるケース節の値と一緒に格納されるために、&lt;e0&gt;あらゆる&lt;/e0&gt;型の関連値を指定することが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, if the context already provides type information, such as a function argument or an already typed variable or constant, you can create an empty array with an empty array literal, which is written as &lt;c0&gt;&lt;s1&gt;[]&lt;/s1&gt;&lt;/c0&gt; (an empty pair of square brackets):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代わりに、前後関係がすでに型の情報を、例えば関数の引数またはすでに型指定された変数や定数などを提供するならば、あなたは空の配列を空の配列リテラル、&lt;c0&gt;&lt;s1&gt;[]&lt;/s1&gt;&lt;/c0&gt;（１対の空の角括弧）のように書かれるものでつくることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, if the context already provides type information, such as a function argument or an already typed variable or constant, you can create an empty set with an empty array literal:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるいはまた、関数の引数や既に型付けされた変数や定数のように、文脈がすでに型情報を提供するならば、あなたは空の集合を空の配列リテラルで作成することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, remove a key-value pair from a dictionary with the &lt;c0&gt;&lt;s1&gt;removeValue(forKey:)&lt;/s1&gt;&lt;/c0&gt; method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるいは代わりに、&lt;c0&gt;&lt;s1&gt;removeValue(forKey:)&lt;/s1&gt;&lt;/c0&gt;メソッドで辞書から「キーと値」の対を削除してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, specify a &lt;e0&gt;default property value&lt;/e0&gt; as part of the property’s declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その代わりの方法として、&lt;e0&gt;省略時のプロパティ値&lt;/e0&gt;をそのプロパティの宣言の一部として指定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, use the underscore character (&lt;c2&gt;&lt;s3&gt;_&lt;/s3&gt;&lt;/c2&gt;), also known as the wildcard pattern, to match any possible value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるいはまた、起こりうるどんな値にもマッチするにはアンダースコア文字（&lt;c2&gt;&lt;s3&gt;_&lt;/s3&gt;&lt;/c2&gt;）、またワイルドカードパターンとして知られるもの、を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, you can create a stand-alone &lt;c0&gt;&lt;s1&gt;Character&lt;/s1&gt;&lt;/c0&gt; constant or variable from a single-character string literal by providing a &lt;c2&gt;&lt;s3&gt;Character&lt;/s3&gt;&lt;/c2&gt; type annotation:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるいは、あなたは１文字だけの文字列リテラルから単独の&lt;c0&gt;&lt;s1&gt;Character&lt;/s1&gt;&lt;/c0&gt;定数または変数を作成することが、&lt;c2&gt;&lt;s3&gt;Character&lt;/s3&gt;&lt;/c2&gt;型注釈を提供することによって可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, you can define a failable initializer that creates an implicitly unwrapped optional instance of the appropriate type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>またはその代わりに、あなたは適切な型の暗黙的にアンラップされるオプショナルのインスタンスを作成する失敗できるイニシャライザを定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, you can mark an extension with an explicit access-level modifier (for example, &lt;c0&gt;&lt;s1&gt;private&lt;/s1&gt;&lt;/c0&gt;) to set a new default access level for all members defined within the extension.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代わりに、あなたは拡張に明確なアクセス水準修飾子（例えば&lt;c0&gt;&lt;s1&gt;private&lt;/s1&gt;&lt;/c0&gt;）で印して、新しい省略時のアクセス水準をその拡張内で定義される全てのメンバーに設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, you can override a superclass failable initializer with a subclass &lt;e0&gt;nonfailable&lt;/e0&gt; initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>または代わりに、あなたはスーパークラスの失敗できるイニシャライザをサブクラスの&lt;e0&gt;失敗できない&lt;/e0&gt;イニシャライザでオーバーライドできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although &lt;c0&gt;&lt;s1&gt;break&lt;/s1&gt;&lt;/c0&gt; is not required in Swift, you can use a &lt;c2&gt;&lt;s3&gt;break&lt;/s3&gt;&lt;/c2&gt; statement to match and ignore a particular case or to break out of a matched case before that case has completed its execution.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;break&lt;/s1&gt;&lt;/c0&gt;はスウィフトでは必要とされないけれども、あなたは&lt;c2&gt;&lt;s3&gt;break&lt;/s3&gt;&lt;/c2&gt;文を特定のケース節を適合してから無視するために、または適合したケース節をそのケース節がそれの実行を完了してしまう前に抜け出すために使うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although both functions have names that begin with &lt;c12&gt;&lt;s13&gt;greet&lt;/s13&gt;&lt;/c12&gt;, the &lt;c14&gt;&lt;s15&gt;greet(person:alreadyGreeted:)&lt;/s15&gt;&lt;/c14&gt; function takes two arguments but the &lt;c16&gt;&lt;s17&gt;greet(person:)&lt;/s17&gt;&lt;/c16&gt; function takes only one.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方の関数が&lt;c12&gt;&lt;s13&gt;greet&lt;/s13&gt;&lt;/c12&gt;で始まる名前を持つとはいえ、&lt;c14&gt;&lt;s15&gt;greet(person:alreadyGreeted:)&lt;/s15&gt;&lt;/c14&gt;関数は２つの引数を取りますが&lt;c16&gt;&lt;s17&gt;greet(person:)&lt;/s17&gt;&lt;/c16&gt;関数はただ１つだけ取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although conforming types don’t have to provide their own implementation of either, requirements with default implementations can be called without optional chaining.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どちらにおいても準拠する型がそれ自身の実装を提供しなくても良いけれども、省略時の実装を持つ要件はオプショナル連鎖なしに呼ばれることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although either &lt;c2&gt;&lt;s3&gt;inlinable&lt;/s3&gt;&lt;/c2&gt; or &lt;c4&gt;&lt;s5&gt;usableFromInline&lt;/s5&gt;&lt;/c4&gt; can be applied to &lt;c6&gt;&lt;s7&gt;internal&lt;/s7&gt;&lt;/c6&gt; declarations, applying both attributes is an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>けれども&lt;c2&gt;&lt;s3&gt;inlinable&lt;/s3&gt;&lt;/c2&gt;または&lt;c4&gt;&lt;s5&gt;usableFromInline&lt;/s5&gt;&lt;/c4&gt;のどちらかは、&lt;c6&gt;&lt;s7&gt;internal&lt;/s7&gt;&lt;/c6&gt;宣言に適用できます、両方の属性を適用することはエラーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although it’s common to define individual types in separate source files, a single source file can contain definitions for multiple types, functions, and so on.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>通常は個々の型を別々のソースファイルに定義しますが、単一のソースファイルは、複数の型、関数、その他の定義を含むことが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although it’s not specified as part of the protocol, it’s assumed that this value will be a number from &lt;c6&gt;&lt;s7&gt;0.0&lt;/s7&gt;&lt;/c6&gt; up to (but not including) &lt;c8&gt;&lt;s9&gt;1.0&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはプロトコルの一部として指定されないけれども、この値は&lt;c6&gt;&lt;s7&gt;0.0&lt;/s7&gt;&lt;/c6&gt;から&lt;c8&gt;&lt;s9&gt;1.0&lt;/s9&gt;&lt;/c8&gt;まで（しかし含めてではない）のある数であるのを仮定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although it’s possible for multiple parameters to have the same argument label, unique argument labels help make your code more readable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数のパラメータが同じ引数ラベルを持つことは可能であるとは言え、特有な引数ラベルはあなたのコードをより読みやすくする助けとなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although properties and methods declared in the &lt;e0&gt;superclass&lt;/e0&gt; are inherited by the current class, designated initializers declared in the &lt;e1&gt;superclass&lt;/e1&gt; are only inherited when the subclass meets the conditions described in &lt;a2&gt;&lt;s3&gt;Automatic Initializer Inheritance&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;スーパークラス&lt;/e0&gt;の中で宣言されるプロパティやメソッドは現在のクラスによって継承されるけれども、&lt;e1&gt;スーパークラス&lt;/e1&gt;の中で宣言される指定イニシャライザはただサブクラスが&lt;a2&gt;&lt;s3&gt;自動的なイニシャライザ継承&lt;/s3&gt;&lt;/a2&gt;で記述される条件と出会う場合に継承されるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although technically allowed, this wouldn’t make for a very good data source.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>技術的には可能であるけれども、これはあまり良いデータ・ソースにつながりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the &lt;e0&gt;method name&lt;/e0&gt; and the &lt;e1&gt;property name&lt;/e1&gt; are expressions, they’re never evaluated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;method name（メソッド名）&lt;/e0&gt;と&lt;e1&gt;property name（プロパティ名）&lt;/e1&gt;は式であるけれども、それらは決して評価されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the &lt;e0&gt;property name&lt;/e0&gt; is an expression, it is never evaluated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;property name（プロパティ名）&lt;/e0&gt;は式であるけれども、それは決して評価されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the actual execution order of pattern-matching operations, and in particular the evaluation order of patterns in cases, is unspecified, pattern matching in a &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; statement behaves as if the evaluation is performed in source order—that is, the order in which they appear in source code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>けれどもパターンマッチ操作の実際の実行順序、とりわけケース節の中のパターンの評価順序は指定されません、&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;文のパターンマッチングはまるでその評価がソース順 ― すなわち、それらがソース・コードにおいて現れる順番、で実行されるかのようにふるまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the generic &lt;c3&gt;&lt;s4&gt;where&lt;/s4&gt;&lt;/c3&gt; clause provides syntactic sugar for expressing simple constraints on type parameters (for example, &lt;c5&gt;&lt;s6&gt;&lt;T:&lt;/s6&gt; &lt;s7&gt;Comparable&gt;&lt;/s7&gt;&lt;/c5&gt; is equivalent to &lt;c8&gt;&lt;s9&gt;&lt;T&gt;&lt;/s9&gt; &lt;s10&gt;where&lt;/s10&gt; &lt;s11&gt;T:&lt;/s11&gt; &lt;s12&gt;Comparable&lt;/s12&gt;&lt;/c8&gt; and so on), you can use it to provide more complex constraints on type parameters and their associated types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体&lt;c3&gt;&lt;s4&gt;where&lt;/s4&gt;&lt;/c3&gt;節は、型パラメータ上で単純な制約を表すために糖衣構文を提供しますが（例えば、&lt;c5&gt;&lt;s6&gt;&lt;T:&lt;/s6&gt; &lt;s7&gt;Comparable&gt;&lt;/s7&gt;&lt;/c5&gt;は&lt;c8&gt;&lt;s9&gt;&lt;T&gt;&lt;/s9&gt; &lt;s10&gt;where&lt;/s10&gt; &lt;s11&gt;T:&lt;/s11&gt; &lt;s12&gt;Comparable&lt;/s12&gt;&lt;/c8&gt;に等しいなどなど）、あなたはそれを使ってより複雑な制約を型パラメータとそれの関連型に提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the indexes used to access the elements can be of any type, each parameter must include a type annotation to specify the type of each index.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>要素にアクセスするために使用されるインデックスは、どんな型でも可能であるけれども、各パラメータは型注釈を含んで、各インデックスの型を指定しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the rest of its functionality is not shown, the purpose of this &lt;c6&gt;&lt;s7&gt;DataManager&lt;/s7&gt;&lt;/c6&gt; class is to manage and provide access to this array of &lt;c8&gt;&lt;s9&gt;String&lt;/s9&gt;&lt;/c8&gt; data.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その機能性の残りの部分は示されないけれども、この&lt;c6&gt;&lt;s7&gt;DataManager&lt;/s7&gt;&lt;/c6&gt;クラスの目的はこの&lt;c8&gt;&lt;s9&gt;String&lt;/s9&gt;&lt;/c8&gt;データの配列を管理して、アクセス提供することになっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the two forms are functionally equivalent, the shorthand form is preferred whenever possible.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つの書式は機能的に等しいですが、可能であればいつでも略記書式が好ましいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the two forms are functionally identical, the shorthand form is preferred and is used throughout this guide when referring to the type of a dictionary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つの書式は機能的に同一であるけれども、短縮形がむしろ好まれ、このガイドを通して辞書の型に言及するときに使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the two forms are functionally identical, the shorthand form is preferred and is used throughout this guide when referring to the type of an array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つの書式は機能的に同一であるけれども、短縮形がむしろ好まれ、このガイドを通して配列の型に言及するとき使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although the unary plus operator doesn’t actually do anything, you can use it to provide symmetry in your code for positive numbers when also using the unary minus operator for negative numbers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単項プラス演算子は実際に何もしないけれども、あなたは、負の数に単項マイナス演算子を使うときに、正の数に対してもまたあなたのコードで釣り合いを取るためにそれを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although these types, functions, and operators are not part of the Swift language itself, they are used extensively in the discussions and code examples in this part of the book.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの型、関数、そして演算子は、スウィフト言語自身の一部ではないけれども、それらは本のこの部分の議論とコード例で広く使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although they are implemented as computed properties, the names of these properties can be appended to a floating-point literal value with dot syntax, as a way to use that literal value to perform distance conversions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらは計算プロパティとして実装されるけれども、これらのプロパティの名前はある浮動小数点リテラル値に、そのリテラル値を距離変換を実行するために使う方法として、ドット構文で追加されることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although you can define custom operators that contain a question mark (&lt;c0&gt;&lt;s1&gt;?&lt;/s1&gt;&lt;/c0&gt;), they can’t consist of a single question mark character only.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは疑問符（&lt;c0&gt;&lt;s1&gt;?&lt;/s1&gt;&lt;/c0&gt;）を含むあつらえの演算子を定義できるけれども、それは単一の疑問符文字だけから構成されることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although you can query the current value of the &lt;c0&gt;&lt;s1&gt;numberOfEdits&lt;/s1&gt;&lt;/c0&gt; property from within another source file, you can’t &lt;e2&gt;modify&lt;/e2&gt; the property from another source file.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは別のソースファイル内から&lt;c0&gt;&lt;s1&gt;numberOfEdits&lt;/s1&gt;&lt;/c0&gt;プロパティの現在の値についてたずねることができるけれども、あなたは別のソースファイルからこのプロパティを&lt;e2&gt;修正&lt;/e2&gt;できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Although you write &lt;c2&gt;&lt;s3&gt;return&lt;/s3&gt; &lt;s4&gt;nil&lt;/s4&gt;&lt;/c2&gt; to trigger an initialization failure, you do not use the &lt;c5&gt;&lt;s6&gt;return&lt;/s6&gt;&lt;/c5&gt; keyword to indicate initialization success.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは&lt;c2&gt;&lt;s3&gt;return&lt;/s3&gt; &lt;s4&gt;nil&lt;/s4&gt;&lt;/c2&gt;を書くことで初期化失敗を引き起こすけれども、あなたは&lt;c5&gt;&lt;s6&gt;return&lt;/s6&gt;&lt;/c5&gt;キーワードを初期化成功を指し示すためには使いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Always give type parameters upper camel case names (such as &lt;c0&gt;&lt;s1&gt;T&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;MyTypeParameter&lt;/s3&gt;&lt;/c2&gt;) to indicate that they’re a placeholder for a &lt;e4&gt;type&lt;/e4&gt;, not a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらが、値ではなく、&lt;e4&gt;型&lt;/e4&gt;のためのプレースホルダであることを示すために、型パラメータに常にアッパーキャメルケース名（例えば&lt;c0&gt;&lt;s1&gt;T&lt;/s1&gt;&lt;/c0&gt;や&lt;c2&gt;&lt;s3&gt;MyTypeParameter&lt;/s3&gt;&lt;/c2&gt;など）を与えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Always make sure that an optional contains a non-&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt; value before using &lt;c4&gt;&lt;s5&gt;!&lt;/s5&gt;&lt;/c4&gt; to force-unwrap its value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>必ずあるオプショナルが&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;ではない値を含むことを、それの値を強制アンラップする&lt;c4&gt;&lt;s5&gt;!&lt;/s5&gt;&lt;/c4&gt;を使う前に確かめてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Always prefix type property requirements with the &lt;c0&gt;&lt;s1&gt;static&lt;/s1&gt;&lt;/c0&gt; keyword when you define them in a protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがあるプロトコルにおいてそれを定義するとき、常に、型プロパティ要件の前に&lt;c0&gt;&lt;s1&gt;static&lt;/s1&gt;&lt;/c0&gt;キーワードを置いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Always use a &lt;c4&gt;&lt;s5&gt;break&lt;/s5&gt;&lt;/c4&gt; statement to ignore a &lt;c6&gt;&lt;s7&gt;switch&lt;/s7&gt;&lt;/c6&gt; case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;switch&lt;/s7&gt;&lt;/c6&gt;ケース節を無視するために、常に&lt;c4&gt;&lt;s5&gt;break&lt;/s5&gt;&lt;/c4&gt;文を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Always use a normal optional type if you need to check for a &lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt; value during the lifetime of a variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある変数の生涯のある時期に&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;値について確認する必要があるならば、必ず普通のオプショナル型を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;a0&gt;&lt;s1&gt;Optional-Chaining Expression&lt;/s1&gt;&lt;/a0&gt; must appear within a postfix expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとつの&lt;a0&gt;&lt;s1&gt;オプショナル連鎖式&lt;/s1&gt;&lt;/a0&gt;が、ひとつの接尾辞式の内部に現れなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;c0&gt;&lt;s1&gt;Int8&lt;/s1&gt;&lt;/c0&gt; constant or variable can store numbers between &lt;c2&gt;&lt;s3&gt;-128&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;127&lt;/s5&gt;&lt;/c4&gt;, whereas a &lt;c6&gt;&lt;s7&gt;UInt8&lt;/s7&gt;&lt;/c6&gt; constant or variable can store numbers between &lt;c8&gt;&lt;s9&gt;0&lt;/s9&gt;&lt;/c8&gt; and &lt;c10&gt;&lt;s11&gt;255&lt;/s11&gt;&lt;/c10&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Int8&lt;/s1&gt;&lt;/c0&gt;定数または変数は、&lt;c2&gt;&lt;s3&gt;-128&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;127&lt;/s5&gt;&lt;/c4&gt;の間の数を格納することができる一方、&lt;c6&gt;&lt;s7&gt;UInt8&lt;/s7&gt;&lt;/c6&gt;定数または変数は、&lt;c8&gt;&lt;s9&gt;0&lt;/s9&gt;&lt;/c8&gt;と&lt;c10&gt;&lt;s11&gt;255&lt;/s11&gt;&lt;/c10&gt;の間の数を格納することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;c0&gt;&lt;s1&gt;available&lt;/s1&gt;&lt;/c0&gt; attribute that specifies availability using a Swift version number can’t additionally specify a declaration’s platform availability.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトバージョン数を使って利用可能性を指定している&lt;c0&gt;&lt;s1&gt;available&lt;/s1&gt;&lt;/c0&gt;属性は、ある宣言の持つプラットホーム有効性を追加的に指定することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt; statement is used for executing code based on the evaluation of one or more conditions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt;文は、１つ以上の条件の評価に基づいてコードを実行するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;c2&gt;&lt;s3&gt;available&lt;/s3&gt;&lt;/c2&gt; attribute that specifies availability using a Swift version number can’t use the asterisk.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトバージョン数を使って有効性を指定する&lt;c2&gt;&lt;s3&gt;available&lt;/s3&gt;&lt;/c2&gt;属性は、アスタリスクを使用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;c4&gt;&lt;s5&gt;if&lt;/s5&gt;&lt;/c4&gt; statement chained together in this way has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このやり方で一緒につながれる&lt;c4&gt;&lt;s5&gt;if&lt;/s5&gt;&lt;/c4&gt;文は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;e0&gt;array literal&lt;/e0&gt; is an ordered collection of values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;配列リテラル&lt;/e0&gt;は、順序付けられた値のコレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;e0&gt;array&lt;/e0&gt; stores values of the same type in an ordered list.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;配列&lt;/e0&gt;は、同じ型の値を順序リストに保管します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;e0&gt;associated type&lt;/e0&gt; gives a placeholder name to a type that is used as part of the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;関連型&lt;/e0&gt;は、プロトコルの一部として使われる型にプレースホルダ名を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;e0&gt;autoclosure&lt;/e0&gt; is a closure that is automatically created to wrap an expression that’s being passed as an argument to a function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;自動クロージャ&lt;/e0&gt;は、自動的に作成されて、引数として関数に渡されている式を包み込むクロージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;e0&gt;availability condition&lt;/e0&gt; is used as a condition of an &lt;c1&gt;&lt;s2&gt;if&lt;/s2&gt;&lt;/c1&gt;, &lt;c3&gt;&lt;s4&gt;while&lt;/s4&gt;&lt;/c3&gt;, and &lt;c5&gt;&lt;s6&gt;guard&lt;/s6&gt;&lt;/c5&gt; statement to query the availability of APIs at runtime, based on specified platforms arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;有効性条件&lt;/e0&gt;は、&lt;c1&gt;&lt;s2&gt;if&lt;/s2&gt;&lt;/c1&gt;、&lt;c3&gt;&lt;s4&gt;while&lt;/s4&gt;&lt;/c3&gt;、そして&lt;c5&gt;&lt;s6&gt;guard&lt;/s6&gt;&lt;/c5&gt;文の条件として使われて、APIの有効性を実行時に、指定されたプラットホーム引数に基づいて問いただします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;e0&gt;enumeration case pattern&lt;/e0&gt; matches a case of an existing enumeration type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;列挙ケース節パターン&lt;/e0&gt;は、既存の列挙型のケース節にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;e0&gt;enumeration declaration&lt;/e0&gt; introduces a named enumeration type into your program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;列挙宣言&lt;/e0&gt;は、名前をつけられた列挙型をあなたのプログラムに導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;e0&gt;enumeration&lt;/e0&gt; defines a common type for a group of related values and enables you to work with those values in a type-safe way within your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;列挙&lt;/e0&gt;は、一群の関連した値のための共通の型を定義して、それらの値を型安全な方法であなたのコード内で扱えるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;e0&gt;explicit member expression&lt;/e0&gt; allows access to the members of a named type, a tuple, or a module.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;明示的メンバー式&lt;/e0&gt;は、名前付きの型、タプル、またはモジュールのメンバーに対するアクセスを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;e0&gt;expression pattern&lt;/e0&gt; represents the value of an expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;式パターン&lt;/e0&gt;は、ある式の値を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;e0&gt;extension declaration&lt;/e0&gt; allows you to extend the behavior of existing types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;拡張宣言&lt;/e0&gt;があなたに可能にするのは、既存の型の挙動を拡張することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;e0&gt;identifier pattern&lt;/e0&gt; matches any value and binds the matched value to a variable or constant name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;識別子パターン&lt;/e0&gt;は、どんな値にでもマッチして、マッチされた値を変数や定数の名前に縛りつけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;e0&gt;implicit member expression&lt;/e0&gt; is an abbreviated way to access a member of a type, such as an enumeration case or a type method, in a context where type inference can determine the implied type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;暗黙のメンバー式&lt;/e0&gt;は、型推論が暗黙の型を決定することができる前後関係において、例えば列挙のケース節や型メソッドなど、ある型のメンバーにアクセスするための簡略された方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;e0&gt;import declaration&lt;/e0&gt; lets you access symbols that are declared outside the current file.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;インポート宣言&lt;/e0&gt;は、あなたに現在のファイルの外側で宣言されるシンボルにアクセスさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;e0&gt;infix operator&lt;/e0&gt; is a binary operator that is written between its two operands, such as the familiar addition operator (&lt;c1&gt;&lt;s2&gt;+&lt;/s2&gt;&lt;/c1&gt;) in the expression &lt;c3&gt;&lt;s4&gt;1&lt;/s4&gt; &lt;s5&gt;+&lt;/s5&gt; &lt;s6&gt;2&lt;/s6&gt;&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;接中辞演算子&lt;/e0&gt;は、それの２つ演算数の間で書かれる二項演算子です、例えば式&lt;c3&gt;&lt;s4&gt;1&lt;/s4&gt; &lt;s5&gt;+&lt;/s5&gt; &lt;s6&gt;2&lt;/s6&gt;&lt;/c3&gt;でのよく知られた加算演算子（&lt;c1&gt;&lt;s2&gt;+&lt;/s2&gt;&lt;/c1&gt;）など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;e0&gt;initializer declaration&lt;/e0&gt; introduces an initializer for a class, structure, or enumeration into your program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;イニシャライザ宣言&lt;/e0&gt;は、あなたのプログラムにクラス、構造体、または列挙のためのイニシャライザを導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;e0&gt;initializer expression&lt;/e0&gt; provides access to a type’s initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、スーパークラスのイニシャライザに委任するために、&lt;e0&gt;イニシャライザ式&lt;/e0&gt;を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;e0&gt;n&lt;/e0&gt;-times-table is based on a fixed mathematical rule.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>九九の&lt;e0&gt;n&lt;/e0&gt;の段は、決められた数学的な規則に基づきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;e0&gt;octal&lt;/e0&gt; number, with a &lt;c1&gt;&lt;s2&gt;0o&lt;/s2&gt;&lt;/c1&gt; prefix</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;８進&lt;/e0&gt;数は、接頭辞&lt;c1&gt;&lt;s2&gt;0o&lt;/s2&gt;&lt;/c1&gt;つきで</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;e0&gt;opaque type&lt;/e0&gt; defines a type that conforms to a protocol or protocol composition, without specifying the underlying concrete type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;不透明型&lt;/e0&gt;は、あるプロトコルまたはプロトコル合成に準拠するある型を定義します、基礎をなす具象型を指定することなしに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;e0&gt;operator declaration&lt;/e0&gt; introduces a new infix, prefix, or postfix operator into your program and is declared using the &lt;c1&gt;&lt;s2&gt;operator&lt;/s2&gt;&lt;/c1&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;演算子宣言&lt;/e0&gt;は、新しい接中辞、接頭辞、または接尾辞演算子をあなたのプログラムに導入します、そしてキーワード&lt;c1&gt;&lt;s2&gt;operator&lt;/s2&gt;&lt;/c1&gt;を使って宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;e0&gt;operator&lt;/e0&gt; is a special symbol or phrase that you use to check, change, or combine values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;演算子&lt;/e0&gt;は、あなたがいろいろな値を調べたり、変えたり、結合したりするために使う、特別な記号または語句です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;e0&gt;optional pattern&lt;/e0&gt; matches values wrapped in a &lt;c1&gt;&lt;s2&gt;some(Wrapped)&lt;/s2&gt;&lt;/c1&gt; case of an &lt;c3&gt;&lt;s4&gt;Optional&lt;Wrapped&gt;&lt;/s4&gt;&lt;/c3&gt; enumeration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;オプショナルパターン&lt;/e0&gt;は、&lt;c3&gt;&lt;s4&gt;Optional&lt;Wrapped&gt;&lt;/s4&gt;&lt;/c3&gt;列挙の&lt;c1&gt;&lt;s2&gt;Some(Wrapped)&lt;/s2&gt;&lt;/c1&gt;ケース節でラップされる値にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;e0&gt;optional-chaining expression&lt;/e0&gt; provides a simplified syntax for using optional values in postfix expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;オプショナル連鎖式&lt;/e0&gt;は、オプショナルの値を使うために単純化された構文を接尾辞式において提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An &lt;e0&gt;optional-try expression&lt;/e0&gt; consists of the &lt;c1&gt;&lt;s2&gt;try?&lt;/s2&gt;&lt;/c1&gt; operator followed by an expression that can throw an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;オプショナルtry式&lt;/e0&gt;は、&lt;c1&gt;&lt;s2&gt;try?&lt;/s2&gt;&lt;/c1&gt;演算子と後につづくエラーをスローできる１つの式から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An HTTP status code is a special value returned by a web server whenever you request a web page.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>HTTP状態コードは、あなたがウェブ・ページを要請するときはいつでもウェブ・サーバーによって返されるある特別な値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An access is &lt;e0&gt;instantaneous&lt;/e0&gt; if it’s not possible for other code to run after that access starts but before it ends.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるアクセスは、もしそのアクセスが始まった後でしかしそれが終わる前に他のコードに実行が可能でないならば、&lt;e0&gt;即時的&lt;/e0&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An arbitrary Unicode scalar value, written as &lt;c0&gt;&lt;s1&gt;\u{&lt;/s1&gt;&lt;/c0&gt;&lt;e2&gt;n&lt;/e2&gt;&lt;c3&gt;&lt;s4&gt;}&lt;/s4&gt;&lt;/c3&gt;, where &lt;e5&gt;n&lt;/e5&gt; is a 1–8 digit hexadecimal number (Unicode is discussed in &lt;a6&gt;&lt;s7&gt;Unicode&lt;/s7&gt;&lt;/a6&gt; below)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>随意のユニコードスカラー値、&lt;c0&gt;&lt;s1&gt;\u{&lt;/s1&gt;&lt;/c0&gt;&lt;e2&gt;n&lt;/e2&gt;&lt;c3&gt;&lt;s4&gt;}&lt;/s4&gt;&lt;/c3&gt;のように書かれます、ここで&lt;e5&gt;n&lt;/e5&gt;は1–8桁の16進数です（ユニコードは下の&lt;a6&gt;&lt;s7&gt;Unicode&lt;/s7&gt;&lt;/a6&gt;で議論されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An array allows new items to be inserted and removed at any location in the array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列は、新しい項目を差し込まれたり取り外除かれることがその配列のどんな場所においても許されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An array literal is written as a list of values, separated by commas, surrounded by a pair of square brackets:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列リテラルは、一対の角括弧に囲まれて、コンマで区切られる値のリストとして書かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An arrow (→) is used to mark grammar productions and can be read as “can consist of.”</seg>
      </tuv>
      <tuv lang="JA">
        <seg>矢印（→）を使って文法導出を示します、「その文法はこうしたものから成り立つことができる」と読まれることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An assertion is triggered if you try to access a subscript that is outside of the matrix bounds:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがマトリックス境界の外にある添え字にアクセスしようとするならば、表明が引き起こされます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An associated type provides an alias for a type that is used as part of a protocol’s declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連型は、エイリアスをプロトコルの宣言の一部として使われる型のために用意します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An attribute provides additional information about the declaration or type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>属性は、宣言または型についての追加的な情報を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An autoclosure lets you delay evaluation, because the code inside isn’t run until you call the closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>自動クロージャは、あなたに評価を延期させます、内部のコードはあなたがそのクロージャを呼び出すまで実行されないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An availability condition has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>有効性条件は以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An eight-bit number has seven value bits, so this means &lt;c6&gt;&lt;s7&gt;2&lt;/s7&gt;&lt;/c6&gt; to the power of &lt;c8&gt;&lt;s9&gt;7&lt;/s9&gt;&lt;/c8&gt;, or &lt;c10&gt;&lt;s11&gt;128&lt;/s11&gt;&lt;/c10&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>８ビットの数は７つの値ビットを持ちますので、これは&lt;c6&gt;&lt;s7&gt;2&lt;/s7&gt;&lt;/c6&gt;の&lt;c8&gt;&lt;s9&gt;7&lt;/s9&gt;&lt;/c8&gt;乗、つまり&lt;c10&gt;&lt;s11&gt;128&lt;/s11&gt;&lt;/c10&gt;を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An element name consists of an identifier followed immediately by a colon (:).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>要素名は、識別子に直ちにコロン（：）が続くものから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An empty dictionary literal is written as a colon inside a pair of brackets (&lt;c11&gt;&lt;s12&gt;[:]&lt;/s12&gt;&lt;/c11&gt;) to distinguish it from an empty array literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>空の辞書リテラルは、一対の角括弧の中のコロン（&lt;c11&gt;&lt;s12&gt;[:]&lt;/s12&gt;&lt;/c11&gt;）として書かれることで、空の配列リテラルからそれを区別します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An enclosing function can also return one of its nested functions to allow the nested function to be used in another scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>囲んでいる関数は、また、入れ子にされた関数が別のスコープにおいて使われるのを許可するために、その入れ子にされた関数のうちの１つを返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An enumeration case pattern also matches values of that case wrapped in an optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙ケースパターンはまた、オプショナルの中にラップされたそのケース節の値それらにマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An enumeration marked &lt;c6&gt;&lt;s7&gt;usableFromInline&lt;/s7&gt;&lt;/c6&gt; can use only types that are public or &lt;c8&gt;&lt;s9&gt;usableFromInline&lt;/s9&gt;&lt;/c8&gt; for the raw values and associated values of its cases.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;usableFromInline&lt;/s7&gt;&lt;/c6&gt;で印される列挙は、生の値およびそれの列挙節の関連値に対してパブリックまたは&lt;c8&gt;&lt;s9&gt;usableFromInline&lt;/s9&gt;&lt;/c8&gt;である型のみに使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An enumeration that is marked with the &lt;c0&gt;&lt;s1&gt;indirect&lt;/s1&gt;&lt;/c0&gt; modifier can contain a mixture of cases that have associated values and cases those that don’t.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;indirect&lt;/s1&gt;&lt;/c0&gt;修飾子で印される列挙は、関連値を持つケース節とそうでないケース節の入り交じったものを持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An explicit spelling of &lt;c0&gt;&lt;s1&gt;unowned&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;unowned&lt;/s1&gt;&lt;/c0&gt;の明確なつづり方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An extended grapheme cluster is a sequence of one or more Unicode scalars that (when combined) produce a single human-readable character.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある拡張書記素クラスタは１つ以上のユニコード・スカラーの連なりです、それは（組み合わされて）人間の読み取り可能な１つの文字を作り出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An extension can be used to extend an existing generic type, as described in &lt;a0&gt;&lt;s1&gt;Extending a Generic Type&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張は、既存の総称体型を拡張するために使われることができます、&lt;a0&gt;&lt;s1&gt;総称体型を拡張する&lt;/s1&gt;&lt;/a0&gt;で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An extension can extend an existing type to make it adopt one or more protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張は、既存の型を拡張して、それが１つ以上のプロトコルを採用するようにできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An implementation of &lt;c0&gt;&lt;s1&gt;subscript(dynamicMemberLookup:)&lt;/s1&gt;&lt;/c0&gt; can accept key paths using an argument of type &lt;a2&gt;&lt;c3&gt;&lt;s4&gt;KeyPath&lt;/s4&gt;&lt;/c3&gt;&lt;/a2&gt;&lt;s5&gt; [https://developer.apple.com/documentation/swift/keypath]&lt;/s5&gt;, &lt;a6&gt;&lt;c7&gt;&lt;s8&gt;WritableKeyPath&lt;/s8&gt;&lt;/c7&gt;&lt;/a6&gt;&lt;s9&gt; [https://developer.apple.com/documentation/swift/writablekeypath]&lt;/s9&gt;, or &lt;a10&gt;&lt;c11&gt;&lt;s12&gt;ReferenceWritableKeyPath&lt;/s12&gt;&lt;/c11&gt;&lt;/a10&gt;&lt;s13&gt; [https://developer.apple.com/documentation/swift/referencewritablekeypath]&lt;/s13&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;subscript(dynamicMemberLookup:)&lt;/s1&gt;&lt;/c0&gt;の実装はキーパスを、型&lt;a2&gt;&lt;c3&gt;&lt;s4&gt;KeyPath&lt;/s4&gt;&lt;/c3&gt;&lt;/a2&gt;&lt;s5&gt; [https://developer.apple.com/documentation/swift/keypath]&lt;/s5&gt;、&lt;a6&gt;&lt;c7&gt;&lt;s8&gt;WritableKeyPath&lt;/s8&gt;&lt;/c7&gt;&lt;/a6&gt;&lt;s9&gt; [https://developer.apple.com/documentation/swift/writablekeypath]&lt;/s9&gt;、または&lt;a10&gt;&lt;c11&gt;&lt;s12&gt;ReferenceWritableKeyPath&lt;/s12&gt;&lt;/c11&gt;&lt;/a10&gt;&lt;s13&gt; [https://developer.apple.com/documentation/swift/referencewritablekeypath]&lt;/s13&gt;の引数を使って受け入れ可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An implicitly unwrapped optional is a normal optional behind the scenes, but can also be used like a non-optional value, without the need to unwrap the optional value each time it’s accessed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗黙的にアンラップされるオプショナルは、舞台裏では普通のオプショナルです、しかしまたオプショナルでない値のように扱うこともできます、それがアクセスされるたびにオプショナルの値をアンラップする必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An in-out parameter has a value that is passed &lt;e2&gt;in&lt;/e2&gt; to the function, is modified by the function, and is passed back &lt;e3&gt;out&lt;/e3&gt; of the function to replace the original value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>in-outパラメータはある値を持ち、それは関数の&lt;e2&gt;中に&lt;/e2&gt;渡されて、その関数によって修正されて、それから逆にその関数の&lt;e3&gt;外に&lt;/e3&gt;渡されて本来の値に取って代わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An indirect case must have an associated value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関節参照のケース節は、関連値を持っていなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An initializer cannot call any instance methods, read the values of any instance properties, or refer to &lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt; as a value until after the first phase of initialization is complete.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザは、初期化の最初の段階が完了するまで、どんなインスタンスメソッドも呼ぶこと、どんなインスタンスプロパティの値も読むこと、または&lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;をひとつの値として参照することができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An instance method can be called only on a specific instance of the type it belongs to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インスタンスメソッドは、それが属している型のある特定のインスタンスでだけ呼ばれることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An instance method has implicit access to all other instance methods and properties of that type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるインスタンスメソッドは、無条件にその型の他のインスタンスメソッドとプロパティの全てへのアクセスを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An instance of &lt;c0&gt;&lt;s1&gt;Hoverboard&lt;/s1&gt;&lt;/c0&gt; uses the default number of wheels supplied by the &lt;c2&gt;&lt;s3&gt;Vehicle&lt;/s3&gt;&lt;/c2&gt; initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Hoverboard&lt;/s1&gt;&lt;/c0&gt;のインスタンスは、&lt;c2&gt;&lt;s3&gt;Vehicle&lt;/s3&gt;&lt;/c2&gt;イニシャライザによって提供される省略時の車輪数を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An instance of a class is traditionally known as an &lt;e0&gt;object&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスのインスタンスは、伝統的に&lt;e0&gt;オブジェクト&lt;/e0&gt;として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An integer type can be initialized with a &lt;c0&gt;&lt;s1&gt;Double&lt;/s1&gt;&lt;/c0&gt; or &lt;c2&gt;&lt;s3&gt;Float&lt;/s3&gt;&lt;/c2&gt; value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数型は、&lt;c0&gt;&lt;s1&gt;Double&lt;/s1&gt;&lt;/c0&gt;または&lt;c2&gt;&lt;s3&gt;Float&lt;/s3&gt;&lt;/c2&gt;値で初期化されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An opaque type lets the function implementation pick the type for the value it returns in a way that’s abstracted away from the code that calls the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある不透明型は、関数実装に、それが返す値に対する型を、その関数を呼び出すコードから離れて抽象化されるある方法で選択させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An opaque type refers to one specific type, although the caller of the function isn’t able to see which type; a protocol type can refer to any type that conforms to the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>不透明型は１つの特定の型を参照します、とはいえ関数の呼び出し側はどの型か知ることができません；プロトコル型はそのプロトコルに準拠するどんな型でも参照できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An optional &lt;c5&gt;&lt;s6&gt;Int&lt;/s6&gt;&lt;/c5&gt; is written as &lt;c7&gt;&lt;s8&gt;Int?&lt;/s8&gt;&lt;/c7&gt;, not &lt;c9&gt;&lt;s10&gt;Int&lt;/s10&gt;&lt;/c9&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルの&lt;c5&gt;&lt;s6&gt;Int&lt;/s6&gt;&lt;/c5&gt;は、&lt;c7&gt;&lt;s8&gt;Int?&lt;/s8&gt;&lt;/c7&gt;のように書かれます、&lt;c9&gt;&lt;s10&gt;Int&lt;/s10&gt;&lt;/c9&gt;ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An optional protocol requirement can be called with optional chaining, to account for the possibility that the requirement was not implemented by a type that conforms to the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルのプロトコル要件は、オプショナル連鎖を使って呼び出されることができます、それによってプロトコルに準拠する型によって要件が満たされなかったという可能性に対応します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An optional represents two possibilities: Either there &lt;e1&gt;is&lt;/e1&gt; a value, and you can unwrap the optional to access that value, or there &lt;e2&gt;isn’t&lt;/e2&gt; a value at all.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるオプショナルは２つの可能性を表します：ある値が存在&lt;e1&gt;する&lt;/e1&gt;、するとあなたはそのオプショナルをアンラップすることでその値を利用できます、または値がそもそも存在&lt;e2&gt;しない&lt;/e2&gt;かのいずれか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An optional tuple type such as &lt;c0&gt;&lt;s1&gt;(Int,&lt;/s1&gt; &lt;s2&gt;Int)?&lt;/s2&gt;&lt;/c0&gt; is different from a tuple that contains optional types such as &lt;c3&gt;&lt;s4&gt;(Int?,&lt;/s4&gt; &lt;s5&gt;Int?)&lt;/s5&gt;&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;(Int,&lt;/s1&gt; &lt;s2&gt;Int)?&lt;/s2&gt;&lt;/c0&gt;のようなオプショナルタプル型は、&lt;c3&gt;&lt;s4&gt;(Int?,&lt;/s4&gt; &lt;s5&gt;Int?)&lt;/s5&gt;&lt;/c3&gt;のようなオプショナル型を含むタプルとは異なる方式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An optional value either contains a value or contains &lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt; to indicate that a value is missing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルの値は、ある値を含むか、値が見つからないことを示す&lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;を含むかのどちらかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An optional variable is used here, because players can leave the game at any point.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルの変数がここで使われます、なぜなら、プレーヤーはどの時点でもゲームから離れることができるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An overridden method named &lt;c0&gt;&lt;s1&gt;someMethod()&lt;/s1&gt;&lt;/c0&gt; can call the superclass version of &lt;c2&gt;&lt;s3&gt;someMethod()&lt;/s3&gt;&lt;/c2&gt; by calling &lt;c4&gt;&lt;s5&gt;super.someMethod()&lt;/s5&gt;&lt;/c4&gt; within the overriding method implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;someMethod()&lt;/s1&gt;&lt;/c0&gt;という名前のオーバーライドされたメソッドは、オーバーライドしているメソッド実装内で&lt;c4&gt;&lt;s5&gt;super.someMethod()&lt;/s5&gt;&lt;/c4&gt;を呼ぶことによって、スーパークラス版の&lt;c2&gt;&lt;s3&gt;someMethod()&lt;/s3&gt;&lt;/c2&gt;を呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An overridden property called &lt;c0&gt;&lt;s1&gt;someProperty&lt;/s1&gt;&lt;/c0&gt; can access the superclass version of &lt;c2&gt;&lt;s3&gt;someProperty&lt;/s3&gt;&lt;/c2&gt; as &lt;c4&gt;&lt;s5&gt;super.someProperty&lt;/s5&gt;&lt;/c4&gt; within the overriding getter or setter implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;someProperty&lt;/s1&gt;&lt;/c0&gt;と呼ばれるオーバーライドされたプロパティは、オーバーライドしているゲッターまたはセッター実装内で、&lt;c4&gt;&lt;s5&gt;super.someProperty&lt;/s5&gt;&lt;/c4&gt;のようにしてスーパークラス版の&lt;c2&gt;&lt;s3&gt;someProperty&lt;/s3&gt;&lt;/c2&gt;にアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An overridden subscript for &lt;c0&gt;&lt;s1&gt;someIndex&lt;/s1&gt;&lt;/c0&gt; can access the superclass version of the same subscript as &lt;c2&gt;&lt;s3&gt;super[someIndex]&lt;/s3&gt;&lt;/c2&gt; from within the overriding subscript implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;someIndex&lt;/s1&gt;&lt;/c0&gt;のためのオーバーライドされた添え字は、オーバーライドしている添え字実装内から&lt;c2&gt;&lt;s3&gt;super[someIndex]&lt;/s3&gt;&lt;/c2&gt;のようにしてスーパークラス版の同じ添え字にアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An override can make an inherited class member more accessible than its superclass version.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オーバーライドは、継承されたクラス・メンバーを、そのスーパークラス版よりもアクセス度を高くすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An underscore (&lt;c0&gt;&lt;s1&gt;_&lt;/s1&gt;&lt;/c0&gt;) before a parameter name suppresses the argument label.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメーター名の前のアンダースコア（&lt;c0&gt;&lt;s1&gt;_&lt;/s1&gt;&lt;/c0&gt;）は、引数ラベルを抑制します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An underscore (&lt;c0&gt;&lt;s1&gt;_&lt;/s1&gt;&lt;/c0&gt;) parameter is explicitly ignored and can’t be accessed within the body of the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとつのアンダースコア（&lt;c0&gt;&lt;s1&gt;_&lt;/s1&gt;&lt;/c0&gt;）のパラメータは、明確に無視されます、そして関数の本体内でアクセスされることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An unowned reference is expected to always have a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非所有参照は、常にある値を持っていることを期待されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An unowned reference is the appropriate capture method to use to resolve the strong reference cycle in the &lt;c0&gt;&lt;s1&gt;HTMLElement&lt;/s1&gt;&lt;/c0&gt; example from &lt;a2&gt;&lt;s3&gt;Strong Reference Cycles for Closures&lt;/s3&gt;&lt;/a2&gt; above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非所有参照は、上の&lt;a2&gt;&lt;s3&gt;クロージャのための強い参照循環&lt;/s3&gt;&lt;/a2&gt;の&lt;c0&gt;&lt;s1&gt;HTMLElement&lt;/s1&gt;&lt;/c0&gt;例での強い参照循環を解消するのために使うのに適切な捕獲の手法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And &lt;c8&gt;&lt;s9&gt;SomeProtocol.self&lt;/s9&gt;&lt;/c8&gt; returns &lt;c10&gt;&lt;s11&gt;SomeProtocol&lt;/s11&gt;&lt;/c10&gt; itself, not an instance of a type that conforms to &lt;c12&gt;&lt;s13&gt;SomeProtocol&lt;/s13&gt;&lt;/c12&gt; at runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そして、&lt;c8&gt;&lt;s9&gt;SomeProtocol.self&lt;/s9&gt;&lt;/c8&gt;は、&lt;c10&gt;&lt;s11&gt;SomeProtocol&lt;/s11&gt;&lt;/c10&gt;自身を返します、実行時に&lt;c12&gt;&lt;s13&gt;SomeProtocol&lt;/s13&gt;&lt;/c12&gt;に準拠するある型のインスタンスではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And because the value of &lt;c8&gt;&lt;s9&gt;ExampleEnum.c&lt;/s9&gt;&lt;/c8&gt; is explicitly set to &lt;c10&gt;&lt;s11&gt;5&lt;/s11&gt;&lt;/c10&gt;, the value of &lt;c12&gt;&lt;s13&gt;ExampleEnum.d&lt;/s13&gt;&lt;/c12&gt; is automatically incremented from &lt;c14&gt;&lt;s15&gt;5&lt;/s15&gt;&lt;/c14&gt; and is therefore &lt;c16&gt;&lt;s17&gt;6&lt;/s17&gt;&lt;/c16&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そして&lt;c8&gt;&lt;s9&gt;ExampleEnum.cの&lt;/s9&gt;&lt;/c8&gt;値が明示的に&lt;c10&gt;&lt;s11&gt;5&lt;/s11&gt;&lt;/c10&gt;に設定されるので、&lt;c12&gt;&lt;s13&gt;ExampleEnum.d&lt;/s13&gt;&lt;/c12&gt;の値は&lt;c14&gt;&lt;s15&gt;5&lt;/s15&gt;&lt;/c14&gt;から自動的に増加して、したがって&lt;c16&gt;&lt;s17&gt;6&lt;/s17&gt;&lt;/c16&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And just like functions and methods, you use the &lt;c0&gt;&lt;s1&gt;throws&lt;/s1&gt;&lt;/c0&gt; or &lt;c2&gt;&lt;s3&gt;rethrows&lt;/s3&gt;&lt;/c2&gt; keyword after an initializer’s parameters to indicate the appropriate behavior.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そして関数やメソッドのように、あなたは&lt;c0&gt;&lt;s1&gt;throws&lt;/s1&gt;&lt;/c0&gt;または&lt;c2&gt;&lt;s3&gt;rethrows&lt;/s3&gt;&lt;/c2&gt;キーワードをイニシャライザのパラメータの後に使って、ふさわしい挙動を指し示すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And just like functions, you can get a reference to an enumeration case and apply it later in your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらにまさに関数のように、あなたはある列挙ケース節の参照を得ることができ、それを後であなたのコードに応用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And so on.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>などなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And, because weak references need to allow their value to be changed to &lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt; at runtime, they are always declared as variables, rather than constants, of an optional type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そしてまた、弱い参照はそれらの値を実行時に&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;に変更されるのを許される必要があることから、それらは常にオプショナル型の変数として宣言されます、定数ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another choice for enumeration cases is to have values associated with the case—these values are determined when you make the instance, and they can be different for each instance of an enumeration case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙ケース節の別の選択はそのケース節と結びつけられる値を持つことになります — それらの値はあなたがインスタンスを作る時に決定されます、そしてそれらはある列挙ケース節のインスタンスそれぞれで異なることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another consequence of long-term write access to in-out parameters is that passing a single variable as the argument for multiple in-out parameters of the same function produces a conflict.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>in-outパラメータに対する長期書き込みアクセスの別の帰着は、同じ関数の複数in-outパラメータのための引数として単一の変数を渡すことが衝突を生み出すことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another problem with this approach is that the shape transformations don’t nest.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この取り組みの別の問題は、形状変換が入れ子にされないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another way to handle errors is to use &lt;c0&gt;&lt;s1&gt;try?&lt;/s1&gt;&lt;/c0&gt; to convert the result to an optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーを取り扱う別の方法は、&lt;c0&gt;&lt;s1&gt;try?&lt;/s1&gt;&lt;/c0&gt;を使って結果をオプショナルに変換することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another way to handle optional values is to provide a default value using the &lt;c0&gt;&lt;s1&gt;??&lt;/s1&gt;&lt;/c0&gt; operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルの値を取り扱うもう１つの方法は、省略時の値を&lt;c0&gt;&lt;s1&gt;??&lt;/s1&gt;&lt;/c0&gt;演算子を使って提供することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any &lt;c0&gt;&lt;s1&gt;Dice&lt;/s1&gt;&lt;/c0&gt; instance can now be treated as &lt;c2&gt;&lt;s3&gt;TextRepresentable&lt;/s3&gt;&lt;/c2&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どんな&lt;c0&gt;&lt;s1&gt;Dice&lt;/s1&gt;&lt;/c0&gt;インスタンスでも、今や&lt;c2&gt;&lt;s3&gt;TextRepresentable&lt;/s3&gt;&lt;/c2&gt;として扱われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any Unicode scalar value except  &lt;c3&gt;"&lt;/c3&gt;,  &lt;c4&gt;\&lt;/c4&gt;, U+000A, or U+000D</seg>
      </tuv>
      <tuv lang="JA">
        <seg>何らかのユニコードスカラー値、しかし&lt;c3&gt;"&lt;/c3&gt;, &lt;c4&gt;\&lt;/c4&gt;、U+000A、またはU+000Dを除く</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any Unicode scalar value except  &lt;c3&gt;/*&lt;/c3&gt; or  &lt;c4&gt;*/&lt;/c4&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>任意のユニコードスカラー値、 しかし&lt;c3&gt;/*&lt;/c3&gt; または &lt;c4&gt;*/&lt;/c4&gt; を除く</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any Unicode scalar value except  &lt;c3&gt;\&lt;/c3&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>任意のユニコードスカラー値、しかし&lt;c3&gt;\&lt;/c3&gt;を除く</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any Unicode scalar value except U+000A or U+000D</seg>
      </tuv>
      <tuv lang="JA">
        <seg>任意のユニコードスカラー値、 しかし U+000A または U+000D を除く</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any additional setup work that uses methods, getters, or setters can also be done at this point.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッド、ゲッター、またはセッターを使うどんな追加の準備作業も、また、この時点で行われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any attempt to override a final method, property, or subscript in a subclass is reported as a compile-time error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるサブクラスの中の最終的なメソッド、プロパティ、または添え字をオーバーライドするどんな試みも、コンパイル時エラーとして報告されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any attempt to set a property through optional chaining returns a value of type &lt;c10&gt;&lt;s11&gt;Void?&lt;/s11&gt;&lt;/c10&gt;, which enables you to compare against &lt;c12&gt;&lt;s13&gt;nil&lt;/s13&gt;&lt;/c12&gt; to see if the property was set successfully:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖を通してプロパティを設定しようとするあらゆる試みは、型&lt;c10&gt;&lt;s11&gt;Void?&lt;/s11&gt;&lt;/c10&gt;の値を返します、それは、あなたに&lt;c12&gt;&lt;s13&gt;nil&lt;/s13&gt;&lt;/c12&gt;と比較することでそのプロパティがうまく設定されたかどうか調べることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any attempt to subclass a final class is reported as a compile-time error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最終版クラスにサブクラスを作る試みは何であれ、コンパイル時エラーを報告します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any bits that are moved beyond the bounds of the integer’s storage are discarded.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数の格納量の境界を越えて動かされるあらゆるビットは、捨てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any class that does not inherit from another class is known as a &lt;e0&gt;base class&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>別のクラスから継承しない何らかのクラスは、&lt;e0&gt;基盤クラス&lt;/e0&gt;として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any constants or variables assigned a value from an optional binding declaration in a &lt;c0&gt;&lt;s1&gt;guard&lt;/s1&gt;&lt;/c0&gt; statement condition can be used for the rest of the guard statement’s enclosing scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;guard&lt;/s1&gt;&lt;/c0&gt;文条件の中のオプショナル束縛宣言由来のあらゆる定数または変数は、guard文の囲むスコープの他の部分で使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any errors thrown inside a nonthrowing function must be handled inside the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スローしない関数の内部でスローされるどんなエラーも、その関数の内部で取り扱われなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any function that you write as just one &lt;c6&gt;&lt;s7&gt;return&lt;/s7&gt;&lt;/c6&gt; line can omit the &lt;c8&gt;&lt;s9&gt;return&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがただ１つだけの&lt;c6&gt;&lt;s7&gt;return&lt;/s7&gt;&lt;/c6&gt;行として書くあらゆる関数は、&lt;c8&gt;&lt;s9&gt;return&lt;/s9&gt;&lt;/c8&gt;を省略できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any gaps in an array are closed when an item is removed, and so the value at index &lt;c0&gt;&lt;s1&gt;0&lt;/s1&gt;&lt;/c0&gt; is once again equal to &lt;c2&gt;&lt;s3&gt;"Six&lt;/s3&gt; &lt;s4&gt;eggs"&lt;/s4&gt;&lt;/c2&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>項目が取り外されるとき、配列でのどんな隙間でも閉じられます、なのでインデックス&lt;c0&gt;&lt;s1&gt;0&lt;/s1&gt;&lt;/c0&gt;での値はふたたび&lt;c2&gt;&lt;s3&gt;"Six&lt;/s3&gt; &lt;s4&gt;eggs"&lt;/s4&gt;&lt;/c2&gt;と等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any identifier, keyword, literal, or operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>任意の識別子、キーワード、リテラル、または演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any initializer in the diagram above can be used to create a fully initialized instance of the class they belong to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の図の中のどんなイニシャライザでも、それらが属しているクラスの充分に初期化されたインスタンスをつくるために使用されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any internal implementation details of your framework can still use the default access level of internal, or can be marked as private or file private if you want to hide them from other parts of the framework’s internal code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのフレームワークのあらゆる内部的実装詳細は、依然として省略時のアクセス水準である内部を使用します、もしくはあなたがそれらをそのフレームワークの内部コードの他の部分から隠したいならば非公開またはファイル限定として印されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any protocol that inherits from a protocol that’s marked with the &lt;c0&gt;&lt;s1&gt;AnyObject&lt;/s1&gt;&lt;/c0&gt; requirement can likewise be adopted only by class types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;AnyObject&lt;/s1&gt;&lt;/c0&gt;要件で印されるプロトコルから継承するどんなプロトコルも、同じようにクラス型でのみ採用されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any punctuation except  &lt;c3&gt;(&lt;/c3&gt;,  &lt;c4&gt;)&lt;/c4&gt;,  &lt;c5&gt;[&lt;/c5&gt;,  &lt;c6&gt;]&lt;/c6&gt;,  &lt;c7&gt;{&lt;/c7&gt;, or  &lt;c8&gt;}&lt;/c8&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>任意の句読点、しかし&lt;c3&gt;(&lt;/c3&gt;,  &lt;c4&gt;)&lt;/c4&gt;,  &lt;c5&gt;[&lt;/c5&gt;,  &lt;c6&gt;]&lt;/c6&gt;,  &lt;c7&gt;{&lt;/c7&gt;, または  &lt;c8&gt;}&lt;/c8&gt;を除く</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any side effects of a key path expression are evaluated only at the point where the expression is evaluated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キーパス式のあらゆる副作用は、式が評価されるところの時点でのみ評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any type aliases you define are treated as distinct types for the purposes of access control.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが定義するどんな型エイリアスでも、アクセス制御の目的のためにはっきりした型とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any type argument substituted for a type parameter must meet all the constraints and requirements placed on the type parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型パラメータと置き換えられるどんな型引数でも、型パラメータに設置された制約と要件の全てに応じなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any type can be explicitly declared to be (or implicitly converted to) an optional type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あらゆる型は、オプショナル型であるとして明示的に宣言される（または暗黙的に変換される）ことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any type members added in an extension have the same default access level as type members declared in the original type being extended.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張において加えられるどんな型メンバーでも、拡張されているところの本来の型で宣言される型メンバーと同じ省略時のアクセス水準を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any type that conforms to the &lt;c0&gt;&lt;s1&gt;Container&lt;/s1&gt;&lt;/c0&gt; protocol must be able to specify the type of values it stores.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Container&lt;/s1&gt;&lt;/c0&gt;プロトコルに準拠するあらゆる型は、それが格納する値の型を指定することができなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any type that is &lt;c0&gt;&lt;s1&gt;Equatable&lt;/s1&gt;&lt;/c0&gt; can be used safely with the &lt;c2&gt;&lt;s3&gt;findIndex(of:in:)&lt;/s3&gt;&lt;/c2&gt; function, because it’s guaranteed to support the equal to operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Equatable&lt;/s1&gt;&lt;/c0&gt;であるどんな型でも&lt;c2&gt;&lt;s3&gt;findIndex(of:in:)&lt;/s3&gt;&lt;/c2&gt;関数で問題なく使われることができます、なぜなら、それが同等演算子をサポートすると保証されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any type that satisfies the requirements of a protocol is said to &lt;e2&gt;conform&lt;/e2&gt; to that protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロトコルの要件を満たす何らかの型は、そのプロトコルに&lt;e2&gt;準拠する&lt;/e2&gt;と言われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any variables or constants that were assigned values using an optional binding as part of the condition are available for the rest of the code block that the &lt;c4&gt;&lt;s5&gt;guard&lt;/s5&gt;&lt;/c4&gt; statement appears in.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル束縛を使ってこの条件の一部として値を代入された、あらゆる変数や定数は、&lt;c4&gt;&lt;s5&gt;guard&lt;/s5&gt;&lt;/c4&gt;文が現れるコードブロックの残りの部分で利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any whitespace between the backslash and the line break is also omitted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>バックスラッシュとラインブレークの間のあらゆる空白もまた省かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Anything that adopts &lt;c4&gt;&lt;s5&gt;PrettyTextRepresentable&lt;/s5&gt;&lt;/c4&gt; must satisfy all of the requirements enforced by &lt;c6&gt;&lt;s7&gt;TextRepresentable&lt;/s7&gt;&lt;/c6&gt;, &lt;e8&gt;plus&lt;/e8&gt; the additional requirements enforced by &lt;c9&gt;&lt;s10&gt;PrettyTextRepresentable&lt;/s10&gt;&lt;/c9&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;PrettyTextRepresentable&lt;/s5&gt;&lt;/c4&gt;を採用するどんなものでも、&lt;c6&gt;&lt;s7&gt;TextRepresentable&lt;/s7&gt;&lt;/c6&gt;によって強制される要件の全て、それに&lt;e8&gt;加えて&lt;/e8&gt;&lt;c9&gt;&lt;s10&gt;PrettyTextRepresentable&lt;/s10&gt;&lt;/c9&gt;によって強制される追加の要件を満たさなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Anything that is &lt;c6&gt;&lt;s7&gt;PrettyTextRepresentable&lt;/s7&gt;&lt;/c6&gt; must also be &lt;c8&gt;&lt;s9&gt;TextRepresentable&lt;/s9&gt;&lt;/c8&gt;, and so the implementation of &lt;c10&gt;&lt;s11&gt;prettyTextualDescription&lt;/s11&gt;&lt;/c10&gt; starts by accessing the &lt;c12&gt;&lt;s13&gt;textualDescription&lt;/s13&gt;&lt;/c12&gt; property from the &lt;c14&gt;&lt;s15&gt;TextRepresentable&lt;/s15&gt;&lt;/c14&gt; protocol to begin an output string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;PrettyTextRepresentable&lt;/s7&gt;&lt;/c6&gt;であるものは何でも、また&lt;c8&gt;&lt;s9&gt;TextRepresentable&lt;/s9&gt;&lt;/c8&gt;でなければなりません、なので&lt;c10&gt;&lt;s11&gt;prettyTextualDescription&lt;/s11&gt;&lt;/c10&gt;の実装は出力文字列を開始するために&lt;c14&gt;&lt;s15&gt;TextRepresentable&lt;/s15&gt;&lt;/c14&gt;プロトコルからの&lt;c12&gt;&lt;s13&gt;textualDescription&lt;/s13&gt;&lt;/c12&gt;プロパティにアクセスすることによって始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply that new attribute to a property of a class, structure, or enumeration to wrap access to the property through an instance of the wrapper type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その新しい属性をクラス、構造体、または列挙のあるプロパティに適用することで、ラッパー型のインスタンスによって、そのプロパティに対するアクセスをラップしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to a class declaration to require all stored properties within the class to provide default values as part of their definitions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性をあるクラス宣言に適用することで、そのクラス内の全ての格納プロパティに、省略時の値をそれら宣言の一部として提供することを要求してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to a class declaration, to implicitly apply the &lt;c0&gt;&lt;s1&gt;objc&lt;/s1&gt;&lt;/c0&gt; attribute to all Objective-C compatible members of the class, its extensions, its subclasses, and all of the extensions of its subclasses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性をあるクラス宣言に適用してください、暗黙的に&lt;c0&gt;&lt;s1&gt;objc&lt;/s1&gt;&lt;/c0&gt;属性をそのクラスの全てのObjective-C互換メンバー、それの拡張、それのサブクラス、そしてそれのサブクラスの全ての拡張に適用するには。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to a class to indicate that it’s the application delegate.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性をあるクラスに適用することで、それがアプリケーション委任先であることを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to a class, structure, enumeration, or protocol to enable members to be looked up by name at runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性をクラス、構造体、列挙、またはプロトコルに適用して、メンバが実行時に名前で検索されることを可能にしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to a class, structure, enumeration, or protocol to treat instances of the type as callable functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性をクラス、構造体、列挙、またはプロトコルに適用することで、その型のインスタンスをcallable関数として扱ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to a class, structure, or enumeration declaration to use that type as a property wrapper.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性をクラス、構造体、または列挙の宣言に適用して、その型をプロパティラッパーとして使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to a function or method declaration to suppress the compiler warning when the function or method that returns a value is called without using its result.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性を関数またはメソッド宣言に適用して、値を返す関数やメソッドがそれの結果を使うことなく呼び出された時にコンパイラが警告を発するのを抑制してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to a function, method, computed property, subscript, convenience initializer, or deinitializer declaration to expose that declaration’s implementation as part of the module’s public interface.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性を関数、メソッド、計算プロパティ、添え字、便宜イニシャライザ、またはデイニシャライザ宣言に適用することで、宣言の実装をモジュールの公開インターフェイスの一部として露出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to a function, method, computed property, subscript, initializer, or deinitializer declaration to allow that symbol to be used in inlinable code that’s defined in the same module as the declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性を関数、メソッド、計算プロパティ、添え字、便宜イニシャライザ、またはデイニシャライザ宣言に適用することで、そのシンボルが、同じモジュールの中で宣言として定義されるインライン可能コードにおいて使用できるようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to a method, property, subscript, or initializer declaration to suppress an implicit &lt;c0&gt;&lt;s1&gt;objc&lt;/s1&gt;&lt;/c0&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性をメソッド、プロパティ、添え字、およびイニシャライザ宣言に適用することで、暗黙的に&lt;c0&gt;&lt;s1&gt;objc&lt;/s1&gt;&lt;/c0&gt;属性となるのを抑制してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to a parameter’s type in a method or function declaration to indicate that the parameter’s value can be stored for later execution.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性をメソッドや関数宣言の中のパラメータの型に適用して、そのパラメータの値がその後の実行のために保管されることができるのを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to a stored variable property of a class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性をクラスの格納変数プロパティに適用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to a structure or enumeration declaration to restrict the kinds of changes you can make to the type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性を構造体または列挙宣言に適用して、あなたがその型にすることが出来る変更の種類を制約してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to a switch case to indicate that it isn’t expected to be matched by any case of the enumeration that’s known at the time the code is compiled.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性をスイッチケース節に適用して、コードがコンパイルされる時点で既知である列挙のどんなケース節によってもそれが合致されることは期待されないことを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to a top-level function, instance method, or class or static method to trigger warnings when that function or method is used without a preceding qualifier, such as a module name, type name, or instance variable or constant.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性をトップレベルの関数、インスタンスメソッド、もしくはクラスまたは静的メソッドに適用することで、その関数またはメソッドが、例えばモジュール名、型名、またはインスタンス変数や定数など、先行する修飾語無しで使われる場合に警告を引き起こしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to an &lt;c0&gt;&lt;s1&gt;import&lt;/s1&gt;&lt;/c0&gt; declaration to import that module with changes to its access control that simplify testing the module’s code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性をある&lt;c0&gt;&lt;s1&gt;import&lt;/s1&gt;&lt;/c0&gt;宣言に適用することで、そのモジュールのインポートをそれのアクセス制御への、モジュールの持つコードを試験するのを簡単にする変更とともに行ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to an instance method or stored variable property of a class that inherits from &lt;c0&gt;&lt;s1&gt;NSManagedObject&lt;/s1&gt;&lt;/c0&gt; to indicate that Core Data dynamically provides its implementation at runtime, based on the associated entity description.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性を&lt;c0&gt;&lt;s1&gt;NSManagedObject&lt;/s1&gt;&lt;/c0&gt;から継承するクラスのインスタンスメソッドまたは格納変数プロパティに適用することで、関連する実体記述に基づいて、Coreデータが動的にそれの実装に実行時に提供されることを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to any declaration that can be represented in Objective-C—for example, nonnested classes, protocols, nongeneric enumerations (constrained to integer raw-value types), properties and methods (including getters and setters) of classes, protocols and optional members of a protocol, initializers, and subscripts.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性をObjective-Cにおいて表わされることができる何らかの宣言に適用してください ― 例えば、入れ子にされないクラス、プロトコル、総称体でない列挙（整数の生の値型に制限される）、クラスのプロパティとメソッド（ゲッターやセッターを含む）、プロトコルおよびあるプロトコルのオプショナルメンバ、イニシャライザ、そして添え字など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to delay the evaluation of an expression by automatically wrapping that expression in a closure with no arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性を適用することで、ある式の評価の延期を、自動的にその式を引数なしクロージャの中にラップすることによって行ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to expose a custom GameplayKit component property to the SpriteKit editor UI.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性を適用することであつらえのGameplayKitコンポーネントプロパティをSpriteKitエディタUIに露出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to indicate a declaration’s life cycle relative to certain Swift language versions or certain platforms and operating system versions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性を適用することで、ある宣言の寿命を、特定のスウィフト言語バージョンまたは特定のプラットホームおよびオペレーティングシステムバージョンに相関的に指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this attribute to the type of a function to indicate its calling conventions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性を関数の型に適用して、それの呼出規約を示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this modifier to a class or to a property, method, or subscript member of a class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この修飾子をクラスに、またはプロパティ、メソッド、またはクラスの添え字メンバーに適用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this modifier to a declaration to indicate the declaration can be accessed and subclassed by code in the same module as the declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この修飾子を宣言に適用して、その宣言がアクセスされることおよびサブクラスを作られることが、宣言と同じモジュールの中のコードによって可能なのを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this modifier to a declaration to indicate the declaration can be accessed only by code in the same module as the declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この修飾子を宣言に適用して、その宣言が、宣言と同じモジュールの中のコードによってのみアクセスされることができるのを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this modifier to a declaration to indicate the declaration can be accessed only by code in the same source file as the declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この修飾子を宣言に適用して、その宣言が、宣言と同じソースファイルの中のコードによってのみアクセスされることができるのを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this modifier to a declaration to indicate the declaration can be accessed only by code within the declaration’s immediate enclosing scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この修飾子を宣言に適用して、その宣言がアクセスされることは、宣言が直に囲んでいるスコープ内のコードによってのみ可能なのを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this modifier to a designated or convenience initializer of a class to indicate that every subclass must implement that initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この修飾子をクラスの必須または便宜イニシャライザに適用して、全てのサブクラスがそのイニシャライザを実装しなければならないことを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this modifier to a member of a class to indicate that the member is a member of the class itself, rather than a member of instances of the class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この修飾子をクラスのメンバーに適用して、そのメンバーがそのクラスそれ自身のメンバーであることを指し示してください、そのクラスのインスタンスのメンバーではなくて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this modifier to a member of a structure, class, enumeration, or protocol to indicate that the member is a member of the type, rather than a member of instances of that type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この修飾子を構造体、クラス、列挙、またはプロトコルのメンバーに適用して、そのメンバーがその型のメンバーであることを指し示してください、その型のインスタンスのメンバーではなくて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this modifier to a protocol’s property, method, or subscript members to indicate that a conforming type isn’t required to implement those members.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この修飾子をプロトコルのプロパティ、メソッド、または添え字メンバーに適用して、ある準拠型がそれらのメンバーを実装する必要がないことを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this modifier to a stored variable or stored variable property to indicate that the variable or property has a weak reference to the object stored as its value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この修飾子を格納変数または格納変数プロパティに適用して、その変数またはプロパティがそれの値として格納されるオブジェクトに対して弱い参照を持つことを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this modifier to a stored variable property of a class or structure to indicate that the property’s initial value is calculated and stored at most once, when the property is first accessed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この修飾子をクラスまたは構造体の格納変数プロパティに適用して、そのプロパティの初期値が最大でも一度だけ、そのプロパティが最初にアクセスされるときに、計算または格納されることを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this modifier to a stored variable, constant, or stored property to indicate that the variable or property has an unowned reference to the object stored as its value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この修飾子を格納変数、定数、または格納プロパティに適用して、その変数またはプロパティがそれの値として格納されるオブジェクトに対して非所有参照を持つことを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Apply this modifier to any member of a class that can be represented by Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この修飾子をObjective-Cによって表わされることのできるクラスのあらゆるメンバーに適用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applying the &lt;c0&gt;&lt;s1&gt;IBAction&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;IBSegueAction&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;IBOutlet&lt;/s5&gt;&lt;/c4&gt;, &lt;c6&gt;&lt;s7&gt;IBDesignable&lt;/s7&gt;&lt;/c6&gt;, or &lt;c8&gt;&lt;s9&gt;IBInspectable&lt;/s9&gt;&lt;/c8&gt; attribute also implies the &lt;c10&gt;&lt;s11&gt;objc&lt;/s11&gt;&lt;/c10&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;IBAction&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;IBSegueAction&lt;/s3&gt;&lt;/c2&gt;、&lt;c4&gt;&lt;s5&gt;IBOutlet&lt;/s5&gt;&lt;/c4&gt;、&lt;c6&gt;&lt;s7&gt;IBDesignable&lt;/s7&gt;&lt;/c6&gt;、または&lt;c8&gt;&lt;s9&gt;IBInspectable&lt;/s9&gt;&lt;/c8&gt;属性を適用することはまた、暗黙的に&lt;c10&gt;&lt;s11&gt;objc&lt;/s11&gt;&lt;/c10&gt;属性を伴います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applying the &lt;c6&gt;&lt;s7&gt;objc&lt;/s7&gt;&lt;/c6&gt; attribute when it isn’t needed can increase your binary size and adversely affect performance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが必要とされない時に&lt;c6&gt;&lt;s7&gt;objc&lt;/s7&gt;&lt;/c6&gt;属性を適用することは、あなたのバイナリサイズを増加させ性能に逆効果です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applying this attribute also implies the &lt;c0&gt;&lt;s1&gt;objc&lt;/s1&gt;&lt;/c0&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性を適用することはまた、&lt;c0&gt;&lt;s1&gt;objc&lt;/s1&gt;&lt;/c0&gt;属性も暗に意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applying this attribute also implies the &lt;c4&gt;&lt;s5&gt;objc&lt;/s5&gt;&lt;/c4&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性を適用することはさらにまた&lt;c4&gt;&lt;s5&gt;objc&lt;/s5&gt;&lt;/c4&gt;属性も意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applying this attribute to an extension has the same effect as applying it to every member of that extension that isn’t explicitly marked with the &lt;c0&gt;&lt;s1&gt;nonobjc&lt;/s1&gt;&lt;/c0&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性をある拡張に適用することは、その拡張のあらゆるメンバで明示的に&lt;c0&gt;&lt;s1&gt;nonobjc&lt;/s1&gt;&lt;/c0&gt;属性で印されていないものにそれを適用することと同じ効果を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applying this attribute to an extension has the same effect as applying it to every member of that extension that isn’t explicitly marked with the &lt;c0&gt;&lt;s1&gt;objc&lt;/s1&gt;&lt;/c0&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性をある拡張に適用することは、明示的に&lt;c0&gt;&lt;s1&gt;objc&lt;/s1&gt;&lt;/c0&gt;属性で印されていないその拡張のあらゆるメンバにそれを適用することと同じ効果を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Argument labels must always be used in an initializer if they are defined, and omitting them is a compile-time error:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>引数ラベルは、それらが定義されるならば常にイニシャライザで使われなければなりません、そして、それらを省略することはコンパイル時エラーになります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Argument names in functions and methods are not part of the corresponding function type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数やメソッドの引数名は、対応する関数型の一部ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arithmetic Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>算術演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arithmetic operators (&lt;c4&gt;&lt;s5&gt;+&lt;/s5&gt;&lt;/c4&gt;, &lt;c6&gt;&lt;s7&gt;-&lt;/s7&gt;&lt;/c6&gt;, &lt;c8&gt;&lt;s9&gt;*&lt;/s9&gt;&lt;/c8&gt;, &lt;c10&gt;&lt;s11&gt;/&lt;/s11&gt;&lt;/c10&gt;, &lt;c12&gt;&lt;s13&gt;%&lt;/s13&gt;&lt;/c12&gt; and so forth) detect and disallow value overflow, to avoid unexpected results when working with numbers that become larger or smaller than the allowed value range of the type that stores them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>算術演算子（&lt;c4&gt;&lt;s5&gt;+&lt;/s5&gt;&lt;/c4&gt;、&lt;c6&gt;&lt;s7&gt;-&lt;/s7&gt;&lt;/c6&gt;、&lt;c8&gt;&lt;s9&gt;*&lt;/s9&gt;&lt;/c8&gt;、&lt;c10&gt;&lt;s11&gt;/&lt;/s11&gt;&lt;/c10&gt;、&lt;c12&gt;&lt;s13&gt;%&lt;/s13&gt;&lt;/c12&gt;その他）は、値があふれること（オーバフロー）を検知して承認しません、数を扱うときにそれらを格納する型の許容される値の範囲より大きいか小さくなる予想外の結果を防ぐためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Array Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Array Type Shorthand Syntax</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列型の短縮形構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Array indices are checked for out-of-bounds errors.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列インデックスは、境界外エラーを確認される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arrays</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arrays are ordered collections of values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列は、順番をつけられた値のコレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arrays automatically grow as you add elements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列は、あなたが要素を追加するとき自動的に増大します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arrays in Swift are always zero-indexed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの配列は、常に０からのインデックスをつけられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arrays, sets, and dictionaries in Swift are always clear about the types of values and keys that they can store.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの配列、集合、そして辞書は、それらが格納できる値とキーの型について常に明確です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Array’s existing &lt;c0&gt;&lt;s1&gt;append(_:)&lt;/s1&gt;&lt;/c0&gt; method and subscript enable Swift to infer the appropriate type to use for &lt;c2&gt;&lt;s3&gt;Item&lt;/s3&gt;&lt;/c2&gt;, just as for the generic &lt;c4&gt;&lt;s5&gt;Stack&lt;/s5&gt;&lt;/c4&gt; type above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列の既存の&lt;c0&gt;&lt;s1&gt;append(_:)&lt;/s1&gt;&lt;/c0&gt;メソッドと添え字は、スウィフトに、ちょうど上の総称体&lt;c4&gt;&lt;s5&gt;Stack&lt;/s5&gt;&lt;/c4&gt;型と同じように、&lt;c2&gt;&lt;s3&gt;Item&lt;/s3&gt;&lt;/c2&gt;に使うのに適当な型を推論するのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a general guideline, prefer structures because they’re easier to reason about, and use classes when they’re appropriate or necessary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一般的な指針として、構造体を選んでください、なぜならそれらは推論するのがより簡単だからです、そしてそれが適切または必要である場合はクラスを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a parameter type or return type in a function, method, or initializer</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数、メソッド、またはイニシャライザにおいてパラメータ型または戻り型として</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, ARC never sets an unowned reference’s value to &lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;, which means that unowned references are defined using non-optional types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果として、ARCは決して非所有参照のもつ値を&lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;に設定しません、それは非所有参照が非オプショナル型を使って定義されることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, a failable initializer can return &lt;c1&gt;&lt;s2&gt;nil&lt;/s2&gt;&lt;/c1&gt; to indicate that initialization failed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果として、失敗できるイニシャライザは、そのイニシャライザが失敗したのを指し示すために&lt;c1&gt;&lt;s2&gt;nil&lt;/s2&gt;&lt;/c1&gt;を返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, code is not just easier to write, but easier to read and maintain as well.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果として、コードは書くのがより簡単なだけでなく、読むことおよび管理するのもまたより簡単です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, if multiple cases contain patterns that evaluate to the same value, and thus can match the value of the control expression, the program executes only the code within the first matching case in source order.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その結果、複数のケース節が同じ値に評価される、そしてそれゆえ制御式の値にマッチすることができるパターンを含むならば、プログラムはソース順において最初のマッチしているケース節内のコードだけを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, in many cases you don’t need to specify an explicit access level in your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その結果、多くの場合には、あなたはあなたのコードにおいて明示的にアクセス水準を指定する必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, it automatically receives a default initializer, as described in &lt;a2&gt;&lt;s3&gt;Default Initializers&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果として、&lt;a2&gt;&lt;s3&gt;省略時のイニシャライザ&lt;/s3&gt;&lt;/a2&gt;で記述されるように、それは自動的に省略時のイニシャライザを受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, only class types can adopt and conform to a protocol that contains optional member requirements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果として、クラス型だけがオプショナルメンバー要件を含むプロトコルを採用および準拠することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, the &lt;c10&gt;&lt;s11&gt;endIndex&lt;/s11&gt;&lt;/c10&gt; property isn’t a valid argument to a string’s subscript.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果として、&lt;c10&gt;&lt;s11&gt;endIndex&lt;/s11&gt;&lt;/c10&gt;プロパティは、文字列の添え字として有効な引数ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, the &lt;e3&gt;statements&lt;/e3&gt; are compiled and executed only if the &lt;e4&gt;compilation condition&lt;/e4&gt; evaluates to &lt;c5&gt;&lt;s6&gt;true&lt;/s6&gt;&lt;/c5&gt; at compile time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果として、&lt;e3&gt;statements（文）&lt;/e3&gt;がコンパイル及び実行されるのは&lt;e4&gt;compilation condition&lt;/e4&gt;がコンパイル時に&lt;c5&gt;&lt;s6&gt;true&lt;/s6&gt;&lt;/c5&gt;に評価される場合に限ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, the number of characters in a string can’t be calculated without iterating through the string to determine its extended grapheme cluster boundaries.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その結果、ある文字列の中の文字の数は、それの拡張書記素クラスタ境界を解決するためにその文字列の最初から終わりまで繰り返していくことなしに計算されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, the value of the &lt;c6&gt;&lt;s7&gt;customerProvider&lt;/s7&gt;&lt;/c6&gt; argument must be allowed to escape the function’s scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その結果、&lt;c6&gt;&lt;s7&gt;customerProvider&lt;/s7&gt;&lt;/c6&gt;引数の値は関数のスコープを脱出することを許されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, there’s no need to use whitespace to disambiguate between the closing &lt;c4&gt;&lt;s5&gt;&gt;&lt;/s5&gt;&lt;/c4&gt; characters in constructs like &lt;c6&gt;&lt;s7&gt;Dictionary&lt;String,&lt;/s7&gt; &lt;s8&gt;Array&lt;Int&gt;&gt;&lt;/s8&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その結果、閉じ&lt;c4&gt;&lt;s5&gt;&gt;&lt;/s5&gt;&lt;/c4&gt;文字の間の曖昧さをなくすために空白を使う必要は、&lt;c6&gt;&lt;s7&gt;Dictionary&lt;String,&lt;/s7&gt; &lt;s8&gt;Array&lt;Int&gt;&gt;&lt;/s8&gt;&lt;/c6&gt;のような構造物においてはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, they are both evaluated before the addition is considered.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果として、それらは両方とも、加算が考慮される前に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, they have a &lt;c2&gt;&lt;s3&gt;rawValue&lt;/s3&gt;&lt;/c2&gt; property and a failable initializer with the signature &lt;c4&gt;&lt;s5&gt;init?(rawValue:&lt;/s5&gt; &lt;s6&gt;RawValue)&lt;/s6&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果として、それは&lt;c2&gt;&lt;s3&gt;rawValue&lt;/s3&gt;&lt;/c2&gt;プロパティとシグネチャ&lt;c4&gt;&lt;s5&gt;init?(rawValue:&lt;/s5&gt; &lt;s6&gt;RawValue)&lt;/s6&gt;&lt;/c4&gt;を持つ失敗できるイニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, whether a closure expression is escaping or nonescaping depends on the surrounding context of the expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果として、あるクロージャ式が脱出または非脱出であるかどうかは、その式を取り囲んでいる前後関係に依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, you can use a nonthrowing function in the same places as a throwing one.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果として、あなたは非スロー関数をスロー関数と同じ場所で使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, you can:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果として、あなたは次のことが出来ます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, you do not write the &lt;c3&gt;&lt;s4&gt;override&lt;/s4&gt;&lt;/c3&gt; modifier when providing a matching implementation of a superclass convenience initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果として、あなたはスーパークラスの便宜イニシャライザに一致する実装を提供している時に&lt;c3&gt;&lt;s4&gt;override&lt;/s4&gt;&lt;/c3&gt;修飾子を書きません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, you don’t implement the getter or setter directly in the protocol in which it is declared.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果として、それが宣言されるプロトコルにおいて、あなたは直接ゲッターまたはセッターを実装しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, you must include at least one statement following the colon (&lt;c4&gt;&lt;s5&gt;:&lt;/s5&gt;&lt;/c4&gt;) of each case label.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その結果、あなたはそれぞれのケース節ラベルのコロン（&lt;c4&gt;&lt;s5&gt;:&lt;/s5&gt;&lt;/c4&gt;）に続いている文を少なくとも１つは含めなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a result, you never need to write an inline closure in its fullest form when the closure is used as a function or method argument.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その結果、あなたは、行内クロージャをその最も完全な形式で書くことは、そのクロージャが関数やメソッドの引数として使われる時にまったく必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a shortcut to accessing its &lt;c0&gt;&lt;s1&gt;rooms&lt;/s1&gt;&lt;/c0&gt; array, this version of &lt;c2&gt;&lt;s3&gt;Residence&lt;/s3&gt;&lt;/c2&gt; provides a read-write subscript that provides access to the room at the requested index in the &lt;c4&gt;&lt;s5&gt;rooms&lt;/s5&gt;&lt;/c4&gt; array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その&lt;c0&gt;&lt;s1&gt;rooms&lt;/s1&gt;&lt;/c0&gt;配列にアクセスすることへの近道として、&lt;c2&gt;&lt;s3&gt;Residence&lt;/s3&gt;&lt;/c2&gt;のこの版は読み出し専用の添え字を提供します、それは、&lt;c4&gt;&lt;s5&gt;rooms&lt;/s5&gt;&lt;/c4&gt;配列の中の要求されたインデックスでの部屋へのアクセスを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an alternative to associated values, enumeration cases can come prepopulated with default values (called &lt;e2&gt;raw values&lt;/e2&gt;), which are all of the same type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連値に代わるものとして、列挙ケース節は全て同じ型の（&lt;e2&gt;生の値&lt;/e2&gt;と呼ばれる）初期値があらかじめ入れられた状態であることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an alternative to querying their &lt;c0&gt;&lt;s1&gt;value&lt;/s1&gt;&lt;/c0&gt; properties, each &lt;c2&gt;&lt;s3&gt;UnicodeScalar&lt;/s3&gt;&lt;/c2&gt; value can also be used to construct a new &lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt; value, such as with string interpolation:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの&lt;c0&gt;&lt;s1&gt;value&lt;/s1&gt;&lt;/c0&gt;プロパティについて尋ねることに代わるものとして、各&lt;c2&gt;&lt;s3&gt;UnicodeScalar&lt;/s3&gt;&lt;/c2&gt;値は、また、新しい&lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt;値を造るために使われることもできます、例えば文字列補間を使って：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an alternative to subscripting, use a dictionary’s &lt;c0&gt;&lt;s1&gt;updateValue(_:forKey:)&lt;/s1&gt;&lt;/c0&gt; method to set or update the value for a particular key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字指定に代わるものとして、辞書の&lt;c0&gt;&lt;s1&gt;updateValue(_:forKey:)&lt;/s1&gt;&lt;/c0&gt;メソッドを、特定のキーに対する値を設定したり更新したりするために使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an example, Swift’s &lt;c0&gt;&lt;s1&gt;Array&lt;/s1&gt;&lt;/c0&gt; type has a &lt;c2&gt;&lt;s3&gt;map(_:)&lt;/s3&gt;&lt;/c2&gt; method which takes a closure expression as its single argument.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例として、スウィフトの&lt;c0&gt;&lt;s1&gt;Array&lt;/s1&gt;&lt;/c0&gt;型は&lt;c2&gt;&lt;s3&gt;map(_:)&lt;/s3&gt;&lt;/c2&gt;メソッドを持ちます、そしてそれは、そのただ１つの引数としてクロージャ式をとります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an example, consider the task of reading and processing data from a file on disk.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとつの例として、ディスク上のファイルからデータを読み込んで処理する作業を考えてみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an example, many functions that start an asynchronous operation take a closure argument as a completion handler.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例として、非同期の演算を開始する多くの関数は、クロージャ引数を完了ハンドラとして取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an example, the &lt;c0&gt;&lt;s1&gt;+++&lt;/s1&gt;&lt;/c0&gt; operator in &lt;c2&gt;&lt;s3&gt;a+++&lt;/s3&gt; &lt;s4&gt;b&lt;/s4&gt;&lt;/c2&gt; is treated as a postfix unary operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例として、&lt;c2&gt;&lt;s3&gt;a+++&lt;/s3&gt; &lt;s4&gt;b&lt;/s4&gt;&lt;/c2&gt;における&lt;c0&gt;&lt;s1&gt;+++&lt;/s1&gt;&lt;/c0&gt;演算子は、接尾辞単項演算子とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an example, the &lt;c0&gt;&lt;s1&gt;+++&lt;/s1&gt;&lt;/c0&gt; operator in &lt;c2&gt;&lt;s3&gt;a+++b&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;a&lt;/s5&gt; &lt;s6&gt;+++&lt;/s6&gt; &lt;s7&gt;b&lt;/s7&gt;&lt;/c4&gt; is treated as a binary operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例として、&lt;c2&gt;&lt;s3&gt;a+++b&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;a&lt;/s5&gt; &lt;s6&gt;+++&lt;/s6&gt; &lt;s7&gt;b&lt;/s7&gt;&lt;/c4&gt;における&lt;c0&gt;&lt;s1&gt;+++&lt;/s1&gt;&lt;/c0&gt;演算子は、二項演算子とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an example, the &lt;c0&gt;&lt;s1&gt;+++&lt;/s1&gt;&lt;/c0&gt; operator in &lt;c2&gt;&lt;s3&gt;a&lt;/s3&gt; &lt;s4&gt;+++b&lt;/s4&gt;&lt;/c2&gt; is treated as a prefix unary operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例として、&lt;c2&gt;&lt;s3&gt;a&lt;/s3&gt; &lt;s4&gt;+++b&lt;/s4&gt;&lt;/c2&gt;における&lt;c0&gt;&lt;s1&gt;+++&lt;/s1&gt;&lt;/c0&gt;演算子は、接頭辞単項演算子とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an example, the &lt;c2&gt;&lt;s3&gt;+++&lt;/s3&gt;&lt;/c2&gt; operator in &lt;c4&gt;&lt;s5&gt;a+++.b&lt;/s5&gt;&lt;/c4&gt; is treated as a postfix unary operator (&lt;c6&gt;&lt;s7&gt;a+++&lt;/s7&gt; &lt;s8&gt;.b&lt;/s8&gt;&lt;/c6&gt; rather than &lt;c9&gt;&lt;s10&gt;a&lt;/s10&gt; &lt;s11&gt;+++&lt;/s11&gt; &lt;s12&gt;.b&lt;/s12&gt;&lt;/c9&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例として、&lt;c2&gt;&lt;s3&gt;+++&lt;/s3&gt;&lt;/c2&gt;演算子は&lt;c4&gt;&lt;s5&gt;a+++.b&lt;/s5&gt;&lt;/c4&gt;において、接尾辞単項演算子（&lt;c6&gt;&lt;s7&gt;a+++&lt;/s7&gt; &lt;s8&gt;.b&lt;/s8&gt;&lt;/c6&gt;、&lt;c9&gt;&lt;s10&gt;a&lt;/s10&gt; &lt;s11&gt;+++&lt;/s11&gt; &lt;s12&gt;.b&lt;/s12&gt;&lt;/c9&gt;ではなく）とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an example, the grammar of a getter-setter block is defined as follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例として、ゲッターセッター・ブロックの文法は、次のように定義されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an optimization, Swift may instead capture and store a &lt;e0&gt;copy&lt;/e0&gt; of a value if that value is not mutated by a closure, and if the value is not mutated after the closure is created.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとつの最適化として、その値がクロージャによって変化させられないならば、そしてその値がクロージャが作成された後に変化されられないならば、スウィフトはそれよりむしろ値の&lt;e0&gt;コピー&lt;/e0&gt;をキャプチャして保管するかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an optimization, when the argument is a value stored at a physical address in memory, the same memory location is used both inside and outside the function body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとつの最適化として、引数がメモリにおいて物理的番地に格納される値である時、同じメモリ位置は関数本体の内側と外側の両方で使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As can be seen above, the getter correctly returns a center point of &lt;c10&gt;&lt;s11&gt;(5,&lt;/s11&gt; &lt;s12&gt;5)&lt;/s12&gt;&lt;/c10&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上で見られるように、ゲッターは正しく中心点&lt;c10&gt;&lt;s11&gt;(5,&lt;/s11&gt; &lt;s12&gt;5)&lt;/s12&gt;&lt;/c10&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As demonstrated in &lt;a0&gt;&lt;s1&gt;Optional Chaining as an Alternative to Forced Unwrapping&lt;/s1&gt;&lt;/a0&gt;, you can use optional chaining to access a property on an optional value, and to check if that property access is successful.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;強制アンラップに代わるものとしてのオプショナル連鎖&lt;/s1&gt;&lt;/a0&gt;で例示されるように、あなたはオプショナル連鎖を使って、あるオプショナル上でプロパティにアクセスして、そのプロパティへのアクセスが成功したか調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As described above, optionals indicate that a constant or variable is allowed to have “no value”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>先に述べたように、オプショナルは、ある定数や変数が「値がない」状態でも許されることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As described above, the ultimate return type of this method call after optional chaining is also &lt;c6&gt;&lt;s7&gt;String?&lt;/s7&gt;&lt;/c6&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>先に述べたように、オプショナル連鎖の後ろのこのメソッド呼び出しの最終的な戻り型は、また、&lt;c6&gt;&lt;s7&gt;String?&lt;/s7&gt;&lt;/c6&gt;です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As described in &lt;a0&gt;&lt;s1&gt;Control Flow&lt;/s1&gt;&lt;/a0&gt;, a &lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt; statement must be exhaustive when considering an enumeration’s cases.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;制御の流れ&lt;/s1&gt;&lt;/a0&gt;で記述されるように、&lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt;文は列挙のケース節を考慮するとき、徹底的でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As described in &lt;a0&gt;&lt;s1&gt;Default Initializers&lt;/s1&gt;&lt;/a0&gt;, Swift automatically provides a &lt;e2&gt;default initializer&lt;/e2&gt; without any arguments for any structure or base class that provides default values for all of its properties and doesn’t provide at least one initializer itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;省略時のイニシャライザ&lt;/s1&gt;&lt;/a0&gt;で記述されるように、スウィフトは、全く引数を持たない&lt;e2&gt;省略時のイニシャライザ&lt;/e2&gt;を、あらゆる構造体または基盤クラスで、それのプロパティの全てに省略時の値を提供して、とにかく１つのイニシャライザもそれ自身では提供しないもののために、自動的に提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As described in &lt;a0&gt;&lt;s1&gt;Failable Initializers&lt;/s1&gt;&lt;/a0&gt;, a special form of the &lt;c2&gt;&lt;s3&gt;return&lt;/s3&gt;&lt;/c2&gt; statement (&lt;c4&gt;&lt;s5&gt;return&lt;/s5&gt; &lt;s6&gt;nil&lt;/s6&gt;&lt;/c4&gt;) can be used in a failable initializer to indicate initialization failure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;失敗できるイニシャライザ&lt;/s1&gt;&lt;/a0&gt;で記述されるように、&lt;c2&gt;&lt;s3&gt;return&lt;/s3&gt;&lt;/c2&gt;文の特別な形式（&lt;c4&gt;&lt;s5&gt;return&lt;/s5&gt; &lt;s6&gt;nil&lt;/s6&gt;&lt;/c4&gt;）は、失敗できるイニシャライザの中で使用されて初期化失敗を指し示すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As described in &lt;a2&gt;&lt;s3&gt;Dictionaries&lt;/s3&gt;&lt;/a2&gt;, the type of a dictionary’s keys must be &lt;e4&gt;hashable&lt;/e4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a2&gt;&lt;s3&gt;辞書&lt;/s3&gt;&lt;/a2&gt;で記述されるように、辞書のキーの型は、&lt;e4&gt;ハッシュ化&lt;/e4&gt;できなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As discussed in &lt;a0&gt;&lt;s1&gt;Initializer Declaration&lt;/s1&gt;&lt;/a0&gt;, classes can have designated and convenience initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;イニシャライザ宣言&lt;/s1&gt;&lt;/a0&gt;で議論されるように、クラスは、指定および便宜イニシャライザを持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As expected, the counter’s &lt;c6&gt;&lt;s7&gt;count&lt;/s7&gt;&lt;/c6&gt; property increases by three each time &lt;c8&gt;&lt;s9&gt;increment()&lt;/s9&gt;&lt;/c8&gt; is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>予想されるように、counterの&lt;c6&gt;&lt;s7&gt;count&lt;/s7&gt;&lt;/c6&gt;プロパティは、&lt;c8&gt;&lt;s9&gt;increment()&lt;/s9&gt;&lt;/c8&gt;が呼ばれるたびに３つずつ増加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As in the previous example, the final case matches all possible remaining values, and so a &lt;c0&gt;&lt;s1&gt;default&lt;/s1&gt;&lt;/c0&gt; case is not needed to make the &lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt; statement exhaustive.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>前の例の場合のように、最後のケース節は全てのあり得る残りの値に適合します、そして&lt;c0&gt;&lt;s1&gt;default&lt;/s1&gt;&lt;/c0&gt;ケース節はこの&lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt;文を網羅的なものにするのに必要ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As in this example, careful choice of Boolean constant and variable names can help to keep code readable and concise, while avoiding double negatives or confusing logic statements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例の場合のように、ブールの定数と変数の名前の慎重な選択はコードを読みやすく簡潔にしておくのを助けることができます、その一方で、二重の否定や、混乱させる論理文を避けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As its name suggests, the &lt;c4&gt;&lt;s5&gt;toggle()&lt;/s5&gt;&lt;/c4&gt; method is intended to toggle or invert the state of any conforming type, typically by modifying a property of that type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その名前が暗示するように、&lt;c4&gt;&lt;s5&gt;toggle()&lt;/s5&gt;&lt;/c4&gt;メソッドはあらゆる準拠型の状態を切り換えるか逆にすることを意図します、概してその型のプロパティの修正によって。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As mentioned above, different characters can require different amounts of memory to store, so in order to determine which &lt;c0&gt;&lt;s1&gt;Character&lt;/s1&gt;&lt;/c0&gt; is at a particular position, you must iterate over each Unicode scalar from the start or end of that &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上で述べたように、異なる文字は格納するのに異なるメモリ量を必要とすることがあり得ます、それで&lt;c0&gt;&lt;s1&gt;Character&lt;/s1&gt;&lt;/c0&gt;がある特定の位置にあることを確定するために、あなたはその&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;の始まりまたは終わりからユニコードスカラーそれぞれにわたってずっと繰り返さなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As mentioned above, subclasses do not inherit their superclass initializers by default.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上で述べたように、サブクラスは何もしなければそれらのスーパークラスのイニシャライザを継承しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As mentioned above, substrings aren’t suitable for long-term storage—because they reuse the storage of the original string, the entire original string must be kept in memory as long as any of its substrings are being used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上で言及したように、下位文字列は長期保管に適していません — それらがオリジナルの文字列のストレージを再利用することから、オリジナルの文字列全体はそれの下位文字列が使われている限りメモリに保持されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As mentioned above, the &lt;c0&gt;&lt;s1&gt;Rank&lt;/s1&gt;&lt;/c0&gt; enumeration defines a further nested structure of its own, called &lt;c2&gt;&lt;s3&gt;Values&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上で言及されるように、&lt;c0&gt;&lt;s1&gt;Rank&lt;/s1&gt;&lt;/c0&gt;列挙は独自の更なる入れ子にされた構造体を定義します、それは&lt;c2&gt;&lt;s3&gt;Values&lt;/s3&gt;&lt;/c2&gt;と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As mentioned above, the memory for an object is only considered fully initialized once the initial state of all of its stored properties is known.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上で言及したように、いったんその格納プロパティの全ての最初の状態が知られる場合にのみ、あるオブジェクトに対するメモリが充分に初期化されたとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As mentioned in &lt;a0&gt;&lt;s1&gt;Generic Parameter Clause&lt;/s1&gt;&lt;/a0&gt;, you don’t use a generic argument clause to specify the type arguments of a generic function or initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;総称体パラメータ節&lt;/s1&gt;&lt;/a0&gt;で言及されるように、あなたは、総称体の関数やイニシャライザの型引数を指定するために総称体引数節を使いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As shown in the figure below, both &lt;c8&gt;&lt;s9&gt;number&lt;/s9&gt;&lt;/c8&gt; and &lt;c10&gt;&lt;s11&gt;stepSize&lt;/s11&gt;&lt;/c10&gt; refer to the same location in memory.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の図で示すように、&lt;c8&gt;&lt;s9&gt;number&lt;/s9&gt;&lt;/c8&gt;と&lt;c10&gt;&lt;s11&gt;stepSize&lt;/s11&gt;&lt;/c10&gt;の両方ともメモリ中の同じ位置を参照します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As shown in the figure below, they access different locations in memory.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の図で示すように、それらはメモリ中の異なる位置を参照します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As soon as all properties of the superclass have an initial value, its memory is considered fully initialized, and phase 1 is complete.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラスの全てのプロパティが初期値を持つとすぐに、そのメモリは完全に初期化されるとみなされます、そして第１段階は完了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As soon as the &lt;c8&gt;&lt;s9&gt;default&lt;/s9&gt;&lt;/c8&gt; case is matched, the &lt;c10&gt;&lt;s11&gt;break&lt;/s11&gt;&lt;/c10&gt; statement ends the &lt;c12&gt;&lt;s13&gt;switch&lt;/s13&gt;&lt;/c12&gt; statement’s execution, and code execution continues from the &lt;c14&gt;&lt;s15&gt;if&lt;/s15&gt; &lt;s16&gt;let&lt;/s16&gt;&lt;/c14&gt; statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c8&gt;&lt;s9&gt;default&lt;/s9&gt;&lt;/c8&gt;ケース節が適合したならすぐに、&lt;c10&gt;&lt;s11&gt;break&lt;/s11&gt;&lt;/c10&gt;文が&lt;c12&gt;&lt;s13&gt;switch&lt;/s13&gt;&lt;/c12&gt;文の実行を終えます、そしてコード実行は&lt;c14&gt;&lt;s15&gt;if&lt;/s15&gt; &lt;s16&gt;let&lt;/s16&gt;&lt;/c14&gt;文から続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As such, &lt;c2&gt;&lt;s3&gt;index&lt;/s3&gt;&lt;/c2&gt; does not have to be declared before it is used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このように、&lt;c2&gt;&lt;s3&gt;index&lt;/s3&gt;&lt;/c2&gt;は、それが使われる前に宣言される必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As such, the performance characteristics of a &lt;c6&gt;&lt;s7&gt;throw&lt;/s7&gt;&lt;/c6&gt; statement are comparable to those of a &lt;c8&gt;&lt;s9&gt;return&lt;/s9&gt;&lt;/c8&gt; statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;throw&lt;/s7&gt;&lt;/c6&gt;文のいろいろな性能特徴は、それ自体としては、&lt;c8&gt;&lt;s9&gt;return&lt;/s9&gt;&lt;/c8&gt;文のそれと同程度です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As the above example shows, patterns in a case can also bind constants using the &lt;c0&gt;&lt;s1&gt;let&lt;/s1&gt;&lt;/c0&gt; keyword (they can also bind variables using the &lt;c2&gt;&lt;s3&gt;var&lt;/s3&gt;&lt;/c2&gt; keyword).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で示されるように、あるケース節中のいくつかのパターンはまた、&lt;c0&gt;&lt;s1&gt;let&lt;/s1&gt;&lt;/c0&gt;キーワードを使って定数に束縛できます（それらはまた&lt;c2&gt;&lt;s3&gt;var&lt;/s3&gt;&lt;/c2&gt;キーワードを使って変数に束縛もできます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As the return type of a method</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッドの戻り型として</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As the return type of a read-only subscript</seg>
      </tuv>
      <tuv lang="JA">
        <seg>読出し専用添え字の戻り型として</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As the type of a constant, variable, or property</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数、変数、またはプロパティの型として</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As the type of a read-only computed property</seg>
      </tuv>
      <tuv lang="JA">
        <seg>読出し専用の計算プロパティの型として</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As the type of items in an array, dictionary, or other container</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列、辞書、または他のコンテナ中の項目の型として</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As their names suggest, the value of a stored variable or a stored variable property is stored in memory.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの名前が示すように、格納変数または格納変数プロパティの値はメモリに格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with &lt;c6&gt;&lt;s7&gt;Int&lt;/s7&gt;&lt;/c6&gt; and &lt;c8&gt;&lt;s9&gt;Double&lt;/s9&gt;&lt;/c8&gt; above, you don’t need to declare constants or variables as &lt;c10&gt;&lt;s11&gt;Bool&lt;/s11&gt;&lt;/c10&gt; if you set them to &lt;c12&gt;&lt;s13&gt;true&lt;/s13&gt;&lt;/c12&gt; or &lt;c14&gt;&lt;s15&gt;false&lt;/s15&gt;&lt;/c14&gt; as soon as you create them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の&lt;c6&gt;&lt;s7&gt;Int&lt;/s7&gt;&lt;/c6&gt;と&lt;c8&gt;&lt;s9&gt;Double&lt;/s9&gt;&lt;/c8&gt;と同様に、あなたがそれらを作成するやいなや&lt;c12&gt;&lt;s13&gt;true&lt;/s13&gt;&lt;/c12&gt;または&lt;c14&gt;&lt;s15&gt;false&lt;/s15&gt;&lt;/c14&gt;に設定するならば、あなたは定数または変数を&lt;c10&gt;&lt;s11&gt;Bool&lt;/s11&gt;&lt;/c10&gt;として宣言する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with all unsafe operations, you take on the responsibility for checking that code for safety.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべての安全でない操作と同様に、あなたはコードの安全について検査する責任を持つようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with an array, you find out the number of items in a &lt;c0&gt;&lt;s1&gt;Dictionary&lt;/s1&gt;&lt;/c0&gt; by checking its read-only &lt;c2&gt;&lt;s3&gt;count&lt;/s3&gt;&lt;/c2&gt; property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列と同様に、あなたはある&lt;c0&gt;&lt;s1&gt;Dictionary&lt;/s1&gt;&lt;/c0&gt;の中の項目の数を、それの読み出し専用の&lt;c2&gt;&lt;s3&gt;count&lt;/s3&gt;&lt;/c2&gt;プロパティを調べることによって突き止めます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with an overridden property, method or subscript, the presence of the &lt;c0&gt;&lt;s1&gt;override&lt;/s1&gt;&lt;/c0&gt; modifier prompts Swift to check that the superclass has a matching designated initializer to be overridden, and validates that the parameters for your overriding initializer have been specified as intended.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オーバーライドされるプロパティ、メソッドや添え字を書く時と同様に、&lt;c0&gt;&lt;s1&gt;override&lt;/s1&gt;&lt;/c0&gt;修飾子の存在はスウィフトにスーパークラスが一致している、オーバーライドされる指定イニシャライザを持つのを確認すること、そしてあなたがオーバーライドするイニシャライザのパラメータが意図されるように指定されてしまっているのを検証することを促します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with any other type, you can leave it to Swift to infer the function type when you assign a function to a constant or variable:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あらゆる他の型と同様に、あなたが関数を定数または変数に代入するとき、あなたはスウィフトに関数型を推論するように任せることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with arrays, you can create an empty &lt;c0&gt;&lt;s1&gt;Dictionary&lt;/s1&gt;&lt;/c0&gt; of a certain type by using initializer syntax:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列と同様に、あなたは、特定の型の空の&lt;c0&gt;&lt;s1&gt;Dictionary&lt;/s1&gt;&lt;/c0&gt;を作成することが、イニシャライザ構文を使うことで行えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with arrays, you don’t have to write the type of the dictionary if you’re initializing it with a dictionary literal whose keys and values have consistent types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列と同様に、キーと値が首尾一貫した型をもつ辞書リテラルでそれを初期化しているならば、あなたは辞書の型を書く必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with computed properties, subscript declarations support reading and writing the value of the accessed elements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>計算プロパティと同様に、添え字宣言はアクセスされた要素の値を読み書きすることをサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with computed properties, you can choose not to specify the setter’s &lt;c2&gt;&lt;s3&gt;(newValue)&lt;/s3&gt;&lt;/c2&gt; parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>計算プロパティと同様に、あなたはセッターの&lt;c2&gt;&lt;s3&gt;(newValue)&lt;/s3&gt;&lt;/c2&gt;パラメータを指定しないほうを選ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with constant declarations, if the &lt;e0&gt;variable name&lt;/e0&gt; is a tuple pattern, the name of each item in the tuple is bound to the corresponding value in the initializer &lt;e1&gt;expression&lt;/e1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数宣言と同様に、&lt;e0&gt;変数名&lt;/e0&gt;がタプルパターンであるならば、タプルの中の各項目の名前はイニシャライザ&lt;e1&gt;式&lt;/e1&gt;の対応する値に縛りつけられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with function and method parameters, initialization parameters can have both a parameter name for use within the initializer’s body and an argument label for use when calling the initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数とメソッドのパラメータと同様に、初期化パラメータは、イニシャライザの本文内で使用するためのパラメータ名とイニシャライザを呼ぶ時に使用するための引数ラベルの両方を持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with function and method parameters, the types of an initializer’s parameters can’t be more private than the initializer’s own access level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数やメソッドパラメータと同様に、イニシャライザのパラメーターの型は、そのイニシャライザ自身のアクセス水準よりも非公開にすることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with methods, properties, and subscripts, you need to mark overridden designated initializers with the &lt;c0&gt;&lt;s1&gt;override&lt;/s1&gt;&lt;/c0&gt; declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッド、プロパティ、そして添え字と同様に、あなたはオーバーライドした指定イニシャライザを&lt;c0&gt;&lt;s1&gt;override&lt;/s1&gt;&lt;/c0&gt;宣言修飾子で印する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with optionals, if you don’t provide an initial value when you declare an implicitly unwrapped optional variable or property, its value automatically defaults to &lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルと同様に、あなたが暗黙的にアンラップされるオプショナルの変数やプロパティに初期値を提供しないならば、その値は自動的に省略時の&lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with other examples of type safety in Swift, this approach avoids accidental errors and ensures that the intention of a particular section of code is always clear.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおける型安全に関する他の例と同様に、このやり方は、偶然のエラーを避けること、そしてコードの特定の節の意図を常にはっきりさせることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with other protocol member declarations, these property declarations declare only the getter and setter requirements for types that conform to the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他のプロトコルメンバー宣言と同様に、これらのプロパティ宣言はそのプロトコルに準拠する型のためのゲッターとセッター要件だけを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with prefix operators, postfix operator declarations don’t specify a precedence level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接頭辞演算子と同様に、接尾辞演算子宣言は、優先順位レベルを指定しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with read-only computed properties, you can simplify the declaration of a read-only subscript by removing the &lt;c0&gt;&lt;s1&gt;get&lt;/s1&gt;&lt;/c0&gt; keyword and its braces:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>読み出し専用の計算プロパティでのように、あなたは読み出し専用の添え字の宣言を単純化することが、&lt;c0&gt;&lt;s1&gt;get&lt;/s1&gt;&lt;/c0&gt;キーワードとそれの波括弧を取り除くことによって行えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with strong reference cycles between two class instances, you declare each captured reference to be a weak or unowned reference rather than a strong reference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つのクラスインスタンスの間の強い参照循環と同様に、あなたは各捕らえられた参照が強い参照というよりは弱いまたは非所有参照であると宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with the closed range operator, the value of &lt;c10&gt;&lt;s11&gt;a&lt;/s11&gt;&lt;/c10&gt; must not be greater than &lt;c12&gt;&lt;s13&gt;b&lt;/s13&gt;&lt;/c12&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>完結範囲演算子と同じように、&lt;c10&gt;&lt;s11&gt;a&lt;/s11&gt;&lt;/c10&gt;の値は&lt;c12&gt;&lt;s13&gt;b&lt;/s13&gt;&lt;/c12&gt;より大きくてはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with the default initializer above, if you want a public structure type to be initializable with a memberwise initializer when used in another module, you must provide a public memberwise initializer yourself as part of the type’s definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上記の省略時のイニシャライザと同様に、あなたがある公開の構造体型を別のモジュール内で使うときにメンバー関連イニシャライザを使って初期化できるようにしたいならば、あなたは公開のメンバー関連イニシャライザをあなた自身でその型定義の一部として提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with type property requirements, you always prefix type method requirements with the &lt;c0&gt;&lt;s1&gt;static&lt;/s1&gt;&lt;/c0&gt; keyword when they’re defined in a protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型プロパティ要件と同様に、あなたは常に型メソッド要件の前に、それらがプロトコルにおいて定義されるとき、&lt;c0&gt;&lt;s1&gt;static&lt;/s1&gt;&lt;/c0&gt;キーワードを置きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As you’ll see in &lt;a0&gt;&lt;s1&gt;Shorthand Getter Declaration&lt;/s1&gt;&lt;/a0&gt;, property getters can also use an implicit return.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが&lt;a0&gt;&lt;s1&gt;略記ゲッター宣言&lt;/s1&gt;&lt;/a0&gt;で見るように、プロパティゲッターもまた暗黙的なreturnを使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assertions and Preconditions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>表明と前提条件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assertions help you find mistakes and incorrect assumptions during development, and preconditions help you detect issues in production.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>表明は、あなたが失策や間違った想定を見つけるのを開発中に助けます、そして前提条件は、あなたが製品における問題点を見抜くのを助けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assigning Constant Properties During Initialization</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期化の間に定数プロパティを割り当てる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assigning to self Within a Mutating Method</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変更メソッド内部でselfに代入する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assignment Operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代入演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assignment is performed from each part of the &lt;e4&gt;value&lt;/e4&gt; to the corresponding part of the &lt;e5&gt;expression&lt;/e5&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代入は、&lt;e4&gt;値&lt;/e4&gt;の各部分から&lt;e5&gt;式&lt;/e5&gt;の対応する部分へと実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Associated Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Associated Types in Action</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連型の動作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Associated Types with a Generic Where Clause</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体where節を持つ関連型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Associated Values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Associated types are similar to type parameters in generic parameter clauses, but they’re associated with &lt;c2&gt;&lt;s3&gt;Self&lt;/s3&gt;&lt;/c2&gt; in the protocol in which they’re declared.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連型は、総称体パラメータ節の中の型パラメータに似ています、しかしそれらは、それらが宣言されるプロトコルにおいて&lt;c2&gt;&lt;s3&gt;Self&lt;/s3&gt;&lt;/c2&gt;と結び付けられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Associated types are specified with the &lt;c1&gt;&lt;s2&gt;associatedtype&lt;/s2&gt;&lt;/c1&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連型は、&lt;c1&gt;&lt;s2&gt;associatedtype&lt;/s2&gt;&lt;/c1&gt;キーワードで指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Associated values are set when you create a new constant or variable based on one of the enumeration’s cases, and can be different each time you do so.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連値は、あなたが列挙のケース節のうちの１つに基づいて新しい定数または変数を作るときに設定されます、そしてあなたがそうするたびに違ったものにすることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assuming that you provide default values for any new properties you introduce in a subclass, the following two rules apply:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが省略時の値をあなたがサブクラスで導入するあらゆる新しいプロパティに用意すると仮定して、以下の２つの規則が適用されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At compile time, a key-path expression is replaced by an instance of the &lt;a0&gt;&lt;c1&gt;&lt;s2&gt;KeyPath&lt;/s2&gt;&lt;/c1&gt;&lt;/a0&gt;&lt;s3&gt; [https://developer.apple.com/documentation/swift/keypath]&lt;/s3&gt; class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイル時に、キーパス式は&lt;a0&gt;&lt;c1&gt;&lt;s2&gt;KeyPath&lt;/s2&gt;&lt;/c1&gt;&lt;/a0&gt;&lt;s3&gt; [https://developer.apple.com/documentation/swift/keypath]&lt;/s3&gt;クラスのインスタンスによって置き換えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At compile time, the key-path string expression is replaced by a string literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイル時で、キーパス文字列式は文字列リテラルによって置き換えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At least one is a write access.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>少なくとも１つが書き込みアクセスである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At parse time, an expression made up of binary operators is represented as a flat list.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構文解析の時、二項演算子から成り立つ式は、平坦なリストとして表わされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At runtime, if the cast succeeds, the value of &lt;e7&gt;expression&lt;/e7&gt; is wrapped in an optional and returned; otherwise, the value returned is &lt;c8&gt;&lt;s9&gt;nil&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実行時に、キャストが成功したならば、&lt;e7&gt;式&lt;/e7&gt;の値がひとつのオプショナルの中にラップされて返されます；そうでなければ返される値は&lt;c8&gt;&lt;s9&gt;nil&lt;/s9&gt;&lt;/c8&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the end of &lt;c17&gt;&lt;s18&gt;resize(to:)&lt;/s18&gt;&lt;/c17&gt;, the return statement checks &lt;c19&gt;&lt;s20&gt;$height&lt;/s20&gt;&lt;/c19&gt; and &lt;c21&gt;&lt;s22&gt;$width&lt;/s22&gt;&lt;/c21&gt; to determine whether the property wrapper adjusted either &lt;c23&gt;&lt;s24&gt;height&lt;/s24&gt;&lt;/c23&gt; or &lt;c25&gt;&lt;s26&gt;width&lt;/s26&gt;&lt;/c25&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c17&gt;&lt;s18&gt;resize(to:)&lt;/s18&gt;&lt;/c17&gt;の終わりで、return文は&lt;c19&gt;&lt;s20&gt;$height&lt;/s20&gt;&lt;/c19&gt;と&lt;c21&gt;&lt;s22&gt;$width&lt;/s22&gt;&lt;/c21&gt;を確認して、プロパティラッパーが&lt;c23&gt;&lt;s24&gt;height&lt;/s24&gt;&lt;/c23&gt;または&lt;c25&gt;&lt;s26&gt;width&lt;/s26&gt;&lt;/c25&gt;のどちらを調節したかを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the end of the &lt;c18&gt;&lt;s19&gt;for&lt;/s19&gt;&lt;/c18&gt;-&lt;c20&gt;&lt;s21&gt;in&lt;/s21&gt;&lt;/c20&gt; loop, the values of &lt;c22&gt;&lt;s23&gt;movieCount&lt;/s23&gt;&lt;/c22&gt; and &lt;c24&gt;&lt;s25&gt;songCount&lt;/s25&gt;&lt;/c24&gt; contain a count of how many &lt;c26&gt;&lt;s27&gt;MediaItem&lt;/s27&gt;&lt;/c26&gt; instances were found of each type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c18&gt;&lt;s19&gt;for&lt;/s19&gt;&lt;/c18&gt;-&lt;c20&gt;&lt;s21&gt;in&lt;/s21&gt;&lt;/c20&gt;ループの終わりに、&lt;c22&gt;&lt;s23&gt;movieCount&lt;/s23&gt;&lt;/c22&gt;と&lt;c24&gt;&lt;s25&gt;songCount&lt;/s25&gt;&lt;/c24&gt;の値は、各型の&lt;c26&gt;&lt;s27&gt;MediaItem&lt;/s27&gt;&lt;/c26&gt;インスタンスがどれくらい見つけられたかの総数を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the start of the game, the player is on “square zero”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ゲームの開始時点で、プレーヤーは−「正方形ゼロ」の上にいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At this point, the original &lt;c0&gt;&lt;s1&gt;Barcode.upc&lt;/s1&gt;&lt;/c0&gt; and its integer values are replaced by the new &lt;c2&gt;&lt;s3&gt;Barcode.qrCode&lt;/s3&gt;&lt;/c2&gt; and its string value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この点で、最初の&lt;c0&gt;&lt;s1&gt;Barcode.upc&lt;/s1&gt;&lt;/c0&gt;およびその整数値は、新しい&lt;c2&gt;&lt;s3&gt;Barcode.qrCode&lt;/s3&gt;&lt;/c2&gt;およびその文字列値と取り替えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attempting to access an index outside of a string’s range or a &lt;c0&gt;&lt;s1&gt;Character&lt;/s1&gt;&lt;/c0&gt; at an index outside of a string’s range will trigger a runtime error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある文字列の範囲外のインデックスにまたはある文字列の範囲外のインデックスで&lt;c0&gt;&lt;s1&gt;Character&lt;/s1&gt;&lt;/c0&gt;にアクセスを試みることは、実行時エラーの引き金となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attempting to do so is reported as an error when your code is compiled:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうしようとすることは、あなたのコードがコンパイルされる時にエラーとして報告されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attempting to do so results in a compile-time error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうしようとすることは、それでコンパイル時エラーという結果となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attributes</seg>
      </tuv>
      <tuv lang="JA">
        <seg>属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Autoclosures</seg>
      </tuv>
      <tuv lang="JA">
        <seg>自動クロージャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Automatic Initializer Inheritance</seg>
      </tuv>
      <tuv lang="JA">
        <seg>自動的なイニシャライザ継承</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Automatic Reference Counting</seg>
      </tuv>
      <tuv lang="JA">
        <seg>自動参照カウント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Availability Condition</seg>
      </tuv>
      <tuv lang="JA">
        <seg>有効性条件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Avoid combining multiple instances of the ternary conditional operator into one compound statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>三項条件演算子を使用したもの複数を１つの複合文に結合することを避けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Avoiding default fallthrough means that Swift &lt;c8&gt;&lt;s9&gt;switch&lt;/s9&gt;&lt;/c8&gt; statements are much more concise and predictable than their counterparts in C, and thus they avoid executing multiple &lt;c10&gt;&lt;s11&gt;switch&lt;/s11&gt;&lt;/c10&gt; cases by mistake.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>何もしなくても抜け落ちることを避けることは、スウィフトの&lt;c8&gt;&lt;s9&gt;switch&lt;/s9&gt;&lt;/c8&gt;文がCでのそれに対応する物よりずっと簡潔で予測できること、そしてそれゆえに、それは誤って複数の&lt;c10&gt;&lt;s11&gt;switch&lt;/s11&gt;&lt;/c10&gt;ケース節を実行することを回避することを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Backslash (&lt;c0&gt;&lt;s1&gt;\\&lt;/s1&gt;&lt;/c0&gt;)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>バックスラッシュ（&lt;c0&gt;&lt;s1&gt;\\&lt;/s1&gt;&lt;/c0&gt;）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Based on the values of &lt;c0&gt;&lt;s1&gt;enteredDoorCode&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;passedRetinaScan&lt;/s3&gt;&lt;/c2&gt;, and &lt;c4&gt;&lt;s5&gt;hasDoorKey&lt;/s5&gt;&lt;/c4&gt;, the first two subexpressions are &lt;c6&gt;&lt;s7&gt;false&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;enteredDoorCode&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;passedRetinaScan&lt;/s3&gt;&lt;/c2&gt;、そして&lt;c4&gt;&lt;s5&gt;hasDoorKey&lt;/s5&gt;&lt;/c4&gt;の値に基づいて、最初の２つの下位の式は&lt;c6&gt;&lt;s7&gt;false&lt;/s7&gt;&lt;/c6&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Basic Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>基本の演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be careful to ensure that operator interactions still behave in the way you intend when porting existing code to Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>既存のコードをスウィフトに移植するとき、依然としてあなたが意図するやり方で演算子相互作用が振る舞うことを確実にするように注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be extended to expand their functionality beyond a default implementation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの機能性を元の実装を越えて広げるために、拡張されます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Be warned, though—this function doesn’t compile, for reasons explained after the example:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>注意するように、とは言うものの ― この関数はコンパイルしません、この例の後に説明される理由のために：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because &lt;c0&gt;&lt;s1&gt;1&lt;/s1&gt;&lt;/c0&gt; is less than &lt;c2&gt;&lt;s3&gt;2&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;(1,&lt;/s5&gt; &lt;s6&gt;"zebra")&lt;/s6&gt;&lt;/c4&gt; is considered less than &lt;c7&gt;&lt;s8&gt;(2,&lt;/s8&gt; &lt;s9&gt;"apple")&lt;/s9&gt;&lt;/c7&gt;, regardless of any other values in the tuples.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;1&lt;/s1&gt;&lt;/c0&gt;は&lt;c2&gt;&lt;s3&gt;2&lt;/s3&gt;&lt;/c2&gt;より少ないことから、&lt;c4&gt;&lt;s5&gt;(1,&lt;/s5&gt; &lt;s6&gt;"zebra")&lt;/s6&gt;&lt;/c4&gt;は&lt;c7&gt;&lt;s8&gt;(2,&lt;/s8&gt; &lt;s9&gt;"apple")&lt;/s9&gt;&lt;/c7&gt;より少ないとみなされます、タプルの中のあらゆる他の値に関係なく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because &lt;c0&gt;&lt;s1&gt;BlackjackCard&lt;/s1&gt;&lt;/c0&gt; is a structure with no custom initializers, it has an implicit memberwise initializer, as described in &lt;a2&gt;&lt;s3&gt;Memberwise Initializers for Structure Types&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;BlackjackCard&lt;/s1&gt;&lt;/c0&gt;があつらえのイニシャライザのない構造体であるので、構造型のための&lt;a2&gt;&lt;s3&gt;メンバー関連イニシャライザ&lt;/s3&gt;&lt;/a2&gt;で記述されるように、それは暗黙のメンバー関連イニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because &lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;Double&lt;/s3&gt;&lt;/c2&gt;, for example, both conform to the &lt;c4&gt;&lt;s5&gt;Comparable&lt;/s5&gt;&lt;/c4&gt; protocol, this function accepts arguments of either type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;Double&lt;/s3&gt;&lt;/c2&gt;は両方とも&lt;c4&gt;&lt;s5&gt;Comparable&lt;/s5&gt;&lt;/c4&gt;プロトコルに準拠するので、この関数はどちらの型の引数でも受け入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because &lt;c0&gt;&lt;s1&gt;capitalCity&lt;/s1&gt;&lt;/c0&gt; has a default &lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt; value, a new &lt;c4&gt;&lt;s5&gt;Country&lt;/s5&gt;&lt;/c4&gt; instance is considered fully initialized as soon as the &lt;c6&gt;&lt;s7&gt;Country&lt;/s7&gt;&lt;/c6&gt; instance sets its &lt;c8&gt;&lt;s9&gt;name&lt;/s9&gt;&lt;/c8&gt; property within its initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;capitalCity&lt;/s1&gt;&lt;/c0&gt;が省略時の&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;値を持つので、新しい&lt;c4&gt;&lt;s5&gt;Country&lt;/s5&gt;&lt;/c4&gt;インスタンスは、&lt;c6&gt;&lt;s7&gt;Country&lt;/s7&gt;&lt;/c6&gt;インスタンスがそのイニシャライザ内でその&lt;c8&gt;&lt;s9&gt;name&lt;/s9&gt;&lt;/c8&gt;プロパティを設定するとすぐに、完全に初期化されると見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because &lt;c0&gt;&lt;s1&gt;john.residence&lt;/s1&gt;&lt;/c0&gt; is &lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;, this optional chaining call fails in the same way as before.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;john.residence&lt;/s1&gt;&lt;/c0&gt;が&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;であるため、このオプショナル連鎖呼び出しは前と同じやり方で失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because &lt;c0&gt;&lt;s1&gt;playerOne&lt;/s1&gt;&lt;/c0&gt; is an optional, it is qualified with an exclamation point (&lt;c2&gt;&lt;s3&gt;!&lt;/s3&gt;&lt;/c2&gt;) when its &lt;c4&gt;&lt;s5&gt;coinsInPurse&lt;/s5&gt;&lt;/c4&gt; property is accessed to print its default number of coins, and whenever its &lt;c6&gt;&lt;s7&gt;win(coins:)&lt;/s7&gt;&lt;/c6&gt; method is called:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;playerOne&lt;/s1&gt;&lt;/c0&gt;がオプショナルであることから、それは感嘆符（&lt;c2&gt;&lt;s3&gt;!&lt;/s3&gt;&lt;/c2&gt;）で修飾されます、それのもつ&lt;c4&gt;&lt;s5&gt;coinsInPurse&lt;/s5&gt;&lt;/c4&gt;プロパティがその省略時のコイン数を出力するためにアクセスされる時に、そして何時でもそれの&lt;c6&gt;&lt;s7&gt;win(coins:)&lt;/s7&gt;&lt;/c6&gt;メソッドが呼ばれる時に：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because &lt;c0&gt;&lt;s1&gt;rangeOfFourItems&lt;/s1&gt;&lt;/c0&gt; is declared as a constant (with the &lt;c2&gt;&lt;s3&gt;let&lt;/s3&gt;&lt;/c2&gt; keyword), it is not possible to change its &lt;c4&gt;&lt;s5&gt;firstValue&lt;/s5&gt;&lt;/c4&gt; property, even though &lt;c6&gt;&lt;s7&gt;firstValue&lt;/s7&gt;&lt;/c6&gt; is a variable property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;rangeOfFourItems&lt;/s1&gt;&lt;/c0&gt;が定数（&lt;c2&gt;&lt;s3&gt;let&lt;/s3&gt;&lt;/c2&gt;キーワードを使って）として宣言されるので、たとえ&lt;c4&gt;&lt;s5&gt;firstValue&lt;/s5&gt;&lt;/c4&gt;が変数プロパティであるとしても、その&lt;c6&gt;&lt;s7&gt;firstValue&lt;/s7&gt;&lt;/c6&gt;プロパティを変えることは可能ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because &lt;c10&gt;&lt;s11&gt;T&lt;/s11&gt;&lt;/c10&gt; is a placeholder, Swift doesn’t look for an actual type called &lt;c12&gt;&lt;s13&gt;T&lt;/s13&gt;&lt;/c12&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c10&gt;&lt;s11&gt;T&lt;/s11&gt;&lt;/c10&gt;がプレースホルダであるので、スウィフトは&lt;c12&gt;&lt;s13&gt;T&lt;/s13&gt;&lt;/c12&gt;と呼ばれる実際の型を捜しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because &lt;c10&gt;&lt;s11&gt;generator&lt;/s11&gt;&lt;/c10&gt; is known to adopt &lt;c12&gt;&lt;s13&gt;RandomNumberGenerator&lt;/s13&gt;&lt;/c12&gt;, it’s guaranteed to have a &lt;c14&gt;&lt;s15&gt;random()&lt;/s15&gt;&lt;/c14&gt; method to call.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c10&gt;&lt;s11&gt;generator&lt;/s11&gt;&lt;/c10&gt;が&lt;c12&gt;&lt;s13&gt;RandomNumberGenerator&lt;/s13&gt;&lt;/c12&gt;を採用すると知られているので、それは&lt;c14&gt;&lt;s15&gt;random()&lt;/s15&gt;&lt;/c14&gt;メソッドを呼ぶことを保証されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because &lt;c12&gt;&lt;s13&gt;userDefinedColorName&lt;/s13&gt;&lt;/c12&gt; is &lt;c14&gt;&lt;s15&gt;nil&lt;/s15&gt;&lt;/c14&gt;, the expression &lt;c16&gt;&lt;s17&gt;userDefinedColorName&lt;/s17&gt; &lt;s18&gt;??&lt;/s18&gt; &lt;s19&gt;defaultColorName&lt;/s19&gt;&lt;/c16&gt; returns the value of &lt;c20&gt;&lt;s21&gt;defaultColorName&lt;/s21&gt;&lt;/c20&gt;, or &lt;c22&gt;&lt;s23&gt;"red"&lt;/s23&gt;&lt;/c22&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c12&gt;&lt;s13&gt;userDefinedColorName&lt;/s13&gt;&lt;/c12&gt;は&lt;c14&gt;&lt;s15&gt;nil&lt;/s15&gt;&lt;/c14&gt;なので、式&lt;c16&gt;&lt;s17&gt;userDefinedColorName&lt;/s17&gt; &lt;s18&gt;??&lt;/s18&gt; &lt;s19&gt;defaultColorName&lt;/s19&gt;&lt;/c16&gt;は、&lt;c20&gt;&lt;s21&gt;defaultColorName&lt;/s21&gt;&lt;/c20&gt;の値、すなわち&lt;c22&gt;&lt;s23&gt;"red"&lt;/s23&gt;&lt;/c22&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because &lt;c2&gt;&lt;s3&gt;Void&lt;/s3&gt;&lt;/c2&gt; is a type alias for &lt;c4&gt;&lt;s5&gt;()&lt;/s5&gt;&lt;/c4&gt;, you can use it to write an empty tuple type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;Void&lt;/s3&gt;&lt;/c2&gt;が&lt;c4&gt;&lt;s5&gt;()&lt;/s5&gt;&lt;/c4&gt;に対する型エイリアスであることから、あなたはそれを使って空のタプル型を書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because &lt;c2&gt;&lt;s3&gt;beginning&lt;/s3&gt;&lt;/c2&gt; is a substring of &lt;c4&gt;&lt;s5&gt;greeting&lt;/s5&gt;&lt;/c4&gt;, it reuses the memory that &lt;c6&gt;&lt;s7&gt;greeting&lt;/s7&gt;&lt;/c6&gt; uses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;beginning&lt;/s3&gt;&lt;/c2&gt;が&lt;c4&gt;&lt;s5&gt;greeting&lt;/s5&gt;&lt;/c4&gt;の下位文字列であることから、それは&lt;c6&gt;&lt;s7&gt;greeting&lt;/s7&gt;&lt;/c6&gt;が使うメモリを再利用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because &lt;c2&gt;&lt;s3&gt;makeASandwich()&lt;/s3&gt;&lt;/c2&gt; can throw an error, the function call is wrapped in a &lt;c4&gt;&lt;s5&gt;try&lt;/s5&gt;&lt;/c4&gt; expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;makeASandwich()&lt;/s3&gt;&lt;/c2&gt;はエラーをスロー可能なので、この関数呼び出しは&lt;c4&gt;&lt;s5&gt;try&lt;/s5&gt;&lt;/c4&gt;式で包まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because &lt;c4&gt;&lt;s5&gt;Resolution&lt;/s5&gt;&lt;/c4&gt; is a structure, a &lt;e6&gt;copy&lt;/e6&gt; of the existing instance is made, and this new copy is assigned to &lt;c7&gt;&lt;s8&gt;cinema&lt;/s8&gt;&lt;/c7&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;Resolution&lt;/s5&gt;&lt;/c4&gt;が構造体であるので、既存のインスタンスの&lt;e6&gt;コピー&lt;/e6&gt;が作成されます、そして、この新しいコピーは&lt;c7&gt;&lt;s8&gt;cinema&lt;/s8&gt;&lt;/c7&gt;に代入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because &lt;c4&gt;&lt;s5&gt;item&lt;/s5&gt;&lt;/c4&gt; is a &lt;c6&gt;&lt;s7&gt;MediaItem&lt;/s7&gt;&lt;/c6&gt; instance, it’s possible that it &lt;e8&gt;might&lt;/e8&gt; be a &lt;c9&gt;&lt;s10&gt;Movie&lt;/s10&gt;&lt;/c9&gt;; equally, it’s also possible that it might be a &lt;c11&gt;&lt;s12&gt;Song&lt;/s12&gt;&lt;/c11&gt;, or even just a base &lt;c13&gt;&lt;s14&gt;MediaItem&lt;/s14&gt;&lt;/c13&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;item&lt;/s5&gt;&lt;/c4&gt;が&lt;c6&gt;&lt;s7&gt;MediaItem&lt;/s7&gt;&lt;/c6&gt;インスタンスであるので、それが&lt;c9&gt;&lt;s10&gt;Movie&lt;/s10&gt;&lt;/c9&gt;である&lt;e8&gt;かもしれない&lt;/e8&gt;可能性があります；等しく、それが&lt;c11&gt;&lt;s12&gt;Song&lt;/s12&gt;&lt;/c11&gt;かもしれない可能性もまたあります、または単に基盤&lt;c13&gt;&lt;s14&gt;MediaItem&lt;/s14&gt;&lt;/c13&gt;であることさえも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because &lt;c6&gt;&lt;s7&gt;AutomaticallyNamedDocument&lt;/s7&gt;&lt;/c6&gt; copes with the empty string case in a different way than its superclass, its initializer does not need to fail, and so it provides a nonfailable version of the initializer instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;AutomaticallyNamedDocument&lt;/s7&gt;&lt;/c6&gt;が空の文字列の場合をそれのスーパークラスと異なるやり方でうまく処理するので、それのイニシャライザは失敗する必要はありません、それでそれはそうせずに、失敗できない改作のイニシャライザを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because &lt;c6&gt;&lt;s7&gt;IntStack&lt;/s7&gt;&lt;/c6&gt; conforms to all of the requirements of the &lt;c8&gt;&lt;s9&gt;Container&lt;/s9&gt;&lt;/c8&gt; protocol, Swift can infer the appropriate &lt;c10&gt;&lt;s11&gt;Item&lt;/s11&gt;&lt;/c10&gt; to use, simply by looking at the type of the &lt;c12&gt;&lt;s13&gt;append(_:)&lt;/s13&gt;&lt;/c12&gt; method’s &lt;c14&gt;&lt;s15&gt;item&lt;/s15&gt;&lt;/c14&gt; parameter and the return type of the subscript.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;IntStack&lt;/s7&gt;&lt;/c6&gt;が&lt;c8&gt;&lt;s9&gt;Container&lt;/s9&gt;&lt;/c8&gt;プロトコルの要件の全てに準拠するので、スウィフトは、単に&lt;c12&gt;&lt;s13&gt;append(_:)&lt;/s13&gt;&lt;/c12&gt;メソッドの&lt;c14&gt;&lt;s15&gt;item&lt;/s15&gt;&lt;/c14&gt;パラメータの型、そして、添え字の戻り型を見ることによって、使用するのに適切な&lt;c10&gt;&lt;s11&gt;item&lt;/s11&gt;&lt;/c10&gt;を推論することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because &lt;c6&gt;&lt;s7&gt;Person&lt;/s7&gt;&lt;/c6&gt; conforms to both protocols, this call is valid, and the &lt;c8&gt;&lt;s9&gt;wishHappyBirthday(to:)&lt;/s9&gt;&lt;/c8&gt; function can print its birthday greeting.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;Person&lt;/s7&gt;&lt;/c6&gt;が両方のプロトコルに準拠するので、これは有効な呼び出しです、それで&lt;c8&gt;&lt;s9&gt;wishHappyBirthday(to:)&lt;/s9&gt;&lt;/c8&gt;関数はその誕生日のお祝いを出力できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because &lt;c6&gt;&lt;s7&gt;game&lt;/s7&gt;&lt;/c6&gt; is known to conform to the &lt;c8&gt;&lt;s9&gt;DiceGame&lt;/s9&gt;&lt;/c8&gt; protocol, it’s guaranteed to have a &lt;c10&gt;&lt;s11&gt;dice&lt;/s11&gt;&lt;/c10&gt; property, and so the &lt;c12&gt;&lt;s13&gt;gameDidStart(_:)&lt;/s13&gt;&lt;/c12&gt; method is able to access and print the dice’s &lt;c14&gt;&lt;s15&gt;sides&lt;/s15&gt;&lt;/c14&gt; property, regardless of what kind of game is being played.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;game&lt;/s7&gt;&lt;/c6&gt;が&lt;c8&gt;&lt;s9&gt;DiceGame&lt;/s9&gt;&lt;/c8&gt;プロトコルに従うと知られているので、それは&lt;c10&gt;&lt;s11&gt;dice&lt;/s11&gt;&lt;/c10&gt;プロパティを持つと保証されます、なので、&lt;c12&gt;&lt;s13&gt;gameDidStart(_:)&lt;/s13&gt;&lt;/c12&gt;メソッドは、どんな種類のゲームがプレイされているかに関係なく、diceの&lt;c14&gt;&lt;s15&gt;sides&lt;/s15&gt;&lt;/c14&gt;プロパティにアクセスして出力することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because &lt;c6&gt;&lt;s7&gt;john.residence&lt;/s7&gt;&lt;/c6&gt; is currently &lt;c8&gt;&lt;s9&gt;nil&lt;/s9&gt;&lt;/c8&gt;, the subscript call fails:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;john.residence&lt;/s7&gt;&lt;/c6&gt;が現在&lt;c8&gt;&lt;s9&gt;nil&lt;/s9&gt;&lt;/c8&gt;なので、添え字呼び出しは失敗します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because &lt;c6&gt;&lt;s7&gt;userDefinedColorName&lt;/s7&gt;&lt;/c6&gt; is of an optional type, you can use the nil-coalescing operator to consider its value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;userDefinedColorName&lt;/s7&gt;&lt;/c6&gt;がオプショナル型であるため、あなたはその値を考慮するためにnil合体演算子を使うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because &lt;c9&gt;&lt;s10&gt;anotherPoint&lt;/s10&gt;&lt;/c9&gt; is always a tuple of two values, this case matches all possible remaining values, and a &lt;c11&gt;&lt;s12&gt;default&lt;/s12&gt;&lt;/c11&gt; case is not needed to make the &lt;c13&gt;&lt;s14&gt;switch&lt;/s14&gt;&lt;/c13&gt; statement exhaustive.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c9&gt;&lt;s10&gt;anotherPoint&lt;/s10&gt;&lt;/c9&gt;が常に２つの値のタプルであることから、このケース節は全てのあり得る残りの値にマッチします、そして&lt;c11&gt;&lt;s12&gt;default&lt;/s12&gt;&lt;/c11&gt;ケース節はこの&lt;c13&gt;&lt;s14&gt;switch&lt;/s14&gt;&lt;/c13&gt;文を網羅的にするのに必要ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because Swift is type safe, it performs &lt;e0&gt;type checks&lt;/e0&gt; when compiling your code and flags any mismatched types as errors.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトが型安全であるので、それは、あなたのコードをコンパイルするとき&lt;e0&gt;型チェック&lt;/e0&gt;を実行して、あらゆる組合せを誤った型をエラーとして合図します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because Swift manages memory automatically, most of the time you don’t have to think about accessing memory at all.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトはメモリを自動的に管理することから、ほとんどの場合あなたはメモリアクセスについて考える必要は全くありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because Swift’s &lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt; statement is exhaustive and does not allow empty cases, it is sometimes necessary to deliberately match and ignore a case in order to make your intentions explicit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの&lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt;文は網羅的でありそして中身が空のケース節を許さないので、あなたの意図を明確にするために故意にあるケース節にマッチしてから無視することが時々必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because a &lt;c4&gt;&lt;s5&gt;throw&lt;/s5&gt;&lt;/c4&gt; statement immediately transfers program control, an item will be vended only if all of these requirements are met.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;throw&lt;/s5&gt;&lt;/c4&gt;文が直ちにプログラム制御を移すので、これらの必要なものすべてが満たされる場合にのみ項目は販売されることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because a credit card will always have a customer, you define its &lt;c0&gt;&lt;s1&gt;customer&lt;/s1&gt;&lt;/c0&gt; property as an unowned reference, to avoid a strong reference cycle:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クレジットカードが常にひとりの顧客を持つので、強い参照循環を避けるために、あなたはその&lt;c0&gt;&lt;s1&gt;customer&lt;/s1&gt;&lt;/c0&gt;プロパティを非所有参照として定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because a failed assertion or precondition indicates an invalid program state, there’s no way to catch a failed assertion.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗した表明または前提条件は無効なプログラム状態を示すことから、失敗した表明を受け止めるための方法はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because a selector is created at compile time, not at runtime, the compiler can check that a method or property exists and that they’re exposed to the Objective-C runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるセレクタが作成されるのはコンパイル時であり、実行時でないので、コンパイラはそのメソッドまたはプロパティが存在すること、そしてそれらがObjective-Cランタイムに露出されていることを確かめることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because a weak reference does not keep a strong hold on the instance it refers to, it’s possible for that instance to be deallocated while the weak reference is still referring to it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>弱い参照がそれが言及するインスタンスに対する強い支配力を保たないので、弱い参照がまだそれに言及している間にそのインスタンスが割り当て解除されることは可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because addition isn’t part of the essential behavior for a vector, the type method is defined in an extension of &lt;c4&gt;&lt;s5&gt;Vector2D&lt;/s5&gt;&lt;/c4&gt; rather than in the main structure declaration of &lt;c6&gt;&lt;s7&gt;Vector2D&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>加算はベクトルの欠くことのできない挙動の部分ではないので、この型メソッドは&lt;c4&gt;&lt;s5&gt;Vector2D&lt;/s5&gt;&lt;/c4&gt;の拡張において定義されます、&lt;c6&gt;&lt;s7&gt;Vector2D&lt;/s7&gt;&lt;/c6&gt;の主構造定義においてではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because all keys in the literal are of the same type as each other, and likewise all values are of the same type as each other, Swift can infer that &lt;c0&gt;&lt;s1&gt;[String:&lt;/s1&gt; &lt;s2&gt;String]&lt;/s2&gt;&lt;/c0&gt; is the correct type to use for the &lt;c3&gt;&lt;s4&gt;airports&lt;/s4&gt;&lt;/c3&gt; dictionary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このリテラルの全てのキーが互いに同じ型である、そして全ての型が互いに他と同じ型であるので、スウィフトは、&lt;c0&gt;&lt;s1&gt;[String:&lt;/s1&gt; &lt;s2&gt;String]&lt;/s2&gt;&lt;/c0&gt;が&lt;c3&gt;&lt;s4&gt;airports&lt;/s4&gt;&lt;/c3&gt;辞書に使うために適切な型であると推測することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because all of the types can be inferred, the return arrow (&lt;c12&gt;&lt;s13&gt;-&gt;&lt;/s13&gt;&lt;/c12&gt;) and the parentheses around the names of the parameters can also be omitted:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型の全てが推論されることができるので、戻り矢印（&lt;c12&gt;&lt;s13&gt;-&gt;&lt;/s13&gt;&lt;/c12&gt;）と、パラメータの名前のまわりの丸括弧もまた省略することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because all properties of the &lt;c0&gt;&lt;s1&gt;ShoppingListItem&lt;/s1&gt;&lt;/c0&gt; class have default values, and because it is a base class with no superclass, &lt;c2&gt;&lt;s3&gt;ShoppingListItem&lt;/s3&gt;&lt;/c2&gt; automatically gains a default initializer implementation that creates a new instance with all of its properties set to their default values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;ShoppingListItem&lt;/s1&gt;&lt;/c0&gt;クラスの全てのプロパティ省略時の値を持つことから、そしてそれがスーパークラスを持たない基盤クラスであることから、&lt;c2&gt;&lt;s3&gt;ShoppingListItem&lt;/s3&gt;&lt;/c2&gt;は自動的に省略時のイニシャライザ実装を獲得します、それは、それのプロパティの全てをそれらの省略時の値に設定して、新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because all values in the array literal are of the same type, Swift can infer that &lt;c0&gt;&lt;s1&gt;Set&lt;String&gt;&lt;/s1&gt;&lt;/c0&gt; is the correct type to use for the &lt;c2&gt;&lt;s3&gt;favoriteGenres&lt;/s3&gt;&lt;/c2&gt; variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列リテラルの中の全ての値が同じ型であることから、スウィフトは&lt;c0&gt;&lt;s1&gt;Set&lt;String&gt;&lt;/s1&gt;&lt;/c0&gt;が正しい型であると推論することができ、&lt;c2&gt;&lt;s3&gt;favoriteGenres&lt;/s3&gt;&lt;/c2&gt;変数に使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because all values in the array literal are of the same type, Swift can infer that &lt;c0&gt;&lt;s1&gt;[String]&lt;/s1&gt;&lt;/c0&gt; is the correct type to use for the &lt;c2&gt;&lt;s3&gt;shoppingList&lt;/s3&gt;&lt;/c2&gt; variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この配列リテラルの値の全てが同じ型であるので、スウィフトは&lt;c0&gt;&lt;s1&gt;[String]&lt;/s1&gt;&lt;/c0&gt;が&lt;c2&gt;&lt;s3&gt;shoppingList&lt;/s3&gt;&lt;/c2&gt;変数のために利用されるのに正しい型であると推測することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because an addition operator was defined earlier, you don’t need to reimplement the addition process here.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>加算演算子は以前に定義されたので、あなたはここでは加算プロセスを再実装する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because an instance is not deallocated until after its deinitializer is called, a deinitializer can access all properties of the instance it is called on and can modify its behavior based on those properties (such as looking up the name of a file that needs to be closed).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インスタンスはそれのデイニシャライザが呼ばれる後までは割り当て解除されないので、デイニシャライザはそれが呼ばれるところのインスタンスの全てのプロパティにアクセスすることができて、それらのプロパティに基づいてその挙動を修正することができます（たとえば閉じられる必要があるファイルの名前を調べることなど）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because argument labels are not part of a function’s type, you omit them when writing a function type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>引数ラベルは関数の型の一部ではないことから、あなたはそれらを関数型を書く時に省略します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because arrays conform to &lt;c0&gt;&lt;s1&gt;Collection&lt;/s1&gt;&lt;/c0&gt; and integers conform to &lt;c2&gt;&lt;s3&gt;Equatable&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;equalNumbers&lt;/s5&gt;&lt;/c4&gt; and &lt;c6&gt;&lt;s7&gt;differentNumbers&lt;/s7&gt;&lt;/c6&gt; can use the &lt;c8&gt;&lt;s9&gt;allEqual()&lt;/s9&gt;&lt;/c8&gt; method:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それら配列は&lt;c0&gt;&lt;s1&gt;Collection&lt;/s1&gt;&lt;/c0&gt;に準拠し、それら整数は&lt;c2&gt;&lt;s3&gt;Equatable&lt;/s3&gt;&lt;/c2&gt;に準拠することから、&lt;c4&gt;&lt;s5&gt;equalNumbers&lt;/s5&gt;&lt;/c4&gt;と&lt;c6&gt;&lt;s7&gt;differentNumbers&lt;/s7&gt;&lt;/c6&gt;は&lt;c8&gt;&lt;s9&gt;allEqual()&lt;/s9&gt;&lt;/c8&gt;メソッドを使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because both of them refer to the same closure, they both increment and return the same running total.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの両方ともが同じクロージャを参照することから、それらは両方とも漸増しますそして同じ実行総数を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because both sides of the addition are now of type &lt;c0&gt;&lt;s1&gt;UInt16&lt;/s1&gt;&lt;/c0&gt;, the addition is allowed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>加算の両側が今では型&lt;c0&gt;&lt;s1&gt;UInt16&lt;/s1&gt;&lt;/c0&gt;であるので、加算は許されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because classes are reference types, &lt;c0&gt;&lt;s1&gt;tenEighty&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;alsoTenEighty&lt;/s3&gt;&lt;/c2&gt; actually both refer to the &lt;e4&gt;same&lt;/e4&gt; &lt;c5&gt;&lt;s6&gt;VideoMode&lt;/s6&gt;&lt;/c5&gt; instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスが参照型であるので、&lt;c0&gt;&lt;s1&gt;tenEighty&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;alsoTenEighty&lt;/s3&gt;&lt;/c2&gt;は両方とも実際に&lt;e4&gt;同じ&lt;/e4&gt;&lt;c5&gt;&lt;s6&gt;VideoMode&lt;/s6&gt;&lt;/c5&gt;インスタンスに言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because classes are reference types, it’s possible for multiple constants and variables to refer to the same single instance of a class behind the scenes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスが参照型であるので、複数の定数と変数があるクラスの同じ１つのインスタンスに言及することが舞台裏で可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because declarations marked with the &lt;c0&gt;&lt;s1&gt;dynamic&lt;/s1&gt;&lt;/c0&gt; modifier are dispatched using the Objective-C runtime, they must be marked with the &lt;c2&gt;&lt;s3&gt;objc&lt;/s3&gt;&lt;/c2&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;dynamic&lt;/s1&gt;&lt;/c0&gt;修飾子で印される宣言はObjective-Cランタイムを使ってディスパッチされるので、それらは&lt;c2&gt;&lt;s3&gt;objc&lt;/s3&gt;&lt;/c2&gt;属性で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because downcasting can fail, the type cast operator comes in two different forms.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ダウンキャストは失敗することがありえるので、型キャスト演算子は２つの異なる書式になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because each numeric type can store a different range of values, you must opt in to numeric type conversion on a case-by-case basis.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれの数の型は、値の異なる幅を格納できるので、あなたは数の型変換を一件一件を原則に決めていかなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because fatal errors are never optimized out, unlike assertions or preconditions, you can be sure that execution always halts if it encounters a stub implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>致命的なエラーは決して間違って最適化されません、表明や前提条件と違います、あなたは実行が常に停止することをそれがスタブ実装に遭遇する場合には確信できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because implicit unwrapping changes the meaning of the declaration that contains that type, optional types that are nested inside a tuple type or a generic type—such as the element types of a dictionary or array—can’t be marked as implicitly unwrapped.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗黙的にアンラップされることがその型を含む宣言の意味することを変えることから、タプル型や総称体型の内部に入れ子にされたオプショナル型—例えば辞書や配列に属する要素型など—は、暗黙的にアンラップされるように印されることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because implicitly unwrapped optionals have the same &lt;c0&gt;&lt;s1&gt;Optional&lt;Wrapped&gt;&lt;/s1&gt;&lt;/c0&gt; type as optional values, you can use implicitly unwrapped optionals in all the same places in your code that you can use optionals.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗黙的にアンラップされるオプショナルがオプショナル値と同じ&lt;c0&gt;&lt;s1&gt;Optional&lt;Wrapped&gt;&lt;/s1&gt;&lt;/c0&gt;型を持つことから、あなたは、あなたのコードにおいてあなたがオプショナルを使うことができるのと同じ場所すべてで暗黙的にアンラップされるオプショナルを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because it does not need to return a value, the function’s definition does not include the return arrow (&lt;c0&gt;&lt;s1&gt;-&gt;&lt;/s1&gt;&lt;/c0&gt;) or a return type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが値を返す必要がないので、この関数の定義は戻り矢印（&lt;c0&gt;&lt;s1&gt;-&gt;&lt;/s1&gt;&lt;/c0&gt;）または戻り型を含みません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because it is an integer, it is rounded down during the division, so &lt;c4&gt;&lt;s5&gt;16&lt;/s5&gt;&lt;/c4&gt; becomes &lt;c6&gt;&lt;s7&gt;1&lt;/s7&gt;&lt;/c6&gt;, &lt;c8&gt;&lt;s9&gt;58&lt;/s9&gt;&lt;/c8&gt; becomes &lt;c10&gt;&lt;s11&gt;5&lt;/s11&gt;&lt;/c10&gt;, and &lt;c12&gt;&lt;s13&gt;510&lt;/s13&gt;&lt;/c12&gt; becomes &lt;c14&gt;&lt;s15&gt;51&lt;/s15&gt;&lt;/c14&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが整数であるので、除算のときに端数を切り捨てられます、それで&lt;c4&gt;&lt;s5&gt;16&lt;/s5&gt;&lt;/c4&gt;が&lt;c6&gt;&lt;s7&gt;1&lt;/s7&gt;&lt;/c6&gt;に、&lt;c8&gt;&lt;s9&gt;58&lt;/s9&gt;&lt;/c8&gt;が&lt;c10&gt;&lt;s11&gt;5&lt;/s11&gt;&lt;/c10&gt;に、そして&lt;c12&gt;&lt;s13&gt;510&lt;/s13&gt;&lt;/c12&gt;は&lt;c14&gt;&lt;s15&gt;51&lt;/s15&gt;&lt;/c14&gt;になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because it is in essence an “additive” operator, it has been given the same precedence group as additive infix operators such as &lt;c4&gt;&lt;s5&gt;+&lt;/s5&gt;&lt;/c4&gt; and &lt;c6&gt;&lt;s7&gt;-&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは本質的には「加法的な」演算子であるので、それは&lt;c4&gt;&lt;s5&gt;+&lt;/s5&gt;&lt;/c4&gt;や&lt;c6&gt;&lt;s7&gt;-&lt;/s7&gt;&lt;/c6&gt;といった加法的な接中辞演算子と同じ優先順位グループを与えられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because it is marked with the &lt;c0&gt;&lt;s1&gt;lazy&lt;/s1&gt;&lt;/c0&gt; modifier, the &lt;c2&gt;&lt;s3&gt;DataImporter&lt;/s3&gt;&lt;/c2&gt; instance for the &lt;c4&gt;&lt;s5&gt;importer&lt;/s5&gt;&lt;/c4&gt; property is only created when the &lt;c6&gt;&lt;s7&gt;importer&lt;/s7&gt;&lt;/c6&gt; property is first accessed, such as when its &lt;c8&gt;&lt;s9&gt;filename&lt;/s9&gt;&lt;/c8&gt; property is queried:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが&lt;c0&gt;&lt;s1&gt;lazy&lt;/s1&gt;&lt;/c0&gt;修飾子という特徴をもつので、&lt;c4&gt;&lt;s5&gt;importer&lt;/s5&gt;&lt;/c4&gt;プロパティのための&lt;c2&gt;&lt;s3&gt;DataImporter&lt;/s3&gt;&lt;/c2&gt;インスタンスは、&lt;c6&gt;&lt;s7&gt;importer&lt;/s7&gt;&lt;/c6&gt;プロパティが最初にアクセスされるsgにだけ作成されます、例えばその&lt;c8&gt;&lt;s9&gt;filename&lt;/s9&gt;&lt;/c8&gt;プロパティがたずねられるときなど：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because it is possible to request a key for which no value exists, a dictionary’s subscript returns an optional value of the dictionary’s value type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それに対する値が存在しないキーへの要請が可能であるので、ある辞書の添え字は、その辞書の値型のオプショナルの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because it provides a default value for all of the properties it introduces and does not define any initializers itself, &lt;c0&gt;&lt;s1&gt;ShoppingListItem&lt;/s1&gt;&lt;/c0&gt; automatically inherits &lt;e2&gt;all&lt;/e2&gt; of the designated and convenience initializers from its superclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが、省略時の値をそれが導入するプロパティの全てに与えて、そしてまったくイニシャライザを定義しないので、&lt;c0&gt;&lt;s1&gt;ShoppingListItem&lt;/s1&gt;&lt;/c0&gt;はそのスーパークラスから自動的に指定および便宜イニシャライザの&lt;e2&gt;全て&lt;/e2&gt;を継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because its type is &lt;c9&gt;&lt;s10&gt;RandomNumberGenerator&lt;/s10&gt;&lt;/c9&gt;, code inside the &lt;c11&gt;&lt;s12&gt;Dice&lt;/s12&gt;&lt;/c11&gt; class can only interact with &lt;c13&gt;&lt;s14&gt;generator&lt;/s14&gt;&lt;/c13&gt; in ways that apply to all generators that conform to this protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それの型が&lt;c9&gt;&lt;s10&gt;RandomNumberGenerator&lt;/s10&gt;&lt;/c9&gt;であることから、&lt;c11&gt;&lt;s12&gt;Dice&lt;/s12&gt;&lt;/c11&gt;クラスの内部のコードは、全ての生成子にこのプロトコルに準拠することを適用するという方法で&lt;c13&gt;&lt;s14&gt;generator&lt;/s14&gt;&lt;/c13&gt;と相互作用できるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because it’s a generic type, &lt;c0&gt;&lt;s1&gt;Stack&lt;/s1&gt;&lt;/c0&gt; can be used to create a stack of &lt;e2&gt;any&lt;/e2&gt; valid type in Swift, in a similar manner to &lt;c3&gt;&lt;s4&gt;Array&lt;/s4&gt;&lt;/c3&gt; and &lt;c5&gt;&lt;s6&gt;Dictionary&lt;/s6&gt;&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが総称体型であるので、&lt;c0&gt;&lt;s1&gt;Stack&lt;/s1&gt;&lt;/c0&gt;は、&lt;c3&gt;&lt;s4&gt;Array&lt;/s4&gt;&lt;/c3&gt;と&lt;c5&gt;&lt;s6&gt;Dictionary&lt;/s6&gt;&lt;/c5&gt;に類似したやり方で、スウィフトにおける&lt;e2&gt;あらゆる&lt;/e2&gt;有効な型のスタックを作るために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because it’s an alias, the call to &lt;c4&gt;&lt;s5&gt;AudioSample.min&lt;/s5&gt;&lt;/c4&gt; actually calls &lt;c6&gt;&lt;s7&gt;UInt16.min&lt;/s7&gt;&lt;/c6&gt;, which provides an initial value of &lt;c8&gt;&lt;s9&gt;0&lt;/s9&gt;&lt;/c8&gt; for the &lt;c10&gt;&lt;s11&gt;maxAmplitudeFound&lt;/s11&gt;&lt;/c10&gt; variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それがエイリアスであるので、&lt;c4&gt;&lt;s5&gt;AudioSample.min&lt;/s5&gt;&lt;/c4&gt;への呼び出しは実際には&lt;c6&gt;&lt;s7&gt;UInt16.min&lt;/s7&gt;&lt;/c6&gt;を呼び、それは&lt;c8&gt;&lt;s9&gt;0&lt;/s9&gt;&lt;/c8&gt;の初期値を&lt;c10&gt;&lt;s11&gt;maxAmplitudeFound&lt;/s11&gt;&lt;/c10&gt;変数のために提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because it’s not necessarily a mistake for code that calls the &lt;c12&gt;&lt;s13&gt;advance(to:)&lt;/s13&gt;&lt;/c12&gt; method to ignore the return value, this function is marked with the &lt;c14&gt;&lt;s15&gt;@discardableResult&lt;/s15&gt;&lt;/c14&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c12&gt;&lt;s13&gt;advance(to:)&lt;/s13&gt;&lt;/c12&gt;メソッドを呼び出して戻り値を無視することが必ずしもコードの誤りでないことから、この関数は&lt;c14&gt;&lt;s15&gt;@discardableResult&lt;/s15&gt;&lt;/c14&gt;属性で印されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because it’s not practical to list every possible &lt;c0&gt;&lt;s1&gt;Character&lt;/s1&gt;&lt;/c0&gt; value in the example above, a &lt;c2&gt;&lt;s3&gt;default&lt;/s3&gt;&lt;/c2&gt; case handles any characters that are not matched.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべてのあり得る&lt;c0&gt;&lt;s1&gt;Character&lt;/s1&gt;&lt;/c0&gt;値を並べることは上の例では実際的ではないので、&lt;c2&gt;&lt;s3&gt;default&lt;/s3&gt;&lt;/c2&gt;ケース節が適合しないあらゆる文字を取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because it’s of an optional type, the &lt;c5&gt;&lt;s6&gt;delegate&lt;/s6&gt;&lt;/c5&gt; property is automatically set to an initial value of &lt;c7&gt;&lt;s8&gt;nil&lt;/s8&gt;&lt;/c7&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それがオプショナル型であるので、&lt;c5&gt;&lt;s6&gt;delegate&lt;/s6&gt;&lt;/c5&gt;プロパティは自動的に初期値の&lt;c7&gt;&lt;s8&gt;nilに&lt;/s8&gt;&lt;/c7&gt;設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because multiline string literals use three double quotation marks instead of just one, you can include a double quotation mark (&lt;c0&gt;&lt;s1&gt;"&lt;/s1&gt;&lt;/c0&gt;) inside of a multiline string literal without escaping it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数行文字列リテラルは、ただ１つではなく３つの二重引用符を使います、あなたは二重引用符（&lt;c0&gt;&lt;s1&gt;"&lt;/s1&gt;&lt;/c0&gt;）を複数行文字列リテラルの内部にそれをエスケープすることなく含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because of the special way that positive and negative numbers are stored, shifting either of them to the right moves them closer to zero.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>正および負の数が格納される特別な方法のため、それらのどちらでも右へシフトすることは、それらをゼロの近くに動かします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because of the unowned &lt;c0&gt;&lt;s1&gt;customer&lt;/s1&gt;&lt;/c0&gt; reference, when you break the strong reference held by the &lt;c2&gt;&lt;s3&gt;john&lt;/s3&gt;&lt;/c2&gt; variable, there are no more strong references to the &lt;c4&gt;&lt;s5&gt;Customer&lt;/s5&gt;&lt;/c4&gt; instance:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非所有&lt;c0&gt;&lt;s1&gt;customer&lt;/s1&gt;&lt;/c0&gt;参照であることから、あなたが&lt;c2&gt;&lt;s3&gt;john&lt;/s3&gt;&lt;/c2&gt;変数によって保持される強い参照を壊すとき、&lt;c4&gt;&lt;s5&gt;Customer&lt;/s5&gt;&lt;/c4&gt;インスタンスへの強い参照はもうそれ以上ありません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because of this behavior, the &lt;c5&gt;&lt;s6&gt;switch&lt;/s6&gt;&lt;/c5&gt; cases &lt;c7&gt;&lt;s8&gt;case&lt;/s8&gt; &lt;s9&gt;let&lt;/s9&gt; &lt;s10&gt;(x,&lt;/s10&gt; &lt;s11&gt;y):&lt;/s11&gt;&lt;/c7&gt; and &lt;c12&gt;&lt;s13&gt;case&lt;/s13&gt; &lt;s14&gt;(let&lt;/s14&gt; &lt;s15&gt;x,&lt;/s15&gt; &lt;s16&gt;let&lt;/s16&gt; &lt;s17&gt;y):&lt;/s17&gt;&lt;/c12&gt; match the same values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この挙動のため、&lt;c5&gt;&lt;s6&gt;switch&lt;/s6&gt;&lt;/c5&gt;ケース節&lt;c7&gt;&lt;s8&gt;case&lt;/s8&gt; &lt;s9&gt;let&lt;/s9&gt; &lt;s10&gt;(x,&lt;/s10&gt; &lt;s11&gt;y):&lt;/s11&gt;&lt;/c7&gt;と&lt;c12&gt;&lt;s13&gt;case&lt;/s13&gt; &lt;s14&gt;(let&lt;/s14&gt; &lt;s15&gt;x,&lt;/s15&gt; &lt;s16&gt;let&lt;/s16&gt; &lt;s17&gt;y):&lt;/s17&gt;&lt;/c12&gt;は、同じ値にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because of this uncertainty, the &lt;c15&gt;&lt;s16&gt;as?&lt;/s16&gt;&lt;/c15&gt; form of the type cast operator returns an &lt;e17&gt;optional&lt;/e17&gt; value when attempting to downcast to a subclass type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この不確実性のために、サブクラス型へのダウンキャストを試みるとき、型キャスト演算子の&lt;c15&gt;&lt;s16&gt;as?&lt;/s16&gt;&lt;/c15&gt;形式は&lt;e17&gt;オプショナル&lt;/e17&gt;の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because of this, Swift provides an automatic argument label for &lt;e0&gt;every&lt;/e0&gt; parameter in an initializer if you don’t provide one.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これのため、スウィフトは、あなたがそれを独自に提供しないならば、自動的な引数ラベルをイニシャライザの&lt;e0&gt;あらゆる&lt;/e0&gt;パラメータに用意します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because of this, all of the &lt;c4&gt;&lt;s5&gt;Int.Kind&lt;/s5&gt;&lt;/c4&gt; case values can be written in shorthand form inside the &lt;c6&gt;&lt;s7&gt;switch&lt;/s7&gt;&lt;/c6&gt; statement, such as &lt;c8&gt;&lt;s9&gt;.negative&lt;/s9&gt;&lt;/c8&gt; rather than &lt;c10&gt;&lt;s11&gt;Int.Kind.negative&lt;/s11&gt;&lt;/c10&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのことから、&lt;c4&gt;&lt;s5&gt;Int.Kind&lt;/s5&gt;&lt;/c4&gt;のケース節の値の全ては、&lt;c6&gt;&lt;s7&gt;switch&lt;/s7&gt;&lt;/c6&gt;文内で略記形式で書かれることができます、たとえば&lt;c10&gt;&lt;s11&gt;Int.Kind.negative&lt;/s11&gt;&lt;/c10&gt;ではなく&lt;c8&gt;&lt;s9&gt;.negative&lt;/s9&gt;&lt;/c8&gt;のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because of this, characters in Swift don’t each take up the same amount of memory within a string’s representation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これのため、スウィフトの中の文字は、それぞれが同じ量のメモリを文字列の表現において取るわけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because of this, it isn’t possible to guarantee that this code will work for &lt;e7&gt;every&lt;/e7&gt; possible type &lt;c8&gt;&lt;s9&gt;T&lt;/s9&gt;&lt;/c8&gt;, and an appropriate error is reported when you try to compile the code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このため、このコードが&lt;e7&gt;すべての&lt;/e7&gt;可能な型&lt;c8&gt;&lt;s9&gt;T&lt;/s9&gt;&lt;/c8&gt;のために機能することを保証することは可能ではありません、それであなたがこのコードをコンパイルしようとする場合は該当するエラーが報告されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because of this, the call to &lt;c8&gt;&lt;s9&gt;john.residence?.address?.street&lt;/s9&gt;&lt;/c8&gt; fails.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このことから、&lt;c8&gt;&lt;s9&gt;john.residence?.address?.street&lt;/s9&gt;&lt;/c8&gt;への呼び出しは、失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because of this, the more general term &lt;e2&gt;instance&lt;/e2&gt; is used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これのため、より一般的な語&lt;e2&gt;インスタンス&lt;/e2&gt;が使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because of this, the raw value initializer always returns an &lt;e2&gt;optional&lt;/e2&gt; enumeration case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのため、生の値のイニシャライザは常に&lt;e2&gt;オプショナル&lt;/e2&gt;の列挙ケース節を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because of type inference, Swift requires far fewer type declarations than languages such as C or Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型推論のため、スウィフトはCまたはObjective-Cのような言語よりはるかに少ない型宣言しか必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because one value is &lt;c10&gt;&lt;s11&gt;true&lt;/s11&gt;&lt;/c10&gt;, the overall expression also evaluates to &lt;c12&gt;&lt;s13&gt;true&lt;/s13&gt;&lt;/c12&gt;, and access is allowed:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>１つの値が&lt;c10&gt;&lt;s11&gt;true&lt;/s11&gt;&lt;/c10&gt;なので、式全体もまた&lt;c12&gt;&lt;s13&gt;true&lt;/s13&gt;&lt;/c12&gt;です、そしてアクセスは許可されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because operators are functions, they can also have long-term accesses to their in-out parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これら演算が関数であることから、それらはまた長期アクセスをそれらのin-outパラメータに対して持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because optional patterns are syntactic sugar for &lt;c0&gt;&lt;s1&gt;Optional&lt;/s1&gt;&lt;/c0&gt; enumeration case patterns, the following are equivalent:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルパターンは&lt;c0&gt;&lt;s1&gt;Optional&lt;/s1&gt;&lt;/c0&gt;列挙ケース節パターンに対する糖衣構文であるので、以下のものは等価です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because patterns represent the structure of a value rather than any one particular value, you can match them with a variety of values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パターンがどれかひとつの特定の値ではなく値の構造を表すので、あなたはそれをいろいろな値と照合（マッチング）できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because property wrapper syntax is just syntactic sugar for a property with a getter and a setter, accessing &lt;c0&gt;&lt;s1&gt;height&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;width&lt;/s3&gt;&lt;/c2&gt; behaves the same as accessing any other property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティラッパー構文がゲッターとセッターをもつプロパティに対する単なる糖衣構文であることから、&lt;c0&gt;&lt;s1&gt;height&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;width&lt;/s3&gt;&lt;/c2&gt;にアクセスすることは、何か他のプロパティと同じ挙動をします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because protocols are types, begin their names with a capital letter (such as &lt;c0&gt;&lt;s1&gt;FullyNamed&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;RandomNumberGenerator&lt;/s3&gt;&lt;/c2&gt;) to match the names of other types in Swift (such as &lt;c4&gt;&lt;s5&gt;Int&lt;/s5&gt;&lt;/c4&gt;, &lt;c6&gt;&lt;s7&gt;String&lt;/s7&gt;&lt;/c6&gt;, and &lt;c8&gt;&lt;s9&gt;Double&lt;/s9&gt;&lt;/c8&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルが型であるので、それらの名前を大文字で開始してください（例えば&lt;c0&gt;&lt;s1&gt;FullyNamed&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;RandomNumberGenerator&lt;/s3&gt;&lt;/c2&gt;のように）、それによってスウィフトでの他の型の名前（例えば&lt;c4&gt;&lt;s5&gt;Int&lt;/s5&gt;&lt;/c4&gt;、&lt;c6&gt;&lt;s7&gt;String&lt;/s7&gt;&lt;/c6&gt;、および&lt;c8&gt;&lt;s9&gt;Double&lt;/s9&gt;&lt;/c8&gt;）と釣り合いがとれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because superclass &lt;c0&gt;&lt;s1&gt;A&lt;/s1&gt;&lt;/c0&gt; and subclass &lt;c2&gt;&lt;s3&gt;B&lt;/s3&gt;&lt;/c2&gt; are defined in the same source file, it’s valid for the &lt;c4&gt;&lt;s5&gt;B&lt;/s5&gt;&lt;/c4&gt; implementation of &lt;c6&gt;&lt;s7&gt;someMethod()&lt;/s7&gt;&lt;/c6&gt; to call &lt;c8&gt;&lt;s9&gt;super.someMethod()&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラス&lt;c0&gt;&lt;s1&gt;A&lt;/s1&gt;&lt;/c0&gt;とサブクラス&lt;c2&gt;&lt;s3&gt;B&lt;/s3&gt;&lt;/c2&gt;が同じソースファイルにおいて定義されるので、&lt;c4&gt;&lt;s5&gt;B&lt;/s5&gt;&lt;/c4&gt;実装の&lt;c6&gt;&lt;s7&gt;someMethod()&lt;/s7&gt;&lt;/c6&gt;が&lt;c8&gt;&lt;s9&gt;super.someMethod()&lt;/s9&gt;&lt;/c8&gt;を呼ぶことは有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the &lt;c0&gt;&lt;s1&gt;Hashable&lt;/s1&gt;&lt;/c0&gt; protocol conforms to &lt;c2&gt;&lt;s3&gt;Equatable&lt;/s3&gt;&lt;/c2&gt;, conforming types must also provide an implementation of the equals operator (&lt;c4&gt;&lt;s5&gt;==&lt;/s5&gt;&lt;/c4&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Hashable&lt;/s1&gt;&lt;/c0&gt;プロトコルが&lt;c2&gt;&lt;s3&gt;Equatable&lt;/s3&gt;&lt;/c2&gt;に準拠することから、準拠する型はまた同等演算子（&lt;c4&gt;&lt;s5&gt;==&lt;/s5&gt;&lt;/c4&gt;）のあるひとつの実装を提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the &lt;c0&gt;&lt;s1&gt;Rect&lt;/s1&gt;&lt;/c0&gt; structure provides default values for all of its properties, it receives a default initializer and a memberwise initializer automatically, as described in &lt;a2&gt;&lt;s3&gt;Default Initializers&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Rect&lt;/s1&gt;&lt;/c0&gt;構造体がそのプロパティの全てに省略時の値を与えるので、&lt;a2&gt;&lt;s3&gt;省略時のイニシャライザ&lt;/s3&gt;&lt;/a2&gt;で記述されるように、それは自動的に省略時のイニシャライザとメンバー関連イニシャライザを受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the &lt;c0&gt;&lt;s1&gt;delegate&lt;/s1&gt;&lt;/c0&gt; property is an &lt;e2&gt;optional&lt;/e2&gt; &lt;c3&gt;&lt;s4&gt;DiceGameDelegate&lt;/s4&gt;&lt;/c3&gt;, the &lt;c5&gt;&lt;s6&gt;play()&lt;/s6&gt;&lt;/c5&gt; method uses optional chaining each time it calls a method on the delegate.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;delegate&lt;/s1&gt;&lt;/c0&gt;プロパティが&lt;e2&gt;オプショナル&lt;/e2&gt;の&lt;c3&gt;&lt;s4&gt;DiceGameDelegate&lt;/s4&gt;&lt;/c3&gt;であるので、&lt;c5&gt;&lt;s6&gt;play()&lt;/s6&gt;&lt;/c5&gt;メソッドは、それが委任先でメソッドを呼ぶたびにオプショナル連鎖を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the &lt;c0&gt;&lt;s1&gt;first&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;second&lt;/s3&gt;&lt;/c2&gt; parameters are nonescaping functions, they can’t be passed as arguments to another nonescaping function parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;first&lt;/s1&gt;&lt;/c0&gt;および&lt;c2&gt;&lt;s3&gt;second&lt;/s3&gt;&lt;/c2&gt;パラメータは非脱出関数であることから、それらは引数として別の非脱出関数パラメータとして渡されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the &lt;c0&gt;&lt;s1&gt;vend(itemNamed:)&lt;/s1&gt;&lt;/c0&gt; method propagates any errors it throws, any code that calls this method must either handle the errors—using a &lt;c2&gt;&lt;s3&gt;do&lt;/s3&gt;&lt;/c2&gt;-&lt;c4&gt;&lt;s5&gt;catch&lt;/s5&gt;&lt;/c4&gt; statement, &lt;c6&gt;&lt;s7&gt;try?&lt;/s7&gt;&lt;/c6&gt;, or &lt;c8&gt;&lt;s9&gt;try!&lt;/s9&gt;&lt;/c8&gt;—or continue to propagate them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この&lt;c0&gt;&lt;s1&gt;vend(itemNamed:)&lt;/s1&gt;&lt;/c0&gt;メソッドはそれがスローするどんなエラーも伝達するので、このメソッドを呼び出す何らかのコードは、それらのエラーを取り扱うか ― &lt;c2&gt;&lt;s3&gt;do&lt;/s3&gt;&lt;/c2&gt;-&lt;c4&gt;&lt;s5&gt;catch&lt;/s5&gt;&lt;/c4&gt;文、&lt;c6&gt;&lt;s7&gt;try?&lt;/s7&gt;&lt;/c6&gt;、または&lt;c8&gt;&lt;s9&gt;try!&lt;/s9&gt;&lt;/c8&gt;を使って ― またはそれらの伝達を続けるか、どちらかをしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the &lt;c5&gt;&lt;s6&gt;vend(itemNamed:)&lt;/s6&gt;&lt;/c5&gt; method can throw an error, it’s called with the &lt;c7&gt;&lt;s8&gt;try&lt;/s8&gt;&lt;/c7&gt; keyword in front of it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c5&gt;&lt;s6&gt;vend(itemNamed:)&lt;/s6&gt;&lt;/c5&gt;メソッドはエラーをスローできることから、それはそれの前の&lt;c7&gt;&lt;s8&gt;try&lt;/s8&gt;&lt;/c7&gt;キーワードとともに呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the &lt;c6&gt;&lt;s7&gt;switch&lt;/s7&gt;&lt;/c6&gt; must have a case for every possible character, not just every alphabetic character, this &lt;c8&gt;&lt;s9&gt;switch&lt;/s9&gt;&lt;/c8&gt; statement uses a &lt;c10&gt;&lt;s11&gt;default&lt;/s11&gt;&lt;/c10&gt; case to match all characters other than &lt;c12&gt;&lt;s13&gt;a&lt;/s13&gt;&lt;/c12&gt; and &lt;c14&gt;&lt;s15&gt;z&lt;/s15&gt;&lt;/c14&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;switch&lt;/s7&gt;&lt;/c6&gt;は、単にすべてのアルファベット文字ではなく、すべての可能な文字に対してひとつのケース節を持たなければならないことから、この&lt;c8&gt;&lt;s9&gt;switch&lt;/s9&gt;&lt;/c8&gt;文は&lt;c12&gt;&lt;s13&gt;a&lt;/s13&gt;&lt;/c12&gt;と&lt;c14&gt;&lt;s15&gt;z&lt;/s15&gt;&lt;/c14&gt;のほかのすべての文字にマッチするために&lt;c10&gt;&lt;s11&gt;default&lt;/s11&gt;&lt;/c10&gt;ケース節を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the &lt;c8&gt;&lt;s9&gt;x&lt;/s9&gt;&lt;/c8&gt;, &lt;c10&gt;&lt;s11&gt;y&lt;/s11&gt;&lt;/c10&gt;, and &lt;c12&gt;&lt;s13&gt;z&lt;/s13&gt;&lt;/c12&gt; properties are all of an &lt;c14&gt;&lt;s15&gt;Equatable&lt;/s15&gt;&lt;/c14&gt; type, &lt;c16&gt;&lt;s17&gt;Vector3D&lt;/s17&gt;&lt;/c16&gt; receives synthesized implementations of the equivalence operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c8&gt;&lt;s9&gt;x&lt;/s9&gt;&lt;/c8&gt;、&lt;c10&gt;&lt;s11&gt;y&lt;/s11&gt;&lt;/c10&gt;、そして&lt;c12&gt;&lt;s13&gt;z&lt;/s13&gt;&lt;/c12&gt;プロパティはみんな&lt;c14&gt;&lt;s15&gt;Equatable&lt;/s15&gt;&lt;/c14&gt;型なので、&lt;c16&gt;&lt;s17&gt;Vector3D&lt;/s17&gt;&lt;/c16&gt;は等価演算子の合成された実装それらを受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the &lt;c9&gt;&lt;s10&gt;DiceGameDelegate&lt;/s10&gt;&lt;/c9&gt; protocol is class-only, you can declare the delegate to be &lt;c11&gt;&lt;s12&gt;weak&lt;/s12&gt;&lt;/c11&gt; to prevent reference cycles.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c9&gt;&lt;s10&gt;DiceGameDelegate&lt;/s10&gt;&lt;/c9&gt;プロトコルがクラス専用であることから、あなたは委任先を&lt;c11&gt;&lt;s12&gt;weak&lt;/s12&gt;&lt;/c11&gt;であると宣言して参照循環を防ぐことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the &lt;e1&gt;return type&lt;/e1&gt; can be a tuple type, function types support functions and methods that return multiple values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e1&gt;return type&lt;/e1&gt;はタプル型であることが可能なので、関数型は複数の値を返す関数およびメソッドをサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the arithmetic addition operator is a binary operator, this operator method takes two input parameters of type &lt;c8&gt;&lt;s9&gt;Vector2D&lt;/s9&gt;&lt;/c8&gt; and returns a single output value, also of type &lt;c10&gt;&lt;s11&gt;Vector2D&lt;/s11&gt;&lt;/c10&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>算術加算演算子は二項演算子なので、この演算子メソッドは&lt;c8&gt;&lt;s9&gt;Vector2D&lt;/s9&gt;&lt;/c8&gt;型の２つの入力パラメーターを取り、同じく&lt;c10&gt;&lt;s11&gt;Vector2D&lt;/s11&gt;&lt;/c10&gt;型のただ１つの出力値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the attempt to access &lt;c0&gt;&lt;s1&gt;numberOfRooms&lt;/s1&gt;&lt;/c0&gt; has the potential to fail, the optional chaining attempt returns a value of type &lt;c2&gt;&lt;s3&gt;Int?&lt;/s3&gt;&lt;/c2&gt;, or “optional &lt;c4&gt;&lt;s5&gt;Int&lt;/s5&gt;&lt;/c4&gt;”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;numberOfRooms&lt;/s1&gt;&lt;/c0&gt;にアクセスする試みは失敗する可能性があるので、オプショナル連鎖は型&lt;c2&gt;&lt;s3&gt;Int?&lt;/s3&gt;&lt;/c2&gt;の値、すなわち「オプショナルの&lt;c4&gt;&lt;s5&gt;Int&lt;/s5&gt;&lt;/c4&gt;」、を返すことを試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the body of the closure is so short, it can even be written on a single line:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャの本文がたいへん短いので、それは１つの行に書かれさえすることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the call to &lt;c0&gt;&lt;s1&gt;increment(forCount:)&lt;/s1&gt;&lt;/c0&gt; can fail for either of these two reasons, the call returns an &lt;e2&gt;optional&lt;/e2&gt; &lt;c3&gt;&lt;s4&gt;Int&lt;/s4&gt;&lt;/c3&gt; value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;increment(forCount:)&lt;/s1&gt;&lt;/c0&gt;への呼び出しがこれらの２つの理由のどちらによっても失敗する可能性があるので、呼び出しは&lt;e2&gt;オプショナルの&lt;/e2&gt;&lt;c3&gt;&lt;s4&gt;Int&lt;/s4&gt;&lt;/c3&gt;値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the closure’s body contains a single expression (&lt;c4&gt;&lt;s5&gt;s1&lt;/s5&gt; &lt;s6&gt;&gt;&lt;/s6&gt; &lt;s7&gt;s2&lt;/s7&gt;&lt;/c4&gt;) that returns a &lt;c8&gt;&lt;s9&gt;Bool&lt;/s9&gt;&lt;/c8&gt; value, there is no ambiguity, and the &lt;c10&gt;&lt;s11&gt;return&lt;/s11&gt;&lt;/c10&gt; keyword can be omitted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャの本文がある単一の式（&lt;c4&gt;&lt;s5&gt;s1&lt;/s5&gt; &lt;s6&gt;&gt;&lt;/s6&gt; &lt;s7&gt;s2&lt;/s7&gt;&lt;/c4&gt;）で&lt;c8&gt;&lt;s9&gt;Bool&lt;/s9&gt;&lt;/c8&gt;値を返すものを含むので、曖昧さはありません、それで&lt;c10&gt;&lt;s11&gt;return&lt;/s11&gt;&lt;/c10&gt;キーワードは省略されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the data is nested, the enumeration used to store the data also needs to support nesting—this means the enumeration needs to be recursive.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>データが入れ子にされるため、データを格納するために使われる列挙もまた、入れ子をサポートする必要があります—これは列挙が再帰することを必要とするのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the function returns a &lt;c9&gt;&lt;s10&gt;String&lt;/s10&gt;&lt;/c9&gt; value, &lt;c11&gt;&lt;s12&gt;greet(person:)&lt;/s12&gt;&lt;/c11&gt; can be wrapped in a call to the &lt;c13&gt;&lt;s14&gt;print(_:separator:terminator:)&lt;/s14&gt;&lt;/c13&gt; function to print that string and see its return value, as shown above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数は&lt;c9&gt;&lt;s10&gt;String&lt;/s10&gt;&lt;/c9&gt;値を返すので、上で見られるように、&lt;c11&gt;&lt;s12&gt;greet(person:)&lt;/s12&gt;&lt;/c11&gt;は&lt;c13&gt;&lt;s14&gt;print(_:separator:terminator:)&lt;/s14&gt;&lt;/c13&gt;関数への呼び出しの中に包まれて、その文字列を出力してその戻り値を見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the function’s return type is private, you must mark the function’s overall access level with the &lt;c0&gt;&lt;s1&gt;private&lt;/s1&gt;&lt;/c0&gt; modifier for the function declaration to be valid:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数の戻り型が非公開であるので、あなたはこの関数宣言が有効になるために関数の全体的なアクセス水準に&lt;c0&gt;&lt;s1&gt;private&lt;/s1&gt;&lt;/c0&gt;修飾子で印しなければなりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the initializer might fail, it returns an &lt;e0&gt;optional&lt;/e0&gt; &lt;c1&gt;&lt;s2&gt;Int&lt;/s2&gt;&lt;/c1&gt;, rather than an &lt;c3&gt;&lt;s4&gt;Int&lt;/s4&gt;&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このイニシャライザが失敗するかもしれないので、それは&lt;c3&gt;&lt;s4&gt;Int&lt;/s4&gt;&lt;/c3&gt;ではなくて、&lt;e0&gt;オプショナル&lt;/e0&gt;の&lt;c1&gt;&lt;s2&gt;Int&lt;/s2&gt;&lt;/c1&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the key path string is created at compile time, not at runtime, the compiler can check that the property exists and that the property is exposed to the Objective-C runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キーパス文字列は実行時ではなく、コンパイル時に作成されるため、コンパイラはプロパティが存在することおよびプロパティがObjective-Cランタイムへと露出されることを確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the last line of &lt;c4&gt;&lt;s5&gt;badStart&lt;/s5&gt;&lt;/c4&gt; doesn’t end with a line break, that line gets combined with the first line of &lt;c6&gt;&lt;s7&gt;end&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;badStart&lt;/s5&gt;&lt;/c4&gt;の最後の行は改行で終わらないことから、その行は&lt;c6&gt;&lt;s7&gt;end&lt;/s7&gt;&lt;/c6&gt;の最初の行と結合されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the new &lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt; instance has been assigned to the &lt;c2&gt;&lt;s3&gt;reference1&lt;/s3&gt;&lt;/c2&gt; variable, there is now a strong reference from &lt;c4&gt;&lt;s5&gt;reference1&lt;/s5&gt;&lt;/c4&gt; to the new &lt;c6&gt;&lt;s7&gt;Person&lt;/s7&gt;&lt;/c6&gt; instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい&lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt;インスタンスが&lt;c2&gt;&lt;s3&gt;reference1&lt;/s3&gt;&lt;/c2&gt;変数に代入されたので、強い参照が現在&lt;c4&gt;&lt;s5&gt;reference1&lt;/s5&gt;&lt;/c4&gt;から新しい&lt;c6&gt;&lt;s7&gt;Person&lt;/s7&gt;&lt;/c6&gt;インスタンスまで存在します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the players start off the board, on “square zero”, the board is initialized with 26 zero &lt;c4&gt;&lt;s5&gt;Int&lt;/s5&gt;&lt;/c4&gt; values, not 25.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プレイヤーは、「正方形ゼロ」で盤を始めることから、この盤は26個のゼロ&lt;c4&gt;&lt;s5&gt;Int&lt;/s5&gt;&lt;/c4&gt;値で初期化されます、25ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the sorting closure is passed as an argument to a method, Swift can infer the types of its parameters and the type of the value it returns.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ソート（分類）するクロージャが引数としてメソッドに渡されるので、スウィフトは、それのパラメータの型とそれが返す値の型を推論することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the temperature has increased to &lt;c0&gt;&lt;s1&gt;40&lt;/s1&gt;&lt;/c0&gt; degrees Fahrenheit, it is no longer cold enough to advise wearing a scarf and so the &lt;c2&gt;&lt;s3&gt;else&lt;/s3&gt;&lt;/c2&gt; branch is triggered instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>温度が華氏&lt;c0&gt;&lt;s1&gt;40&lt;/s1&gt;&lt;/c0&gt;度まで増加したので、スカーフを着けることを助言するに足りるほどもはや寒くありません、それで代わりに&lt;c2&gt;&lt;s3&gt;else&lt;/s3&gt;&lt;/c2&gt;分岐が作動させられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the temperature is neither too cold nor too warm to trigger the &lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt; or &lt;c2&gt;&lt;s3&gt;else&lt;/s3&gt; &lt;s4&gt;if&lt;/s4&gt;&lt;/c2&gt; conditions, no message is printed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この気温は&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt;または&lt;c2&gt;&lt;s3&gt;else&lt;/s3&gt; &lt;s4&gt;if&lt;/s4&gt;&lt;/c2&gt;条件の引き金になるにはあまり寒くもなくあまり暖かくもないので、メッセージは出力されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the tuple’s member values are named as part of the function’s return type, they can be accessed with dot syntax to retrieve the minimum and maximum found values:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプルの構成要素値は、この関数の戻り型の部分で命名されるので、それらは最小および最大の見つけられた値を取り出すためにドット構文でアクセスされることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the type alias and the existing type can be used interchangeably, the type alias can’t introduce additional generic constraints.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型エイリアスと既存の型は交換可能に使われることができるので、型エイリアスは追加的な総称体制約を導入することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the value of &lt;c6&gt;&lt;s7&gt;approximateCount&lt;/s7&gt;&lt;/c6&gt; falls between 12 and 100, &lt;c8&gt;&lt;s9&gt;naturalCount&lt;/s9&gt;&lt;/c8&gt; is assigned the value &lt;c10&gt;&lt;s11&gt;"dozens&lt;/s11&gt; &lt;s12&gt;of"&lt;/s12&gt;&lt;/c10&gt;, and execution is transferred out of the &lt;c13&gt;&lt;s14&gt;switch&lt;/s14&gt;&lt;/c13&gt; statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;approximateCount&lt;/s7&gt;&lt;/c6&gt;の値が12と100の間で失敗することから、&lt;c8&gt;&lt;s9&gt;naturalCount&lt;/s9&gt;&lt;/c8&gt;は、値&lt;c10&gt;&lt;s11&gt;"dozens&lt;/s11&gt; &lt;s12&gt;of"&lt;/s12&gt;&lt;/c10&gt;を代入されます、そして実行は&lt;c13&gt;&lt;s14&gt;switch&lt;/s14&gt;&lt;/c13&gt;文の外に移されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the value of the &lt;e0&gt;condition&lt;/e0&gt; is evaluated after the &lt;e1&gt;statements&lt;/e1&gt; are executed, the &lt;e2&gt;statements&lt;/e2&gt; in a &lt;c3&gt;&lt;s4&gt;repeat&lt;/s4&gt;&lt;/c3&gt;-&lt;c5&gt;&lt;s6&gt;while&lt;/s6&gt;&lt;/c5&gt; statement are executed at least once.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e1&gt;文&lt;/e1&gt;が実行された後で&lt;e0&gt;条件&lt;/e0&gt;の値が評価されるので、&lt;c3&gt;&lt;s4&gt;repeat&lt;/s4&gt;&lt;/c3&gt;-&lt;c5&gt;&lt;s6&gt;while&lt;/s6&gt;&lt;/c5&gt;文の中の&lt;e2&gt;文&lt;/e2&gt;は少なくとも一回は実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the value of the &lt;e0&gt;condition&lt;/e0&gt; is evaluated before the &lt;e1&gt;statements&lt;/e1&gt; are executed, the &lt;e2&gt;statements&lt;/e2&gt; in a &lt;c3&gt;&lt;s4&gt;while&lt;/s4&gt;&lt;/c3&gt; statement can be executed zero or more times.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e1&gt;文&lt;/e1&gt;が実行される前に、&lt;e0&gt;条件&lt;/e0&gt;の値が評価されるので、&lt;c3&gt;&lt;s4&gt;while&lt;/s4&gt;&lt;/c3&gt;文の中の&lt;e2&gt;文&lt;/e2&gt;は０回またはそれ以上実行される可能性を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because there are no more strong references to the &lt;c0&gt;&lt;s1&gt;Apartment&lt;/s1&gt;&lt;/c0&gt; instance, it too is deallocated:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Apartment&lt;/s1&gt;&lt;/c0&gt;インスタンスへの強い参照はもうこれ以上ないので、それも割り当て解除されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because there are no more strong references to the &lt;c0&gt;&lt;s1&gt;Customer&lt;/s1&gt;&lt;/c0&gt; instance, it’s deallocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Customer&lt;/s1&gt;&lt;/c0&gt;インスタンスへの強い参照はもうないので、それは割り当て解除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because there are no more strong references to the &lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt; instance, it’s deallocated and the &lt;c2&gt;&lt;s3&gt;tenant&lt;/s3&gt;&lt;/c2&gt; property is set to &lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もうこれ以上&lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt;インスタンスへの強い参照はないことから、それは割り当て解除されます、そして&lt;c2&gt;&lt;s3&gt;tenant&lt;/s3&gt;&lt;/c2&gt;特性は&lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;に設定されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because there are no other specific cases, &lt;c4&gt;&lt;s5&gt;integerToDescribe&lt;/s5&gt;&lt;/c4&gt; is matched by the &lt;c6&gt;&lt;s7&gt;default&lt;/s7&gt;&lt;/c6&gt; case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他のいかなる特定のケース節もないことから、&lt;c4&gt;&lt;s5&gt;integerToDescribe&lt;/s5&gt;&lt;/c4&gt;は&lt;c6&gt;&lt;s7&gt;default&lt;/s7&gt;&lt;/c6&gt;ケース節に適合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because there is at least one strong reference, ARC makes sure that this &lt;c8&gt;&lt;s9&gt;Person&lt;/s9&gt;&lt;/c8&gt; is kept in memory and is not deallocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>少なくとも１つの強い参照があるので、ARCはこの&lt;c8&gt;&lt;s9&gt;Person&lt;/s9&gt;&lt;/c8&gt;がメモリに保たれて割り当て解除されないことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because these are value types, mutating any piece of the value mutates the whole value, meaning read or write access to one of the properties requires read or write access to the whole value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらが値型であることから、その値の何か１つを変更することは値全体を変更し、プロパティの１つに対する読み出しや書き込みアクセスを意図することは値全体への読み出しや書き込みアクセスを必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because these variables are of an optional type (&lt;c4&gt;&lt;s5&gt;Person?&lt;/s5&gt;&lt;/c4&gt;, not &lt;c6&gt;&lt;s7&gt;Person&lt;/s7&gt;&lt;/c6&gt;), they are automatically initialized with a value of &lt;c8&gt;&lt;s9&gt;nil&lt;/s9&gt;&lt;/c8&gt;, and do not currently reference a &lt;c10&gt;&lt;s11&gt;Person&lt;/s11&gt;&lt;/c10&gt; instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの変数がオプショナル型（&lt;c6&gt;&lt;s7&gt;Person&lt;/s7&gt;&lt;/c6&gt;ではなく、&lt;c4&gt;&lt;s5&gt;Person?&lt;/s5&gt;&lt;/c4&gt;）であることから、それらは自動的に&lt;c8&gt;&lt;s9&gt;nil&lt;/s9&gt;&lt;/c8&gt;の値で初期化されて、今は&lt;c10&gt;&lt;s11&gt;Person&lt;/s11&gt;&lt;/c10&gt;インスタンスに参照をつけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because they’re named types, you can extend their behavior to suit the needs of your program, using an extension declaration, discussed in &lt;a0&gt;&lt;s1&gt;Extensions&lt;/s1&gt;&lt;/a0&gt; and &lt;a2&gt;&lt;s3&gt;Extension Declaration&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらが名前付きの型であるので、あなたはそれらの挙動を、&lt;a0&gt;&lt;s1&gt;拡張&lt;/s1&gt;&lt;/a0&gt;および&lt;a2&gt;&lt;s3&gt;拡張宣言&lt;/s3&gt;&lt;/a2&gt;で議論される拡張宣言を使って、あなたのプログラムの必要に応じて拡張することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because this convenience initializer overrides a designated initializer from its superclass, it must be marked with the &lt;c11&gt;&lt;s12&gt;override&lt;/s12&gt;&lt;/c11&gt; modifier (as described in &lt;a13&gt;&lt;s14&gt;Initializer Inheritance and Overriding&lt;/s14&gt;&lt;/a13&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この便宜イニシャライザがそれのスーパークラスからの指定イニシャライザをオーバーライドするので、それは&lt;c11&gt;&lt;s12&gt;override&lt;/s12&gt;&lt;/c11&gt;修飾子で印されなければなりません（&lt;a13&gt;&lt;s14&gt;イニシャライザの継承およびオーバーライド&lt;/s14&gt;&lt;/a13&gt;で記述されるように）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because this particular array has specified a value type of &lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt;, it is allowed to store &lt;c6&gt;&lt;s7&gt;String&lt;/s7&gt;&lt;/c6&gt; values only.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この特定の配列が&lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt;の値型を指定したので、それが貯蔵を許可されるのは&lt;c6&gt;&lt;s7&gt;String&lt;/s7&gt;&lt;/c6&gt;値のみです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because this particular set has specified a value type of &lt;c6&gt;&lt;s7&gt;String&lt;/s7&gt;&lt;/c6&gt;, it is &lt;e8&gt;only&lt;/e8&gt; allowed to store &lt;c9&gt;&lt;s10&gt;String&lt;/s10&gt;&lt;/c9&gt; values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この問題の集合が明確に指定された&lt;c6&gt;&lt;s7&gt;String&lt;/s7&gt;&lt;/c6&gt;の値型を持つことから、それは&lt;c9&gt;&lt;s10&gt;String&lt;/s10&gt;&lt;/c9&gt;値を格納すること&lt;e8&gt;だけ&lt;/e8&gt;が許されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because this version of &lt;c0&gt;&lt;s1&gt;Residence&lt;/s1&gt;&lt;/c0&gt; stores an array of &lt;c2&gt;&lt;s3&gt;Room&lt;/s3&gt;&lt;/c2&gt; instances, its &lt;c4&gt;&lt;s5&gt;numberOfRooms&lt;/s5&gt;&lt;/c4&gt; property is implemented as a computed property, not a stored property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Residence&lt;/s1&gt;&lt;/c0&gt;のこの改作が&lt;c2&gt;&lt;s3&gt;Room&lt;/s3&gt;&lt;/c2&gt;インスタンスの配列を格納するので、その&lt;c4&gt;&lt;s5&gt;numberOfRooms&lt;/s5&gt;&lt;/c4&gt;プロパティは計算プロパティとして実装されます、格納プロパティではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because your code can’t define properties that start with &lt;c5&gt;&lt;s6&gt;$&lt;/s6&gt;&lt;/c5&gt; the projected value never interferes with properties you define.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのコードが&lt;c5&gt;&lt;s6&gt;$&lt;/s6&gt;&lt;/c5&gt;で始まるプロパティを定義できないことから予測値は決してあなたが定義するプロパティと干渉しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before and after the update, you can read any information from the budget and get a correct answer, as shown in the figure below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更新の前後で、あなたはあらゆる情報を予算案から読み出して正しい答えを得ることができます、下の図で示すように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before updating &lt;c6&gt;&lt;s7&gt;currentLevel&lt;/s7&gt;&lt;/c6&gt;, this method checks whether the requested new level is already unlocked.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;currentLevel&lt;/s7&gt;&lt;/c6&gt;を更新する前に、このメソッドは要請された新しいレベルがすでに錠を開けられるかどうか調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before you can fix the conflicting access, you have to determine what it was intended to do.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがこのアクセス衝突を修正するためには、あなたは実行を意図されたものは何かを判定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Behind the scenes, &lt;c2&gt;&lt;s3&gt;UInt16&lt;/s3&gt;&lt;/c2&gt; has an initializer that accepts a &lt;c4&gt;&lt;s5&gt;UInt8&lt;/s5&gt;&lt;/c4&gt; value, and so this initializer is used to make a new &lt;c6&gt;&lt;s7&gt;UInt16&lt;/s7&gt;&lt;/c6&gt; from an existing &lt;c8&gt;&lt;s9&gt;UInt8&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>舞台裏で、&lt;c2&gt;&lt;s3&gt;UInt16&lt;/s3&gt;&lt;/c2&gt;は&lt;c4&gt;&lt;s5&gt;UInt8&lt;/s5&gt;&lt;/c4&gt;値を受け入れるイニシャライザを持ちます、それでこのイニシャライザが新しい&lt;c6&gt;&lt;s7&gt;UInt16&lt;/s7&gt;&lt;/c6&gt;を既存の&lt;c8&gt;&lt;s9&gt;UInt8&lt;/s9&gt;&lt;/c8&gt;から作るために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Behind the scenes, Swift’s compiler optimizes string usage so that actual copying takes place only when absolutely necessary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>舞台裏で、スウィフトのコンパイラは、実際にコピーすることは絶対に必要なときだけ起こるように、文字列使用を最適化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Behind the scenes, Swift’s native &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; type is built from &lt;e2&gt;Unicode scalar values&lt;/e2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>舞台裏で、スウィフト生得の&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;型は&lt;e2&gt;ユニコードスカラー値&lt;/e2&gt;によって組み立てられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Between one and eight hexadecimal digits</seg>
      </tuv>
      <tuv lang="JA">
        <seg>１から８桁の16進数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary Expressions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>二項式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary literals begin with &lt;c1&gt;&lt;s2&gt;0b&lt;/s2&gt;&lt;/c1&gt;, octal literals begin with &lt;c3&gt;&lt;s4&gt;0o&lt;/s4&gt;&lt;/c3&gt;, and hexadecimal literals begin with &lt;c5&gt;&lt;s6&gt;0x&lt;/s6&gt;&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２進のリテラルは&lt;c1&gt;&lt;s2&gt;0b&lt;/s2&gt;&lt;/c1&gt;から始まります、８進のリテラルは&lt;c3&gt;&lt;s4&gt;0o&lt;/s4&gt;&lt;/c3&gt;から始まります、そして16進のリテラルは&lt;c5&gt;&lt;s6&gt;0x&lt;/s6&gt;&lt;/c5&gt;から始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary literals contain &lt;c4&gt;&lt;s5&gt;0&lt;/s5&gt;&lt;/c4&gt; and &lt;c6&gt;&lt;s7&gt;1&lt;/s7&gt;&lt;/c6&gt;, octal literals contain &lt;c8&gt;&lt;s9&gt;0&lt;/s9&gt;&lt;/c8&gt; through &lt;c10&gt;&lt;s11&gt;7&lt;/s11&gt;&lt;/c10&gt;, and hexadecimal literals contain &lt;c12&gt;&lt;s13&gt;0&lt;/s13&gt;&lt;/c12&gt; through &lt;c14&gt;&lt;s15&gt;9&lt;/s15&gt;&lt;/c14&gt; as well as &lt;c16&gt;&lt;s17&gt;A&lt;/s17&gt;&lt;/c16&gt; through &lt;c18&gt;&lt;s19&gt;F&lt;/s19&gt;&lt;/c18&gt; in upper- or lowercase.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２進のリテラルは&lt;c4&gt;&lt;s5&gt;0&lt;/s5&gt;&lt;/c4&gt;と&lt;c6&gt;&lt;s7&gt;1&lt;/s7&gt;&lt;/c6&gt;を含みます、８進のリテラルは&lt;c8&gt;&lt;s9&gt;0&lt;/s9&gt;&lt;/c8&gt;から&lt;c10&gt;&lt;s11&gt;7&lt;/s11&gt;&lt;/c10&gt;までを含みます、そして、16進のリテラルは&lt;c12&gt;&lt;s13&gt;0&lt;/s13&gt;&lt;/c12&gt;から&lt;c14&gt;&lt;s15&gt;9&lt;/s15&gt;&lt;/c14&gt;までに加えて大文字または小文字での&lt;c16&gt;&lt;s17&gt;A&lt;/s17&gt;&lt;/c16&gt;から&lt;c18&gt;&lt;s19&gt;F&lt;/s19&gt;&lt;/c18&gt;までを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bitwise AND Operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット単位の論理積演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bitwise Left and Right Shift Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット単位の左および右シフト演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bitwise NOT Operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット単位の論理否定演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bitwise OR Operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット単位の論理和演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bitwise Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット単位演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bitwise XOR Operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット単位の排他的論理和演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bitwise left and right shifts have the effect of multiplying or dividing an integer by a factor of two.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット単位の左または右シフトは、２の因数によって、ある整数を掛けるまたは割る効果を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bitwise operators can also be useful when you work with raw data from external sources, such as encoding and decoding data for communication over a custom protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット単位演算子はまた、あなたが外部のソースからの生のデータを扱うとき、役に立つことがありえます、例えば、あつらえのプロトコルを越えて通信するためのデータの符号化や復号など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Blue numbers are shifted, gray numbers are discarded, and orange zeros are inserted:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>青色の数はシフトされます、灰色の数は捨てられます、そしてオレンジ色のゼロが差し込まれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Boolean values are particularly useful when you work with conditional statements such as the &lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt; statement:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt;文のような条件つきの文で作業するとき、ブールの値は特に役に立ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Boolean values are referred to as &lt;e3&gt;logical&lt;/e3&gt;, because they can only ever be true or false.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ブールの値は、&lt;e3&gt;論理&lt;/e3&gt;として参照されます、なぜならそれらは真か偽であることだけができるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Booleans</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ブール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;Substring&lt;/s3&gt;&lt;/c2&gt; conform to the &lt;a4&gt;&lt;c5&gt;&lt;s6&gt;StringProtocol&lt;/s6&gt;&lt;/c5&gt;&lt;/a4&gt;&lt;s7&gt; [https://developer.apple.com/documentation/swift/stringprotocol]&lt;/s7&gt; protocol, which means it’s often convenient for string-manipulation functions to accept a &lt;c8&gt;&lt;s9&gt;StringProtocol&lt;/s9&gt;&lt;/c8&gt; value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;Substring&lt;/s3&gt;&lt;/c2&gt;の両方とも&lt;a4&gt;&lt;c5&gt;&lt;s6&gt;StringProtocol&lt;/s6&gt;&lt;/c5&gt;&lt;/a4&gt;&lt;s7&gt; [https://developer.apple.com/documentation/swift/stringprotocol]&lt;/s7&gt;プロトコルに準拠します、それは&lt;c8&gt;&lt;s9&gt;StringProtocol&lt;/s9&gt;&lt;/c8&gt;値を受け取ることは文字列操作関数それぞれにとってしばしば都合が良いのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both &lt;c12&gt;&lt;s13&gt;C1&lt;/s13&gt;&lt;/c12&gt; and &lt;c14&gt;&lt;s15&gt;C2&lt;/s15&gt;&lt;/c14&gt; are type parameters for two container types to be determined when the function is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c12&gt;&lt;s13&gt;C1&lt;/s13&gt;&lt;/c12&gt;と&lt;c14&gt;&lt;s15&gt;C2&lt;/s15&gt;&lt;/c14&gt;の両方は、２つのコンテナ型のための型パラメータで、関数が呼ばれるときに決定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both &lt;c4&gt;&lt;s5&gt;playerInformation.health&lt;/s5&gt;&lt;/c4&gt; and &lt;c6&gt;&lt;s7&gt;playerInformation.energy&lt;/s7&gt;&lt;/c6&gt; are passed as in-out parameters, which means &lt;c8&gt;&lt;s9&gt;balance(_:_:)&lt;/s9&gt;&lt;/c8&gt; needs write access to them for the duration of the function call.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;playerInformation.health&lt;/s5&gt;&lt;/c4&gt;と&lt;c6&gt;&lt;s7&gt;playerInformation.energy&lt;/s7&gt;&lt;/c6&gt;の両方ともin-outパラメータとして渡されます、それは&lt;c8&gt;&lt;s9&gt;balance(_:_:)&lt;/s9&gt;&lt;/c8&gt;がそれらへの書き込みアクセスを関数呼び出しの期間中に必要とすることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both an empty tuple expression and an empty tuple type are written &lt;c0&gt;&lt;s1&gt;()&lt;/s1&gt;&lt;/c0&gt; in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>空のタプル式と空のタプル型は両方とも、&lt;c0&gt;&lt;s1&gt;()&lt;/s1&gt;&lt;/c0&gt;とスウィフトでは書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both can:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方とも以下のことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both classes correctly conform to the &lt;c10&gt;&lt;s11&gt;HasArea&lt;/s11&gt;&lt;/c10&gt; protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方のクラスは、正しく&lt;c10&gt;&lt;s11&gt;HasArea&lt;/s11&gt;&lt;/c10&gt;プロトコルに従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both constants can now be used independently:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方の定数は、今や独立して使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both designated initializers must call the single designated initializer from the superclass, to satisfy rule 1 from above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上記の規則１を満たすために、両方の指定イニシャライザは、スーパークラスからその１つだけある指定イニシャライザを呼ばなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both functions are generic because the types they rely on are generic, and the type parameters to the function pass along the type information needed by &lt;c10&gt;&lt;s11&gt;FlippedShape&lt;/s11&gt;&lt;/c10&gt; and &lt;c12&gt;&lt;s13&gt;JoinedShape&lt;/s13&gt;&lt;/c12&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方の関数は総称体です、なぜならそれらが頼りにする型が総称体であるからです、そして関数への型パラメータは、&lt;c10&gt;&lt;s11&gt;FlippedShape&lt;/s11&gt;&lt;/c10&gt;と&lt;c12&gt;&lt;s13&gt;JoinedShape&lt;/s13&gt;&lt;/c12&gt;によって必要とされる型情報を伝達します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both functions have a type of &lt;c8&gt;&lt;s9&gt;(Int)&lt;/s9&gt; &lt;s10&gt;-&gt;&lt;/s10&gt; &lt;s11&gt;Int&lt;/s11&gt;&lt;/c8&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方の関数は、&lt;c8&gt;&lt;s9&gt;(Int)&lt;/s9&gt; &lt;s10&gt;-&gt;&lt;/s10&gt; &lt;s11&gt;Int&lt;/s11&gt;&lt;/c8&gt;の型を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both initializers can be used to create a new &lt;c0&gt;&lt;s1&gt;Color&lt;/s1&gt;&lt;/c0&gt; instance, by providing named values for each initializer parameter:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方のイニシャライザとも、新しい&lt;c0&gt;&lt;s1&gt;Color&lt;/s1&gt;&lt;/c0&gt;インスタンスを作成するために、各イニシャライザ・パラメータに名前を付けられた値を提供することで、使用されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both initializers convert their single argument into the corresponding Celsius value and store this value in a property called &lt;c8&gt;&lt;s9&gt;temperatureInCelsius&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方のイニシャライザは、それらのただ１つの引数を相当する摂氏の値に変えて、その値を&lt;c8&gt;&lt;s9&gt;temperatureInCelsius&lt;/s9&gt;&lt;/c8&gt;と呼ばれるプロパティに保管します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both integers and floats can be padded with extra zeros and can contain underscores to help with readability.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数と浮動小数点は、余分のゼロを詰められることができ、読みやすくするためにアンダースコアを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both of these classes also define a deinitializer, which prints the fact that an instance of that class is being deinitialized.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのクラスの両方ともデイニシャライザを定義します、それは、そのクラスのインスタンスがデイニシャライズされているという事実を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both of these extended grapheme clusters are valid ways to represent the character &lt;c22&gt;&lt;s23&gt;é&lt;/s23&gt;&lt;/c22&gt;, and so they’re considered to be canonically equivalent:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの拡張書記素クラスタの両方とも、文字&lt;c22&gt;&lt;s23&gt;é&lt;/s23&gt;&lt;/c22&gt;を表わす有効な方法です、そういうわけでそれらは正準等価とみなされます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both of these representations qualify as a single &lt;c2&gt;&lt;s3&gt;Character&lt;/s3&gt;&lt;/c2&gt; value in Swift:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの表し方の双方とも、スウィフトでは単一の&lt;c2&gt;&lt;s3&gt;Character&lt;/s3&gt;&lt;/c2&gt;値としての基準を満たします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both of these variables have an initial value of &lt;c8&gt;&lt;s9&gt;nil&lt;/s9&gt;&lt;/c8&gt;, by virtue of being optional:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルである利点によって、これらの変数の両方とも、&lt;c8&gt;&lt;s9&gt;nil&lt;/s9&gt;&lt;/c8&gt;の初期値を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both patterns include a binding for &lt;c10&gt;&lt;s11&gt;distance&lt;/s11&gt;&lt;/c10&gt; and &lt;c12&gt;&lt;s13&gt;distance&lt;/s13&gt;&lt;/c12&gt; is an integer in both patterns—which means that the code in the body of the &lt;c14&gt;&lt;s15&gt;case&lt;/s15&gt;&lt;/c14&gt; can always access a value for &lt;c16&gt;&lt;s17&gt;distance&lt;/s17&gt;&lt;/c16&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方のパターンは、&lt;c10&gt;&lt;s11&gt;distance&lt;/s11&gt;&lt;/c10&gt;に対する束縛を含みます、そして&lt;c12&gt;&lt;s13&gt;distance&lt;/s13&gt;&lt;/c12&gt;は両方のパターンにおいて整数です—それは&lt;c14&gt;&lt;s15&gt;case&lt;/s15&gt;&lt;/c14&gt;の本文のコードは常に&lt;c16&gt;&lt;s17&gt;distance&lt;/s17&gt;&lt;/c16&gt;に対する値にアクセスできることを編みします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both place their entire definition within a pair of braces:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方とも、それらの全ての定義を一対の波括弧の範囲内に置きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both properties are inferred to be of type &lt;c6&gt;&lt;s7&gt;Double&lt;/s7&gt;&lt;/c6&gt; by assigning a default value of &lt;c8&gt;&lt;s9&gt;0.0&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方のプロパティは、省略時の値の&lt;c8&gt;&lt;s9&gt;0.0&lt;/s9&gt;&lt;/c8&gt;を代入することによって&lt;c6&gt;&lt;s7&gt;Double&lt;/s7&gt;&lt;/c6&gt;型であると推測されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both protocols are adopted by a structure called &lt;c12&gt;&lt;s13&gt;Person&lt;/s13&gt;&lt;/c12&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方のプロトコルは、&lt;c12&gt;&lt;s13&gt;Person&lt;/s13&gt;&lt;/c12&gt;と呼ばれる構造体によって採用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both the protocol and the optional requirement must be marked with the &lt;c3&gt;&lt;s4&gt;@objc&lt;/s4&gt;&lt;/c3&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルとオプショナル要件の両方は、&lt;c3&gt;&lt;s4&gt;@objc&lt;/s4&gt;&lt;/c3&gt;属性で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Braces around the body are required.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>本文のまわりの波括弧は必須です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Branch Statements</seg>
      </tuv>
      <tuv lang="JA">
        <seg>分岐文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Branch statements allow the program to execute certain parts of code depending on the value of one or more conditions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>分岐文は、プログラムが１つ以上の条件の値に従いコードの特定の部分を実行するようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Break Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ブレーク文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Break in a Loop Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ループ文の中断</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Break in a Switch Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>switch文の中断</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bridging lets you use an expression of a Swift standard library type such as &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; as its corresponding Foundation type such as &lt;c2&gt;&lt;s3&gt;NSString&lt;/s3&gt;&lt;/c2&gt; without needing to create a new instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ブリッジは、あなたに&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;のようなスウィフト標準ライブラリ型の式を、&lt;c2&gt;&lt;s3&gt;NSString&lt;/s3&gt;&lt;/c2&gt;のようなそれの対応しているFoundation型として使用させます、新しいインスタンスを作成する必要なしに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But if you provide a setter clause, you must also provide a getter clause.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしあなたがセッター節を提供するならば、あなた同様にゲッター節を提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By constraining a collection’s elements to the &lt;c4&gt;&lt;s5&gt;Equatable&lt;/s5&gt;&lt;/c4&gt; protocol, a part of the standard library, you can use the &lt;c6&gt;&lt;s7&gt;==&lt;/s7&gt;&lt;/c6&gt; and &lt;c8&gt;&lt;s9&gt;!=&lt;/s9&gt;&lt;/c8&gt; operators to check for equality and inequality between two elements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるコレクションの持つ要素を&lt;c4&gt;&lt;s5&gt;Equatable&lt;/s5&gt;&lt;/c4&gt;プロトコル、標準ライブラリの１つ、に制約することで、あなたは&lt;c6&gt;&lt;s7&gt;==&lt;/s7&gt;&lt;/c6&gt;と&lt;c8&gt;&lt;s9&gt;!=&lt;/s9&gt;&lt;/c8&gt;演算子を使って同等性と同一性を２つの要素間で確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By contrast, C requires you to insert an explicit &lt;c4&gt;&lt;s5&gt;break&lt;/s5&gt;&lt;/c4&gt; statement at the end of every &lt;c6&gt;&lt;s7&gt;switch&lt;/s7&gt;&lt;/c6&gt; case to prevent fallthrough.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対照的に、Cはあなたに抜け落ちること（フォールスルー）を防ぐために明示的に&lt;c4&gt;&lt;s5&gt;break&lt;/s5&gt;&lt;/c4&gt;文をあらゆる&lt;c6&gt;&lt;s7&gt;switch&lt;/s7&gt;&lt;/c6&gt;ケース節の終わりに書き入れることを要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By creating an extension on the protocol, all conforming types automatically gain this method implementation without any additional modification.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張をプロトコル上に作成することによって、すべての準拠している型が自動的にこのメソッド実装をなんら追加の修正なしに手に入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Swift assigns the raw values starting at zero and incrementing by one each time, but you can change this behavior by explicitly specifying values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期状態で、スウィフトはゼロで開始して毎回１つ増加させながら生の値を割り当てます、しかしあなたは明示的にそれらの値を指定することでこの挙動を変更できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Swift prevents unsafe behavior from happening in your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期状態では、スウィフトはあなたのコードにおける偶発事由来の安全でない挙動を防止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, a closure expression captures constants and variables from its surrounding scope with strong references to those values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期状態では、クロージャ式は、それの囲んでいるスコープから定数や変数をそれらの値への強い参照を使ってキャプチャします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, any new &lt;c0&gt;&lt;s1&gt;Bicycle&lt;/s1&gt;&lt;/c0&gt; instance you create will not have a basket.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に何もしなければ、あなたが作成するあらゆる新しい&lt;c0&gt;&lt;s1&gt;Bicycle&lt;/s1&gt;&lt;/c0&gt;インスタンスは、入れ物かごを持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, custom classes and structures don’t have an implementation of the &lt;e0&gt;equivalence operators&lt;/e0&gt;, known as the &lt;e1&gt;equal to&lt;/e1&gt; operator (&lt;c2&gt;&lt;s3&gt;==&lt;/s3&gt;&lt;/c2&gt;) and &lt;e4&gt;not equal to&lt;/e4&gt; operator (&lt;c5&gt;&lt;s6&gt;!=&lt;/s6&gt;&lt;/c5&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期状態では、あつらえのクラスと構造体は、&lt;e1&gt;「同等」&lt;/e1&gt;演算子（&lt;c2&gt;&lt;s3&gt;==&lt;/s3&gt;&lt;/c2&gt;）そして&lt;e4&gt;「不等」&lt;/e4&gt;演算子（&lt;c5&gt;&lt;s6&gt;!=&lt;/s6&gt;&lt;/c5&gt;）として知られる、&lt;e0&gt;等価演算子&lt;/e0&gt;の実装を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, floating-point literals are expressed in decimal (with no prefix), but they can also be expressed in hexadecimal (with a &lt;c0&gt;&lt;s1&gt;0x&lt;/s1&gt;&lt;/c0&gt; prefix).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期状態で、浮動小数点リテラルは10進において（接頭辞なしで）表されます、しかしそれらはまた、16進法において（&lt;c0&gt;&lt;s1&gt;0x&lt;/s1&gt;&lt;/c0&gt;接頭辞で）表されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, functions use their parameter names as labels for their arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に何もしなくとも、関数はそれらのパラメータ名をそれらの引数のラベルとして使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, initializers declared in a superclass are not inherited by subclasses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期状態では、スーパークラスで宣言されるイニシャライザは、サブクラスによって継承されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, integer literals are expressed in decimal; you can specify an alternate base using a prefix.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期状態では、整数リテラルは10進法で表されます；あなたは、接頭辞を使用して代替の基数を指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, most declarations are implicitly marked with the &lt;c0&gt;&lt;s1&gt;internal&lt;/s1&gt;&lt;/c0&gt; access-level modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時では、大部分の宣言は暗黙的に&lt;c0&gt;&lt;s1&gt;internal&lt;/s1&gt;&lt;/c0&gt;アクセス水準修飾子で印されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, only entities marked as open or public are accessible to other modules.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に何もしない状態では、開放または公開と印される実在だけが他のモジュールに利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, parameter names are also used as argument labels.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に何もしなければ、パラメータ名はまた引数ラベルとしても使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, parameters use their parameter name as their argument label.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に何もしなければ、パラメータはそれらのパラメータ名をそれらの引数ラベルとして使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, the &lt;c0&gt;&lt;s1&gt;asHTML&lt;/s1&gt;&lt;/c0&gt; property is assigned a closure that returns a string representation of an HTML tag.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に何もしなければ、&lt;c0&gt;&lt;s1&gt;asHTML&lt;/s1&gt;&lt;/c0&gt;プロパティは、あるHTMLタグの文字列表現を返すクロージャを代入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, the &lt;c6&gt;&lt;s7&gt;~=&lt;/s7&gt;&lt;/c6&gt; operator compares two values of the same type using the &lt;c8&gt;&lt;s9&gt;==&lt;/s9&gt;&lt;/c8&gt; operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期状態で、&lt;c6&gt;&lt;s7&gt;~=&lt;/s7&gt;&lt;/c6&gt;演算子は、同じ型の２つの値を&lt;c8&gt;&lt;s9&gt;==&lt;/s9&gt;&lt;/c8&gt;演算子を使用して比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, the function terminates the line it prints by adding a line break.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期状態では、この関数はそれが出力する行を改行を加えて終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, the parameters used in subscripting don’t have argument labels, unlike functions, methods, and initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期状態で、添字において使用されるパラメータは引数ラベルを持ちません、関数、メソッド、およびイニシャライザとは違って。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, the properties of a value type cannot be modified from within its instance methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期状態では、ある値型に属するプロパティは、それのインスタンスメソッド内から修正されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, types that conform to a protocol must implement all properties, methods, and subscripts declared in the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期状態では、あるプロトコルに準拠する型は、そのプロトコルにおいて宣言される全てのプロパティ、メソッド、そして添え字を実装しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, variables, constants, and other named declarations that are declared at the top-level of a source file are accessible to code in every source file that is part of the same module.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期状態では、あるソースファイルのトップレベルで宣言される変数、定数、そして他の名前をつけられる宣言は、同じモジュールの一部であるすべてのソースファイルの中のコードにアクセス可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By including arguments to the property wrapper, you can set up the initial state in the wrapper or pass other options to the wrapper when it’s created.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>引数をプロパティラッパーに含めることによって、あなたは初期状態をラッパーにおいて準備することまたは他のオプションをラッパーに渡すことが、それが作成される時に可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By making &lt;c4&gt;&lt;s5&gt;if&lt;/s5&gt; &lt;s6&gt;x&lt;/s6&gt; &lt;s7&gt;=&lt;/s7&gt; &lt;s8&gt;y&lt;/s8&gt;&lt;/c4&gt; invalid, Swift helps you to avoid these kinds of errors in your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;if&lt;/s5&gt; &lt;s6&gt;x&lt;/s6&gt; &lt;s7&gt;=&lt;/s7&gt; &lt;s8&gt;y&lt;/s8&gt;&lt;/c4&gt;を無効にすることによって、スウィフトはあなたがこれらの種類のエラーをあなたのコードにおいて避けるのを手伝います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By returning a tuple with two distinct values, each of a different type, the function provides more useful information about its outcome than if it could only return a single value of a single type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つの別の値をそれぞれ異なる型で持つひとつのタプルを返すことによって、その関数は、それが１つの型の１つの値を返すことができるだけよりも、その結果に関するより役に立つ情報を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By their nature, two instantaneous accesses can’t happen at the same time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>本質的に、２つの即時アクセスは同時に起こりえません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By wrapping the function call in a &lt;c6&gt;&lt;s7&gt;do&lt;/s7&gt;&lt;/c6&gt; statement, any errors that are thrown will be propagated to the provided &lt;c8&gt;&lt;s9&gt;catch&lt;/s9&gt;&lt;/c8&gt; clauses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その関数呼び出しを&lt;c6&gt;&lt;s7&gt;do&lt;/s7&gt;&lt;/c6&gt;文の中に包み込むことによって、スローされるどんなエラーも添付の&lt;c8&gt;&lt;s9&gt;catch&lt;/s9&gt;&lt;/c8&gt;節に伝えられるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Call a function by following its name with a list of arguments in parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数は、その名前の後に丸括弧に入れた引数の目録（リスト）を続けることで呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Call one of the initializers declared within the class, as described in &lt;a0&gt;&lt;s1&gt;Initializers&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのクラス内で宣言されるイニシャライザのうちの１つを呼び出す、&lt;a0&gt;&lt;s1&gt;イニシャライザ&lt;/s1&gt;&lt;/a0&gt;で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Call one of the initializers declared within the structure, as described in &lt;a0&gt;&lt;s1&gt;Initializers&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その構造体の内部で宣言されるイニシャライザの内の１つを呼び出す、&lt;a0&gt;&lt;s1&gt;イニシャライザ&lt;/s1&gt;&lt;/a0&gt;で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling Methods Through Optional Chaining</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖を通してメソッドを呼ぶ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling it with &lt;c2&gt;&lt;s3&gt;playerOneScore&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;playerTwoScore&lt;/s5&gt;&lt;/c4&gt; as arguments doesn’t produce a conflict—there are two write accesses that overlap in time, but they access different locations in memory.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それを&lt;c2&gt;&lt;s3&gt;playerOneScore&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;playerTwoScore&lt;/s5&gt;&lt;/c4&gt;を引数として使って呼び出すことは衝突を生み出しません — 時間内にオーバーラップする２つの書き込みアクセスがあります、しかしそれらはメモリ中の異なる位置にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling the function multiple times shows this behavior in action:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数を複数回呼ぶことは、活動中にこの挙動を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling the original incrementer (&lt;c0&gt;&lt;s1&gt;incrementByTen&lt;/s1&gt;&lt;/c0&gt;) again continues to increment its own &lt;c2&gt;&lt;s3&gt;runningTotal&lt;/s3&gt;&lt;/c2&gt; variable, and does not affect the variable captured by &lt;c4&gt;&lt;s5&gt;incrementBySeven&lt;/s5&gt;&lt;/c4&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初のインクリメンタ（&lt;c0&gt;&lt;s1&gt;incrementByTen&lt;/s1&gt;&lt;/c0&gt;）を再び呼ぶことは、それ独自の&lt;c2&gt;&lt;s3&gt;runningTotal&lt;/s3&gt;&lt;/c2&gt;変数を増加させることを継続します、そして&lt;c4&gt;&lt;s5&gt;incrementBySeven&lt;/s5&gt;&lt;/c4&gt;によってキャプチャされる変数に影響しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling the superclass’s initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラスのイニシャライザを呼ぶ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling this initializer returns a &lt;c6&gt;&lt;s7&gt;Rect&lt;/s7&gt;&lt;/c6&gt; instance whose &lt;c8&gt;&lt;s9&gt;origin&lt;/s9&gt;&lt;/c8&gt; and &lt;c10&gt;&lt;s11&gt;size&lt;/s11&gt;&lt;/c10&gt; properties are both initialized with the default values of &lt;c12&gt;&lt;s13&gt;Point(x:&lt;/s13&gt; &lt;s14&gt;0.0,&lt;/s14&gt; &lt;s15&gt;y:&lt;/s15&gt; &lt;s16&gt;0.0)&lt;/s16&gt;&lt;/c12&gt; and &lt;c17&gt;&lt;s18&gt;Size(width:&lt;/s18&gt; &lt;s19&gt;0.0,&lt;/s19&gt; &lt;s20&gt;height:&lt;/s20&gt; &lt;s21&gt;0.0)&lt;/s21&gt;&lt;/c17&gt; from their property definitions:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このイニシャライザを呼ぶことは&lt;c6&gt;&lt;s7&gt;Rect&lt;/s7&gt;&lt;/c6&gt;インスタンスを返します、それは、&lt;c8&gt;&lt;s9&gt;origin&lt;/s9&gt;&lt;/c8&gt;と&lt;c10&gt;&lt;s11&gt;size&lt;/s11&gt;&lt;/c10&gt;プロパティが両方ともそれらのプロパティ定義からの省略時の値の&lt;c12&gt;&lt;s13&gt;Point(x:&lt;/s13&gt; &lt;s14&gt;0.0,&lt;/s14&gt; &lt;s15&gt;y:&lt;/s15&gt; &lt;s16&gt;0.0)&lt;/s16&gt;&lt;/c12&gt;と&lt;c17&gt;&lt;s18&gt;Size(width:&lt;/s18&gt; &lt;s19&gt;0.0,&lt;/s19&gt; &lt;s20&gt;height:&lt;/s20&gt; &lt;s21&gt;0.0)&lt;/s21&gt;&lt;/c17&gt;で初期化されるものです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calls to a throwing function or method must be wrapped in a &lt;c0&gt;&lt;s1&gt;try&lt;/s1&gt;&lt;/c0&gt; or &lt;c2&gt;&lt;s3&gt;try!&lt;/s3&gt;&lt;/c2&gt; expression (that is, in the scope of a &lt;c4&gt;&lt;s5&gt;try&lt;/s5&gt;&lt;/c4&gt; or &lt;c6&gt;&lt;s7&gt;try!&lt;/s7&gt;&lt;/c6&gt; operator).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スロー関数またはメソッドに対する呼び出しは、&lt;c0&gt;&lt;s1&gt;try&lt;/s1&gt;&lt;/c0&gt;または&lt;c2&gt;&lt;s3&gt;try!&lt;/s3&gt;&lt;/c2&gt;式の中に（即ち、&lt;c4&gt;&lt;s5&gt;try&lt;/s5&gt;&lt;/c4&gt;または&lt;c6&gt;&lt;s7&gt;try!&lt;/s7&gt;&lt;/c6&gt;演算子のスコープの中に）包まれなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Capture Lists</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キャプチャリスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Capturing Values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値を捕獲する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Capturing by reference ensures that &lt;c11&gt;&lt;s12&gt;runningTotal&lt;/s12&gt;&lt;/c11&gt; and &lt;c13&gt;&lt;s14&gt;amount&lt;/s14&gt;&lt;/c13&gt; do not disappear when the call to &lt;c15&gt;&lt;s16&gt;makeIncrementer&lt;/s16&gt;&lt;/c15&gt; ends, and also ensures that &lt;c17&gt;&lt;s18&gt;runningTotal&lt;/s18&gt;&lt;/c17&gt; is available the next time the &lt;c19&gt;&lt;s20&gt;incrementer&lt;/s20&gt;&lt;/c19&gt; function is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>参照を捕獲することは、&lt;c15&gt;&lt;s16&gt;makeIncrementer&lt;/s16&gt;&lt;/c15&gt;への呼び出しが終わる時に&lt;c11&gt;&lt;s12&gt;runningTotal&lt;/s12&gt;&lt;/c11&gt;と&lt;c13&gt;&lt;s14&gt;amount&lt;/s14&gt;&lt;/c13&gt;が消えてなくならないことを確かにします、そしてまた&lt;c19&gt;&lt;s20&gt;incrementer&lt;/s20&gt;&lt;/c19&gt;関数が呼ばれる次の時に&lt;c17&gt;&lt;s18&gt;runningTotal&lt;/s18&gt;&lt;/c17&gt;が利用可能であることを確実にもします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Carriage return (&lt;c0&gt;&lt;s1&gt;\r&lt;/s1&gt;&lt;/c0&gt;)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キャリッジリターン「復帰文字」（&lt;c0&gt;&lt;s1&gt;\r&lt;/s1&gt;&lt;/c0&gt;）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cases can match many different patterns, including interval matches, tuples, and casts to a specific type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらのケース節は、区間マッチ、タプル、そして特定の型への型キャストを含む、多くの異なるパターンにマッチすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Casting does not actually modify the instance or change its values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キャストは、実際にインスタンスを修正したり、その値を変えたりしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chaining on Methods with Optional Return Values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルの戻り値をもつメソッド上で連鎖する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Change &lt;c0&gt;&lt;s1&gt;optionalName&lt;/s1&gt;&lt;/c0&gt; to &lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;optionalName&lt;/s1&gt;&lt;/c0&gt;を&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;に変えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Change the printer name to &lt;c0&gt;&lt;s1&gt;"Never&lt;/s1&gt; &lt;s2&gt;Has&lt;/s2&gt; &lt;s3&gt;Toner"&lt;/s3&gt;&lt;/c0&gt;, so that the &lt;c4&gt;&lt;s5&gt;send(job:toPrinter:)&lt;/s5&gt;&lt;/c4&gt; function throws an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プリンタ名を&lt;c0&gt;&lt;s1&gt;"Never&lt;/s1&gt; &lt;s2&gt;Has&lt;/s2&gt; &lt;s3&gt;Toner"&lt;/s3&gt;&lt;/c0&gt;に変更してください、そうすると&lt;c4&gt;&lt;s5&gt;send(job:toPrinter:)&lt;/s5&gt;&lt;/c4&gt;関数はエラーをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changing the value of &lt;c4&gt;&lt;s5&gt;currentDirection&lt;/s5&gt;&lt;/c4&gt; thereafter doesn’t affect the copy of the original value that was stored in &lt;c6&gt;&lt;s7&gt;rememberedDirection&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それ以降に&lt;c4&gt;&lt;s5&gt;currentDirection&lt;/s5&gt;&lt;/c4&gt;の値を変えることは、本来の値のコピーに、&lt;c6&gt;&lt;s7&gt;rememberedDirection&lt;/s7&gt;&lt;/c6&gt;に格納されたものに影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changing the value of properties defined by the superclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラスによって定義されるプロパティの値を変える。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Characteristics of Memory Access</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メモリアクセスの特徴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checking API Availability</seg>
      </tuv>
      <tuv lang="JA">
        <seg>API有効性の確認</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checking Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型を調べる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checking for Protocol Conformance</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル準拠の確認</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checking for an empty string value (such as &lt;c0&gt;&lt;s1&gt;""&lt;/s1&gt;&lt;/c0&gt; rather than &lt;c2&gt;&lt;s3&gt;"Giraffe"&lt;/s3&gt;&lt;/c2&gt;) is not the same as checking for &lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt; to indicate the absence of an &lt;e6&gt;optional&lt;/e6&gt; &lt;c7&gt;&lt;s8&gt;String&lt;/s8&gt;&lt;/c7&gt; value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>空の文字列値（例えば&lt;c2&gt;&lt;s3&gt;"Giraffe"&lt;/s3&gt;&lt;/c2&gt;といったものでなく&lt;c0&gt;&lt;s1&gt;""&lt;/s1&gt;&lt;/c0&gt;）について調べることは、&lt;e6&gt;オプショナル&lt;/e6&gt;の&lt;c7&gt;&lt;s8&gt;String&lt;/s8&gt;&lt;/c7&gt;値の不在を指し示す&lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;について調べることと同じではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checking for and casting to a protocol follows exactly the same syntax as checking for and casting to a type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロトコルについて調べたりそれにキャストすることは、ある型について調べたりキャストするのと正確に同じ構文に従います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checking the &lt;c0&gt;&lt;s1&gt;frameRate&lt;/s1&gt;&lt;/c0&gt; property of &lt;c2&gt;&lt;s3&gt;tenEighty&lt;/s3&gt;&lt;/c2&gt; shows that it correctly reports the new frame rate of &lt;c4&gt;&lt;s5&gt;30.0&lt;/s5&gt;&lt;/c4&gt; from the underlying &lt;c6&gt;&lt;s7&gt;VideoMode&lt;/s7&gt;&lt;/c6&gt; instance:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;tenEighty&lt;/s3&gt;&lt;/c2&gt;の&lt;c0&gt;&lt;s1&gt;frameRate&lt;/s1&gt;&lt;/c0&gt;プロパティを調べてみると、それが根底にある&lt;c6&gt;&lt;s7&gt;VideoMode&lt;/s7&gt;&lt;/c6&gt;インスタンス由来の新しいフレームレートの&lt;c4&gt;&lt;s5&gt;30.0&lt;/s5&gt;&lt;/c4&gt;を正しく報告することがわかります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Checking the &lt;c0&gt;&lt;s1&gt;width&lt;/s1&gt;&lt;/c0&gt; property of &lt;c2&gt;&lt;s3&gt;cinema&lt;/s3&gt;&lt;/c2&gt; shows that it has indeed changed to be &lt;c4&gt;&lt;s5&gt;2048&lt;/s5&gt;&lt;/c4&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;cinema&lt;/s3&gt;&lt;/c2&gt;の&lt;c0&gt;&lt;s1&gt;width&lt;/s1&gt;&lt;/c0&gt;プロパティをチェックすると、&lt;c4&gt;&lt;s5&gt;2048&lt;/s5&gt;&lt;/c4&gt;になるように変えられたことを示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Chess is played on an 8 x 8 board, with alternating black and white squares.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>チェスは、黒と白の正方形を互い違いに持つ、８×８マスの盤上で行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Clarified the full list of characters that can be used when defining &lt;a0&gt;&lt;s1&gt;Custom Operators&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;あつらえの演算子&lt;/s1&gt;&lt;/a0&gt;を定義するとき使われることが出来る文字の完全なリストをわかりやすくしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class &lt;c4&gt;&lt;s5&gt;B&lt;/s5&gt;&lt;/c4&gt; is a subclass of &lt;c6&gt;&lt;s7&gt;A&lt;/s7&gt;&lt;/c6&gt;, with a reduced access level of “internal”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス&lt;c4&gt;&lt;s5&gt;B&lt;/s5&gt;&lt;/c4&gt;は&lt;c6&gt;&lt;s7&gt;A&lt;/s7&gt;&lt;/c6&gt;のサブクラスです、そして減少させられたアクセス水準の「内部」を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class Implementations of Protocol Initializer Requirements</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザ要件プロトコルのクラス実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class Inheritance and Initialization</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス継承と初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class and structure initialization is described in more detail in &lt;a4&gt;&lt;s5&gt;Initialization&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスと構造体の初期化は、更に詳細に&lt;a4&gt;&lt;s5&gt;初期化&lt;/s5&gt;&lt;/a4&gt;で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class declarations are declared using the &lt;c1&gt;&lt;s2&gt;class&lt;/s2&gt;&lt;/c1&gt; keyword and have the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス宣言は、キーワード&lt;c1&gt;&lt;s2&gt;class&lt;/s2&gt;&lt;/c1&gt;を使用して宣言されて、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class declarations can’t contain protocol declarations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス宣言は、プロトコル宣言を含むことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class definitions can have at most one deinitializer per class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス定義は、クラスごとに多くとも１つのデイニシャライザしか持つことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class initialization in Swift is a two-phase process.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでのクラス初期化は、２段階処理です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class types can inherit from a single superclass and conform to any number of protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス型は、１つのスーパークラスから継承することができ、任意の数のプロトコルに準拠することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class-Only Protocols</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス専用プロトコル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes Are Reference Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスは、参照型です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes and class members that are marked with the &lt;c6&gt;&lt;s7&gt;internal&lt;/s7&gt;&lt;/c6&gt; or &lt;c8&gt;&lt;s9&gt;public&lt;/s9&gt;&lt;/c8&gt; access-level modifier are imported as if they were declared with the &lt;c10&gt;&lt;s11&gt;open&lt;/s11&gt;&lt;/c10&gt; access-level modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;internal&lt;/s7&gt;&lt;/c6&gt;または&lt;c8&gt;&lt;s9&gt;public&lt;/s9&gt;&lt;/c8&gt;アクセス水準修飾子で印されるクラスまたはクラスメンバは、まるでそれらが&lt;c10&gt;&lt;s11&gt;open&lt;/s11&gt;&lt;/c10&gt;アクセス水準修飾子で宣言されたかのようにインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes and structures &lt;e0&gt;must&lt;/e0&gt; set all of their stored properties to an appropriate initial value by the time an instance of that class or structure is created.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスと構造体は、それらの格納プロパティの全てを、そのクラスや構造体のインスタンスがつくられる時には適切な初期値に設定する&lt;e0&gt;必要があります&lt;/e0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes and structures can also provide implementations of the standard &lt;e0&gt;unary operators&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスと構造体は、また、標準の&lt;e0&gt;単項演算子&lt;/e0&gt;の実施も提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes and structures can provide their own implementations of existing operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスと構造体は、既存の演算子のそれら独自の実装を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes are reference types; instances of a class are referred to, rather than copied, when assigned to variables or constants, or when passed as arguments to a function call.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスは、参照型です；クラスのインスタンスは、変数または定数に代入されるとき、または関数呼び出しに対する引数として渡されるときに、コピーされるのではなく、参照されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes can also add property observers to inherited properties in order to be notified when the value of a property changes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスはまた、プロパティの値が変化するとき通知されるように継承されたプロパティにプロパティオブザーバー（監視者）を加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes can mark type computed properties with the &lt;c2&gt;&lt;s3&gt;class&lt;/s3&gt;&lt;/c2&gt; declaration modifier instead to allow subclasses to override the superclass’s implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスは、型計算プロパティを代わりに&lt;c2&gt;&lt;s3&gt;class&lt;/s3&gt;&lt;/c2&gt;宣言修飾子で印をつけて、サブクラスがスーパークラスの実装をオーバーライドすることを許可することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes can use the &lt;c5&gt;&lt;s6&gt;class&lt;/s6&gt;&lt;/c5&gt; keyword instead, to allow subclasses to override the superclass’s implementation of that method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスは代わりに&lt;c5&gt;&lt;s6&gt;class&lt;/s6&gt;&lt;/c5&gt;キーワードを使って、サブクラスにスーパークラスのもつそのメソッドの実装をオーバーライドすることを許可できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes can use the &lt;c5&gt;&lt;s6&gt;class&lt;/s6&gt;&lt;/c5&gt; keyword instead, to allow subclasses to override the superclass’s implementation of that subscript.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスは、&lt;c5&gt;&lt;s6&gt;class&lt;/s6&gt;&lt;/c5&gt;キーワードを代わりに使用して、サブクラスにスーパークラスのもつその添え字の実装のオーバーライドを許可できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes can’t use an opaque type as the return type of a nonfinal method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスは、不透明型を非最終メソッドの戻り型として使用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes do not have a default memberwise initializer, and so the &lt;c0&gt;&lt;s1&gt;Food&lt;/s1&gt;&lt;/c0&gt; class provides a designated initializer that takes a single argument called &lt;c2&gt;&lt;s3&gt;name&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのクラスには省略時のメンバー関連イニシャライザがありません、なので、&lt;c0&gt;&lt;s1&gt;Food&lt;/s1&gt;&lt;/c0&gt;クラスは&lt;c2&gt;&lt;s3&gt;name&lt;/s3&gt;&lt;/c2&gt;と呼ばれる１つの引数をとる指定イニシャライザを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes have additional capabilities that structures don’t have:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスは以下の追加の能力を持ちます、それは構造体が持たないものです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes in Swift can call and access methods, properties, and subscripts belonging to their superclass and can provide their own overriding versions of those methods, properties, and subscripts to refine or modify their behavior.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのクラスは、それらのスーパークラスに属しているメソッド、プロパティ、そして添え字の呼び出しやアクセスが行えて、それらのメソッド、プロパティ、そして添え字の独自の優先的に使われる改変板を提供することでそれらの挙動の洗練や修正を行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes tend to have very few designated initializers, and it is quite common for a class to have only one.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスはほとんど指定イニシャライザを持たない傾向があります、そして、あるクラスが１つだけしか持たないことは全く普通です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes you define without specifying a superclass automatically become base classes for you to build upon.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラスを指定することなくあなたが定義するクラスは、自動的に基盤クラスになり、あなたが基礎とするために使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes, enumerations, and structs can all adopt protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス、列挙、そして構造体は、全てそのようなプロトコルを採用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes, however, can inherit from other classes, as described in &lt;a0&gt;&lt;s1&gt;Inheritance&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスはしかし、&lt;a0&gt;&lt;s1&gt;継承&lt;/s1&gt;&lt;/a0&gt;で記述されるように、他のクラスから継承することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes, structures, and enumerations can all define instance methods, which encapsulate specific tasks and functionality for working with an instance of a given type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれのクラス、構造体、および列挙は、すべてインスタンスメソッドを定義することができます、それは、ある定められた型のあるインスタンスで働くために特定の作業や機能性をカプセル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes, structures, and enumerations can also define type methods, which are associated with the type itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス、構造体、および列挙は、また、型メソッドを定義することができます、それは型それ自身に結び付けられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Classes, structures, and enumerations can define &lt;e0&gt;subscripts&lt;/e0&gt;, which are shortcuts for accessing the member elements of a collection, list, or sequence.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス、構造体、および列挙は、&lt;e0&gt;添え字&lt;/e0&gt;を定義することができます、それは、コレクション、リスト、またはシーケンスのメンバー要素にアクセスするための近道です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closed Range Operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>完結範囲演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closed ranges are also available, by using &lt;c0&gt;&lt;s1&gt;stride(from:through:by:)&lt;/s1&gt;&lt;/c0&gt; instead:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>完結範囲も利用可能です、代わりに&lt;c0&gt;&lt;s1&gt;stride(from:through:by:)&lt;/s1&gt;&lt;/c0&gt;を使うことで：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closure Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャ式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closure Expression Syntax</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャ式構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closure Expressions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャ式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closure expression syntax has the following general form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャ式構文は、以下の一般的な形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closure expressions are unnamed closures written in a lightweight syntax that can capture values from their surrounding context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャ式は、それの周囲の前後関係から値を捕獲することができる軽快な構文で書かれる無名のクロージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closure expressions can be used without being stored in a variable or constant, such as when you immediately use a closure as part of a function call.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャ式は、変数や定数の中に格納されることなく利用できます、例えばあなたが直接にクロージャを関数呼び出しの一部として使う場合など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closure expressions provide several syntax optimizations for writing closures in a shortened form without loss of clarity or intent.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャ式は、いくつかの構文最適化を、ある省略形式で明快さや意図の損失なしでクロージャを書くために提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closures</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closures Are Reference Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャは参照型です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closures can capture and store references to any constants and variables from the context in which they are defined.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャは、それが定義されている前後関係からのあらゆる定数や変数への参照を捕獲して、格納することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closures in Swift are similar to blocks in C and Objective-C and to lambdas in other programming languages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおけるクロージャは、CとObjective-Cでのブロックに、そして他のプログラミング言語でのラムダ（lambda）に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closures take one of three forms:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャは、３つの書式のうちの１つをとります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Code Blocks</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コード・ブロック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Code that interacts with an opaque value can use the value only in ways that are part of the interface defined by the &lt;e3&gt;constraint&lt;/e3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>不透明型と相互作用するコードは、&lt;e3&gt;constraint&lt;/e3&gt;によって定義されるインターフェイスの一部であるやり方それらにおいてのみ値を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Code that uses this property wrapper, can’t specify a different initial value for a property that’s wrapped by &lt;c4&gt;&lt;s5&gt;TwelveOrLess&lt;/s5&gt;&lt;/c4&gt;—for example, the definition of &lt;c6&gt;&lt;s7&gt;SmallRectangle&lt;/s7&gt;&lt;/c6&gt; can’t give &lt;c8&gt;&lt;s9&gt;height&lt;/s9&gt;&lt;/c8&gt; or &lt;c10&gt;&lt;s11&gt;width&lt;/s11&gt;&lt;/c10&gt; initial values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロパティラッパーを使うコードは、&lt;c4&gt;&lt;s5&gt;TwelveOrLess&lt;/s5&gt;&lt;/c4&gt;によってラップされるプロパティに対して異なる初期値を指定できません — 例えば、&lt;c6&gt;&lt;s7&gt;SmallRectangle&lt;/s7&gt;&lt;/c6&gt;に対する定義は&lt;c8&gt;&lt;s9&gt;height&lt;/s9&gt;&lt;/c8&gt;や&lt;c10&gt;&lt;s11&gt;width&lt;/s11&gt;&lt;/c10&gt;に初期値を与えることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Code that’s compiled in library evolution mode, code in the standard library, Swift overlays for Apple frameworks, and C and Objective-C code can declare nonfrozen enumerations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ライブラリ進化モードでコンパイルされるコード、標準ライブラリでのコード、Appleフレームワークに対するスウィフトオーバーレイ、そしてCとObjective-Cコードは、非凍結列挙を宣言できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Code that’s written anywhere else accesses the value using the getter and setter for &lt;c8&gt;&lt;s9&gt;wrappedValue&lt;/s9&gt;&lt;/c8&gt;, and can’t use &lt;c10&gt;&lt;s11&gt;number&lt;/s11&gt;&lt;/c10&gt; directly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どこか他で書かれるコードは、&lt;c8&gt;&lt;s9&gt;wrappedValue&lt;/s9&gt;&lt;/c8&gt;に対するゲッターとセッターを使って値にアクセスします、そして&lt;c10&gt;&lt;s11&gt;number&lt;/s11&gt;&lt;/c10&gt;を直接に使用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Code written at global scope is used as the entry point for the program, so you don’t need a &lt;c0&gt;&lt;s1&gt;main()&lt;/s1&gt;&lt;/c0&gt; function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>グローバルなスコープで書かれるコードは、プログラムのエントリポイントとして使われるので、あなたは&lt;c0&gt;&lt;s1&gt;main()&lt;/s1&gt;&lt;/c0&gt;関数を必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Collection Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コレクション型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Collections defined by the standard library like arrays, dictionaries, and strings use an optimization to reduce the performance cost of copying.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列、辞書、そして文字列のような、標準ライブラリによって定義されるコレクションは、ある最適化を使うことでコピーすることによる性能損失を減らします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Collections of Protocol Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル型のコレクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Combining Logical Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>論理演算子を結合する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comments</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comments are ignored by the Swift compiler when your code is compiled.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのコードがコンパイルされるとき、コメントはスウィフトのコンパイラによって無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comments are not statements and do not cause a &lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt; case to be ignored.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コメントは、文でなくて、&lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt;ケース節を無視されるようにはしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comments are treated as whitespace by the compiler.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コメントは、コンパイラによって空白とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comments can contain additional formatting and markup, as described in &lt;a0&gt;Markup Formatting Reference&lt;/a0&gt;&lt;s1&gt; [https://developer.apple.com/library/content/documentation/Xcode/Reference/xcode_markup_formatting_ref/index.html]&lt;/s1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コメントは、さらに追加の書式とマークアップを含む事が、&lt;a0&gt;Markup Formatting Reference&lt;/a0&gt;&lt;s1&gt; [https://developer.apple.com/library/content/documentation/Xcode/Reference/xcode_markup_formatting_ref/index.html]&lt;/s1&gt;で記述されるように可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comments in Swift are very similar to comments in C. Single-line comments begin with two forward-slashes (&lt;c0&gt;&lt;s1&gt;//&lt;/s1&gt;&lt;/c0&gt;):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのコメントは、Cのコメントに非常に似ています。一行コメントは２つのスラッシュで始まります（&lt;c0&gt;&lt;s1&gt;//&lt;/s1&gt;&lt;/c0&gt;）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compare the return value from the &lt;c8&gt;&lt;s9&gt;printNumberOfRooms&lt;/s9&gt;&lt;/c8&gt; call against &lt;c10&gt;&lt;s11&gt;nil&lt;/s11&gt;&lt;/c10&gt; to see if the method call was successful:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c8&gt;&lt;s9&gt;printNumberOfRooms&lt;/s9&gt;&lt;/c8&gt;呼び出しからの戻り値を&lt;c10&gt;&lt;s11&gt;nil&lt;/s11&gt;&lt;/c10&gt;と比較して、そのメソッドがうまく呼び出されたか見てください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comparing Strings</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列を比較する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comparing Structures and Classes</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体とクラスを比較する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comparison Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>比較演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comparison operators are often used in conditional statements, such as the &lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt; statement:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>比較演算子は、条件文においてしばしば使われます、例えば&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt;文など：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comparisons like &lt;c6&gt;&lt;s7&gt;i&lt;/s7&gt; &lt;s8&gt;==&lt;/s8&gt; &lt;s9&gt;1&lt;/s9&gt;&lt;/c6&gt; are discussed in &lt;a10&gt;&lt;s11&gt;Basic Operators&lt;/s11&gt;&lt;/a10&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;i&lt;/s7&gt; &lt;s8&gt;==&lt;/s8&gt; &lt;s9&gt;1&lt;/s9&gt;&lt;/c6&gt;のような比較は&lt;a10&gt;&lt;s11&gt;「基本の演算子」&lt;/s11&gt;&lt;/a10&gt;で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compile-Time Diagnostic Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイル時診断文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compiler Control Statements</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラ制御文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compiler control statements allow the program to change aspects of the compiler’s behavior and include a conditional compilation block and a line control statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラ制御文は、プログラムにコンパイラの挙動のいろいろな面を変更できるようにします、そして条件コンパイルブロックと行制御文を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compiler control statements allow the program to change aspects of the compiler’s behavior.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラ制御文は、プログラムに、コンパイラの挙動の様々な面を変更できるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compound Assignment Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複合代入演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compound Cases</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複合ケース節</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compound cases can also include value bindings.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複合ケース節はまた、値束縛を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Computed Properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>計算プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Computed Variables and Computed Properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>計算変数と計算プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Computed properties are provided by classes, structures, and enumerations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>計算プロパティは、クラス、構造体、および列挙で提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Computed type properties are always declared as variable properties, in the same way as computed instance properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>計算型プロパティは、計算インスタンスプロパティと同じ方法で、常に変数プロパティとして宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Computed variables calculate their value, rather than storing it, and they are written in the same way as computed properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>計算変数は値を計算します、それの貯蔵ではなくて、そして計算プロパティと同じ方法で書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Concatenating Strings and Characters</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列と文字の連結</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conditional Compilation Block</seg>
      </tuv>
      <tuv lang="JA">
        <seg>条件コンパイルブロック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conditional Conformance</seg>
      </tuv>
      <tuv lang="JA">
        <seg>条件準拠</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conditional Statements</seg>
      </tuv>
      <tuv lang="JA">
        <seg>条件つきの文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conditional compilation blocks that contain multiple branches have the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数の分岐を含む条件コンパイルブロックは、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conditional statements such as the &lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt; statement are covered in more detail in &lt;a2&gt;&lt;s3&gt;Control Flow&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt;文のような条件つきの文は、更に詳細に&lt;a2&gt;&lt;s3&gt;「制御の流れ」&lt;/s3&gt;&lt;/a2&gt;で扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conditionally Conforming to a Protocol</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロトコルに条件付きで準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conflicting Access to In-Out Parameters</seg>
      </tuv>
      <tuv lang="JA">
        <seg>in-outパラメータに対するアクセスの衝突</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conflicting Access to Properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティに対するアクセスの衝突</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conflicting Access to self in Methods</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッドの中でのselfに対するアクセスの衝突</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conform to protocols to provide standard functionality of a certain kind</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特定の種類の標準の機能性を提供するために、プロトコルに準拠します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider drawing the tick marks for every minute on a watch face.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>時計盤上のすべての分表示に目盛りを描画することを考えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider this example, which uses the &lt;c0&gt;&lt;s1&gt;Resolution&lt;/s1&gt;&lt;/c0&gt; structure from the previous example:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例を考慮してください、それは、前の例から&lt;c0&gt;&lt;s1&gt;Resolution&lt;/s1&gt;&lt;/c0&gt;構造体を使用します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider two arrays of integers, one where all the elements are the same, and one where they aren’t:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いくつかの整数からなる２つの配列を考えてください、すべての要素が同じであるもの、そしてそうではないもの：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constant Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constant and variable names can contain almost any character, including Unicode characters:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数と変数の名前は、ユニコード文字を含めて、ほとんどどんな文字でも含むことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constant and variable names can’t contain whitespace characters, mathematical symbols, arrows, private-use Unicode scalar values, or line- and box-drawing characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数と変数の名前は、空白文字、数学記号、矢印、私的使用Unicodeスカラー値、または罫線文字を含むことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constant declarations are declared using the &lt;c1&gt;&lt;s2&gt;let&lt;/s2&gt;&lt;/c1&gt; keyword and have the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数宣言は、&lt;c1&gt;&lt;s2&gt;let&lt;/s2&gt;&lt;/c1&gt;キーワードを使用して宣言され、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constant declarations are not computed properties and therefore do not have getters or setters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数宣言は、計算プロパティではなく、したがって、ゲッターまたはセッターを持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constant properties must always have a value &lt;e2&gt;before&lt;/e2&gt; initialization completes, and therefore cannot be declared as lazy.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数プロパティは常に値を、初期化が完了する&lt;e2&gt;前に&lt;/e2&gt;持たなければなりません、それゆえに遅延であると宣言されることが出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constants and Variables</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数と変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constants and variables are still explicitly typed, but much of the work of specifying their type is done for you.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数と変数は依然として明確に型を決められます、しかしそれらの型を指定する行為のほとんどは、あなたのために行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constants and variables associate a name (such as &lt;c0&gt;&lt;s1&gt;maximumNumberOfLoginAttempts&lt;/s1&gt;&lt;/c0&gt; or &lt;c2&gt;&lt;s3&gt;welcomeMessage&lt;/s3&gt;&lt;/c2&gt;) with a value of a particular type (such as the number &lt;c4&gt;&lt;s5&gt;10&lt;/s5&gt;&lt;/c4&gt; or the string &lt;c6&gt;&lt;s7&gt;"Hello"&lt;/s7&gt;&lt;/c6&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数と変数は、ひとつの名前（例えば&lt;c0&gt;&lt;s1&gt;maximumNumberOfLoginAttempts&lt;/s1&gt;&lt;/c0&gt;または&lt;c2&gt;&lt;s3&gt;welcomeMessage&lt;/s3&gt;&lt;/c2&gt;など）を特定の型のひとつの値（例えば数&lt;c4&gt;&lt;s5&gt;10&lt;/s5&gt;&lt;/c4&gt;または文字列&lt;c6&gt;&lt;s7&gt;"Hello"&lt;/s7&gt;&lt;/c6&gt;など）と結びつけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constants and variables created with optional binding in an &lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt; statement are available only within the body of the &lt;c2&gt;&lt;s3&gt;if&lt;/s3&gt;&lt;/c2&gt; statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt;文の中でオプショナル束縛を使って作成された定数と変数は、その&lt;c2&gt;&lt;s3&gt;if&lt;/s3&gt;&lt;/c2&gt;文の本文の内部でのみ利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constants and variables must be declared before they’re used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数と変数は、それらが使われる前に宣言されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constants and variables of type &lt;c0&gt;&lt;s1&gt;Any&lt;/s1&gt;&lt;/c0&gt; can now contain function instances.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型&lt;c0&gt;&lt;s1&gt;Any&lt;/s1&gt;&lt;/c0&gt;の定数と変数は、今では関数インスタンスを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constants and variables of type &lt;c4&gt;&lt;s5&gt;Barcode&lt;/s5&gt;&lt;/c4&gt; can store either a &lt;c6&gt;&lt;s7&gt;.upc&lt;/s7&gt;&lt;/c6&gt; or a &lt;c8&gt;&lt;s9&gt;.qrCode&lt;/s9&gt;&lt;/c8&gt; (together with their associated values), but they can store only one of them at any given time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型&lt;c4&gt;&lt;s5&gt;Barcode&lt;/s5&gt;&lt;/c4&gt;の定数と変数は、&lt;c6&gt;&lt;s7&gt;.upc&lt;/s7&gt;&lt;/c6&gt;または&lt;c8&gt;&lt;s9&gt;.qrCode&lt;/s9&gt;&lt;/c8&gt;のどちらでも（それらの関連値と共に）格納することができます、しかしそれらはどんな時でもそれらの１つを格納することだけができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constants can now be declared without being initialized in local function scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数は今では初期化されることなくローカル関数のスコープ内で宣言されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constants, Variables, Properties, and Subscripts</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数、変数、プロパティ，そして添え字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Continue Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>継続文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Control Flow</seg>
      </tuv>
      <tuv lang="JA">
        <seg>制御の流れ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Control Transfer Statements</seg>
      </tuv>
      <tuv lang="JA">
        <seg>制御移動文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Control flow in a loop statement can be changed by a &lt;c0&gt;&lt;s1&gt;break&lt;/s1&gt;&lt;/c0&gt; statement and a &lt;c2&gt;&lt;s3&gt;continue&lt;/s3&gt;&lt;/c2&gt; statement and is discussed in &lt;a4&gt;&lt;s5&gt;Break Statement&lt;/s5&gt;&lt;/a4&gt; and &lt;a6&gt;&lt;s7&gt;Continue Statement&lt;/s7&gt;&lt;/a6&gt; below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ループ文の中の制御の流れは、&lt;c0&gt;&lt;s1&gt;break&lt;/s1&gt;&lt;/c0&gt;文そして&lt;c2&gt;&lt;s3&gt;continue&lt;/s3&gt;&lt;/c2&gt;文によって変えられることができます、そして下記の&lt;a4&gt;&lt;s5&gt;ブレーク文&lt;/s5&gt;&lt;/a4&gt;と&lt;a6&gt;&lt;s7&gt;継続文&lt;/s7&gt;&lt;/a6&gt;で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Control flow in an &lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt; statement or a &lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt; statement can be changed by a &lt;c4&gt;&lt;s5&gt;break&lt;/s5&gt;&lt;/c4&gt; statement and is discussed in &lt;a6&gt;&lt;s7&gt;Break Statement&lt;/s7&gt;&lt;/a6&gt; below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt;文または&lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt;文の中の制御の流れは、&lt;c4&gt;&lt;s5&gt;break&lt;/s5&gt;&lt;/c4&gt;文によって変えられることができます、それは下記の&lt;a6&gt;&lt;s7&gt;ブレーク文&lt;/s7&gt;&lt;/a6&gt;で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Control flow statements are used to control the flow of execution in a program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>制御の流れ文は、プログラムにおいて実行の流れを制御するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Control transfer statements are discussed in &lt;a0&gt;&lt;s1&gt;Control Transfer Statements&lt;/s1&gt;&lt;/a0&gt; below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>制御移動文は、下の&lt;a0&gt;&lt;s1&gt;制御移動文&lt;/s1&gt;&lt;/a0&gt;で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Control transfer statements can change the order in which code in your program is executed by unconditionally transferring program control from one piece of code to another.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>制御移動文は、あなたのプログラムの中のコードが実行される順番を、プログラム制御を１つのコード片から他のものまで無条件に移すことによって変えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Convenience initializers are written in the same style, but with the &lt;c0&gt;&lt;s1&gt;convenience&lt;/s1&gt;&lt;/c0&gt; modifier placed before the &lt;c2&gt;&lt;s3&gt;init&lt;/s3&gt;&lt;/c2&gt; keyword, separated by a space:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>便宜イニシャライザは同じ形式で書かれます、しかし&lt;c0&gt;&lt;s1&gt;convenience&lt;/s1&gt;&lt;/c0&gt;修飾子が&lt;c2&gt;&lt;s3&gt;init&lt;/s3&gt;&lt;/c2&gt;キーワードの前に空白で区切って置かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Convenience initializers can delegate the initialization process to another convenience initializer or to one of the class’s designated initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>便宜イニシャライザは、初期化プロセスを別の便宜イニシャライザに、またはそのクラスの指定イニシャライザのうちの１つに委任することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Convenience initializers can’t call a superclass’s initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>便宜イニシャライザは、スーパークラスのイニシャライザを呼ぶことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Convenience initializers must always delegate &lt;e0&gt;across&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>便宜イニシャライザは、常に&lt;e0&gt;横に&lt;/e0&gt;委任しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conversely, &lt;c0&gt;&lt;s1&gt;LATIN&lt;/s1&gt; &lt;s2&gt;CAPITAL&lt;/s2&gt; &lt;s3&gt;LETTER&lt;/s3&gt; &lt;s4&gt;A&lt;/s4&gt;&lt;/c0&gt; (&lt;c5&gt;&lt;s6&gt;U+0041&lt;/s6&gt;&lt;/c5&gt;, or &lt;c7&gt;&lt;s8&gt;"A"&lt;/s8&gt;&lt;/c7&gt;), as used in English, is &lt;e9&gt;not&lt;/e9&gt; equivalent to &lt;c10&gt;&lt;s11&gt;CYRILLIC&lt;/s11&gt; &lt;s12&gt;CAPITAL&lt;/s12&gt; &lt;s13&gt;LETTER&lt;/s13&gt; &lt;s14&gt;A&lt;/s14&gt;&lt;/c10&gt; (&lt;c15&gt;&lt;s16&gt;U+0410&lt;/s16&gt;&lt;/c15&gt;, or &lt;c17&gt;&lt;s18&gt;"А"&lt;/s18&gt;&lt;/c17&gt;), as used in Russian.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>反対に、英語で使われるような、&lt;c0&gt;&lt;s1&gt;LATIN&lt;/s1&gt; &lt;s2&gt;CAPITAL&lt;/s2&gt; &lt;s3&gt;LETTER&lt;/s3&gt; &lt;s4&gt;A&lt;/s4&gt;&lt;/c0&gt;（&lt;c5&gt;&lt;s6&gt;U+0041&lt;/s6&gt;&lt;/c5&gt;、または&lt;c7&gt;&lt;s8&gt;"A"&lt;/s8&gt;&lt;/c7&gt;）は、ロシアで使われるような、&lt;c10&gt;&lt;s11&gt;CYRILLIC&lt;/s11&gt; &lt;s12&gt;CAPITAL&lt;/s12&gt; &lt;s13&gt;LETTER&lt;/s13&gt; &lt;s14&gt;A&lt;/s14&gt;&lt;/c10&gt;（&lt;c15&gt;&lt;s16&gt;U+0410&lt;/s16&gt;&lt;/c15&gt;、または&lt;c17&gt;&lt;s18&gt;"А"&lt;/s18&gt;&lt;/c17&gt;）と等しく&lt;e9&gt;ありません&lt;/e9&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conversely, define a capture as a weak reference when the captured reference may become &lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt; at some point in the future.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>逆に、捕らえられた参照が将来どこかの時点で&lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;になるかもしれないときは、捕獲を弱い参照として定義してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conversely, if you write a subclass initializer that matches a superclass &lt;e0&gt;convenience&lt;/e0&gt; initializer, that superclass convenience initializer can never be called directly by your subclass, as per the rules described above in &lt;a1&gt;&lt;s2&gt;Initializer Delegation for Class Types&lt;/s2&gt;&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>逆に言えば、上記の&lt;a1&gt;&lt;s2&gt;クラス型のためのイニシャライザ委任&lt;/s2&gt;&lt;/a1&gt;で記述される規則どおりに、あなたがスーパークラスの&lt;e0&gt;便宜&lt;/e0&gt;イニシャライザに一致するサブクラスのイニシャライザを書くならば、そのスーパークラスの便宜イニシャライザは直接にあなたのサブクラスによって呼び出されることが決してできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conversely, set &lt;c15&gt;&lt;s16&gt;b&lt;/s16&gt;&lt;/c15&gt; is a &lt;e17&gt;subset&lt;/e17&gt; of set &lt;c18&gt;&lt;s19&gt;a&lt;/s19&gt;&lt;/c18&gt;, because all elements in &lt;c20&gt;&lt;s21&gt;b&lt;/s21&gt;&lt;/c20&gt; are also contained by &lt;c22&gt;&lt;s23&gt;a&lt;/s23&gt;&lt;/c22&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>逆に言えば、集合&lt;c15&gt;&lt;s16&gt;b&lt;/s16&gt;&lt;/c15&gt;は集合&lt;c18&gt;&lt;s19&gt;a&lt;/s19&gt;&lt;/c18&gt;の&lt;e17&gt;下位集合&lt;/e17&gt;です、&lt;c20&gt;&lt;s21&gt;b&lt;/s21&gt;&lt;/c20&gt;の要素すべては&lt;c22&gt;&lt;s23&gt;a&lt;/s23&gt;&lt;/c22&gt;によってまた含まれるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conversions between integer and floating-point numeric types must be made explicit:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数と浮動小数点数型の間の変換は、明示的に行われる必要があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Converting Errors to Optional Values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーをオプショナルの値に変換する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Corrected the discussion of the &lt;c0&gt;&lt;s1&gt;@NSApplicationMain&lt;/s1&gt;&lt;/c0&gt; attribute in the &lt;a2&gt;&lt;s3&gt;Declaration Attributes&lt;/s3&gt;&lt;/a2&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;@NSApplicationMain&lt;/s1&gt;&lt;/c0&gt;属性の解説を&lt;a2&gt;&lt;s3&gt;宣言属性&lt;/s3&gt;&lt;/a2&gt;の節において訂正した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Counting Characters</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字を数える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Create a constant with an explicit type of &lt;c0&gt;&lt;s1&gt;Float&lt;/s1&gt;&lt;/c0&gt; and a value of &lt;c2&gt;&lt;s3&gt;4&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>明確に&lt;c0&gt;&lt;s1&gt;Float&lt;/s1&gt;&lt;/c0&gt;の型で値&lt;c2&gt;&lt;s3&gt;4&lt;/s3&gt;&lt;/c2&gt;の定数をつくってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Create an instance of a class by putting parentheses after the class name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス名の後に丸括弧を置くことによって、クラスのインスタンスをつくってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Create arrays and dictionaries using brackets (&lt;c0&gt;&lt;s1&gt;[]&lt;/s1&gt;&lt;/c0&gt;), and access their elements by writing the index or key in brackets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>角括弧（&lt;c0&gt;&lt;s1&gt;[]&lt;/s1&gt;&lt;/c0&gt;）を使って配列および辞書（連想配列）を作ってください、そしてインデックスまたはキーを角括弧の中に記述することによってそれらの要素にアクセスしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Create convenience initializers whenever a shortcut to a common initialization pattern will save time or make initialization of the class clearer in intent.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>共通の初期化の繰り返しに対する近道が時間を節約したり、そのクラスの初期化を意図においてより明白にするときはいつでも、便宜イニシャライザをつくってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating a Dictionary with a Dictionary Literal</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書を辞書リテラルで作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating a Set with an Array Literal</seg>
      </tuv>
      <tuv lang="JA">
        <seg>集合を配列リテラルで作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating an Array by Adding Two Arrays Together</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つの配列を一緒にすることで１つの配列を作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating an Array with a Default Value</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列を１つの初期値で作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating an Array with an Array Literal</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列を配列リテラルで作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating an Empty Array</seg>
      </tuv>
      <tuv lang="JA">
        <seg>空の配列の作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating an Empty Dictionary</seg>
      </tuv>
      <tuv lang="JA">
        <seg>空の辞書を作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creating and Initializing an Empty Set</seg>
      </tuv>
      <tuv lang="JA">
        <seg>空の集合の作成と初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Custom Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あつらえの演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Custom Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あつらえの型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Custom infix operators each belong to a precedence group.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あつらえの接中辞演算子それぞれは、ある優先順位グループに属しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Custom initializers can be assigned an access level less than or equal to the type that they initialize.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あつらえのイニシャライザは、それらが初期化する型と同じか低いアクセス水準を割り当てられることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Custom operators can begin with one of the ASCII characters &lt;c0&gt;&lt;s1&gt;/&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;=&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;-&lt;/s5&gt;&lt;/c4&gt;, &lt;c6&gt;&lt;s7&gt;+&lt;/s7&gt;&lt;/c6&gt;, &lt;c8&gt;&lt;s9&gt;!&lt;/s9&gt;&lt;/c8&gt;, &lt;c10&gt;&lt;s11&gt;*&lt;/s11&gt;&lt;/c10&gt;, &lt;c12&gt;&lt;s13&gt;%&lt;/s13&gt;&lt;/c12&gt;, &lt;c14&gt;&lt;s15&gt;&lt;&lt;/s15&gt;&lt;/c14&gt;, &lt;c16&gt;&lt;s17&gt;&gt;&lt;/s17&gt;&lt;/c16&gt;, &lt;c18&gt;&lt;s19&gt;&amp;&lt;/s19&gt;&lt;/c18&gt;, &lt;c20&gt;&lt;s21&gt;|&lt;/s21&gt;&lt;/c20&gt;, &lt;c22&gt;&lt;s23&gt;^&lt;/s23&gt;&lt;/c22&gt;, &lt;c24&gt;&lt;s25&gt;?&lt;/s25&gt;&lt;/c24&gt;, or &lt;c26&gt;&lt;s27&gt;~&lt;/s27&gt;&lt;/c26&gt;, or one of the Unicode characters defined in the grammar below (which include characters from the &lt;e28&gt;Mathematical Operators&lt;/e28&gt;, &lt;e29&gt;Miscellaneous Symbols&lt;/e29&gt;, and &lt;e30&gt;Dingbats&lt;/e30&gt; Unicode blocks, among others).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あつらえの演算子は、ASCII文字&lt;c0&gt;&lt;s1&gt;/&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;=&lt;/s3&gt;&lt;/c2&gt;、&lt;c4&gt;&lt;s5&gt;-&lt;/s5&gt;&lt;/c4&gt;、&lt;c6&gt;&lt;s7&gt;+&lt;/s7&gt;&lt;/c6&gt;、&lt;c8&gt;&lt;s9&gt;!&lt;/s9&gt;&lt;/c8&gt;、&lt;c10&gt;&lt;s11&gt;*&lt;/s11&gt;&lt;/c10&gt;、&lt;c12&gt;&lt;s13&gt;%&lt;/s13&gt;&lt;/c12&gt;、&lt;c14&gt;&lt;s15&gt;&lt;&lt;/s15&gt;&lt;/c14&gt;、&lt;c16&gt;&lt;s17&gt;&gt;&lt;/s17&gt;&lt;/c16&gt;、&lt;c18&gt;&lt;s19&gt;&amp;&lt;/s19&gt;&lt;/c18&gt;、&lt;c20&gt;&lt;s21&gt;|&lt;/s21&gt;&lt;/c20&gt;、&lt;c22&gt;&lt;s23&gt;^&lt;/s23&gt;&lt;/c22&gt;、&lt;c24&gt;&lt;s25&gt;?&lt;/s25&gt;&lt;/c24&gt;、および&lt;c26&gt;&lt;s27&gt;~&lt;/s27&gt;&lt;/c26&gt;のうちの１つ、または以下の文法において定義されるユニコード文字のうちの１つで始まります（それは&lt;e28&gt;Mathematical Operators&lt;/e28&gt;、&lt;e29&gt;Miscellaneous Symbols&lt;/e29&gt;、そして&lt;e30&gt;Dingbats&lt;/e30&gt;ユニコードブロックなどからの文字を含みます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Custom operators can now contain the &lt;c0&gt;&lt;s1&gt;?&lt;/s1&gt;&lt;/c0&gt; character.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あつらえの演算子は、今では&lt;c0&gt;&lt;s1&gt;?&lt;/s1&gt;&lt;/c0&gt;文字を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Custom types state that they adopt a particular protocol by placing the protocol’s name after the type’s name, separated by a colon, as part of their definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あつらえの型は、それが特定のプロトコルを採用することを、型の名前の後に、コロンで区切って、それらの定義の一部としてプロトコルの名前を置くことによって示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Customizing Initialization</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期化をカスタマイズする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data types that are normally considered basic or primitive in other languages—such as types that represent numbers, characters, and strings—are actually named types, defined and implemented in the Swift standard library using structures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の言語で通常は基本的またはプリミティブであるとみなされるデータ型 ― 例えば数、文字、そして文字列を表す型 ― これらは実際に名前付きの型で、構造体を使用してスウィフト標準ライブラリにおいて定義および実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DataImporter is a class to import data from an external file.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（DataImporterは、データを外部ファイルからインポートするクラスです。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Debugging with Assertions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>表明を使ってデバッグする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Decimal floating-point literals consist of a sequence of decimal digits followed by either a decimal fraction, a decimal exponent, or both.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>10進の浮動小数点リテラルは、一連の10進の桁に、小数部か10進の指数のどちらか、または両方が続くものから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Decimal floats can also have an optional &lt;e2&gt;exponent&lt;/e2&gt;, indicated by an uppercase or lowercase &lt;c3&gt;&lt;s4&gt;e&lt;/s4&gt;&lt;/c3&gt;; hexadecimal floats must have an exponent, indicated by an uppercase or lowercase &lt;c5&gt;&lt;s6&gt;p&lt;/s6&gt;&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>10進浮動小数点はまた、任意に&lt;e2&gt;指数&lt;/e2&gt;を持つことができ、大文字か小文字の&lt;c3&gt;&lt;s4&gt;e&lt;/s4&gt;&lt;/c3&gt;で示されます；16進浮動小数点は、指数を持つ必要があり、大文字か小文字の&lt;c5&gt;&lt;s6&gt;p&lt;/s6&gt;&lt;/c5&gt;で示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Decimal literals contain the digits &lt;c0&gt;&lt;s1&gt;0&lt;/s1&gt;&lt;/c0&gt; through &lt;c2&gt;&lt;s3&gt;9&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>10進のリテラルは、&lt;c0&gt;&lt;s1&gt;0&lt;/s1&gt;&lt;/c0&gt;から&lt;c2&gt;&lt;s3&gt;9&lt;/s3&gt;&lt;/c2&gt;までの桁を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declaration Attributes</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declaration Attributes Used by Interface Builder</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インターフェイスビルダーで使用される宣言属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declaration Modifiers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言修飾子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declarations</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declarations in a protocol extension can’t be marked &lt;c2&gt;&lt;s3&gt;final&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル拡張の中の宣言は、&lt;c2&gt;&lt;s3&gt;final&lt;/s3&gt;&lt;/c2&gt;で印されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declarations marked with the &lt;c0&gt;&lt;s1&gt;inlinable&lt;/s1&gt;&lt;/c0&gt; attribute are implicitly usable from inlinable code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;inlinable&lt;/s1&gt;&lt;/c0&gt;属性で印される宣言は、暗黙的にインライン可能コードから利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declarations marked with the &lt;c0&gt;&lt;s1&gt;open&lt;/s1&gt;&lt;/c0&gt; access-level modifier can also be accessed and subclassed by code in a module that imports the module that contains that declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;open&lt;/s1&gt;&lt;/c0&gt;アクセス水準修飾子で印される宣言はまた、アクセスされることおよびサブクラスを作られることが、その宣言を含むモジュールをインポートするモジュール内のコードによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declarations marked with the &lt;c0&gt;&lt;s1&gt;public&lt;/s1&gt;&lt;/c0&gt; access-level modifier can also be accessed (but not subclassed) by code in a module that imports the module that contains that declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;public&lt;/s1&gt;&lt;/c0&gt;アクセス水準修飾子で印される宣言はまた、アクセスされる（しかしサブクラスは作られない）ことが、その宣言を含むモジュールをインポートするモジュール内のコードによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declare a private member in an extension, and access that member from the original declaration in the same file.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある非公開メンバをある拡張の中で宣言する、そしてそのメンバに対して同じファイル中のオリジナルの宣言からアクセスする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declare a private member in one extension, and access that member from another extension in the same file.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある非公開メンバを一方の拡張の中で宣言する、そしてそのメンバに対して同じファイル中の別の拡張からアクセスする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declare a private member in the original declaration, and access that member from extensions in the same file.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある非公開メンバをオリジナルの宣言の中で宣言する、そしてそのメンバに対して同じファイル中の拡張からアクセスする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declare extensions with the &lt;c0&gt;&lt;s1&gt;extension&lt;/s1&gt;&lt;/c0&gt; keyword:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;extension&lt;/s1&gt;&lt;/c0&gt;キーワードによって拡張を宣言してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declaring Constants and Variables</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数と変数の宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declaring Protocol Adoption with an Extension</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張を使ってプロトコル採用を宣言する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Default Access Levels</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時のアクセス水準</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Default Initializers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時のイニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Default Memberwise Initializers for Structure Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体体型のための省略時のメンバー関連イニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Default Parameter Values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時のパラメータ値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Default Property Values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時のプロパティ値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Default values, however, can’t be specified for method parameters within a protocol’s definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時の値は、しかしながら、プロトコル定義の内部のメソッドパラメーターに対して指定されることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defer Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>defer文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deferred actions are executed in the reverse of the order that they’re written in your source code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>延期された動作は、それらがあなたのソースコードに書かれた順序の逆に実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Define a capture in a closure as an unowned reference when the closure and the instance it captures will always refer to each other, and will always be deallocated at the same time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが捕らえるクロージャとインスタンスが常にお互いに言及して、常に同時に割り当て解除されるときは、クロージャにおいて捕獲を非所有参照として定義してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Define and use new nested types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい入れ子にされた型を定義して、使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Define initializers to set up their initial state</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの初期状態を設定するために、イニシャライザを定義します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Define instance methods and type methods</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インスタンスメソッドと型メソッドを定義する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Define methods to provide functionality</seg>
      </tuv>
      <tuv lang="JA">
        <seg>機能性を提供するために、メソッドを定義します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Define properties to store values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値を格納するために、プロパティを定義します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Define subscripts</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字を定義する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Define subscripts to provide access to their values using subscript syntax</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字構文を使用してそれらの値の利用することを提供するために、添え字を定義します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Define the access level for an entity by placing one of the &lt;c0&gt;&lt;s1&gt;open&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;public&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;internal&lt;/s5&gt;&lt;/c4&gt;, &lt;c6&gt;&lt;s7&gt;fileprivate&lt;/s7&gt;&lt;/c6&gt;, or &lt;c8&gt;&lt;s9&gt;private&lt;/s9&gt;&lt;/c8&gt; modifiers at the beginning of the entity’s declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある実在にアクセス水準を定義するには、&lt;c0&gt;&lt;s1&gt;open&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;public&lt;/s3&gt;&lt;/c2&gt;、&lt;c4&gt;&lt;s5&gt;internal&lt;/s5&gt;&lt;/c4&gt;、&lt;c6&gt;&lt;s7&gt;fileprivate&lt;/s7&gt;&lt;/c6&gt;、または&lt;c8&gt;&lt;s9&gt;private&lt;/s9&gt;&lt;/c8&gt;修飾子のうちの１つをその実在の宣言の始まりに置いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining Model Classes for Optional Chaining</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖のモデル・クラスを定義する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining a Base Class</seg>
      </tuv>
      <tuv lang="JA">
        <seg>基盤クラスを定義すること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining a Capture List</seg>
      </tuv>
      <tuv lang="JA">
        <seg>捕獲リストの定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining a Class Hierarchy for Type Casting</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型キャストのためにクラス階層を定義する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining a call-as-function method, or a method from the &lt;c0&gt;&lt;s1&gt;dynamicCallable&lt;/s1&gt;&lt;/c0&gt; attribute, doesn’t let you use an instance of that type as if it were a function in any context other than a function call expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>call-as-functionメソッド、または&lt;c0&gt;&lt;s1&gt;dynamicCallable&lt;/s1&gt;&lt;/c0&gt;属性からのメソッドを定義することは、あなたにその型のインスタンスを使わせません、まるでそれが関数呼び出し式と違う何か他の文脈での関数だったかのようには。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defining and Calling Functions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数の定義と呼び出し</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Definition Syntax</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定義構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deinitialization</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デイニシャライズ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deinitializer Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デイニシャライザ宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deinitializers are called automatically, just before instance deallocation takes place.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デイニシャライザは、インスタンスの割り当て解除が起こる直前に、自動的に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deinitializers are not called directly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デイニシャライザは、直接に呼ばれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deinitializers are only available on class types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デイニシャライザは、クラス型で利用可能なだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deinitializers enable an instance of a class to free up any resources it has assigned.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デイニシャライザは、クラスのインスタンスにそれが代入したどんなリソースでも解放するのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deinitializers in Action</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デイニシャライザの動作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Deinitializers take no parameters and have the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デイニシャライザは、パラメータを取らない以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Delaying evaluation is useful for code that has side effects or is computationally expensive, because it lets you control when that code is evaluated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>評価を遅らせることは、副作用を持つまたは計算的に高くつくコードに対して有用です、なぜならそれがあなたに何時そのコードが評価されるかを制御させるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Delegation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>委任</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Delegation can be used to respond to a particular action, or to retrieve data from an external source without needing to know the underlying type of that source.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>委任は、特定の動作に応答したり、外部ソースからそのソースの根底の型を知る必要なしにデータを取り出したりするのに使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Designated Initializers and Convenience Initializers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定イニシャライザと便宜イニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Designated and Convenience Initializers in Action</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定および便宜イニシャライザの動作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Designated initializers and deinitializers must always be provided by the original class implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定イニシャライザとデイニシャライザは、常に最初のクラス実施によって提供されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Designated initializers are “funnel” points through which initialization takes place, and through which the initialization process continues up the superclass chain.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定イニシャライザは、「漏斗」地点です、そこを通して初期化が行われ、そこを通して初期化処理がスーパークラス連鎖を上って続いていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Designated initializers can be declared in the context of a class declaration only and therefore can’t be added to a class using an extension declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定イニシャライザは、クラス宣言の文脈においてのみ宣言されることができて、したがって拡張宣言を使ってあるクラスに加えられることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Designated initializers for classes are written in the same way as simple initializers for value types:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスのための指定イニシャライザは、値型のための単純なイニシャライザと同様に書かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Designated initializers must always delegate &lt;e0&gt;up&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定イニシャライザは、常に&lt;e0&gt;上に&lt;/e0&gt;委任しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Despite this simplicity of syntax, Swift’s &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; type is a fast, modern string implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構文のこの単純さにもかかわらず、スウィフトの&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;型は、速く、現代的な文字列の実装です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dictionaries</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dictionaries are an unordered collection, so their keys and values are iterated over in an arbitrary order.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書は、順序付けられないコレクションです、なのでそのキーと値は気まぐれな順番で繰り返されていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dictionaries are unordered collections of key-value associations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書は、「キーと値」を結びつけたものの順番をつけられないコレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dictionary Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dictionary Type Shorthand Syntax</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書型の略記構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Differences Between Opaque Types and Protocol Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>不透明型とプロトコル型の間の違い</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Digit 0 or 1</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アラビア数字の0または1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Digit 0 through 7</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アラビア数字の0から7</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Digit 0 through 9</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アラビア数字の0から9</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Digit 0 through 9, a through f, or A through F</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アラビア数字の0から9、aからf、またはAからF</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Disabling Error Propagation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラー伝達を抑制する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Distinguishing among these different situations allows a program to resolve some errors and to communicate to the user any errors it can’t resolve.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの異なった状況を区別することは、プログラムにいくらかのエラーを解消すること、そしてなんらかのそれが解消できないエラーを利用者に伝えることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Division (&lt;c0&gt;&lt;s1&gt;/&lt;/s1&gt;&lt;/c0&gt;)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>除算（&lt;c0&gt;&lt;s1&gt;/&lt;/s1&gt;&lt;/c0&gt;）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>do文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do this by placing an exclamation point after the &lt;c4&gt;&lt;s5&gt;init&lt;/s5&gt;&lt;/c4&gt; keyword (&lt;c6&gt;&lt;s7&gt;init!&lt;/s7&gt;&lt;/c6&gt;) instead of a question mark.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これを、疑問符ではなく、感嘆符を&lt;c4&gt;&lt;s5&gt;init&lt;/s5&gt;&lt;/c4&gt;キーワードの後に置くこと（&lt;c6&gt;&lt;s7&gt;init!&lt;/s7&gt;&lt;/c6&gt;）によって行ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do this by writing the &lt;c1&gt;&lt;s2&gt;final&lt;/s2&gt;&lt;/c1&gt; modifier before the method, property, or subscript’s introducer keyword (such as &lt;c3&gt;&lt;s4&gt;final&lt;/s4&gt; &lt;s5&gt;var&lt;/s5&gt;&lt;/c3&gt;, &lt;c6&gt;&lt;s7&gt;final&lt;/s7&gt; &lt;s8&gt;func&lt;/s8&gt;&lt;/c6&gt;, &lt;c9&gt;&lt;s10&gt;final&lt;/s10&gt; &lt;s11&gt;class&lt;/s11&gt; &lt;s12&gt;func&lt;/s12&gt;&lt;/c9&gt;, and &lt;c13&gt;&lt;s14&gt;final&lt;/s14&gt; &lt;s15&gt;subscript&lt;/s15&gt;&lt;/c13&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッド、プロパティ、または添え字の導入子キーワードの前に&lt;c1&gt;&lt;s2&gt;final&lt;/s2&gt;&lt;/c1&gt;修飾子を書くことによって、これをしてください（例えば、&lt;c3&gt;&lt;s4&gt;final&lt;/s4&gt; &lt;s5&gt;var&lt;/s5&gt;&lt;/c3&gt;、&lt;c6&gt;&lt;s7&gt;final&lt;/s7&gt; &lt;s8&gt;func&lt;/s8&gt;&lt;/c6&gt;、&lt;c9&gt;&lt;s10&gt;final&lt;/s10&gt; &lt;s11&gt;class&lt;/s11&gt; &lt;s12&gt;func&lt;/s12&gt;&lt;/c9&gt;、そして&lt;c13&gt;&lt;s14&gt;final&lt;/s14&gt; &lt;s15&gt;subscript&lt;/s15&gt;&lt;/c13&gt;など）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Document Revision History</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文書改訂履歴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Doing so clarifies that you intend to provide an override and have not provided a matching definition by mistake.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうすることは、あなたがオーバーライドを提供するつもりであって、誤って同じ定義を提供したのでないことを明らかにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Doing so is consistent with the label’s use alongside the &lt;c11&gt;&lt;s12&gt;break&lt;/s12&gt;&lt;/c11&gt; statement and helps make the game’s logic clearer to read and understand.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうすることは、&lt;c11&gt;&lt;s12&gt;break&lt;/s12&gt;&lt;/c11&gt;文と並べるとラベルの使用で調和して、ゲームの論理を読み取って理解するのをより明快にする助けとなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Doing so makes it easier for you to reason about your code and enables the Swift compiler to optimize the performance of the collections you create.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうすることは、あなたがあなたのコードについて推論するのをより容易にして、スウィフトのコンパイラにあなたが作成するコレクションの運用性能を最適なものにすることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don’t use an implicitly unwrapped optional when there’s a possibility of a variable becoming &lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt; at a later point.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある変数がその後のある時点で&lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;になる可能性がある時には、暗黙的にアンラップされるオプショナルを使用しないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don’t worry if you are not familiar with the concept of capturing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがキャプチャの概念に馴染みがなくても、心配いりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Don’t worry if you don’t understand something—everything introduced in this tour is explained in detail in the rest of this book.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>わからないことがあっても心配することはありません ― このツアーにおいて紹介されるすべてのことは、この本の残りで詳細に説明されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Double quotation mark (&lt;c0&gt;&lt;s1&gt;\"&lt;/s1&gt;&lt;/c0&gt;)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>二重引用符（&lt;c0&gt;&lt;s1&gt;\"&lt;/s1&gt;&lt;/c0&gt;）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Downcasting</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ダウンキャスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Downcasting to &lt;c0&gt;&lt;s1&gt;Movie&lt;/s1&gt;&lt;/c0&gt; fails when applied to the &lt;c2&gt;&lt;s3&gt;Song&lt;/s3&gt;&lt;/c2&gt; instances in the library array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Movie&lt;/s1&gt;&lt;/c0&gt;にダウンキャストすることは、library配列の&lt;c2&gt;&lt;s3&gt;Song&lt;/s3&gt;&lt;/c2&gt;インスタンスに適用されるとき失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dynamic member lookup by key path can be used to implement a wrapper type in a way that supports compile-time type checking.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キーパスによる動的メンバー検索は、ラッパー型を、コンバイル時型検査をサポートするある方法で実装するために使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Dynamic member lookup by member name can be used to create a wrapper type around data that can’t be type checked at compile time, such as when bridging data from other languages into Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メンバー名による動的メンバー検索は、コンパイル時に型検査されることができないデータを取り囲むラッパー型を作成するために使用できます、たとえば他の言語からスウィフトへとブリッジしている時など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each &lt;c0&gt;&lt;s1&gt;Player&lt;/s1&gt;&lt;/c0&gt; instance is initialized with a starting allowance of a specified number of coins from the bank during initialization, although a &lt;c2&gt;&lt;s3&gt;Player&lt;/s3&gt;&lt;/c2&gt; instance may receive fewer than that number if not enough coins are available.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各&lt;c0&gt;&lt;s1&gt;Player&lt;/s1&gt;&lt;/c0&gt;インスタンスは、初期化の間に、胴元からの指定された数のコインの開始手当で初期化されます、とは言え、十分なコインが利用可能でなければ&lt;c2&gt;&lt;s3&gt;Player&lt;/s3&gt;&lt;/c2&gt;インスタンスはその数より少ないものを受け取るかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; value has an associated &lt;e2&gt;index type&lt;/e2&gt;, &lt;c3&gt;&lt;s4&gt;String.Index&lt;/s4&gt;&lt;/c3&gt;, which corresponds to the position of each &lt;c5&gt;&lt;s6&gt;Character&lt;/s6&gt;&lt;/c5&gt; in the string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれの&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;値は、結び付けられた&lt;e2&gt;インデックス型&lt;/e2&gt;、&lt;c3&gt;&lt;s4&gt;String.Index&lt;/s4&gt;&lt;/c3&gt;を持ちます、それは、各&lt;c5&gt;&lt;s6&gt;Character&lt;/s6&gt;&lt;/c5&gt;のその文字列中での位置に対応しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each &lt;c0&gt;&lt;s1&gt;UnicodeScalar&lt;/s1&gt;&lt;/c0&gt; has a &lt;c2&gt;&lt;s3&gt;value&lt;/s3&gt;&lt;/c2&gt; property that returns the scalar’s 21-bit value, represented within a &lt;c4&gt;&lt;s5&gt;UInt32&lt;/s5&gt;&lt;/c4&gt; value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各&lt;c0&gt;&lt;s1&gt;UnicodeScalar&lt;/s1&gt;&lt;/c0&gt;はひとつの&lt;c2&gt;&lt;s3&gt;value&lt;/s3&gt;&lt;/c2&gt;プロパティを持ちます、それはそのスカラーの21ビットの値を返します、そしてそれは&lt;c4&gt;&lt;s5&gt;UInt32&lt;/s5&gt;&lt;/c4&gt;値の範囲内で表されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each &lt;c2&gt;&lt;s3&gt;Starship&lt;/s3&gt;&lt;/c2&gt; class instance stores a mandatory &lt;c4&gt;&lt;s5&gt;name&lt;/s5&gt;&lt;/c4&gt; and an optional &lt;c6&gt;&lt;s7&gt;prefix&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各&lt;c2&gt;&lt;s3&gt;Starship&lt;/s3&gt;&lt;/c2&gt;クラスインスタンスは、義務的な&lt;c4&gt;&lt;s5&gt;name&lt;/s5&gt;&lt;/c4&gt;そしてオプショナルの&lt;c6&gt;&lt;s7&gt;prefix&lt;/s7&gt;&lt;/c6&gt;を格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each &lt;c4&gt;&lt;s5&gt;case&lt;/s5&gt;&lt;/c4&gt; compares that value to a number or interval.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各&lt;c4&gt;&lt;s5&gt;case&lt;/s5&gt;&lt;/c4&gt;は、その値をある数または区間と比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each access-level modifier above optionally accepts a single argument, which consists of the &lt;c0&gt;&lt;s1&gt;set&lt;/s1&gt;&lt;/c0&gt; keyword enclosed in parentheses (for example, &lt;c2&gt;&lt;s3&gt;private(set)&lt;/s3&gt;&lt;/c2&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上記のそれぞれのアクセス水準修飾子は、任意に１つだけの引数を受け入れます、それは丸括弧に囲まれたキーワード&lt;c0&gt;&lt;s1&gt;set&lt;/s1&gt;&lt;/c0&gt;からなります（例えば、&lt;c2&gt;&lt;s3&gt;private(set)&lt;/s3&gt;&lt;/c2&gt;）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each approach is described in a section below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各取り組みは、以下の節で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each barcode has a number system digit, followed by five manufacturer code digits and five product code digits.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各バーコードは、１つの「ナンバーシステム」桁、それに続く５桁の「製造者コード」そして５桁の「商品コード」を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each build target (such as an app bundle or framework) in Xcode is treated as a separate module in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Xcodeでの各ビルドターゲット（例えばアプリ・バンドルまたはフレームワーク）は、スウィフトにおいて別々のモジュールとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each case can also specify that it stores values of a given type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各ケース節は、また、それが特定の型の値を格納することを示すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each case must have a unique name and be assigned a unique raw value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれのケース節は、固有な名前を持ち固有な生の値を割り当てられなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each channel has an integer audio level between &lt;c0&gt;&lt;s1&gt;0&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;10&lt;/s3&gt;&lt;/c2&gt; inclusive.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各チャンネルは、&lt;c0&gt;&lt;s1&gt;0&lt;/s1&gt;&lt;/c0&gt;から&lt;c2&gt;&lt;s3&gt;10&lt;/s3&gt;&lt;/c2&gt;を含むまでの整数オーディオ・レベルがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each element of the tuple can be tested against a different value or interval of values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプルの各要素は、ある異なる値または値の区間に対して試験されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each enumeration definition defines a new type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各列挙定義は、ある新しい型を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each example below shows a different representation of the following string, which is made up of the characters &lt;c0&gt;&lt;s1&gt;D&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;o&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;g&lt;/s5&gt;&lt;/c4&gt;, &lt;c6&gt;&lt;s7&gt;‼&lt;/s7&gt;&lt;/c6&gt; (&lt;c8&gt;&lt;s9&gt;DOUBLE&lt;/s9&gt; &lt;s10&gt;EXCLAMATION&lt;/s10&gt; &lt;s11&gt;MARK&lt;/s11&gt;&lt;/c8&gt;, or Unicode scalar &lt;c12&gt;&lt;s13&gt;U+203C&lt;/s13&gt;&lt;/c12&gt;), and the 🐶 character (&lt;c14&gt;&lt;s15&gt;DOG&lt;/s15&gt; &lt;s16&gt;FACE&lt;/s16&gt;&lt;/c14&gt;, or Unicode scalar &lt;c17&gt;&lt;s18&gt;U+1F436&lt;/s18&gt;&lt;/c17&gt;):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の各例は、次の文字列の異なる表現を示します、それは文字&lt;c0&gt;&lt;s1&gt;D&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;o&lt;/s3&gt;&lt;/c2&gt;、&lt;c4&gt;&lt;s5&gt;g&lt;/s5&gt;&lt;/c4&gt;、&lt;c6&gt;&lt;s7&gt;‼&lt;/s7&gt;&lt;/c6&gt;（&lt;c8&gt;&lt;s9&gt;DOUBLE&lt;/s9&gt; &lt;s10&gt;EXCLAMATION&lt;/s10&gt; &lt;s11&gt;MARK&lt;/s11&gt;&lt;/c8&gt;、またはユニコードスカラー&lt;c12&gt;&lt;s13&gt;U+203C&lt;/s13&gt;&lt;/c12&gt;）、そして🐶文字（&lt;c14&gt;&lt;s15&gt;DOG&lt;/s15&gt; &lt;s16&gt;FACE&lt;/s16&gt;&lt;/c14&gt;またはユニコードスカラー&lt;c17&gt;&lt;s18&gt;U+1F436&lt;/s18&gt;&lt;/c17&gt;）から成ります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each expression can have an optional identifier before it, separated by a colon (&lt;c1&gt;&lt;s2&gt;:&lt;/s2&gt;&lt;/c1&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各式はそれの前に、コロン（&lt;c1&gt;&lt;s2&gt;:&lt;/s2&gt;&lt;/c1&gt;）で区切られる任意の識別子を持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each form encodes the string in small chunks known as &lt;e1&gt;code units&lt;/e1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各方式は、文字列を、&lt;e1&gt;符号単位&lt;/e1&gt;として知られている小さいかたまりで符号化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each function parameter has both an &lt;e0&gt;argument label&lt;/e0&gt; and a &lt;e1&gt;parameter name&lt;/e1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数パラメーターそれぞれは、&lt;e0&gt;引数ラベル&lt;/e0&gt;と&lt;e1&gt;パラメーター名&lt;/e1&gt;の両方を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each identifier in a tuple expression must be unique within the scope of the tuple expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるタプル式の中の各識別子は、そのタプル式のスコープ内で特有でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each instance of &lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt; has a single stored property called &lt;c2&gt;&lt;s3&gt;fullName&lt;/s3&gt;&lt;/c2&gt;, which is of type &lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt;の各インスタンスは、&lt;c2&gt;&lt;s3&gt;fullName&lt;/s3&gt;&lt;/c2&gt;と呼ばれる１つの格納プロパティを持ちます、それは、型&lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each item in a capture list is a pairing of the &lt;c0&gt;&lt;s1&gt;weak&lt;/s1&gt;&lt;/c0&gt; or &lt;c2&gt;&lt;s3&gt;unowned&lt;/s3&gt;&lt;/c2&gt; keyword with a reference to a class instance (such as &lt;c4&gt;&lt;s5&gt;self&lt;/s5&gt;&lt;/c4&gt;) or a variable initialized with some value (such as &lt;c6&gt;&lt;s7&gt;delegate&lt;/s7&gt; &lt;s8&gt;=&lt;/s8&gt; &lt;s9&gt;self.delegate&lt;/s9&gt;&lt;/c6&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>捕獲リストの各項目は、&lt;c0&gt;&lt;s1&gt;weak&lt;/s1&gt;&lt;/c0&gt;または&lt;c2&gt;&lt;s3&gt;unowned&lt;/s3&gt;&lt;/c2&gt;キーワードと、クラスインスタンスへの参照（例えば&lt;c4&gt;&lt;s5&gt;self&lt;/s5&gt;&lt;/c4&gt;）またはなんらかの値で初期化された変数（例えば&lt;c6&gt;&lt;s7&gt;delegate&lt;/s7&gt; &lt;s8&gt;=&lt;/s8&gt; &lt;s9&gt;self.delegate&lt;/s9&gt;&lt;/c6&gt;）を対にしたものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each item in a protocol composition list is one of the following; the list can contain at most one class:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル合成リストの各項目は以下のうちの１つです；リストは最大１つのクラスを含むことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each item in the dictionary is returned as a &lt;c0&gt;&lt;s1&gt;(key,&lt;/s1&gt; &lt;s2&gt;value)&lt;/s2&gt;&lt;/c0&gt; tuple when the dictionary is iterated, and you can decompose the &lt;c3&gt;&lt;s4&gt;(key,&lt;/s4&gt; &lt;s5&gt;value)&lt;/s5&gt;&lt;/c3&gt; tuple’s members as explicitly named constants for use within the body of the &lt;c6&gt;&lt;s7&gt;for&lt;/s7&gt;&lt;/c6&gt;-&lt;c8&gt;&lt;s9&gt;in&lt;/s9&gt;&lt;/c8&gt; loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書の中の各項目は、辞書が繰り返されるとき、&lt;c0&gt;&lt;s1&gt;(key,&lt;/s1&gt; &lt;s2&gt;value)&lt;/s2&gt;&lt;/c0&gt;タプルとして返されます、そしてあなたは&lt;c3&gt;&lt;s4&gt;(key,&lt;/s4&gt; &lt;s5&gt;value)&lt;/s5&gt;&lt;/c3&gt;タプルの構成要素を&lt;c6&gt;&lt;s7&gt;for&lt;/s7&gt;&lt;/c6&gt;-&lt;c8&gt;&lt;s9&gt;in&lt;/s9&gt;&lt;/c8&gt;ループの本文内で使用するわかりやすい名前の定数として分解することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each item in the dictionary is returned as a &lt;c4&gt;&lt;s5&gt;(key,&lt;/s5&gt; &lt;s6&gt;value)&lt;/s6&gt;&lt;/c4&gt; tuple, and you can decompose the tuple’s members into temporary constants or variables as part of the iteration:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書の中の各項目は、&lt;c4&gt;&lt;s5&gt;(key,&lt;/s5&gt; &lt;s6&gt;value)&lt;/s6&gt;&lt;/c4&gt;タプルとして返されます、そしてあなたはタプルの構成要素を一時的な定数または変数に分解することが、この繰り返しの一部として行えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each item that you insert into the string literal is wrapped in a pair of parentheses, prefixed by a backslash (&lt;c3&gt;&lt;s4&gt;\&lt;/s4&gt;&lt;/c3&gt;):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがリテラル文字列に差し込む各項目は、一対の丸括弧に包まれて、バックスラッシュ（&lt;c3&gt;&lt;s4&gt;\&lt;/s4&gt;&lt;/c3&gt;）を前に置かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each kind of expression is described in detail in the sections below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各種類の式は、以下の節において詳細に記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each of the comparison operators returns a &lt;c0&gt;&lt;s1&gt;Bool&lt;/s1&gt;&lt;/c0&gt; value to indicate whether or not the statement is true:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれの比較演算子は、&lt;c0&gt;&lt;s1&gt;Bool&lt;/s1&gt;&lt;/c0&gt;値を返して、その文が真かどうかを指し示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each of these key-path components can be repeated as many times as needed, in any order.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらキーパス構成要素のそれぞれは、必要なだけ、任意の順序で、何度も繰り返されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each pair of characters in a hexadecimal number uses 8 bits, so a move 16 places to the right will convert &lt;c3&gt;&lt;s4&gt;0xCC0000&lt;/s4&gt;&lt;/c3&gt; into &lt;c5&gt;&lt;s6&gt;0x0000CC&lt;/s6&gt;&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>16進数の中の文字の各ペアは８ビットを使うので、右への16桁の移動は&lt;c3&gt;&lt;s4&gt;0xCC0000&lt;/s4&gt;&lt;/c3&gt;を&lt;c5&gt;&lt;s6&gt;0x0000CC&lt;/s6&gt;&lt;/c5&gt;へと変えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each player has a certain number of coins stored in their purse at any time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各々のプレーヤーは、特定の数のコインをいつでもかれらの財布に保管しておきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each position in the matrix is given an initial value of &lt;c12&gt;&lt;s13&gt;0.0&lt;/s13&gt;&lt;/c12&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>行列の中の各位置は、&lt;c12&gt;&lt;s13&gt;0.0&lt;/s13&gt;&lt;/c12&gt;の初期値を与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each raw value must be unique within its enumeration declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>生の値それぞれは、その列挙宣言の範囲内で固有でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each statement in the body of a conditional compilation block is parsed even if it’s not compiled.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>条件コンパイルブロックの本文中の各文は、たとえそれがコンパイルされなくとも、構文解析されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each time &lt;c5&gt;&lt;s6&gt;swapTwoValues(_:_:)&lt;/s6&gt;&lt;/c5&gt; is called, the type to use for &lt;c7&gt;&lt;s8&gt;T&lt;/s8&gt;&lt;/c7&gt; is inferred from the types of values passed to the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c5&gt;&lt;s6&gt;swapTwoValues(_:_:)&lt;/s6&gt;&lt;/c5&gt;が呼ばれるたびに、&lt;c7&gt;&lt;s8&gt;T&lt;/s8&gt;&lt;/c7&gt;のために使われる型は関数に渡される値の型から推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each time through the &lt;c4&gt;&lt;s5&gt;while&lt;/s5&gt;&lt;/c4&gt; loop, &lt;c6&gt;&lt;s7&gt;diceRoll&lt;/s7&gt;&lt;/c6&gt; is incremented by one and is then checked to see whether it has become too large.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>毎回&lt;c4&gt;&lt;s5&gt;while&lt;/s5&gt;&lt;/c4&gt;ループの間、&lt;c6&gt;&lt;s7&gt;diceRoll&lt;/s7&gt;&lt;/c6&gt;は１増やされて、それからそれが大きくなりすぎていないか調べられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each turn, you roll a six-sided dice and move by that number of squares, following the horizontal path indicated by the dotted arrow above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>順番になるたび、あなたは六面のさいころを転がします、そしてその数だけ正方形を移動します、上の点線の矢印で示される水平移動の経路をたどっていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each type argument must satisfy all the constraints of the generic parameter it replaces, including any additional requirements specified in a generic &lt;c14&gt;&lt;s15&gt;where&lt;/s15&gt;&lt;/c14&gt; clause.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各型引数は、それが置き換える総称体パラメータの全ての制約を、総称体&lt;c14&gt;&lt;s15&gt;where&lt;/s15&gt;&lt;/c14&gt;節で指定される任意の追加の要件を含めて、満たさなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each type method is explicitly scoped to the type it supports.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各型メソッドは、当然ながらそれが支える型にスコープを指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each unassigned case of type &lt;c8&gt;&lt;s9&gt;Int&lt;/s9&gt;&lt;/c8&gt; is implicitly assigned a raw value that is automatically incremented from the raw value of the previous case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型&lt;c8&gt;&lt;s9&gt;Int&lt;/s9&gt;&lt;/c8&gt;の未割り当てのケース節それぞれは、暗黙のうちに生の値を割り当てられます、それは、前のケース節の生の値から自動的に増やされたものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each value is associated with a unique &lt;e1&gt;key&lt;/e1&gt;, which acts as an identifier for that value within the dictionary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各値は固有の&lt;e1&gt;キー&lt;/e1&gt;と結び付けられます、そして、それはその辞書の内部でその値のために識別子の働きをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Early Exit</seg>
      </tuv>
      <tuv lang="JA">
        <seg>早期退出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Effectively, the addition and the assignment are combined into one operator that performs both tasks at the same time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実質的に、加算と代入は１つの演算子に結合され、同時に両方の作業を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Effectively, they are just two different names for the same single instance, as shown in the figure below:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>事実上、それらは同じ１つのインスタンスに対する単なる２つの異なる名前です、以下の図で示されるように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Empty array literals are written using an empty pair of square brackets and can be used to create an empty array of a specified type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>空の配列リテラルは、空の角括弧の対を使って書かれて、指定された型の空の配列をつくるために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enforcing Preconditions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>前提条件の遵守</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Entities in the imported module that are marked with the &lt;c2&gt;&lt;s3&gt;internal&lt;/s3&gt;&lt;/c2&gt; access-level modifier are imported as if they were declared with the &lt;c4&gt;&lt;s5&gt;public&lt;/s5&gt;&lt;/c4&gt; access-level modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;internal&lt;/s3&gt;&lt;/c2&gt;アクセス水準修飾子で印されるインポートされたモジュールの中の存在それらは、まるでそれらが&lt;c4&gt;&lt;s5&gt;public&lt;/s5&gt;&lt;/c4&gt;アクセス水準修飾子で宣言されたかのようにインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumeration Case Pattern</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙ケース節パターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumeration Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumeration Syntax</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumeration Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumeration case patterns appear in &lt;c1&gt;&lt;s2&gt;switch&lt;/s2&gt;&lt;/c1&gt; statement case labels and in the case conditions of &lt;c3&gt;&lt;s4&gt;if&lt;/s4&gt;&lt;/c3&gt;, &lt;c5&gt;&lt;s6&gt;while&lt;/s6&gt;&lt;/c5&gt;, &lt;c7&gt;&lt;s8&gt;guard&lt;/s8&gt;&lt;/c7&gt;, and &lt;c9&gt;&lt;s10&gt;for&lt;/s10&gt;&lt;/c9&gt;-&lt;c11&gt;&lt;s12&gt;in&lt;/s12&gt;&lt;/c11&gt; statements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙ケース節パターンは、&lt;c1&gt;&lt;s2&gt;switch&lt;/s2&gt;&lt;/c1&gt;文のケース節ラベル（ケース節表記）において、そして&lt;c3&gt;&lt;s4&gt;if&lt;/s4&gt;&lt;/c3&gt;、&lt;c5&gt;&lt;s6&gt;while&lt;/s6&gt;&lt;/c5&gt;、&lt;c7&gt;&lt;s8&gt;guard&lt;/s8&gt;&lt;/c7&gt;、および&lt;c9&gt;&lt;s10&gt;for&lt;/s10&gt;&lt;/c9&gt;-&lt;c11&gt;&lt;s12&gt;in&lt;/s12&gt;&lt;/c11&gt;文のケース節条件において現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumeration case values without associated values (as described in &lt;a8&gt;&lt;s9&gt;Enumerations&lt;/s9&gt;&lt;/a8&gt;) are also hashable by default.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連値なしでの列挙ケース節の値（&lt;a8&gt;&lt;s9&gt;列挙&lt;/s9&gt;&lt;/a8&gt;で記述されます）もまた、そのままでハッシュ化できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumeration cases that store associated values can be used as functions that create instances of the enumeration with the specified associated values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連値を格納する列挙ケース節は、関数として使われることができ、それは指定された関連値を持つその列挙のインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumeration declarations can’t contain deinitializer or protocol declarations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙宣言は、デイニシャライザまたはプロトコル宣言を含むことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumeration declarations have two basic forms and are declared using the &lt;c0&gt;&lt;s1&gt;enum&lt;/s1&gt;&lt;/c0&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙宣言は、２つの基本の形式を持ち、キーワード&lt;c0&gt;&lt;s1&gt;enum&lt;/s1&gt;&lt;/c0&gt;を使って宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumeration types can adopt any number of protocols, but can’t inherit from classes, structures, or other enumerations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙型は、任意の数のプロトコルに準拠することができます、しかしクラス、構造体、または他の列挙から継承することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations and Structures</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙と構造体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations are often created to support a specific class or structure’s functionality.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙は、特定のクラスまたは構造体の機能性を支えるためにたびたびつくられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations can also define initializers to provide an initial case value; can be extended to expand their functionality beyond their original implementation; and can conform to protocols to provide standard functionality.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙は、さらに、最初のケース節値を提供するためにイニシャライザを定義することができます；それらの本来の実装を越えてそれらの機能性を広げるために拡張されることができます；そして、標準の機能性を提供するためにプロトコルに準拠することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations can have a recursive structure, that is, they can have cases with associated values that are instances of the enumeration type itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙は、再帰構造を持つことができます、すなわち、それは、その列挙型それ自身のインスタンスである関連値を伴うケース節を持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations declared in this form are sometimes called &lt;e0&gt;discriminated unions&lt;/e0&gt; in other programming languages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この形式で宣言される列挙は、時として他のプログラミング言語では&lt;e0&gt;判別共用体&lt;/e0&gt;と呼ばれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations in Swift are first-class types in their own right.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの列挙は、れっきとした第一級の型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations in Swift are much more flexible, and don’t have to provide a value for each case of the enumeration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの列挙は、ずっと柔軟で、列挙のケース節の各々に値を与える必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations similar to these are known as &lt;e0&gt;discriminated unions&lt;/e0&gt;, &lt;e1&gt;tagged unions&lt;/e1&gt;, or &lt;e2&gt;variants&lt;/e2&gt; in other programming languages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これに似ている列挙は、他のプログラミング言語で&lt;e0&gt;判別共用体&lt;/e0&gt;、&lt;e1&gt;タグ付き共用体&lt;/e1&gt;、または&lt;e2&gt;バリアント&lt;/e2&gt;として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations that have cases of a raw-value type implicitly conform to the &lt;c0&gt;&lt;s1&gt;RawRepresentable&lt;/s1&gt;&lt;/c0&gt; protocol, defined in the Swift standard library.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「生の値」型のケース節を持つ列挙は、スウィフト標準ライブラリで定義される&lt;c0&gt;&lt;s1&gt;RawRepresentable&lt;/s1&gt;&lt;/c0&gt;プロトコルに暗黙的に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations that have no associated types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連型を持たない列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations that have only associated types that conform to the &lt;c0&gt;&lt;s1&gt;Equatable&lt;/s1&gt;&lt;/c0&gt; protocol</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Equatable&lt;/s1&gt;&lt;/c0&gt;プロトコルに準拠する関連型だけを持つ列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations with Cases of Any Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>随意の型のケース節をもつ列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations with Cases of a Raw-Value Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「生の値」型のケース節を持つ列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations with Indirection</seg>
      </tuv>
      <tuv lang="JA">
        <seg>間接参照を持つ列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations with raw values automatically receive a failable initializer, &lt;c0&gt;&lt;s1&gt;init?(rawValue:)&lt;/s1&gt;&lt;/c0&gt;, that takes a parameter called &lt;c2&gt;&lt;s3&gt;rawValue&lt;/s3&gt;&lt;/c2&gt; of the appropriate raw-value type and selects a matching enumeration case if one is found, or triggers an initialization failure if no matching value exists.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>生の値を持つ列挙は、自動的にひとつの失敗できるイニシャライザ、&lt;c0&gt;&lt;s1&gt;init?(rawValue:)&lt;/s1&gt;&lt;/c0&gt;を受け取ります、それは、適切な「生の値」型の&lt;c2&gt;&lt;s3&gt;rawValue&lt;/s3&gt;&lt;/c2&gt;と呼ばれるパラメータを取って、適合する列挙ケース節をそれが見つかったならば選択します、または適合する値が存在しないならば初期化失敗を引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enumerations with raw values now have a &lt;c0&gt;&lt;s1&gt;rawValue&lt;/s1&gt;&lt;/c0&gt; property rather than a &lt;c2&gt;&lt;s3&gt;toRaw()&lt;/s3&gt;&lt;/c2&gt; method and a failable initializer with a &lt;c4&gt;&lt;s5&gt;rawValue&lt;/s5&gt;&lt;/c4&gt; parameter rather than a &lt;c6&gt;&lt;s7&gt;fromRaw()&lt;/s7&gt;&lt;/c6&gt; method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>生の値を持つ列挙は、今では&lt;c2&gt;&lt;s3&gt;toRaw()&lt;/s3&gt;&lt;/c2&gt;メソッドではなく&lt;c0&gt;&lt;s1&gt;rawValue&lt;/s1&gt;&lt;/c0&gt;プロパティを、そして&lt;c6&gt;&lt;s7&gt;fromRaw()&lt;/s7&gt;&lt;/c6&gt;メソッドではなく&lt;c4&gt;&lt;s5&gt;rawValue&lt;/s5&gt;&lt;/c4&gt;パラメーターを使う失敗できるイニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Equal to (&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt; &lt;s2&gt;==&lt;/s2&gt; &lt;s3&gt;b&lt;/s3&gt;&lt;/c0&gt;)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同等である (&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt; &lt;s2&gt;==&lt;/s2&gt; &lt;s3&gt;b&lt;/s3&gt;&lt;/c0&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Equivalence Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>等価演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Error Handling</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーの処理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Error handling allows controlled recovery from unexpected failures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラー処理が、予期せぬ失敗からの制御された復旧を可能にする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Error handling in Swift interoperates with error handling patterns that use the &lt;c0&gt;&lt;s1&gt;NSError&lt;/s1&gt;&lt;/c0&gt; class in Cocoa and Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでのエラー処理は、CocoaとObjective-Cでの&lt;c0&gt;&lt;s1&gt;NSError&lt;/s1&gt;&lt;/c0&gt;クラスを使うエラー処理パターンと相互運用性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Error handling in Swift resembles exception handling in other languages, with the use of the &lt;c0&gt;&lt;s1&gt;try&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;catch&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;throw&lt;/s5&gt;&lt;/c4&gt; keywords.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおけるエラー処理は、&lt;c0&gt;&lt;s1&gt;try&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;catch&lt;/s3&gt;&lt;/c2&gt;、そして&lt;c4&gt;&lt;s5&gt;throw&lt;/s5&gt;&lt;/c4&gt;キーワードの使用とともに、他の言語での例外処理に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Escaping Closures</seg>
      </tuv>
      <tuv lang="JA">
        <seg>脱出クロージャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evaluating an expression returns a value, causes a side effect, or both.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある式を評価することは、ひとつの値を返す、ある副作用を引き起こす、あるいはその両方です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even if your source file has a mix of carriage returns and line feeds, all of the line breaks in the string will be the same.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえあなたのソースファイルがキャリッジリターンとラインフィードの混合を持つとしても、文字列の中のラインブレークの全ては同じになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even on 32-bit platforms, &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt; can store any value between &lt;c4&gt;&lt;s5&gt;-2,147,483,648&lt;/s5&gt;&lt;/c4&gt; and &lt;c6&gt;&lt;s7&gt;2,147,483,647&lt;/s7&gt;&lt;/c6&gt;, and is large enough for many integer ranges.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>32ビットのプラットホーム上でさえ、&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;は&lt;c4&gt;&lt;s5&gt;-2,147,483,648&lt;/s5&gt;&lt;/c4&gt;と&lt;c6&gt;&lt;s7&gt;2,147,483,647&lt;/s7&gt;&lt;/c6&gt;の間のどんな値でも格納することができ、多くの整数範囲のために十分に大きいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though &lt;c0&gt;&lt;s1&gt;Rank&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;Suit&lt;/s3&gt;&lt;/c2&gt; are nested within &lt;c4&gt;&lt;s5&gt;BlackjackCard&lt;/s5&gt;&lt;/c4&gt;, their type can be inferred from context, and so the initialization of this instance is able to refer to the enumeration cases by their case names (&lt;c6&gt;&lt;s7&gt;.ace&lt;/s7&gt;&lt;/c6&gt; and &lt;c8&gt;&lt;s9&gt;.spades&lt;/s9&gt;&lt;/c8&gt;) alone.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえ&lt;c0&gt;&lt;s1&gt;Rank&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;Suit&lt;/s3&gt;&lt;/c2&gt;が&lt;c4&gt;&lt;s5&gt;BlackjackCard&lt;/s5&gt;&lt;/c4&gt;内部に入れ子にされるとしても、それらの型は前後関係から推論されることができます、なのでこのインスタンスの初期化は、列挙ケース節を参照することがもっぱらそれらのケース節名（&lt;c6&gt;&lt;s7&gt;.ace&lt;/s7&gt;&lt;/c6&gt;と&lt;c8&gt;&lt;s9&gt;.spades&lt;/s9&gt;&lt;/c8&gt;）のみによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though &lt;c0&gt;&lt;s1&gt;RecipeIngredient&lt;/s1&gt;&lt;/c0&gt; provides the &lt;c2&gt;&lt;s3&gt;init(name:&lt;/s3&gt; &lt;s4&gt;String)&lt;/s4&gt;&lt;/c2&gt; initializer as a convenience initializer, &lt;c5&gt;&lt;s6&gt;RecipeIngredient&lt;/s6&gt;&lt;/c5&gt; has nonetheless provided an implementation of all of its superclass’s designated initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえ&lt;c0&gt;&lt;s1&gt;RecipeIngredient&lt;/s1&gt;&lt;/c0&gt;が便宜イニシャライザとして&lt;c2&gt;&lt;s3&gt;init(name:&lt;/s3&gt; &lt;s4&gt;String)&lt;/s4&gt;&lt;/c2&gt;イニシャライザを提供するとしても、&lt;c5&gt;&lt;s6&gt;RecipeIngredient&lt;/s6&gt;&lt;/c5&gt;はそれでもやはりそれのスーパークラスの指定イニシャライザの全ての実装を提供しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though &lt;c9&gt;&lt;s10&gt;hd&lt;/s10&gt;&lt;/c9&gt; and &lt;c11&gt;&lt;s12&gt;cinema&lt;/s12&gt;&lt;/c11&gt; now have the same width and height, they are two completely different instances behind the scenes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえ&lt;c9&gt;&lt;s10&gt;hd&lt;/s10&gt;&lt;/c9&gt;と&lt;c11&gt;&lt;s12&gt;cinema&lt;/s12&gt;&lt;/c11&gt;が現在同じ幅と高さを持つとしても、それらは舞台裏では２つの完全に異なるインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though the &lt;c6&gt;&lt;s7&gt;text&lt;/s7&gt;&lt;/c6&gt; property is now a constant, it can still be set within the class’s initializer:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえ&lt;c6&gt;&lt;s7&gt;text&lt;/s7&gt;&lt;/c6&gt;プロパティが今や定数であるとしても、それはクラスのイニシャライザの内部ではまだ設定されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though the closure refers to &lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt; multiple times, it only captures one strong reference to the &lt;c2&gt;&lt;s3&gt;HTMLElement&lt;/s3&gt;&lt;/c2&gt; instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえクロージャが複数回&lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;に言及するとしても、それはその&lt;c2&gt;&lt;s3&gt;HTMLElement&lt;/s3&gt;&lt;/c2&gt;インスタンスへの１つの強い参照を捕獲するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though the first element of the &lt;c0&gt;&lt;s1&gt;customersInLine&lt;/s1&gt;&lt;/c0&gt; array is removed by the code inside the closure, the array element isn’t removed until the closure is actually called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえ&lt;c0&gt;&lt;s1&gt;customersInLine&lt;/s1&gt;&lt;/c0&gt;配列の最初の要素がクロージャ内部のコードによって取り除かれるとしても、その配列要素はクロージャが実際に呼び出されるまで実行されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though the stack and the array are of a different type, they both conform to the &lt;c6&gt;&lt;s7&gt;Container&lt;/s7&gt;&lt;/c6&gt; protocol, and both contain the same type of values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえスタックと配列が異なる型であるとしても、それらは両方とも&lt;c6&gt;&lt;s7&gt;Container&lt;/s7&gt;&lt;/c6&gt;プロトコルに準拠して、両方とも同じ型の値を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though the two write accesses overlap in time, they don’t conflict.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえ２つの書き込みアクセスが時間内にオーバーラップしても、それらは衝突しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though the variable &lt;c0&gt;&lt;s1&gt;protocolValue&lt;/s1&gt;&lt;/c0&gt; has a runtime type of &lt;c2&gt;&lt;s3&gt;SimpleClass&lt;/s3&gt;&lt;/c2&gt;, the compiler treats it as the given type of &lt;c4&gt;&lt;s5&gt;ExampleProtocol&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえ変数&lt;c0&gt;&lt;s1&gt;protocolValue&lt;/s1&gt;&lt;/c0&gt;が実行時の型として&lt;c2&gt;&lt;s3&gt;SimpleClass&lt;/s3&gt;&lt;/c2&gt;を持つとしても、コンパイラはそれを与えられた型&lt;c4&gt;&lt;s5&gt;ExampleProtocol&lt;/s5&gt;&lt;/c4&gt;とみなします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though there are two optional chaining operations, one after another, the result is still wrapped in a single optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえ２つのオプショナル連鎖演算があったとしても、後から後から、その結果は依然としてただ１つのオプショナルの中にラップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even though you don’t write an explicit getter and setter for a stored property, Swift still synthesizes an implicit getter and setter for you to provide access to the stored property’s backing storage.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえあなたが格納プロパティのために明確なゲッターとセッターを書かないとしても、スウィフトは格納プロパティのもつ支援外部記憶へのアクセスを提供するためにあなたのためにまだ暗黙のゲッターとセッターを総合的に扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every &lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt; instance has a &lt;c2&gt;&lt;s3&gt;name&lt;/s3&gt;&lt;/c2&gt; property of type &lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt; and an optional &lt;c6&gt;&lt;s7&gt;apartment&lt;/s7&gt;&lt;/c6&gt; property that is initially &lt;c8&gt;&lt;s9&gt;nil&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あらゆる&lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt;インスタンスは、型&lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt;の&lt;c2&gt;&lt;s3&gt;name&lt;/s3&gt;&lt;/c2&gt;プロパティと初期時には&lt;c8&gt;&lt;s9&gt;nil&lt;/s9&gt;&lt;/c8&gt;であるオプショナルの&lt;c6&gt;&lt;s7&gt;apartment&lt;/s7&gt;&lt;/c6&gt;プロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; statement consists of multiple possible &lt;e2&gt;cases&lt;/e2&gt;, each of which begins with the &lt;c3&gt;&lt;s4&gt;case&lt;/s4&gt;&lt;/c3&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あらゆる&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;文は複数の起こりうる&lt;e2&gt;ケース節&lt;/e2&gt;から成ります。そして、それぞれは&lt;c3&gt;&lt;s4&gt;case&lt;/s4&gt;&lt;/c3&gt;キーワードから始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; statement must be &lt;e2&gt;exhaustive&lt;/e2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あらゆる&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;文は、&lt;e2&gt;網羅的&lt;/e2&gt;でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every class must have at least one designated initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あらゆるクラスは、少なくとも１つの指定イニシャライザを持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every conditional compilation block begins with the &lt;c0&gt;&lt;s1&gt;#if&lt;/s1&gt;&lt;/c0&gt; compilation directive and ends with the &lt;c2&gt;&lt;s3&gt;#endif&lt;/s3&gt;&lt;/c2&gt; compilation directive.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべての条件コンパイルブロックは、&lt;c0&gt;&lt;s1&gt;#if&lt;/s1&gt;&lt;/c0&gt;コンパイル指令で始まって、&lt;c2&gt;&lt;s3&gt;#endif&lt;/s3&gt;&lt;/c2&gt;コンパイル指令で終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every function has a &lt;e0&gt;function name&lt;/e0&gt;, which describes the task that the function performs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あらゆる関数は&lt;e0&gt;関数名&lt;/e0&gt;を持ち、それはその関数が実行する作業を形容します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every function has a specific &lt;e0&gt;function type&lt;/e0&gt;, made up of the parameter types and the return type of the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あらゆる関数は特定の&lt;e0&gt;関数型&lt;/e0&gt;を持ちます、それは、その関数のパラメータ型と戻り型から成り立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every function in Swift has a type, consisting of the function’s parameter types and return type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのあらゆる関数は、その関数のパラメータ型と戻り型から成る、ある型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every instance of Swift’s &lt;c0&gt;&lt;s1&gt;Character&lt;/s1&gt;&lt;/c0&gt; type represents a single &lt;e2&gt;extended grapheme cluster&lt;/e2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの&lt;c0&gt;&lt;s1&gt;Character&lt;/s1&gt;&lt;/c0&gt;型の全てのインスタンスは、単一の&lt;e2&gt;拡張書記素クラスタ（房、群）&lt;/e2&gt;を表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every instance of a type has an implicit property called &lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;, which is exactly equivalent to the instance itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型のすべてのインスタンスは、暗黙的に&lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;と呼ばれるプロパティを持ちます、それは、正確にそのインスタンスそれ自身に等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every item in the shopping list starts out as “unpurchased”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>購入品目リストでのあらゆる項目は、「未購入」として始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every property needs a value assigned—either in its declaration (as with &lt;c6&gt;&lt;s7&gt;numberOfSides&lt;/s7&gt;&lt;/c6&gt;) or in the initializer (as with &lt;c8&gt;&lt;s9&gt;name&lt;/s9&gt;&lt;/c8&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あらゆるプロパティは、代入される値を必要とします ― その宣言において（&lt;c6&gt;&lt;s7&gt;numberOfSides&lt;/s7&gt;&lt;/c6&gt;でのように）またはイニシャライザにおいて（&lt;c8&gt;&lt;s9&gt;name&lt;/s9&gt;&lt;/c8&gt;でのように）のどちらでも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every string is composed of encoding-independent Unicode characters, and provides support for accessing those characters in various Unicode representations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あらゆる文字列は、符号化に依存しないUnicode文字から構成されます、そして多彩なUnicode表現においてそのような文字にアクセスするための支援を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every time a player finishes a level, that level is unlocked for all players on the device.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プレーヤーがあるレベルを終了するごとに、そのレベルはその装置上の全てのプレーヤーのために鍵を外されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every time you create a new instance of a class, ARC allocates a chunk of memory to store information about that instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがクラスの新しいインスタンスをつくるたびに、ARCはメモリのある量を割り当てて、そのインスタンスに関する情報を格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every time you create a new instance of that type, it has its own set of property values, separate from any other instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがその型の新しいインスタンスをつくるたびに、それは、他のあらゆるインスタンスから独立した、独自のひと組のプロパティ値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Examples of &lt;a0&gt;&lt;s1&gt;Closure Expressions&lt;/s1&gt;&lt;/a0&gt; now use the global &lt;c2&gt;&lt;s3&gt;sorted(_:_:)&lt;/s3&gt;&lt;/c2&gt; function rather than the global &lt;c4&gt;&lt;s5&gt;sort(_:_:)&lt;/s5&gt;&lt;/c4&gt; function, to reflect the new array value semantics.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;クロージャ式&lt;/s1&gt;&lt;/a0&gt;の例は、現在はグローバルな&lt;c2&gt;&lt;s3&gt;sorted(_:_:)&lt;/s3&gt;&lt;/c2&gt;関数を、グローバルな&lt;c4&gt;&lt;s5&gt;sort(_:_:)&lt;/s5&gt;&lt;/c4&gt;関数のかわりに使用します、それによって新しい配列値意味論を反映します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Executing the last &lt;c2&gt;&lt;s3&gt;defer&lt;/s3&gt;&lt;/c2&gt; statement in a given scope first means that statements inside that last &lt;c4&gt;&lt;s5&gt;defer&lt;/s5&gt;&lt;/c4&gt; statement can refer to resources that will be cleaned up by other &lt;c6&gt;&lt;s7&gt;defer&lt;/s7&gt;&lt;/c6&gt; statements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある特定のスコープ中の最後の&lt;c2&gt;&lt;s3&gt;defer&lt;/s3&gt;&lt;/c2&gt;文の実行が最初であることは、その最後の&lt;c4&gt;&lt;s5&gt;defer&lt;/s5&gt;&lt;/c4&gt;文内の文は別の&lt;c6&gt;&lt;s7&gt;defer&lt;/s7&gt;&lt;/c6&gt;文によってクリーンアップされることになるリソースを参照できるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Execution Does Not Fall Through Cases Implicitly</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実行は暗黙のうちにケース節を抜け落ちません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Execution doesn’t continue to the next case, so there is no need to explicitly break out of the switch at the end of each case’s code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実行は次の条件部分に続かないので、各条件部分のコードの終わりで明示的にスイッチから抜け出す必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Existing bits are moved to the left or right by the requested number of places.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>既存のビットは、左または右へ要請された桁数だけ動かされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Existing instances of a type automatically adopt and conform to a protocol when that conformance is added to the instance’s type in an extension.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型の既存のインスタンスたちは、そのインスタンスの型に拡張の中で準拠が加えられるとき、そのプロトコルを自動的に採用して準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Experiment</seg>
      </tuv>
      <tuv lang="JA">
        <seg>試してください</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Explicit Member Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>明示的メンバー式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Explicit Parentheses</seg>
      </tuv>
      <tuv lang="JA">
        <seg>明確な括弧</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exposing detailed information about the creation of a shape allows types that aren’t meant to be part of the ASCII art module’s public interface to leak out because of the need to state the full return type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある形状の作成についての詳細な情報を露出することは、ASCIIアートモジュールのもつパブリックインターフェイスの一部であることを意図する型それらに漏れ出ていくのを許します、完全な戻り型を公表する必要があるのが原因で。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Expression Pattern</seg>
      </tuv>
      <tuv lang="JA">
        <seg>式パターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Expression patterns appear only in &lt;c1&gt;&lt;s2&gt;switch&lt;/s2&gt;&lt;/c1&gt; statement case labels.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>式パターンは、&lt;c1&gt;&lt;s2&gt;switch&lt;/s2&gt;&lt;/c1&gt;文のケース節ラベルにおいてのみ現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Expressions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extended Grapheme Clusters</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張書記素クラスタ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extended String Delimiters</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張文字列区切り記号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extended grapheme clusters are a flexible way to represent many complex script characters as a single &lt;c0&gt;&lt;s1&gt;Character&lt;/s1&gt;&lt;/c0&gt; value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張書記素クラスタは、多くの複雑な書き方の文字を単一の&lt;c0&gt;&lt;s1&gt;Character&lt;/s1&gt;&lt;/c0&gt;値として表わす適応性に富む方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extended grapheme clusters are canonically equivalent if they have the same linguistic meaning and appearance, even if they’re composed from different Unicode scalars behind the scenes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張書記素クラスタが正準等価であるのは、それらが同じ言語的な意味と外観を持つ場合です、たとえそれらが舞台裏で異なるユニコードスカラーから組み立てられるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extended grapheme clusters can be composed of multiple Unicode scalars.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張書記素クラスタは、多数のユニコード・スカラーから構成される可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extended grapheme clusters enable scalars for enclosing marks (such as &lt;c0&gt;&lt;s1&gt;COMBINING&lt;/s1&gt; &lt;s2&gt;ENCLOSING&lt;/s2&gt; &lt;s3&gt;CIRCLE&lt;/s3&gt;&lt;/c0&gt;, or &lt;c4&gt;&lt;s5&gt;U+20DD&lt;/s5&gt;&lt;/c4&gt;) to enclose other Unicode scalars as part of a single &lt;c6&gt;&lt;s7&gt;Character&lt;/s7&gt;&lt;/c6&gt; value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張書記素クラスタは、囲み記号としてのスカラー（&lt;c0&gt;&lt;s1&gt;COMBINING&lt;/s1&gt; &lt;s2&gt;ENCLOSING&lt;/s2&gt; &lt;s3&gt;CIRCLE&lt;/s3&gt;&lt;/c0&gt;、または&lt;c4&gt;&lt;s5&gt;U+20DD&lt;/s5&gt;&lt;/c4&gt;）を可能にして、単一の&lt;c6&gt;&lt;s7&gt;Character&lt;/s7&gt;&lt;/c6&gt;値の一部として他のユニコード・スカラーを囲み入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extending a Generic Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体型を拡張する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extending an Existing Type to Specify an Associated Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>既存の型を拡張して関連型を指定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extending existing types to provide initializers that accept new types (including your own type definitions) is covered in &lt;a13&gt;&lt;s14&gt;Extensions&lt;/s14&gt;&lt;/a13&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい型（あなた独自の型定義を含む）を受け入れるイニシャライザを提供するように既存の型を拡張することは、&lt;a13&gt;&lt;s14&gt;「拡張」&lt;/s14&gt;&lt;/a13&gt;で扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extension Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extension Syntax</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extension declarations are declared using the &lt;c1&gt;&lt;s2&gt;extension&lt;/s2&gt;&lt;/c1&gt; keyword and have the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張宣言は、キーワード&lt;c1&gt;&lt;s2&gt;extension&lt;/s2&gt;&lt;/c1&gt;キーワードを使って宣言され、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extension declarations can add protocol conformance to an existing class, structure, or enumeration type by specifying &lt;e0&gt;adopted protocols&lt;/e0&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張宣言は、プロトコル準拠を既存のクラス、構造体、または列挙型に加えることが&lt;e0&gt;adopted protocols 採用プロトコル&lt;/e0&gt;を指定することによって可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extension declarations can contain initializer declarations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張宣言は、イニシャライザ宣言を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extension declarations can’t add class inheritance to an existing class, and therefore you can specify only a list of protocols after the &lt;e0&gt;type name&lt;/e0&gt; and colon.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張宣言は、クラス継承を既存のクラスに加えることができません、従ってあなたは幾らかのプロトコルからなるリストのみを&lt;e0&gt;type name 型名&lt;/e0&gt;とコロンの後に指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extension declarations can’t contain deinitializer or protocol declarations, stored properties, property observers, or other extension declarations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張宣言は、デイニシャライザまたはプロトコル宣言、格納プロパティ、プロパティオブザーバー、または他の拡張宣言を含むことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extension declarations that extend a generic type or a protocol with associated types can include &lt;e0&gt;requirements&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体型またはプロトコルを関連型で拡張する拡張宣言は、&lt;e0&gt;requirements いくつかの要件&lt;/e0&gt;を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions are similar to categories in Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張は、Objective-Cでのカテゴリーに似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions can add computed instance properties and computed type properties to existing types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張は、既存の型に計算インスタンスプロパティと計算型プロパティを加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions can add new computed properties, but they cannot add stored properties, or add property observers to existing properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張は新しい計算プロパティを加えることができます、しかし、それは格納プロパティを加えることができません、またプロパティオブザーバーを既存のプロパティに加えることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions can add new convenience initializers to a class, but they cannot add new designated initializers or deinitializers to a class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張は、新しい便利なイニシャライザをクラスに加えることができます、しかし、それは新しい指定イニシャライザまたはデイニシャライザをクラスに加えることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions can add new functionality to a type, but they cannot override existing functionality.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張は、新しい機能性をある型に加えることができます、しかしそれは既存の機能性をオーバーライドすることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions can add new initializers to existing types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張は、新しいイニシャライザを既存の型に加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions can add new instance methods and type methods to existing types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張は、新しいインスタンスメソッドと型メソッドを既存の型に加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions can add new nested types to existing classes, structures, and enumerations:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張は、新しい入れ子にされた型を既存のクラス、構造体、および列挙に加えることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions can add new properties, methods, and subscripts to an existing type, and are therefore able to add any requirements that a protocol may demand.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張は、新しいプロパティ、メソッド、そして添え字を既存の型に加えることができます、したがって、あるプロトコルが要求するであろうどんな要件でも加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions can add new subscripts to an existing type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張は、新しい添え字を既存の型に加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions in Swift can:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの拡張は、以下が可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions of a generic type can also include requirements that instances of the extended type must satisfy in order to gain the new functionality, as discussed in &lt;a0&gt;&lt;s1&gt;Extensions with a Generic Where Clause&lt;/s1&gt;&lt;/a0&gt; below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある総称体型のそれぞれの拡張はまた、拡張された型のインスタンスが新しい機能性を獲得する手段として満たさなければならない要件を含むことができます、下の&lt;a0&gt;&lt;s1&gt;総称体where節を持つ拡張&lt;/s1&gt;&lt;/a0&gt;で議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions that add protocol conformance to a structure, enumeration, or class use the same keyword as the type they extend uses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル準拠を構造体、列挙、またはクラスに加える拡張それらは、同じキーワードをそれらが利用を拡張するところの型として使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions that are in the same file as the class, structure, or enumeration that they extend behave as if the code in the extension had been written as part of the original type’s declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが拡張するクラス、構造体、または列挙と同じファイルの中にある拡張は、まるでその拡張の中のコードがオリジナルの型の持つ宣言の一部として書かれたかのように振る舞います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions that provide a default implementation for a static subscript requirement use the &lt;c8&gt;&lt;s9&gt;static&lt;/s9&gt;&lt;/c8&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>静的添え字要件に省略時の実装を提供する拡張は、&lt;c8&gt;&lt;s9&gt;static&lt;/s9&gt;&lt;/c8&gt;キーワードを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions that provide a default implementation for a type method requirement use the &lt;c8&gt;&lt;s9&gt;static&lt;/s9&gt;&lt;/c8&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型メソッド要件に省略時の実装を提供する拡張は、&lt;c8&gt;&lt;s9&gt;static&lt;/s9&gt;&lt;/c8&gt;キーワードを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions that provide a default implementation for a type property requirement use the &lt;c8&gt;&lt;s9&gt;static&lt;/s9&gt;&lt;/c8&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型プロパティ要件に省略時の実装を提供する拡張は、&lt;c8&gt;&lt;s9&gt;static&lt;/s9&gt;&lt;/c8&gt;キーワードを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensions with a Generic Where Clause</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体where節を持つ拡張</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Failable Initializer Requirements</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できるイニシャライザ要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Failable Initializers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できるイニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Failable Initializers for Enumerations</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙のための失敗できるイニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Failable Initializers for Enumerations with Raw Values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>生の値を使う列挙のための失敗できるイニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fallthrough</seg>
      </tuv>
      <tuv lang="JA">
        <seg>抜け落ちる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fallthrough Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>フォールスルー文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, &lt;c0&gt;&lt;s1&gt;Residence&lt;/s1&gt;&lt;/c0&gt; defines an optional property called &lt;c2&gt;&lt;s3&gt;address&lt;/s3&gt;&lt;/c2&gt;, with a type of &lt;c4&gt;&lt;s5&gt;Address?&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最終的に、&lt;c0&gt;&lt;s1&gt;Residence&lt;/s1&gt;&lt;/c0&gt;は&lt;c2&gt;&lt;s3&gt;address&lt;/s3&gt;&lt;/c2&gt;と呼ばれるオプショナルのプロパティを、&lt;c4&gt;&lt;s5&gt;Address?&lt;/s5&gt;&lt;/c4&gt;の型で定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, any convenience initializers in the chain have the option to customize the instance and to work with &lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最後に、連鎖の中のあらゆる便宜イニシャライザは、インスタンスを好みに合わせて作り変えるために、&lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;を扱うために選択肢を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, once the subclass’s designated initializer is finished, the convenience initializer that was originally called can perform additional customization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最後に、一旦サブクラスの指定イニシャライザが作業をし終えるならば、最初に呼ばれた便宜イニシャライザは追加の特注処理を実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, the &lt;c2&gt;&lt;s3&gt;default&lt;/s3&gt;&lt;/c2&gt; case matches any other character.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最終的に、&lt;c2&gt;&lt;s3&gt;default&lt;/s3&gt;&lt;/c2&gt;ケース節が他の文字のすべてにマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, the blue component is obtained by performing a bitwise AND between the numbers &lt;c0&gt;&lt;s1&gt;0xCC6699&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;0x0000FF&lt;/s3&gt;&lt;/c2&gt;, which gives an output value of &lt;c4&gt;&lt;s5&gt;0x000099&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最後に、青の構成要素は数&lt;c0&gt;&lt;s1&gt;0xCC6699&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;0x0000FF&lt;/s3&gt;&lt;/c2&gt;との間のビット単位の論理積を実行することによって得られます、それは、&lt;c4&gt;&lt;s5&gt;0x000099&lt;/s5&gt;&lt;/c4&gt;の出力値を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, the overall minimum and maximum values are returned as a tuple of two &lt;c10&gt;&lt;s11&gt;Int&lt;/s11&gt;&lt;/c10&gt; values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最後に、全体で最も小さいそして最も大きい値が２つの&lt;c10&gt;&lt;s11&gt;Int&lt;/s11&gt;&lt;/c10&gt;値のタプルとして返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Find out whether a &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; value is empty by checking its Boolean &lt;c2&gt;&lt;s3&gt;isEmpty&lt;/s3&gt;&lt;/c2&gt; property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;値が空かどうかを、それのブールの&lt;c2&gt;&lt;s3&gt;isEmpty&lt;/s3&gt;&lt;/c2&gt;プロパティを調べることで確認してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, it’s possible that &lt;c1&gt;&lt;s2&gt;dataSource&lt;/s2&gt;&lt;/c1&gt; may be &lt;c3&gt;&lt;s4&gt;nil&lt;/s4&gt;&lt;/c3&gt;, and so &lt;c5&gt;&lt;s6&gt;dataSource&lt;/s6&gt;&lt;/c5&gt; has a question mark after its name to indicate that &lt;c7&gt;&lt;s8&gt;increment(forCount:)&lt;/s8&gt;&lt;/c7&gt; should be called only if &lt;c9&gt;&lt;s10&gt;dataSource&lt;/s10&gt;&lt;/c9&gt; isn’t &lt;c11&gt;&lt;s12&gt;nil&lt;/s12&gt;&lt;/c11&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第１に、&lt;c1&gt;&lt;s2&gt;dataSource&lt;/s2&gt;&lt;/c1&gt;が&lt;c3&gt;&lt;s4&gt;nil&lt;/s4&gt;&lt;/c3&gt;かもしれない可能性があります、なので、&lt;c5&gt;&lt;s6&gt;dataSource&lt;/s6&gt;&lt;/c5&gt;はその名前の後に疑問符を持ち、&lt;c9&gt;&lt;s10&gt;dataSource&lt;/s10&gt;&lt;/c9&gt;が&lt;c11&gt;&lt;s12&gt;nil&lt;/s12&gt;&lt;/c11&gt;でない場合にのみ&lt;c7&gt;&lt;s8&gt;increment(forCount:)&lt;/s8&gt;&lt;/c7&gt;が呼ばれるべきであるのを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, two classes called &lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;Residence&lt;/s3&gt;&lt;/c2&gt; are defined:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初に、&lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;Residence&lt;/s3&gt;&lt;/c2&gt;（個人と邸宅）と呼ばれる２つのクラスが定義されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, you can add &lt;c0&gt;&lt;s1&gt;-1&lt;/s1&gt;&lt;/c0&gt; to &lt;c2&gt;&lt;s3&gt;-4&lt;/s3&gt;&lt;/c2&gt;, simply by performing a standard binary addition of all eight bits (including the sign bit), and discarding anything that doesn’t fit in the eight bits once you’re done:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第１に、あなたは&lt;c0&gt;&lt;s1&gt;-1&lt;/s1&gt;&lt;/c0&gt;を&lt;c2&gt;&lt;s3&gt;-4&lt;/s3&gt;&lt;/c2&gt;に加えることが、単純に８つのビット全て（符号ビットを含む）の通常のバイナリの加算を実行して、あなたがそうしたならばその８ビットに収まらない何でも捨てることによって行えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Floating-Point Literals</seg>
      </tuv>
      <tuv lang="JA">
        <seg>浮動小数点リテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Floating-Point Numbers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>浮動小数点数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Floating-point literals can be decimal (with no prefix), or hexadecimal (with a &lt;c0&gt;&lt;s1&gt;0x&lt;/s1&gt;&lt;/c0&gt; prefix).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>浮動小数点リテラルは、10進（接頭辞なし）、または16進（接頭辞&lt;c0&gt;&lt;s1&gt;0x&lt;/s1&gt;&lt;/c0&gt;つき）であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Floating-point literals can begin with leading zeros (&lt;c2&gt;&lt;s3&gt;0&lt;/s3&gt;&lt;/c2&gt;), but they’re likewise ignored and don’t affect the base or value of the literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>浮動小数点リテラルは、いくつかのゼロ（&lt;c2&gt;&lt;s3&gt;0&lt;/s3&gt;&lt;/c2&gt;）を先頭に始まることができます、しかしそれらは同様に無視されて、リテラルの基数または値に影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Floating-point to integer conversion must also be made explicit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>浮動小数点を整数に変換することは、また、明示的に行われる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Floating-point types can represent a much wider range of values than integer types, and can store numbers that are much larger or smaller than can be stored in an &lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>浮動小数点型は、整数型よりずっと広い値の幅を表すことができ、そして&lt;c0&gt;&lt;s1&gt;Intに&lt;/s1&gt;&lt;/c0&gt;格納できるよりずっと大きいまたは小さい数を格納できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Floating-point values are always truncated when used to initialize a new integer value in this way.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この方法で新しい整数値を初期化するとき、浮動小数点値は常に切り詰められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a complete list of precedence groups provided by the Swift standard library, see &lt;a12&gt;Operator Declarations&lt;/a12&gt;&lt;s13&gt; [https://developer.apple.com/documentation/swift/operator_declarations]&lt;/s13&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト標準ライブラリによって提供される優先順位グループの完全なリストとして、&lt;a12&gt;演算子宣言&lt;/a12&gt;&lt;s13&gt; [https://developer.apple.com/documentation/swift/operator_declarations]&lt;/s13&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a description of the &lt;e0&gt;Snakes and Ladders&lt;/e0&gt; gameplay, see &lt;a1&gt;&lt;s2&gt;Break&lt;/s2&gt;&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;ヘビとはしご&lt;/e0&gt;のゲームプレイの解説として、&lt;a1&gt;&lt;s2&gt;Break&lt;/s2&gt;&lt;/a1&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a detailed discussion of the Swift standard library &lt;c0&gt;&lt;s1&gt;Array&lt;/s1&gt;&lt;/c0&gt; type, see &lt;a2&gt;&lt;s3&gt;Arrays&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト標準ライブラリ&lt;c0&gt;&lt;s1&gt;Array&lt;/s1&gt;&lt;/c0&gt;型の詳細な議論のために、&lt;a2&gt;&lt;s3&gt;配列&lt;/s3&gt;&lt;/a2&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a detailed discussion of the Swift standard library &lt;c0&gt;&lt;s1&gt;Dictionary&lt;/s1&gt;&lt;/c0&gt; type, see &lt;a2&gt;&lt;s3&gt;Dictionaries&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト標準ライブラリ&lt;c0&gt;&lt;s1&gt;Dictionary&lt;/s1&gt;&lt;/c0&gt;型の詳細な議論として、&lt;a2&gt;&lt;s3&gt;辞書&lt;/s3&gt;&lt;/a2&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a detailed discussion of the behavior of in-out parameters and associated compiler optimizations, see &lt;a4&gt;&lt;s5&gt;In-Out Parameters&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>in-outパラメータの挙動と関連するコンパイラ最適化の詳細な議論として、&lt;a4&gt;&lt;s5&gt;in-outパラメータ&lt;/s5&gt;&lt;/a4&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a detailed discussion of the behavior of in-out parameters, see &lt;a4&gt;&lt;s5&gt;In-Out Parameters&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>in-outパラメータの振る舞いの詳細な議論のために、&lt;a4&gt;&lt;s5&gt;in-outパラメータ&lt;/s5&gt;&lt;/a4&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a dictionary that stores &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt; values, for example, the method returns a value of type &lt;c4&gt;&lt;s5&gt;String?&lt;/s5&gt;&lt;/c4&gt;, or “optional &lt;c6&gt;&lt;s7&gt;String&lt;/s7&gt;&lt;/c6&gt;”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;値を格納する辞書に対しては、このメソッドは型&lt;c4&gt;&lt;s5&gt;String?&lt;/s5&gt;&lt;/c4&gt;、すなわち「オプショナルの&lt;c6&gt;&lt;s7&gt;String&lt;/s7&gt;&lt;/c6&gt;」の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a discussion and several examples of classes that include various kinds of declarations, see &lt;a2&gt;&lt;s3&gt;Structures and Classes&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>議論および、さまざまな種類の宣言を含むクラスの例のいくつかのために、&lt;a2&gt;&lt;s3&gt;構造体とクラス&lt;/s3&gt;&lt;/a2&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a discussion and several examples of extensions that include various kinds of declarations, see &lt;a4&gt;&lt;s5&gt;Extensions&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いろいろな種類の宣言を含む拡張の解説といくつかの例のために、&lt;a4&gt;&lt;s5&gt;拡張&lt;/s5&gt;&lt;/a4&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a discussion and several examples of structures that include various kinds of declarations, see &lt;a2&gt;&lt;s3&gt;Structures and Classes&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>議論および、さまざまな種類の宣言を含む構造体の例のいくつかのために、&lt;a2&gt;&lt;s3&gt;構造体とクラス&lt;/s3&gt;&lt;/a2&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a discussion of nested functions, see &lt;a0&gt;&lt;s1&gt;Nested Functions&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>入れ子にされた関数の議論のために、&lt;a0&gt;&lt;s1&gt;入れ子にされた関数&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a generic function, that return type can use the function’s generic type parameters, but it must still be a single type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体関数に対して、その戻り型は、関数のもつ総称体型パラメータを使用できます、しかしそれは依然として単一の型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a list of characters that can be used to define custom operators, see &lt;a1&gt;&lt;s2&gt;Operators&lt;/s2&gt;&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あつらえの演算子を定義するために使用できる文字のリストとして、&lt;a1&gt;&lt;s2&gt;演算子&lt;/s2&gt;&lt;/a1&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a more detailed comparison, see &lt;a0&gt;Choosing Between Structures and Classes&lt;/a0&gt;&lt;s1&gt; [https://developer.apple.com/documentation/swift/choosing_between_structures_and_classes]&lt;/s1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>詳細な比較は、&lt;a0&gt;構造体とクラスから選ぶ&lt;/a0&gt;&lt;s1&gt; [https://developer.apple.com/documentation/swift/choosing_between_structures_and_classes]&lt;/s1&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a paragraph element, the closure would return &lt;c6&gt;&lt;s7&gt;"&lt;p&gt;some&lt;/s7&gt; &lt;s8&gt;text&lt;/p&gt;"&lt;/s8&gt;&lt;/c6&gt; or &lt;c9&gt;&lt;s10&gt;"&lt;p&lt;/s10&gt; &lt;s11&gt;/&gt;"&lt;/s11&gt;&lt;/c9&gt;, depending on whether the &lt;c12&gt;&lt;s13&gt;text&lt;/s13&gt;&lt;/c12&gt; property equals &lt;c14&gt;&lt;s15&gt;"some&lt;/s15&gt; &lt;s16&gt;text"&lt;/s16&gt;&lt;/c14&gt; or &lt;c17&gt;&lt;s18&gt;nil&lt;/s18&gt;&lt;/c17&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>段落要素のために、このクロージャは、&lt;c6&gt;&lt;s7&gt;"&lt;p&gt;some&lt;/s7&gt; &lt;s8&gt;text&lt;/p&gt;"&lt;/s8&gt;&lt;/c6&gt;または&lt;c9&gt;&lt;s10&gt;"&lt;p&lt;/s10&gt; &lt;s11&gt;/&gt;"&lt;/s11&gt;&lt;/c9&gt;を返します、&lt;c12&gt;&lt;s13&gt;text&lt;/s13&gt;&lt;/c12&gt;プロパティが&lt;c14&gt;&lt;s15&gt;"some&lt;/s15&gt; &lt;s16&gt;text"&lt;/s16&gt;&lt;/c14&gt;に等しいまたは&lt;c17&gt;&lt;s18&gt;nil&lt;/s18&gt;&lt;/c17&gt;かどうかに従って。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a property marked with the &lt;c2&gt;&lt;s3&gt;NSManaged&lt;/s3&gt;&lt;/c2&gt; attribute, Core Data also provides the storage at runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;NSManaged&lt;/s3&gt;&lt;/c2&gt;属性で印されるプロパティに対して、Coreデータはまたストレージを実行時に提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a protocol that inherits from another protocol, you add a constraint to an inherited associated type by including the generic &lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt; clause in the protocol declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>別のプロトコルから継承するプロトコルに対して、あなたは継承された関連型への制約の追加を、総称体&lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt;節をそのプロトコル宣言の中で含めることによって行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a type that is defined as &lt;c2&gt;&lt;s3&gt;public&lt;/s3&gt;&lt;/c2&gt;, the default initializer is considered internal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;public&lt;/s3&gt;&lt;/c2&gt;として定義される型のために、その省略時のイニシャライザは内部と見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an alternative way to write this example without defining the &lt;c0&gt;&lt;s1&gt;init()&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;init(origin:size:)&lt;/s3&gt;&lt;/c2&gt; initializers yourself, see &lt;a4&gt;&lt;s5&gt;Extensions&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;init()&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;init(origin:size:)&lt;/s3&gt;&lt;/c2&gt;イニシャライザをあなた自身で定義することなくこの例を書く代わりの方法のために、&lt;a4&gt;&lt;s5&gt;拡張&lt;/s5&gt;&lt;/a4&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example and more information about the &lt;c0&gt;&lt;s1&gt;unowned&lt;/s1&gt;&lt;/c0&gt; modifier, see &lt;a2&gt;&lt;s3&gt;Unowned References&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;unowned&lt;/s1&gt;&lt;/c0&gt;修飾子についての例とさらなる情報として、&lt;a2&gt;&lt;s3&gt;非所有参照&lt;/s3&gt;&lt;/a2&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example and more information about the &lt;c2&gt;&lt;s3&gt;weak&lt;/s3&gt;&lt;/c2&gt; modifier, see &lt;a4&gt;&lt;s5&gt;Weak References&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;weak&lt;/s3&gt;&lt;/c2&gt;修飾子についての例と更なる情報のために、&lt;a4&gt;&lt;s5&gt;弱い参照&lt;/s5&gt;&lt;/a4&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example of an autoclosure function type parameter, see &lt;a8&gt;&lt;s9&gt;Autoclosures&lt;/s9&gt;&lt;/a8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>自動クロージャ関数型パラメータの例として、&lt;a8&gt;&lt;s9&gt;自動クロージャ&lt;/s9&gt;&lt;/a8&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example of an enumeration definition that uses a type inheritance clause to specify the type of its raw values, see &lt;a0&gt;&lt;s1&gt;Raw Values&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その生の値の型を指定するために型継承節を使う列挙定義の例のために、&lt;a0&gt;&lt;s1&gt;生の値&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example of how to use a &lt;c0&gt;&lt;s1&gt;fallthrough&lt;/s1&gt;&lt;/c0&gt; statement in a &lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt; statement, see &lt;a4&gt;&lt;s5&gt;Control Transfer Statements&lt;/s5&gt;&lt;/a4&gt; in &lt;a6&gt;&lt;s7&gt;Control Flow&lt;/s7&gt;&lt;/a6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;fallthrough&lt;/s1&gt;&lt;/c0&gt;文を&lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt;文において使う方法の例のために、&lt;a4&gt;&lt;s5&gt;制御移動文&lt;/s5&gt;&lt;/a4&gt;を章&lt;a6&gt;&lt;s7&gt;制御の流れ&lt;/s7&gt;&lt;/a6&gt;で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example of how to use a &lt;c0&gt;&lt;s1&gt;throw&lt;/s1&gt;&lt;/c0&gt; statement, see &lt;a2&gt;&lt;s3&gt;Propagating Errors Using Throwing Functions&lt;/s3&gt;&lt;/a2&gt; in &lt;a4&gt;&lt;s5&gt;Error Handling&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;throw&lt;/s1&gt;&lt;/c0&gt;文を使う方法の例のために、&lt;a2&gt;&lt;s3&gt;スロー関数を使ってエラーを伝える&lt;/s3&gt;&lt;/a2&gt;を&lt;a4&gt;&lt;s5&gt;エラー処理&lt;/s5&gt;&lt;/a4&gt;の章で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example of how to use a deinitializer in a class declaration, see &lt;a0&gt;&lt;s1&gt;Deinitialization&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス宣言においてデイニシャライザを使う方法の例のために、&lt;a0&gt;&lt;s1&gt;デイニシャライズ&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example of how to use protocol inheritance, see &lt;a0&gt;&lt;s1&gt;Protocol Inheritance&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル継承を使う方法の例のために、&lt;a0&gt;&lt;s1&gt;プロトコル継承&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example of how to use the &lt;c0&gt;&lt;s1&gt;autoclosure&lt;/s1&gt;&lt;/c0&gt; attribute, see &lt;a2&gt;&lt;s3&gt;Autoclosures&lt;/s3&gt;&lt;/a2&gt; and &lt;a4&gt;&lt;s5&gt;Function Type&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;autoclosure&lt;/s1&gt;&lt;/c0&gt;属性を使用する方法の例として、&lt;a2&gt;&lt;s3&gt;自動クロージャ&lt;/s3&gt;&lt;/a2&gt;と&lt;a4&gt;&lt;s5&gt;関数型&lt;/s5&gt;&lt;/a4&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example of how to use the &lt;c0&gt;&lt;s1&gt;final&lt;/s1&gt;&lt;/c0&gt; attribute, see &lt;a2&gt;&lt;s3&gt;Preventing Overrides&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;final&lt;/s1&gt;&lt;/c0&gt;属性を使う方法の例として、&lt;a2&gt;&lt;s3&gt;オーバーライドを防ぐ&lt;/s3&gt;&lt;/a2&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example of how to use the &lt;c0&gt;&lt;s1&gt;lazy&lt;/s1&gt;&lt;/c0&gt; modifier, see &lt;a2&gt;&lt;s3&gt;Lazy Stored Properties&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;lazy&lt;/s1&gt;&lt;/c0&gt;修飾子を使う方法の例として、&lt;a2&gt;&lt;s3&gt;遅延格納プロパティ&lt;/s3&gt;&lt;/a2&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example of how to use the &lt;c0&gt;&lt;s1&gt;unknown&lt;/s1&gt;&lt;/c0&gt; attribute, see &lt;a2&gt;&lt;s3&gt;Switching Over Future Enumeration Cases&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;unknown&lt;/s1&gt;&lt;/c0&gt;属性を使う方法の例のために、&lt;a2&gt;&lt;s3&gt;未来列挙ケース節に対してスイッチする&lt;/s3&gt;&lt;/a2&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example of how to use the &lt;c4&gt;&lt;s5&gt;escaping&lt;/s5&gt;&lt;/c4&gt; attribute, see &lt;a6&gt;&lt;s7&gt;Escaping Closures&lt;/s7&gt;&lt;/a6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;escaping&lt;/s5&gt;&lt;/c4&gt;属性を使う方法の例として、&lt;a6&gt;&lt;s7&gt;脱出クロージャ&lt;/s7&gt;&lt;/a6&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example that demonstrates both of these features, see &lt;a0&gt;&lt;s1&gt;Functions with Multiple Return Values&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの特徴の両方を示す例のために、&lt;a0&gt;&lt;s1&gt;複数の戻り値をもつ関数&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example that uses a &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; statement to match enumeration cases containing associated values, see &lt;a2&gt;&lt;s3&gt;Associated Values&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連値を含んでいる列挙ケース節にマッチするために&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;文を使う例のために、&lt;a2&gt;&lt;s3&gt;関連値&lt;/s3&gt;&lt;/a2&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example that uses a &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; statement to match values with &lt;c2&gt;&lt;s3&gt;is&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;as&lt;/s5&gt;&lt;/c4&gt; patterns, see &lt;a6&gt;&lt;s7&gt;Type Casting for Any and AnyObject&lt;/s7&gt;&lt;/a6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;文を使用して、さまざまに値を&lt;c2&gt;&lt;s3&gt;is&lt;/s3&gt;&lt;/c2&gt;や&lt;c4&gt;&lt;s5&gt;as&lt;/s5&gt;&lt;/c4&gt;パターンとマッチする例のために、&lt;a6&gt;&lt;s7&gt;AnyおよびAnyObjectに対する型キャスト&lt;/s7&gt;&lt;/a6&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example that uses a variadic parameter, see &lt;a6&gt;&lt;s7&gt;Variadic Parameters&lt;/s7&gt;&lt;/a6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>可変長パラメータを使う例のために、&lt;a6&gt;&lt;s7&gt;可変長パラメータ&lt;/s7&gt;&lt;/a6&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example that uses a variadic parameter, see &lt;a9&gt;&lt;s10&gt;Variadic Parameters&lt;/s10&gt;&lt;/a9&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>可変長パラメータを使う例のために、&lt;a9&gt;&lt;s10&gt;可変長パラメータ&lt;/s10&gt;&lt;/a9&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an example that uses the ternary conditional operator, see &lt;a0&gt;&lt;s1&gt;Ternary Conditional Operator&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>三項条件演算子を使用する例のために、&lt;a0&gt;&lt;s1&gt;三項条件演算子&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an extended discussion and several examples of class inheritance, see &lt;a0&gt;&lt;s1&gt;Inheritance&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス継承の広範囲にわたる議論といくつかの例のために、&lt;a0&gt;&lt;s1&gt;継承&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For an overview of generics in Swift, see &lt;a0&gt;&lt;s1&gt;Generics&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでの総称体の概要のために、&lt;a0&gt;&lt;s1&gt;総称体&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For both signed and unsigned integers, overflow in the positive direction wraps around from the maximum valid integer value back to the minimum, and overflow in the negative direction wraps around from the minimum value to the maximum.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>符号つきおよび符号なし整数の両方に対して、正の方向でのオーバフローは最大限の有効な整数値から逆に最小限へとぐるっと送り込まれ、負の方向でのオーバフローは最小限の値から最大限へとぐるっと送り込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For brevity, multiple values are covered in a single &lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt; case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>簡潔にするため、複数の値が１つの&lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt;ケース節で扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For characters in strings, “greater than” means “appears later in the alphabet than”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列の中の文字のために、「より大きい」は「アルファベットにおいてより後に現れる」ことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For class instances, a constant property can be modified during initialization only by the class that introduces it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスインスタンスのために、定数プロパティは、それを導入するクラスによってのみ初期化の間に修正されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For class instances, the initializer that’s called must be marked with the &lt;c0&gt;&lt;s1&gt;required&lt;/s1&gt;&lt;/c0&gt; keyword or the entire class marked with the &lt;c2&gt;&lt;s3&gt;final&lt;/s3&gt;&lt;/c2&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスインスタンスに対しては、呼び出されるイニシャライザが&lt;c0&gt;&lt;s1&gt;required&lt;/s1&gt;&lt;/c0&gt;キーワードで印されるか、クラス全体が&lt;c2&gt;&lt;s3&gt;final&lt;/s3&gt;&lt;/c2&gt;キーワードで印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For classes that are defined in another module, you can override any open class member.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>別のモジュールにおいて定義されるクラスに対して、あなたはどんな開放クラスメンバーでもオーバーライドできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For computed type properties for class types, you can use the &lt;c2&gt;&lt;s3&gt;class&lt;/s3&gt;&lt;/c2&gt; keyword instead to allow subclasses to override the superclass’s implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス型のための計算型プロパティに対しては、あなたは代わりに&lt;c2&gt;&lt;s3&gt;class&lt;/s3&gt;&lt;/c2&gt;キーワードを使って、サブクラスにそのスーパークラスの実装のオーバーライドを許可することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For convenience and because the distinction isn’t that important in Swift, the term &lt;e0&gt;declaration&lt;/e0&gt; covers both declarations and definitions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>便利さとその区別がスウィフトにおいてそんなに重要でないことから、用語&lt;e0&gt;宣言&lt;/e0&gt;は、宣言と定義を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For decimal numbers with an exponent of &lt;c0&gt;&lt;s1&gt;exp&lt;/s1&gt;&lt;/c0&gt;, the base number is multiplied by 10&lt;s2&gt;exp&lt;/s2&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;exp&lt;/s1&gt;&lt;/c0&gt;の指数を持つある10進数に対して、その基数は10&lt;s2&gt;exp&lt;/s2&gt;を掛けられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For details, see &lt;a4&gt;&lt;s5&gt;Break in a Switch Statement&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>詳細は&lt;a4&gt;&lt;s5&gt;スイッチ文の中断&lt;/s5&gt;&lt;/a4&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each entry in the capture list, a constant is initialized to the value of the constant or variable that has the same name in the surrounding scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キャプチャリストのそれぞれの登録項目に対して、その定数や変数の値へとひとつの定数が初期化されます、それは囲んでいるスコープの中で同じ名前を待ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each integer in the array, the function considers the &lt;c4&gt;&lt;s5&gt;kind&lt;/s5&gt;&lt;/c4&gt; computed property for that integer, and prints an appropriate description.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その配列の各整数に対して、この関数はその整数に対する&lt;c4&gt;&lt;s5&gt;kind&lt;/s5&gt;&lt;/c4&gt;計算プロパティを考慮して、適切な説明を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each item in the array, the &lt;c2&gt;&lt;s3&gt;enumerated()&lt;/s3&gt;&lt;/c2&gt; method returns a tuple composed of an integer and the item.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この配列の各項目に対して、&lt;c2&gt;&lt;s3&gt;enumerated()&lt;/s3&gt;&lt;/c2&gt;メソッドは、整数とその項目から成るひとつのタプルを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each item, the function checks whether the item from &lt;c8&gt;&lt;s9&gt;someContainer&lt;/s9&gt;&lt;/c8&gt; isn’t equal to the corresponding item in &lt;c10&gt;&lt;s11&gt;anotherContainer&lt;/s11&gt;&lt;/c10&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各項目のために、関数は&lt;c8&gt;&lt;s9&gt;someContainer&lt;/s9&gt;&lt;/c8&gt;からの項目が&lt;c10&gt;&lt;s11&gt;anotherContainer&lt;/s11&gt;&lt;/c10&gt;での対応する項目と同等でないかどうか確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example in the code below, &lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt;&lt;/c0&gt; is included in the capture list but &lt;c2&gt;&lt;s3&gt;b&lt;/s3&gt;&lt;/c2&gt; is not, which gives them different behavior.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば以下のコードにおいて、&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt;&lt;/c0&gt;はキャプチャリストに含まれますが&lt;c2&gt;&lt;s3&gt;b&lt;/s3&gt;&lt;/c2&gt;はそうではありません、そのことはそれらに異なる挙動を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, &lt;c0&gt;&lt;s1&gt;((Int,&lt;/s1&gt; &lt;s2&gt;Int))&lt;/s2&gt; &lt;s3&gt;-&gt;&lt;/s3&gt; &lt;s4&gt;Void&lt;/s4&gt;&lt;/c0&gt; is the type of a function that takes a single parameter of the tuple type &lt;c5&gt;&lt;s6&gt;(Int,&lt;/s6&gt; &lt;s7&gt;Int)&lt;/s7&gt;&lt;/c5&gt; and doesn’t return any value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;c0&gt;&lt;s1&gt;((Int,&lt;/s1&gt; &lt;s2&gt;Int))&lt;/s2&gt; &lt;s3&gt;-&gt;&lt;/s3&gt; &lt;s4&gt;Void&lt;/s4&gt;&lt;/c0&gt;は、タプル型&lt;c5&gt;&lt;s6&gt;(Int,&lt;/s6&gt; &lt;s7&gt;Int)&lt;/s7&gt;&lt;/c5&gt;の単一のパラメータを取り、何ら値を返さない関数の型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, &lt;c0&gt;&lt;s1&gt;(Int)&lt;/s1&gt;&lt;/c0&gt; is equivalent to &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;c0&gt;&lt;s1&gt;(Int)&lt;/s1&gt;&lt;/c0&gt;は&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;に等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, &lt;c0&gt;&lt;s1&gt;(a:&lt;/s1&gt; &lt;s2&gt;10,&lt;/s2&gt; &lt;s3&gt;a:&lt;/s3&gt; &lt;s4&gt;20)&lt;/s4&gt;&lt;/c0&gt; is invalid because the label &lt;c5&gt;&lt;s6&gt;a&lt;/s6&gt;&lt;/c5&gt; appears twice at the same level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;c0&gt;&lt;s1&gt;(a:&lt;/s1&gt; &lt;s2&gt;10,&lt;/s2&gt; &lt;s3&gt;a:&lt;/s3&gt; &lt;s4&gt;20)&lt;/s4&gt;&lt;/c0&gt;は無効です、なぜならラベル&lt;c5&gt;&lt;s6&gt;a&lt;/s6&gt;&lt;/c5&gt;が同じ水準で二度現れるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, &lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt; is a type identifier that directly refers to the named type &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;, and the type identifier &lt;c4&gt;&lt;s5&gt;Dictionary&lt;String,&lt;/s5&gt; &lt;s6&gt;Int&gt;&lt;/s6&gt;&lt;/c4&gt; directly refers to the named type &lt;c7&gt;&lt;s8&gt;Dictionary&lt;String,&lt;/s8&gt; &lt;s9&gt;Int&gt;&lt;/s9&gt;&lt;/c7&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt;は、直接に名前付きの型&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;に言及する型識別子です、そして型識別子&lt;c4&gt;&lt;s5&gt;Dictionary&lt;String,&lt;/s5&gt; &lt;s6&gt;Int&gt;&lt;/s6&gt;&lt;/c4&gt;は、直接に名前付きの型&lt;c7&gt;&lt;s8&gt;Dictionary&lt;String,&lt;/s8&gt; &lt;s9&gt;Int&gt;&lt;/s9&gt;&lt;/c7&gt;に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, &lt;c0&gt;&lt;s1&gt;LATIN&lt;/s1&gt; &lt;s2&gt;SMALL&lt;/s2&gt; &lt;s3&gt;LETTER&lt;/s3&gt; &lt;s4&gt;E&lt;/s4&gt; &lt;s5&gt;WITH&lt;/s5&gt; &lt;s6&gt;ACUTE&lt;/s6&gt;&lt;/c0&gt; (&lt;c7&gt;&lt;s8&gt;U+00E9&lt;/s8&gt;&lt;/c7&gt;) is canonically equivalent to &lt;c9&gt;&lt;s10&gt;LATIN&lt;/s10&gt; &lt;s11&gt;SMALL&lt;/s11&gt; &lt;s12&gt;LETTER&lt;/s12&gt; &lt;s13&gt;E&lt;/s13&gt;&lt;/c9&gt; (&lt;c14&gt;&lt;s15&gt;U+0065&lt;/s15&gt;&lt;/c14&gt;) followed by &lt;c16&gt;&lt;s17&gt;COMBINING&lt;/s17&gt; &lt;s18&gt;ACUTE&lt;/s18&gt; &lt;s19&gt;ACCENT&lt;/s19&gt;&lt;/c16&gt; (&lt;c20&gt;&lt;s21&gt;U+0301&lt;/s21&gt;&lt;/c20&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;c0&gt;&lt;s1&gt;LATIN&lt;/s1&gt; &lt;s2&gt;SMALL&lt;/s2&gt; &lt;s3&gt;LETTER&lt;/s3&gt; &lt;s4&gt;E&lt;/s4&gt; &lt;s5&gt;WITH&lt;/s5&gt; &lt;s6&gt;ACUTE&lt;/s6&gt;&lt;/c0&gt;（&lt;c7&gt;&lt;s8&gt;U+00E9&lt;/s8&gt;&lt;/c7&gt;）は、&lt;c9&gt;&lt;s10&gt;LATIN&lt;/s10&gt; &lt;s11&gt;SMALL&lt;/s11&gt; &lt;s12&gt;LETTER&lt;/s12&gt; &lt;s13&gt;E&lt;/s13&gt;&lt;/c9&gt;（&lt;c14&gt;&lt;s15&gt;U+0065&lt;/s15&gt;&lt;/c14&gt;）に&lt;c16&gt;&lt;s17&gt;COMBINING&lt;/s17&gt; &lt;s18&gt;ACUTE&lt;/s18&gt; &lt;s19&gt;ACCENT&lt;/s19&gt;&lt;/c16&gt;（&lt;c20&gt;&lt;s21&gt;U+0301&lt;/s21&gt;&lt;/c20&gt;）を続けたものと正準等価です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, &lt;c0&gt;&lt;s1&gt;UInt64(0xffff_ffff_ffff_ffff)&lt;/s1&gt;&lt;/c0&gt; evaluates to the correct value rather than overflowing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;c0&gt;&lt;s1&gt;UInt64(0xffff_ffff_ffff_ffff)&lt;/s1&gt;&lt;/c0&gt;は正しい値に評価されます、オーバーフローするのではなくて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, &lt;c12&gt;&lt;s13&gt;Int8&lt;/s13&gt;&lt;/c12&gt; conforms to the &lt;c14&gt;&lt;s15&gt;ExpressibleByIntegerLiteral&lt;/s15&gt;&lt;/c14&gt; protocol, and therefore it can be used in the type annotation for the integer literal &lt;c16&gt;&lt;s17&gt;42&lt;/s17&gt;&lt;/c16&gt; in the declaration &lt;c18&gt;&lt;s19&gt;let&lt;/s19&gt; &lt;s20&gt;x:&lt;/s20&gt; &lt;s21&gt;Int8&lt;/s21&gt; &lt;s22&gt;=&lt;/s22&gt; &lt;s23&gt;42&lt;/s23&gt;&lt;/c18&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;c12&gt;&lt;s13&gt;Int8&lt;/s13&gt;&lt;/c12&gt;は&lt;c14&gt;&lt;s15&gt;ExpressibleByIntegerLiteral&lt;/s15&gt;&lt;/c14&gt;プロトコルに準拠します、したがってそれは宣言&lt;c18&gt;&lt;s19&gt;let&lt;/s19&gt; &lt;s20&gt;x:&lt;/s20&gt; &lt;s21&gt;Int8&lt;/s21&gt; &lt;s22&gt;=&lt;/s22&gt; &lt;s23&gt;42&lt;/s23&gt;&lt;/c18&gt;の中の整数リテラル&lt;c16&gt;&lt;s17&gt;42&lt;/s17&gt;&lt;/c16&gt;のための型注釈において使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, &lt;c13&gt;&lt;s14&gt;&lt;S:&lt;/s14&gt; &lt;s15&gt;Sequence&gt;&lt;/s15&gt; &lt;s16&gt;where&lt;/s16&gt; &lt;s17&gt;S.Iterator.Element:&lt;/s17&gt; &lt;s18&gt;Equatable&lt;/s18&gt;&lt;/c13&gt; specifies that &lt;c19&gt;&lt;s20&gt;S&lt;/s20&gt;&lt;/c19&gt; conforms to the &lt;c21&gt;&lt;s22&gt;Sequence&lt;/s22&gt;&lt;/c21&gt; protocol and that the associated type &lt;c23&gt;&lt;s24&gt;S.Iterator.Element&lt;/s24&gt;&lt;/c23&gt; conforms to the &lt;c25&gt;&lt;s26&gt;Equatable&lt;/s26&gt;&lt;/c25&gt; protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;c13&gt;&lt;s14&gt;&lt;S:&lt;/s14&gt; &lt;s15&gt;Sequence&gt;&lt;/s15&gt; &lt;s16&gt;where&lt;/s16&gt; &lt;s17&gt;S.Iterator.Element:&lt;/s17&gt; &lt;s18&gt;Equatable&lt;/s18&gt;&lt;/c13&gt;が指定するのは、&lt;c19&gt;&lt;s20&gt;S&lt;/s20&gt;&lt;/c19&gt;が&lt;c21&gt;&lt;s22&gt;Sequence&lt;/s22&gt;&lt;/c21&gt;プロトコルに準拠すること、そして関連型&lt;c23&gt;&lt;s24&gt;S.Iterator.Element&lt;/s24&gt;&lt;/c23&gt;が&lt;c25&gt;&lt;s26&gt;Equatable&lt;/s26&gt;&lt;/c25&gt;プロトコルに準拠することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, &lt;c1&gt;&lt;s2&gt;x.self&lt;/s2&gt;&lt;/c1&gt; evaluates to &lt;c3&gt;&lt;s4&gt;x&lt;/s4&gt;&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;c1&gt;&lt;s2&gt;x.self&lt;/s2&gt;&lt;/c1&gt;は&lt;c3&gt;&lt;s4&gt;x&lt;/s4&gt;&lt;/c3&gt;に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, &lt;c2&gt;&lt;s3&gt;.+.&lt;/s3&gt;&lt;/c2&gt; is treated as a single operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;c2&gt;&lt;s3&gt;.+.&lt;/s3&gt;&lt;/c2&gt;は単一の演算子とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, &lt;c2&gt;&lt;s3&gt;&lt;S1:&lt;/s3&gt; &lt;s4&gt;Sequence,&lt;/s4&gt; &lt;s5&gt;S2:&lt;/s5&gt; &lt;s6&gt;Sequence&gt;&lt;/s6&gt; &lt;s7&gt;where&lt;/s7&gt; &lt;s8&gt;S1.Iterator.Element&lt;/s8&gt; &lt;s9&gt;==&lt;/s9&gt; &lt;s10&gt;S2.Iterator.Element&lt;/s10&gt;&lt;/c2&gt; expresses the constraints that &lt;c11&gt;&lt;s12&gt;S1&lt;/s12&gt;&lt;/c11&gt; and &lt;c13&gt;&lt;s14&gt;S2&lt;/s14&gt;&lt;/c13&gt; conform to the &lt;c15&gt;&lt;s16&gt;Sequence&lt;/s16&gt;&lt;/c15&gt; protocol and that the elements of both sequences must be of the same type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;c2&gt;&lt;s3&gt;&lt;S1:&lt;/s3&gt; &lt;s4&gt;Sequence,&lt;/s4&gt; &lt;s5&gt;S2:&lt;/s5&gt; &lt;s6&gt;Sequence&gt;&lt;/s6&gt; &lt;s7&gt;where&lt;/s7&gt; &lt;s8&gt;S1.Iterator.Element&lt;/s8&gt; &lt;s9&gt;==&lt;/s9&gt; &lt;s10&gt;S2.Iterator.Element&lt;/s10&gt;&lt;/c2&gt;が表す制約は、&lt;c11&gt;&lt;s12&gt;S1&lt;/s12&gt;&lt;/c11&gt;と&lt;c13&gt;&lt;s14&gt;S2&lt;/s14&gt;&lt;/c13&gt;が&lt;c15&gt;&lt;s16&gt;Sequence&lt;/s16&gt;&lt;/c15&gt;プロトコルに準拠すること、そして両方のシーケンスの要素が同じ型でなければならないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, &lt;c2&gt;&lt;s3&gt;SomeClass.self&lt;/s3&gt;&lt;/c2&gt; returns &lt;c4&gt;&lt;s5&gt;SomeClass&lt;/s5&gt;&lt;/c4&gt; itself, not an instance of &lt;c6&gt;&lt;s7&gt;SomeClass&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;c2&gt;&lt;s3&gt;SomeClass.self&lt;/s3&gt;&lt;/c2&gt;は、&lt;c4&gt;&lt;s5&gt;SomeClass&lt;/s5&gt;&lt;/c4&gt;自身を返します、&lt;c6&gt;&lt;s7&gt;SomeClass&lt;/s7&gt;&lt;/c6&gt;のインスタンスではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, &lt;c2&gt;&lt;s3&gt;class&lt;/s3&gt;&lt;/c2&gt; is not a valid identifier, but &lt;c4&gt;&lt;s5&gt;`class`&lt;/s5&gt;&lt;/c4&gt; is valid.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;c2&gt;&lt;s3&gt;class&lt;/s3&gt;&lt;/c2&gt;は有効な識別子ではありません、しかし、&lt;c4&gt;&lt;s5&gt;`class`&lt;/s5&gt;&lt;/c4&gt;は有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, &lt;c4&gt;&lt;s5&gt;+.+&lt;/s5&gt;&lt;/c4&gt; is treated as the &lt;c6&gt;&lt;s7&gt;+&lt;/s7&gt;&lt;/c6&gt; operator followed by the &lt;c8&gt;&lt;s9&gt;.+&lt;/s9&gt;&lt;/c8&gt; operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;c4&gt;&lt;s5&gt;+.+&lt;/s5&gt;&lt;/c4&gt;は、&lt;c6&gt;&lt;s7&gt;+&lt;/s7&gt;&lt;/c6&gt;演算子に&lt;c8&gt;&lt;s9&gt;.+&lt;/s9&gt;&lt;/c8&gt;演算子が続くとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, &lt;c6&gt;&lt;s7&gt;0xFp2&lt;/s7&gt;&lt;/c6&gt; represents 15 x 2&lt;s8&gt;2&lt;/s8&gt;, which evaluates to &lt;c9&gt;&lt;s10&gt;60&lt;/s10&gt;&lt;/c9&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;c6&gt;&lt;s7&gt;0xFp2&lt;/s7&gt;&lt;/c6&gt;は15 × 2&lt;s8&gt;2&lt;/s8&gt;を表します、それは&lt;c9&gt;&lt;s10&gt;60&lt;/s10&gt;&lt;/c9&gt;に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, &lt;c6&gt;&lt;s7&gt;1.25e2&lt;/s7&gt;&lt;/c6&gt; represents 1.25 x 10&lt;s8&gt;2&lt;/s8&gt;, which evaluates to &lt;c9&gt;&lt;s10&gt;125.0&lt;/s10&gt;&lt;/c9&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;c6&gt;&lt;s7&gt;1.25e2&lt;/s7&gt;&lt;/c6&gt;は1.25 × 10&lt;s8&gt;2&lt;/s8&gt;を表します、それは&lt;c9&gt;&lt;s10&gt;125.0&lt;/s10&gt;&lt;/c9&gt;に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, Hangul syllables from the Korean alphabet can be represented as either a precomposed or decomposed sequence.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、コリアン・アルファベットのハングル音節は、最初から組み立てられるか、または分解されて並べたもののどちらでも表わすことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, Swift ensures that variables are initialized before they’re used, memory isn’t accessed after it’s been deallocated, and array indices are checked for out-of-bounds errors.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、変数はそれらが使用される前に初期化されること、メモリはそれがデアロケートされてしまった後にアクセスされないこと、そして配列インデックスは境界外エラーを調べられることを、スウィフトは確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, Swift’s &lt;c0&gt;&lt;s1&gt;Dictionary&lt;/s1&gt;&lt;/c0&gt; type implements a subscript to set and retrieve the values stored in a &lt;c2&gt;&lt;s3&gt;Dictionary&lt;/s3&gt;&lt;/c2&gt; instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、スウィフトの&lt;c0&gt;&lt;s1&gt;Dictionary&lt;/s1&gt;&lt;/c0&gt;型は、&lt;c2&gt;&lt;s3&gt;Dictionary&lt;/s3&gt;&lt;/c2&gt;インスタンスに格納される値を設定したり取り出すために添え字を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, Swift’s &lt;c0&gt;&lt;s1&gt;Dictionary&lt;/s1&gt;&lt;/c0&gt; type places a limitation on the types that can be used as keys for a dictionary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、スウィフトの&lt;c0&gt;&lt;s1&gt;Dictionary&lt;/s1&gt;&lt;/c0&gt;型は、辞書のキーとして使われることができる型に制限を置きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, Swift’s &lt;c1&gt;&lt;s2&gt;Array&lt;/s2&gt;&lt;/c1&gt; and &lt;c3&gt;&lt;s4&gt;Dictionary&lt;/s4&gt;&lt;/c3&gt; types are both generic collections.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、スウィフトの&lt;c1&gt;&lt;s2&gt;Array&lt;/s2&gt;&lt;/c1&gt;と&lt;c3&gt;&lt;s4&gt;Dictionary&lt;/s4&gt;&lt;/c3&gt;型は、両方とも総称体コレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a &lt;e16&gt;control expression&lt;/e16&gt; matches the case in the example below only if it is a tuple that contains two elements of the same value, such as &lt;c17&gt;&lt;s18&gt;(1,&lt;/s18&gt; &lt;s19&gt;1)&lt;/s19&gt;&lt;/c17&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、ある&lt;e16&gt;制御式&lt;/e16&gt;は、それが同じ値の２つの要素を持つタプル、例えば&lt;c17&gt;&lt;s18&gt;(1,&lt;/s18&gt; &lt;s19&gt;1)&lt;/s19&gt;&lt;/c17&gt;のようなものである場合にのみ、以下の例におけるケース節にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a case named &lt;c2&gt;&lt;s3&gt;venus&lt;/s3&gt;&lt;/c2&gt; in a Swift &lt;c4&gt;&lt;s5&gt;Planet&lt;/s5&gt;&lt;/c4&gt; enumeration is exposed to Objective-C code as a case named &lt;c6&gt;&lt;s7&gt;PlanetVenus&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、スウィフトの&lt;c4&gt;&lt;s5&gt;Planet&lt;/s5&gt;&lt;/c4&gt;列挙の中の&lt;c2&gt;&lt;s3&gt;venus&lt;/s3&gt;&lt;/c2&gt;と名付けられるケース節は、Objective-Cコードに&lt;c6&gt;&lt;s7&gt;PlanetVenus&lt;/s7&gt;&lt;/c6&gt;と名付けられるケース節として暴露されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a function &lt;c0&gt;&lt;s1&gt;someFunction&lt;T&gt;()&lt;/s1&gt;&lt;/c0&gt; could return a value of type &lt;c2&gt;&lt;s3&gt;T&lt;/s3&gt;&lt;/c2&gt; or &lt;c4&gt;&lt;s5&gt;Dictionary&lt;String,&lt;/s5&gt; &lt;s6&gt;T&gt;&lt;/s6&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、関数&lt;c0&gt;&lt;s1&gt;someFunction&lt;T&gt;()&lt;/s1&gt;&lt;/c0&gt;は、型&lt;c2&gt;&lt;s3&gt;T&lt;/s3&gt;&lt;/c2&gt;または&lt;c4&gt;&lt;s5&gt;Dictionary&lt;String,&lt;/s5&gt; &lt;s6&gt;T&gt;&lt;/s6&gt;&lt;/c4&gt;の値を返すことができました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a method of type &lt;c0&gt;&lt;s1&gt;(Int)&lt;/s1&gt; &lt;s2&gt;-&gt;&lt;/s2&gt; &lt;s3&gt;String&lt;/s3&gt;&lt;/c0&gt; becomes &lt;c4&gt;&lt;s5&gt;((Int)&lt;/s5&gt; &lt;s6&gt;-&gt;&lt;/s6&gt; &lt;s7&gt;String)?&lt;/s7&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、型&lt;c0&gt;&lt;s1&gt;(Int)&lt;/s1&gt; &lt;s2&gt;-&gt;&lt;/s2&gt; &lt;s3&gt;String&lt;/s3&gt;&lt;/c0&gt;のメソッドは&lt;c4&gt;&lt;s5&gt;((Int)&lt;/s5&gt; &lt;s6&gt;-&gt;&lt;/s6&gt; &lt;s7&gt;String)?&lt;/s7&gt;&lt;/c4&gt;になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a private type alias can alias a private, file-private, internal, public, or open type, but a public type alias can’t alias an internal, file-private, or private type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、非公開の型エイリアスは、非公開、ファイル外非公開、内部、公開、または開放型のエイリアス（別名）となることができます、しかし公開型エイリアスは、内部、ファイル外非公開、または非公開型をエイリアスできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a variadic parameter with a name of &lt;c0&gt;&lt;s1&gt;numbers&lt;/s1&gt;&lt;/c0&gt; and a type of &lt;c2&gt;&lt;s3&gt;Double...&lt;/s3&gt;&lt;/c2&gt; is made available within the function’s body as a constant array called &lt;c4&gt;&lt;s5&gt;numbers&lt;/s5&gt;&lt;/c4&gt; of type &lt;c6&gt;&lt;s7&gt;[Double]&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;c0&gt;&lt;s1&gt;numbers&lt;/s1&gt;&lt;/c0&gt;の名前と&lt;c2&gt;&lt;s3&gt;Double...&lt;/s3&gt;&lt;/c2&gt;の型を持つある可変長パラメータは、関数の本文内で型&lt;c4&gt;&lt;s5&gt;[Double]&lt;/s5&gt;&lt;/c4&gt;の&lt;c6&gt;&lt;s7&gt;numbers&lt;/s7&gt;&lt;/c6&gt;と呼ばれるある定数配列として利用可能にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, all of the following string literals have the same value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下の文字列リテラルの全ては、同じ値を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, all the read and write accesses in the code listing below are instantaneous:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のコード出力での全ての読み出しおよび書き込みアクセスは即時的です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, as demonstrated in the code below, you can compare two tuples of type &lt;c0&gt;&lt;s1&gt;(String,&lt;/s1&gt; &lt;s2&gt;Int)&lt;/s2&gt;&lt;/c0&gt; because both &lt;c3&gt;&lt;s4&gt;String&lt;/s4&gt;&lt;/c3&gt; and &lt;c5&gt;&lt;s6&gt;Int&lt;/s6&gt;&lt;/c5&gt; values can be compared using the &lt;c7&gt;&lt;s8&gt;&lt;&lt;/s8&gt;&lt;/c7&gt; operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、下のコードで実演されるように、あなたは型&lt;c0&gt;&lt;s1&gt;(String,&lt;/s1&gt; &lt;s2&gt;Int)&lt;/s2&gt;&lt;/c0&gt;の２つのタプルを比較できます、なぜなら&lt;c3&gt;&lt;s4&gt;String&lt;/s4&gt;&lt;/c3&gt;と&lt;c5&gt;&lt;s6&gt;Int&lt;/s6&gt;&lt;/c5&gt;の値の両方とも&lt;c7&gt;&lt;s8&gt;&lt;&lt;/s8&gt;&lt;/c7&gt;演算子を使って比較できるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, because &lt;c1&gt;&lt;s2&gt;SomeClass.self&lt;/s2&gt;&lt;/c1&gt; evaluates to the &lt;c3&gt;&lt;s4&gt;SomeClass&lt;/s4&gt;&lt;/c3&gt; type itself, you can pass it to a function or method that accepts a type-level argument.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;c1&gt;&lt;s2&gt;SomeClass.self&lt;/s2&gt;&lt;/c1&gt;は&lt;c3&gt;&lt;s4&gt;SomeClass&lt;/s4&gt;&lt;/c3&gt;型それ自体に評価されるので、あなたはそれを型レベルの引数を受け入れる関数またはメソッドへ渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, both functions below have the same behavior:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、下の両方の関数は同じ挙動を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, consider a game where each player has a health amount, which decreases when taking damage, and an energy amount, which decreases when using special abilities.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あるゲームを考えてください、そこにおいて各プレイヤーはダメージを受ける場合に減少する体力量、そして特別な能力を使う場合に減少するエネルギー量を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, consider the case of requesting the sunrise and sunset times from a server.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、日の出と日没の時間をあるサーバーに要請する場合を考えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, given the following simple protocol:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下の簡単なプロトコルを与えられて：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, here is an enumeration that stores simple arithmetic expressions:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、ここに単純な算術式を格納する列挙があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, here’s a function that evaluates an arithmetic expression:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、ここに算術式の数値を求める関数があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, here’s a protocol that refines the &lt;c0&gt;&lt;s1&gt;Container&lt;/s1&gt;&lt;/c0&gt; protocol, adding the requirement of a &lt;c2&gt;&lt;s3&gt;suffix(_:)&lt;/s3&gt;&lt;/c2&gt; method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、ここに&lt;c0&gt;&lt;s1&gt;Container&lt;/s1&gt;&lt;/c0&gt;プロトコルを改良したプロトコルがあり、&lt;c2&gt;&lt;s3&gt;suffix(_:)&lt;/s3&gt;&lt;/c2&gt;メソッドという要件を追加しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, here’s a version of &lt;c0&gt;&lt;s1&gt;SmallRectangle&lt;/s1&gt;&lt;/c0&gt; from the previous code listing that wraps its properties in the &lt;c2&gt;&lt;s3&gt;TwelveOrLess&lt;/s3&gt;&lt;/c2&gt; structure explicitly, instead of writing &lt;c4&gt;&lt;s5&gt;@TwelveOrLess&lt;/s5&gt;&lt;/c4&gt; as an attribute:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、ここに前のコード出力からの&lt;c0&gt;&lt;s1&gt;SmallRectangle&lt;/s1&gt;&lt;/c0&gt;の変形版があります、それはそれのプロパティを&lt;c2&gt;&lt;s3&gt;TwelveOrLess&lt;/s3&gt;&lt;/c2&gt;構造体の中に明示的にラップします、&lt;c4&gt;&lt;s5&gt;@TwelveOrLess&lt;/s5&gt;&lt;/c4&gt;を属性として書く代わりに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, here’s a version of &lt;c0&gt;&lt;s1&gt;flip(_:)&lt;/s1&gt;&lt;/c0&gt; that uses a protocol type as its return type instead of an opaque return type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、ここに&lt;c0&gt;&lt;s1&gt;flip(_:)&lt;/s1&gt;&lt;/c0&gt;のあるバージョンがあります、それはあるプロトコル型をそれの戻り型として使います、不透明戻り型の代わりに：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, here’s a version of the &lt;c0&gt;&lt;s1&gt;Container&lt;/s1&gt;&lt;/c0&gt; protocol from &lt;a2&gt;&lt;s3&gt;Generics&lt;/s3&gt;&lt;/a2&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、ここに&lt;a2&gt;&lt;s3&gt;総称体&lt;/s3&gt;&lt;/a2&gt;からの、&lt;c0&gt;&lt;s1&gt;Container&lt;/s1&gt;&lt;/c0&gt;プロトコルのあるバージョンがあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, here’s an &lt;e0&gt;invalid&lt;/e0&gt; version of the shape-flipping function that includes a special case for squares:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、ここに形状反転関数の&lt;e0&gt;無効な&lt;/e0&gt;バージョンがあります、それは正方形に対する特別な場合を含みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, here’s an extension to the nongeneric &lt;c14&gt;&lt;s15&gt;IntStack&lt;/s15&gt;&lt;/c14&gt; type that adds &lt;c16&gt;&lt;s17&gt;SuffixableContainer&lt;/s17&gt;&lt;/c16&gt; conformance, using &lt;c18&gt;&lt;s19&gt;Stack&lt;Int&gt;&lt;/s19&gt;&lt;/c18&gt; as its suffix type instead of &lt;c20&gt;&lt;s21&gt;IntStack&lt;/s21&gt;&lt;/c20&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、ここに非総称体&lt;c14&gt;&lt;s15&gt;IntStack&lt;/s15&gt;&lt;/c14&gt;型に対する拡張があります、それは&lt;c16&gt;&lt;s17&gt;SuffixableContainer&lt;/s17&gt;&lt;/c16&gt;準拠を、&lt;c18&gt;&lt;s19&gt;Stack&lt;Int&gt;&lt;/s19&gt;&lt;/c18&gt;をそれのsuffix型として&lt;c20&gt;&lt;s21&gt;IntStack&lt;/s21&gt;&lt;/c20&gt;の代わりに使って追加します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, here’s how you might represent the error conditions of operating a vending machine inside a game:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、ここにあなたが表すかもしれないあるゲーム内の自動販売機操作のエラー状況がどのようなものかがあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if &lt;c0&gt;&lt;s1&gt;balance(_:_:)&lt;/s1&gt;&lt;/c0&gt; was an operator function named &lt;c2&gt;&lt;s3&gt;&lt;^&gt;&lt;/s3&gt;&lt;/c2&gt;, writing &lt;c4&gt;&lt;s5&gt;playerOneScore&lt;/s5&gt; &lt;s6&gt;&lt;^&gt;&lt;/s6&gt; &lt;s7&gt;playerOneScore&lt;/s7&gt;&lt;/c4&gt; would result in the same conflict as &lt;c8&gt;&lt;s9&gt;balance(&amp;playerOneScore,&lt;/s9&gt; &lt;s10&gt;&amp;playerOneScore)&lt;/s10&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;c0&gt;&lt;s1&gt;balance(_:_:)&lt;/s1&gt;&lt;/c0&gt;が&lt;c2&gt;&lt;s3&gt;&lt;^&gt;&lt;/s3&gt;&lt;/c2&gt;という名前の演算子関数であったならば、書き込み&lt;c4&gt;&lt;s5&gt;playerOneScore&lt;/s5&gt; &lt;s6&gt;&lt;^&gt;&lt;/s6&gt; &lt;s7&gt;playerOneScore&lt;/s7&gt;&lt;/c4&gt;は、&lt;c8&gt;&lt;s9&gt;balance(&amp;playerOneScore,&lt;/s9&gt; &lt;s10&gt;&amp;playerOneScore)&lt;/s10&gt;&lt;/c8&gt;と同じ衝突という結果になるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if a public type conforms to an internal protocol, the type’s implementation of each protocol requirement must be at least internal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、ある公開型が内部プロトコルに準拠するならば、その型の持つ各プロトコル要件の実装は、少なくとも内部でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if a type is public, but a protocol it conforms to is internal, the type’s conformance to that protocol is also internal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、ある型が公開である、しかしそれが準拠するプロトコルは内部であるならば、その型のもつそのプロトコルに対する準拠もまた内部です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if the variable &lt;c0&gt;&lt;s1&gt;holly&lt;/s1&gt;&lt;/c0&gt; in the example above is changed to a local variable instead of a global variable, the compiler can prove that overlapping access to stored properties of the structure is safe:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、変数&lt;c0&gt;&lt;s1&gt;holly&lt;/s1&gt;&lt;/c0&gt;が上の例においてグローバル変数ではなくローカル変数に変更されるならば、コンパイラは構造体に属する格納プロパティへのオーバーラッブするアクセスが安全であることを立証できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you assign a literal value of &lt;c0&gt;&lt;s1&gt;42&lt;/s1&gt;&lt;/c0&gt; to a new constant without saying what type it is, Swift infers that you want the constant to be an &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;, because you have initialized it with a number that looks like an integer:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたがそれがどんな型であるかについて言うことなく、新しい定数にリテラル値&lt;c0&gt;&lt;s1&gt;42&lt;/s1&gt;&lt;/c0&gt;を代入するならば、スウィフトは、あなたがその定数に&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;であって欲しいのだと推測します、なぜならあなたがそれを整数のように見える数で初期化したからです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you compile your code using the Swift 5 compiler in Swift 4.2 mode, the compiler version is 5 and the language version is 4.2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたがSwift 5コンパイラを使ってSwift 4.2モードであなたのコードをコンパイルするならば、コンパイラバージョンは5で、言語バージョンは4.2です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you compose a tuple from two different types, one with internal access and one with private access, the access level for that compound tuple type will be private.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたが２つの異なる型、内部アクセスを持つものと非公開アクセスを持つものからタプルを組み立てるならば、その複合のタプル型のためのアクセス水準は非公開になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you create a custom class to open a file and write some data to it, you might need to close the file before the class instance is deallocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたがファイルを開いてそれに何かのデータを書くあつらえのクラスを作成するならば、クラスインスタンスが割り当て解除される前に、あなたはファイルを閉じる必要があるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you define a file-private class, that class can only be used as the type of a property, or as a function parameter or return type, in the source file in which the file-private class is defined.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたがあるファイル外非公開のクラスを定義するならば、そのクラスは、プロパティの型として、または関数パラメータや戻り型として、そのファイル外非公開クラスが定義されるソースファイルの中で使われることだけができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you have properties that provide thread-safety checks or store their underlying data in a database, you have to write that code on every property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたがスレッド安全検査を提供するまたはそれらの基礎をなすデータをデータベースに格納するプロパティそれらを持つならば、あなたはそのコードをあらゆるプロパティ上で書かなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you initialize a new string with the four-character word &lt;c0&gt;&lt;s1&gt;cafe&lt;/s1&gt;&lt;/c0&gt;, and then append a &lt;c2&gt;&lt;s3&gt;COMBINING&lt;/s3&gt; &lt;s4&gt;ACUTE&lt;/s4&gt; &lt;s5&gt;ACCENT&lt;/s5&gt;&lt;/c2&gt; (&lt;c6&gt;&lt;s7&gt;U+0301&lt;/s7&gt;&lt;/c6&gt;) to the end of the string, the resulting string will still have a character count of &lt;c8&gt;&lt;s9&gt;4&lt;/s9&gt;&lt;/c8&gt;, with a fourth character of &lt;c10&gt;&lt;s11&gt;é&lt;/s11&gt;&lt;/c10&gt;, not &lt;c12&gt;&lt;s13&gt;e&lt;/s13&gt;&lt;/c12&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたがある新しい文字列を４文字の単語&lt;c0&gt;&lt;s1&gt;cafe&lt;/s1&gt;&lt;/c0&gt;で初期化して、それから&lt;c2&gt;&lt;s3&gt;COMBINING&lt;/s3&gt; &lt;s4&gt;ACUTE&lt;/s4&gt; &lt;s5&gt;ACCENT&lt;/s5&gt;&lt;/c2&gt;（&lt;c6&gt;&lt;s7&gt;U+0301&lt;/s7&gt;&lt;/c6&gt;）をその文字列の終わりに加えたならば、結果の文字列は依然として文字数&lt;c8&gt;&lt;s9&gt;4&lt;/s9&gt;&lt;/c8&gt;で、&lt;c12&gt;&lt;s13&gt;e&lt;/s13&gt;&lt;/c12&gt;ではなく、&lt;c10&gt;&lt;s11&gt;é&lt;/s11&gt;&lt;/c10&gt;の４番目の文字を持ちます：&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you make a function call inside a subscript in a key path expression, the function is called only once as part of evaluating the expression, not every time the key path is used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたがキーパス式の中の添え字内で関数呼び出しを作るならば、関数は式の評価の一部としてただ一度だけ呼び出されます、キーパス式が使われるたびごとではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you provide an initial value and a maximum value, Swift uses the &lt;c0&gt;&lt;s1&gt;init(wrappedValue:maximum:)&lt;/s1&gt;&lt;/c0&gt; initializer:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたが初期値と最大値を提供するならば、スウィフトは&lt;c0&gt;&lt;s1&gt;init(wrappedValue:maximum:)&lt;/s1&gt;&lt;/c0&gt;イニシャライザを使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if you write &lt;c16&gt;&lt;s17&gt;let&lt;/s17&gt; &lt;s18&gt;dict:&lt;/s18&gt; &lt;s19&gt;Dictionary&lt;/s19&gt; &lt;s20&gt;=&lt;/s20&gt; &lt;s21&gt;["A":&lt;/s21&gt; &lt;s22&gt;1]&lt;/s22&gt;&lt;/c16&gt;, the compiler infers that &lt;c23&gt;&lt;s24&gt;dict&lt;/s24&gt;&lt;/c23&gt; has the type &lt;c25&gt;&lt;s26&gt;Dictionary&lt;String,&lt;/s26&gt; &lt;s27&gt;Int&gt;&lt;/s27&gt;&lt;/c25&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば、あなたが&lt;c16&gt;&lt;s17&gt;let&lt;/s17&gt; &lt;s18&gt;dict:&lt;/s18&gt; &lt;s19&gt;Dictionary&lt;/s19&gt; &lt;s20&gt;=&lt;/s20&gt; &lt;s21&gt;["A":&lt;/s21&gt; &lt;s22&gt;1]&lt;/s22&gt;&lt;/c16&gt;を書くならば、コンパイラは&lt;c23&gt;&lt;s24&gt;dict&lt;/s24&gt;&lt;/c23&gt;が型&lt;c25&gt;&lt;s26&gt;Dictionary&lt;String,&lt;/s26&gt; &lt;s27&gt;Int&gt;&lt;/s27&gt;&lt;/c25&gt;を持つと推測します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if your app uses a custom subclass of &lt;c6&gt;&lt;s7&gt;UIApplication&lt;/s7&gt;&lt;/c6&gt; as its principal class, call the &lt;c8&gt;&lt;s9&gt;UIApplicationMain(_:_:_:_:)&lt;/s9&gt;&lt;/c8&gt; function instead of using this attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたのアプリがそれの主役クラス（プリンシパルクラス）として&lt;c6&gt;&lt;s7&gt;UIApplication&lt;/s7&gt;&lt;/c6&gt;のあつらえのサブクラスを使うならば、&lt;c8&gt;&lt;s9&gt;UIApplicationMain(_:_:_:_:)&lt;/s9&gt;&lt;/c8&gt;関数をこの属性を使用する代わりに呼んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if your string is &lt;c2&gt;&lt;s3&gt;#"Line&lt;/s3&gt; &lt;s4&gt;1\nLine&lt;/s4&gt; &lt;s5&gt;2"#&lt;/s5&gt;&lt;/c2&gt; and you want to break the line, you can use &lt;c6&gt;&lt;s7&gt;#"Line&lt;/s7&gt; &lt;s8&gt;1\#nLine&lt;/s8&gt; &lt;s9&gt;2"#&lt;/s9&gt;&lt;/c6&gt; instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたの文字列が&lt;c2&gt;&lt;s3&gt;#"Line&lt;/s3&gt; &lt;s4&gt;1\nLine&lt;/s4&gt; &lt;s5&gt;2"#&lt;/s5&gt;&lt;/c2&gt;であるそしてあなたが行を改めることを望むならば、あなたは&lt;c6&gt;&lt;s7&gt;#"Line&lt;/s7&gt; &lt;s8&gt;1\#nLine&lt;/s8&gt; &lt;s9&gt;2"#&lt;/s9&gt;&lt;/c6&gt;を代わりに使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, in addition to the values of scalar types, such as integers and characters, your code can branch on the values of any type, including floating-point numbers, strings, tuples, instances of custom classes, and optionals.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば、整数と文字のようなスカラー型の値に加えて、あなたのコードは、浮動小数点数、文字列、タプル、あつらえのクラスのインスタンス、そしてオプショナルを含むあらゆる型の値に関して分岐することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, in the code below, &lt;c2&gt;&lt;s3&gt;SomeStruct&lt;/s3&gt;&lt;/c2&gt; calls each of the initializers that &lt;c4&gt;&lt;s5&gt;SomeWrapper&lt;/s5&gt;&lt;/c4&gt; defines.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、下のコードにおいて、&lt;c2&gt;&lt;s3&gt;SomeStruct&lt;/s3&gt;&lt;/c2&gt;は、&lt;c4&gt;&lt;s5&gt;SomeWrapper&lt;/s5&gt;&lt;/c4&gt;が定義するイニシャライザそれぞれを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, in the code below, the closure passed to &lt;c4&gt;&lt;s5&gt;someFunctionWithEscapingClosure(_:)&lt;/s5&gt;&lt;/c4&gt; is an escaping closure, which means it needs to refer to &lt;c6&gt;&lt;s7&gt;self&lt;/s7&gt;&lt;/c6&gt; explicitly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のコードにおいて、&lt;c4&gt;&lt;s5&gt;someFunctionWithEscapingClosure(_:)&lt;/s5&gt;&lt;/c4&gt;に渡されるクロージャは脱出クロージャです、それは、それが&lt;c6&gt;&lt;s7&gt;self&lt;/s7&gt;&lt;/c6&gt;を明示的に参照する必要があるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, in the declaration &lt;c0&gt;&lt;s1&gt;let&lt;/s1&gt; &lt;s2&gt;x:&lt;/s2&gt; &lt;s3&gt;Int8&lt;/s3&gt; &lt;s4&gt;=&lt;/s4&gt; &lt;s5&gt;42&lt;/s5&gt;&lt;/c0&gt;, Swift uses the explicit type annotation (&lt;c6&gt;&lt;s7&gt;:&lt;/s7&gt; &lt;s8&gt;Int8&lt;/s8&gt;&lt;/c6&gt;) to infer that the type of the integer literal &lt;c9&gt;&lt;s10&gt;42&lt;/s10&gt;&lt;/c9&gt; is &lt;c11&gt;&lt;s12&gt;Int8&lt;/s12&gt;&lt;/c11&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、宣言&lt;c0&gt;&lt;s1&gt;let&lt;/s1&gt; &lt;s2&gt;x:&lt;/s2&gt; &lt;s3&gt;Int8&lt;/s3&gt; &lt;s4&gt;=&lt;/s4&gt; &lt;s5&gt;42&lt;/s5&gt;&lt;/c0&gt;において、スウィフトは明示的な型注釈（&lt;c6&gt;&lt;s7&gt;:&lt;/s7&gt; &lt;s8&gt;Int8&lt;/s8&gt;&lt;/c6&gt;）を使って、整数リテラル&lt;c9&gt;&lt;s10&gt;42&lt;/s10&gt;&lt;/c9&gt;の型は&lt;c11&gt;&lt;s12&gt;Int8&lt;/s12&gt;&lt;/c11&gt;であると推論します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, in the declaration &lt;c21&gt;&lt;s22&gt;let&lt;/s22&gt; &lt;s23&gt;str&lt;/s23&gt; &lt;s24&gt;=&lt;/s24&gt; &lt;s25&gt;"Hello,&lt;/s25&gt; &lt;s26&gt;world"&lt;/s26&gt;&lt;/c21&gt;, the default inferred type of the string literal &lt;c27&gt;&lt;s28&gt;"Hello,&lt;/s28&gt; &lt;s29&gt;world"&lt;/s29&gt;&lt;/c27&gt; is &lt;c30&gt;&lt;s31&gt;String&lt;/s31&gt;&lt;/c30&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、宣言&lt;c21&gt;&lt;s22&gt;let&lt;/s22&gt; &lt;s23&gt;str&lt;/s23&gt; &lt;s24&gt;=&lt;/s24&gt; &lt;s25&gt;"Hello,&lt;/s25&gt; &lt;s26&gt;world"&lt;/s26&gt;&lt;/c21&gt;において、文字列リテラル&lt;c27&gt;&lt;s28&gt;"Hello,&lt;/s28&gt; &lt;s29&gt;world"&lt;/s29&gt;&lt;/c27&gt;の省略時の推論される型は&lt;c30&gt;&lt;s31&gt;String&lt;/s31&gt;&lt;/c30&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, in the following assignment 10 is assigned to &lt;c1&gt;&lt;s2&gt;x&lt;/s2&gt;&lt;/c1&gt; and 20 is ignored:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下の代入において、10は&lt;c1&gt;&lt;s2&gt;x&lt;/s2&gt;&lt;/c1&gt;に代入されて20は無視されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, in the following code &lt;c6&gt;&lt;s7&gt;x&lt;/s7&gt;&lt;/c6&gt; and &lt;c8&gt;&lt;s9&gt;y&lt;/s9&gt;&lt;/c8&gt; have the same value and behavior:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のコードにおいて&lt;c6&gt;&lt;s7&gt;x&lt;/s7&gt;&lt;/c6&gt;と&lt;c8&gt;&lt;s9&gt;y&lt;/s9&gt;&lt;/c8&gt;は、同じ値と挙動を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, in the following constant declaration, &lt;c1&gt;&lt;s2&gt;someValue&lt;/s2&gt;&lt;/c1&gt; is an identifier pattern that matches the value &lt;c3&gt;&lt;s4&gt;42&lt;/s4&gt;&lt;/c3&gt; of type &lt;c5&gt;&lt;s6&gt;Int&lt;/s6&gt;&lt;/c5&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下の定数宣言において、&lt;c1&gt;&lt;s2&gt;someValue&lt;/s2&gt;&lt;/c1&gt;は、型&lt;c5&gt;&lt;s6&gt;Int&lt;/s6&gt;&lt;/c5&gt;の値&lt;c3&gt;&lt;s4&gt;42&lt;/s4&gt;&lt;/c3&gt;にマッチする識別子パターンです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, in the generic function below, the generic parameter &lt;c1&gt;&lt;s2&gt;T:&lt;/s2&gt; &lt;s3&gt;Comparable&lt;/s3&gt;&lt;/c1&gt; indicates that any type argument substituted for the type parameter &lt;c4&gt;&lt;s5&gt;T&lt;/s5&gt;&lt;/c4&gt; must conform to the &lt;c6&gt;&lt;s7&gt;Comparable&lt;/s7&gt;&lt;/c6&gt; protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば、下記の総称体関数において、総称体パラメータ&lt;c1&gt;&lt;s2&gt;T:&lt;/s2&gt; &lt;s3&gt;Comparable&lt;/s3&gt;&lt;/c1&gt;は、型パラメータ&lt;c4&gt;&lt;s5&gt;T&lt;/s5&gt;&lt;/c4&gt;と置き換えられる任意の型の引数は&lt;c6&gt;&lt;s7&gt;Comparable&lt;/s7&gt;&lt;/c6&gt;プロトコルに準拠しなければならないことを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, instances of a user-defined class named &lt;c1&gt;&lt;s2&gt;MyClass&lt;/s2&gt;&lt;/c1&gt; have the type &lt;c3&gt;&lt;s4&gt;MyClass&lt;/s4&gt;&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;c1&gt;&lt;s2&gt;MyClass&lt;/s2&gt;&lt;/c1&gt;という名前をつけられるユーザー定義のクラスのインスタンスは、型&lt;c3&gt;&lt;s4&gt;MyClass&lt;/s4&gt;&lt;/c3&gt;を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, instead of writing &lt;c1&gt;&lt;s2&gt;var&lt;/s2&gt; &lt;s3&gt;x:&lt;/s3&gt; &lt;s4&gt;Int&lt;/s4&gt; &lt;s5&gt;=&lt;/s5&gt; &lt;s6&gt;0&lt;/s6&gt;&lt;/c1&gt;, you can write &lt;c7&gt;&lt;s8&gt;var&lt;/s8&gt; &lt;s9&gt;x&lt;/s9&gt; &lt;s10&gt;=&lt;/s10&gt; &lt;s11&gt;0&lt;/s11&gt;&lt;/c7&gt;, omitting the type completely—the compiler correctly infers that &lt;c12&gt;&lt;s13&gt;x&lt;/s13&gt;&lt;/c12&gt; names a value of type &lt;c14&gt;&lt;s15&gt;Int&lt;/s15&gt;&lt;/c14&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;c1&gt;&lt;s2&gt;var&lt;/s2&gt; &lt;s3&gt;x:&lt;/s3&gt; &lt;s4&gt;Int&lt;/s4&gt; &lt;s5&gt;=&lt;/s5&gt; &lt;s6&gt;0&lt;/s6&gt;&lt;/c1&gt;を書く代わりに、あなたは型を完全に省略して&lt;c7&gt;&lt;s8&gt;var&lt;/s8&gt; &lt;s9&gt;x&lt;/s9&gt; &lt;s10&gt;=&lt;/s10&gt; &lt;s11&gt;0&lt;/s11&gt;&lt;/c7&gt;と書くことができます ― コンパイラは、&lt;c12&gt;&lt;s13&gt;x&lt;/s13&gt;&lt;/c12&gt;が型&lt;c14&gt;&lt;s15&gt;Int&lt;/s15&gt;&lt;/c14&gt;の値に名をつけると正しく推測します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, it’s not possible to write an &lt;c6&gt;&lt;s7&gt;==&lt;/s7&gt;&lt;/c6&gt; operator comparing results returned by this function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、この関数によって返される結果を比較する&lt;c6&gt;&lt;s7&gt;==&lt;/s7&gt;&lt;/c6&gt;演算子を書くことは可能ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, operator precedence explains why the following expression equals &lt;c0&gt;&lt;s1&gt;17&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、演算子優先順位は、なぜ以下の式が&lt;c0&gt;&lt;s1&gt;17&lt;/s1&gt;&lt;/c0&gt;に等しいのかを説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, overlapping write accesses to the elements of a tuple produces a conflict:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あるタプルの要素いくつかへの書き込みアクセスがオーバーラップすると衝突を生み出します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, printing the string literal &lt;c5&gt;&lt;s6&gt;#"Line&lt;/s6&gt; &lt;s7&gt;1\nLine&lt;/s7&gt; &lt;s8&gt;2"#&lt;/s8&gt;&lt;/c5&gt; prints the line feed escape sequence (&lt;c9&gt;&lt;s10&gt;\n&lt;/s10&gt;&lt;/c9&gt;) rather than printing the string across two lines.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、文字列リテラル&lt;c5&gt;&lt;s6&gt;#"Line&lt;/s6&gt; &lt;s7&gt;1\nLine&lt;/s7&gt; &lt;s8&gt;2"#&lt;/s8&gt;&lt;/c5&gt;をブリントすることは、行送りエスケープシーケンス（&lt;c9&gt;&lt;s10&gt;\n&lt;/s10&gt;&lt;/c9&gt;）をプリントします、プリントする文字列が２つの行に渡るのではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, suppose an inventory tracking system needs to track products by two different types of barcode.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、ある在庫追跡システムが、２つの異なる型のバーコードによって製品を追跡する必要があると思ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, suppose you want to make a version of &lt;c2&gt;&lt;s3&gt;Container&lt;/s3&gt;&lt;/c2&gt; that includes an iterator, like what the &lt;c4&gt;&lt;s5&gt;Sequence&lt;/s5&gt;&lt;/c4&gt; protocol uses in the standard library.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたが&lt;c2&gt;&lt;s3&gt;Container&lt;/s3&gt;&lt;/c2&gt;のあるバージョンを作りたいと仮定してください、それはあるイテレータ、標準ライブラリで使われている&lt;c4&gt;&lt;s5&gt;Sequence&lt;/s5&gt;&lt;/c4&gt;プロトコルのようなものを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, suppose you’re writing a module that draws ASCII art shapes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたがさまざまなASCIIアート形状を描くモジュールを記述していると仮定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the &lt;c0&gt;&lt;s1&gt;Diccionario&lt;/s1&gt;&lt;/c0&gt; type alias declared here has the same generic parameters and constraints as &lt;c2&gt;&lt;s3&gt;Dictionary&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、ここで宣言される&lt;c0&gt;&lt;s1&gt;Diccionario&lt;/s1&gt;&lt;/c0&gt;型エイリアスは、&lt;c2&gt;&lt;s3&gt;Dictionary&lt;/s3&gt;&lt;/c2&gt;と同じ総称体パラメータと制約を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the &lt;c0&gt;&lt;s1&gt;Int16&lt;/s1&gt;&lt;/c0&gt; integer type can hold any signed integer between &lt;c2&gt;&lt;s3&gt;-32768&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;32767&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;c0&gt;&lt;s1&gt;Int16&lt;/s1&gt;&lt;/c0&gt;整数型は、&lt;c2&gt;&lt;s3&gt;-32768&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;32767&lt;/s5&gt;&lt;/c4&gt;の間のどんな符号つき整数でも持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the &lt;c0&gt;&lt;s1&gt;PrettyTextRepresentable&lt;/s1&gt;&lt;/c0&gt; protocol, which inherits the &lt;c2&gt;&lt;s3&gt;TextRepresentable&lt;/s3&gt;&lt;/c2&gt; protocol can provide a default implementation of its required &lt;c4&gt;&lt;s5&gt;prettyTextualDescription&lt;/s5&gt;&lt;/c4&gt; property to simply return the result of accessing the &lt;c6&gt;&lt;s7&gt;textualDescription&lt;/s7&gt;&lt;/c6&gt; property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;c2&gt;&lt;s3&gt;TextRepresentable&lt;/s3&gt;&lt;/c2&gt;プロトコルを継承する&lt;c0&gt;&lt;s1&gt;prettyTextualDescription&lt;/s1&gt;&lt;/c0&gt;プロパティは、それの必須プロパティ&lt;c4&gt;&lt;s5&gt;prettyTextualDescription&lt;/s5&gt;&lt;/c4&gt;の省略時の実装を提供して、単に&lt;c6&gt;&lt;s7&gt;textualDescription&lt;/s7&gt;&lt;/c6&gt;プロパティの結果を返すようにできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the &lt;c0&gt;&lt;s1&gt;RandomNumberGenerator&lt;/s1&gt;&lt;/c0&gt; protocol can be extended to provide a &lt;c2&gt;&lt;s3&gt;randomBool()&lt;/s3&gt;&lt;/c2&gt; method, which uses the result of the required &lt;c4&gt;&lt;s5&gt;random()&lt;/s5&gt;&lt;/c4&gt; method to return a random &lt;c6&gt;&lt;s7&gt;Bool&lt;/s7&gt;&lt;/c6&gt; value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;c0&gt;&lt;s1&gt;RandomNumberGenerator&lt;/s1&gt;&lt;/c0&gt;プロトコルは拡張されて&lt;c2&gt;&lt;s3&gt;randomBool()&lt;/s3&gt;&lt;/c2&gt;メソッドを提供することができます、それは必須メソッドの&lt;c4&gt;&lt;s5&gt;random()&lt;/s5&gt;&lt;/c4&gt;を利用してランダムな&lt;c6&gt;&lt;s7&gt;Bool&lt;/s7&gt;&lt;/c6&gt;値を返すものです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the &lt;c0&gt;&lt;s1&gt;UntitledDocument&lt;/s1&gt;&lt;/c0&gt; subclass below is always named &lt;c2&gt;&lt;s3&gt;"[Untitled]"&lt;/s3&gt;&lt;/c2&gt;, and it uses the failable &lt;c4&gt;&lt;s5&gt;init(name:)&lt;/s5&gt;&lt;/c4&gt; initializer from its superclass during initialization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、下の&lt;c0&gt;&lt;s1&gt;UntitledDocument&lt;/s1&gt;&lt;/c0&gt;サブクラスは、常に&lt;c2&gt;&lt;s3&gt;"[Untitled]"&lt;/s3&gt;&lt;/c2&gt;と名前をつけられます、そしてそれは失敗できる&lt;c4&gt;&lt;s5&gt;init(name:)&lt;/s5&gt;&lt;/c4&gt;イニシャライザをそれのスーパークラスから初期化の間に使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the &lt;c0&gt;&lt;s1&gt;asHTML&lt;/s1&gt;&lt;/c0&gt; property could be set to a closure that defaults to some text if the &lt;c2&gt;&lt;s3&gt;text&lt;/s3&gt;&lt;/c2&gt; property is &lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;, in order to prevent the representation from returning an empty HTML tag:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;c0&gt;&lt;s1&gt;asHTML&lt;/s1&gt;&lt;/c0&gt;プロパティは、あるクロージャに設定されることができます、それは&lt;c2&gt;&lt;s3&gt;text&lt;/s3&gt;&lt;/c2&gt;プロパティが&lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;ならば特に何もしなくともいくらかのテキストになり、その表現が空のHTMLタグを返すことを予防する手段となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the &lt;c0&gt;&lt;s1&gt;discardableResult&lt;/s1&gt;&lt;/c0&gt; attribute on a function declaration indicates that, although the function returns a value, the compiler shouldn’t generate a warning if the return value is unused.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、ある関数宣言上での&lt;c0&gt;&lt;s1&gt;discardableResult&lt;/s1&gt;&lt;/c0&gt;属性が指し示すのは、たとえその関数が値を返すとしても、コンパイラは戻り値が使われなくても警告を生成すべきでないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the &lt;c10&gt;&lt;s11&gt;buyFavoriteSnack(person:vendingMachine:)&lt;/s11&gt;&lt;/c10&gt; in the example below is also a throwing function, and any errors that the &lt;c12&gt;&lt;s13&gt;vend(itemNamed:)&lt;/s13&gt;&lt;/c12&gt; method throws will propagate up to the point where the &lt;c14&gt;&lt;s15&gt;buyFavoriteSnack(person:vendingMachine:)&lt;/s15&gt;&lt;/c14&gt; function is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば、下の例の&lt;c10&gt;&lt;s11&gt;buyFavoriteSnack(person:vendingMachine:)&lt;/s11&gt;&lt;/c10&gt;もまたスロー関数です、そして&lt;c12&gt;&lt;s13&gt;vend(itemNamed:)&lt;/s13&gt;&lt;/c12&gt;メソッドがスローするあらゆるエラーは、&lt;c14&gt;&lt;s15&gt;buyFavoriteSnack(person:vendingMachine:)&lt;/s15&gt;&lt;/c14&gt;関数が呼び出される地点へとさかのぼり伝えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the &lt;c27&gt;&lt;s28&gt;&lt;&lt;/s28&gt;&lt;/c27&gt; operator has an associativity of &lt;c29&gt;&lt;s30&gt;none&lt;/s30&gt;&lt;/c29&gt;, which means &lt;c31&gt;&lt;s32&gt;1&lt;/s32&gt; &lt;s33&gt;&lt;&lt;/s33&gt; &lt;s34&gt;2&lt;/s34&gt; &lt;s35&gt;&lt;&lt;/s35&gt; &lt;s36&gt;3&lt;/s36&gt;&lt;/c31&gt; is not a valid expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;c27&gt;&lt;s28&gt;&lt;&lt;/s28&gt;&lt;/c27&gt;演算子は、&lt;c29&gt;&lt;s30&gt;none&lt;/s30&gt;&lt;/c29&gt;の関係性を持ちます、それは&lt;c31&gt;&lt;s32&gt;1&lt;/s32&gt; &lt;s33&gt;&lt;&lt;/s33&gt; &lt;s34&gt;2&lt;/s34&gt; &lt;s35&gt;&lt;&lt;/s35&gt; &lt;s36&gt;3&lt;/s36&gt;&lt;/c31&gt;が有効な式でないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the &lt;c2&gt;&lt;s3&gt;assert(condition:message:file:line:)&lt;/s3&gt;&lt;/c2&gt; function takes an autoclosure for its &lt;c4&gt;&lt;s5&gt;condition&lt;/s5&gt;&lt;/c4&gt; and &lt;c6&gt;&lt;s7&gt;message&lt;/s7&gt;&lt;/c6&gt; parameters; its &lt;c8&gt;&lt;s9&gt;condition&lt;/s9&gt;&lt;/c8&gt; parameter is evaluated only in debug builds and its &lt;c10&gt;&lt;s11&gt;message&lt;/s11&gt;&lt;/c10&gt; parameter is evaluated only if &lt;c12&gt;&lt;s13&gt;condition&lt;/s13&gt;&lt;/c12&gt; is &lt;c14&gt;&lt;s15&gt;false&lt;/s15&gt;&lt;/c14&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;c2&gt;&lt;s3&gt;assert(condition:message:file:line:)&lt;/s3&gt;&lt;/c2&gt;関数は自動クロージャをそれの&lt;c4&gt;&lt;s5&gt;condition&lt;/s5&gt;&lt;/c4&gt;と&lt;c6&gt;&lt;s7&gt;message&lt;/s7&gt;&lt;/c6&gt;パラメータとして取ります；それの&lt;c8&gt;&lt;s9&gt;condition&lt;/s9&gt;&lt;/c8&gt;パラメータはデバッグビルドにおいてのみ評価されます、そしてそれの&lt;c10&gt;&lt;s11&gt;message&lt;/s11&gt;&lt;/c10&gt;パラメータは&lt;c12&gt;&lt;s13&gt;condition&lt;/s13&gt;&lt;/c12&gt;が&lt;c14&gt;&lt;s15&gt;false&lt;/s15&gt;&lt;/c14&gt;である場合にのみ評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the Swift standard library includes both a top-level &lt;a0&gt;&lt;c1&gt;&lt;s2&gt;min(_:_:)&lt;/s2&gt;&lt;/c1&gt;&lt;/a0&gt;&lt;s3&gt; [https://developer.apple.com/documentation/swift/1538339-min/]&lt;/s3&gt; function and a &lt;a4&gt;&lt;c5&gt;&lt;s6&gt;min()&lt;/s6&gt;&lt;/c5&gt;&lt;/a4&gt;&lt;s7&gt; [https://developer.apple.com/documentation/swift/sequence/1641174-min]&lt;/s7&gt; method for sequences with comparable elements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、スウィフト標準ライブラリはトップレベルの&lt;a0&gt;&lt;c1&gt;&lt;s2&gt;min(_:_:)&lt;/s2&gt;&lt;/c1&gt;&lt;/a0&gt;&lt;s3&gt; [https://developer.apple.com/documentation/swift/1538339-min/]&lt;/s3&gt;関数と&lt;a4&gt;&lt;c5&gt;&lt;s6&gt;min()&lt;/s6&gt;&lt;/c5&gt;&lt;/a4&gt;&lt;s7&gt; [https://developer.apple.com/documentation/swift/sequence/1641174-min]&lt;/s7&gt;メソッドの両方を、比較可能な要素を持つシーケンスに対して含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the above example can be written so any error that isn’t a &lt;c0&gt;&lt;s1&gt;VendingMachineError&lt;/s1&gt;&lt;/c0&gt; is instead caught by the calling function:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、上の例は&lt;c0&gt;&lt;s1&gt;VendingMachineError&lt;/s1&gt;&lt;/c0&gt;でないあらゆるエラーが、呼び出し側の関数によって代わりにキャッチされるように書かれることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the addition (&lt;c0&gt;&lt;s1&gt;+&lt;/s1&gt;&lt;/c0&gt;) and subtraction (&lt;c2&gt;&lt;s3&gt;-&lt;/s3&gt;&lt;/c2&gt;) operators belong to the &lt;c4&gt;&lt;s5&gt;AdditionPrecedence&lt;/s5&gt;&lt;/c4&gt; group, and the multiplication (&lt;c6&gt;&lt;s7&gt;*&lt;/s7&gt;&lt;/c6&gt;) and division (&lt;c8&gt;&lt;s9&gt;/&lt;/s9&gt;&lt;/c8&gt;) operators belong to the &lt;c10&gt;&lt;s11&gt;MultiplicationPrecedence&lt;/s11&gt;&lt;/c10&gt; group.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、加算（&lt;c0&gt;&lt;s1&gt;+&lt;/s1&gt;&lt;/c0&gt;）および減算（&lt;c2&gt;&lt;s3&gt;-&lt;/s3&gt;&lt;/c2&gt;）演算子は、&lt;c4&gt;&lt;s5&gt;AdditionPrecedence&lt;/s5&gt;&lt;/c4&gt;グルーブに所属し、そして乗算（&lt;c6&gt;&lt;s7&gt;*&lt;/s7&gt;&lt;/c6&gt;）および減算（&lt;c8&gt;&lt;s9&gt;/&lt;/s9&gt;&lt;/c8&gt;）演算子は&lt;c10&gt;&lt;s11&gt;MultiplicationPrecedence&lt;/s11&gt;&lt;/c10&gt;グルーブに属します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the addition assignment operator (&lt;c3&gt;&lt;s4&gt;+=&lt;/s4&gt;&lt;/c3&gt;) combines addition and assignment into a single operation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、加算代入演算子（&lt;c3&gt;&lt;s4&gt;+=&lt;/s4&gt;&lt;/c3&gt;）は、加算と代入を一回の操作に結合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the addition operator (&lt;c1&gt;&lt;s2&gt;+&lt;/s2&gt;&lt;/c1&gt;) adds two numbers, as in &lt;c3&gt;&lt;s4&gt;let&lt;/s4&gt; &lt;s5&gt;i&lt;/s5&gt; &lt;s6&gt;=&lt;/s6&gt; &lt;s7&gt;1&lt;/s7&gt; &lt;s8&gt;+&lt;/s8&gt; &lt;s9&gt;2&lt;/s9&gt;&lt;/c3&gt;, and the logical AND operator (&lt;c10&gt;&lt;s11&gt;&amp;&amp;&lt;/s11&gt;&lt;/c10&gt;) combines two Boolean values, as in &lt;c12&gt;&lt;s13&gt;if&lt;/s13&gt; &lt;s14&gt;enteredDoorCode&lt;/s14&gt; &lt;s15&gt;&amp;&amp;&lt;/s15&gt; &lt;s16&gt;passedRetinaScan&lt;/s16&gt;&lt;/c12&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、加算演算子（&lt;c1&gt;&lt;s2&gt;+&lt;/s2&gt;&lt;/c1&gt;）は、&lt;c3&gt;&lt;s4&gt;let&lt;/s4&gt; &lt;s5&gt;i&lt;/s5&gt; &lt;s6&gt;=&lt;/s6&gt; &lt;s7&gt;1&lt;/s7&gt; &lt;s8&gt;+&lt;/s8&gt; &lt;s9&gt;2&lt;/s9&gt;&lt;/c3&gt;のように、２つの数を加えてひとつにします、そして論理積演算子（&lt;c10&gt;&lt;s11&gt;&amp;&amp;&lt;/s11&gt;&lt;/c10&gt;）は、&lt;c12&gt;&lt;s13&gt;if&lt;/s13&gt; &lt;s14&gt;enteredDoorCode&lt;/s14&gt; &lt;s15&gt;&amp;&amp;&lt;/s15&gt; &lt;s16&gt;passedRetinaScan&lt;/s16&gt;&lt;/c12&gt;のように、２つのブール値を組み合わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the class below ensures that the side length of its triangle is always the same as the side length of its square.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、下のクラスは、その三角形の横の長さが常にその正方形の横の長さと同じものであることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the code below shows an instance method &lt;c0&gt;&lt;s1&gt;f&lt;/s1&gt;&lt;/c0&gt; whose return type is &lt;c2&gt;&lt;s3&gt;Self&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のコードはインスタンスメソッド&lt;c0&gt;&lt;s1&gt;f&lt;/s1&gt;&lt;/c0&gt;を示します、それの戻り型は&lt;c2&gt;&lt;s3&gt;Self&lt;/s3&gt;&lt;/c2&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the code in &lt;c4&gt;&lt;s5&gt;resize(to:)&lt;/s5&gt;&lt;/c4&gt; accesses &lt;c6&gt;&lt;s7&gt;height&lt;/s7&gt;&lt;/c6&gt; and &lt;c8&gt;&lt;s9&gt;width&lt;/s9&gt;&lt;/c8&gt; using their property wrapper.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;c4&gt;&lt;s5&gt;resize(to:)&lt;/s5&gt;&lt;/c4&gt;でのコードは、&lt;c6&gt;&lt;s7&gt;height&lt;/s7&gt;&lt;/c6&gt;と&lt;c8&gt;&lt;s9&gt;width&lt;/s9&gt;&lt;/c8&gt;にそれらのプロパティラッパーを使ってアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the declarations of &lt;c2&gt;&lt;s3&gt;SubProtocol&lt;/s3&gt;&lt;/c2&gt; below are equivalent:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、下の&lt;c2&gt;&lt;s3&gt;SubProtocol&lt;/s3&gt;&lt;/c2&gt;の宣言は同等です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the definition of &lt;c0&gt;&lt;s1&gt;PQR&lt;/s1&gt;&lt;/c0&gt; in the code below is equivalent to &lt;c2&gt;&lt;s3&gt;P&lt;/s3&gt; &lt;s4&gt;&amp;&lt;/s4&gt; &lt;s5&gt;Q&lt;/s5&gt; &lt;s6&gt;&amp;&lt;/s6&gt; &lt;s7&gt;R&lt;/s7&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のコードでの&lt;c0&gt;&lt;s1&gt;PQR&lt;/s1&gt;&lt;/c0&gt;の定義は、&lt;c2&gt;&lt;s3&gt;P&lt;/s3&gt; &lt;s4&gt;&amp;&lt;/s4&gt; &lt;s5&gt;Q&lt;/s5&gt; &lt;s6&gt;&amp;&lt;/s6&gt; &lt;s7&gt;R&lt;/s7&gt;&lt;/c2&gt;と同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the expression &lt;c0&gt;&lt;s1&gt;2&lt;/s1&gt; &lt;s2&gt;+&lt;/s2&gt; &lt;s3&gt;3&lt;/s3&gt; &lt;s4&gt;*&lt;/s4&gt; &lt;s5&gt;5&lt;/s5&gt;&lt;/c0&gt; is initially understood as a flat list of five items, &lt;c6&gt;&lt;s7&gt;2&lt;/s7&gt;&lt;/c6&gt;, &lt;c8&gt;&lt;s9&gt;+&lt;/s9&gt;&lt;/c8&gt;, &lt;c10&gt;&lt;s11&gt;3&lt;/s11&gt;&lt;/c10&gt;, &lt;c12&gt;&lt;s13&gt;*&lt;/s13&gt;&lt;/c12&gt;, and &lt;c14&gt;&lt;s15&gt;5&lt;/s15&gt;&lt;/c14&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、式&lt;c0&gt;&lt;s1&gt;2&lt;/s1&gt; &lt;s2&gt;+&lt;/s2&gt; &lt;s3&gt;3&lt;/s3&gt; &lt;s4&gt;*&lt;/s4&gt; &lt;s5&gt;5&lt;/s5&gt;&lt;/c0&gt;は、最初に５つの項目、&lt;c6&gt;&lt;s7&gt;2&lt;/s7&gt;&lt;/c6&gt;、&lt;c8&gt;&lt;s9&gt;+&lt;/s9&gt;&lt;/c8&gt;、&lt;c10&gt;&lt;s11&gt;3&lt;/s11&gt;&lt;/c10&gt;、&lt;c12&gt;&lt;s13&gt;*&lt;/s13&gt;&lt;/c12&gt;、そして&lt;c14&gt;&lt;s15&gt;5&lt;/s15&gt;&lt;/c14&gt;の平坦なリストとして理解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the expression &lt;c4&gt;&lt;s5&gt;(5&lt;/s5&gt; &lt;s6&gt;+&lt;/s6&gt; &lt;s7&gt;4)&lt;/s7&gt; &lt;s8&gt;*&lt;/s8&gt; &lt;s9&gt;2&lt;/s9&gt;&lt;/c4&gt; has a number on the right-hand side of the multiplication and another expression on the left-hand side of the multiplication.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、式&lt;c4&gt;&lt;s5&gt;(5&lt;/s5&gt; &lt;s6&gt;+&lt;/s6&gt; &lt;s7&gt;4)&lt;/s7&gt; &lt;s8&gt;*&lt;/s8&gt; &lt;s9&gt;2&lt;/s9&gt;&lt;/c4&gt;は、１つの数を掛け算の右手側に、そして別の式を掛け算の左手側に持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following are equivalent:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のものはどれも等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following code contains both a read access and a write access:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のコードは読み出しアクセスと書き込みアクセスの両方を含みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following code declares a &lt;c2&gt;&lt;s3&gt;ComparableContainer&lt;/s3&gt;&lt;/c2&gt; protocol that requires &lt;c4&gt;&lt;s5&gt;Item&lt;/s5&gt;&lt;/c4&gt; to conform to &lt;c6&gt;&lt;s7&gt;Comparable&lt;/s7&gt;&lt;/c6&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のコードは&lt;c2&gt;&lt;s3&gt;ComparableContainer&lt;/s3&gt;&lt;/c2&gt;プロトコルを宣言します、それは&lt;c4&gt;&lt;s5&gt;Item&lt;/s5&gt;&lt;/c4&gt;が&lt;c6&gt;&lt;s7&gt;Comparable&lt;/s7&gt;&lt;/c6&gt;に準拠することを要求します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following code defines a version of &lt;c0&gt;&lt;s1&gt;Container&lt;/s1&gt;&lt;/c0&gt; that requires the items in the container to be equatable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のコードは&lt;c0&gt;&lt;s1&gt;Container&lt;/s1&gt;&lt;/c0&gt;のあるバージョンを定義します、それはコンテナの中の項目に同等評価可能であることを要求するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following code isn’t valid because the element &lt;c4&gt;&lt;s5&gt;0&lt;/s5&gt;&lt;/c4&gt; in the tuple pattern &lt;c6&gt;&lt;s7&gt;(x,&lt;/s7&gt; &lt;s8&gt;0)&lt;/s8&gt;&lt;/c6&gt; is an expression pattern:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のコードは有効ではありません、タプルパターン&lt;c6&gt;&lt;s7&gt;(x,&lt;/s7&gt; &lt;s8&gt;0)&lt;/s8&gt;&lt;/c6&gt;の中の要素&lt;c4&gt;&lt;s5&gt;0&lt;/s5&gt;&lt;/c4&gt;が式パターンであるためです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following code iterates through the closed range &lt;c3&gt;&lt;s4&gt;1...3&lt;/s4&gt;&lt;/c3&gt;, ignoring the current value of the range on each iteration of the loop:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、完結範囲&lt;c3&gt;&lt;s4&gt;1...3&lt;/s4&gt;&lt;/c3&gt;のすべてに繰り返す以下のコードは、ループの各繰り返しにおいて範囲の現在の値を無視しています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following code matches against all three cases of the &lt;c0&gt;&lt;s1&gt;VendingMachineError&lt;/s1&gt;&lt;/c0&gt; enumeration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のコードは&lt;c0&gt;&lt;s1&gt;VendingMachineError&lt;/s1&gt;&lt;/c0&gt;列挙の３つのケース節すべてに対して適合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following code throws an error to indicate that five additional coins are needed by the vending machine:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のコードはあるエラーをスローして、５つの追加のコインが自動販売機に必要とされることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following code uses a &lt;c0&gt;&lt;s1&gt;loadImage(atPath:)&lt;/s1&gt;&lt;/c0&gt; function, which loads the image resource at a given path or throws an error if the image can’t be loaded.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のコードは&lt;c0&gt;&lt;s1&gt;loadImage(atPath:)&lt;/s1&gt;&lt;/c0&gt;関数を使います、それは画像リソースを与えられたパスでロードします、または画像がロードできないならばエラーをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following code uses several approaches to fetch data, or returns &lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt; if all of the approaches fail.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のコードはいくつかの取り組みを使ってデータを取ってきます、またはすべての取り組みが失敗するならば&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following is invalid because the &lt;c12&gt;&lt;s13&gt;catch&lt;/s13&gt;&lt;/c12&gt; clause would handle the error thrown by &lt;c14&gt;&lt;s15&gt;alwaysThrows()&lt;/s15&gt;&lt;/c14&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のものは無効です、なぜなら&lt;c12&gt;&lt;s13&gt;catch&lt;/s13&gt;&lt;/c12&gt;節が&lt;c14&gt;&lt;s15&gt;alwaysThrows()&lt;/s15&gt;&lt;/c14&gt;によってスローされるエラーを取り扱おうとするからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following listing shows chained method calls split over several lines:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のコード出力は、連結されたメソッド呼び出しがいくつかの行に分けられるのを示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following protocol can be adopted only by class types:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のプロトコルはクラス型によってのみ採用されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the function in the following code returns a type that depends on its caller:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のコードの関数は、それの呼び出し側に依存する、ある型を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the function in the following example returns a trapezoid without exposing the underlying type of that shape.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下の例での関数は、ある台形を、その形状の基礎をなす型を露出することなしに返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the function type &lt;c2&gt;&lt;s3&gt;(Int)&lt;/s3&gt; &lt;s4&gt;-&gt;&lt;/s4&gt; &lt;s5&gt;(Int)&lt;/s5&gt; &lt;s6&gt;-&gt;&lt;/s6&gt; &lt;s7&gt;Int&lt;/s7&gt;&lt;/c2&gt; is understood as &lt;c8&gt;&lt;s9&gt;(Int)&lt;/s9&gt; &lt;s10&gt;-&gt;&lt;/s10&gt; &lt;s11&gt;((Int)&lt;/s11&gt; &lt;s12&gt;-&gt;&lt;/s12&gt; &lt;s13&gt;Int)&lt;/s13&gt;&lt;/c8&gt;—that is, a function that takes an &lt;c14&gt;&lt;s15&gt;Int&lt;/s15&gt;&lt;/c14&gt; and returns another function that takes and returns an &lt;c16&gt;&lt;s17&gt;Int&lt;/s17&gt;&lt;/c16&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、関数型&lt;c2&gt;&lt;s3&gt;(Int)&lt;/s3&gt; &lt;s4&gt;-&gt;&lt;/s4&gt; &lt;s5&gt;(Int)&lt;/s5&gt; &lt;s6&gt;-&gt;&lt;/s6&gt; &lt;s7&gt;Int&lt;/s7&gt;&lt;/c2&gt;は、&lt;c8&gt;&lt;s9&gt;(Int)&lt;/s9&gt; &lt;s10&gt;-&gt;&lt;/s10&gt; &lt;s11&gt;((Int)&lt;/s11&gt; &lt;s12&gt;-&gt;&lt;/s12&gt; &lt;s13&gt;Int)&lt;/s13&gt;&lt;/c8&gt;として理解されます ― すなわち、ひとつの&lt;c14&gt;&lt;s15&gt;Int&lt;/s15&gt;&lt;/c14&gt;を取って、ひとつの&lt;c16&gt;&lt;s17&gt;Int&lt;/s17&gt;&lt;/c16&gt;を取りそして返す別の関数を返す関数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the initializer for the &lt;c0&gt;&lt;s1&gt;PurchasedSnack&lt;/s1&gt;&lt;/c0&gt; structure in the listing below calls a throwing function as part of the initialization process, and it handles any errors that it encounters by propagating them to its caller.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のコード出力の&lt;c0&gt;&lt;s1&gt;PurchasedSnack&lt;/s1&gt;&lt;/c0&gt;構造体のためのイニシャライザは、スロー関数を初期化処理の一部として呼び出します、そしてそれは、それが遭遇するどんなエラーもそれの呼び出し側にそれらを伝達することによって取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the metatype of the class type &lt;c4&gt;&lt;s5&gt;SomeClass&lt;/s5&gt;&lt;/c4&gt; is &lt;c6&gt;&lt;s7&gt;SomeClass.Type&lt;/s7&gt;&lt;/c6&gt; and the metatype of the protocol &lt;c8&gt;&lt;s9&gt;SomeProtocol&lt;/s9&gt;&lt;/c8&gt; is &lt;c10&gt;&lt;s11&gt;SomeProtocol.Protocol&lt;/s11&gt;&lt;/c10&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、クラス型&lt;c4&gt;&lt;s5&gt;SomeClass&lt;/s5&gt;&lt;/c4&gt;のメタタイプは&lt;c6&gt;&lt;s7&gt;SomeClass.Type&lt;/s7&gt;&lt;/c6&gt;です、そして、プロトコル&lt;c8&gt;&lt;s9&gt;SomeProtocol&lt;/s9&gt;&lt;/c8&gt;のメタタイプは&lt;c10&gt;&lt;s11&gt;SomeProtocol.Protocol&lt;/s11&gt;&lt;/c10&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the structure of a tuple &lt;c1&gt;&lt;s2&gt;(1,&lt;/s2&gt; &lt;s3&gt;2)&lt;/s3&gt;&lt;/c1&gt; is a comma-separated list of two elements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、タプル&lt;c1&gt;&lt;s2&gt;(1,&lt;/s2&gt; &lt;s3&gt;2)&lt;/s3&gt;&lt;/c1&gt;の構造は、コンマで区切られた２つの要素のリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the subtraction operator (&lt;c9&gt;&lt;s10&gt;-&lt;/s10&gt;&lt;/c9&gt;) is left-associative, so the expression &lt;c11&gt;&lt;s12&gt;4&lt;/s12&gt; &lt;s13&gt;-&lt;/s13&gt; &lt;s14&gt;5&lt;/s14&gt; &lt;s15&gt;-&lt;/s15&gt; &lt;s16&gt;6&lt;/s16&gt;&lt;/c11&gt; is grouped as &lt;c17&gt;&lt;s18&gt;(4&lt;/s18&gt; &lt;s19&gt;-&lt;/s19&gt; &lt;s20&gt;5)&lt;/s20&gt; &lt;s21&gt;-&lt;/s21&gt; &lt;s22&gt;6&lt;/s22&gt;&lt;/c17&gt; and evaluates to &lt;c23&gt;&lt;s24&gt;-7&lt;/s24&gt;&lt;/c23&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、減算演算子（&lt;c9&gt;&lt;s10&gt;-&lt;/s10&gt;&lt;/c9&gt;）は左結合です、それで式&lt;c11&gt;&lt;s12&gt;4&lt;/s12&gt; &lt;s13&gt;-&lt;/s13&gt; &lt;s14&gt;5&lt;/s14&gt; &lt;s15&gt;-&lt;/s15&gt; &lt;s16&gt;6&lt;/s16&gt;&lt;/c11&gt;は&lt;c17&gt;&lt;s18&gt;(4&lt;/s18&gt; &lt;s19&gt;-&lt;/s19&gt; &lt;s20&gt;5)&lt;/s20&gt; &lt;s21&gt;-&lt;/s21&gt; &lt;s22&gt;6&lt;/s22&gt;&lt;/c17&gt;のようにグループにされて、&lt;c23&gt;&lt;s24&gt;-7&lt;/s24&gt;&lt;/c23&gt;に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the tuple pattern &lt;c0&gt;&lt;s1&gt;(x,&lt;/s1&gt; &lt;s2&gt;y):&lt;/s2&gt; &lt;s3&gt;(Int,&lt;/s3&gt; &lt;s4&gt;Int)&lt;/s4&gt;&lt;/c0&gt; in the constant declaration &lt;c5&gt;&lt;s6&gt;let&lt;/s6&gt; &lt;s7&gt;(x,&lt;/s7&gt; &lt;s8&gt;y):&lt;/s8&gt; &lt;s9&gt;(Int,&lt;/s9&gt; &lt;s10&gt;Int)&lt;/s10&gt; &lt;s11&gt;=&lt;/s11&gt; &lt;s12&gt;(1,&lt;/s12&gt; &lt;s13&gt;2)&lt;/s13&gt;&lt;/c5&gt; matches only tuple types in which both elements are of type &lt;c14&gt;&lt;s15&gt;Int&lt;/s15&gt;&lt;/c14&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、定数宣言&lt;c5&gt;&lt;s6&gt;let&lt;/s6&gt; &lt;s7&gt;(x,&lt;/s7&gt; &lt;s8&gt;y):&lt;/s8&gt; &lt;s9&gt;(Int,&lt;/s9&gt; &lt;s10&gt;Int)&lt;/s10&gt; &lt;s11&gt;=&lt;/s11&gt; &lt;s12&gt;(1,&lt;/s12&gt; &lt;s13&gt;2)&lt;/s13&gt;&lt;/c5&gt;におけるタプルパターン&lt;c0&gt;&lt;s1&gt;(x,&lt;/s1&gt; &lt;s2&gt;y):&lt;/s2&gt; &lt;s3&gt;(Int,&lt;/s3&gt; &lt;s4&gt;Int)&lt;/s4&gt;&lt;/c0&gt;は、両方の要素が型&lt;c14&gt;&lt;s15&gt;Int&lt;/s15&gt;&lt;/c14&gt;であるタプル型だけにマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the tuple type &lt;c1&gt;&lt;s2&gt;(Int,&lt;/s2&gt; &lt;s3&gt;(Int,&lt;/s3&gt; &lt;s4&gt;Int))&lt;/s4&gt;&lt;/c1&gt; contains two elements: The first is the named type &lt;c5&gt;&lt;s6&gt;Int&lt;/s6&gt;&lt;/c5&gt;, and the second is another compound type &lt;c7&gt;&lt;s8&gt;(Int,&lt;/s8&gt; &lt;s9&gt;Int)&lt;/s9&gt;&lt;/c7&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば、タプル型&lt;c1&gt;&lt;s2&gt;(Int,&lt;/s2&gt; &lt;s3&gt;(Int,&lt;/s3&gt; &lt;s4&gt;Int))&lt;/s4&gt;&lt;/c1&gt;は、２つの要素を含みます：第一は名前付きの型&lt;c5&gt;&lt;s6&gt;Int&lt;/s6&gt;&lt;/c5&gt;です、そして第二は別の複合の型&lt;c7&gt;&lt;s8&gt;(Int,&lt;/s8&gt; &lt;s9&gt;Int)&lt;/s9&gt;&lt;/c7&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the type identifier in the following code references the named type &lt;c2&gt;&lt;s3&gt;MyType&lt;/s3&gt;&lt;/c2&gt; that is declared in the &lt;c4&gt;&lt;s5&gt;ExampleModule&lt;/s5&gt;&lt;/c4&gt; module.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下のコードの型識別子は、&lt;c4&gt;&lt;s5&gt;ExampleModule&lt;/s5&gt;&lt;/c4&gt;モジュールで宣言される名前付きの型&lt;c2&gt;&lt;s3&gt;MyType&lt;/s3&gt;&lt;/c2&gt;を参照します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the values of &lt;c2&gt;&lt;s3&gt;textA&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;textB&lt;/s5&gt;&lt;/c4&gt; in the example below are identical—no runtime concatenation is performed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば、以下の例の&lt;c2&gt;&lt;s3&gt;textA&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;textB&lt;/s5&gt;&lt;/c4&gt;の値は同一です ― 実行時連結は行われません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the variadic parameter &lt;c2&gt;&lt;s3&gt;Int...&lt;/s3&gt;&lt;/c2&gt; is treated as &lt;c4&gt;&lt;s5&gt;[Int]&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば、可変長パラメータ&lt;c2&gt;&lt;s3&gt;Int...&lt;/s3&gt;&lt;/c2&gt;は&lt;c4&gt;&lt;s5&gt;[Int]&lt;/s5&gt;&lt;/c4&gt;とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, there are two things named &lt;c0&gt;&lt;s1&gt;x&lt;/s1&gt;&lt;/c0&gt; in the code below, a variable in the outer scope and a constant in the inner scope, but they both refer to the same object because of reference semantics.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;c0&gt;&lt;s1&gt;x&lt;/s1&gt;&lt;/c0&gt;と名前をつけられる２つのものが以下のコードにはあります、外側のスコープの中の変数と内側のスコープの中の定数、しかしそれらは両方とも同じオブジェクトを参照します、なぜなら参照意味論だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, this protocol, called &lt;c0&gt;&lt;s1&gt;TextRepresentable&lt;/s1&gt;&lt;/c0&gt;, can be implemented by any type that has a way to be represented as text.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、このプロトコル、&lt;c0&gt;&lt;s1&gt;TextRepresentable&lt;/s1&gt;&lt;/c0&gt;と呼ばれるものは、テキストとして表わされる方法を持つどんな型によってでも実装されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, to create a new stack of strings, you write &lt;c2&gt;&lt;s3&gt;Stack&lt;String&gt;()&lt;/s3&gt;&lt;/c2&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、新しく文字列のスタックを作成するために、あなたは&lt;c2&gt;&lt;s3&gt;Stack&lt;String&gt;()&lt;/s3&gt;&lt;/c2&gt;を書きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, use a precondition to check that a subscript is not out of bounds, or to check that a function has been passed a valid value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、前提時要件を使って、ある添え字が範囲外でないことを調べてください、またはある関数が有効な値を渡されていることを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, when a computed property or a property with observers is passed as an in-out parameter, its getter is called as part of the function call and its setter is called as part of the function return.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、計算プロパティまたはオブザーバを持つプロパティがin-outパラメータとして渡される時、それのゲッターは関数呼び出しの一部として呼び出され、それのセッターは関数の戻りの一部として呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, when integers are used for raw values, the implicit value for each case is one more than the previous case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、整数が生の値のために使われるとき、各ケース節に対する暗黙の値は、その前のケース節よりも１つ多くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, writing &lt;c0&gt;&lt;s1&gt;shoppingList[shoppingList.count]&lt;/s1&gt; &lt;s2&gt;=&lt;/s2&gt; &lt;s3&gt;"Salt"&lt;/s3&gt;&lt;/c0&gt; to try to append an item to the end of the array results in a runtime error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、&lt;c0&gt;&lt;s1&gt;shoppingList[shoppingList.count]&lt;/s1&gt; &lt;s2&gt;=&lt;/s2&gt; &lt;s3&gt;"Salt"&lt;/s3&gt;&lt;/c0&gt;と書くことでこの配列の終わりに項目を加えようとするのは実行時エラーという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you access elements in an &lt;c1&gt;&lt;s2&gt;Array&lt;/s2&gt;&lt;/c1&gt; instance as &lt;c3&gt;&lt;s4&gt;someArray[index]&lt;/s4&gt;&lt;/c3&gt; and elements in a &lt;c5&gt;&lt;s6&gt;Dictionary&lt;/s6&gt;&lt;/c5&gt; instance as &lt;c7&gt;&lt;s8&gt;someDictionary[key]&lt;/s8&gt;&lt;/c7&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたはある&lt;c1&gt;&lt;s2&gt;Array&lt;/s2&gt;&lt;/c1&gt;インスタンスの中の要素に&lt;c3&gt;&lt;s4&gt;someArray[index]&lt;/s4&gt;&lt;/c3&gt;として、そしてある&lt;c5&gt;&lt;s6&gt;Dictionary&lt;/s6&gt;&lt;/c5&gt;インスタンスの中の要素に&lt;c7&gt;&lt;s8&gt;someDictionary[key]&lt;/s8&gt;&lt;/c7&gt;のようにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can assign values of implicitly unwrapped optionals to variables, constants, and properties of optionals, and vice versa.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば、あなたは暗黙的にアンラップされるオプショナルの値を、オプショナルの変数、定数、そしてプロパティに代入することができます、その逆もまたできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can constrain the associated types of type parameters to conform to protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば、あなたは型パラメータの関連型をいくらかのプロトコルに準拠するように制約することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can create a three-dimensional array of integers using three sets of square brackets:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたは３つ固めた角括弧を使って整数の三次元配列をつくることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can decompose the elements of a tuple and bind the value of each element to a corresponding identifier pattern.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたはタプルの要素を分解して、各要素の値を対応する識別子パターンへと縛り付けることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can define a constant or variable to be of a function type and assign an appropriate function to that variable:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたはある関数型となる定数または変数を定義して、適切な関数をその変数に代入することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can define a public type that can be used in other modules, but whose conformance to an internal protocol can only be used within the internal protocol’s defining module.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば、あなたは、別のモジュール内で使われることができる公開の型を定義することができます、しかし内部プロトコルに準拠するものは、ただその内部プロトコルの定義するモジュール内で使われることができるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can define an extension to the &lt;c0&gt;&lt;s1&gt;Collection&lt;/s1&gt;&lt;/c0&gt; protocol that applies to any collection whose elements conform to the &lt;c2&gt;&lt;s3&gt;Equatable&lt;/s3&gt;&lt;/c2&gt; protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、それの要素が&lt;c2&gt;&lt;s3&gt;Equatable&lt;/s3&gt;&lt;/c2&gt;プロトコルに準拠するあらゆるコレクションに適用される&lt;c0&gt;&lt;s1&gt;Collection&lt;/s1&gt;&lt;/c0&gt;プロトコルに対して、あなたはある拡張を定義できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can refine the behavior of that existing implementation, or store a modified value in an existing inherited variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたはその既存の実施の挙動を洗練させたり、既存の継承された変数に修正された値を格納することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can replace the type parameter &lt;c0&gt;&lt;s1&gt;Element&lt;/s1&gt;&lt;/c0&gt; in &lt;c2&gt;&lt;s3&gt;Array&lt;Element&gt;&lt;/s3&gt;&lt;/c2&gt; with a specialized version of an array, &lt;c4&gt;&lt;s5&gt;Array&lt;Int&gt;&lt;/s5&gt;&lt;/c4&gt;, to form an array whose elements are themselves arrays of integers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたは&lt;c2&gt;&lt;s3&gt;Array&lt;Element&gt;&lt;/s3&gt;&lt;/c2&gt;における型パラメータ&lt;c0&gt;&lt;s1&gt;Element&lt;/s1&gt;&lt;/c0&gt;を配列の特殊化版、&lt;c4&gt;&lt;s5&gt;Array&lt;Int&gt;&lt;/s5&gt;&lt;/c4&gt;で置き換えて、要素それ自身が整数の配列である配列を作り出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can rewrite the above example to compare the &lt;c2&gt;&lt;s3&gt;point&lt;/s3&gt;&lt;/c2&gt; expression with a string representations of points.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたは上記の例を書き直して、&lt;c2&gt;&lt;s3&gt;point&lt;/s3&gt;&lt;/c2&gt;式をpoint（座標）の文字列表現と比較するようにできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can use a &lt;c7&gt;&lt;s8&gt;defer&lt;/s8&gt;&lt;/c7&gt; statement to ensure that file descriptors are closed and manually allocated memory is freed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたは&lt;c7&gt;&lt;s8&gt;defer&lt;/s8&gt;&lt;/c7&gt;文を使ってファイル記述子が閉じられて手動割り当てメモリが解放されることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can use the protocol composition type &lt;c0&gt;&lt;s1&gt;ProtocolA&lt;/s1&gt; &lt;s2&gt;&amp;&lt;/s2&gt; &lt;s3&gt;ProtocolB&lt;/s3&gt; &lt;s4&gt;&amp;&lt;/s4&gt; &lt;s5&gt;ProtocolC&lt;/s5&gt;&lt;/c0&gt; instead of declaring a new protocol that inherits from &lt;c6&gt;&lt;s7&gt;ProtocolA&lt;/s7&gt;&lt;/c6&gt;, &lt;c8&gt;&lt;s9&gt;ProtocolB&lt;/s9&gt;&lt;/c8&gt;, and &lt;c10&gt;&lt;s11&gt;ProtocolC&lt;/s11&gt;&lt;/c10&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、プロトコル合成型&lt;c0&gt;&lt;s1&gt;ProtocolA&lt;/s1&gt; &lt;s2&gt;&amp;&lt;/s2&gt; &lt;s3&gt;ProtocolB&lt;/s3&gt; &lt;s4&gt;&amp;&lt;/s4&gt; &lt;s5&gt;ProtocolC&lt;/s5&gt;&lt;/c0&gt;を使うことが、&lt;c6&gt;&lt;s7&gt;ProtocolA&lt;/s7&gt;&lt;/c6&gt;、&lt;c8&gt;&lt;s9&gt;ProtocolB&lt;/s9&gt;&lt;/c8&gt;、そして&lt;c10&gt;&lt;s11&gt;ProtocolC&lt;/s11&gt;&lt;/c10&gt;から継承する新しいプロトコルを宣言する代わりに行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can’t use a private type as the raw-value type of an enumeration with an internal access level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたはある非公開型を、内部のアクセス水準をもつ列挙の「生の値」型として使うことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can’t write &lt;c0&gt;&lt;s1&gt;let&lt;/s1&gt; &lt;s2&gt;b&lt;/s2&gt; &lt;s3&gt;=&lt;/s3&gt; &lt;s4&gt;a&lt;/s4&gt; &lt;s5&gt;+=&lt;/s5&gt; &lt;s6&gt;2&lt;/s6&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたは&lt;c0&gt;&lt;s1&gt;let&lt;/s1&gt; &lt;s2&gt;b&lt;/s2&gt; &lt;s3&gt;=&lt;/s3&gt; &lt;s4&gt;a&lt;/s4&gt; &lt;s5&gt;+=&lt;/s5&gt; &lt;s6&gt;2&lt;/s6&gt;&lt;/c0&gt;を書くことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can’t write a public protocol that inherits from an internal protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたは内部のプロトコルから継承する公開のプロトコルを書くことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you use declarations to introduce functions and methods, to introduce variables and constants, and to define enumeration, structure, class, and protocol types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、あなたは宣言を使うことで、関数やメソッドを導入したり、変数や定数を導入したり、そして列挙、構造体、クラス、そしてプロトコル型を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For examples of conforming types that implement the method requirements of a protocol, see &lt;a0&gt;&lt;s1&gt;Method Requirements&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロトコルのメソッド要件を満たすものである準拠している型の例のために、&lt;a0&gt;&lt;s1&gt;メソッド要件&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For examples of conforming types that implement the property requirements of a protocol, see &lt;a6&gt;&lt;s7&gt;Property Requirements&lt;/s7&gt;&lt;/a6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロトコルのプロパティ要件を実装するものである、準拠している型の例のために、&lt;a6&gt;&lt;s7&gt;プロパティ要件&lt;/s7&gt;&lt;/a6&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For examples of how to use a &lt;c0&gt;&lt;s1&gt;break&lt;/s1&gt;&lt;/c0&gt; statement, see &lt;a2&gt;&lt;s3&gt;Break&lt;/s3&gt;&lt;/a2&gt; and &lt;a4&gt;&lt;s5&gt;Labeled Statements&lt;/s5&gt;&lt;/a4&gt; in &lt;a6&gt;&lt;s7&gt;Control Flow&lt;/s7&gt;&lt;/a6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;break&lt;/s1&gt;&lt;/c0&gt;文を使う方法の例のために、&lt;a2&gt;&lt;s3&gt;ブレーク&lt;/s3&gt;&lt;/a2&gt;と&lt;a4&gt;&lt;s5&gt;ラベルをつけられた文&lt;/s5&gt;&lt;/a4&gt;を章&lt;a6&gt;&lt;s7&gt;制御の流れ&lt;/s7&gt;&lt;/a6&gt;で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For examples of how to use a &lt;c0&gt;&lt;s1&gt;continue&lt;/s1&gt;&lt;/c0&gt; statement, see &lt;a2&gt;&lt;s3&gt;Continue&lt;/s3&gt;&lt;/a2&gt; and &lt;a4&gt;&lt;s5&gt;Labeled Statements&lt;/s5&gt;&lt;/a4&gt; in &lt;a6&gt;&lt;s7&gt;Control Flow&lt;/s7&gt;&lt;/a6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;continue&lt;/s1&gt;&lt;/c0&gt;文を使う方法の例のために、&lt;a2&gt;&lt;s3&gt;続ける&lt;/s3&gt;&lt;/a2&gt;と&lt;a4&gt;&lt;s5&gt;ラベルをつけられた文&lt;/s5&gt;&lt;/a4&gt;を章&lt;a6&gt;&lt;s7&gt;制御の流れ&lt;/s7&gt;&lt;/a6&gt;で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For examples of how to use these various types of values in &lt;c1&gt;&lt;s2&gt;switch&lt;/s2&gt;&lt;/c1&gt; statements, see &lt;a3&gt;&lt;s4&gt;Switch&lt;/s4&gt;&lt;/a3&gt; in &lt;a5&gt;&lt;s6&gt;Control Flow&lt;/s6&gt;&lt;/a5&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのいろいろな型の値を&lt;c1&gt;&lt;s2&gt;switch&lt;/s2&gt;&lt;/c1&gt;文で使う方法の例のために、&lt;a3&gt;&lt;s4&gt;スイッチ&lt;/s4&gt;&lt;/a3&gt;を&lt;a5&gt;&lt;s6&gt;制御の流れ&lt;/s6&gt;&lt;/a5&gt;で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For hexadecimal numbers with an exponent of &lt;c0&gt;&lt;s1&gt;exp&lt;/s1&gt;&lt;/c0&gt;, the base number is multiplied by 2&lt;s2&gt;exp&lt;/s2&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;exp&lt;/s1&gt;&lt;/c0&gt;の指数を持つある16進数に対して、その基数は２&lt;s2&gt;exp&lt;/s2&gt;を掛けられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information about &lt;c12&gt;&lt;s13&gt;private&lt;/s13&gt;&lt;/c12&gt;, see &lt;a14&gt;&lt;s15&gt;Access Control&lt;/s15&gt;&lt;/a14&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c12&gt;&lt;s13&gt;private&lt;/s13&gt;&lt;/c12&gt;に対する情報として、&lt;a14&gt;&lt;s15&gt;アクセス制御&lt;/s15&gt;&lt;/a14&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information about avoiding conflicting access to memory, see &lt;a2&gt;&lt;s3&gt;Memory Safety&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メモリへのアクセスの衝突の回避についての情報として、&lt;a2&gt;&lt;s3&gt;メモリ安全&lt;/s3&gt;&lt;/a2&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information about frozen and nonfrozen enumerations, see &lt;a2&gt;&lt;s3&gt;frozen&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>凍結および非凍結列挙についての情報として、&lt;a2&gt;&lt;s3&gt;frozen&lt;/s3&gt;&lt;/a2&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information about initialization and initializer syntax, see &lt;a8&gt;&lt;s9&gt;Initialization&lt;/s9&gt;&lt;/a8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期化とイニシャライザ構文についての情報として、&lt;a8&gt;&lt;s9&gt;初期化&lt;/s9&gt;&lt;/a8&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information about key-value coding and key-value observing, see &lt;a2&gt;Key-Value Coding Programming Guide&lt;/a2&gt;&lt;s3&gt; [https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i]&lt;/s3&gt; and &lt;a4&gt;Key-Value Observing Programming Guide&lt;/a4&gt;&lt;s5&gt; [https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i]&lt;/s5&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キー値コーディングとキー値監視についての情報として、&lt;a2&gt;キー値コーディングプログラミングガイド&lt;/a2&gt;&lt;s3&gt; [https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i]&lt;/s3&gt;と&lt;a4&gt;キー値監視プログラミングガイド&lt;/a4&gt;&lt;s5&gt; [https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i]&lt;/s5&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information about parameters with default values, see &lt;a12&gt;&lt;s13&gt;Default Parameter Values&lt;/s13&gt;&lt;/a12&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時の値を持つパラメータについての情報として、&lt;a12&gt;&lt;s13&gt;省略時のパラメータ値&lt;/s13&gt;&lt;/a12&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information about passing a closure as an argument to a function, see &lt;a0&gt;&lt;s1&gt;Function Call Expression&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャを引数として関数に渡すことに関する情報については、&lt;a0&gt;&lt;s1&gt;関数呼び出し式&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information about protocols, see &lt;a4&gt;&lt;s5&gt;Protocols&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルについての情報として、&lt;a4&gt;&lt;s5&gt;Protocols&lt;/s5&gt;&lt;/a4&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information about reference types, see &lt;a0&gt;&lt;s1&gt;Structures and Enumerations Are Value Types&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>参照型に関して詳しくは、&lt;a0&gt;&lt;s1&gt;構造体と列挙は値型です&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information about subscript declarations, see &lt;a0&gt;&lt;s1&gt;Protocol Subscript Declaration&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字宣言に関して詳しくは、&lt;a0&gt;&lt;s1&gt;プロトコル添え字宣言&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information about the behavior of these operators, see &lt;a0&gt;&lt;s1&gt;Basic Operators&lt;/s1&gt;&lt;/a0&gt; and &lt;a2&gt;&lt;s3&gt;Advanced Operators&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの演算子の挙動に関して詳しくは、&lt;a0&gt;&lt;s1&gt;基本の演算子&lt;/s1&gt;&lt;/a0&gt;と&lt;a2&gt;&lt;s3&gt;先進の演算子&lt;/s3&gt;&lt;/a2&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information about the operators provided by the Swift standard library, including a complete list of the operator precedence groups and associativity settings, see &lt;a0&gt;Operator Declarations&lt;/a0&gt;&lt;s1&gt; [https://developer.apple.com/documentation/swift/operator_declarations]&lt;/s1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト標準ライブラリによって提供される演算子についての情報として、演算子優先順位と結合性の設定の完全なリストを含めて、&lt;a0&gt;演算子宣言&lt;/a0&gt;&lt;s1&gt; [https://developer.apple.com/documentation/swift/operator_declarations]&lt;/s1&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information about the operators provided by the Swift standard library, including a complete list of the operator precedence groups and associativity settings, see &lt;a8&gt;Operator Declarations&lt;/a8&gt;&lt;s9&gt; [https://developer.apple.com/documentation/swift/operator_declarations]&lt;/s9&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト標準ライブラリによって提供される演算子についての情報として、演算子優先順位と結合性の設定の完全なリストを含めて、&lt;a8&gt;演算子宣言&lt;/a8&gt;&lt;s9&gt; [https://developer.apple.com/documentation/swift/operator_declarations]&lt;/s9&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information about the operators provided by the Swift standard library, see &lt;a0&gt;Operator Declarations&lt;/a0&gt;&lt;s1&gt; [https://developer.apple.com/documentation/swift/operator_declarations]&lt;/s1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト標準ライブラリによって提供される演算子についての情報のために、&lt;a0&gt;演算子宣言&lt;/a0&gt;&lt;s1&gt; [https://developer.apple.com/documentation/swift/operator_declarations]&lt;/s1&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information about value types, see &lt;a0&gt;&lt;s1&gt;Structures and Enumerations Are Value Types&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値型に関して詳しくは、&lt;a0&gt;&lt;s1&gt;構造体と列挙は値型です&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information about weak references, see &lt;a4&gt;&lt;s5&gt;Strong Reference Cycles Between Class Instances&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>弱い参照についての詳細は、&lt;a4&gt;&lt;s5&gt;クラスインスタンス間の強い参照循環&lt;/s5&gt;&lt;/a4&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information on optional chaining, see &lt;a2&gt;&lt;s3&gt;Optional Chaining&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖に関する情報のために、&lt;a2&gt;&lt;s3&gt;オプショナル連鎖&lt;/s3&gt;&lt;/a2&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For information on using playground literals in Xcode, see &lt;a0&gt;Add a color, file, or image literal&lt;/a0&gt;&lt;s1&gt; [https://help.apple.com/xcode/mac/current/#/dev4c60242fc]&lt;/s1&gt; in Xcode Help.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Xcodeにおけるプレイグラウンドリテラルの使用に関するさらなる情報として、&lt;a0&gt;Add a color, file, or image literal&lt;/a0&gt;&lt;s1&gt; [https://help.apple.com/xcode/mac/current/#/dev4c60242fc]&lt;/s1&gt;をXcodeヘルプで見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance methods on value types (that is, structures and enumerations) you place the &lt;c1&gt;&lt;s2&gt;mutating&lt;/s2&gt;&lt;/c1&gt; keyword before a method’s &lt;c3&gt;&lt;s4&gt;func&lt;/s4&gt;&lt;/c3&gt; keyword to indicate that the method is allowed to modify the instance it belongs to and any properties of that instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値型（すなわち、構造体と列挙）のインスタンスメソッドのために、あなたは&lt;c1&gt;&lt;s2&gt;mutating&lt;/s2&gt;&lt;/c1&gt;キーワードをメソッドの&lt;c3&gt;&lt;s4&gt;func&lt;/s4&gt;&lt;/c3&gt;キーワードの前に置いて、メソッドがそれが属しているインスタンスおよびそのインスタンスのあらゆるプロパティを修正するのを許可されることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, failable initializers are implemented for numeric type conversions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、いくつかの失敗できるイニシャライザが数値型変換のために実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, in the example below, the use of &lt;c0&gt;&lt;s1&gt;Point&lt;/s1&gt;&lt;/c0&gt; in the type annotation refers to the tuple type &lt;c2&gt;&lt;s3&gt;(Int,&lt;/s3&gt; &lt;s4&gt;Int)&lt;/s4&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば、下記の例で、型注釈において&lt;c0&gt;&lt;s1&gt;Point&lt;/s1&gt;&lt;/c0&gt;を使うことは、タプル型&lt;c2&gt;&lt;s3&gt;(Int,&lt;/s3&gt; &lt;s4&gt;Int)&lt;/s4&gt;&lt;/c2&gt;に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, the pattern &lt;c4&gt;&lt;s5&gt;(x,&lt;/s5&gt; &lt;s6&gt;y)&lt;/s6&gt;&lt;/c4&gt; matches the tuple &lt;c7&gt;&lt;s8&gt;(1,&lt;/s8&gt; &lt;s9&gt;2)&lt;/s9&gt;&lt;/c7&gt; and any other two-element tuple.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば、パターン&lt;c4&gt;&lt;s5&gt;(x,&lt;/s5&gt; &lt;s6&gt;y)&lt;/s6&gt;&lt;/c4&gt;はタプル&lt;c7&gt;&lt;s8&gt;(1,&lt;/s8&gt; &lt;s9&gt;2)&lt;/s9&gt;&lt;/c7&gt;および他のどんな２要素タプルにでもマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, the variadic parameter &lt;c5&gt;&lt;s6&gt;Int...&lt;/s6&gt;&lt;/c5&gt; is treated as &lt;c7&gt;&lt;s8&gt;[Int]&lt;/s8&gt;&lt;/c7&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば、可変長パラメータ&lt;c5&gt;&lt;s6&gt;Int...&lt;/s6&gt;&lt;/c5&gt;は&lt;c7&gt;&lt;s8&gt;[Int]&lt;/s8&gt;&lt;/c7&gt;とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more about &lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt; loops, see &lt;a4&gt;&lt;s5&gt;Control Flow&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt;ループに関する詳細は、&lt;a4&gt;&lt;s5&gt;制御の流れ&lt;/s5&gt;&lt;/a4&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more about arrays and dictionaries, see &lt;a4&gt;&lt;s5&gt;Collection Types&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列と辞書に関する詳細は、&lt;a4&gt;&lt;s5&gt;コレクション型&lt;/s5&gt;&lt;/a4&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more about arrays, see &lt;a4&gt;&lt;s5&gt;Arrays&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列に関する詳細は、&lt;a4&gt;&lt;s5&gt;配列&lt;/s5&gt;&lt;/a4&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more about extensions, see &lt;a0&gt;&lt;s1&gt;Extensions&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張についてのより多くのために、&lt;a0&gt;&lt;s1&gt;拡張&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more about generic &lt;c2&gt;&lt;s3&gt;where&lt;/s3&gt;&lt;/c2&gt; clauses, see &lt;a4&gt;&lt;s5&gt;Generic Where Clauses&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体&lt;c2&gt;&lt;s3&gt;where&lt;/s3&gt;&lt;/c2&gt;節に関する詳細は、&lt;a4&gt;&lt;s5&gt;総称体where節&lt;/s5&gt;&lt;/a4&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more about generic types and collections, see &lt;a1&gt;&lt;s2&gt;Generics&lt;/s2&gt;&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体型とコレクションに関する詳細は&lt;a1&gt;&lt;s2&gt;「総称体」&lt;/s2&gt;&lt;/a1&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more about operator methods, see &lt;a0&gt;&lt;s1&gt;Operator Methods&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子メソッドについてさらに、&lt;a0&gt;&lt;s1&gt;演算子メソッド&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more about ranges, see &lt;a6&gt;&lt;s7&gt;Range Operators&lt;/s7&gt;&lt;/a6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>範囲に関する詳細は、&lt;a6&gt;&lt;s7&gt;範囲演算子&lt;/s7&gt;&lt;/a6&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more about reference and value semantics, see &lt;a0&gt;&lt;s1&gt;Structures and Enumerations Are Value Types&lt;/s1&gt;&lt;/a0&gt; and &lt;a2&gt;&lt;s3&gt;Classes Are Reference Types&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>参照および値意味論に関する詳細は、&lt;a0&gt;&lt;s1&gt;構造体と列挙は値型です&lt;/s1&gt;&lt;/a0&gt;と&lt;a2&gt;&lt;s3&gt;クラスは、参照型です&lt;/s3&gt;&lt;/a2&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more about the &lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt; loop, see &lt;a4&gt;&lt;s5&gt;For-In Loops&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更に&lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt;ループについて、&lt;a4&gt;&lt;s5&gt;for-inループ&lt;/s5&gt;&lt;/a4&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more about the &lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt; statement, see &lt;a2&gt;&lt;s3&gt;Control Flow&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt;文に関する詳細は、&lt;a2&gt;&lt;s3&gt;制御の流れ&lt;/s3&gt;&lt;/a2&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more about the &lt;c4&gt;&lt;s5&gt;final&lt;/s5&gt;&lt;/c4&gt; modifier, see &lt;a6&gt;&lt;s7&gt;Preventing Overrides&lt;/s7&gt;&lt;/a6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;final&lt;/s5&gt;&lt;/c4&gt;修飾子に関する詳細は、&lt;a6&gt;&lt;s7&gt;オーバーライドを防ぐ&lt;/s7&gt;&lt;/a6&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more about these capabilities, see &lt;a0&gt;&lt;s1&gt;Properties&lt;/s1&gt;&lt;/a0&gt;, &lt;a2&gt;&lt;s3&gt;Methods&lt;/s3&gt;&lt;/a2&gt;, &lt;a4&gt;&lt;s5&gt;Initialization&lt;/s5&gt;&lt;/a4&gt;, &lt;a6&gt;&lt;s7&gt;Extensions&lt;/s7&gt;&lt;/a6&gt;, and &lt;a8&gt;&lt;s9&gt;Protocols&lt;/s9&gt;&lt;/a8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの能力に関する詳細は、&lt;a0&gt;&lt;s1&gt;プロパティ&lt;/s1&gt;&lt;/a0&gt;、&lt;a2&gt;&lt;s3&gt;メソッド&lt;/s3&gt;&lt;/a2&gt;、&lt;a4&gt;&lt;s5&gt;初期化&lt;/s5&gt;&lt;/a4&gt;、&lt;a6&gt;&lt;s7&gt;拡張&lt;/s7&gt;&lt;/a6&gt;、そして&lt;a8&gt;&lt;s9&gt;プロトコル&lt;/s9&gt;&lt;/a8&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more details, see &lt;a0&gt;&lt;s1&gt;Protocol Extensions&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>詳細は、&lt;a0&gt;&lt;s1&gt;プロトコル拡張&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more discussion and examples of in-out parameters, see &lt;a0&gt;&lt;s1&gt;In-Out Parameters&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>in-outパラメータの議論と例のために、&lt;a0&gt;&lt;s1&gt;in-outパラメータ&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about &lt;c0&gt;&lt;s1&gt;Dictionary&lt;/s1&gt;&lt;/c0&gt; subscripting, see &lt;a2&gt;&lt;s3&gt;Accessing and Modifying a Dictionary&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Dictionary&lt;/s1&gt;&lt;/c0&gt;で添え字を使うことの詳細については、&lt;a2&gt;&lt;s3&gt;辞書へのアクセスと修正&lt;/s3&gt;&lt;/a2&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about capture lists, see &lt;a0&gt;&lt;s1&gt;Capture Lists&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キャプチャリストについての更なる情報として、&lt;a0&gt;&lt;s1&gt;キャプチャリスト&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about compound cases, see &lt;a0&gt;&lt;s1&gt;Compound Cases&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複合ケース節についてのさらなる情報として、&lt;a0&gt;&lt;s1&gt;複合ケース節&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about conforming to protocols, see &lt;a0&gt;&lt;s1&gt;Protocols&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルに準拠することについての更なる情報は、&lt;a0&gt;&lt;s1&gt;プロトコル&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about constants and for guidance about when to use them, see &lt;a0&gt;&lt;s1&gt;Constants and Variables&lt;/s1&gt;&lt;/a0&gt; and &lt;a2&gt;&lt;s3&gt;Stored Properties&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数の詳細について、そしていつそれらを使うべきかの手引きとして、&lt;a0&gt;&lt;s1&gt;定数と変数&lt;/s1&gt;&lt;/a0&gt;および&lt;a2&gt;&lt;s3&gt;格納プロパティ&lt;/s3&gt;&lt;/a2&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about deinitializers, see &lt;a1&gt;&lt;s2&gt;Deinitialization&lt;/s2&gt;&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デイニシャライザの詳細については、&lt;a1&gt;&lt;s2&gt;デイニシャライザ&lt;/s2&gt;&lt;/a1&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about escaping closures, see &lt;a0&gt;&lt;s1&gt;Escaping Closures&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>脱出クロージャについてのさらなる情報として、&lt;a0&gt;&lt;s1&gt;脱出クロージャ&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about generic &lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt; clauses and to see an example of one in a generic function declaration, see &lt;a2&gt;&lt;s3&gt;Generic Where Clauses&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体&lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt;節のさらなる情報のために、そして総称体関数宣言におけるそれの一例を見るために、&lt;a2&gt;&lt;s3&gt;総称体where節&lt;/s3&gt;&lt;/a2&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about how to use the &lt;c4&gt;&lt;s5&gt;optional&lt;/s5&gt;&lt;/c4&gt; modifier and for guidance about how to access optional protocol members—for example, when you’re not sure whether a conforming type implements them—see &lt;a6&gt;&lt;s7&gt;Optional Protocol Requirements&lt;/s7&gt;&lt;/a6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;optional&lt;/s5&gt;&lt;/c4&gt;修飾子を使う方法についての更なる情報のために、そしてオプショナルプロトコルメンバーにアクセスする方法についての手引きとして ― 例えば、あなたがある準拠型がそれらを実装するかどうか確信が持てない時など ― &lt;a6&gt;&lt;s7&gt;オプショナルのプロトコル要件&lt;/s7&gt;&lt;/a6&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about how to use the &lt;c8&gt;&lt;s9&gt;optional&lt;/s9&gt;&lt;/c8&gt; declaration modifier and for guidance about how to access optional protocol members—for example, when you’re not sure whether a conforming type implements them—see &lt;a10&gt;&lt;s11&gt;Optional Protocol Requirements&lt;/s11&gt;&lt;/a10&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c8&gt;&lt;s9&gt;optional&lt;/s9&gt;&lt;/c8&gt;宣言修飾子を働かせる方法に関する詳細は、そして、オプショナルのプロトコルメンバーにアクセスする方法 ― 例えば、ある準拠している型がそれらを実装するかどうかについてあなたが確信が持てない時など ― についての手引きとして&lt;a10&gt;&lt;s11&gt;オプショナルのプロトコル要件&lt;/s11&gt;&lt;/a10&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about implicitly unwrapped optional types, see &lt;a0&gt;&lt;s1&gt;Implicitly Unwrapped Optionals&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗黙的にアンラップされるオプショナル型の詳細については、&lt;a0&gt;&lt;s1&gt;暗黙的にアンラップされるオプショナル&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about initializer delegation, see &lt;a0&gt;&lt;s1&gt;Initializer Delegation for Value Types&lt;/s1&gt;&lt;/a0&gt; and &lt;a2&gt;&lt;s3&gt;Initializer Delegation for Class Types&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザ委任についての更なる情報として、&lt;a0&gt;&lt;s1&gt;値型のためのイニシャライザ委任&lt;/s1&gt;&lt;/a0&gt;と&lt;a2&gt;&lt;s3&gt;クラス型のためのイニシャライザ委任&lt;/s3&gt;&lt;/a2&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about memory safety and memory exclusivity, see &lt;a0&gt;&lt;s1&gt;Memory Safety&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メモリ安全とメモリ排他についての更なる情報として、&lt;a0&gt;&lt;s1&gt;メモリ安全&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about pattern matching, see &lt;a6&gt;&lt;s7&gt;Patterns&lt;/s7&gt;&lt;/a6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パターンマッチングについての更なる情報として、&lt;a6&gt;&lt;s7&gt;パターン&lt;/s7&gt;&lt;/a6&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about precedence groups and to see the syntax for defining your own operators and precedence groups, see &lt;a10&gt;&lt;s11&gt;Operator Declaration&lt;/s11&gt;&lt;/a10&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>優先順位グループについてのさらなる情報として、そしてあなた独自の演算子と優先順位グループを定義するための構文を見るには、&lt;a10&gt;&lt;s11&gt;演算子宣言&lt;/s11&gt;&lt;/a10&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about subscripting and to see examples of subscript declarations, see &lt;a0&gt;&lt;s1&gt;Subscripts&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字に関するより多くの情報のために、そして、添え字宣言の例を見るために、&lt;a0&gt;&lt;s1&gt;添え字&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about the &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt; type, see &lt;a4&gt;&lt;s5&gt;Strings and Characters&lt;/s5&gt;&lt;/a4&gt; and &lt;a6&gt;&lt;c7&gt;&lt;s8&gt;String&lt;/s8&gt;&lt;/c7&gt;&lt;/a6&gt;&lt;s9&gt; [https://developer.apple.com/documentation/swift/string]&lt;/s9&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;型についての詳細として、&lt;a4&gt;&lt;s5&gt;文字列と文字&lt;/s5&gt;&lt;/a4&gt;と&lt;a6&gt;&lt;c7&gt;&lt;s8&gt;String&lt;/s8&gt;&lt;/c7&gt;&lt;/a6&gt;&lt;s9&gt; [https://developer.apple.com/documentation/swift/string]&lt;/s9&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about the &lt;c6&gt;&lt;s7&gt;fallthrough&lt;/s7&gt;&lt;/c6&gt; statement, see &lt;a8&gt;&lt;s9&gt;Fallthrough Statement&lt;/s9&gt;&lt;/a8&gt; below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;fallthrough&lt;/s7&gt;&lt;/c6&gt;文の詳細については、下記の&lt;a8&gt;&lt;s9&gt;フォールスルー文&lt;/s9&gt;&lt;/a8&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about the patterns you can use in a &lt;c10&gt;&lt;s11&gt;catch&lt;/s11&gt;&lt;/c10&gt; clause, see &lt;a12&gt;&lt;s13&gt;Patterns&lt;/s13&gt;&lt;/a12&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが&lt;c10&gt;&lt;s11&gt;catch&lt;/s11&gt;&lt;/c10&gt;節において使うパターンについての更なる情報として、&lt;a12&gt;&lt;s13&gt;パターン&lt;/s13&gt;&lt;/a12&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about this attribute, see &lt;a16&gt;&lt;s17&gt;Attributes&lt;/s17&gt;&lt;/a16&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性についてのさらなる情報として、&lt;a16&gt;&lt;s17&gt;属性&lt;/s17&gt;&lt;/a16&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about this class, see &lt;a2&gt;Handling Cocoa Errors in Swift&lt;/a2&gt;&lt;s3&gt; [https://developer.apple.com/documentation/swift/cocoa_design_patterns/handling_cocoa_errors_in_swift]&lt;/s3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このクラスについてのさらなる情報として、&lt;a2&gt;CocoaエラーをSwiftにおいて処理する&lt;/a2&gt;&lt;s3&gt; [https://developer.apple.com/documentation/swift/cocoa_design_patterns/handling_cocoa_errors_in_swift]&lt;/s3&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about type casting and to see examples that use the type-casting operators, see &lt;a0&gt;&lt;s1&gt;Type Casting&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型キャストに関するより多くの情報のために、そして、型キャスト演算子を使用する例をより多く見るために、&lt;a0&gt;&lt;s1&gt;型キャスト&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about using &lt;c0&gt;&lt;s1&gt;Array&lt;/s1&gt;&lt;/c0&gt; with Foundation and Cocoa, see &lt;a2&gt;Bridging Between Array and NSArray&lt;/a2&gt;&lt;s3&gt; [https://developer.apple.com/documentation/swift/array#2846730]&lt;/s3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>FoundationとCocoaとともに&lt;c0&gt;&lt;s1&gt;Array&lt;/s1&gt;&lt;/c0&gt;を使うことについてのさらなる情報として、&lt;a2&gt;ArrayとNSArrayの間のブリッジ&lt;/a2&gt;&lt;s3&gt; [https://developer.apple.com/documentation/swift/array#2846730]&lt;/s3&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about using &lt;c0&gt;&lt;s1&gt;Dictionary&lt;/s1&gt;&lt;/c0&gt; with Foundation and Cocoa, see &lt;a2&gt;Bridging Between Dictionary and NSDictionary&lt;/a2&gt;&lt;s3&gt; [https://developer.apple.com/documentation/swift/dictionary#2846239]&lt;/s3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>FoundationとCocoaとともに&lt;c0&gt;&lt;s1&gt;Dictionary&lt;/s1&gt;&lt;/c0&gt;を使うことについてのさらなる情報として、&lt;a2&gt;DictionaryとNSDictionaryの間のブリッジ&lt;/a2&gt;&lt;s3&gt; [https://developer.apple.com/documentation/swift/dictionary#2846239]&lt;/s3&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about using &lt;c0&gt;&lt;s1&gt;Set&lt;/s1&gt;&lt;/c0&gt; with Foundation and Cocoa, see &lt;a2&gt;Bridging Between Set and NSSet&lt;/a2&gt;&lt;s3&gt; [https://developer.apple.com/documentation/swift/set#2845530]&lt;/s3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>FoundationとCocoaとともに&lt;c0&gt;&lt;s1&gt;Set&lt;/s1&gt;&lt;/c0&gt;を使うことについてのさらなる情報として、&lt;a2&gt;SetとNSSetの間のブリッジ&lt;/a2&gt;&lt;s3&gt; [https://developer.apple.com/documentation/swift/set#2845530]&lt;/s3&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about using &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; with Foundation and Cocoa, see &lt;a2&gt;Bridging Between String and NSString&lt;/a2&gt;&lt;s3&gt; [https://developer.apple.com/documentation/swift/string#2919514]&lt;/s3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>FoundationとCocoaとともに&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;を使うことについてのさらなる情報として、&lt;a2&gt;StringとNSStringの間のブリッジ&lt;/a2&gt;&lt;s3&gt; [https://developer.apple.com/documentation/swift/string#2919514]&lt;/s3&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about using key paths in Swift code that interacts with Objective-C APIs, see &lt;a0&gt;Using Objective-C Runtime Features in Swift&lt;/a0&gt;&lt;s1&gt; [https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift]&lt;/s1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-C APIと相互作用するSwiftコードにおけるキーパスの使用についてのさらなる情報として、&lt;a0&gt;Objective-Cランタイム機能をSwiftで使用する&lt;/a0&gt;&lt;s1&gt; [https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift]&lt;/s1&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about using key paths in code that interacts with Objective-C APIs, see &lt;a0&gt;Using Objective-C Runtime Features in Swift&lt;/a0&gt;&lt;s1&gt; [https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift]&lt;/s1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-C APIと相互作用するコードにおけるキーパスの使用についてのさらなる情報として、&lt;a0&gt;Objective-Cランタイム機能をSwiftで使用する&lt;/a0&gt;&lt;s1&gt; [https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift]&lt;/s1&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about using multiple optional chaining operations, see &lt;a11&gt;&lt;s12&gt;Linking Multiple Levels of Chaining&lt;/s12&gt;&lt;/a11&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数のオプショナル連鎖演算を使用することについての更なる情報として、&lt;a11&gt;&lt;s12&gt;連鎖の複数の階層を結ぶ&lt;/s12&gt;&lt;/a11&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information about using selectors in Swift code that interacts with Objective-C APIs, see &lt;a0&gt;Using Objective-C Runtime Features in Swift&lt;/a0&gt;&lt;s1&gt; [https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift]&lt;/s1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-C APIと相互作用するSwiftコードにおけるセレクタの使用についてのさらなる情報として、&lt;a0&gt;Objective-Cランタイム機能をSwiftで使用する&lt;/a0&gt;&lt;s1&gt; [https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift]&lt;/s1&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information and examples of capture lists, see &lt;a2&gt;&lt;s3&gt;Resolving Strong Reference Cycles for Closures&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キャプチャリストのより多くの情報と例のために、&lt;a2&gt;&lt;s3&gt;クロージャのための強い参照循環の解消&lt;/s3&gt;&lt;/a2&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information and examples of closure expressions, see &lt;a0&gt;&lt;s1&gt;Closure Expressions&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャ式のより多くの情報と例のために、&lt;a0&gt;&lt;s1&gt;クロージャ式&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information and examples, see &lt;a6&gt;&lt;s7&gt;Associated Types&lt;/s7&gt;&lt;/a6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より多くの情報と例のために、&lt;a6&gt;&lt;s7&gt;関連型&lt;/s7&gt;&lt;/a6&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information and to see an example of how to use property observers, see &lt;a0&gt;&lt;s1&gt;Property Observers&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より多くの情報のために、そして、プロパティオブザーバーを使う方法の例を見るために、&lt;a0&gt;&lt;s1&gt;プロパティオブザーバー&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information and to see an example, see &lt;a2&gt;&lt;s3&gt;In-Out Parameters&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より多くの情報のために、そして、例を見るために、&lt;a2&gt;&lt;s3&gt;In-Outパラメータ&lt;/s3&gt;&lt;/a2&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information and to see examples of cases with associated value types, see &lt;a0&gt;&lt;s1&gt;Associated Values&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より多くの情報のために、そして関連値型をもつケース節の例を見るために、&lt;a0&gt;&lt;s1&gt;関連値&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information and to see examples of cases with raw-value types, see &lt;a14&gt;&lt;s15&gt;Raw Values&lt;/s15&gt;&lt;/a14&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より多くの情報のために、そして「生の値」型をもつケース節の例を見るために、&lt;a14&gt;&lt;s15&gt;生の値&lt;/s15&gt;&lt;/a14&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information and to see examples of computed properties, see &lt;a0&gt;&lt;s1&gt;Computed Properties&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より多くの情報のために、そして、&lt;a0&gt;&lt;s1&gt;計算プロパティ&lt;/s1&gt;&lt;/a0&gt;の例を見るために、計算プロパティを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information and to see examples of failable initializers, see &lt;a0&gt;&lt;s1&gt;Failable Initializers&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらなる情報と、失敗できるイニシャライザの例を見るために、&lt;a0&gt;&lt;s1&gt;失敗できるイニシャライザ&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information and to see examples of how to use &lt;c0&gt;&lt;s1&gt;try&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;try?&lt;/s3&gt;&lt;/c2&gt;, and &lt;c4&gt;&lt;s5&gt;try!&lt;/s5&gt;&lt;/c4&gt;, see &lt;a6&gt;&lt;s7&gt;Error Handling&lt;/s7&gt;&lt;/a6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より多くの情報のために、そして&lt;c0&gt;&lt;s1&gt;try&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;try?&lt;/s3&gt;&lt;/c2&gt;、そして&lt;c4&gt;&lt;s5&gt;try!&lt;/s5&gt;&lt;/c4&gt;文を使う方法の例を見るために、&lt;a6&gt;&lt;s7&gt;エラーを処理する&lt;/s7&gt;&lt;/a6&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information and to see examples of how to use statement labels, see &lt;a0&gt;&lt;s1&gt;Labeled Statements&lt;/s1&gt;&lt;/a0&gt; in &lt;a2&gt;&lt;s3&gt;Control Flow&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より多くの情報のために、そして、文ラベルを使用する方法の例を見るために、&lt;a0&gt;&lt;s1&gt;ラベルをつけられた文&lt;/s1&gt;&lt;/a0&gt;を&lt;a2&gt;&lt;s3&gt;制御の流れ&lt;/s3&gt;&lt;/a2&gt;で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information and to see examples that show how to use optional types, see &lt;a0&gt;&lt;s1&gt;Optionals&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より多くの情報のために、そしてオプショナル型を使う方法を示す例を見るために、&lt;a0&gt;&lt;s1&gt;オプショナル&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information on bridging, see &lt;a4&gt;Working with Foundation Types&lt;/a4&gt;&lt;s5&gt; [https://developer.apple.com/documentation/swift/imported_c_and_objective_c_apis/working_with_foundation_types]&lt;/s5&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ブリッジに関するより多くの情報のために、&lt;a4&gt;Foundation型を扱う&lt;/a4&gt;&lt;s5&gt; [https://developer.apple.com/documentation/swift/imported_c_and_objective_c_apis/working_with_foundation_types]&lt;/s5&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information on functions with the &lt;c2&gt;&lt;s3&gt;Never&lt;/s3&gt;&lt;/c2&gt; return type, see &lt;a4&gt;&lt;s5&gt;Functions that Never Return&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;Never&lt;/s3&gt;&lt;/c2&gt;戻り型を持つ関数でのさらなる情報は、&lt;a4&gt;&lt;s5&gt;決して戻らない関数&lt;/s5&gt;&lt;/a4&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information on property observers, see &lt;a0&gt;&lt;s1&gt;Property Observers&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティオブザーバーの詳細については、&lt;a0&gt;&lt;s1&gt;プロパティオブザーバー&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information on required initializers, see &lt;a0&gt;&lt;s1&gt;Required Initializers&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>必須イニシャライザに関する更なる情報として、&lt;a0&gt;&lt;s1&gt;必須イニシャライザ&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information see &lt;a2&gt;&lt;s3&gt;Type Variable Properties&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更なる情報として、&lt;a2&gt;&lt;s3&gt;型変数プロパティ&lt;/s3&gt;&lt;/a2&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see &lt;a0&gt;&lt;c1&gt;&lt;s2&gt;type(of:)&lt;/s2&gt;&lt;/c1&gt;&lt;/a0&gt;&lt;s3&gt; [https://developer.apple.com/documentation/swift/2885064-type]&lt;/s3&gt; in the Swift standard library.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>詳細は、&lt;a0&gt;&lt;c1&gt;&lt;s2&gt;type(of:)&lt;/s2&gt;&lt;/c1&gt;&lt;/a0&gt;&lt;s3&gt; [https://developer.apple.com/documentation/swift/2885064-type]&lt;/s3&gt;をスウィフト標準ライブラリで見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see &lt;a0&gt;&lt;s1&gt;Assigning Constant Properties During Initialization&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更なる情報として、&lt;a0&gt;&lt;s1&gt;初期化の間に定数プロパティを割り当てる&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see &lt;a0&gt;&lt;s1&gt;Constant Declaration&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更なる情報として、&lt;a0&gt;&lt;s1&gt;定数宣言&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see &lt;a0&gt;&lt;s1&gt;Extensions&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>詳細は、&lt;a0&gt;&lt;s1&gt;拡張&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see &lt;a0&gt;&lt;s1&gt;Failable Initializers&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらなる情報として、&lt;a0&gt;&lt;s1&gt;失敗できるイニシャライザ&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see &lt;a0&gt;&lt;s1&gt;Inheritance&lt;/s1&gt;&lt;/a0&gt;, &lt;a2&gt;&lt;s3&gt;Type Casting&lt;/s3&gt;&lt;/a2&gt;, &lt;a4&gt;&lt;s5&gt;Deinitialization&lt;/s5&gt;&lt;/a4&gt;, and &lt;a6&gt;&lt;s7&gt;Automatic Reference Counting&lt;/s7&gt;&lt;/a6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>詳細は、&lt;a0&gt;&lt;s1&gt;継承&lt;/s1&gt;&lt;/a0&gt;、&lt;a2&gt;&lt;s3&gt;型キャスト&lt;/s3&gt;&lt;/a2&gt;、&lt;a4&gt;&lt;s5&gt;デイニシャライズ&lt;/s5&gt;&lt;/a4&gt;、そして&lt;a6&gt;&lt;s7&gt;自動参照カウント&lt;/s7&gt;&lt;/a6&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see &lt;a0&gt;&lt;s1&gt;Properties&lt;/s1&gt;&lt;/a0&gt;, &lt;a2&gt;&lt;s3&gt;Methods&lt;/s3&gt;&lt;/a2&gt;, &lt;a4&gt;&lt;s5&gt;Subscripts&lt;/s5&gt;&lt;/a4&gt;, &lt;a6&gt;&lt;s7&gt;Initialization&lt;/s7&gt;&lt;/a6&gt;, &lt;a8&gt;&lt;s9&gt;Extensions&lt;/s9&gt;&lt;/a8&gt;, and &lt;a10&gt;&lt;s11&gt;Protocols&lt;/s11&gt;&lt;/a10&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>詳細は、&lt;a0&gt;&lt;s1&gt;プロパティ&lt;/s1&gt;&lt;/a0&gt;, &lt;a2&gt;&lt;s3&gt;メソッド&lt;/s3&gt;&lt;/a2&gt;、&lt;a4&gt;&lt;s5&gt;添え字&lt;/s5&gt;&lt;/a4&gt;、&lt;a6&gt;&lt;s7&gt;初期化&lt;/s7&gt;&lt;/a6&gt;、&lt;a8&gt;&lt;s9&gt;拡張&lt;/s9&gt;&lt;/a8&gt;、そして&lt;a10&gt;&lt;s11&gt;プロトコル&lt;/s11&gt;&lt;/a10&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see &lt;a0&gt;&lt;s1&gt;Structures and Classes&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>詳細は、&lt;a0&gt;&lt;s1&gt;クラスと構造体&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see &lt;a0&gt;Importing Swift into Objective-C&lt;/a0&gt;&lt;s1&gt; [https://developer.apple.com/documentation/swift/imported_c_and_objective-c_apis/importing_swift_into_objective-c]&lt;/s1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらなる情報は、&lt;a0&gt;SwiftをObjective-Cにインポートする&lt;/a0&gt;&lt;s1&gt; [https://developer.apple.com/documentation/swift/imported_c_and_objective-c_apis/importing_swift_into_objective-c]&lt;/s1&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see &lt;a1&gt;&lt;s2&gt;Automatic Initializer Inheritance&lt;/s2&gt;&lt;/a1&gt; below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更なる情報は、以下の&lt;a1&gt;&lt;s2&gt;自動的なイニシャライザ継承&lt;/s2&gt;&lt;/a1&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see &lt;a1&gt;&lt;s2&gt;Strong Reference Cycles for Closures&lt;/s2&gt;&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>詳細は、&lt;a1&gt;&lt;s2&gt;クロージャのための強い参照循環&lt;/s2&gt;&lt;/a1&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see &lt;a2&gt;&lt;s3&gt;Optional Binding&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更なる情報として、&lt;a2&gt;&lt;s3&gt;オプショナルの束縛&lt;/s3&gt;&lt;/a2&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see &lt;a2&gt;&lt;s3&gt;Sets&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更なる情報として、&lt;a2&gt;&lt;s3&gt;集合&lt;/s3&gt;&lt;/a2&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see &lt;a3&gt;&lt;s4&gt;Functions with Multiple Return Values&lt;/s4&gt;&lt;/a3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>詳細は、&lt;a3&gt;&lt;s4&gt;「複数の戻り値をもつ関数」&lt;/s4&gt;&lt;/a3&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see &lt;a4&gt;&lt;s5&gt;Checking for Protocol Conformance&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更なる情報として、&lt;a4&gt;&lt;s5&gt;プロトコル準拠の確認&lt;/s5&gt;&lt;/a4&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see &lt;a4&gt;&lt;s5&gt;Declaration Attributes&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更なる情報として、&lt;a4&gt;&lt;s5&gt;宣言属性&lt;/s5&gt;&lt;/a4&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see &lt;a4&gt;&lt;s5&gt;Precedence Group Declaration&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらなる情報は、&lt;a4&gt;&lt;s5&gt;優先順位グループ定義&lt;/s5&gt;&lt;/a4&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see &lt;a5&gt;&lt;s6&gt;Identity Operators&lt;/s6&gt;&lt;/a5&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更なる情報として、&lt;a5&gt;&lt;s6&gt;同一性演算子&lt;/s6&gt;&lt;/a5&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see &lt;a6&gt;&lt;s7&gt;Type-Casting Operators&lt;/s7&gt;&lt;/a6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更なる情報として、&lt;a6&gt;&lt;s7&gt;型キャスト演算子&lt;/s7&gt;&lt;/a6&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see &lt;a8&gt;&lt;s9&gt;Raw Values&lt;/s9&gt;&lt;/a8&gt; and &lt;a10&gt;&lt;s11&gt;Enumerations with Cases of a Raw-Value Type&lt;/s11&gt;&lt;/a10&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更なる情報として、&lt;a8&gt;&lt;s9&gt;生の値&lt;/s9&gt;&lt;/a8&gt;と「&lt;a10&gt;&lt;s11&gt;生の値」型のケース節を持つ列挙&lt;/s11&gt;&lt;/a10&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For more information, see the &lt;a2&gt;&lt;s3&gt;propertyWrapper&lt;/s3&gt;&lt;/a2&gt; section of the &lt;a4&gt;&lt;s5&gt;Attributes&lt;/s5&gt;&lt;/a4&gt; chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらなる情報として、&lt;a4&gt;&lt;s5&gt;属性&lt;/s5&gt;&lt;/a4&gt;の章の&lt;a2&gt;&lt;s3&gt;propertyWrapper&lt;/s3&gt;&lt;/a2&gt;の節を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For multithreaded code, use &lt;a0&gt;Thread Sanitizer&lt;/a0&gt;&lt;s1&gt; [https://developer.apple.com/documentation/code_diagnostics/thread_sanitizer]&lt;/s1&gt; to help detect conflicting access across threads.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>マルチスレッドコードに対しては、&lt;a0&gt;Thread Sanitizer&lt;/a0&gt;&lt;s1&gt; [https://developer.apple.com/documentation/code_diagnostics/thread_sanitizer]&lt;/s1&gt;を使うことでスレッドをまたぐアクセス衝突を検出する助けとしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For readability, a compound case can also be written over multiple lines.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>可読性のために、複合ケース節はまた複数行にわたって書かれることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For simple numeric values, the unary minus operator converts positive numbers into their negative equivalent and vice versa.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単純な数の値のために、この単項マイナス演算子は正の数をその負の等価物に変えます、逆の場合も同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For some enumerations, it’s useful to have a collection of all of that enumeration’s cases.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いくつかの列挙に対して、その列挙の持つケース節の全てからなるコレクションを持つことは役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the &lt;c3&gt;&lt;s4&gt;numberOfLegs&lt;/s4&gt;&lt;/c3&gt; dictionary above, the key-value subscript takes and returns a value of type &lt;c5&gt;&lt;s6&gt;Int?&lt;/s6&gt;&lt;/c5&gt;, or “optional int”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の&lt;c3&gt;&lt;s4&gt;numberOfLegs&lt;/s4&gt;&lt;/c3&gt;辞書のために、その「キーと値」添え字は型&lt;c5&gt;&lt;s6&gt;Int?&lt;/s6&gt;&lt;/c5&gt;、つまり「オプショナルのint」の値を受け取りそして返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the example above, this enables the names of &lt;c0&gt;&lt;s1&gt;Suit&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;Rank&lt;/s3&gt;&lt;/c2&gt;, and &lt;c4&gt;&lt;s5&gt;Values&lt;/s5&gt;&lt;/c4&gt; to be kept deliberately short, because their names are naturally qualified by the context in which they are defined.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、これは、&lt;c0&gt;&lt;s1&gt;Suit&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;Rank&lt;/s3&gt;&lt;/c2&gt;、そして&lt;c4&gt;&lt;s5&gt;Values&lt;/s5&gt;&lt;/c4&gt;の名前が故意に短いままにしておかれるようにします、なぜなら、それらが定義される文脈によってそれらの名前が自然に修飾されて限定されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the numeric cards, it uses the rank’s raw &lt;c16&gt;&lt;s17&gt;Int&lt;/s17&gt;&lt;/c16&gt; value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>数字カードのために、それは等級の生の&lt;c16&gt;&lt;s17&gt;Int&lt;/s17&gt;&lt;/c16&gt;値を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the other three properties, new &lt;c8&gt;&lt;s9&gt;VideoMode&lt;/s9&gt;&lt;/c8&gt; instances will be initialized with an &lt;c10&gt;&lt;s11&gt;interlaced&lt;/s11&gt;&lt;/c10&gt; setting of &lt;c12&gt;&lt;s13&gt;false&lt;/s13&gt;&lt;/c12&gt; (meaning “noninterlaced video”), a playback frame rate of &lt;c14&gt;&lt;s15&gt;0.0&lt;/s15&gt;&lt;/c14&gt;, and an optional &lt;c16&gt;&lt;s17&gt;String&lt;/s17&gt;&lt;/c16&gt; value called &lt;c18&gt;&lt;s19&gt;name&lt;/s19&gt;&lt;/c18&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の３つのプロパティのために、新しい&lt;c8&gt;&lt;s9&gt;VideoMode&lt;/s9&gt;&lt;/c8&gt;インスタンスは、&lt;c12&gt;&lt;s13&gt;false&lt;/s13&gt;&lt;/c12&gt;に設定される&lt;c10&gt;&lt;s11&gt;interlaced&lt;/s11&gt;&lt;/c10&gt;（「ノンインタレース・ビデオ」を意味します）、&lt;c14&gt;&lt;s15&gt;0.0&lt;/s15&gt;&lt;/c14&gt;の再生フレームレート、&lt;c18&gt;&lt;s19&gt;name&lt;/s19&gt;&lt;/c18&gt;というオプショナルの&lt;c16&gt;&lt;s17&gt;String&lt;/s17&gt;&lt;/c16&gt;値で初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the purpose of access control, extensions to the same type that are in the same file share an access-control scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アクセス制御の目的のために、同じ型で同じファイルの中にあるものに対する拡張それらは、アクセス制御スコープを共有します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the purposes of these rules, the characters &lt;c0&gt;&lt;s1&gt;(&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;[&lt;/s3&gt;&lt;/c2&gt;, and &lt;c4&gt;&lt;s5&gt;{&lt;/s5&gt;&lt;/c4&gt; before an operator, the characters &lt;c6&gt;&lt;s7&gt;)&lt;/s7&gt;&lt;/c6&gt;, &lt;c8&gt;&lt;s9&gt;]&lt;/s9&gt;&lt;/c8&gt;, and &lt;c10&gt;&lt;s11&gt;}&lt;/s11&gt;&lt;/c10&gt; after an operator, and the characters &lt;c12&gt;&lt;s13&gt;,&lt;/s13&gt;&lt;/c12&gt;, &lt;c14&gt;&lt;s15&gt;;&lt;/s15&gt;&lt;/c14&gt;, and &lt;c16&gt;&lt;s17&gt;:&lt;/s17&gt;&lt;/c16&gt; are also considered whitespace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの規則を理由に、演算子の前の文字&lt;c0&gt;&lt;s1&gt;(&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;[&lt;/s3&gt;&lt;/c2&gt;、および&lt;c4&gt;&lt;s5&gt;{&lt;/s5&gt;&lt;/c4&gt;、演算子の後の文字&lt;c6&gt;&lt;s7&gt;)&lt;/s7&gt;&lt;/c6&gt;、&lt;c8&gt;&lt;s9&gt;]&lt;/s9&gt;&lt;/c8&gt;、および&lt;c10&gt;&lt;s11&gt;}&lt;/s11&gt;&lt;/c10&gt;、そして文字&lt;c12&gt;&lt;s13&gt;,&lt;/s13&gt;&lt;/c12&gt;、&lt;c14&gt;&lt;s15&gt;;&lt;/s15&gt;&lt;/c14&gt;、および&lt;c16&gt;&lt;s17&gt;:&lt;/s17&gt;&lt;/c16&gt;は、また、空白と見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the purposes of this example, &lt;c4&gt;&lt;s5&gt;+++&lt;/s5&gt;&lt;/c4&gt; is treated as a new “prefix doubling” operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例の目的のために、&lt;c4&gt;&lt;s5&gt;+++&lt;/s5&gt;&lt;/c4&gt;は新しい「接頭辞倍加」演算子とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the same reason, you can’t pass the same value to multiple in-out parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じ理由のために、あなたは複数のin-outパラメータに対して同じ値を渡すことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For these types, Objective-C methods typically return a special value (such as &lt;c4&gt;&lt;s5&gt;NSNotFound&lt;/s5&gt;&lt;/c4&gt;) to indicate the absence of a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの型のために、Objective-Cメソッドは、値の欠如を示すために概して特別な値（例えば&lt;c4&gt;&lt;s5&gt;NSNotFound&lt;/s5&gt;&lt;/c4&gt;）を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this calculation, the individual counter values each time through the loop are unnecessary—the code simply executes the loop the correct number of times.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この計算では、ループするごとに個別のカウンタ値は必要ではありません ― このコードは単に正しい回数ループを実行するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this reason, Swift strings can’t be indexed by integer values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この理由のために、スウィフトの文字列は整数値でインデックス付けされることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this reason, the default implementation provided by the &lt;c10&gt;&lt;s11&gt;Loggable&lt;/s11&gt;&lt;/c10&gt; protocol is used instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この理由のために、&lt;c10&gt;&lt;s11&gt;Loggable&lt;/s11&gt;&lt;/c10&gt;プロトコルによって提供される省略時の実装が代わりに使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For value types, you use &lt;c0&gt;&lt;s1&gt;self.init&lt;/s1&gt;&lt;/c0&gt; to refer to other initializers from the same value type when writing your own custom initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値型のために、あなたは&lt;c0&gt;&lt;s1&gt;self.init&lt;/s1&gt;&lt;/c0&gt;を使って、あなた独自のあつらえのイニシャライザを書くとき同じ値型の他のイニシャライザに言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For-In Loops</seg>
      </tuv>
      <tuv lang="JA">
        <seg>for-inループ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For-In Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>For-In文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Forced-Value Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>強制された値式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Foundation also extends &lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt; to expose methods defined by &lt;c6&gt;&lt;s7&gt;NSString&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Foundationはまた、&lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt;を拡張して&lt;c6&gt;&lt;s7&gt;NSString&lt;/s7&gt;&lt;/c6&gt;によって定義されるメソッドに触れさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Frozen types, the types of the stored properties of frozen structures, and the associated values of frozen enumeration cases must be public or marked with the &lt;c0&gt;&lt;s1&gt;usableFromInline&lt;/s1&gt;&lt;/c0&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>凍結型、凍結構造体の格納プロパティの型、そして凍結列挙ケース節の関連値は、パブリックであるか&lt;c0&gt;&lt;s1&gt;usableFromInline&lt;/s1&gt;&lt;/c0&gt;属性で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function Argument Labels and Parameter Names</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数の引数ラベルとパラメータ名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function Call Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数呼び出し式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function Parameters and Return Values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数のパラメータと戻り値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function Types as Parameter Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータ型としての関数型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function Types as Return Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>戻り型としての関数型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function call expressions have the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数呼び出し式は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function declarations are declared using the &lt;c2&gt;&lt;s3&gt;func&lt;/s3&gt;&lt;/c2&gt; keyword and have the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数宣言は、キーワード&lt;c2&gt;&lt;s3&gt;func&lt;/s3&gt;&lt;/c2&gt;を使って宣言されます、そして以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function parameters and return values are extremely flexible in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数パラメータと戻り値は、スウィフトではとても柔軟です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function parameters are a comma-separated list where each parameter has one of several forms.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数パラメータはひとつの「コンマ区切り」のリストです、そこにおいて各パラメータはいくつかの書式のうちの１つを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function parameters are constants by default.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数パラメータは、特に何もしなければ定数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function parameters can have both a name (for use within the function’s body) and an argument label (for use when calling the function), as described in &lt;a0&gt;&lt;s1&gt;Function Argument Labels and Parameter Names&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数パラメータは、名前（関数の本文内で使うため）と引数ラベル（関数を呼び出すとき使うため）の両方を持つことができます、&lt;a0&gt;&lt;s1&gt;関数の引数ラベルとパラメータ名&lt;/s1&gt;&lt;/a0&gt;で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function type parameters with the &lt;c0&gt;&lt;s1&gt;escaping&lt;/s1&gt;&lt;/c0&gt; type attribute require explicit use of &lt;c2&gt;&lt;s3&gt;self.&lt;/s3&gt;&lt;/c2&gt; for properties or methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;escaping&lt;/s1&gt;&lt;/c0&gt;型属性を持つ関数型パラメーターは、明示的な&lt;c2&gt;&lt;s3&gt;self.&lt;/s3&gt;&lt;/c2&gt;の使用をプロパティやメソッドに対して必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function types that can throw or rethrow an error must be marked with the &lt;c0&gt;&lt;s1&gt;throws&lt;/s1&gt;&lt;/c0&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーをスローまたは再スローできる関数型は、&lt;c0&gt;&lt;s1&gt;throws&lt;/s1&gt;&lt;/c0&gt;キーワードで印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions With Multiple Parameters</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数のパラメーターを持つ関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions With an Implicit Return</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗黙的なreturnをもつ関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions Without Parameters</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータのない関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions Without Return Values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>戻り値のない関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions and Closures</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数とクロージャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions and closures that are defined inside an inlinable function are implicitly inlinable, even though they can’t be marked with this attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インライン可能関数内部で定義される関数とクロージャは、暗黙的にインライン可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions and methods that can throw an error must be marked with the &lt;c0&gt;&lt;s1&gt;throws&lt;/s1&gt;&lt;/c0&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーをスローできる関数とメソッドは、&lt;c0&gt;&lt;s1&gt;throws&lt;/s1&gt;&lt;/c0&gt;キーワードで印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions and methods with the &lt;c2&gt;&lt;s3&gt;Never&lt;/s3&gt;&lt;/c2&gt; return type are called &lt;e4&gt;nonreturning&lt;/e4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;Never&lt;/s3&gt;&lt;/c2&gt;戻り型を持つ関数およびメソッドは、&lt;e4&gt;非復帰&lt;/e4&gt;と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions are a first-class type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数は、第一級（ファーストクラス）の種類のものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions are actually a special case of closures: blocks of code that can be called later.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数は、実際のところクロージャ：後刻に呼び出されることができるコードのひとまとまり、の特別な場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions are not required to define a return type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数は、戻り型を定義することを要求されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions are not required to define input parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数は、入力パラメータを定義することを要求されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions can also be written within other functions to encapsulate useful functionality within a nested function scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数は、また、他の関数の内部で記述されることで、役に立つ機能性を入れ子にされた関数スコープ内でカプセル化することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions can be nested.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数は、入れ子にされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions can have multiple input parameters, which are written within the function’s parentheses, separated by commas.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数は複数の入力パラメータを持つことが出来ます、それは関数の丸括弧内に書かれ、コンマで区切られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions can return multiple values using a tuple type as the return type of the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数は、関数の戻り型としてタプル型を使って、複数の値を返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions that Never Return</seg>
      </tuv>
      <tuv lang="JA">
        <seg>決して返らない関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions that return an opaque type require the Swift 5.1 runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>不透明型を返す関数は、スウィフト5.1ランタイムを必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions with Multiple Return Values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数の戻り値を持つ関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Functions without a defined return type return a special value of type &lt;c3&gt;&lt;s4&gt;Void&lt;/s4&gt;&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>戻り型定義のない関数は、型&lt;c3&gt;&lt;s4&gt;Void&lt;/s4&gt;&lt;/c3&gt;の特別な値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fundamental Set Operations</seg>
      </tuv>
      <tuv lang="JA">
        <seg>集合演算の基本</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Furthermore, a new &lt;c0&gt;&lt;s1&gt;CreditCard&lt;/s1&gt;&lt;/c0&gt; instance can &lt;e2&gt;only&lt;/e2&gt; be created by passing a &lt;c3&gt;&lt;s4&gt;number&lt;/s4&gt;&lt;/c3&gt; value and a &lt;c5&gt;&lt;s6&gt;customer&lt;/s6&gt;&lt;/c5&gt; instance to a custom &lt;c7&gt;&lt;s8&gt;CreditCard&lt;/s8&gt;&lt;/c7&gt; initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらに、新しい&lt;c0&gt;&lt;s1&gt;CreditCard&lt;/s1&gt;&lt;/c0&gt;インスタンスは、&lt;c3&gt;&lt;s4&gt;number&lt;/s4&gt;&lt;/c3&gt;値と&lt;c5&gt;&lt;s6&gt;customer&lt;/s6&gt;&lt;/c5&gt;インスタンスをあつらえの&lt;c7&gt;&lt;s8&gt;CreditCard&lt;/s8&gt;&lt;/c7&gt;イニシャライザに渡すことによって&lt;e2&gt;のみ&lt;/e2&gt;作成されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Future versions of the library can’t change the declaration by adding, removing, or reordering an enumeration’s cases or a structure’s stored instance properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ライブラリの将来のバージョンは、追加、削除、または列挙のもつケース節や構造体のもつ格納インスタンスプロパティの再配列によって宣言を変更できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generally speaking, protocol types give you more flexibility about the underlying types of the values they store, and opaque types let you make stronger guarantees about those underlying types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一般的に言えば、プロトコル型はそれらが格納する値の基礎をなす型についてあなたにより柔軟性を与えます、そして不透明型はそれらの基礎をなす型についてあなたにより確固とした保証をさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generic Argument Clause</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体引数節</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generic Functions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generic Parameter Clause</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体パラメータ節</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generic Parameters and Arguments</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体パラメータと引数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generic Subscripts</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体添え字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generic Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generic Where Clauses</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体where節</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generic classes can inherit from other generic and nongeneric classes, but a nongeneric class can inherit only from other nongeneric classes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体クラスは、他の総称体および非総称体クラスから継承することができます、しかし非総称体クラスはただ他の非総称体クラスからのみ継承することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generic code enables you to write such a function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体コードは、あなたにこのような関数を書くことを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generic types let the code that calls a function pick the type for that function’s parameters and return value in a way that’s abstracted away from the function implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体型は、ある関数を呼び出すコードに、その関数のもつパラメータと戻り値に対する型を、関数実装から離れて抽象化されるある方法で選択させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generics</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Generics are one of the most powerful features of Swift, and much of the Swift standard library is built with generic code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体は、スウィフトの最も強力な特徴のうちの１つです、そして、多くのスウィフト標準ライブラリは総称体コードで組み立てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Gettable and settable properties are indicated by writing &lt;c2&gt;&lt;s3&gt;{&lt;/s3&gt; &lt;s4&gt;get&lt;/s4&gt; &lt;s5&gt;set&lt;/s5&gt; &lt;s6&gt;}&lt;/s6&gt;&lt;/c2&gt; after their type declaration, and gettable properties are indicated by writing &lt;c7&gt;&lt;s8&gt;{&lt;/s8&gt; &lt;s9&gt;get&lt;/s9&gt; &lt;s10&gt;}&lt;/s10&gt;&lt;/c7&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>取得可能かつまた設定可能なプロパティは、それらの型宣言の後に&lt;c2&gt;&lt;s3&gt;{&lt;/s3&gt; &lt;s4&gt;get&lt;/s4&gt; &lt;s5&gt;set&lt;/s5&gt; &lt;s6&gt;}&lt;/s6&gt;&lt;/c2&gt;を書くことによって示されます、そして取得可能なプロパティは&lt;c7&gt;&lt;s8&gt;{&lt;/s8&gt; &lt;s9&gt;get&lt;/s9&gt; &lt;s10&gt;}&lt;/s10&gt;&lt;/c7&gt;を書くことによって示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Getters and Setters</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ゲッターとセッター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Getters and setters for constants, variables, properties, and subscripts automatically receive the same access level as the constant, variable, property, or subscript they belong to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数、変数、プロパティ、そして添え字のためのゲッターとセッターは、自動的に、それらが属している定数、変数、プロパティまたは添え字と同じアクセス水準を受けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Give enumeration types singular rather than plural names, so that they read as self-evident:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙型に複数形よりむしろ単数形の名前を与えてください、わかりきったことという印象を受けるので：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Give properties and methods &lt;c12&gt;&lt;s13&gt;lowerCamelCase&lt;/s13&gt;&lt;/c12&gt; names (such as &lt;c14&gt;&lt;s15&gt;frameRate&lt;/s15&gt;&lt;/c14&gt; and &lt;c16&gt;&lt;s17&gt;incrementCount&lt;/s17&gt;&lt;/c16&gt;) to differentiate them from type names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティとメソッドに&lt;c12&gt;&lt;s13&gt;lowerCamelCase ローワーキャメルケース&lt;/s13&gt;&lt;/c12&gt;名（例えば&lt;c14&gt;&lt;s15&gt;frameRate&lt;/s15&gt;&lt;/c14&gt;や&lt;c16&gt;&lt;s17&gt;incrementCount&lt;/s17&gt;&lt;/c16&gt;など）を与えて、それらを型名と区別するようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Give types &lt;c0&gt;&lt;s1&gt;UpperCamelCase&lt;/s1&gt;&lt;/c0&gt; names (such as &lt;c2&gt;&lt;s3&gt;SomeStructure&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;SomeClass&lt;/s5&gt;&lt;/c4&gt; here) to match the capitalization of standard Swift types (such as &lt;c6&gt;&lt;s7&gt;String&lt;/s7&gt;&lt;/c6&gt;, &lt;c8&gt;&lt;s9&gt;Int&lt;/s9&gt;&lt;/c8&gt;, and &lt;c10&gt;&lt;s11&gt;Bool&lt;/s11&gt;&lt;/c10&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それら型に&lt;c0&gt;&lt;s1&gt;UpperCamelCase アッパーキャメルケース&lt;/s1&gt;&lt;/c0&gt;名（ここでの&lt;c2&gt;&lt;s3&gt;SomeStructure&lt;/s3&gt;&lt;/c2&gt;や&lt;c4&gt;&lt;s5&gt;SomeClass&lt;/s5&gt;&lt;/c4&gt;のような）を与えて、標準のスウィフト型（例えば&lt;c6&gt;&lt;s7&gt;String&lt;/s7&gt;&lt;/c6&gt;、&lt;c8&gt;&lt;s9&gt;Int&lt;/s9&gt;&lt;/c8&gt;、そして&lt;c10&gt;&lt;s11&gt;Bool&lt;/s11&gt;&lt;/c10&gt;など）の大文字の使用法に合わせてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Global and Local Variables</seg>
      </tuv>
      <tuv lang="JA">
        <seg>グローバルおよびローカル変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Global and nested functions, as introduced in &lt;a0&gt;&lt;s1&gt;Functions&lt;/s1&gt;&lt;/a0&gt;, are actually special cases of closures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;関数&lt;/s1&gt;&lt;/a0&gt;で紹介される、グローバルおよび入れ子にされた関数は、実際にはクロージャの特別な場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Global constants and variables are always computed lazily, in a similar manner to &lt;a0&gt;&lt;s1&gt;Lazy Stored Properties&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>グローバルな定数と変数は、&lt;a0&gt;&lt;s1&gt;遅延格納プロパティ&lt;/s1&gt;&lt;/a0&gt;と似たやり方で、常に遅延計算されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Global functions are closures that have a name and do not capture any values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>グローバルな関数は、名前を持ち、まったく値をキャプチャしない（捕獲しない）クロージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Global variables are variables that are defined outside of any function, method, closure, or type context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>グローバルな変数は、あらゆる関数、メソッド、クロージャ、または型の文脈の外で定義される変数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a Self type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Self型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a binary expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>二項式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a branch statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>分岐文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a break statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ブレーク文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a class declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a closure expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャ式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a code block</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コードブロックの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a compile-time diagnostic statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイル時診断文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a compiler control statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラ制御文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a conditional compilation block</seg>
      </tuv>
      <tuv lang="JA">
        <seg>条件コンパイルブロックの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a conditional operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>条件演算子の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a constant declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a continue statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>継続文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a control transfer statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>制御移動文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a declaration modifier</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言修飾子の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a defer statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>defer文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a deinitializer declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デイニシャライザ宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a dictionary type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a do statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>do文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a fallthrough statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>フォールスルー文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a floating-point literal</seg>
      </tuv>
      <tuv lang="JA">
        <seg>浮動小数点リテラルの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a for-in statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>for-in文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a forced-value expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>強制された値の式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a function call expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数呼び出し式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a function declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a function type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a generic argument clause</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体引数節の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a generic parameter clause</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体パラメータ節の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a getter-setter block</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ゲッターセッター・ブロックの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a guard statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>guard文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a implicit member expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗黙的メンバー式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a key-path expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キーパス式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a key-path string expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キーパス文字列式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a labeled statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ラベルをつけられた文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a line control statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>行制御文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a literal</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リテラルの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a literal expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リテラル式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a loop statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ループ文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a metatype type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メタタイプ型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a parenthesized expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>丸括弧に入れられた式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a pattern</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a postfix expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接尾辞式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a postfix self expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接尾辞self式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a precedence group declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>優先順位グループ宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a prefix expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接頭辞式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a primary expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>基本式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a protocol associated type declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル関連型宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a protocol composition type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル合成型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a protocol declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a protocol initializer declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル・イニシャライザ宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a protocol method declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルメソッド宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a protocol property declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルプロパティ宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a protocol subscript declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル添え字宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a repeat-while statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>repeat-while文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a return statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>return文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a selector expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セレクタ式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a self expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>self式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a string literal</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列リテラルの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a structure declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a subscript declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a subscript expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a superclass expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラス式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a switch statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>switch文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a throw statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スロー文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a top-level declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>トップレベル宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a try expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>try式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a tuple expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプル式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a tuple pattern</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプル・パターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a tuple type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプル型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a type alias declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型エイリアス宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a type annotation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型注釈の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a type casting pattern</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型キャスト・パターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a type identifier</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型識別子の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a type inheritance clause</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型継承節の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a type-casting operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型キャスト演算子の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a value-binding pattern</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値束縛パターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a variable declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変数宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a while statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>while文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a wildcard expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ワイルドカード式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of a wildcard pattern</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ワイルドカード・パターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an array type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an assignment operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代入演算子の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an attribute</seg>
      </tuv>
      <tuv lang="JA">
        <seg>属性の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an availability condition</seg>
      </tuv>
      <tuv lang="JA">
        <seg>有効性条件の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an enumeration case pattern</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙ケース節パターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an enumeration declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an explicit member expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>明示的メンバー式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an expression pattern</seg>
      </tuv>
      <tuv lang="JA">
        <seg>式パターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an extension declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an identifier</seg>
      </tuv>
      <tuv lang="JA">
        <seg>識別子の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an identifier pattern</seg>
      </tuv>
      <tuv lang="JA">
        <seg>識別子パターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an if statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>if文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an implicitly unwrapped optional type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗黙的にアンラップされるオプショナル型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an import declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インポート宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an initializer declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザ宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an initializer expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザ式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an integer literal</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数リテラルの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an opaque type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>不透明型の構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an operator declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an optional pattern</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルパターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an optional type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of an optional-chaining expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grammar of whitespace</seg>
      </tuv>
      <tuv lang="JA">
        <seg>空白の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Greater than (&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt; &lt;s2&gt;&gt;&lt;/s2&gt; &lt;s3&gt;b&lt;/s3&gt;&lt;/c0&gt;)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より大きい (&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt; &lt;s2&gt;&gt;&lt;/s2&gt; &lt;s3&gt;b&lt;/s3&gt;&lt;/c0&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Greater than or equal to (&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt; &lt;s2&gt;&gt;=&lt;/s2&gt; &lt;s3&gt;b&lt;/s3&gt;&lt;/c0&gt;)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より大きいか等しい、以上 (&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt; &lt;s2&gt;&gt;=&lt;/s2&gt; &lt;s3&gt;b&lt;/s3&gt;&lt;/c0&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Greet n times</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（n回あいさつします）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Grouping parentheses don’t change an expression’s type—for example, the type of &lt;c1&gt;&lt;s2&gt;(1)&lt;/s2&gt;&lt;/c1&gt; is simply &lt;c3&gt;&lt;s4&gt;Int&lt;/s4&gt;&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>グループ化括弧はある式のもつ型を変えません — 例えば、&lt;c1&gt;&lt;s2&gt;(1)&lt;/s2&gt;&lt;/c1&gt;の型は単に&lt;c3&gt;&lt;s4&gt;Int&lt;/s4&gt;&lt;/c3&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Guard Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>guard文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Guiding Principle of Access Levels</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アクセス水準の原理指針</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Half-Open Range Operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>半開範囲演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Half-open ranges are particularly useful when you work with zero-based lists such as arrays, where it’s useful to count up to (but not including) the length of the list:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>半開範囲は、あなたが配列のようなゼロに基づくリストを扱うとき特に便利です、そこにおいて、そのリストの長さまで（しかしそれは含まずに）数え上げるのに役に立ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Handling Errors</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーを処理する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Handling Errors Using Do-Catch</seg>
      </tuv>
      <tuv lang="JA">
        <seg>do-catchを使ってエラーを処理する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hash Values for Set Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Set型のためのハッシュ値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Having created a new &lt;c0&gt;&lt;s1&gt;Vehicle&lt;/s1&gt;&lt;/c0&gt; instance, you can access its &lt;c2&gt;&lt;s3&gt;description&lt;/s3&gt;&lt;/c2&gt; property to print a human-readable description of the vehicle’s current speed:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい&lt;c0&gt;&lt;s1&gt;Vehicle&lt;/s1&gt;&lt;/c0&gt;インスタンスを作成したら、あなたはそれの&lt;c2&gt;&lt;s3&gt;description&lt;/s3&gt;&lt;/c2&gt;プロパティにアクセスして、その乗り物の現在速度の説明を人の読めるように出力することが出来ます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are two classes, &lt;c0&gt;&lt;s1&gt;Circle&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;Country&lt;/s3&gt;&lt;/c2&gt;, both of which conform to the &lt;c4&gt;&lt;s5&gt;HasArea&lt;/s5&gt;&lt;/c4&gt; protocol:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その両方とも&lt;c4&gt;&lt;s5&gt;HasArea&lt;/s5&gt;&lt;/c4&gt;プロトコルに従う２つのクラス、&lt;c0&gt;&lt;s1&gt;Circle&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;Country&lt;/s3&gt;&lt;/c2&gt;が、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is the general form of a &lt;c0&gt;&lt;s1&gt;do&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;catch&lt;/s3&gt;&lt;/c2&gt; statement:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに&lt;c0&gt;&lt;s1&gt;do&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;catch&lt;/s3&gt;&lt;/c2&gt;文の一般的な形式があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here the function returns an integer, so &lt;c18&gt;&lt;s19&gt;x&lt;/s19&gt;&lt;/c18&gt; and &lt;c20&gt;&lt;s21&gt;y&lt;/s21&gt;&lt;/c20&gt; are optional integers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに整数を返す関数があります、それで&lt;c18&gt;&lt;s19&gt;x&lt;/s19&gt;&lt;/c18&gt;と&lt;c20&gt;&lt;s21&gt;y&lt;/s21&gt;&lt;/c20&gt;はオプショナル整数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, &lt;c0&gt;&lt;s1&gt;$0&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;$1&lt;/s3&gt;&lt;/c2&gt; refer to the closure’s first and second &lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt; arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここでは、&lt;c0&gt;&lt;s1&gt;$0&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;$1&lt;/s3&gt;&lt;/c2&gt;は、クロージャの１番目と２番目の&lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt;引数に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, &lt;c0&gt;&lt;s1&gt;AudioSample&lt;/s1&gt;&lt;/c0&gt; is defined as an alias for &lt;c2&gt;&lt;s3&gt;UInt16&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここでは、&lt;c0&gt;&lt;s1&gt;AudioSample&lt;/s1&gt;&lt;/c0&gt;は&lt;c2&gt;&lt;s3&gt;UInt16&lt;/s3&gt;&lt;/c2&gt;に対するエイリアス（別名）として定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, &lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt; disambiguates between a method parameter called &lt;c2&gt;&lt;s3&gt;x&lt;/s3&gt;&lt;/c2&gt; and an instance property that is also called &lt;c4&gt;&lt;s5&gt;x&lt;/s5&gt;&lt;/c4&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここでは、&lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;は、&lt;c2&gt;&lt;s3&gt;x&lt;/s3&gt;&lt;/c2&gt;と呼ばれるメソッドパラメータと同様にまた&lt;c4&gt;&lt;s5&gt;x&lt;/s5&gt;&lt;/c4&gt;と呼ばれるインスタンスプロパティの間の曖昧さをなくします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, a new array called &lt;c0&gt;&lt;s1&gt;breakfastList&lt;/s1&gt;&lt;/c0&gt; is created from an array literal containing three new &lt;c2&gt;&lt;s3&gt;ShoppingListItem&lt;/s3&gt;&lt;/c2&gt; instances.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここでは、&lt;c0&gt;&lt;s1&gt;breakfastList&lt;/s1&gt;&lt;/c0&gt;と呼ばれる新しい配列は、３つの新しい&lt;c2&gt;&lt;s3&gt;ShoppingListItem&lt;/s3&gt;&lt;/c2&gt;インスタンスを含んでいる配列リテラルからつくられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, an additional &lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt; statement was added to respond to particularly warm temperatures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここでは、追加の&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt;文は、特に暖かい気温に反応するために加えられました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, the &lt;c11&gt;&lt;s12&gt;favoriteGenres&lt;/s12&gt;&lt;/c11&gt; set is initialized with three &lt;c13&gt;&lt;s14&gt;String&lt;/s14&gt;&lt;/c13&gt; values (&lt;c15&gt;&lt;s16&gt;"Rock"&lt;/s16&gt;&lt;/c15&gt;, &lt;c17&gt;&lt;s18&gt;"Classical"&lt;/s18&gt;&lt;/c17&gt;, and &lt;c19&gt;&lt;s20&gt;"Hip&lt;/s20&gt; &lt;s21&gt;hop"&lt;/s21&gt;&lt;/c19&gt;), written within an array literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここでは、&lt;c11&gt;&lt;s12&gt;favoriteGenres&lt;/s12&gt;&lt;/c11&gt;集合は、配列リテラル内に書かれる、３つの&lt;c13&gt;&lt;s14&gt;String&lt;/s14&gt;&lt;/c13&gt;値（&lt;c15&gt;&lt;s16&gt;"Rock"&lt;/s16&gt;&lt;/c15&gt;、&lt;c17&gt;&lt;s18&gt;"Classical"&lt;/s18&gt;&lt;/c17&gt;、そして&lt;c19&gt;&lt;s20&gt;"Hip&lt;/s20&gt; &lt;s21&gt;hop"&lt;/s21&gt;&lt;/c19&gt;）で初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, the &lt;c8&gt;&lt;s9&gt;shoppingList&lt;/s9&gt;&lt;/c8&gt; array is initialized with two &lt;c10&gt;&lt;s11&gt;String&lt;/s11&gt;&lt;/c10&gt; values (&lt;c12&gt;&lt;s13&gt;"Eggs"&lt;/s13&gt;&lt;/c12&gt; and &lt;c14&gt;&lt;s15&gt;"Milk"&lt;/s15&gt;&lt;/c14&gt;), written within an array literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここで、&lt;c8&gt;&lt;s9&gt;shoppingList&lt;/s9&gt;&lt;/c8&gt;配列は、配列リテラル内に書かれる２つの&lt;c10&gt;&lt;s11&gt;String&lt;/s11&gt;&lt;/c10&gt;値（&lt;c12&gt;&lt;s13&gt;"Eggs"&lt;/s13&gt;&lt;/c12&gt;と&lt;c14&gt;&lt;s15&gt;"Milk"&lt;/s15&gt;&lt;/c14&gt;）で初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, the deinitializer simply returns all of the player’s coins to the bank:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここでは、デイニシャライザは単に胴元にプレーヤーのコインの全てを返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, the function type of the &lt;c0&gt;&lt;s1&gt;sorted(by:)&lt;/s1&gt;&lt;/c0&gt; method’s argument makes it clear that a &lt;c2&gt;&lt;s3&gt;Bool&lt;/s3&gt;&lt;/c2&gt; value must be returned by the closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここでは、&lt;c0&gt;&lt;s1&gt;sorted(by:)&lt;/s1&gt;&lt;/c0&gt;メソッドの引数である関数型は、&lt;c2&gt;&lt;s3&gt;Bool&lt;/s3&gt;&lt;/c2&gt;値がクロージャによって返されなければならないことを明白にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, the player has won 2,000 coins.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここでは、プレーヤーは2,000個のコインを獲得しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, the possibility that &lt;c18&gt;&lt;s19&gt;increment(forCount:)&lt;/s19&gt;&lt;/c18&gt; might not be implemented is also handled by optional chaining.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここでは、&lt;c18&gt;&lt;s19&gt;increment(forCount:)&lt;/s19&gt;&lt;/c18&gt;が実装されないかもしれないという可能性もまたオプショナル連鎖によって取り扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, the raw values for an enumeration called &lt;c0&gt;&lt;s1&gt;ASCIIControlCharacter&lt;/s1&gt;&lt;/c0&gt; are defined to be of type &lt;c2&gt;&lt;s3&gt;Character&lt;/s3&gt;&lt;/c2&gt;, and are set to some of the more common ASCII control characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここでは、&lt;c0&gt;&lt;s1&gt;ASCIIControlCharacter&lt;/s1&gt;&lt;/c0&gt;と呼ばれる列挙に対する生の値は、型&lt;c2&gt;&lt;s3&gt;Character&lt;/s3&gt;&lt;/c2&gt;であると定義されて、たいへんありふれたASCII制御文字のいくつかに設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, the superclass has a single designated initializer and two convenience initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここでは、スーパークラスは１つの指定イニシャライザと２つの便宜イニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, the value of the constant &lt;c0&gt;&lt;s1&gt;three&lt;/s1&gt;&lt;/c0&gt; is used to create a new value of type &lt;c2&gt;&lt;s3&gt;Double&lt;/s3&gt;&lt;/c2&gt;, so that both sides of the addition are of the same type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここでは、定数&lt;c0&gt;&lt;s1&gt;three&lt;/s1&gt;&lt;/c0&gt;の値が、&lt;c2&gt;&lt;s3&gt;Double&lt;/s3&gt;&lt;/c2&gt;型の新しい値をつくるために使われます、それでこの加算の両側は同じ型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, they are used to print the categorization of the point.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここでは、それらはポイントの分類を出力するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s a class called &lt;c0&gt;&lt;s1&gt;Animal&lt;/s1&gt;&lt;/c0&gt;, which doesn’t conform to the &lt;c2&gt;&lt;s3&gt;HasArea&lt;/s3&gt;&lt;/c2&gt; protocol:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;HasArea&lt;/s3&gt;&lt;/c2&gt;プロトコルに従わない&lt;c0&gt;&lt;s1&gt;Animal&lt;/s1&gt;&lt;/c0&gt;と呼ばれるクラスが、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s a function called &lt;c0&gt;&lt;s1&gt;chooseStepFunction(backward:)&lt;/s1&gt;&lt;/c0&gt;, whose return type is &lt;c2&gt;&lt;s3&gt;(Int)&lt;/s3&gt; &lt;s4&gt;-&gt;&lt;/s4&gt; &lt;s5&gt;Int&lt;/s5&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに&lt;c0&gt;&lt;s1&gt;chooseStepFunction(backward:)&lt;/s1&gt;&lt;/c0&gt;と呼ばれる関数があります、それの戻り型は&lt;c2&gt;&lt;s3&gt;(Int)&lt;/s3&gt; &lt;s4&gt;-&gt;&lt;/s4&gt; &lt;s5&gt;Int&lt;/s5&gt;&lt;/c2&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s a function with no input parameters, which always returns the same &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; message whenever it is called:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに入力パラメータのない関数があります、そしてそれは、それが呼ばれるときはいつでも、常に同じ&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;メッセージを返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s a generic version of the &lt;c1&gt;&lt;s2&gt;swapTwoInts(_:_:)&lt;/s2&gt;&lt;/c1&gt; function from above, called &lt;c3&gt;&lt;s4&gt;swapTwoValues(_:_:)&lt;/s4&gt;&lt;/c3&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに、上記の&lt;c1&gt;&lt;s2&gt;swapTwoInts(_:_:)&lt;/s2&gt;&lt;/c1&gt;関数の総称体版があります、それは&lt;c3&gt;&lt;s4&gt;swapTwoValues(_:_:)&lt;/s4&gt;&lt;/c3&gt;と呼ばれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s a generic version of the same code:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じコードの総称体版は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s a more complex class, which also adopts and conforms to the &lt;c0&gt;&lt;s1&gt;FullyNamed&lt;/s1&gt;&lt;/c0&gt; protocol:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>また、&lt;c0&gt;&lt;s1&gt;FullyNamed&lt;/s1&gt;&lt;/c0&gt;プロトコルを採用して準拠するさらに複雑なクラスが、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s a more complex data source called &lt;c0&gt;&lt;s1&gt;TowardsZeroSource&lt;/s1&gt;&lt;/c0&gt;, which makes a &lt;c2&gt;&lt;s3&gt;Counter&lt;/s3&gt;&lt;/c2&gt; instance count up or down towards zero from its current &lt;c4&gt;&lt;s5&gt;count&lt;/s5&gt;&lt;/c4&gt; value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;TowardsZeroSource&lt;/s1&gt;&lt;/c0&gt;と呼ばれるより複雑なデータ・ソースがここにあります、それは、&lt;c2&gt;&lt;s3&gt;Counter&lt;/s3&gt;&lt;/c2&gt;インスタンスをその現在の&lt;c4&gt;&lt;s5&gt;count&lt;/s5&gt;&lt;/c4&gt;値から上下にゼロの方へ数えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s a nongeneric function called &lt;c0&gt;&lt;s1&gt;findIndex(ofString:in:)&lt;/s1&gt;&lt;/c0&gt;, which is given a &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt; value to find and an array of &lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt; values within which to find it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに&lt;c0&gt;&lt;s1&gt;findIndex(ofString:in:)&lt;/s1&gt;&lt;/c0&gt;と呼ばれる非総称体関数があります、それは、見つける&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;値と、そこにおいてそれを捜す&lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt;値からなる配列を与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s a simple &lt;c0&gt;&lt;s1&gt;CounterDataSource&lt;/s1&gt;&lt;/c0&gt; implementation where the data source returns a constant value of &lt;c2&gt;&lt;s3&gt;3&lt;/s3&gt;&lt;/c2&gt; every time it’s queried.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある単純な&lt;c0&gt;&lt;s1&gt;CounterDataSource&lt;/s1&gt;&lt;/c0&gt;実装がここにあります、そこにおいて、データ・ソースは&lt;c2&gt;&lt;s3&gt;3&lt;/s3&gt;&lt;/c2&gt;の定数値をそれが問い合わされるたびに返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s a skeleton outline of how a closure can be used to provide a default property value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに、あるクロージャが省略時のプロパティ値を提供するために使われることができる方法の骨組み概要があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s a standard, nongeneric function called &lt;c0&gt;&lt;s1&gt;swapTwoInts(_:_:)&lt;/s1&gt;&lt;/c0&gt;, which swaps two &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt; values:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに、通常の、非総称体の&lt;c0&gt;&lt;s1&gt;swapTwoInts(_:_:)&lt;/s1&gt;&lt;/c0&gt;と呼ばれる関数があります、それは、２つの&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;値を交換します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s a structure that stores a small rectangle, using the same (rather arbitrary) definition of “small” that’s implemented by the &lt;c0&gt;&lt;s1&gt;TwelveOrLess&lt;/s1&gt;&lt;/c0&gt; property wrapper:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここにある構造体があります、それは小さな矩形を格納します、&lt;c0&gt;&lt;s1&gt;TwelveOrLess&lt;/s1&gt;&lt;/c0&gt;プロパティラッパーによって実装されるのと同じ “小さい” の定義を使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s a variation of the &lt;c0&gt;&lt;s1&gt;greet(person:)&lt;/s1&gt;&lt;/c0&gt; function that takes a person’s name and hometown and returns a greeting:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに&lt;c0&gt;&lt;s1&gt;greet(person:)&lt;/s1&gt;&lt;/c0&gt;関数の変形があります、それはある個人の名前と出身地をとって挨拶を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s a version of the &lt;c0&gt;&lt;s1&gt;greet(person:)&lt;/s1&gt;&lt;/c0&gt; function, which prints its own &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt; value rather than returning it:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに&lt;c0&gt;&lt;s1&gt;greet(person:)&lt;/s1&gt;&lt;/c0&gt;関数の改作があります、それは&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;値を自身で出力します、それを返すのではなく：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s a version of the &lt;e0&gt;Snakes and Ladders&lt;/e0&gt; game originally introduced in &lt;a1&gt;&lt;s2&gt;Control Flow&lt;/s2&gt;&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a1&gt;&lt;s2&gt;制御の流れ&lt;/s2&gt;&lt;/a1&gt;で元々は紹介される&lt;e0&gt;ヘビとはしご&lt;/e0&gt;ゲームのひとつの改作が、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s a version of the nongeneric &lt;c0&gt;&lt;s1&gt;IntStack&lt;/s1&gt;&lt;/c0&gt; type from &lt;a2&gt;&lt;s3&gt;Generic Types&lt;/s3&gt;&lt;/a2&gt; above, adapted to conform to the &lt;c4&gt;&lt;s5&gt;Container&lt;/s5&gt;&lt;/c4&gt; protocol:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに、上の&lt;a2&gt;&lt;s3&gt;総称体型&lt;/s3&gt;&lt;/a2&gt;からの非総称体&lt;c0&gt;&lt;s1&gt;IntStack&lt;/s1&gt;&lt;/c0&gt;型の改作、&lt;c4&gt;&lt;s5&gt;Container&lt;/s5&gt;&lt;/c4&gt;プロトコルに準拠するために適応させたものがあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an alternative version of the &lt;c2&gt;&lt;s3&gt;Rect&lt;/s3&gt;&lt;/c2&gt; structure that takes advantage of this shorthand notation:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに&lt;c2&gt;&lt;s3&gt;Rect&lt;/s3&gt;&lt;/c2&gt;構造体の代替のバージョンがあります、それはこの短縮形表記法を利用します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an another version of the &lt;c0&gt;&lt;s1&gt;Rect&lt;/s1&gt;&lt;/c0&gt; structure that takes advantage of this shorthand notation and the shorthand notation for setters:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに&lt;c0&gt;&lt;s1&gt;Rect&lt;/s1&gt;&lt;/c0&gt;構造体の別のバージョンがあります、それはこの省略形表記法とセッターに対する省略形表記法を利用します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example for the four main points of a compass:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに、コンパスの主な４方位のための例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of &lt;c0&gt;&lt;s1&gt;makeIncrementer&lt;/s1&gt;&lt;/c0&gt; in action:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>動作している&lt;c0&gt;&lt;s1&gt;makeIncrementer&lt;/s1&gt;&lt;/c0&gt;の例がここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of &lt;c0&gt;&lt;s1&gt;willSet&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;didSet&lt;/s3&gt;&lt;/c2&gt; in action.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;willSet&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;didSet&lt;/s3&gt;&lt;/c2&gt;の作動する例が、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of a deinitializer in action.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デイニシャライザの動作の例は、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of a function called &lt;c0&gt;&lt;s1&gt;makeIncrementer&lt;/s1&gt;&lt;/c0&gt;, which contains a nested function called &lt;c2&gt;&lt;s3&gt;incrementer&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに、&lt;c0&gt;&lt;s1&gt;makeIncrementer&lt;/s1&gt;&lt;/c0&gt;と呼ばれる関数の例があります、それは&lt;c2&gt;&lt;s3&gt;incrementer&lt;/s3&gt;&lt;/c2&gt;と呼ばれる入れ子にされた関数を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of a function called &lt;c0&gt;&lt;s1&gt;swapTwoInts(_:_:)&lt;/s1&gt;&lt;/c0&gt;, which has two in-out integer parameters called &lt;c2&gt;&lt;s3&gt;a&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;b&lt;/s5&gt;&lt;/c4&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに&lt;c0&gt;&lt;s1&gt;swapTwoInts(_:_:)&lt;/s1&gt;&lt;/c0&gt;と呼ばれる関数の例があります、それは、&lt;c2&gt;&lt;s3&gt;a&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;b&lt;/s5&gt;&lt;/c4&gt;と呼ばれる２つのin-out整数パラメータを持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of a function that incorporates its type parameter into the underlying type of the value it returns:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに、ある関数の例があります、それはそれの型パラメータを、それが返す値のその基礎をなす型へと組み入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of a protocol called &lt;c0&gt;&lt;s1&gt;Container&lt;/s1&gt;&lt;/c0&gt;, which declares an associated type called &lt;c2&gt;&lt;s3&gt;Item&lt;/s3&gt;&lt;/c2&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Container&lt;/s1&gt;&lt;/c0&gt;と呼ばれるプロトコルの例がここにあります、それは&lt;c2&gt;&lt;s3&gt;Item&lt;/s3&gt;&lt;/c2&gt;と呼ばれる関連型を宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of a protocol that inherits the &lt;c0&gt;&lt;s1&gt;TextRepresentable&lt;/s1&gt;&lt;/c0&gt; protocol from above:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の&lt;c0&gt;&lt;s1&gt;TextRepresentable&lt;/s1&gt;&lt;/c0&gt;プロトコルを継承するプロトコルの例は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of a protocol used as a type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型として使われるプロトコルの例は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of a protocol with a single instance property requirement:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ただ１つのインスタンスプロパティ要件を持つプロトコルの例が、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of a read-only subscript implementation, which defines a &lt;c0&gt;&lt;s1&gt;TimesTable&lt;/s1&gt;&lt;/c0&gt; structure to represent an &lt;e2&gt;n&lt;/e2&gt;-times-table of integers:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに読み出し専用の添え字の実施の例があります、それは、整数の九九の&lt;e2&gt;n&lt;/e2&gt;段を表す&lt;c0&gt;&lt;s1&gt;TimesTable&lt;/s1&gt;&lt;/c0&gt;構造体を定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of a simple structure that adopts and conforms to the &lt;c0&gt;&lt;s1&gt;FullyNamed&lt;/s1&gt;&lt;/c0&gt; protocol:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;FullyNamed&lt;/s1&gt;&lt;/c0&gt;プロトコルを採用して準拠する単純な構造体の例は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of a structure definition and a class definition:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体定義とクラス定義の例は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of how Automatic Reference Counting works.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>自動参照カウントがどのように働くかの例は、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of how a strong reference cycle can be created by accident.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>強い参照循環がどのように偶然に作られることができるかの例は、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of how constants and variables can be used to track the number of login attempts a user has made:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに定数と変数が、どのようにあるユーザーが行ったログインの試みの数を追跡するために使われることができるかの例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of how error handling can be used to respond to different error conditions:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここにどのようにエラー処理が異なるエラー状態に応答するために使われることができるかの例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of how optionals can be used to cope with the absence of a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに、値の欠如に対処するためにどのようにオプショナルが使われることができるかの１つの例があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of this syntax for a &lt;c0&gt;&lt;s1&gt;while&lt;/s1&gt;&lt;/c0&gt; loop, although the principle is the same for all loops and &lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt; statements:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに、この構文の&lt;c0&gt;&lt;s1&gt;while&lt;/s1&gt;&lt;/c0&gt;ループに対する例があります、とはいえその原則は全てのループと&lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt;文のための同じです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of using &lt;c0&gt;&lt;s1&gt;Any&lt;/s1&gt;&lt;/c0&gt; to work with a mix of different types, including function types and nonclass types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数型と非クラス型を含む、異なった型の混合を扱うために&lt;c0&gt;&lt;s1&gt;Any&lt;/s1&gt;&lt;/c0&gt;を使う例が、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example of what happens when an unsigned integer is allowed to overflow in the positive direction, using the overflow addition operator (&lt;c0&gt;&lt;s1&gt;&amp;+&lt;/s1&gt;&lt;/c0&gt;):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに、オーバフロー加算演算子（&lt;c0&gt;&lt;s1&gt;&amp;+&lt;/s1&gt;&lt;/c0&gt;）を使用して、正の向きにおいて符号なし整数がオーバフローを許されるとき何が起こるかの例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example that combines the &lt;c0&gt;&lt;s1&gt;Named&lt;/s1&gt;&lt;/c0&gt; protocol from the previous example with a &lt;c2&gt;&lt;s3&gt;Location&lt;/s3&gt;&lt;/c2&gt; class:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに１つの例があります、それは前の例からの&lt;c0&gt;&lt;s1&gt;Named&lt;/s1&gt;&lt;/c0&gt;プロトコルを&lt;c2&gt;&lt;s3&gt;Location&lt;/s3&gt;&lt;/c2&gt;クラスと結び付けます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example that combines two protocols called &lt;c0&gt;&lt;s1&gt;Named&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;Aged&lt;/s3&gt;&lt;/c2&gt; into a single protocol composition requirement on a function parameter:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに、関数パラメータ上で&lt;c0&gt;&lt;s1&gt;Named&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;Aged&lt;/s3&gt;&lt;/c2&gt;と呼ばれる２つのプロトコルを１つのプロトコル合成要件に結合する例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example that defines a simple &lt;c0&gt;&lt;s1&gt;Counter&lt;/s1&gt;&lt;/c0&gt; class, which can be used to count the number of times an action occurs:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単純な&lt;c0&gt;&lt;s1&gt;Counter&lt;/s1&gt;&lt;/c0&gt;クラスを定義する例がここにあります、それは、ある動作が起こる回数を数えるために使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example that stores raw ASCII values alongside named enumeration cases:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定した列挙ケース節の傍らに生のASCII値を格納する例は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example to print the results of the math functions from above:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに上記の数学関数の結果を出力する例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example using the overflow subtraction operator (&lt;c0&gt;&lt;s1&gt;&amp;-&lt;/s1&gt;&lt;/c0&gt;):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここにオーバフロー減算演算子（&lt;c0&gt;&lt;s1&gt;&amp;-&lt;/s1&gt;&lt;/c0&gt;）を使った例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example, using the &lt;c0&gt;&lt;s1&gt;VideoMode&lt;/s1&gt;&lt;/c0&gt; class defined above:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上で定義される&lt;c0&gt;&lt;s1&gt;VideoMode&lt;/s1&gt;&lt;/c0&gt;クラスを使用している例がここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example, which calculates the height for a table row.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここにひとつの例があります、それはあるテーブルの列の高さを計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここにひとつの例があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an example:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここにある例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an expanded version of &lt;c12&gt;&lt;s13&gt;TwelveOrLess&lt;/s13&gt;&lt;/c12&gt; called &lt;c14&gt;&lt;s15&gt;SmallNumber&lt;/s15&gt;&lt;/c14&gt; that defines initializers that set the wrapped and maximum value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここにある拡張されたバージョンの&lt;c12&gt;&lt;s13&gt;TwelveOrLess&lt;/s13&gt;&lt;/c12&gt;、&lt;c14&gt;&lt;s15&gt;SmallNumber&lt;/s15&gt;&lt;/c14&gt;と呼ばれるものがあります、それはラップされたそして最大限の値を設定するイニシャライザそれらを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an expanded version of the &lt;c0&gt;&lt;s1&gt;Celsius&lt;/s1&gt;&lt;/c0&gt; example from &lt;a2&gt;&lt;s3&gt;Initialization Parameters&lt;/s3&gt;&lt;/a2&gt; above, with an additional initializer to create a new &lt;c4&gt;&lt;s5&gt;Celsius&lt;/s5&gt;&lt;/c4&gt; instance from a &lt;c6&gt;&lt;s7&gt;Double&lt;/s7&gt;&lt;/c6&gt; value that is already in the Celsius scale:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに上の&lt;a2&gt;&lt;s3&gt;初期化パラメータ&lt;/s3&gt;&lt;/a2&gt;からの&lt;c0&gt;&lt;s1&gt;Celsius&lt;/s1&gt;&lt;/c0&gt;例の拡張版があります、それは追加のイニシャライザを使って、既に摂氏尺度である&lt;c6&gt;&lt;s7&gt;Double&lt;/s7&gt;&lt;/c6&gt;値から新しい&lt;c4&gt;&lt;s5&gt;Celsius&lt;/s5&gt;&lt;/c4&gt;インスタンスを作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an extension of the &lt;c0&gt;&lt;s1&gt;Stack&lt;/s1&gt;&lt;/c0&gt; type from &lt;a2&gt;&lt;s3&gt;Generic Types&lt;/s3&gt;&lt;/a2&gt; above that adds conformance to the &lt;c4&gt;&lt;s5&gt;SuffixableContainer&lt;/s5&gt;&lt;/c4&gt; protocol:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに、上の&lt;a2&gt;&lt;s3&gt;Generic Types&lt;/s3&gt;&lt;/a2&gt;からの&lt;c0&gt;Stack&lt;/c0&gt;型の拡張があります、それは&lt;c4&gt;&lt;s5&gt;SuffixableContainer&lt;/s5&gt;&lt;/c4&gt;プロトコルへの準拠を加えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s an implementation of a class that adopts and conforms to the &lt;c0&gt;&lt;s1&gt;RandomNumberGenerator&lt;/s1&gt;&lt;/c0&gt; protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;RandomNumberGenerator&lt;/s1&gt;&lt;/c0&gt;プロトコルを採用して準拠するクラスの実施が、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s another example, for a function with no parameters or return value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もう１つの例がここにあります、パラメータおよび戻り値のないある関数です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how &lt;c0&gt;&lt;s1&gt;DiceGameTracker&lt;/s1&gt;&lt;/c0&gt; looks in action:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>動作中の&lt;c0&gt;&lt;s1&gt;DiceGameTracker&lt;/s1&gt;&lt;/c0&gt;がどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how &lt;c0&gt;&lt;s1&gt;stackOfStrings&lt;/s1&gt;&lt;/c0&gt; looks after pushing these four values on to the stack:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの４つの値をそのスタックにプッシュした後で&lt;c0&gt;&lt;s1&gt;stackOfStrings&lt;/s1&gt;&lt;/c0&gt;がどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how bit shifting looks in Swift code:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビットシフトがスウィフトコードにおいてどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how phase 1 looks for an initialization call for a hypothetical subclass and superclass:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第１段階がある仮定のサブクラスとスーパークラスのための初期化呼び出しを捜す方法がここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how phase 2 looks for the same initialization call:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第２段階が同じ初期化呼び出しを捜す方法は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how the &lt;c0&gt;&lt;s1&gt;Dice&lt;/s1&gt;&lt;/c0&gt; class can be used to create a six-sided dice with a &lt;c2&gt;&lt;s3&gt;LinearCongruentialGenerator&lt;/s3&gt;&lt;/c2&gt; instance as its random number generator:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Dice&lt;/s1&gt;&lt;/c0&gt;クラスが、６面のさいころをつくるためにその乱数生成器として&lt;c2&gt;&lt;s3&gt;LinearCongruentialGenerator&lt;/s3&gt;&lt;/c2&gt;インスタンスをつかってどのように使われることができるかが、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how the &lt;c0&gt;&lt;s1&gt;allItemsMatch(_:_:)&lt;/s1&gt;&lt;/c0&gt; function looks in action:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>動作中の&lt;c0&gt;&lt;s1&gt;allItemsMatch(_:_:)&lt;/s1&gt;&lt;/c0&gt;関数がどのように見えるかが、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how the &lt;c0&gt;&lt;s1&gt;isTop(_:)&lt;/s1&gt;&lt;/c0&gt; method looks in action:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>動作中の&lt;c0&gt;&lt;s1&gt;isTop(_:)&lt;/s1&gt;&lt;/c0&gt;メソッドがどのように見えるかが、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how the bits inside an &lt;c0&gt;&lt;s1&gt;Int8&lt;/s1&gt;&lt;/c0&gt; look for the number &lt;c2&gt;&lt;s3&gt;-4&lt;/s3&gt;&lt;/c2&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Int8&lt;/s1&gt;&lt;/c0&gt;内のビットが数&lt;c2&gt;&lt;s3&gt;-4&lt;/s3&gt;&lt;/c2&gt;に対してどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how the bits inside an &lt;c3&gt;&lt;s4&gt;Int8&lt;/s4&gt;&lt;/c3&gt; look for the number &lt;c5&gt;&lt;s6&gt;4&lt;/s6&gt;&lt;/c5&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c3&gt;&lt;s4&gt;Int8&lt;/s4&gt;&lt;/c3&gt;内のビットが数&lt;c5&gt;&lt;s6&gt;4&lt;/s6&gt;&lt;/c5&gt;に対してどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how the cycle looks:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>循環がどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how the first lines compare:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の行がどのくらい似ているかが、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how the method looks:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どのようにそのメソッドが見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how the references look now that you’ve linked the two instances together:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが２つのインスタンスを結びつけた今、参照がどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how the references look with the capture list in place:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>捕獲リストで適切にされた参照がどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how the references look, now that you’ve linked the two instances:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが２つのインスタンスを結んだ今、これらの参照がどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how the remainder operator works.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに剰余演算子が機能する方法があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how the stack looks after popping its top value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スタックがその一番上の値をポップした後にどう見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how the strong references look after creating and assigning these two instances.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの２つのインスタンスの作成と代入の後に強い参照がどのように見えるかが、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how the strong references look after you link the two instances together:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが２つのインスタンスを結びつけた後に強い参照がどのように見えるかが、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how the strong references look after you set the &lt;c0&gt;&lt;s1&gt;john&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;unit4A&lt;/s3&gt;&lt;/c2&gt; variables to &lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが&lt;c0&gt;&lt;s1&gt;john&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;unit4A&lt;/s3&gt;&lt;/c2&gt;変数を&lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;に設定したあと、強い参照がどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how to write a nongeneric version of a stack, in this case for a stack of &lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt; values:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スタックの非総称体版を書く方法がここにあります、これは&lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt;値のスタックの場合です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how two-phase initialization plays out, based on the four safety checks above:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２段階初期化が、上の４つの安全点検に基づいて最後までやり終える方法がここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how you call a type method on a class called &lt;c0&gt;&lt;s1&gt;SomeClass&lt;/s1&gt;&lt;/c0&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが型メソッドを&lt;c0&gt;&lt;s1&gt;SomeClass&lt;/s1&gt;&lt;/c0&gt;と呼ばれるクラスの上で呼び出す方法がここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how you can use the &lt;c0&gt;&lt;s1&gt;map(_:)&lt;/s1&gt;&lt;/c0&gt; method with a trailing closure to convert an array of &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt; values into an array of &lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt; values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに、あなたが&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;値の配列を&lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt;値の配列に変えるために後付クロージャとともに&lt;c0&gt;&lt;s1&gt;map(_:)&lt;/s1&gt;&lt;/c0&gt;メソッドをどのように使用できるかがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how you might expect a generic version of &lt;c0&gt;&lt;s1&gt;findIndex(ofString:in:)&lt;/s1&gt;&lt;/c0&gt;, called &lt;c2&gt;&lt;s3&gt;findIndex(of:in:)&lt;/s3&gt;&lt;/c2&gt;, to be written.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが予想する&lt;c0&gt;&lt;s1&gt;findIndex(ofString:in:)&lt;/s1&gt;&lt;/c0&gt;の総称体版、&lt;c2&gt;&lt;s3&gt;findIndex(of:in:)&lt;/s3&gt;&lt;/c2&gt;と呼ばれるものが書かれる方法はここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how you use the &lt;c0&gt;&lt;s1&gt;HTMLElement&lt;/s1&gt;&lt;/c0&gt; class to create and print a new instance:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが新しいインスタンスを作成して出力するために&lt;c0&gt;&lt;s1&gt;HTMLElement&lt;/s1&gt;&lt;/c0&gt;クラスを使用する方法は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how you write that:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがそれをどう書くかここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s how you write the &lt;c4&gt;&lt;s5&gt;HTMLElement&lt;/s5&gt;&lt;/c4&gt; class to avoid the cycle:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに、あなたが&lt;c4&gt;&lt;s5&gt;HTMLElement&lt;/s5&gt;&lt;/c4&gt;クラスを循環を避けるように書く方法があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s the &lt;e0&gt;Snakes and Ladders&lt;/e0&gt; example again, written as a &lt;c1&gt;&lt;s2&gt;repeat&lt;/s2&gt;&lt;/c1&gt;-&lt;c3&gt;&lt;s4&gt;while&lt;/s4&gt;&lt;/c3&gt; loop rather than a &lt;c5&gt;&lt;s6&gt;while&lt;/s6&gt;&lt;/c5&gt; loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここに再び&lt;e0&gt;「ヘビとはしご」&lt;/e0&gt;の例があります、それは&lt;c1&gt;&lt;s2&gt;repeat&lt;/s2&gt;&lt;/c1&gt;-&lt;c3&gt;&lt;s4&gt;while&lt;/s4&gt;&lt;/c3&gt;ループとして書かれます、&lt;c5&gt;&lt;s6&gt;while&lt;/s6&gt;&lt;/c5&gt;ループではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s the general form of a &lt;c0&gt;&lt;s1&gt;repeat&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;while&lt;/s3&gt;&lt;/c2&gt; loop:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;repeat&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;while&lt;/s3&gt;&lt;/c2&gt;ループの一般的な形式は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s the general form of a &lt;c0&gt;&lt;s1&gt;while&lt;/s1&gt;&lt;/c0&gt; loop:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;while&lt;/s1&gt;&lt;/c0&gt;ループの一般的な形式は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here’s the initial array to be sorted:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>分類される最初の配列は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hexadecimal floating-point literals consist of a &lt;c0&gt;&lt;s1&gt;0x&lt;/s1&gt;&lt;/c0&gt; prefix, followed by an optional hexadecimal fraction, followed by a hexadecimal exponent.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>16進の浮動小数点リテラルは、&lt;c0&gt;&lt;s1&gt;0x&lt;/s1&gt;&lt;/c0&gt;接頭辞、続けて任意の16進の小数部、それに続く16進の指数から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hiding type information is useful at boundaries between a module and code that calls into the module, because the underlying type of the return value can remain private.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型情報を隠すことは、あるモジュールとモジュールへと呼び出しをするコードとの間の境界で役立ちます、なぜなら戻り値のその基礎をなす型は、プライベートのままであることが可能だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Higher-precedence operators are evaluated before lower-precedence ones.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より高い優先順位の演算子は、より低い優先順位のもの前に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Horizontal tab (&lt;c0&gt;&lt;s1&gt;\t&lt;/s1&gt;&lt;/c0&gt;)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>水平タブ（&lt;c0&gt;&lt;s1&gt;\t&lt;/s1&gt;&lt;/c0&gt;）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How ARC Works</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ARCは、どのように働きますか</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How Deinitialization Works</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デイニシャライズはどのように働くか</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How to Read the Grammar</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この文法を読む方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, &lt;c7&gt;&lt;s8&gt;(a:&lt;/s8&gt; &lt;s9&gt;10,&lt;/s9&gt; &lt;s10&gt;b:&lt;/s10&gt; &lt;s11&gt;(a:&lt;/s11&gt; &lt;s12&gt;1,&lt;/s12&gt; &lt;s13&gt;x:&lt;/s13&gt; &lt;s14&gt;2))&lt;/s14&gt;&lt;/c7&gt; is valid—although &lt;c15&gt;&lt;s16&gt;a&lt;/s16&gt;&lt;/c15&gt; appears twice, it appears once in the outer tuple and once in the inner tuple.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、&lt;c7&gt;&lt;s8&gt;(a:&lt;/s8&gt; &lt;s9&gt;10,&lt;/s9&gt; &lt;s10&gt;b:&lt;/s10&gt; &lt;s11&gt;(a:&lt;/s11&gt; &lt;s12&gt;1,&lt;/s12&gt; &lt;s13&gt;x:&lt;/s13&gt; &lt;s14&gt;2))&lt;/s14&gt;&lt;/c7&gt;は有効です — もっとも&lt;c15&gt;&lt;s16&gt;a&lt;/s16&gt;&lt;/c15&gt;が二度現れますが、それは一度だけ外側タプルに、そして一度だけ内側タプルに現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, Swift structures and classes are much closer in functionality than in other languages, and much of this chapter describes functionality that applies to instances of &lt;e1&gt;either&lt;/e1&gt; a class or a structure type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、スウィフトの構造体とクラスは他の言語においてよりも機能性において非常に近いものです、したがってこの章の多くはクラスまたは構造体型の&lt;e1&gt;両方の&lt;/e1&gt;インスタンスに適用される機能性を記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, a method marked with the &lt;c4&gt;&lt;s5&gt;objc&lt;/s5&gt;&lt;/c4&gt; attribute can override a method marked with the &lt;c6&gt;&lt;s7&gt;nonobjc&lt;/s7&gt;&lt;/c6&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、&lt;c4&gt;&lt;s5&gt;objc&lt;/s5&gt;&lt;/c4&gt;属性で印されるメソッドは&lt;c6&gt;&lt;s7&gt;nonobjc&lt;/s7&gt;&lt;/c6&gt;属性で印されるメソッドをオーバーライドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, a unit test target can access any internal entity, if you mark the import declaration for a product module with the &lt;c0&gt;&lt;s1&gt;@testable&lt;/s1&gt;&lt;/c0&gt; attribute and compile that product module with testing enabled.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、あなたが製品モジュールのためのインポート宣言を&lt;c0&gt;&lt;s1&gt;@testable&lt;/s1&gt;&lt;/c0&gt;属性で印して、その製品モジュールをテスト可能な状態にコンパイルするならば、ユニットテストターゲットはあらゆる内部実在にアクセス可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, a value of a protocol type doesn’t conform to that protocol; the value returned by &lt;c6&gt;&lt;s7&gt;protoFlip(_:)&lt;/s7&gt;&lt;/c6&gt; doesn’t conform to &lt;c8&gt;&lt;s9&gt;Shape&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、あるプロトコル型からなるある値は、そのプロトコルに準拠しません；&lt;c6&gt;&lt;s7&gt;protoFlip(_:)&lt;/s7&gt;&lt;/c6&gt;によって返される値は、&lt;c8&gt;&lt;s9&gt;Shape&lt;/s9&gt;&lt;/c8&gt;に準拠しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, adding parentheses around a type doesn’t have any effect.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>けれども、ある型の周りに丸括弧を加えることは全く影響はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, at the point that they’re stored in the &lt;c6&gt;&lt;s7&gt;objectWithArea&lt;/s7&gt;&lt;/c6&gt; constant, they’re only known to be of type &lt;c8&gt;&lt;s9&gt;HasArea&lt;/s9&gt;&lt;/c8&gt;, and so only their &lt;c10&gt;&lt;s11&gt;area&lt;/s11&gt;&lt;/c10&gt; property can be accessed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、それらが定数の&lt;c6&gt;&lt;s7&gt;objectWithArea&lt;/s7&gt;&lt;/c6&gt;に格納される時点で、それらは型&lt;c8&gt;&lt;s9&gt;HasArea&lt;/s9&gt;&lt;/c8&gt;であるということを知られているだけです、なので、それらの&lt;c10&gt;&lt;s11&gt;area&lt;/s11&gt;&lt;/c10&gt;プロパティだけがアクセスされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, avoid using keywords as names unless you have absolutely no choice.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、あなたに選択が全くない場合を除き、キーワードをなんらかの名前として使用することを避けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, because &lt;c2&gt;&lt;s3&gt;asHTML&lt;/s3&gt;&lt;/c2&gt; is a closure property rather than an instance method, you can replace the default value of the &lt;c4&gt;&lt;s5&gt;asHTML&lt;/s5&gt;&lt;/c4&gt; property with a custom closure, if you want to change the HTML rendering for a particular HTML element.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、&lt;c2&gt;&lt;s3&gt;asHTML&lt;/s3&gt;&lt;/c2&gt;はインスタンスメソッドではなくクロージャプロパティであるので、あなたが特定のHTML要素に対してHTML解釈を変更したいならば、あなたはあつらえのクロージャで&lt;c4&gt;&lt;s5&gt;asHTML&lt;/s5&gt;&lt;/c4&gt;プロパティの省略時の値を置き替えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, because it’s called with a string constant, you can see that the initializer won’t fail, so no runtime error can occur in this case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、それは文字列定数で呼び出されるので、あなたはこのイニシャライザが失敗することはないと分かります、それで実行時エラーはこの場合には起こりえません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, because of Swift’s type inference, you don’t have to write the type of the set’s elements if you’re initializing it with an array literal that contains values of just one type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、スウィフトのもつ型推論のために、あなたは集合の持つ要素それらの型を書くことは、あなたがそれをただ１つの型だけの値それらを含む配列リテラルを使って初期化しているならば、必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, because the closure refers to &lt;c2&gt;&lt;s3&gt;self&lt;/s3&gt;&lt;/c2&gt; within its body (as a way to reference &lt;c4&gt;&lt;s5&gt;self.name&lt;/s5&gt;&lt;/c4&gt; and &lt;c6&gt;&lt;s7&gt;self.text&lt;/s7&gt;&lt;/c6&gt;), the closure &lt;e8&gt;captures&lt;/e8&gt; self, which means that it holds a strong reference back to the &lt;c9&gt;&lt;s10&gt;HTMLElement&lt;/s10&gt;&lt;/c9&gt; instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、クロージャがその本文内で&lt;c2&gt;&lt;s3&gt;self&lt;/s3&gt;&lt;/c2&gt;に言及する（&lt;c4&gt;&lt;s5&gt;self.name&lt;/s5&gt;&lt;/c4&gt;と&lt;c6&gt;&lt;s7&gt;self.text&lt;/s7&gt;&lt;/c6&gt;を参照する方法として）ので、クロージャはselfを&lt;e8&gt;捕獲&lt;/e8&gt;します、それは、今度は逆にそれが&lt;c9&gt;&lt;s10&gt;HTMLElement&lt;/s10&gt;&lt;/c9&gt;インスタンスへの強い参照を保持することを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, because they are separate instances, setting the width of &lt;c9&gt;&lt;s10&gt;cinema&lt;/s10&gt;&lt;/c9&gt; to &lt;c11&gt;&lt;s12&gt;2048&lt;/s12&gt;&lt;/c11&gt; doesn’t affect the width stored in &lt;c13&gt;&lt;s14&gt;hd&lt;/s14&gt;&lt;/c13&gt;, as shown in the figure below:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、それらが別々のインスタンスであるので、&lt;c9&gt;&lt;s10&gt;cinema&lt;/s10&gt;&lt;/c9&gt;の幅を&lt;c11&gt;&lt;s12&gt;2048&lt;/s12&gt;&lt;/c11&gt;に設定することは&lt;c13&gt;&lt;s14&gt;hd&lt;/s14&gt;&lt;/c13&gt;に格納される幅に影響を及ぼしません、下の図で示されるように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, before you learn how to break a strong reference cycle with a closure capture list, it’s useful to understand how such a cycle can be caused.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、あなたがクロージャ捕獲リストで強い参照循環を壊す方法を学ぶ前に、そのような循環がどのように引き起こされることがありえるか理解することは役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, before you learn how to resolve a strong reference cycle, it’s useful to understand how such a cycle is caused.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、あなたが強い参照循環を解消する方法を学ぶ前に、そのような循環がどのように引き起こされるか理解することは役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, code outside the module might still be able to interact with the declaration’s symbol by using runtime behavior.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、モジュール外部のコードは、依然として宣言のシンボルと実行時挙動を使うことによって相互作用可能かもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, constant type properties of a class are an exception: &lt;c6&gt;&lt;s7&gt;static&lt;/s7&gt;&lt;/c6&gt; has its normal, nonclass meaning there because you can’t write &lt;c8&gt;&lt;s9&gt;class&lt;/s9&gt;&lt;/c8&gt; or &lt;c10&gt;&lt;s11&gt;final&lt;/s11&gt;&lt;/c10&gt; on those declarations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、クラスの定数型プロパティは例外です：&lt;c6&gt;&lt;s7&gt;static&lt;/s7&gt;&lt;/c6&gt;はそれの通常の、非クラスの意味をそこで持ちません、なぜならあなたは&lt;c8&gt;&lt;s9&gt;class&lt;/s9&gt;&lt;/c8&gt;または&lt;c10&gt;&lt;s11&gt;final&lt;/s11&gt;&lt;/c10&gt;をそれらの宣言上で書けないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, for the inline closure expression, the parameters and return type are written &lt;e9&gt;inside&lt;/e9&gt; the curly braces, not outside of them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、行内クロージャ式のために、パラメータと戻り型は、波括弧の&lt;e9&gt;内側&lt;/e9&gt;に書かれます、その外側ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, functions and methods with no return type have an implicit return type of &lt;c0&gt;&lt;s1&gt;Void&lt;/s1&gt;&lt;/c0&gt;, as described in &lt;a2&gt;&lt;s3&gt;Functions Without Return Values&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、&lt;a2&gt;&lt;s3&gt;戻り値のない関数&lt;/s3&gt;&lt;/a2&gt;で記述されるように、戻り型のない関数やメソッドは、&lt;c0&gt;&lt;s1&gt;Void&lt;/s1&gt;&lt;/c0&gt;の暗黙の戻り型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if ARC were to deallocate an instance that was still in use, it would no longer be possible to access that instance’s properties, or call that instance’s methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、ARCがまだ使用中だったインスタンスの割り当て解除をすることになったならば、そのインスタンスのプロパティにアクセスすることや、そのインスタンスのメソッドを呼ぶことは、もはや可能でないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if multiple matches are possible, the first matching case is always used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、複数の適合が出来るならば、最初の適合するケース節が常に使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if you apply both a prefix and a postfix operator to the same operand, the postfix operator is applied first.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、あなたが接頭辞演算子と接尾辞演算子の両方を同じ演算数を適用したならば、接尾辞演算子が最初に適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if you iterate over the contents of this array, the items you receive back are typed as &lt;c6&gt;&lt;s7&gt;MediaItem&lt;/s7&gt;&lt;/c6&gt;, and not as &lt;c8&gt;&lt;s9&gt;Movie&lt;/s9&gt;&lt;/c8&gt; or &lt;c10&gt;&lt;s11&gt;Song&lt;/s11&gt;&lt;/c10&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、あなたがこの配列の内容上に繰り返すならば、あなたがそこから取り出す項目は、&lt;c6&gt;&lt;s7&gt;MediaItem&lt;/s7&gt;&lt;/c6&gt;型としてであって、&lt;c8&gt;&lt;s9&gt;Movie&lt;/s9&gt;&lt;/c8&gt;または&lt;c10&gt;&lt;s11&gt;Song&lt;/s11&gt;&lt;/c10&gt;ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if you need to modify the properties of your structure or enumeration within a particular method, you can opt in to &lt;e0&gt;mutating&lt;/e0&gt; behavior for that method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、あなたがある特定のメソッド内であなたの構造体または列挙のプロパティを修正する必要があるならば、あなたはそのメソッドのために&lt;e0&gt;可変&lt;/e0&gt;挙動を選ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if you pass &lt;c0&gt;&lt;s1&gt;oscar&lt;/s1&gt;&lt;/c0&gt; as the argument to &lt;c2&gt;&lt;s3&gt;shareHealth(with:)&lt;/s3&gt;&lt;/c2&gt;, there’s a conflict:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、あなたが&lt;c0&gt;&lt;s1&gt;oscar&lt;/s1&gt;&lt;/c0&gt;を引数として&lt;c2&gt;&lt;s3&gt;shareHealth(with:)&lt;/s3&gt;&lt;/c2&gt;に渡すならば、衝突が存在します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if you write whitespace at the beginning of a line in addition to what’s before the closing quotation marks, that whitespace &lt;e2&gt;is&lt;/e2&gt; included.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、あなたが終了引用符の前のものに加えて空白文字をある行の始まりで書くならば、その空白文字は含められ&lt;e2&gt;ます&lt;/e2&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, in a few cases ARC requires more information about the relationships between parts of your code in order to manage memory for you.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、２、３の場合には、ARCは、あなたのためにメモリを管理するために、あなたのコードの部分間の関係に関するより多くの情報を要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, initializers do not have an identifying function name before their parentheses in the way that functions and methods do.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、イニシャライザは、関数とメソッドがするように識別する関数名をその括弧の前に持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, instances of enumeration types have value semantics, which means they have a fixed layout in memory.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、列挙型のインスタンスは値意味論を持ちます、それは、それらがメモリにおいてある固定された配置を持つことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it is more convenient (and clearer in intent) for the &lt;c6&gt;&lt;s7&gt;init(center:size:)&lt;/s7&gt;&lt;/c6&gt; initializer to take advantage of an existing initializer that already provides exactly that functionality.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、すでに正確にその機能性を提供する既存のイニシャライザを利用するほうが、&lt;c6&gt;&lt;s7&gt;init(center:size:)&lt;/s7&gt;&lt;/c6&gt;イニシャライザにとってより便利です（そして意図においてより明白です）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it is not appropriate for an animal to have an empty string as the value of its &lt;c13&gt;&lt;s14&gt;species&lt;/s14&gt;&lt;/c13&gt; property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、ある動物にとってそれの&lt;c13&gt;&lt;s14&gt;species&lt;/s14&gt;&lt;/c13&gt;（種族）プロパティの値として空の文字列を持つことはふさわしくありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it is sometimes useful to write shorter versions of function-like constructs without a full declaration and name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、まるまる完全な宣言や名前なしに、関数のような構造物のより短いものをいろいろと書くことは、時々役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, its behavior in Swift for negative numbers means that, strictly speaking, it’s a remainder rather than a modulo operation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、スウィフトでの負数に対するそれの挙動は、それが、厳密に言って、剰余（remainder）であり、モジュロ（modulo）演算でないのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it’s important to understand where potential conflicts can occur, so you can avoid writing code that has conflicting access to memory.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、潜在的に衝突が起こり得るところを理解するのは重要です、そうすることであなたはメモリへのアクセスが衝突するコードを書くのを防止できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it’s possible to write code in which an instance of a class &lt;e0&gt;never&lt;/e0&gt; gets to a point where it has zero strong references.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、あるクラスのあるインスタンスが、強い参照を１つも持たない状態になることが&lt;e0&gt;決してない&lt;/e0&gt;コードを書くことは、可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it’s sometimes useful to be able to store values of other types alongside these case values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、他の型の値をこれらのケース節値の傍らに格納することができることは、時々役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it’s sometimes useful to enforce certain &lt;e4&gt;type constraints&lt;/e4&gt; on the types that can be used with generic functions and generic types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、総称体関数と総称体型で使われることができる型に、特定の&lt;e4&gt;型制約&lt;/e4&gt;を強制することは、時々役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, like all type aliases, &lt;c6&gt;&lt;s7&gt;Void&lt;/s7&gt;&lt;/c6&gt; is always a type—you can’t use it to write an empty tuple expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、すべての型エイリアスのように、&lt;c6&gt;&lt;s7&gt;Void&lt;/s7&gt;&lt;/c6&gt;は常にある型です—あなたはそれを使って空のタプル式を書くことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, loops and conditional statements can both use the &lt;c0&gt;&lt;s1&gt;break&lt;/s1&gt;&lt;/c0&gt; statement to end their execution prematurely.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、ループと条件文は、両方ともしかるべき時よりも早くそれらの実行を終えるために&lt;c0&gt;&lt;s1&gt;break&lt;/s1&gt;&lt;/c0&gt;文を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, multiple levels of optional chaining do not add more levels of optionality to the returned value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、オプショナル連鎖の複数の階層は、返された値にさらにオプショナルの階層を加えません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, not every string can be converted into an integer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、すべての文字列が、整数に変えられることができるというわけでありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, properties can also be associated with the type itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、プロパティはまた、型それ自体に結び付けられることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, rather than two class instances, this time it’s a class instance and a closure that are keeping each other alive.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし２つのクラスインスタンスではなく、今度は、それはお互いを生かし続けているクラスインスタンスとクロージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, remainder and multiplication have the &lt;e0&gt;same&lt;/e0&gt; precedence as each other.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、剰余と乗算は、互いに&lt;e0&gt;同じ&lt;/e0&gt;優先順位を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, semicolons &lt;e2&gt;are&lt;/e2&gt; required if you want to write multiple separate statements on a single line:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それにもかかわらず、セミコロンは必要と&lt;e2&gt;されます&lt;/e2&gt;、もしあなたが１つの行に複数の別々の文を書きたい場合には：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, superclass initializers &lt;e0&gt;are&lt;/e0&gt; automatically inherited if certain conditions are met.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、スーパークラスのイニシャライザは、決まった条件が満たされるならば、自動的に継承&lt;e0&gt;されます&lt;/e0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, that argument is now an inline closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、この引数は今では１つの行内クロージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, that property declaration can’t be implemented as a constant property or a read-only computed property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、そのプロパティ宣言は、定数プロパティまたは読み出し専用の計算プロパティとして実装されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the &lt;c0&gt;&lt;s1&gt;width&lt;/s1&gt;&lt;/c0&gt; property of the original &lt;c2&gt;&lt;s3&gt;hd&lt;/s3&gt;&lt;/c2&gt; instance still has the old value of &lt;c4&gt;&lt;s5&gt;1920&lt;/s5&gt;&lt;/c4&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、最初の&lt;c2&gt;&lt;s3&gt;hd&lt;/s3&gt;&lt;/c2&gt;インスタンスの&lt;c0&gt;&lt;s1&gt;width&lt;/s1&gt;&lt;/c0&gt;プロパティは、まだ&lt;c4&gt;&lt;s5&gt;1920&lt;/s5&gt;&lt;/c4&gt;の古い値を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the &lt;c2&gt;&lt;s3&gt;fatalError(_:file:line:)&lt;/s3&gt;&lt;/c2&gt; function always halts execution, regardless of optimization settings.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、&lt;c2&gt;&lt;s3&gt;fatalError(_:file:line:)&lt;/s3&gt;&lt;/c2&gt;関数は常に実行を停止します、最適化設定に関係なく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the &lt;c4&gt;&lt;s5&gt;&amp;&amp;&lt;/s5&gt;&lt;/c4&gt; and &lt;c6&gt;&lt;s7&gt;||&lt;/s7&gt;&lt;/c6&gt; operators still operate on only two values, so this is actually three smaller expressions chained together.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、&lt;c4&gt;&lt;s5&gt;&amp;&amp;&lt;/s5&gt;&lt;/c4&gt;と&lt;c6&gt;&lt;s7&gt;||&lt;/s7&gt;&lt;/c6&gt;演算子は依然として２つの値だけに作用します、なのでこれは実際のところ１つに繋がれた３つのより小さい式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the access level for the &lt;c4&gt;&lt;s5&gt;numberOfEdits&lt;/s5&gt;&lt;/c4&gt; property is marked with a &lt;c6&gt;&lt;s7&gt;private(set)&lt;/s7&gt;&lt;/c6&gt; modifier to indicate that the property’s getter still has the default access level of internal, but the property is settable only from within code that’s part of the &lt;c8&gt;&lt;s9&gt;TrackedString&lt;/s9&gt;&lt;/c8&gt; structure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、&lt;c4&gt;&lt;s5&gt;numberOfEdits&lt;/s5&gt;&lt;/c4&gt;プロパティのためのアクセス水準は、&lt;c6&gt;&lt;s7&gt;private(set)&lt;/s7&gt;&lt;/c6&gt;修飾子を使って印を付けられて、そのプロパティの持つゲッターが依然として省略時のアクセス水準の内部を持つ、しかしプロパティは&lt;c8&gt;&lt;s9&gt;TrackedString&lt;/s9&gt;&lt;/c8&gt;構造体の部分であるコード内からのみ設定可能であることを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the actual answer is &lt;c0&gt;&lt;s1&gt;17&lt;/s1&gt;&lt;/c0&gt;, not &lt;c2&gt;&lt;s3&gt;5&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、実際の答えは&lt;c0&gt;&lt;s1&gt;17&lt;/s1&gt;&lt;/c0&gt;です、&lt;c2&gt;&lt;s3&gt;5&lt;/s3&gt;&lt;/c2&gt;ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the alternative example below is valid:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、これに代わる以下の例は有効です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the conflicting access discussed here can happen on a single thread and &lt;e0&gt;doesn’t&lt;/e0&gt; involve concurrent or multithreaded code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、ここで議論するアクセス衝突は、単一スレッド上で起こることが可能で、並列またはマルチスレッドのコードを伴い&lt;e0&gt;ません&lt;/e0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the cost of that flexibility is that some operations aren’t possible on the returned values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、その柔軟性の対価は、いくつかの演算がその返される値の上で可能でないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the emergency override password is known, so the overall compound expression still evaluates to &lt;c8&gt;&lt;s9&gt;true&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、非常用解除パスワードは知られているので、複合式全体はなお&lt;c8&gt;&lt;s9&gt;true&lt;/s9&gt;&lt;/c8&gt;と評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the first line of &lt;c4&gt;&lt;s5&gt;swapTwoValues(_:_:)&lt;/s5&gt;&lt;/c4&gt; is slightly different from &lt;c6&gt;&lt;s7&gt;swapTwoInts(_:_:)&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、&lt;c4&gt;&lt;s5&gt;swapTwoValues(_:_:)&lt;/s5&gt;&lt;/c4&gt;の最初の行は、わずかに&lt;c6&gt;&lt;s7&gt;swapTwoInts(_:_:)&lt;/s7&gt;&lt;/c6&gt;と異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the function does not perform any safety checks on the array it is passed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、この関数は、それが渡される配列に関してどんな安全確認も実行しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the initializer for &lt;c4&gt;&lt;s5&gt;Country&lt;/s5&gt;&lt;/c4&gt; cannot pass &lt;c6&gt;&lt;s7&gt;self&lt;/s7&gt;&lt;/c6&gt; to the &lt;c8&gt;&lt;s9&gt;City&lt;/s9&gt;&lt;/c8&gt; initializer until a new &lt;c10&gt;&lt;s11&gt;Country&lt;/s11&gt;&lt;/c10&gt; instance is fully initialized, as described in &lt;a12&gt;&lt;s13&gt;Two-Phase Initialization&lt;/s13&gt;&lt;/a12&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、&lt;c4&gt;&lt;s5&gt;Country&lt;/s5&gt;&lt;/c4&gt;のためのイニシャライザは、&lt;c6&gt;&lt;s7&gt;self&lt;/s7&gt;&lt;/c6&gt;を&lt;c8&gt;&lt;s9&gt;City&lt;/s9&gt;&lt;/c8&gt;イニシャライザに渡すことが、新しい&lt;c10&gt;&lt;s11&gt;Country&lt;/s11&gt;&lt;/c10&gt;インスタンスが完全に初期化されるまでできません、&lt;a12&gt;&lt;s13&gt;２段階初期化&lt;/s13&gt;&lt;/a12&gt;で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the method is still able to use type casting to query the type of the underlying instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、このメソッドは依然として基盤インスタンスの型についてたずねるために型キャストを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the projected value is &lt;c6&gt;&lt;s7&gt;true&lt;/s7&gt;&lt;/c6&gt; after trying to store a number that’s too large, like 55.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、予測値は、55のような大きすぎる数を格納しようとする後は&lt;c6&gt;&lt;s7&gt;true&lt;/s7&gt;&lt;/c6&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the propagated error must be handled by &lt;e6&gt;some&lt;/e6&gt; surrounding scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、伝えられるエラーは取り囲んでいるスコープの&lt;e6&gt;何れか&lt;/e6&gt;によって処理される必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the read access to &lt;c4&gt;&lt;s5&gt;stepSize&lt;/s5&gt;&lt;/c4&gt; overlaps with the write access to &lt;c6&gt;&lt;s7&gt;number&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、&lt;c4&gt;&lt;s5&gt;stepSize&lt;/s5&gt;&lt;/c4&gt;に対する読み出しアクセスは&lt;c6&gt;&lt;s7&gt;number&lt;/s7&gt;&lt;/c6&gt;に対する書き込みアクセスとオーバーラップします（重なります）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the same letter can also be represented as a &lt;e13&gt;pair&lt;/e13&gt; of scalars—a standard letter &lt;c14&gt;&lt;s15&gt;e&lt;/s15&gt;&lt;/c14&gt; (&lt;c16&gt;&lt;s17&gt;LATIN&lt;/s17&gt; &lt;s18&gt;SMALL&lt;/s18&gt; &lt;s19&gt;LETTER&lt;/s19&gt; &lt;s20&gt;E&lt;/s20&gt;&lt;/c16&gt;, or &lt;c21&gt;&lt;s22&gt;U+0065&lt;/s22&gt;&lt;/c21&gt;), followed by the &lt;c23&gt;&lt;s24&gt;COMBINING&lt;/s24&gt; &lt;s25&gt;ACUTE&lt;/s25&gt; &lt;s26&gt;ACCENT&lt;/s26&gt;&lt;/c23&gt; scalar (&lt;c27&gt;&lt;s28&gt;U+0301&lt;/s28&gt;&lt;/c27&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、同じ文字はまた、&lt;e13&gt;一対&lt;/e13&gt;のスカラー ― 通常の文字&lt;c14&gt;&lt;s15&gt;e&lt;/s15&gt;&lt;/c14&gt;（&lt;c16&gt;&lt;s17&gt;LATIN&lt;/s17&gt; &lt;s18&gt;SMALL&lt;/s18&gt; &lt;s19&gt;LETTER&lt;/s19&gt; &lt;s20&gt;E&lt;/s20&gt;&lt;/c16&gt;、または&lt;c21&gt;&lt;s22&gt;U+0065&lt;/s22&gt;&lt;/c21&gt;）、それに続けて&lt;c23&gt;&lt;s24&gt;COMBINING&lt;/s24&gt; &lt;s25&gt;ACUTE&lt;/s25&gt; &lt;s26&gt;ACCENT&lt;/s26&gt;&lt;/c23&gt;スカラー（&lt;c27&gt;&lt;s28&gt;U+0301&lt;/s28&gt;&lt;/c27&gt;）として表わされることも出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the subclass must not be generic, and must not inherit from any generic classes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、サブクラスは総称体である必要はありません、そして何らかの総称体クラスから継承する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the value of &lt;c4&gt;&lt;s5&gt;john.residence.address&lt;/s5&gt;&lt;/c4&gt; is currently &lt;c6&gt;&lt;s7&gt;nil&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、&lt;c4&gt;&lt;s5&gt;john.residence.address&lt;/s5&gt;&lt;/c4&gt;の値は、現在は&lt;c6&gt;&lt;s7&gt;nil&lt;/s7&gt;&lt;/c6&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there are several ways to access memory, called &lt;e0&gt;long-term&lt;/e0&gt; accesses, that span the execution of other code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、メモリにアクセスするための幾つかの方法、&lt;e0&gt;長期&lt;/e0&gt;アクセスと呼ばれる、他のコードの実行の期間にまたがるいくつかのものがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there is a third scenario, in which &lt;e0&gt;both&lt;/e0&gt; properties should always have a value, and neither property should ever be &lt;c1&gt;&lt;s2&gt;nil&lt;/s2&gt;&lt;/c1&gt; once initialization is complete.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、第３の筋書きがあります、そこにおいて&lt;e0&gt;両方の&lt;/e0&gt;プロパティは常に値を持たなければなりません、そして一旦初期化が終了しているならば、どちらのプロパティも決して&lt;c1&gt;&lt;s2&gt;nil&lt;/s2&gt;&lt;/c1&gt;であってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there is an exception if the compilation condition includes a &lt;c0&gt;&lt;s1&gt;swift()&lt;/s1&gt;&lt;/c0&gt; platform condition: The statements are parsed only if the compiler’s version of Swift matches what is specified in the platform condition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、例外があります、それはコンパイル条件が&lt;c0&gt;&lt;s1&gt;swift()&lt;/s1&gt;&lt;/c0&gt;プラットホーム条件を含む場合です：文はスウィフトのコンパイラのバージョンがプラットホーム条件において指定されるものと合致する場合にのみ構文解析されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there is no harm in using the &lt;c7&gt;&lt;s8&gt;gameLoop&lt;/s8&gt;&lt;/c7&gt; label with the &lt;c9&gt;&lt;s10&gt;continue&lt;/s10&gt;&lt;/c9&gt; statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、&lt;c7&gt;&lt;s8&gt;gameLoop&lt;/s8&gt;&lt;/c7&gt;ラベルを&lt;c9&gt;&lt;s10&gt;continue&lt;/s10&gt;&lt;/c9&gt;文で使用することに害はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there’s an important limitation to this approach: The flipped result exposes the exact generic types that were used to create it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、重大な限界がこの取り組みにはあります：その裏返された結果は、それを作成するのに使われた正確な総称体型を露出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, they can contain other string literals.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、それは、他の文字列リテラルを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this code always triggers a runtime error when &lt;c8&gt;&lt;s9&gt;residence&lt;/s9&gt;&lt;/c8&gt; is &lt;c10&gt;&lt;s11&gt;nil&lt;/s11&gt;&lt;/c10&gt;, as illustrated above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、&lt;c8&gt;&lt;s9&gt;residence&lt;/s9&gt;&lt;/c8&gt;が&lt;c10&gt;&lt;s11&gt;nilの&lt;/s11&gt;&lt;/c10&gt;とき、上で説明するように、このコードは常に実行時エラーの引き金となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this doesn’t mean that you have to specify the type of every constant and variable that you declare.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、これはあなたがすべてのあなたが宣言する定数と変数の型を指定しなければならないことを意味しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this is a rather long-winded way to write what is essentially a single-expression function (&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt; &lt;s2&gt;&gt;&lt;/s2&gt; &lt;s3&gt;b&lt;/s3&gt;&lt;/c0&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、これは本質的に単一式の関数（&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt; &lt;s2&gt;&gt;&lt;/s2&gt; &lt;s3&gt;b&lt;/s3&gt;&lt;/c0&gt;）であるものを書くには、相当に長たらしい方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this means that they are not exactly the same as in C-based languages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、これはCに基づく言語とそれらが厳密には同じでないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, type properties are queried and set on the &lt;e0&gt;type&lt;/e0&gt;, not on an instance of that type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、型プロパティは、その型のインスタンスにではなく、その&lt;e0&gt;型&lt;/e0&gt;に問い合わせられ設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, unlike functions, subscripts can’t use in-out parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、関数とは違い、添え字はin-outパラメータを使用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, unlike strings, you use substrings for only a short amount of time while performing actions on a string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、文字列と違い、ある文字列に関して様々な行為を行う間の短いある程度の時間だけのために、あなたは下位文字列を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, unlike the value in that example, &lt;c6&gt;&lt;s7&gt;flip(_:)&lt;/s7&gt;&lt;/c6&gt; and &lt;c8&gt;&lt;s9&gt;join(_:_:)&lt;/s9&gt;&lt;/c8&gt; wrap the underlying types that the generic shape operations return in an opaque return type, which prevents those types from being visible.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、その例での値と違い、&lt;c6&gt;&lt;s7&gt;flip(_:)&lt;/s7&gt;&lt;/c6&gt;と&lt;c8&gt;&lt;s9&gt;join(_:_:)&lt;/s9&gt;&lt;/c8&gt;は基礎をなす型それらをラップします、それらは総称体の形状演算が不透明戻り型において返すものです、それはこれらの型が可視であるのを防ぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, using them to enforce valid data and state causes your app to terminate more predictably if an invalid state occurs, and helps make the problem easier to debug.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、それらを使って有効なデータと状態を遵守させることは、あなたのアプリに不正な状態が生じる場合により予測のつく結びとなるようにします、そして問題をより簡単にデバッグする助けとなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, when &lt;c0&gt;&lt;s1&gt;oneAndTwo&lt;/s1&gt;&lt;/c0&gt; is used in a generic context or as an instance of the &lt;c2&gt;&lt;s3&gt;Loggable&lt;/s3&gt;&lt;/c2&gt; protocol, the specialized version isn’t used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、&lt;c0&gt;&lt;s1&gt;oneAndTwo&lt;/s1&gt;&lt;/c0&gt;がある総称体文脈においてまたは&lt;c2&gt;&lt;s3&gt;Loggable&lt;/s3&gt;&lt;/c2&gt;プロトコルのインスタンスとして使われる場合、この特殊化版は使用されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, when the tuples’ first elements are the same, their second elements &lt;e14&gt;are&lt;/e14&gt; compared—this is what happens on the second and third line.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、タプルのもつ最初の要素が同じ場合、２番目の要素は比較&lt;e14&gt;されます&lt;/e14&gt; — これが２番目と３番目の行で起こることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, when there isn’t a meaningful relationship between them, it’s traditional to name them using single letters such as &lt;c11&gt;&lt;s12&gt;T&lt;/s12&gt;&lt;/c11&gt;, &lt;c13&gt;&lt;s14&gt;U&lt;/s14&gt;&lt;/c13&gt;, and &lt;c15&gt;&lt;s16&gt;V&lt;/s16&gt;&lt;/c15&gt;, such as &lt;c17&gt;&lt;s18&gt;T&lt;/s18&gt;&lt;/c17&gt; in the &lt;c19&gt;&lt;s20&gt;swapTwoValues(_:_:)&lt;/s20&gt;&lt;/c19&gt; function above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、意味がある関係がそれらの間に無かった時、&lt;c11&gt;&lt;s12&gt;T&lt;/s12&gt;&lt;/c11&gt;、&lt;c13&gt;&lt;s14&gt;U&lt;/s14&gt;&lt;/c13&gt;、そして&lt;c15&gt;&lt;s16&gt;V&lt;/s16&gt;&lt;/c15&gt;などの一文字を使ってそれらに名前をつけるのが伝統的です、例えば上の&lt;c19&gt;&lt;s20&gt;swapTwoValues(_:_:)&lt;/s20&gt;&lt;/c19&gt;関数における&lt;c17&gt;&lt;s18&gt;T&lt;/s18&gt;&lt;/c17&gt;のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, when you are working with your own resources, you might need to perform some additional cleanup yourself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、あなたがあなた独自のリソース（計算資源）を扱うとき、あなたは追加のいくらかの掃除をあなた自身でする必要があるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, when you specifically want an overflow condition to truncate the number of available bits, you can opt in to this behavior rather than triggering an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、あなたがに利用できるビットの数を切り詰めるために特にオーバフロー条件を望むとき、あなたはエラーを引き起こすのではなくこの挙動を選ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, with ARC, values are deallocated as soon as their last strong reference is removed, making weak references unsuitable for such a purpose.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、ARCでは、値はその最後の強い参照が削除されるやいなや割り当て解除されて、弱い参照をそのような目的のためにふさわしくないものにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, you call type methods on the type, not on an instance of that type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、あなたは型のメソッドを型の上で呼び出します、その型のインスタンスの上ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, you can also define &lt;e0&gt;computed variables&lt;/e0&gt; and define observers for stored variables, in either a global or local scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、あなたはまた、&lt;e0&gt;計算変数&lt;/e0&gt;を定義すること、そして格納変数のためにオブザーバーを定義することが、グローバルなまたはローカルなスコープのどちらにおいても可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, you can downcast from a protocol type to an underlying type in the same way you can downcast from a superclass to a subclass, as discussed in &lt;a15&gt;&lt;s16&gt;Downcasting&lt;/s16&gt;&lt;/a15&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、あなたはあるプロトコル型からある基礎をなす型へとダウンキャストすることが、あなたがスーパークラスからサブクラスへとダウンキャスト出来るのと同じ方法で可能です、&lt;a15&gt;&lt;s16&gt;ダウンキャスト&lt;/s16&gt;&lt;/a15&gt;で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, you can provide explicit argument labels using the same syntax that functions, methods, and initializers use.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、あなたは明示的に引数ラベルを提供することが、関数、メソッド、およびイニシャライザが使うのと同じ構文を使うことで可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, you can still change &lt;c5&gt;&lt;s6&gt;tenEighty.frameRate&lt;/s6&gt;&lt;/c5&gt; and &lt;c7&gt;&lt;s8&gt;alsoTenEighty.frameRate&lt;/s8&gt;&lt;/c7&gt; because the values of the &lt;c9&gt;&lt;s10&gt;tenEighty&lt;/s10&gt;&lt;/c9&gt; and &lt;c11&gt;&lt;s12&gt;alsoTenEighty&lt;/s12&gt;&lt;/c11&gt; constants themselves don’t actually change.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、あなたはそれでもなお&lt;c5&gt;&lt;s6&gt;tenEighty.frameRate&lt;/s6&gt;&lt;/c5&gt;と&lt;c7&gt;&lt;s8&gt;alsoTenEighty.frameRate&lt;/s8&gt;&lt;/c7&gt;を変更することができます、なぜなら&lt;c9&gt;&lt;s10&gt;tenEighty&lt;/s10&gt;&lt;/c9&gt;および&lt;c11&gt;&lt;s12&gt;alsoTenEighty&lt;/s12&gt;&lt;/c11&gt;定数それら自身の値は実のところ変わらないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, you can’t construct an instance of a protocol, because protocols do not actually provide the implementations for the requirements they specify.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、あなたはプロトコルからインスタンスを造ることができません、なぜならプロトコルは実際にはそれらが指定する要件に対する実装を用意しないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, you don’t always have to write the type explicitly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、あなたは必ずしも明確に型を書く必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Identical to (&lt;c0&gt;&lt;s1&gt;===&lt;/s1&gt;&lt;/c0&gt;)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同一である（&lt;c0&gt;&lt;s1&gt;===&lt;/s1&gt;&lt;/c0&gt;）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Identifier Pattern</seg>
      </tuv>
      <tuv lang="JA">
        <seg>識別子パターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Identifiers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>識別子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Identifiers patterns within a value-binding pattern bind new named variables or constants to their matching values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある値束縛パターン内の複数の識別子パターンは、複数の新しい名前をつけられた変数または定数を、それらがマッチしている値に縛りつけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Identity Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同一性演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;c0&gt;&lt;s1&gt;someThrowingFunction()&lt;/s1&gt;&lt;/c0&gt; throws an error, the value of &lt;c2&gt;&lt;s3&gt;x&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;y&lt;/s5&gt;&lt;/c4&gt; is &lt;c6&gt;&lt;s7&gt;nil&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;someThrowingFunction()&lt;/s1&gt;&lt;/c0&gt;がエラーをスローするならば、&lt;c2&gt;&lt;s3&gt;x&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;y&lt;/s5&gt;&lt;/c4&gt;の値は&lt;c6&gt;&lt;s7&gt;nil&lt;/s7&gt;&lt;/c6&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;c0&gt;&lt;s1&gt;tenEighty&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;alsoTenEighty&lt;/s3&gt;&lt;/c2&gt; were far apart in your program’s code, it could be difficult to find all the ways that the video mode is changed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;tenEighty&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;alsoTenEighty&lt;/s3&gt;&lt;/c2&gt;があなたのプログラムのコードの中で離ればなれになってしまったら、ビデオモードが変更される全ての道筋を見つけるのは難しくなるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;c0&gt;&lt;s1&gt;true&lt;/s1&gt;&lt;/c0&gt;, execution continues to step 2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;true&lt;/s1&gt;&lt;/c0&gt;ならば、実行はステップ２に続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;c0&gt;&lt;s1&gt;true&lt;/s1&gt;&lt;/c0&gt;, execution returns to step 1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;true&lt;/s1&gt;&lt;/c0&gt;ならば、実行はステップ１に戻ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;c2&gt;&lt;s3&gt;false&lt;/s3&gt;&lt;/c2&gt;, the program is finished executing the &lt;c4&gt;&lt;s5&gt;repeat&lt;/s5&gt;&lt;/c4&gt;-&lt;c6&gt;&lt;s7&gt;while&lt;/s7&gt;&lt;/c6&gt; statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;false&lt;/s3&gt;&lt;/c2&gt;ならば、プログラムは&lt;c4&gt;&lt;s5&gt;repeat&lt;/s5&gt;&lt;/c4&gt;-&lt;c6&gt;&lt;s7&gt;while&lt;/s7&gt;&lt;/c6&gt;文の実行を終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;c2&gt;&lt;s3&gt;false&lt;/s3&gt;&lt;/c2&gt;, the program is finished executing the &lt;c4&gt;&lt;s5&gt;while&lt;/s5&gt;&lt;/c4&gt; statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;false&lt;/s3&gt;&lt;/c2&gt;ならば、プログラムは&lt;c4&gt;&lt;s5&gt;while&lt;/s5&gt;&lt;/c4&gt;文の実行を終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;c4&gt;&lt;s5&gt;a&lt;/s5&gt;&lt;/c4&gt; and &lt;c6&gt;&lt;s7&gt;b&lt;/s7&gt;&lt;/c6&gt; aren’t of the same type, it isn’t possible to swap their values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;a&lt;/s5&gt;&lt;/c4&gt;と&lt;c6&gt;&lt;s7&gt;b&lt;/s7&gt;&lt;/c6&gt;が同じ型でないならば、それらの値を交換することは可能ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;c8&gt;&lt;s9&gt;count&lt;/s9&gt;&lt;/c8&gt; is already zero, the method returns &lt;c10&gt;&lt;s11&gt;0&lt;/s11&gt;&lt;/c10&gt; to indicate that no further counting should take place.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c8&gt;&lt;s9&gt;count&lt;/s9&gt;&lt;/c8&gt;がすでにゼロであるならば、メソッドは&lt;c10&gt;&lt;s11&gt;0&lt;/s11&gt;&lt;/c10&gt;を返して、これ以上数えることは必要ないことを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;c8&gt;&lt;s9&gt;square&lt;/s9&gt;&lt;/c8&gt; is valid, the value stored in &lt;c10&gt;&lt;s11&gt;board[square]&lt;/s11&gt;&lt;/c10&gt; is added to the current &lt;c12&gt;&lt;s13&gt;square&lt;/s13&gt;&lt;/c12&gt; value to move the player up or down any ladders or snakes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c8&gt;&lt;s9&gt;square&lt;/s9&gt;&lt;/c8&gt;が有効ならば、&lt;c10&gt;&lt;s11&gt;board[square]&lt;/s11&gt;&lt;/c10&gt;に格納される値は現在の&lt;c12&gt;&lt;s13&gt;square&lt;/s13&gt;&lt;/c12&gt;の値に加えられて、はしごや蛇があればプレーヤーを上や下に動かします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;c9&gt;&lt;s10&gt;question&lt;/s10&gt;&lt;/c9&gt; is true, it evaluates &lt;c11&gt;&lt;s12&gt;answer1&lt;/s12&gt;&lt;/c11&gt; and returns its value; otherwise, it evaluates &lt;c13&gt;&lt;s14&gt;answer2&lt;/s14&gt;&lt;/c13&gt; and returns its value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c9&gt;&lt;s10&gt;question&lt;/s10&gt;&lt;/c9&gt;が真実ならば、それは&lt;c11&gt;&lt;s12&gt;answer1&lt;/s12&gt;&lt;/c11&gt;を評価して、その値を返します；そうでなければ、それは&lt;c13&gt;&lt;s14&gt;answer2&lt;/s14&gt;&lt;/c13&gt;を評価して、その値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>if文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If Statements and Forced Unwrapping</seg>
      </tuv>
      <tuv lang="JA">
        <seg>if文と強制アンラップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a &lt;c12&gt;&lt;s13&gt;String&lt;/s13&gt;&lt;/c12&gt; is empty, &lt;c14&gt;&lt;s15&gt;startIndex&lt;/s15&gt;&lt;/c14&gt; and &lt;c16&gt;&lt;s17&gt;endIndex&lt;/s17&gt;&lt;/c16&gt; are equal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある&lt;c12&gt;&lt;s13&gt;String&lt;/s13&gt;&lt;/c12&gt;が空ならば、&lt;c14&gt;&lt;s15&gt;startIndex&lt;/s15&gt;&lt;/c14&gt;と&lt;c16&gt;&lt;s17&gt;endIndex&lt;/s17&gt;&lt;/c16&gt;は同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a &lt;c2&gt;&lt;s3&gt;catch&lt;/s3&gt;&lt;/c2&gt; clause doesn’t have a pattern, the clause matches any error and binds the error to a local constant named &lt;c4&gt;&lt;s5&gt;error&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;catch&lt;/s3&gt;&lt;/c2&gt;節がパターンを持たないならば、その節はあらゆるエラーにマッチします、そしてそのエラーを&lt;c4&gt;&lt;s5&gt;error&lt;/s5&gt;&lt;/c4&gt;と名前を付けられるローカル定数に束縛します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a &lt;c4&gt;&lt;s5&gt;catch&lt;/s5&gt;&lt;/c4&gt; clause does not specify a pattern, the &lt;c6&gt;&lt;s7&gt;catch&lt;/s7&gt;&lt;/c6&gt; clause matches and binds any error to a local constant named &lt;c8&gt;&lt;s9&gt;error&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある&lt;c4&gt;&lt;s5&gt;catch&lt;/s5&gt;&lt;/c4&gt;節がパターンを指定しないならば、その&lt;c6&gt;&lt;s7&gt;catch&lt;/s7&gt;&lt;/c6&gt;節はマッチしてあらゆるエラーを&lt;c8&gt;&lt;s9&gt;error&lt;/s9&gt;&lt;/c8&gt;と名前をつけられるローカル定数に束縛します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a &lt;c8&gt;&lt;s9&gt;where&lt;/s9&gt;&lt;/c8&gt; clause is present, the &lt;e10&gt;statements&lt;/e10&gt; within the relevant case are executed only if the value of the &lt;e11&gt;control expression&lt;/e11&gt; matches one of the patterns of the case and the expression of the &lt;c12&gt;&lt;s13&gt;where&lt;/s13&gt;&lt;/c12&gt; clause evaluates to &lt;c14&gt;&lt;s15&gt;true&lt;/s15&gt;&lt;/c14&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c8&gt;&lt;s9&gt;where&lt;/s9&gt;&lt;/c8&gt;節が存在するならば、関連するケース節の範囲内のいくらかの&lt;e10&gt;文&lt;/e10&gt;は、&lt;e11&gt;制御式&lt;/e11&gt;の値がケース節のパターンの１つとマッチして、そして&lt;c12&gt;&lt;s13&gt;where&lt;/s13&gt;&lt;/c12&gt;節が&lt;c14&gt;&lt;s15&gt;true&lt;/s15&gt;&lt;/c14&gt;に評価される場合にだけ、実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a class has a superclass, list the superclass name before any protocols it adopts, followed by a comma:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるクラスがスーパークラスを持つならば、それが採用するあらゆるプロトコルの前に、コンマに続けてスーパークラス名を列記してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a closure does not specify a parameter list or return type because they can be inferred from context, place the capture list at the very start of the closure, followed by the &lt;c0&gt;&lt;s1&gt;in&lt;/s1&gt;&lt;/c0&gt; keyword:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャがパラメータ・リストまたは戻り型を、それらが前後関係から推論されることができるために指定しないならば、捕獲リストをクロージャのまさしくその始まりに、&lt;c0&gt;&lt;s1&gt;in&lt;/s1&gt;&lt;/c0&gt;キーワードに続けて置いてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a closure expression is provided as the function or method’s only argument and you provide that expression as a trailing closure, you do not need to write a pair of parentheses &lt;c0&gt;&lt;s1&gt;()&lt;/s1&gt;&lt;/c0&gt; after the function or method’s name when you call the function:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるクロージャ式がただ関数やメソッドの引数としてだけ提供され、そしてあなたが後付クロージャとしてその式を提供するならば、あなたがその関数を呼ぶときに、一対の丸括弧&lt;c0&gt;&lt;s1&gt;()&lt;/s1&gt;&lt;/c0&gt;を関数やメソッドの名前の後に書く必要はありません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a computed property’s setter doesn’t define a name for the new value to be set, a default name of &lt;c0&gt;&lt;s1&gt;newValue&lt;/s1&gt;&lt;/c0&gt; is used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>計算プロパティのもつセッターがその設定される新しい値に名前を定義しないならば、&lt;c0&gt;&lt;s1&gt;newValue&lt;/s1&gt;&lt;/c0&gt;の省略時の値が使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a conforming type provides its own implementation of a required method or property, that implementation will be used instead of the one provided by the extension.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>準拠している型がある必須のメソッドやプロパティのそれ自身の実装を提供する場合は、その実装が拡張によって提供されるものの代わりに使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a conforming type satisfies the requirements for multiple constrained extensions that provide implementations for the same method or property, Swift uses the implementation corresponding to the most specialized constraints.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある準拠型が同じメソッドやプロパティに対する実装を提供する複数の制約拡張に対する要件を満たすならば、スウィフトは最も特殊化した制約と一致する実装を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a constant or variable in your code needs to work with the absence of a value under certain conditions, always declare it as an optional value of the appropriate type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのコードの中の定数または変数が特定の条件下で値の欠如を取り扱う必要があるならば、常に、それを適切な型のオプショナルの値として宣言してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a constant, variable, property, or subscript makes use of a private type, the constant, variable, property, or subscript must also be marked as &lt;c0&gt;&lt;s1&gt;private&lt;/s1&gt;&lt;/c0&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数、変数、プロパティ、または添え字が非公開の型を利用するならば、定数、変数、プロパティ、または添え字はまた、&lt;c0&gt;&lt;s1&gt;private&lt;/s1&gt;&lt;/c0&gt;と印しされなければなりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a default value is defined, you can omit that parameter when calling the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時の値が定義されるならば、あなたは関数を呼ぶときそのパラメータを省略することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a function type has only one parameter and that parameter’s type is a tuple type, then the tuple type must be parenthesized when writing the function’s type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある関数型がただ１つだけのパラメータを持ちそしてそのパラメータの型がタプル型であるならば、その場合そのタプル型は関数の型を記述する時に丸括弧に入れられなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a function type includes more than a single arrow (&lt;c0&gt;&lt;s1&gt;-&gt;&lt;/s1&gt;&lt;/c0&gt;), the function types are grouped from right to left.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある関数型がただ１つだけの矢印（&lt;c0&gt;&lt;s1&gt;-&gt;&lt;/s1&gt;&lt;/c0&gt;）ではなくもっと多く含むならば、その関数型は右から左にグループにされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a function with an opaque return type returns from multiple places, all of the possible return values must have the same type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>不透明戻り型をもつ関数が複数の場所から返るならば、可能な戻り値の全ては、同じ型を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a match is found, one of the &lt;c6&gt;&lt;s7&gt;switch&lt;/s7&gt;&lt;/c6&gt; statement’s cases sets an optional &lt;c8&gt;&lt;s9&gt;Int?&lt;/s9&gt;&lt;/c8&gt; variable called &lt;c10&gt;&lt;s11&gt;possibleIntegerValue&lt;/s11&gt;&lt;/c10&gt; to an appropriate integer value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとつの適合が見つけられるならば、&lt;c6&gt;&lt;s7&gt;switch&lt;/s7&gt;&lt;/c6&gt;文のケース節の１つは、&lt;c10&gt;&lt;s11&gt;possibleIntegerValue&lt;/s11&gt;&lt;/c10&gt;と呼ばれるあるオプショナルの&lt;c8&gt;&lt;s9&gt;Int?&lt;/s9&gt;&lt;/c8&gt;変数を適切な整数値に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a match is found, the program executes the &lt;e3&gt;statements&lt;/e3&gt; listed within the scope of that case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>マッチが見つけられるならば、プログラムはそのケース節のスコープ内で列記される&lt;e3&gt;文&lt;/e3&gt;を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a nonfailable initializer delegates to an &lt;c4&gt;&lt;s5&gt;init!&lt;/s5&gt;&lt;/c4&gt; failable initializer that fails and returns &lt;c6&gt;&lt;s7&gt;nil&lt;/s7&gt;&lt;/c6&gt;, then a runtime error is raised (as if you used the &lt;c8&gt;&lt;s9&gt;!&lt;/s9&gt;&lt;/c8&gt; operator to unwrap an optional that has a &lt;c10&gt;&lt;s11&gt;nil&lt;/s11&gt;&lt;/c10&gt; value).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できないイニシャライザが、ある失敗して&lt;c6&gt;&lt;s7&gt;nil&lt;/s7&gt;&lt;/c6&gt;を返す失敗できるイニシャライザ&lt;c4&gt;&lt;s5&gt;init!&lt;/s5&gt;&lt;/c4&gt;へと委任するならば、その時は実行時エラーが（まるであなたが&lt;c10&gt;&lt;s11&gt;nil&lt;/s11&gt;&lt;/c10&gt;の値を持つオプショナルをアンラップするために&lt;c8&gt;&lt;s9&gt;!&lt;/s9&gt;&lt;/c8&gt;演算子を使ったかのように）引き起こされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a parameter has an argument label, the argument &lt;e0&gt;must&lt;/e0&gt; be labeled when you call the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある引数が引数ラベルを持つならば、その引数は、あなたがその関数を呼ぶ時にラベルを付けられる&lt;e0&gt;必要があります&lt;/e0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a particular dice roll would take you beyond square 25, you must roll again until you roll the exact number needed to land on square 25.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある特定のさいころを振る回が、正方形25を越えてあなたを連れて行くならば、あなたは正方形25に到着するのに必要な正確な数を出すまで、再びさいころを振らなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a period appears at the beginning of a line, it is understood as part of an explicit member expression, not as an implicit member expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ピリオドがある行の初めに現れたならば、それはある明示的なメンバー式の一部として理解されます、ひとつの明示的なメンバー式としてではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a postfix expression that contains an optional-chaining expression is nested inside other postfix expressions, only the outermost expression returns an optional type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖式を含む接尾辞式が、他の接尾辞式の内部に入れ子にされるならば、最も外部の式だけがオプショナル型を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a property always takes the same initial value, provide a default value rather than setting a value within an initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロパティが常に同じ初期値をとるならば、イニシャライザ内で値を設定することよりむしろ省略時の値を提供してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a property declaration includes both the &lt;c0&gt;&lt;s1&gt;get&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;set&lt;/s3&gt;&lt;/c2&gt; keywords, a conforming type can implement it with a stored variable property or a computed property that is both readable and writeable (that is, one that implements both a getter and a setter).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロパティ宣言が&lt;c0&gt;&lt;s1&gt;get&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;set&lt;/s3&gt;&lt;/c2&gt;キーワードを両方とも含むならば、準拠している型はそれを、格納変数プロパティや計算プロパティを使って実装することができます、それは読み出し可能と書き込み可能の両方であるものです（すなわち、ゲッターとセッターのどちらも実装できるもの）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a property declaration includes only the &lt;c4&gt;&lt;s5&gt;get&lt;/s5&gt;&lt;/c4&gt; keyword, it can be implemented as any kind of property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティ宣言が&lt;c4&gt;&lt;s5&gt;get&lt;/s5&gt;&lt;/c4&gt;キーワードだけを含むならば、それはどんな種類のプロパティとしてでも実装されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a property marked with the &lt;c0&gt;&lt;s1&gt;lazy&lt;/s1&gt;&lt;/c0&gt; modifier is accessed by multiple threads simultaneously and the property has not yet been initialized, there is no guarantee that the property will be initialized only once.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;lazy&lt;/s1&gt;&lt;/c0&gt;修飾子で印されるプロパティが複数のスレッドによって同時にアクセスされ、そのプロパティがその時まだ初期化されないならば、そのプロパティがただ一度だけ初期化されるとは保障されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a protocol is marked with the &lt;c0&gt;&lt;s1&gt;objc&lt;/s1&gt;&lt;/c0&gt; attribute, the &lt;c2&gt;&lt;s3&gt;AnyObject&lt;/s3&gt;&lt;/c2&gt; requirement is implicitly applied to that protocol; there’s no need to mark the protocol with the &lt;c4&gt;&lt;s5&gt;AnyObject&lt;/s5&gt;&lt;/c4&gt; requirement explicitly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロトコルが&lt;c0&gt;&lt;s1&gt;objc&lt;/s1&gt;&lt;/c0&gt;属性で印されるならば、&lt;c2&gt;&lt;s3&gt;AnyObject&lt;/s3&gt;&lt;/c2&gt;要件は暗黙的にそのプロトコルに適用されます；&lt;c4&gt;&lt;s5&gt;AnyObject&lt;/s5&gt;&lt;/c4&gt;要件で明示的に印する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a protocol requires a property to be gettable and settable, that property requirement can’t be fulfilled by a constant stored property or a read-only computed property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロトコルがプロパティに取得可能かつまた設定可能であることを要求するならば、そのプロパティ要件は、定数格納プロパティまたは読み出し専用の計算プロパティによって満たされることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a stored property’s default value requires some customization or setup, you can use a closure or global function to provide a customized default value for that property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある格納プロパティの省略時の値が、いくらかの特別な注文または準備を必要とするならば、あなたは特注の省略時の値をそのプロパティのために用意するために、クロージャまたはグローバル関数を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a stored value in your code won’t change, always declare it as a constant with the &lt;c0&gt;&lt;s1&gt;let&lt;/s1&gt;&lt;/c0&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある格納された値をあなたのコードにおいて変化させる予定がないならば、常に&lt;c0&gt;&lt;s1&gt;let&lt;/s1&gt;&lt;/c0&gt;キーワードを使ってそれを定数として宣言してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a subclass initializer performs no customization in phase 2 of the initialization process, and the superclass has a zero-argument designated initializer, you can omit a call to &lt;c0&gt;&lt;s1&gt;super.init()&lt;/s1&gt;&lt;/c0&gt; after assigning values to all of the subclass’s stored properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブクラスのイニシャライザが初期化過程の第２段階においてなんら特注の挙動を実行しない、そしてスーパークラスがゼロ個引数の指定イニシャライザを持つならば、あなたはサブクラスの持つ格納プロパティの全てに値を割り当てた後、&lt;c0&gt;&lt;s1&gt;super.init()&lt;/s1&gt;&lt;/c0&gt;の呼び出しを省略できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a subclass overrides a designated initializer from a superclass, and also implements a matching initializer requirement from a protocol, mark the initializer implementation with both the &lt;c0&gt;&lt;s1&gt;required&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;override&lt;/s3&gt;&lt;/c2&gt; modifiers:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるサブクラスが、スーパークラスからの指定イニシャライザをオーバーライドして、またプロトコルからのイニシャライザ要件にも合致するものを実装するならば、そのイニシャライザ実装を&lt;c0&gt;&lt;s1&gt;required&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;override&lt;/s3&gt;&lt;/c2&gt;の両方の修飾子を使って印してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a subscript returns a value of optional type—such as the key subscript of Swift’s &lt;c0&gt;&lt;s1&gt;Dictionary&lt;/s1&gt;&lt;/c0&gt; type—place a question mark &lt;e2&gt;after&lt;/e2&gt; the subscript’s closing bracket to chain on its optional return value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある添え字がオプショナル型の値を返すならば ― 例えばスウィフトの&lt;c0&gt;&lt;s1&gt;Dictionary&lt;/s1&gt;&lt;/c0&gt;型のキー添え字 ― 疑問符をその添え字の閉じ括弧の&lt;e2&gt;後ろに&lt;/e2&gt;置いて、そのオプショナルの戻り値の上に連鎖を繋げてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a type already conforms to all of the requirements of a protocol, but has not yet stated that it adopts that protocol, you can make it adopt the protocol with an empty extension:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型があるプロトコルの要件の全てにすでに準拠するが、それがそのプロトコルを採用するとまだ示していなかったならば、あなたは空の拡張を使ってそれがそのプロトコルを採用するようにできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a type defines one of these methods, instances of the type can be used in function call syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型がそれらメソッドの１つを定義するならば、その型のインスタンスは関数呼び出し構文において使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a value (known as a &lt;e0&gt;raw&lt;/e0&gt; value) is provided for each enumeration case, the value can be a string, a character, or a value of any integer or floating-point type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値（&lt;e0&gt;raw&lt;/e0&gt;の値として知られるもの）が列挙のケース節の各々のために提供されている場合には、その値は文字列、文字、またはあらゆる整数または浮動小数点型の値であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If all of the associated values for an enumeration case are extracted as constants, or if all are extracted as variables, you can place a single &lt;c0&gt;&lt;s1&gt;var&lt;/s1&gt;&lt;/c0&gt; or &lt;c2&gt;&lt;s3&gt;let&lt;/s3&gt;&lt;/c2&gt; annotation before the case name, for brevity:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙ケース節の関連値の全てが定数として抽出されるならば、または全てが変数として抽出されるならば、あなたは簡潔に&lt;c0&gt;&lt;s1&gt;var&lt;/s1&gt;&lt;/c0&gt;または&lt;c2&gt;&lt;s3&gt;let&lt;/s3&gt;&lt;/c2&gt;注釈１つだけをケース節名の前に置くことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If all the elements are equal, then the tuples themselves are equal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべての要素が等しいならば、その時それらのタプル自体が等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an &lt;c0&gt;&lt;s1&gt;available&lt;/s1&gt;&lt;/c0&gt; attribute only specifies an &lt;c2&gt;&lt;s3&gt;introduced&lt;/s3&gt;&lt;/c2&gt; argument in addition to a platform or language name argument, you can use the following shorthand syntax instead:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;available&lt;/s1&gt;&lt;/c0&gt;属性がただ１つの&lt;c2&gt;&lt;s3&gt;introduced&lt;/s3&gt;&lt;/c2&gt;引数をプラットホームまたは言語名引数に加えて指定するならば、あなたは以下の略記構文が代わりに利用可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an audio signal comes in with a higher value than &lt;c8&gt;&lt;s9&gt;10&lt;/s9&gt;&lt;/c8&gt;, it will be capped to this threshold value (as described below).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある音声信号が&lt;c8&gt;&lt;s9&gt;10&lt;/s9&gt;&lt;/c8&gt;より高い値でやってくるならば、それはこの限界値に制限されます（下記のように）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an empty string is found, an initialization failure is triggered.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もし空の文字列が見つけられたならば、初期化失敗が引き起こされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an enumeration has raw values, those values are determined as part of the declaration, which means every instance of a particular enumeration case always has the same raw value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある列挙が生の値を持つならば、それらの値は宣言の一部として決定されます、それはある特定の列挙ケース節のすべてのインスタンスが常に同じ生の値を持つことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an error actually is thrown, you’ll get a runtime error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーが実際はスローされるならば、あなたは実行時エラーを受け取るでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an error is thrown and it matches the &lt;c2&gt;&lt;s3&gt;SandwichError.outOfCleanDishes&lt;/s3&gt;&lt;/c2&gt; case, then the &lt;c4&gt;&lt;s5&gt;washDishes()&lt;/s5&gt;&lt;/c4&gt; function will be called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーがスローされてそれが&lt;c2&gt;&lt;s3&gt;SandwichError.outOfCleanDishes&lt;/s3&gt;&lt;/c2&gt;ケース節にマッチするならば、そのとき&lt;c4&gt;&lt;s5&gt;washDishes()&lt;/s5&gt;&lt;/c4&gt;関数が呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an error is thrown and it matches the &lt;c6&gt;&lt;s7&gt;SandwichError.missingIngredients&lt;/s7&gt;&lt;/c6&gt; case, then the &lt;c8&gt;&lt;s9&gt;buyGroceries(_:)&lt;/s9&gt;&lt;/c8&gt; function is called with the associated &lt;c10&gt;&lt;s11&gt;[String]&lt;/s11&gt;&lt;/c10&gt; value captured by the &lt;c12&gt;&lt;s13&gt;catch&lt;/s13&gt;&lt;/c12&gt; pattern.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーがスローされてそれが&lt;c6&gt;&lt;s7&gt;SandwichError.missingIngredients&lt;/s7&gt;&lt;/c6&gt;ケース節にマッチするならば、そのとき&lt;c8&gt;&lt;s9&gt;buyGroceries(_:)&lt;/s9&gt;&lt;/c8&gt;関数がその&lt;c12&gt;&lt;s13&gt;catch&lt;/s13&gt;&lt;/c12&gt;パターンによってキャプチャされた&lt;c10&gt;&lt;s11&gt;[String]&lt;/s11&gt;&lt;/c10&gt;関連値とともに呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an error is thrown by the code in the &lt;c4&gt;&lt;s5&gt;do&lt;/s5&gt;&lt;/c4&gt; clause, it is matched against the &lt;c6&gt;&lt;s7&gt;catch&lt;/s7&gt;&lt;/c6&gt; clauses to determine which one of them can handle the error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるエラーが&lt;c4&gt;&lt;s5&gt;do&lt;/s5&gt;&lt;/c4&gt;節の中にあるコードによってスローされるならば、それは&lt;c6&gt;&lt;s7&gt;catch&lt;/s7&gt;&lt;/c6&gt;節と照合されて、それらの１つがそのエラーを処理できると決定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an error is thrown while evaluating the &lt;c2&gt;&lt;s3&gt;try?&lt;/s3&gt;&lt;/c2&gt; expression, the value of the expression is &lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;try?&lt;/s3&gt;&lt;/c2&gt;式を評価している間にエラーがスローされるならば、式の値は&lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an error is thrown, execution immediately transfers to the &lt;c4&gt;&lt;s5&gt;catch&lt;/s5&gt;&lt;/c4&gt; clauses, which decide whether to allow propagation to continue.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーがスローされるならば、実行は直ちに&lt;c4&gt;&lt;s5&gt;catch&lt;/s5&gt;&lt;/c4&gt;節に移ります、それは伝達を継続させるかどうか結論を下します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an implicitly unwrapped optional is &lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt; and you try to access its wrapped value, you’ll trigger a runtime error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗黙的にアンラップされるオプショナルが&lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;であり、あなたがそれのラップされた値にアクセスしようとするならば、あなたは実行時エラーを引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an instance of an optional type contains a value, you can access that value using the postfix operator &lt;c0&gt;&lt;s1&gt;!&lt;/s1&gt;&lt;/c0&gt;, as shown below:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル型のインスタンスが値を含むならば、あなたが接尾辞演算子&lt;c0&gt;&lt;s1&gt;!&lt;/s1&gt;&lt;/c0&gt;を使用してその値にアクセスすることができます、以下に示すように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an instance of the extended type or of a type that conforms to the extended protocol satisfies the &lt;e1&gt;requirements&lt;/e1&gt;, the instance gains the behavior specified in the declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張された型のまたは拡張されたプロトコルに準拠する型のインスタンスが&lt;e1&gt;requirements 要件&lt;/e1&gt;を満たすならば、そのインスタンスは宣言において指定される挙動を獲得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an operator doesn’t begin with a dot, it can’t contain a dot elsewhere.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある演算子がドットで始まらないならば、それはどこか他にドットを含むことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an operator has no whitespace on the left but is followed immediately by a dot (&lt;c0&gt;&lt;s1&gt;.&lt;/s1&gt;&lt;/c0&gt;), it’s treated as a postfix unary operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある演算子が左側では空白を持たないが直ちに続けて１つのドット（&lt;c0&gt;&lt;s1&gt;.&lt;/s1&gt;&lt;/c0&gt;）を持つならば、それは接尾辞単項演算子と見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an operator has whitespace around both sides or around neither side, it’s treated as a binary operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある演算子が、空白をそのまわりの両側に持つか、そのまわりのどちら側にも持たないならば、それは二項演算子とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an operator has whitespace on the left side only, it’s treated as a prefix unary operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある演算子が左側だけで空白を持つならば、それは接頭辞単項演算子とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an operator has whitespace on the right side only, it’s treated as a postfix unary operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある演算子が右側だけで空白を持つならば、それは接尾辞単項演算子とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If an optional has a value, it’s considered to be “not equal to” &lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるオプショナルが値を持つならば、それは&lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;と「同等でない」と判断されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any of the patterns match, then the case is considered to match.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらのパターンのどれかが合致するならば、そのときそのケース節は合致するとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any of the values in the optional bindings are &lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt; or any Boolean condition evaluates to &lt;c4&gt;&lt;s5&gt;false&lt;/s5&gt;&lt;/c4&gt;, the whole &lt;c6&gt;&lt;s7&gt;if&lt;/s7&gt;&lt;/c6&gt; statement’s condition is considered to be &lt;c8&gt;&lt;s9&gt;false&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>何れかのオプショナル束縛の中の値が&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;であるか何かのブール条件の評価が&lt;c4&gt;&lt;s5&gt;false&lt;/s5&gt;&lt;/c4&gt;になるならば、&lt;c6&gt;&lt;s7&gt;if&lt;/s7&gt;&lt;/c6&gt;文の条件の全体が&lt;c8&gt;&lt;s9&gt;false&lt;/s9&gt;&lt;/c8&gt;であるとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If casting to the specified &lt;e10&gt;type&lt;/e10&gt; is guaranteed to fail or is guaranteed to succeed, a compile-time error is raised.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定された&lt;e10&gt;型&lt;/e10&gt;へのキャストが失敗すると保証されるまたは成功すると保証される場合には、コンパイル時エラーが引き起こされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If either value is &lt;c0&gt;&lt;s1&gt;false&lt;/s1&gt;&lt;/c0&gt;, the overall expression will also be &lt;c2&gt;&lt;s3&gt;false&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どちらかの値が&lt;c0&gt;&lt;s1&gt;false&lt;/s1&gt;&lt;/c0&gt;ならば、全体的な式もまた&lt;c2&gt;&lt;s3&gt;false&lt;/s3&gt;&lt;/c2&gt;になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it doesn’t, the new value the convenience initializer assigns will be overwritten by its own class’s designated initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それがそうしないならば、便宜イニシャライザが代入する新しい値は、それ自身のクラスの指定イニシャライザによって上書きされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it doesn’t, the new value the designated initializer assigns will be overwritten by the superclass as part of its own initialization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それがそうしないならば、指定イニシャライザが代入する新しい値は、スーパークラスによってそれ自身の初期化の一部として上書きされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it is, a message is printed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしそうならば、メッセージが出力されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it’s &lt;e0&gt;not&lt;/e0&gt; possible to retrieve a value from the &lt;c1&gt;&lt;s2&gt;increment(forCount:)&lt;/s2&gt;&lt;/c1&gt; method—either because &lt;c3&gt;&lt;s4&gt;dataSource&lt;/s4&gt;&lt;/c3&gt; is nil, or because the data source doesn’t implement &lt;c5&gt;&lt;s6&gt;increment(forCount:)&lt;/s6&gt;&lt;/c5&gt;—then the &lt;c7&gt;&lt;s8&gt;increment()&lt;/s8&gt;&lt;/c7&gt; method tries to retrieve a value from the data source’s &lt;c9&gt;&lt;s10&gt;fixedIncrement&lt;/s10&gt;&lt;/c9&gt; property instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値を&lt;c1&gt;&lt;s2&gt;increment(forCount:)&lt;/s2&gt;&lt;/c1&gt;メソッドから取り出すことが可能で&lt;e0&gt;ない&lt;/e0&gt;ならば ― &lt;c3&gt;&lt;s4&gt;dataSource&lt;/s4&gt;&lt;/c3&gt;がnilであるから、またはデータ・ソースが&lt;c5&gt;&lt;s6&gt;increment(forCount:)&lt;/s6&gt;&lt;/c5&gt;を実装しないからのどちらでも ― その時&lt;c7&gt;&lt;s8&gt;increment()&lt;/s8&gt;&lt;/c7&gt;メソッドはその代わりに値をデータ・ソースの&lt;c9&gt;&lt;s10&gt;fixedIncrement&lt;/s10&gt;&lt;/c9&gt;プロパティから取り出そうとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it’s not appropriate to provide a case for every possible value, you can define a default case to cover any values that are not addressed explicitly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべてのあり得る値に対してひとつのケース節を用意することが妥当でないならば、あなたはdefault（省略時）ケース節を定義することで、明確に言及されないどんな値にも対応できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If multiple &lt;c0&gt;&lt;s1&gt;defer&lt;/s1&gt;&lt;/c0&gt; statements appear in the same scope, the order they appear is the reverse of the order they are executed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数の&lt;c0&gt;&lt;s1&gt;defer&lt;/s1&gt;&lt;/c0&gt;文が同じスコープに現れるならば、それらが現れる順番が、それらが実行される順番の逆です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no error is thrown, the &lt;c0&gt;&lt;s1&gt;eatASandwich()&lt;/s1&gt;&lt;/c0&gt; function is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーがスローされないならば、&lt;c0&gt;&lt;s1&gt;eatASandwich()&lt;/s1&gt;&lt;/c0&gt;関数が呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no error is thrown, the remaining statements in the &lt;c10&gt;&lt;s11&gt;do&lt;/s11&gt;&lt;/c10&gt; statement are executed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーがスローされることが全く無いならば、&lt;c10&gt;&lt;s11&gt;do&lt;/s11&gt;&lt;/c10&gt;文に残っている文が遂行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no initializers are declared, and all properties of the class declaration were given initial values, call the class’s default initializer, as described in &lt;a0&gt;&lt;s1&gt;Default Initializers&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザが宣言されない、そして全てのクラス宣言のプロパティが初期値を与えられるならば、クラスの省略時のイニシャライザを呼び出す、&lt;a0&gt;&lt;s1&gt;省略時のイニシャライザ&lt;/s1&gt;&lt;/a0&gt;で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no initializers are declared, and all properties of the structure declaration were given initial values, call the structure’s default initializer, as described in &lt;a0&gt;&lt;s1&gt;Default Initializers&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザが宣言されない、そしてその構造体宣言の全てのプロパティが初期値を与えられたならば、構造体の省略時のイニシャライザを呼び出す、&lt;a0&gt;&lt;s1&gt;省略時のイニシャライザ&lt;/s1&gt;&lt;/a0&gt;で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no initializers are declared, call the structure’s memberwise initializer, as described in &lt;a0&gt;&lt;s1&gt;Memberwise Initializers for Structure Types&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザが宣言されないならば、その構造体のメンバー関連イニシャライザ呼び出す、&lt;a0&gt;&lt;s1&gt;構造型のためのメンバー関連イニシャライザ&lt;/s1&gt;&lt;/a0&gt;で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no pattern is matched, the error gets caught by the final &lt;c6&gt;&lt;s7&gt;catch&lt;/s7&gt;&lt;/c6&gt; clause and is bound to a local &lt;c8&gt;&lt;s9&gt;error&lt;/s9&gt;&lt;/c8&gt; constant.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パターンが適合することが全く無いならば、エラーは最後の&lt;c6&gt;&lt;s7&gt;catch&lt;/s7&gt;&lt;/c6&gt;節によってキャッチされて、あるローカル&lt;c8&gt;&lt;s9&gt;error&lt;/s9&gt;&lt;/c8&gt;定数に束縛されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If none of the &lt;c4&gt;&lt;s5&gt;catch&lt;/s5&gt;&lt;/c4&gt; clauses handle the error, the error propagates to the surrounding scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どの&lt;c4&gt;&lt;s5&gt;catch&lt;/s5&gt;&lt;/c4&gt;節もエラーを処理しないならば、エラーは取り囲んでいるスコープへと伝えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If one of the copies of the collection is modified, the elements are copied just before the modification.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのコレクションのいくつかのコピーのうちの１つが修正されるならば、それら要素はその修正の直前にコピーされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If part of your code requires a &lt;c1&gt;&lt;s2&gt;String&lt;/s2&gt;&lt;/c1&gt;, type safety prevents you from passing it an &lt;c3&gt;&lt;s4&gt;Int&lt;/s4&gt;&lt;/c3&gt; by mistake.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのコードの一部が&lt;c1&gt;&lt;s2&gt;String&lt;/s2&gt;&lt;/c1&gt;を要求するならば、型安全はあなたが間違ってそれに&lt;c3&gt;&lt;s4&gt;Int&lt;/s4&gt;&lt;/c3&gt;を渡すことを防ぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If part of your code requires a &lt;c1&gt;&lt;s2&gt;String&lt;/s2&gt;&lt;/c1&gt;, you can’t pass it an &lt;c3&gt;&lt;s4&gt;Int&lt;/s4&gt;&lt;/c3&gt; by mistake.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのコードの一部が&lt;c1&gt;&lt;s2&gt;String&lt;/s2&gt;&lt;/c1&gt;を要求するならば、あなたは誤ってそれに&lt;c3&gt;&lt;s4&gt;Int&lt;/s4&gt;&lt;/c3&gt;を渡すことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If such a determination can be made, the error is considered handled.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのような決定が為されるならば、エラーは処理されたと判断されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If that condition is not met, the code inside the &lt;c0&gt;&lt;s1&gt;else&lt;/s1&gt;&lt;/c0&gt; branch is executed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その条件が満たされないならば、&lt;c0&gt;&lt;s1&gt;else&lt;/s1&gt;&lt;/c0&gt;分岐の内部のコードが実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;c0&gt;&lt;s1&gt;!&lt;/s1&gt;&lt;/c0&gt; or &lt;c2&gt;&lt;s3&gt;?&lt;/s3&gt;&lt;/c2&gt; predefined operator has no whitespace on the left, it’s treated as a postfix operator, regardless of whether it has whitespace on the right.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あらかじめ定義された演算子&lt;c0&gt;&lt;s1&gt;!&lt;/s1&gt;&lt;/c0&gt;または&lt;c2&gt;&lt;s3&gt;?&lt;/s3&gt;&lt;/c2&gt;が左側に空白を持たないならば、それは接尾辞演算子と見なされます、それが右側に空白を持つかどうかに関係なく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt; value does not have enough digits for the requested index, the subscript implementation returns &lt;c2&gt;&lt;s3&gt;0&lt;/s3&gt;&lt;/c2&gt;, as if the number had been padded with zeros to the left:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt;値には要十分な桁が請されたインデックスに対してないならば、この添え字実装は、まるで数が左にゼロを詰められたように&lt;c2&gt;&lt;s3&gt;0&lt;/s3&gt;&lt;/c2&gt;を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;c0&gt;&lt;s1&gt;break&lt;/s1&gt;&lt;/c0&gt; statement above did not use the &lt;c2&gt;&lt;s3&gt;gameLoop&lt;/s3&gt;&lt;/c2&gt; label, it would break out of the &lt;c4&gt;&lt;s5&gt;switch&lt;/s5&gt;&lt;/c4&gt; statement, not the &lt;c6&gt;&lt;s7&gt;while&lt;/s7&gt;&lt;/c6&gt; statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の&lt;c0&gt;&lt;s1&gt;break&lt;/s1&gt;&lt;/c0&gt;文が&lt;c2&gt;&lt;s3&gt;gameLoop&lt;/s3&gt;&lt;/c2&gt;ラベルを使用しないならば、それは、&lt;c6&gt;&lt;s7&gt;while&lt;/s7&gt;&lt;/c6&gt;文ではなく、&lt;c4&gt;&lt;s5&gt;switch&lt;/s5&gt;&lt;/c4&gt;文から抜け出すでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;c0&gt;&lt;s1&gt;guard&lt;/s1&gt;&lt;/c0&gt; statement’s condition is met, code execution continues after the &lt;c2&gt;&lt;s3&gt;guard&lt;/s3&gt;&lt;/c2&gt; statement’s closing brace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;guard&lt;/s1&gt;&lt;/c0&gt;文の条件が満たされるならば、コード実行は&lt;c2&gt;&lt;s3&gt;guard&lt;/s3&gt;&lt;/c2&gt;文の閉じ中括弧の後に続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;c4&gt;&lt;s5&gt;array&lt;/s5&gt;&lt;/c4&gt; argument contains an empty array, the &lt;c6&gt;&lt;s7&gt;minMax(array:)&lt;/s7&gt;&lt;/c6&gt; function, as defined above, will trigger a runtime error when attempting to access &lt;c8&gt;&lt;s9&gt;array[0]&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;array&lt;/s5&gt;&lt;/c4&gt;引数が空の配列を含んでいるならば、上で定義される&lt;c6&gt;&lt;s7&gt;minMax(array:)&lt;/s7&gt;&lt;/c6&gt;関数は、&lt;c8&gt;&lt;s9&gt;array[0]&lt;/s9&gt;&lt;/c8&gt;にアクセスしようとする時に実行時エラーを引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;c4&gt;&lt;s5&gt;case&lt;/s5&gt;&lt;/c4&gt; for &lt;c6&gt;&lt;s7&gt;.west&lt;/s7&gt;&lt;/c6&gt; is omitted, this code doesn’t compile, because it doesn’t consider the complete list of &lt;c8&gt;&lt;s9&gt;CompassPoint&lt;/s9&gt;&lt;/c8&gt; cases.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;.west&lt;/s7&gt;&lt;/c6&gt;のための&lt;c4&gt;&lt;s5&gt;case&lt;/s5&gt;&lt;/c4&gt;が省略されるならば、このコードはコンパイルしません、なぜなら、それが&lt;c8&gt;&lt;s9&gt;CompassPoint&lt;/s9&gt;&lt;/c8&gt;のケース節の完全なリストを考慮しないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;c6&gt;&lt;s7&gt;quantity&lt;/s7&gt;&lt;/c6&gt; is invalid, the entire initialization process fails immediately and no further initialization code is executed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;quantity&lt;/s7&gt;&lt;/c6&gt;が無効ならば、初期化処理全体が直ちに失敗して、以降の初期化コードは実行されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;c7&gt;&lt;s8&gt;delegate&lt;/s8&gt;&lt;/c7&gt; property is nil, these delegate calls fail gracefully and without error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c7&gt;&lt;s8&gt;delegate&lt;/s8&gt;&lt;/c7&gt;プロパティがnilならば、これらの委任先呼び出しはエラーなしで美しく失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;c9&gt;&lt;s10&gt;delegate&lt;/s10&gt;&lt;/c9&gt; property is non-nil, the delegate methods are called, and are passed the &lt;c11&gt;&lt;s12&gt;SnakesAndLadders&lt;/s12&gt;&lt;/c11&gt; instance as a parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c9&gt;&lt;s10&gt;delegate&lt;/s10&gt;&lt;/c9&gt;プロパティがnilでないならば、委任先のさまざまなメソッドが呼ばれます、そしてパラメータとして&lt;c11&gt;&lt;s12&gt;SnakesAndLadders&lt;/s12&gt;&lt;/c11&gt;インスタンスを渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;e0&gt;condition&lt;/e0&gt; evaluates to &lt;c1&gt;&lt;s2&gt;true&lt;/s2&gt;&lt;/c1&gt;, the conditional operator evaluates the first expression and returns its value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;条件&lt;/e0&gt;が&lt;c1&gt;&lt;s2&gt;true&lt;/s2&gt;&lt;/c1&gt;に評価されるならば、条件演算子は最初の式を評価して、その値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;e0&gt;constant name&lt;/e0&gt; of a constant declaration is a tuple pattern, the name of each item in the tuple is bound to the corresponding value in the initializer &lt;e1&gt;expression&lt;/e1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数宣言の&lt;e0&gt;定数名&lt;/e0&gt;がタプルパターンであるならば、タプルの中の各項目の名前は、イニシャライザ&lt;e1&gt;式&lt;/e1&gt;の中の対応する値に縛りつけられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;e0&gt;expression&lt;/e0&gt; does not throw an error, the value of the optional-try expression is an optional containing the value of the &lt;e1&gt;expression&lt;/e1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この&lt;e0&gt;expression（式）&lt;/e0&gt;がエラーをスローしないならば、オプショナルtry式の値はひとつのオプショナルになり、その&lt;e1&gt;expression（式）&lt;/e1&gt;の値を含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;e0&gt;expression&lt;/e0&gt; throws an error, a runtime error is produced.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この&lt;e0&gt;expression（式）&lt;/e0&gt;がエラーをスローするならば、実行時エラーが生み出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;e0&gt;type name&lt;/e0&gt; is a class, structure, or enumeration type, the extension extends that type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;type name&lt;/e0&gt;がクラス、構造体、または列挙型ならば、その拡張はその型を拡張します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;e1&gt;type name&lt;/e1&gt; is a protocol type, the extension extends all types that conform to that protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e1&gt;type name&lt;/e1&gt;がプロトコル型ならば、その拡張はそのプロトコルに準拠するすべての型を拡張します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;e2&gt;expression&lt;/e2&gt; is a tuple, the &lt;e3&gt;value&lt;/e3&gt; must be a tuple with the same number of elements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e2&gt;式&lt;/e2&gt;がタプルであるならば、&lt;e3&gt;値&lt;/e3&gt;は同じ数の要素をもつタプルでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the Boolean condition in the assertion or precondition evaluates to &lt;c2&gt;&lt;s3&gt;true&lt;/s3&gt;&lt;/c2&gt;, code execution continues as usual.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>表明または前提条件におけるブール条件が&lt;c2&gt;&lt;s3&gt;true&lt;/s3&gt;&lt;/c2&gt;に評価されるならば、コードは普段通り続けて実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the captured reference will never become &lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;, it should always be captured as an unowned reference, rather than a weak reference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>捕獲された参照が決して&lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;にならないならば、それは常に、非所有参照として捕らえられなければなりません、弱い参照ではなくて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the case contains multiple patterns that match the control expression, all of the patterns must contain the same constant or variable bindings, and each bound variable or constant must have the same type in all of the case’s patterns.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>制御式にマッチする複数のパターンをケース節が含むならば、そのパターンのすべてが同じ定数または変数束縛を含まなければなりません、そして束縛された変数または定数の各々は、そのケース節の持つパターンのすべてで同じ型を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the cast fails, a runtime error is raised.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キャストが失敗したならば、実行時エラーが引き起こされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the class doesn’t inherit from another class, the list can begin with a protocol instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスが別のクラスから継承しないならば、このリストは代わりにプロトコルで始まることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the class inherits any properties from its superclass, one of the superclass’s designated initializers must be called before any of these properties can be set or modified in the current class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスが何らかのプロパティをそのスーパークラスから受け継ぐならば、これらのプロパティのどれかが現在のクラスにおいて設定または修正されることができる前に、スーパークラスの指定イニシャライザのうちの１つが呼ばれなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the closure is never called, the expression inside the closure is never evaluated, which means the array element is never removed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このクロージャが決して呼び出されないならば、クロージャ内部の式は決して評価されません、それは配列要素が決して取り除かれないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the code already checks the condition, you use the &lt;a0&gt;&lt;c1&gt;&lt;s2&gt;assertionFailure(_:file:line:)&lt;/s2&gt;&lt;/c1&gt;&lt;/a0&gt;&lt;s3&gt; [https://developer.apple.com/documentation/swift/1539616-assertionfailure]&lt;/s3&gt; function to indicate that an assertion has failed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コードがすでに条件を調べるならば、あなたは&lt;a0&gt;&lt;c1&gt;&lt;s2&gt;assertionFailure(_:file:line:)&lt;/s2&gt;&lt;/c1&gt;&lt;/a0&gt;&lt;s3&gt; [https://developer.apple.com/documentation/swift/1539616-assertionfailure]&lt;/s3&gt;関数を使って表明が失敗していることを示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the compiler can prove that the constant’s value is never read, the constant isn’t required to have a value set at all.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数のもつ値が決して読み出されないことをコンパイラが立証できるならば、定数は値を設定されることを全く要求されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the compiler can’t prove the access is safe, it doesn’t allow the access.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラがそのアクセスを安全であると立証できないならば、それはアクセスを許可しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the condition evaluates to &lt;c4&gt;&lt;s5&gt;false&lt;/s5&gt;&lt;/c4&gt;, the current state of the program is invalid; code execution ends, and your app is terminated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>条件が&lt;c4&gt;&lt;s5&gt;false&lt;/s5&gt;&lt;/c4&gt;に評価されるならば、プログラムの現在の状態は無効です；コード実行は止まり、そしてあなたのアプリは終了させられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the condition is &lt;c2&gt;&lt;s3&gt;true&lt;/s3&gt;&lt;/c2&gt;, a set of statements is repeated until the condition becomes &lt;c4&gt;&lt;s5&gt;false&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その条件が&lt;c2&gt;&lt;s3&gt;true&lt;/s3&gt;&lt;/c2&gt;ならば、条件が&lt;c4&gt;&lt;s5&gt;false&lt;/s5&gt;&lt;/c4&gt;になるまで、ひとかたまりの文が繰り返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the context already provides type information, you can create an empty dictionary with an empty dictionary literal, which is written as &lt;c0&gt;&lt;s1&gt;[:]&lt;/s1&gt;&lt;/c0&gt; (a colon inside a pair of square brackets):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>前後関係がすでに型の情報を提供するならば、あなたは&lt;c0&gt;&lt;s1&gt;[:]&lt;/s1&gt;&lt;/c0&gt;（一対の角括弧の内側のひとつのコロン）として書かれる空の辞書リテラルを使って、空の辞書を作成することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the conversion is successful, the &lt;c0&gt;&lt;s1&gt;actualNumber&lt;/s1&gt;&lt;/c0&gt; constant becomes available for use within the first branch of the &lt;c2&gt;&lt;s3&gt;if&lt;/s3&gt;&lt;/c2&gt; statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変換が成功しているならば、定数&lt;c0&gt;&lt;s1&gt;actualNumber&lt;/s1&gt;&lt;/c0&gt;は、&lt;c2&gt;&lt;s3&gt;if&lt;/s3&gt;&lt;/c2&gt;文の最初の分岐の内部での利用に役立てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the dice roll will move the player &lt;e0&gt;beyond&lt;/e0&gt; the final square, the move is invalid and the player needs to roll again.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さいころの目が最後の正方形を&lt;e0&gt;越えて&lt;/e0&gt;プレーヤーを動かすならば、その移動は無効です、そしてプレーヤーは再びさいころを振る必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the dice roll will move the player onto the final square, the game is over.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さいころの目が最後の正方形の上へプレーヤーを動かすならば、ゲームは終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the dictionary contains a value for the requested key, the subscript returns an optional value containing the existing value for that key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その辞書が要請されたキーに対する値を含むならば、添え字はそのキーに対する既存の値を含んでいるオプショナルの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the downcasting succeeds, the properties of &lt;c0&gt;&lt;s1&gt;movie&lt;/s1&gt;&lt;/c0&gt; are then used to print a description for that &lt;c2&gt;&lt;s3&gt;Movie&lt;/s3&gt;&lt;/c2&gt; instance, including the name of its &lt;c4&gt;&lt;s5&gt;director&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ダウンキャストが成功するならば、&lt;c0&gt;&lt;s1&gt;movie&lt;/s1&gt;&lt;/c0&gt;のプロパティがそれから使用されて、その&lt;c2&gt;&lt;s3&gt;Movie&lt;/s3&gt;&lt;/c2&gt;インスタンスの、それの&lt;c4&gt;&lt;s5&gt;director&lt;/s5&gt;&lt;/c4&gt;（監督）の名前を含む説明を出力することになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the entire body of a getter is a single expression, the getter implicitly returns that expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ゲッターの全本文が単一の式ならば、ゲッターは暗黙的にその式を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the entire body of the function is a single expression, the function implicitly returns that expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数の本文全体がある単一の式であるならば、その関数は暗黙的にその式を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the enumeration case you’re trying to match has any associated values, the corresponding enumeration case pattern must specify a tuple pattern that contains one element for each associated value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがマッチしようとしている列挙ケース節が関連値を持つならば、対応する列挙ケース節パターンは、各関連値に対して１つの要素を含んでいるタプルパターンを指定しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the error propagates to the top-level scope without being handled, you’ll get a runtime error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーが取り扱われることなくトップレベルスコープに伝わるならば、あなたは実行時エラーを得るでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the first case doesn’t have a value set, its value is &lt;c0&gt;&lt;s1&gt;0&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初のケース節が値を設定されないならば、それの値は&lt;c0&gt;&lt;s1&gt;0&lt;/s1&gt;&lt;/c0&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the first string (&lt;c0&gt;&lt;s1&gt;s1&lt;/s1&gt;&lt;/c0&gt;) is greater than the second string (&lt;c2&gt;&lt;s3&gt;s2&lt;/s3&gt;&lt;/c2&gt;), the &lt;c4&gt;&lt;s5&gt;backward(_:_:)&lt;/s5&gt;&lt;/c4&gt; function will return &lt;c6&gt;&lt;s7&gt;true&lt;/s7&gt;&lt;/c6&gt;, indicating that &lt;c8&gt;&lt;s9&gt;s1&lt;/s9&gt;&lt;/c8&gt; should appear before &lt;c10&gt;&lt;s11&gt;s2&lt;/s11&gt;&lt;/c10&gt; in the sorted array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の文字列（&lt;c0&gt;&lt;s1&gt;s1&lt;/s1&gt;&lt;/c0&gt;）が第二の文字列（&lt;c2&gt;&lt;s3&gt;s2&lt;/s3&gt;&lt;/c2&gt;）より大きいならば、&lt;c4&gt;&lt;s5&gt;backward(_:_:)&lt;/s5&gt;&lt;/c4&gt;関数は、ソートされた配列において&lt;c8&gt;&lt;s9&gt;s1&lt;/s9&gt;&lt;/c8&gt;が&lt;c10&gt;&lt;s11&gt;s2&lt;/s11&gt;&lt;/c10&gt;の前に現れなければならないことを示す、&lt;c6&gt;&lt;s7&gt;true&lt;/s7&gt;&lt;/c6&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the function definition includes names for its parameters, the function call must include names before its argument values separated by a colon (&lt;c0&gt;&lt;s1&gt;:&lt;/s1&gt;&lt;/c0&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数定義がそれのパラメータたちの名前を含むならば、関数呼び出しはそれらの引数値の前にその名前をコロン（&lt;c0&gt;&lt;s1&gt;:&lt;/s1&gt;&lt;/c0&gt;）で区切って含まなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the function has a return type of &lt;c0&gt;&lt;s1&gt;Void&lt;/s1&gt;&lt;/c0&gt;, the return type can be omitted as follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数が&lt;c0&gt;&lt;s1&gt;Void&lt;/s1&gt;&lt;/c0&gt;の戻り型を持つならば、次のように戻り型は省略されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the function specifies a return type, you write the &lt;c5&gt;&lt;s6&gt;throws&lt;/s6&gt;&lt;/c5&gt; keyword before the return arrow (&lt;c7&gt;&lt;s8&gt;-&gt;&lt;/s8&gt;&lt;/c7&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その関数が戻り型を指定するならば、あなたは&lt;c5&gt;&lt;s6&gt;throws&lt;/s6&gt;&lt;/c5&gt;キーワードを戻り矢印（&lt;c7&gt;&lt;s8&gt;-&gt;&lt;/s8&gt;&lt;/c7&gt;）の前に書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the function throws an error, the specific error is discarded and the result is &lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数がエラーをスローするならば、その具体的なエラーは廃棄されます、そしてその結果は&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the initial value doesn’t provide enough information (or if there is no initial value), specify the type by writing it after the variable, separated by a colon.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の値が十分な情報を提供しないならば（または最初の値がないならば）、変数の後にコロンで区切ってそれを書くことによって型を指定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the left side of a Logical OR expression is &lt;c0&gt;&lt;s1&gt;true&lt;/s1&gt;&lt;/c0&gt;, the right side is not evaluated, because it can’t change the outcome of the overall expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>論理和式の左側が&lt;c0&gt;&lt;s1&gt;true&lt;/s1&gt;&lt;/c0&gt;ならば、右側は評価されません、なぜならそれが式全体の結論を変えることができないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the loop finishes without finding a mismatch, the two containers match, and the function returns &lt;c0&gt;&lt;s1&gt;true&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ループが一致しない組合せを見つけることなく終わるならば、２つのコンテナは合致します、そして関数は&lt;c0&gt;&lt;s1&gt;true&lt;/s1&gt;&lt;/c0&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the match succeeds, the type of the matched value is cast to the &lt;e4&gt;pattern&lt;/e4&gt; specified in the right-hand side of the &lt;c5&gt;&lt;s6&gt;as&lt;/s6&gt;&lt;/c5&gt; pattern.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>マッチが成功するならば、マッチされた値の型は、&lt;c5&gt;&lt;s6&gt;as&lt;/s6&gt;&lt;/c5&gt;パターンの右手側で指定される&lt;e4&gt;パターン&lt;/e4&gt;にキャストされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the module is present, the platform condition returns &lt;c2&gt;&lt;s3&gt;true&lt;/s3&gt;&lt;/c2&gt;; otherwise, it returns &lt;c4&gt;&lt;s5&gt;false&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのモジュールが存在するならば、プラットホーム条件は&lt;c2&gt;&lt;s3&gt;true&lt;/s3&gt;&lt;/c2&gt;を返します；そうでなければ、それは&lt;c4&gt;&lt;s5&gt;false&lt;/s5&gt;&lt;/c4&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the new value of &lt;c0&gt;&lt;s1&gt;currentLevel&lt;/s1&gt;&lt;/c0&gt; (after any capping) is higher than any value previously received by &lt;e2&gt;any&lt;/e2&gt; &lt;c3&gt;&lt;s4&gt;AudioChannel&lt;/s4&gt;&lt;/c3&gt; instance, the property observer stores the new &lt;c5&gt;&lt;s6&gt;currentLevel&lt;/s6&gt;&lt;/c5&gt; value in the &lt;c7&gt;&lt;s8&gt;maxInputLevelForAllChannels&lt;/s8&gt;&lt;/c7&gt; type property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;currentLevel&lt;/s1&gt;&lt;/c0&gt;の新しい値が（制限を受けた後に）&lt;e2&gt;あらゆる&lt;/e2&gt;&lt;c3&gt;&lt;s4&gt;AudioChannel&lt;/s4&gt;&lt;/c3&gt;インスタンスで以前に受けた値より高いならば、プロパティオブザーバーは、新しい&lt;c5&gt;&lt;s6&gt;currentLevel&lt;/s6&gt;&lt;/c5&gt;値を型プロパティ&lt;c7&gt;&lt;s8&gt;maxInputLevelForAllChannels&lt;/s8&gt;&lt;/c7&gt;に保管します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the new value of &lt;c0&gt;&lt;s1&gt;currentLevel&lt;/s1&gt;&lt;/c0&gt; is greater than the allowed &lt;c2&gt;&lt;s3&gt;thresholdLevel&lt;/s3&gt;&lt;/c2&gt;, the property observer caps &lt;c4&gt;&lt;s5&gt;currentLevel&lt;/s5&gt;&lt;/c4&gt; to &lt;c6&gt;&lt;s7&gt;thresholdLevel&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;currentLevel&lt;/s1&gt;&lt;/c0&gt;の新しい値が許可された&lt;c2&gt;&lt;s3&gt;thresholdLevel&lt;/s3&gt;&lt;/c2&gt;より大きいならば、このプロパティオブザーバーは&lt;c4&gt;&lt;s5&gt;currentLevel&lt;/s5&gt;&lt;/c4&gt;を&lt;c6&gt;&lt;s7&gt;thresholdLevel&lt;/s7&gt;&lt;/c6&gt;に制限します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the omitted types can’t be inferred, a compile-time error is raised.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略された型が推論されることができないならば、コンパイル時エラーが引き起こされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the optional &lt;c6&gt;&lt;s7&gt;Int&lt;/s7&gt;&lt;/c6&gt; does contain a value—that is, if the delegate and method both exist, and the method returned a value—the unwrapped &lt;c8&gt;&lt;s9&gt;amount&lt;/s9&gt;&lt;/c8&gt; is added onto the stored &lt;c10&gt;&lt;s11&gt;count&lt;/s11&gt;&lt;/c10&gt; property, and incrementation is complete.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルの&lt;c6&gt;&lt;s7&gt;Int&lt;/s7&gt;&lt;/c6&gt;が値を含むならば ― すなわち、委任先とメソッドが両方とも存在する、そしてメソッドが値を返すならば ― アンラップされた&lt;c8&gt;&lt;s9&gt;amount&lt;/s9&gt;&lt;/c8&gt;が格納&lt;c10&gt;&lt;s11&gt;count&lt;/s11&gt;&lt;/c10&gt;プロパティへと加えられます、そして増加作業は完了です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the optional contains a value, the property, method, or subscript call succeeds; if the optional is &lt;c3&gt;&lt;s4&gt;nil&lt;/s4&gt;&lt;/c3&gt;, the property, method, or subscript call returns &lt;c5&gt;&lt;s6&gt;nil&lt;/s6&gt;&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのオプショナルが値を含むならば、プロパティ、メソッド、または添え字の呼び出しは成功します；そのオプショナルが&lt;c3&gt;&lt;s4&gt;nil&lt;/s4&gt;&lt;/c3&gt;であるならば、プロパティ、メソッド、または添え字の呼び出しは&lt;c5&gt;&lt;s6&gt;nil&lt;/s6&gt;&lt;/c5&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the optional value is &lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;, the conditional is &lt;c2&gt;&lt;s3&gt;false&lt;/s3&gt;&lt;/c2&gt; and the code in braces is skipped.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルの値が&lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;ならば、この条件文は&lt;c2&gt;&lt;s3&gt;false&lt;/s3&gt;&lt;/c2&gt;になります、そして波括弧の中のコードはスキップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the optional value is missing, the default value is used instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル値が見つからないならば、省略時の値が代わりに使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the parameter is omitted when calling the function, the default value is used instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメーターが関数呼び出し時に省略されるならば、省略時の値が代わりに使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the player has moved on or beyond square number &lt;c2&gt;&lt;s3&gt;25&lt;/s3&gt;&lt;/c2&gt;, the loop’s condition evaluates to &lt;c4&gt;&lt;s5&gt;false&lt;/s5&gt;&lt;/c4&gt; and the game ends.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プレーヤーが&lt;c2&gt;&lt;s3&gt;25&lt;/s3&gt;&lt;/c2&gt;番目の正方形の上にまたは越えて移動したならば、ループの条件は&lt;c4&gt;&lt;s5&gt;false&lt;/s5&gt;&lt;/c4&gt;に評価してゲームは終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the protocol only requires a property to be gettable, the requirement can be satisfied by any kind of property, and it’s valid for the property to be also settable if this is useful for your own code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルがプロパティに取得可能であるのを要求するだけならば、その要件はどんなプロパティにでもよって満たされることができます、そして、同時にまた設定可能でもあることは、もしそれがあなた自身のコードに役立つ場合には、そのプロパティにとって有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the raw-value type is specified as &lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt; and you don’t assign a value to the cases explicitly, they are implicitly assigned the values &lt;c2&gt;&lt;s3&gt;0&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;1&lt;/s5&gt;&lt;/c4&gt;, &lt;c6&gt;&lt;s7&gt;2&lt;/s7&gt;&lt;/c6&gt;, and so on.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もし生の値型が&lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt;として指定され、あなたが明示的に値をそれぞれのケース節に割り当てないならば、それらは暗黙のうちに値&lt;c2&gt;&lt;s3&gt;0&lt;/s3&gt;&lt;/c2&gt;、&lt;c4&gt;&lt;s5&gt;1&lt;/s5&gt;&lt;/c4&gt;、&lt;c6&gt;&lt;s7&gt;2&lt;/s7&gt;&lt;/c6&gt;、等々を割り当てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the raw-value type is specified as &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; and you don’t assign values to the cases explicitly, each unassigned case is implicitly assigned a string with the same text as the name of that case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「生の値」型が&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;として指定されてあなたが明示的に値をそのケース節に割り当てないならば、未割り当てのケース節のそれぞれは暗黙的にそのケース節の名前である同じテキストをもつ文字列を割り当てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the right side of the assignment is a tuple with multiple values, its elements can be decomposed into multiple constants or variables at once:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代入の右側が、複数の値をもつタプルであるならば、その要素は同時に複数の定数または変数に分解されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the specified key isn’t contained in the dictionary, the subscript returns &lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定されたキーがその辞書に含まれないならば、添え字は&lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the square’s value is greater than &lt;c0&gt;&lt;s1&gt;0&lt;/s1&gt;&lt;/c0&gt;, it’s the base of a ladder, and is represented by &lt;c2&gt;&lt;s3&gt;▲&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>正方形の値が&lt;c0&gt;&lt;s1&gt;0&lt;/s1&gt;&lt;/c0&gt;より大きいならば、それははしごの基部であって、&lt;c2&gt;&lt;s3&gt;▲&lt;/s3&gt;&lt;/c2&gt;によって表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the square’s value is less than &lt;c0&gt;&lt;s1&gt;0&lt;/s1&gt;&lt;/c0&gt;, it’s the head of a snake, and is represented by &lt;c2&gt;&lt;s3&gt;▼&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>正方形の値が&lt;c0&gt;&lt;s1&gt;0&lt;/s1&gt;&lt;/c0&gt;より小さいならば、それはヘビの頭であって、&lt;c2&gt;&lt;s3&gt;▼&lt;/s3&gt;&lt;/c2&gt;によって表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the stack is empty, &lt;c4&gt;&lt;s5&gt;topItem&lt;/s5&gt;&lt;/c4&gt; returns &lt;c6&gt;&lt;s7&gt;nil&lt;/s7&gt;&lt;/c6&gt;; if the stack isn’t empty, &lt;c8&gt;&lt;s9&gt;topItem&lt;/s9&gt;&lt;/c8&gt; returns the final item in the &lt;c10&gt;&lt;s11&gt;items&lt;/s11&gt;&lt;/c10&gt; array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スタックが空ならば、&lt;c4&gt;&lt;s5&gt;topItem&lt;/s5&gt;&lt;/c4&gt;は&lt;c6&gt;&lt;s7&gt;nil&lt;/s7&gt;&lt;/c6&gt;を返します；スタックが空でないならば、&lt;c8&gt;&lt;s9&gt;topItem&lt;/s9&gt;&lt;/c8&gt;は&lt;c10&gt;&lt;s11&gt;items&lt;/s11&gt;&lt;/c10&gt;配列の最後の項目を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the subclass overrides all of the superclass’s designated initializers, it inherits the superclass’s convenience initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブクラスがスーパークラスの指定イニシャライザのすべてをオーバーライドするならば、それはスーパークラスの便宜イニシャライザたちを継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the subscript declaration includes both the &lt;c0&gt;&lt;s1&gt;get&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;set&lt;/s3&gt;&lt;/c2&gt; keywords, a conforming type must implement both a getter and a setter clause.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字宣言が&lt;c0&gt;&lt;s1&gt;get&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;set&lt;/s3&gt;&lt;/c2&gt;キーワードを両方とも含むならば、準拠している型はゲッターとセッター節を両方とも実装しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the subscript declaration includes only the &lt;c4&gt;&lt;s5&gt;get&lt;/s5&gt;&lt;/c4&gt; keyword, a conforming type must implement &lt;e6&gt;at least&lt;/e6&gt; a getter clause and optionally can implement a setter clause.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字宣言が&lt;c4&gt;&lt;s5&gt;get&lt;/s5&gt;&lt;/c4&gt;キーワードだけを含むならば、準拠している型は、&lt;e6&gt;少なくとも&lt;/e6&gt;ゲッター節を実装しなければなりません、そして随意にセッター節を実装することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the total number of steps has increased, a message is printed to indicate how many new steps have been taken.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総歩数が増加したならば、どれくらいの新たな歩数がとられたかについて示すためにメッセージが出力されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the trailing closure is the function’s only argument, the parentheses can be omitted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>後付クロージャが関数のただ１つの引数であるならば、括弧は省略されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the tuple type to be returned from a function has the potential to have “no value” for the entire tuple, you can use an &lt;e0&gt;optional&lt;/e0&gt; tuple return type to reflect the fact that the entire tuple can be &lt;c1&gt;&lt;s2&gt;nil&lt;/s2&gt;&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある関数から返されるタプル型がタプル全体として「値がない」見込みがあるならば、あなたはタプル全体が&lt;c1&gt;&lt;s2&gt;nil&lt;/s2&gt;&lt;/c1&gt;であることが出来るのを反映するために&lt;e0&gt;オプショナル&lt;/e0&gt;タプルの戻り型を使うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the two items aren’t equal, then the two containers don’t match, and the function returns &lt;c12&gt;&lt;s13&gt;false&lt;/s13&gt;&lt;/c12&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つの項目が等しくないならば、２つのコンテナは合致しません、そして関数は&lt;c12&gt;&lt;s13&gt;false&lt;/s13&gt;&lt;/c12&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the type already implements all of the requirements, you can leave the body of the extension declaration empty.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その型が要件の全てをすでに実装するならば、あなたは拡張宣言の本文を空のままにしておいてかまいません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the type conversion cannot maintain the value, the initializer fails.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型変換が値を維持できないならば、イニシャライザは失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the type defines both a call-as-function method and one of the methods used by the &lt;c6&gt;&lt;s7&gt;dynamicCallable&lt;/s7&gt;&lt;/c6&gt; attribute, the compiler gives preference to the call-as-function method in circumstances where either method could be used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その型がcall-as-functionメソッドと&lt;c6&gt;&lt;s7&gt;dynamicCallable&lt;/s7&gt;&lt;/c6&gt;によって使われるメソッドの１つを両方とも定義するならば、コンパイラは、どちらのメソッドも使用できる環境ではcall-as-functionメソッドを優先します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the type of the expression’s value is a class, you can mark the expression in a capture list with &lt;c0&gt;&lt;s1&gt;weak&lt;/s1&gt;&lt;/c0&gt; or &lt;c2&gt;&lt;s3&gt;unowned&lt;/s3&gt;&lt;/c2&gt; to capture a weak or unowned reference to the expression’s value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この式の値の型がクラスならば、あなたはその式をキャプチャリストの中で&lt;c0&gt;&lt;s1&gt;weak&lt;/s1&gt;&lt;/c0&gt;または&lt;c2&gt;&lt;s3&gt;unowned&lt;/s3&gt;&lt;/c2&gt;を使って印を付けて、式の値に対する弱いまたは非所有の参照をキャプチャすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the type they extend is also in the same file, they share the type’s access-control scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらが拡張した型もまた同じファイルにあるならば、それらはその型のもつアクセス制御スコープを共有します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the type you are trying to retrieve is &lt;e0&gt;already&lt;/e0&gt; optional, it will not become &lt;e1&gt;more&lt;/e1&gt; optional because of the chaining.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが取り出そうとしている型が&lt;e0&gt;すでに&lt;/e0&gt;オプショナルならば、それは連鎖であることから&lt;e1&gt;さらに&lt;/e1&gt;オプショナルにはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the type you are trying to retrieve is not optional, it will become optional because of the optional chaining.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが取り出そうとしている型がオプショナルでないならば、それはオプショナル連鎖であることからオプショナルになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the value before the &lt;c2&gt;&lt;s3&gt;?&lt;/s3&gt;&lt;/c2&gt; is &lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;, everything after the &lt;c6&gt;&lt;s7&gt;?&lt;/s7&gt;&lt;/c6&gt; is ignored and the value of the whole expression is &lt;c8&gt;&lt;s9&gt;nil&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;?&lt;/s3&gt;&lt;/c2&gt;の前の値が&lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;ならば、&lt;c6&gt;&lt;s7&gt;?&lt;/s7&gt;&lt;/c6&gt;の後のすべてのものは、無視されて、その全体の式の値は&lt;c8&gt;&lt;s9&gt;nil&lt;/s9&gt;&lt;/c8&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the value is &lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;, no operation is performed and therefore no runtime error is produced.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その値が&lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;ならば、演算は実行されません、したがって、実行時エラーは生じません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the value of &lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt;&lt;/c0&gt; is non-&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;, the value of &lt;c4&gt;&lt;s5&gt;b&lt;/s5&gt;&lt;/c4&gt; is not evaluated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt;&lt;/c0&gt;の値が&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;でないならば、&lt;c4&gt;&lt;s5&gt;b&lt;/s5&gt;&lt;/c4&gt;の値は評価されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the value of &lt;c14&gt;&lt;s15&gt;a&lt;/s15&gt;&lt;/c14&gt; is equal to &lt;c16&gt;&lt;s17&gt;b&lt;/s17&gt;&lt;/c16&gt;, then the resulting range will be empty.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c14&gt;&lt;s15&gt;a&lt;/s15&gt;&lt;/c14&gt;の値が&lt;c16&gt;&lt;s17&gt;b&lt;/s17&gt;&lt;/c16&gt;と等しいならば、そのとき結果として生じる範囲は空になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the value of &lt;c8&gt;&lt;s9&gt;age&lt;/s9&gt;&lt;/c8&gt; is negative, as in the code above, then &lt;c10&gt;&lt;s11&gt;age&lt;/s11&gt; &lt;s12&gt;&gt;=&lt;/s12&gt; &lt;s13&gt;0&lt;/s13&gt;&lt;/c10&gt; evaluates to &lt;c14&gt;&lt;s15&gt;false&lt;/s15&gt;&lt;/c14&gt;, and the assertion fails, terminating the application.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c8&gt;&lt;s9&gt;age&lt;/s9&gt;&lt;/c8&gt;の値が負であるならば、上のコードでのように、そのとき&lt;c10&gt;&lt;s11&gt;age&lt;/s11&gt; &lt;s12&gt;&gt;=&lt;/s12&gt; &lt;s13&gt;0&lt;/s13&gt;&lt;/c10&gt;は&lt;c14&gt;&lt;s15&gt;false&lt;/s15&gt;&lt;/c14&gt;に評価され、そして表明は失敗して、アプリケーションを終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the value of &lt;c8&gt;&lt;s9&gt;integerToDescribe&lt;/s9&gt;&lt;/c8&gt; is one of the prime numbers in the list, the function appends text to the end of &lt;c10&gt;&lt;s11&gt;description&lt;/s11&gt;&lt;/c10&gt;, to note that the number is prime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c8&gt;&lt;s9&gt;integerToDescribe&lt;/s9&gt;&lt;/c8&gt;の値がリストにある素数の１つであるならば、数が素数であることを書き留めるために、関数は&lt;c10&gt;&lt;s11&gt;description&lt;/s11&gt;&lt;/c10&gt;の終わりにテキストを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the value of the &lt;e0&gt;expression&lt;/e0&gt; is not &lt;c1&gt;&lt;s2&gt;nil&lt;/s2&gt;&lt;/c1&gt;, the optional value is unwrapped and returned with the corresponding non-optional type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;式&lt;/e0&gt;の値が&lt;c1&gt;&lt;s2&gt;nil&lt;/s2&gt;&lt;/c1&gt;でないならば、オプショナルの値は包装を取られて（アンラップされて）、対応する非オプショナル型で返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the value of the expression does not match the value of the return type declared in the function or method declaration, the expression’s value is converted to the return type before it is returned to the calling function or method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>式の値が関数またはメソッド宣言において宣言される戻り型の値にマッチしないならば、それが関数またはメソッドを呼んでいるところに返される前に、式の値は戻り型に変換されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the value of the optional-chaining expression is &lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;, all of the other operations in the postfix expression are ignored and the entire postfix expression evaluates to &lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖式の値が&lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;ならば、接尾辞式での他の演算の全ては無視されます、そして接尾辞式の全体は&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the value of the optional-chaining expression is &lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;, the expression on the right-hand side of the assignment operator is not evaluated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖式の値が&lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;ならば、代入演算子の右手側での式は評価されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the value of the optional-chaining expression is not &lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;, the value of the optional-chaining expression is unwrapped and used to evaluate the rest of the postfix expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖式の値が&lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;でないならば、オプショナル連鎖式の値はアンラップされて、接尾辞式の残りを評価するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the value returned is not &lt;c9&gt;&lt;s10&gt;nil&lt;/s10&gt;&lt;/c9&gt;, it is assigned to the &lt;e11&gt;item&lt;/e11&gt; pattern, the program executes the &lt;e12&gt;statements&lt;/e12&gt;, and then continues execution at the beginning of the loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>返される値が&lt;c9&gt;&lt;s10&gt;nil&lt;/s10&gt;&lt;/c9&gt;でないならば、それは&lt;e11&gt;item（項目）&lt;/e11&gt;パターンに割り当てられて、プログラムは&lt;e12&gt;statements（文）&lt;/e12&gt;を実行して、それからループの初めに戻って実行を続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are expressions of multiple types, &lt;c4&gt;&lt;s5&gt;T&lt;/s5&gt;&lt;/c4&gt; is their closest common supertype.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数の型の式があるならば、&lt;c4&gt;&lt;s5&gt;T&lt;/s5&gt;&lt;/c4&gt;はそれらの最も近い共通のスーパー型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are expressions of multiple types, &lt;c7&gt;&lt;s8&gt;Key&lt;/s8&gt;&lt;/c7&gt; and &lt;c9&gt;&lt;s10&gt;Value&lt;/s10&gt;&lt;/c9&gt; are the closest common supertype for their respective values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数の型の式があるならば、&lt;c7&gt;&lt;s8&gt;Key&lt;/s8&gt;&lt;/c7&gt;と&lt;c9&gt;&lt;s10&gt;Value&lt;/s10&gt;&lt;/c9&gt;はそれらめいめいの値に対して最も近い共通のスーパー型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are multiple in-out parameters, the write accesses start in the same order as the parameters appear.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数のin-outパラメータが存在するならば、書き込みアクセスはパラメータが現れるのと同じ順番で始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are not enough coins, &lt;c2&gt;&lt;s3&gt;Bank&lt;/s3&gt;&lt;/c2&gt; returns a smaller number than the number that was requested (and returns zero if no coins are left in the bank).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>十分なコインがないならば、&lt;c2&gt;&lt;s3&gt;Bank&lt;/s3&gt;&lt;/c2&gt;は要請された数より少ない数を返します（そしてコインが胴元に残っていないならばゼロを返します）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there isn’t suitable type information available, Swift infers that the literal’s type is one of the default literal types defined in the Swift standard library.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>適した型情報が得られなかったならば、スウィフトはそのリテラルの型はスウィフト標準ライブラリで定義される省略時のリテラル型の１つと推論します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If they contain a different number of items, there’s no way that they can match, and the function returns &lt;c2&gt;&lt;s3&gt;false&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらが異なる数の項目を含むならば、それらが合致することができる術はありません、そして関数は&lt;c2&gt;&lt;s3&gt;false&lt;/s3&gt;&lt;/c2&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this check is not performed, &lt;c0&gt;&lt;s1&gt;board[square]&lt;/s1&gt;&lt;/c0&gt; might try to access a value outside the bounds of the &lt;c2&gt;&lt;s3&gt;board&lt;/s3&gt;&lt;/c2&gt; array, which would trigger a runtime error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この確認が行われなかったならば、&lt;c0&gt;&lt;s1&gt;board[square]&lt;/s1&gt;&lt;/c0&gt;は&lt;c2&gt;&lt;s3&gt;board&lt;/s3&gt;&lt;/c2&gt;配列の境界外で値にアクセスしようとするかもしれません、それは実行時エラーを引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this is successful, set a new temporary constant called &lt;c4&gt;&lt;s5&gt;movie&lt;/s5&gt;&lt;/c4&gt; to the value stored in the returned optional &lt;c6&gt;&lt;s7&gt;Movie&lt;/s7&gt;&lt;/c6&gt;.”</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これが成功するならば、&lt;c4&gt;&lt;s5&gt;movie&lt;/s5&gt;&lt;/c4&gt;と呼ばれる新しい一時的な定数を、返されたオプショナルの&lt;c6&gt;&lt;s7&gt;Movie&lt;/s7&gt;&lt;/c6&gt;に格納される値に設定してください。」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this isn’t the case, &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt; is preferred, even when the values to be stored are known to be nonnegative.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この場合でないならば、保存される値が負数でないことがわかっている時でさえ、&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;がむしろ好まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If type information can be inferred, you can write an empty array as &lt;c0&gt;&lt;s1&gt;[]&lt;/s1&gt;&lt;/c0&gt; and an empty dictionary as &lt;c2&gt;&lt;s3&gt;[:]&lt;/s3&gt;&lt;/c2&gt;—for example, when you set a new value for a variable or pass an argument to a function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型情報が推論されることが出来るならば、あなたは空の配列を&lt;c0&gt;&lt;s1&gt;[]&lt;/s1&gt;&lt;/c0&gt;のように、そして空の辞書を&lt;c2&gt;&lt;s3&gt;[:]&lt;/s3&gt;&lt;/c2&gt;のように書くことができます ― 例えば、あなたが新しい値を変数に設定したり、関数に引数を渡す時に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If we’ve entered the correct door code and passed the retina scan, or if we have a valid door key, or if we know the emergency override password, then allow access.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>私達が正しいドア・コードを入力して網膜走査をパスしたならば、または私達が有効なドア・キーを持つならば、または私達が非常用解除パスワードを知っているならば、その時アクセスを許可してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you access the variable or property after the object has been deallocated, its value is &lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが変数またはプロパティにそのオブジェクトがデアロケートされてしまった後にアクセスするならば、それの値は&lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you add additional cases in the future, the compiler generates a warning to indicate that you need to update the switch statement to take the new cases into account.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが追加のケース節を将来において加えるならば、コンパイラは警告を生成して、あなたがスイッチ文を更新して新しいケース節を考慮に入れる必要があることを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you apply the &lt;c0&gt;&lt;s1&gt;objc&lt;/s1&gt;&lt;/c0&gt; attribute to an enumeration, each enumeration case is exposed to Objective-C code as the concatenation of the enumeration name and the case name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが&lt;c0&gt;&lt;s1&gt;objc&lt;/s1&gt;&lt;/c0&gt;属性をある列挙に適応したならば、個々の列挙ケース節はObjective-Cコードに列挙名とそのケース節名を連結したものとして暴露されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are familiar with C, you will know that C enumerations assign related names to a set of integer values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがCに精通しているならば、あなたはCの列挙がひとまとめの整数値それぞれに対して関連した名前を割り当てるということを知っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are working with particularly long string values, be aware that the &lt;c0&gt;&lt;s1&gt;count&lt;/s1&gt;&lt;/c0&gt; property must iterate over the Unicode scalars in the entire string in order to determine the characters for that string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが特に長い文字列値を扱う場合は、&lt;c0&gt;&lt;s1&gt;count&lt;/s1&gt;&lt;/c0&gt;プロパティは、その文字列の文字を決定する目的で文字列全体のユニコード・スカラーのすべてに繰り返しを行わなければならないことを知っていてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you ask it to store a larger number, it stores 12 instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがそれにより大きな数を格納するように頼むならば、それは代わりに12を格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you assign a closure to a property of a class instance, and the closure captures that instance by referring to the instance or its members, you will create a strong reference cycle between the closure and the instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが、あるクロージャをあるクラスインスタンスのプロパティに代入して、そしてクロージャがそのインスタンスを、インスタンスまたはそのメンバ（属するもの）に言及することによって捕獲するならば、あなたはクロージャとインスタンスの間で強い参照循環をつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you assign a non-&lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt; value to &lt;c2&gt;&lt;s3&gt;userDefinedColorName&lt;/s3&gt;&lt;/c2&gt; and perform the nil-coalescing operator check again, the value wrapped inside &lt;c4&gt;&lt;s5&gt;userDefinedColorName&lt;/s5&gt;&lt;/c4&gt; is used instead of the default:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが&lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;でない値を&lt;c2&gt;&lt;s3&gt;userDefinedColorName&lt;/s3&gt;&lt;/c2&gt;に代入して、nil合体演算子による確認をふたたび実行するならば、&lt;c4&gt;&lt;s5&gt;userDefinedColorName&lt;/s5&gt;&lt;/c4&gt;内にラップされた値は省略時のものの代わりに使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you assign a value to a property within its own &lt;c4&gt;&lt;s5&gt;didSet&lt;/s5&gt;&lt;/c4&gt; observer, the new value that you assign replaces the one that was just set.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが独自の&lt;c4&gt;&lt;s5&gt;didSet&lt;/s5&gt;&lt;/c4&gt;オブザーバーの内部で値をプロパティに代入するならば、あなたが代入する新しい値はついさっき設定されたものを置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you assign an array, a set, or a dictionary to a constant, that collection is &lt;e2&gt;immutable&lt;/e2&gt;, and its size and contents cannot be changed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある配列、集合、または辞書をある定数に代入したならば、そのコレクションは&lt;e2&gt;不変&lt;/e2&gt;になります、そしてそれの大きさと内容は変更されることが出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you assign an instance of a reference type to a constant, you can still change that instance’s variable properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが参照型のインスタンスを定数に代入するならば、あなたは依然としてそのインスタンスの変数プロパティを変えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you assign the same &lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt; instance to two more variables, two more strong references to that instance are established:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが同じ&lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt;インスタンスをさらに２つの変数に代入するならば、そのインスタンスへのさらに２つの強い参照が確立されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you break &lt;e4&gt;that&lt;/e4&gt; strong reference, there are no more strong references to the &lt;c5&gt;&lt;s6&gt;Apartment&lt;/s6&gt;&lt;/c5&gt; instance:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが&lt;e4&gt;その&lt;/e4&gt;強い参照を壊すならば、&lt;c5&gt;&lt;s6&gt;Apartment&lt;/s6&gt;&lt;/c5&gt;インスタンスへの強い参照はもうこれ以上ありません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you break two of these strong references (including the original reference) by assigning &lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt; to two of the variables, a single strong reference remains, and the &lt;c2&gt;&lt;s3&gt;Person&lt;/s3&gt;&lt;/c2&gt; instance is not deallocated:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが変数のうちの２つに&lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;を代入することによってこれらの強い参照のうちの（最初の参照を含む）２つを壊すならば、１つの強い参照が残ります、そして&lt;c2&gt;&lt;s3&gt;Person&lt;/s3&gt;&lt;/c2&gt;インスタンスは割り当て解除されません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you call &lt;c10&gt;&lt;s11&gt;resize(to:&lt;/s11&gt; &lt;s12&gt;.large)&lt;/s12&gt;&lt;/c10&gt;, the switch case for &lt;c13&gt;&lt;s14&gt;.large&lt;/s14&gt;&lt;/c13&gt; sets the rectangle’s height and width to 100.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが&lt;c10&gt;&lt;s11&gt;resize(to:&lt;/s11&gt; &lt;s12&gt;.large)&lt;/s12&gt;&lt;/c10&gt;を呼び出すならば、&lt;c13&gt;&lt;s14&gt;.large&lt;/s14&gt;&lt;/c13&gt;に対するスイッチケース節は、矩形のもつ高さと幅を100に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you call this function with a &lt;c0&gt;&lt;s1&gt;Square&lt;/s1&gt;&lt;/c0&gt;, it returns a &lt;c2&gt;&lt;s3&gt;Square&lt;/s3&gt;&lt;/c2&gt;; otherwise, it returns a &lt;c4&gt;&lt;s5&gt;FlippedShape&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがこの関数を&lt;c0&gt;&lt;s1&gt;Square&lt;/s1&gt;&lt;/c0&gt;で呼び出すならば、それは&lt;c2&gt;&lt;s3&gt;Square&lt;/s3&gt;&lt;/c2&gt;を返します；そうでなければ、それは&lt;c4&gt;&lt;s5&gt;FlippedShape&lt;/s5&gt;&lt;/c4&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you call this method on an optional value with optional chaining, the method’s return type will be &lt;c0&gt;&lt;s1&gt;Void?&lt;/s1&gt;&lt;/c0&gt;, not &lt;c2&gt;&lt;s3&gt;Void&lt;/s3&gt;&lt;/c2&gt;, because return values are always of an optional type when called through optional chaining.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがこのメソッドをあるオプショナルの値の上でオプショナル連鎖を使って呼ぶならば、メソッドの戻り値は&lt;c0&gt;&lt;s1&gt;Void?&lt;/s1&gt;&lt;/c0&gt;になります、&lt;c2&gt;&lt;s3&gt;Void&lt;/s3&gt;&lt;/c2&gt;ではなく、なぜならば、オプショナル連鎖を通して呼び出されるとき戻り値は常にオプショナルだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you combine integer and floating-point literals in an expression, a type of &lt;c0&gt;&lt;s1&gt;Double&lt;/s1&gt;&lt;/c0&gt; will be inferred from the context:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある式の中で整数と浮動小数点リテラルを結合するならば、その前後関係から&lt;c0&gt;&lt;s1&gt;Double&lt;/s1&gt;&lt;/c0&gt;の型が推論されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you compile in unchecked mode (&lt;c0&gt;&lt;s1&gt;-Ounchecked&lt;/s1&gt;&lt;/c0&gt;), preconditions aren’t checked.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが未検査モード（&lt;c0&gt;&lt;s1&gt;-Ounchecked&lt;/s1&gt;&lt;/c0&gt;）でコンパイルするならば、前提条件は調べられません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you create a &lt;c0&gt;&lt;s1&gt;CartItem&lt;/s1&gt;&lt;/c0&gt; instance with a nonempty name and a quantity of &lt;c2&gt;&lt;s3&gt;1&lt;/s3&gt;&lt;/c2&gt; or more, initialization succeeds:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが&lt;c0&gt;&lt;s1&gt;CartItem&lt;/s1&gt;&lt;/c0&gt;インスタンスを空でない名前と&lt;c2&gt;&lt;s3&gt;1&lt;/s3&gt;&lt;/c2&gt;以上の数量で作成するならば、初期化は成功します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you create a &lt;c0&gt;&lt;s1&gt;TrackedString&lt;/s1&gt;&lt;/c0&gt; instance and modify its string value a few times, you can see the &lt;c2&gt;&lt;s3&gt;numberOfEdits&lt;/s3&gt;&lt;/c2&gt; property value update to match the number of modifications:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが&lt;c0&gt;&lt;s1&gt;TrackedString&lt;/s1&gt;&lt;/c0&gt;インスタンスをつくって、２、３回その文字列値を修正するならば、あなたは&lt;c2&gt;&lt;s3&gt;numberOfEdits&lt;/s3&gt;&lt;/c2&gt;プロパティが修正の数に合うように更新されるのを見ることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you create a new &lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt; instance, its &lt;c2&gt;&lt;s3&gt;residence&lt;/s3&gt;&lt;/c2&gt; property is default initialized to &lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;, by virtue of being optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが新しい&lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt;インスタンスをつくるならば、その&lt;c2&gt;&lt;s3&gt;residence&lt;/s3&gt;&lt;/c2&gt;プロパティは、オプショナルである長所によって、省略時で&lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;に初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you create a new &lt;c3&gt;&lt;s4&gt;String&lt;/s4&gt;&lt;/c3&gt; value, that &lt;c5&gt;&lt;s6&gt;String&lt;/s6&gt;&lt;/c5&gt; value is &lt;e7&gt;copied&lt;/e7&gt; when it’s passed to a function or method, or when it’s assigned to a constant or variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが新しい&lt;c3&gt;&lt;s4&gt;String&lt;/s4&gt;&lt;/c3&gt;値をつくるならば、その&lt;c5&gt;&lt;s6&gt;String&lt;/s6&gt;&lt;/c5&gt;値は、それが関数またはメソッドに渡される時に、またはそれが定数または変数に代入される時に、&lt;e7&gt;コピーされます&lt;/e7&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you create a new instance of &lt;c0&gt;&lt;s1&gt;Train&lt;/s1&gt;&lt;/c0&gt; and call its &lt;c2&gt;&lt;s3&gt;makeNoise()&lt;/s3&gt;&lt;/c2&gt; method, you can see that the &lt;c4&gt;&lt;s5&gt;Train&lt;/s5&gt;&lt;/c4&gt; subclass version of the method is called:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが&lt;c0&gt;&lt;s1&gt;Train&lt;/s1&gt;&lt;/c0&gt;の新しいインスタンスを作成してそれの&lt;c2&gt;&lt;s3&gt;makeNoise()&lt;/s3&gt;&lt;/c2&gt;メソットを呼び出すならば、あなたはサブクラス板の&lt;c4&gt;&lt;s5&gt;Train&lt;/s5&gt;&lt;/c4&gt;メソッドが呼び出されるのを見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you create a second incrementer, it will have its own stored reference to a new, separate &lt;c0&gt;&lt;s1&gt;runningTotal&lt;/s1&gt;&lt;/c0&gt; variable:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが第２のインクリメンタをつくるならば、それは、独自に格納された、ある新しい、別個の&lt;c0&gt;&lt;s1&gt;runningTotal&lt;/s1&gt;&lt;/c0&gt;変数への参照を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you create a second player, whom you try to move to a level that is not yet unlocked by any player in the game, the attempt to set the player’s current level fails:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが二番目のプレーヤーを作成して、あなたがその人をそのゲームにおいてどのプレーヤーによってもまだ錠を開けられていないレベルへ動かそうとするならば、プレーヤーの現在のレベルを決めるその試みは失敗します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you create an array, a set, or a dictionary, and assign it to a variable, the collection that is created will be &lt;e0&gt;mutable&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある配列、集合、または辞書を作成して、それをある変数に代入したならば、作成されたコレクションは&lt;e0&gt;可変&lt;/e0&gt;となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you create an instance of &lt;c0&gt;&lt;s1&gt;Bicycle&lt;/s1&gt;&lt;/c0&gt;, you can call its inherited &lt;c2&gt;&lt;s3&gt;description&lt;/s3&gt;&lt;/c2&gt; computed property to see how its &lt;c4&gt;&lt;s5&gt;numberOfWheels&lt;/s5&gt;&lt;/c4&gt; property has been updated:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが&lt;c0&gt;&lt;s1&gt;Bicycle&lt;/s1&gt;&lt;/c0&gt;のインスタンスを作成するならば、あなたはそれの継承された&lt;c2&gt;&lt;s3&gt;description&lt;/s3&gt;&lt;/c2&gt;計算プロパティを呼び出して、どのようにそれの&lt;c4&gt;&lt;s5&gt;numberOfWheels&lt;/s5&gt;&lt;/c4&gt;プロパティが更新されたか見ることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you create an instance of &lt;c0&gt;&lt;s1&gt;Tandem&lt;/s1&gt;&lt;/c0&gt;, you can work with any of its new and inherited properties, and query the read-only &lt;c2&gt;&lt;s3&gt;description&lt;/s3&gt;&lt;/c2&gt; property it inherits from &lt;c4&gt;&lt;s5&gt;Vehicle&lt;/s5&gt;&lt;/c4&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが&lt;c0&gt;&lt;s1&gt;Tandem&lt;/s1&gt;&lt;/c0&gt;のインスタンスを作成するならば、あなたはそれの新規および継承するプロパティを扱うことができて、それが&lt;c4&gt;&lt;s5&gt;Vehicle&lt;/s5&gt;&lt;/c4&gt;から継承する読み込み専用の&lt;c2&gt;&lt;s3&gt;description&lt;/s3&gt;&lt;/c2&gt;プロパティについて問い合わせることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you create an instance of a structure and assign that instance to a constant, you cannot modify the instance’s properties, even if they were declared as variable properties:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが構造体のインスタンスをつくって、そのインスタンスを定数に代入するならば、あなたはそのインスタンスのもつプロパティを、たとえそれらが変数プロパティとして宣言されたとしても、修正することはできません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you create an instance of the &lt;c0&gt;&lt;s1&gt;Car&lt;/s1&gt;&lt;/c0&gt; class and set its &lt;c2&gt;&lt;s3&gt;gear&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;currentSpeed&lt;/s5&gt;&lt;/c4&gt; properties, you can see that its &lt;c6&gt;&lt;s7&gt;description&lt;/s7&gt;&lt;/c6&gt; property returns the tailored description defined within the &lt;c8&gt;&lt;s9&gt;Car&lt;/s9&gt;&lt;/c8&gt; class:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが&lt;c0&gt;&lt;s1&gt;Car&lt;/s1&gt;&lt;/c0&gt;クラスのインスタンスを作成して、それの&lt;c2&gt;&lt;s3&gt;gear&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;currentSpeed&lt;/s5&gt;&lt;/c4&gt;プロパティを設定するならば、あなたはそれの&lt;c6&gt;&lt;s7&gt;description&lt;/s7&gt;&lt;/c6&gt;プロパティが&lt;c8&gt;&lt;s9&gt;Car&lt;/s9&gt;&lt;/c8&gt;クラス内で定義される特注の説明を返すのを見ることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you create and assign an actual &lt;c0&gt;&lt;s1&gt;Residence&lt;/s1&gt;&lt;/c0&gt; instance to &lt;c2&gt;&lt;s3&gt;john.residence&lt;/s3&gt;&lt;/c2&gt;, with one or more &lt;c4&gt;&lt;s5&gt;Room&lt;/s5&gt;&lt;/c4&gt; instances in its &lt;c6&gt;&lt;s7&gt;rooms&lt;/s7&gt;&lt;/c6&gt; array, you can use the &lt;c8&gt;&lt;s9&gt;Residence&lt;/s9&gt;&lt;/c8&gt; subscript to access the actual items in the &lt;c10&gt;&lt;s11&gt;rooms&lt;/s11&gt;&lt;/c10&gt; array through optional chaining:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが実際の&lt;c0&gt;&lt;s1&gt;Residence&lt;/s1&gt;&lt;/c0&gt;インスタンスをつくって&lt;c2&gt;&lt;s3&gt;john.residence&lt;/s3&gt;&lt;/c2&gt;に代入して、その&lt;c6&gt;&lt;s7&gt;rooms&lt;/s7&gt;&lt;/c6&gt;配列の中に１つ以上の&lt;c4&gt;&lt;s5&gt;Room&lt;/s5&gt;&lt;/c4&gt;インスタンスをもつならば、あなたは&lt;c8&gt;&lt;s9&gt;Residence&lt;/s9&gt;&lt;/c8&gt;添え字を使って、オプショナル連鎖を通して&lt;c10&gt;&lt;s11&gt;rooms&lt;/s11&gt;&lt;/c10&gt;配列の実際の項目にアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you create your own class or structure to represent a complex data model, for example, then the meaning of “equal to” for that class or structure isn’t something that Swift can guess for you.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが例えば独自のクラスまたは構造体を作成してある複合データモデルを表すならば、そのときそのクラスまたは構造体のための「同等」の意味することはスウィフトがあなたのために推測することができる何かではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you define a new protocol that inherits from an existing protocol, the new protocol can have at most the same access level as the protocol it inherits from.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが既存のプロトコルから継承する新しいプロトコルを定義するならば、新しいプロトコルは最大ではそれが継承するプロトコルと同じアクセス水準を持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you define a protocol instance method requirement that is intended to mutate instances of any type that adopts the protocol, mark the method with the &lt;c0&gt;&lt;s1&gt;mutating&lt;/s1&gt;&lt;/c0&gt; keyword as part of the protocol’s definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがそのプロトコルを採用するあらゆる型のインスタンスを変化させることを意図したインスタンスメソッド要件プロトコルを定義するならば、プロトコルの定義の一部としてそのメソッドに&lt;c0&gt;&lt;s1&gt;mutating&lt;/s1&gt;&lt;/c0&gt;キーワードで印をつけてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you define a public protocol, the protocol’s requirements require a public access level for those requirements when they’re implemented.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある公開プロトコルを定義するならば、そのプロトコルの持つ要件は、それら要件に対してそれらが実装されるときに公開アクセス水準を必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you define a type’s access level as internal or public (or use the default access level of internal without specifying an access level explicitly), the default access level of the type’s members will be internal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある型のアクセス水準を内部または公開として定義する（または明示的にアクセス水準を指定することなく省略時のアクセス水準である内部を使用する）ならば、その型のメンバーの省略時のアクセス水準は内部になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you define a type’s access level as private or file private, the default access level of its members will also be private or file private.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある型のアクセス水準を非公開またはファイル外非公開として定義するならば、そのメンバーの省略時のアクセス水準も、非公開またはファイル外非公開になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you define an enumeration with a raw-value type, the enumeration automatically receives an initializer that takes a value of the raw value’s type (as a parameter called &lt;c0&gt;&lt;s1&gt;rawValue&lt;/s1&gt;&lt;/c0&gt;) and returns either an enumeration case or &lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが列挙を「生の値」型を使って定義したならば、その列挙は生の値の方の値を（&lt;c0&gt;&lt;s1&gt;rawValue&lt;/s1&gt;&lt;/c0&gt;と呼ばれるパラメーターとして）とって、１つの列挙ケース節か&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;のどちらかを返すイニシャライザを自動的に受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you define an extension to add new functionality to an existing type, the new functionality will be available on all existing instances of that type, even if they were created before the extension was defined.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが新しい機能性を既存の型に加えるために拡張を定義するならば、新しい機能性はその型の全ての既存の例で利用可能になります、たとえそれらが拡張が定義される前につくられたとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you define an optional variable without providing a default value, the variable is automatically set to &lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt; for you:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが既定値を提供することなくオプショナルの変数を定義するならば、その変数はあなたのために自動的に&lt;c0&gt;&lt;s1&gt;nilに&lt;/s1&gt;&lt;/c0&gt;設定されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you didn’t mark the parameter of this function with &lt;c2&gt;&lt;s3&gt;@escaping&lt;/s3&gt;&lt;/c2&gt;, you would get a compile-time error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがこの関数のパラメータを&lt;c2&gt;&lt;s3&gt;@escaping&lt;/s3&gt;&lt;/c2&gt;で印しないならば、あなたはコンパイル時エラーを得るでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you do not provide a setter name, the default parameter name to the setter is &lt;c1&gt;&lt;s2&gt;newValue&lt;/s2&gt;&lt;/c1&gt;, as described in &lt;a3&gt;&lt;s4&gt;Shorthand Setter Declaration&lt;/s4&gt;&lt;/a3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがセッター名を提供しないならば、&lt;a3&gt;&lt;s4&gt;短縮形セッター宣言&lt;/s4&gt;&lt;/a3&gt;で記述されるように、セッターへの省略時のパラメータ名は&lt;c1&gt;&lt;s2&gt;newValue&lt;/s2&gt;&lt;/c1&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you do not provide a setter name, the default parameter name to the setter is &lt;c1&gt;&lt;s2&gt;value&lt;/s2&gt;&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがセッター名を提供しないならば、セッターへの省略時のパラメータ名は&lt;c1&gt;&lt;s2&gt;value&lt;/s2&gt;&lt;/c1&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you do not provide setter names, the default parameter name to the &lt;c9&gt;&lt;s10&gt;willSet&lt;/s10&gt;&lt;/c9&gt; observer is &lt;c11&gt;&lt;s12&gt;newValue&lt;/s12&gt;&lt;/c11&gt; and the default parameter name to the &lt;c13&gt;&lt;s14&gt;didSet&lt;/s14&gt;&lt;/c13&gt; observer is &lt;c15&gt;&lt;s16&gt;oldValue&lt;/s16&gt;&lt;/c15&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがセッター名を提供しないならば、&lt;c9&gt;&lt;s10&gt;willSet&lt;/s10&gt;&lt;/c9&gt;オブザーバーへの初期状態でのパラメータ名は&lt;c11&gt;&lt;s12&gt;newValue&lt;/s12&gt;&lt;/c11&gt;です、そして、&lt;c13&gt;&lt;s14&gt;didSet&lt;/s14&gt;&lt;/c13&gt;オブザーバーへの初期状態でのパラメータ名は&lt;c15&gt;&lt;s16&gt;oldValue&lt;/s16&gt;&lt;/c15&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you do not want to use an argument label for an initializer parameter, write an underscore (&lt;c0&gt;&lt;s1&gt;_&lt;/s1&gt;&lt;/c0&gt;) instead of an explicit argument label for that parameter to override the default behavior.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがイニシャライザ・パラメータのために引数ラベルを使うことを望まないならば、そのパラメータに対して明示的な引数ラベルを書くのではなくひとつのアンダーバー（&lt;c0&gt;&lt;s1&gt;_&lt;/s1&gt;&lt;/c0&gt;）を書いて、省略時の挙動をオーバーライドしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you don’t explicitly write &lt;c2&gt;&lt;s3&gt;self&lt;/s3&gt;&lt;/c2&gt;, Swift assumes that you are referring to a property or method of the current instance whenever you use a known property or method name within a method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが明示的に&lt;c2&gt;&lt;s3&gt;self&lt;/s3&gt;&lt;/c2&gt;を書かないならば、スウィフトは、あなたがメソッド内で既知のプロパティまたはメソッド名を使用するときはいつでも、あなたが現在のインスタンスに属するプロパティまたはメソッドに言及していると仮定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you don’t need each value from a sequence, you can ignore the values by using an underscore in place of a variable name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある連続物からの各値を必要としないならば、あなたは変数の名前の代わりにアンダースコアを使うことによってその値を無視することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you don’t need to compute the property but still need to provide code that is run before and after setting a new value, use &lt;c0&gt;&lt;s1&gt;willSet&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;didSet&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが、プロパティを計算する必要がないにもかかわらず新しい値の設定の前や後で実行されるコードを提供する必要があるならば、&lt;c0&gt;&lt;s1&gt;willSet&lt;/s1&gt;&lt;/c0&gt;や&lt;c2&gt;&lt;s3&gt;didSet&lt;/s3&gt;&lt;/c2&gt;を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you don’t provide an initial value when you declare an optional variable or property, its value automatically defaults to &lt;c6&gt;&lt;s7&gt;nil&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルの変数またはプロパティを宣言する時にあなたが最初の値を提供しないならば、その値は自動的に省略時の&lt;c6&gt;&lt;s7&gt;nil&lt;/s7&gt;&lt;/c6&gt;になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you don’t specify the type of value you need, Swift uses &lt;e0&gt;type inference&lt;/e0&gt; to work out the appropriate type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが必要とする値の型をあなたが指定しないならば、スウィフトは適切な型を導きだすために&lt;e0&gt;型推論&lt;/e0&gt;を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you don’t use this attribute, supply a &lt;c0&gt;&lt;s1&gt;main.swift&lt;/s1&gt;&lt;/c0&gt; file with code at the top level that calls the &lt;a2&gt;&lt;c3&gt;&lt;s4&gt;UIApplicationMain(_:_:_:_:)&lt;/s4&gt;&lt;/c3&gt;&lt;/a2&gt;&lt;s5&gt; [https://developer.apple.com/documentation/uikit/1622933-uiapplicationmain]&lt;/s5&gt; function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがこの属性を使わないならば、&lt;a2&gt;&lt;c3&gt;&lt;s4&gt;UIApplicationMain(_:_:_:_:)&lt;/s4&gt;&lt;/c3&gt;&lt;/a2&gt;&lt;s5&gt; [https://developer.apple.com/documentation/uikit/1622933-uiapplicationmain]&lt;/s5&gt;関数を呼ぶトップレベルでのコードを持つ&lt;c0&gt;&lt;s1&gt;main.swift&lt;/s1&gt;&lt;/c0&gt;ファイルを提供してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you don’t use this attribute, supply a &lt;c0&gt;&lt;s1&gt;main.swift&lt;/s1&gt;&lt;/c0&gt; file with code at the top level that calls the &lt;c2&gt;&lt;s3&gt;NSApplicationMain(_:_:)&lt;/s3&gt;&lt;/c2&gt; function as follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがこの属性を使わないならば、&lt;c2&gt;&lt;s3&gt;NSApplicationMain(_:_:)&lt;/s3&gt;&lt;/c2&gt;関数を呼ぶトップレベルコードを持つ&lt;c0&gt;&lt;s1&gt;main.swift&lt;/s1&gt;&lt;/c0&gt;ファイルを以下のように提供してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you don’t want an argument label for a parameter, write an underscore (&lt;c0&gt;&lt;s1&gt;_&lt;/s1&gt;&lt;/c0&gt;) instead of an explicit argument label for that parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがあるパラメーターに引数ラベルを使うことを望まないならば、そのパラメーターに対して明示的な引数ラベルの代わりにひとつのアンダースコア（&lt;c0&gt;&lt;s1&gt;_&lt;/s1&gt;&lt;/c0&gt;）を書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you don’t want to modify the inherited property’s value within the overriding getter, you can simply pass through the inherited value by returning &lt;c0&gt;&lt;s1&gt;super.someProperty&lt;/s1&gt;&lt;/c0&gt; from the getter, where &lt;c2&gt;&lt;s3&gt;someProperty&lt;/s3&gt;&lt;/c2&gt; is the name of the property you are overriding.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがオーバーライドのゲッター内で継承されたプロパティの値を修正したくないならば、あなたは、そのゲッターから&lt;c0&gt;&lt;s1&gt;super.someProperty&lt;/s1&gt;&lt;/c0&gt;を返すことによって、単に継承された値を通り抜けさせることができます、ここで&lt;c2&gt;&lt;s3&gt;someProperty&lt;/s3&gt;&lt;/c2&gt;はあなたがオーバーライドしているプロパティの名前です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you don’t write the parameter name and parentheses within your implementation, the parameter is made available with a default parameter name of &lt;c4&gt;&lt;s5&gt;newValue&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがパラメータ名と丸括弧をあなたの実装内で書かないならば、パラメータは省略時のパラメータ名の&lt;c4&gt;&lt;s5&gt;newValue&lt;/s5&gt;&lt;/c4&gt;を使って利用可能にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you extend a file-private type, any new type members you add have a default access level of file private.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがあるファイル外非公開型を拡張するならば、あなたが加えるどんな新しい型メンバーでも省略時のアクセス水準であるファイル外非公開を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you extend a private type, any new type members you add have a default access level of private.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある非公開型を拡張するならば、あなたが加えるどんな新しい型メンバーでも省略時のアクセス水準である非公開を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you extend a public or internal type, any new type members you add have a default access level of internal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある公開または内部型を拡張するならば、あなたが加えるどんな新しい型メンバーでも省略時のアクセス水準である内部を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you group together aspects of your app’s code as a stand-alone framework—perhaps to encapsulate and reuse that code across multiple applications—then everything you define within that framework will be part of a separate module when it’s imported and used within an app, or when it’s used within another framework.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが、あなたのアプリのコードのさまざまな面をスタンドアローンのフレームワークとして ― おそらくそのコードをカプセル化して複数のアプリケーションに渡って再利用するために ― １つにまとめるならば、あなたがそのフレームワーク内で定義するすべてのものは、それがアプリ内にインポートされて使われるとき、またはそれがもう１つのフレームワーク内で使われるとき、別々のモジュール部分になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have conflicting access to memory from within a single thread, Swift guarantees that you’ll get an error at either compile time or runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがシングルスレッド内部からのメモリアクセス衝突を起こしているならば、スウィフトはコンパイル時または実行時のどちらかであなたがエラーを得るのを保証します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have experience with C, C++, or Objective-C, you may know that these languages use &lt;e0&gt;pointers&lt;/e0&gt; to refer to addresses in memory.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがC、C++、またはObjective-Cで経験を持つならば、あなたはこれらの言語がメモリのアドレスに言及するために&lt;e0&gt;ポインター&lt;/e0&gt;を使用するということを知っているかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have experience with Objective-C, you may know that it provides &lt;e0&gt;two&lt;/e0&gt; ways to store values and references as part of a class instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがObjective-Cでの経験を持つならば、あなたはそれがクラスインスタンスの一部として値や参照を格納するために&lt;e0&gt;２つの&lt;/e0&gt;方法を提供するということを知っているかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have written code in C or Objective-C, this syntax looks familiar to you—in Swift, this line of code is a complete program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがCまたはObjective-Cでコードを書いたことがあるならば、この構文はあなたにとって馴染みがあるものでしょう ― スウィフトにおいて、コードのこの行は、ひとつの完全なプログラムです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you implement a &lt;c0&gt;&lt;s1&gt;willSet&lt;/s1&gt;&lt;/c0&gt; observer, it’s passed the new property value as a constant parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが&lt;c0&gt;&lt;s1&gt;willSet&lt;/s1&gt;&lt;/c0&gt;オブザーバーを実装するならば、それは新しいプロパティ値を定数パラメータとして渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you implement both &lt;c0&gt;&lt;s1&gt;dynamicallyCall&lt;/s1&gt;&lt;/c0&gt; methods, &lt;c2&gt;&lt;s3&gt;dynamicallyCall(withKeywordArguments:)&lt;/s3&gt;&lt;/c2&gt; is called when the method call includes keyword arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが両方の&lt;c0&gt;&lt;s1&gt;dynamicallyCall&lt;/s1&gt;&lt;/c0&gt;メソッドを実装するならば、&lt;c2&gt;&lt;s3&gt;dynamicallyCall(withKeywordArguments:)&lt;/s3&gt;&lt;/c2&gt;が呼び出されるのは、メソッド呼び出しがキーワード引数を含む時です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you implement the &lt;c0&gt;&lt;s1&gt;Togglable&lt;/s1&gt;&lt;/c0&gt; protocol for a structure or enumeration, that structure or enumeration can conform to the protocol by providing an implementation of the &lt;c2&gt;&lt;s3&gt;toggle()&lt;/s3&gt;&lt;/c2&gt; method that is also marked as &lt;c4&gt;&lt;s5&gt;mutating&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが&lt;c0&gt;&lt;s1&gt;Togglable&lt;/s1&gt;&lt;/c0&gt;プロトコルをある構造体または列挙のために実装するならば、その構造体または列挙は、同様に&lt;c4&gt;&lt;s5&gt;mutating&lt;/s5&gt;&lt;/c4&gt;として印される&lt;c2&gt;&lt;s3&gt;toggle()&lt;/s3&gt;&lt;/c2&gt;メソッドの実施を提供することによって、このプロトコルに準拠できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you mark a protocol instance method requirement as &lt;c0&gt;&lt;s1&gt;mutating&lt;/s1&gt;&lt;/c0&gt;, you don’t need to write the &lt;c2&gt;&lt;s3&gt;mutating&lt;/s3&gt;&lt;/c2&gt; keyword when writing an implementation of that method for a class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがインスタンスメソッド要件プロトコルに&lt;c0&gt;&lt;s1&gt;mutating&lt;/s1&gt;&lt;/c0&gt;として印するならば、あるクラスのためにそのメソッドの実装を書くとき、あなたは&lt;c2&gt;&lt;s3&gt;mutating&lt;/s3&gt;&lt;/c2&gt;キーワードを書く必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you mark an initializer with the &lt;c0&gt;&lt;s1&gt;required&lt;/s1&gt;&lt;/c0&gt; declaration modifier, you don’t also mark the initializer with the &lt;c2&gt;&lt;s3&gt;override&lt;/s3&gt;&lt;/c2&gt; modifier when you override the required initializer in a subclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがイニシャライザを&lt;c0&gt;&lt;s1&gt;required&lt;/s1&gt;&lt;/c0&gt;宣言修飾子で印するならば、あなたはさらにそのイニシャライザを&lt;c2&gt;&lt;s3&gt;override&lt;/s3&gt;&lt;/c2&gt;宣言修飾子で印することは、あなたがサブクラスの必須イニシャライザをオーバーライドする場合には、しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you name the elements in a tuple, you can use the element names to access the values of those elements:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがタプルの要素に名をつけるならば、あなたはそれらの要素の値にアクセスするために要素名を使用することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need C-style fallthrough behavior, you can opt in to this behavior on a case-by-case basis with the &lt;c0&gt;&lt;s1&gt;fallthrough&lt;/s1&gt;&lt;/c0&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがC形式のフォールスルー挙動を必要とするならば、あなたは&lt;c0&gt;&lt;s1&gt;fallthrough&lt;/s1&gt;&lt;/c0&gt;キーワードを使ってそれぞれ個別にこの挙動を選択できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need a string that spans several lines, use a multiline string literal—a sequence of characters surrounded by three double quotation marks:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがいくつかの行に及ぶ文字列を必要とするならば、複数行文字列リテラル — ３つの二重引用符で囲まれる一連の文字、を使ってください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need a type to conditionally conform to two protocols that inherit from a single parent, explicitly declare conformance to the parent protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある型に単一の親から継承する２つのプロトコルに対して条件準拠して欲しいならば、明示的に親プロトコルに対する準拠を宣言してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need the behavior of the &lt;c4&gt;&lt;s5&gt;swapTwoValues(_:_:)&lt;/s5&gt;&lt;/c4&gt; function in your own code, you can use Swift’s existing &lt;c6&gt;&lt;s7&gt;swap(_:_:)&lt;/s7&gt;&lt;/c6&gt; function rather than providing your own implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがあなた自身のコードにおいて&lt;c4&gt;&lt;s5&gt;swapTwoValues(_:_:)&lt;/s5&gt;&lt;/c4&gt;関数の挙動を必要とするならば、あなたはあなた自身の実施を提供するのではなくスウィフトの既存の&lt;c6&gt;&lt;s7&gt;swap(_:_:)&lt;/s7&gt;&lt;/c6&gt;関数を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need the integer index of each item as well as its value, use the &lt;c0&gt;&lt;s1&gt;enumerated()&lt;/s1&gt;&lt;/c0&gt; method to iterate over the array instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがその値のみならず各項目の整数インデックスを必要とするならば、代わりに&lt;c0&gt;&lt;s1&gt;enumerated()&lt;/s1&gt;&lt;/c0&gt;メソッドを配列じゅうを繰り返し処理するのに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need the special effects of a character in a string literal, match the number of number signs within the string following the escape character (&lt;c0&gt;&lt;s1&gt;\&lt;/s1&gt;&lt;/c0&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが文字列リテラルの中のある文字の特別な効果を必要とするならば、文字列内のエスケープ文字（&lt;c0&gt;&lt;s1&gt;\&lt;/s1&gt;&lt;/c0&gt;）に続くシャープ記号の数を一致させてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to add conditional conformance based on multiple concrete types, create a new protocol that each type can conform to and use that protocol as the requirement when declaring conditional conformance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが複数の具象型に基づく条件準拠を加える必要があるならば、それぞれの型が準拠できる新しいプロトコルを作成してください、そしてそのプロトコルを条件準拠を宣言する時に要件として使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to avoid this restriction, mark one of the parameters as escaping, or temporarily convert one of the nonescaping function parameters to an escaping function by using the &lt;c0&gt;&lt;s1&gt;withoutActuallyEscaping(_:do:)&lt;/s1&gt;&lt;/c0&gt; function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがこの規制を回避する必要があるならば、パラメータの１つを脱出すると印してください、または一時的に非脱出関数パラメータの１つを脱出関数へと&lt;c0&gt;&lt;s1&gt;withoutActuallyEscaping(_:do:)&lt;/s1&gt;&lt;/c0&gt;関数を使うことによって変換してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to capture an in-out parameter without mutating it or to observe changes made by other code, use a capture list to explicitly capture the parameter immutably.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがin-outパラメータをキャプチャする必要がそれを変化させることなしにまたは他のコードによってなされる変更を監視するためにあるならば、キャプチャリストを使うことで明示的にそのパラメータを不変にキャプチャしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to capture and mutate an in-out parameter, use an explicit local copy, such as in multithreaded code that ensures all mutation has finished before the function returns.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがin-outパラメータをキャプチャして変化させる必要があるならば、明示的なローカルコピーを使ってください、例えばすべての変化がその関数が返るまえに完了してしまっていることを保証するマルチスレッド化されたコードにおいてなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to convert a value to a different type, explicitly make an instance of the desired type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある値を異なる型に変換する必要があるならば、明示的に望む型のインスタンスにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to expose many declarations, you can group them in an extension that has the &lt;c2&gt;&lt;s3&gt;objc&lt;/s3&gt;&lt;/c2&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが多くの宣言を露出する必要があるならば、あなたはそれらを&lt;c2&gt;&lt;s3&gt;objc&lt;/s3&gt;&lt;/c2&gt;属性を持つある拡張にまとめることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to give a constant or variable the same name as a reserved Swift keyword, surround the keyword with backticks (&lt;c0&gt;&lt;s1&gt;`&lt;/s1&gt;&lt;/c0&gt;) when using it as a name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが予約済みのスウィフトのキーワードと同じ名前を定数または変数に与える必要があるならば、名前としてそれを使うときバッククォート（&lt;c0&gt;&lt;s1&gt;`&lt;/s1&gt;&lt;/c0&gt;）でそのキーワードを囲んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to pass a closure expression to a function as the function’s final argument and the closure expression is long, it can be useful to write it as a &lt;e0&gt;trailing closure&lt;/e0&gt; instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが関数の最後の引数としてクロージャ式を関数に渡す必要がある、そして、クロージャ式が長いならば、代わりに&lt;e0&gt;後付クロージャ&lt;/e0&gt;としてそれを書くことは役に立つことがありえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you need to use a dictionary’s keys or values with an API that takes an &lt;c0&gt;&lt;s1&gt;Array&lt;/s1&gt;&lt;/c0&gt; instance, initialize a new array with the &lt;c2&gt;&lt;s3&gt;keys&lt;/s3&gt;&lt;/c2&gt; or &lt;c4&gt;&lt;s5&gt;values&lt;/s5&gt;&lt;/c4&gt; property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが、ある辞書のキーまたは値を、&lt;c0&gt;&lt;s1&gt;Array&lt;/s1&gt;&lt;/c0&gt;インスタンスを引数にとるAPIで使う必要があるならば、&lt;c2&gt;&lt;s3&gt;keys&lt;/s3&gt;&lt;/c2&gt;または&lt;c4&gt;&lt;s5&gt;values&lt;/s5&gt;&lt;/c4&gt;プロパティによってひとつの新しい配列を初期化してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you omit the argument, the name used in Objective-C code matches the name in Swift code, and the runtime name follows the normal Swift compiler convention of name mangling.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが引数を省略するならば、Objective-Cコードにおいて使われる名前はSwiftコードにおける名前と合致します、そしてランタイム名は名前修飾の通常のSwiftコンパイラ慣例に従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you omit the parameter names and both types, omit the &lt;c0&gt;&lt;s1&gt;in&lt;/s1&gt;&lt;/c0&gt; keyword before the statements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがパラメータ名と両方の型を省略するならば、文の前の&lt;c0&gt;&lt;s1&gt;in&lt;/s1&gt;&lt;/c0&gt;キーワードを省略します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you omit the precedence group for an operator, Swift uses the default precedence group, &lt;c0&gt;&lt;s1&gt;DefaultPrecedence&lt;/s1&gt;&lt;/c0&gt;, which specifies a precedence just higher than &lt;c2&gt;&lt;s3&gt;TernaryPrecedence&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが優先順位グループを省略するならば、スウィフトは省略時の優先順位グループ、&lt;c0&gt;&lt;s1&gt;DefaultPrecedence&lt;/s1&gt;&lt;/c0&gt;を使います、それは&lt;c2&gt;&lt;s3&gt;TernaryPrecedence&lt;/s3&gt;&lt;/c2&gt;のすぐ上の優先順位を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you omit the version number, omit the colon (&lt;c1&gt;&lt;s2&gt;:&lt;/s2&gt;&lt;/c1&gt;) as well.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがこのバージョン番号を省略したならば、コロン（&lt;c1&gt;&lt;s2&gt;:&lt;/s2&gt;&lt;/c1&gt;）も同様に省いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you omit these parentheses, you are trying to assign the closure itself to the property, and not the return value of the closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがこの丸括弧を省略するならば、あなたはプロパティにクロージャそれ自体を代入することを試みています、つまりそのクロージャの戻り値でなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you only need some of the tuple’s values, ignore parts of the tuple with an underscore (&lt;c0&gt;&lt;s1&gt;_&lt;/s1&gt;&lt;/c0&gt;) when you decompose the tuple:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがタプルの値の一部を必要とするだけならば、あなたがタプルを分解するとき、アンダースコア（&lt;c0&gt;&lt;s1&gt;_&lt;/s1&gt;&lt;/c0&gt;）で、タプルの一部を無視してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you pass a property that has observers to a function as an in-out parameter, the &lt;c0&gt;&lt;s1&gt;willSet&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;didSet&lt;/s3&gt;&lt;/c2&gt; observers are always called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがオブザーバーを持つプロパティをある関数へin-outパラメータとして渡すならば、&lt;c0&gt;&lt;s1&gt;willSet&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;didSet&lt;/s3&gt;&lt;/c2&gt;オブザーバーは常に呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you pass an empty string value to the failable initializer’s &lt;c0&gt;&lt;s1&gt;species&lt;/s1&gt;&lt;/c0&gt; parameter, the initializer triggers an initialization failure:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが失敗できるイニシャライザの&lt;c0&gt;&lt;s1&gt;species&lt;/s1&gt;&lt;/c0&gt;パラメータに空の文字列値を渡すならば、イニシャライザは初期化失敗を引き起こします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you provide a new initializer with an extension, you are still responsible for making sure that each instance is fully initialized once the initializer completes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが新しいイニシャライザを拡張によって提供する場合、あなたは依然として、一旦イニシャライザが完了するならば各インスタンスが完全に初期化されることを確かにする責任があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you provide a setter as part of a property override, you must also provide a getter for that override.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがプロパティオーバーライドの一部としてセッターを提供するならば、あなたはまたそのオーバーライドのためにゲッターも提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you provide a setter name, it is used as the name of the parameter to the setter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがセッター名を提供するならば、それがセッターにパラメータの名前として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you provide an initial value for a constant or variable at the point that it’s defined, Swift can almost always infer the type to be used for that constant or variable, as described in &lt;a0&gt;&lt;s1&gt;Type Safety and Type Inference&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが最初の値を定数または変数に、それが定義される時点で提供するならば、スウィフトはたいていその定数または変数のために使われる型を推測することが、&lt;a0&gt;&lt;s1&gt;「型安全と型推論」&lt;/s1&gt;&lt;/a0&gt;で記述されるように可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you provide setter names, they are used as the parameter names to the &lt;c5&gt;&lt;s6&gt;willSet&lt;/s6&gt;&lt;/c5&gt; and &lt;c7&gt;&lt;s8&gt;didSet&lt;/s8&gt;&lt;/c7&gt; observers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがセッター名を提供するならば、それらが&lt;c5&gt;&lt;s6&gt;willSet&lt;/s6&gt;&lt;/c5&gt;と&lt;c7&gt;&lt;s8&gt;didSet&lt;/s8&gt;&lt;/c7&gt;オブザーバーへのパラメータ名として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you read strictly from left to right, you might expect the expression to be calculated as follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが厳密に左から右に読んだならば、あなたはこの式を以下のように計算されることを期待するでしょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you really do need to use an optional value as an &lt;c4&gt;&lt;s5&gt;Any&lt;/s5&gt;&lt;/c4&gt; value, you can use the &lt;c6&gt;&lt;s7&gt;as&lt;/s7&gt;&lt;/c6&gt; operator to explicitly cast the optional to &lt;c8&gt;&lt;s9&gt;Any&lt;/s9&gt;&lt;/c8&gt;, as shown below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが本当にオプショナル値を&lt;c4&gt;&lt;s5&gt;Any&lt;/s5&gt;&lt;/c4&gt;値として使う必要があるならば、あなたは&lt;c6&gt;&lt;s7&gt;as&lt;/s7&gt;&lt;/c6&gt;演算子を使って明示的にオプショナルを&lt;c8&gt;&lt;s9&gt;Any&lt;/s9&gt;&lt;/c8&gt;へキャストすることが、以下で示すように行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you set an actual &lt;c0&gt;&lt;s1&gt;Address&lt;/s1&gt;&lt;/c0&gt; instance as the value for &lt;c2&gt;&lt;s3&gt;john.residence.address&lt;/s3&gt;&lt;/c2&gt;, and set an actual value for the address’s &lt;c4&gt;&lt;s5&gt;street&lt;/s5&gt;&lt;/c4&gt; property, you can access the value of the &lt;c6&gt;&lt;s7&gt;street&lt;/s7&gt;&lt;/c6&gt; property through multilevel optional chaining:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが実際の&lt;c0&gt;&lt;s1&gt;Address&lt;/s1&gt;&lt;/c0&gt;インスタンスを&lt;c2&gt;&lt;s3&gt;john.residence.address&lt;/s3&gt;&lt;/c2&gt;のための値として設定して、そしてアドレスのもつ&lt;c4&gt;&lt;s5&gt;street&lt;/s5&gt;&lt;/c4&gt;プロパティのために実際の値を設定するならば、あなたは複数階層のオプショナル連鎖を通して&lt;c6&gt;&lt;s7&gt;street&lt;/s7&gt;&lt;/c6&gt;プロパティの値にアクセスすることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you set the &lt;c0&gt;&lt;s1&gt;currentLevel&lt;/s1&gt;&lt;/c0&gt; of the &lt;e2&gt;left&lt;/e2&gt; channel to &lt;c3&gt;&lt;s4&gt;7&lt;/s4&gt;&lt;/c3&gt;, you can see that the &lt;c5&gt;&lt;s6&gt;maxInputLevelForAllChannels&lt;/s6&gt;&lt;/c5&gt; type property is updated to equal &lt;c7&gt;&lt;s8&gt;7&lt;/s8&gt;&lt;/c7&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが&lt;e2&gt;左&lt;/e2&gt;のチャンネルの&lt;c0&gt;&lt;s1&gt;currentLevel&lt;/s1&gt;&lt;/c0&gt;を&lt;c3&gt;&lt;s4&gt;7&lt;/s4&gt;&lt;/c3&gt;に設定するならば、あなたは型プロパティ&lt;c5&gt;&lt;s6&gt;maxInputLevelForAllChannels&lt;/s6&gt;&lt;/c5&gt;が&lt;c7&gt;&lt;s8&gt;7&lt;/s8&gt;&lt;/c7&gt;に等しくなるよう更新されるのを見ることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you set the &lt;c0&gt;&lt;s1&gt;paragraph&lt;/s1&gt;&lt;/c0&gt; variable to &lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt; and break its strong reference to the &lt;c4&gt;&lt;s5&gt;HTMLElement&lt;/s5&gt;&lt;/c4&gt; instance, neither the &lt;c6&gt;&lt;s7&gt;HTMLElement&lt;/s7&gt;&lt;/c6&gt; instance nor its closure are deallocated, because of the strong reference cycle:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが&lt;c0&gt;&lt;s1&gt;paragraph&lt;/s1&gt;&lt;/c0&gt;変数を&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;に設定して、&lt;c4&gt;&lt;s5&gt;HTMLElement&lt;/s5&gt;&lt;/c4&gt;へのそれの強い参照を壊すならば、&lt;c6&gt;&lt;s7&gt;HTMLElement&lt;/s7&gt;&lt;/c6&gt;インスタンスもそれのクロージャも割り当て解除されません、強い参照循環のためです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you set the strong reference from the &lt;c4&gt;&lt;s5&gt;paragraph&lt;/s5&gt;&lt;/c4&gt; variable to &lt;c6&gt;&lt;s7&gt;nil&lt;/s7&gt;&lt;/c6&gt;, the &lt;c8&gt;&lt;s9&gt;HTMLElement&lt;/s9&gt;&lt;/c8&gt; instance is deallocated, as can be seen from the printing of its deinitializer message in the example below:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが強い参照である&lt;c4&gt;&lt;s5&gt;paragraph&lt;/s5&gt;&lt;/c4&gt;変数を&lt;c6&gt;&lt;s7&gt;nil&lt;/s7&gt;&lt;/c6&gt;に設定するならば、その&lt;c8&gt;&lt;s9&gt;HTMLElement&lt;/s9&gt;&lt;/c8&gt;インスタンスは、下の例におけるそれのデイニシャライザのメッセージの出力から分かるように、割り当て解除されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you specify a name by passing an argument, that name is used as the name in Objective-C code and as the runtime name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが名前を引数を渡す事によって指定するならば、その名前はObjective-Cコードにおける名前としてそしてランタイム名として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you specify a type by name, you can access the type’s initializer without using an initializer expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある型を名前で指定するならば、あなたはその型のイニシャライザにイニシャライザ式を使うことなくアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you specify the Objective-C name for a class, protocol, or enumeration, include a three-letter prefix on the name, as described in &lt;a4&gt;Conventions&lt;/a4&gt;&lt;s5&gt; [https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Conventions/Conventions.html#//apple_ref/doc/uid/TP40011210-CH10-SW1]&lt;/s5&gt; in &lt;a6&gt;Programming with Objective-C&lt;/a6&gt;&lt;s7&gt; [https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011210]&lt;/s7&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがObjective-C名をクラス、プロトコル、または列挙に指定するならば、ある３文字接頭辞をその名前に含めて下さい、&lt;a4&gt;Conventions&lt;/a4&gt;&lt;s5&gt; [https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Conventions/Conventions.html#//apple_ref/doc/uid/TP40011210-CH10-SW1]&lt;/s5&gt;で&lt;a6&gt;Programming with Objective-C&lt;/a6&gt;&lt;s7&gt; [https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011210]&lt;/s7&gt;において記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you subtract &lt;c4&gt;&lt;s5&gt;1&lt;/s5&gt;&lt;/c4&gt; from &lt;c6&gt;&lt;s7&gt;00000000&lt;/s7&gt;&lt;/c6&gt; using the overflow subtraction operator (&lt;c8&gt;&lt;s9&gt;&amp;-&lt;/s9&gt;&lt;/c8&gt;), the number will overflow and wrap around to &lt;c10&gt;&lt;s11&gt;11111111&lt;/s11&gt;&lt;/c10&gt;, or &lt;c12&gt;&lt;s13&gt;255&lt;/s13&gt;&lt;/c12&gt; in decimal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがオーバフロー減算演算子（&lt;c8&gt;&lt;s9&gt;&amp;-&lt;/s9&gt;&lt;/c8&gt;）を使用して&lt;c6&gt;&lt;s7&gt;00000000&lt;/s7&gt;&lt;/c6&gt;から&lt;c4&gt;&lt;s5&gt;1&lt;/s5&gt;&lt;/c4&gt;を減ずるならば、その数はあふれ出てぐるっと送り込まれて&lt;c10&gt;&lt;s11&gt;11111111&lt;/s11&gt;&lt;/c10&gt;、10進での&lt;c12&gt;&lt;s13&gt;255&lt;/s13&gt;&lt;/c12&gt;になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you throw an error in a function, the function returns immediately and the code that called the function handles the error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが関数においてエラーをスローするならば、その関数は直ちに返ります、そして関数を呼んだコードがエラーを取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you tried to do this without a generic &lt;c2&gt;&lt;s3&gt;where&lt;/s3&gt;&lt;/c2&gt; clause, you would have a problem: The implementation of &lt;c4&gt;&lt;s5&gt;isTop(_:)&lt;/s5&gt;&lt;/c4&gt; uses the &lt;c6&gt;&lt;s7&gt;==&lt;/s7&gt;&lt;/c6&gt; operator, but the definition of &lt;c8&gt;&lt;s9&gt;Stack&lt;/s9&gt;&lt;/c8&gt; doesn’t require its items to be equatable, so using the &lt;c10&gt;&lt;s11&gt;==&lt;/s11&gt;&lt;/c10&gt; operator results in a compile-time error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが総称体&lt;c2&gt;&lt;s3&gt;where&lt;/s3&gt;&lt;/c2&gt;節なしにこれをしようとするならば、あなたは問題を抱えることになるでしょう：&lt;c4&gt;&lt;s5&gt;isTop(_:)&lt;/s5&gt;&lt;/c4&gt;の実装は&lt;c6&gt;&lt;s7&gt;==&lt;/s7&gt;&lt;/c6&gt;演算子を使います、しかし&lt;c8&gt;&lt;s9&gt;Stack&lt;/s9&gt;&lt;/c8&gt;の定義はそれの項目に同等評価可能であることを要求しません、それで&lt;c10&gt;&lt;s11&gt;==&lt;/s11&gt;&lt;/c10&gt;演算子の使用はコンパイル時エラーという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you try adding one, the next issue you’ll encounter is that the &lt;c4&gt;&lt;s5&gt;==&lt;/s5&gt;&lt;/c4&gt; operator needs to know the types of its left-hand and right-hand arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがそれを加えることを試みるならば、あなたがぶつかる次の問題は、&lt;c4&gt;&lt;s5&gt;==&lt;/s5&gt;&lt;/c4&gt;演算子はそれの左手および右手の引数の型を知る必要があることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you try to access &lt;c6&gt;&lt;s7&gt;numberOfRooms&lt;/s7&gt;&lt;/c6&gt; with the same optional chaining as before, it will now return an &lt;c8&gt;&lt;s9&gt;Int?&lt;/s9&gt;&lt;/c8&gt; that contains the default &lt;c10&gt;&lt;s11&gt;numberOfRooms&lt;/s11&gt;&lt;/c10&gt; value of &lt;c12&gt;&lt;s13&gt;1&lt;/s13&gt;&lt;/c12&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが前と同じオプショナル連鎖で&lt;c6&gt;&lt;s7&gt;numberOfRooms&lt;/s7&gt;&lt;/c6&gt;にアクセスしようとするならば、それは今では省略時の&lt;c10&gt;&lt;s11&gt;numberOfRooms&lt;/s11&gt;&lt;/c10&gt;値の&lt;c12&gt;&lt;s13&gt;1&lt;/s13&gt;&lt;/c12&gt;を含む&lt;c8&gt;&lt;s9&gt;Int?&lt;/s9&gt;&lt;/c8&gt;を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you try to access an unsafe unowned reference after the instance that it refers to is deallocated, your program will try to access the memory location where the instance used to be, which is an unsafe operation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが安全でない非所有参照に、それが参照するインスタンスがデアロケートされてしまった後にアクセスすることを試みるならば、あなたのプログラムはそのインスタンスが存在するのに使われたところの位置でメモリにアクセスしようと試みるでしょう、それはメモリ安全ではない操作です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you try to access or modify a value for an index that is outside of an array’s existing bounds, you will trigger a runtime error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが配列のもつ存在する境界の外にあるインデックスに対する値にアクセスまたは変更しようとするならば、あなたは実行時エラーの引き金を引くことになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you try to access the &lt;c0&gt;&lt;s1&gt;numberOfRooms&lt;/s1&gt;&lt;/c0&gt; property of this person’s &lt;c2&gt;&lt;s3&gt;residence&lt;/s3&gt;&lt;/c2&gt;, by placing an exclamation point after &lt;c4&gt;&lt;s5&gt;residence&lt;/s5&gt;&lt;/c4&gt; to force the unwrapping of its value, you trigger a runtime error, because there is no &lt;c6&gt;&lt;s7&gt;residence&lt;/s7&gt;&lt;/c6&gt; value to unwrap:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがこの人の&lt;c2&gt;&lt;s3&gt;residence&lt;/s3&gt;&lt;/c2&gt;の&lt;c0&gt;&lt;s1&gt;numberOfRooms&lt;/s1&gt;&lt;/c0&gt;プロパティに、その値を強制アンラップするため&lt;c4&gt;&lt;s5&gt;residence&lt;/s5&gt;&lt;/c4&gt;の後に感嘆符を置くことによって、アクセスしようとするならば、あなたは実行時エラーを引き起こします、なぜなら、アンラップする&lt;c6&gt;&lt;s7&gt;residence&lt;/s7&gt;&lt;/c6&gt;値はないからです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you try to access the value of an unowned reference after that instance has been deallocated, you’ll get a runtime error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある非所有参照の値に、そのインスタンスがデアロケートされてしまった後にアクセスしようとするならば、あなたは実行時エラーを得るでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you try to access the variable or property after the object has been deallocated, a runtime error is raised.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが変数またはプロパティにそのオブジェクトがデアロケートされてしまった後にアクセスすることを試みるならば、実行時エラーが引き起こされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you try to access the variable or property after the object has been deallocated, you’ll access the memory at the location where the object used to be, which is a memory-unsafe operation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが変数またはプロパティに、そのオブジェクトがデアロケートされてしまった後にアクセスすることを試みるならば、あなたはそのオブジェクトが存在するのに使われたところの位置でメモリにアクセスするでしょう、それはメモリ安全ではない操作です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you try to call the &lt;c0&gt;&lt;s1&gt;isTop(_:)&lt;/s1&gt;&lt;/c0&gt; method on a stack whose elements aren’t equatable, you’ll get a compile-time error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが&lt;c0&gt;&lt;s1&gt;isTop(_:)&lt;/s1&gt;&lt;/c0&gt;メソッドを、それの持つ要素が同等評価可能でないスタック上で呼び出そうとするならば、あなたはコンパイル時エラーを得るでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you try to create a &lt;c0&gt;&lt;s1&gt;CartItem&lt;/s1&gt;&lt;/c0&gt; instance with a &lt;c2&gt;&lt;s3&gt;quantity&lt;/s3&gt;&lt;/c2&gt; value of &lt;c4&gt;&lt;s5&gt;0&lt;/s5&gt;&lt;/c4&gt;, the &lt;c6&gt;&lt;s7&gt;CartItem&lt;/s7&gt;&lt;/c6&gt; initializer causes initialization to fail:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが&lt;c0&gt;&lt;s1&gt;CartItem&lt;/s1&gt;&lt;/c0&gt;インスタンスを&lt;c4&gt;&lt;s5&gt;0&lt;/s5&gt;&lt;/c4&gt;の&lt;c2&gt;&lt;s3&gt;quantity&lt;/s3&gt;&lt;/c2&gt;値で作成することを試みるならば、&lt;c6&gt;&lt;s7&gt;CartItem&lt;/s7&gt;&lt;/c6&gt;イニシャライザが初期化を失敗する原因となります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you try to find a planet with a position of &lt;c0&gt;&lt;s1&gt;11&lt;/s1&gt;&lt;/c0&gt;, the optional &lt;c2&gt;&lt;s3&gt;Planet&lt;/s3&gt;&lt;/c2&gt; value returned by the raw value initializer will be &lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが&lt;c0&gt;&lt;s1&gt;11&lt;/s1&gt;&lt;/c0&gt;の位置で惑星を見つけようとするならば、生の値のイニシャライザによって返されるオプショナルの&lt;c2&gt;&lt;s3&gt;Planet&lt;/s3&gt;&lt;/c2&gt;値は、&lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;になります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you try to insert a number into an integer constant or variable that cannot hold that value, by default Swift reports an error rather than allowing an invalid value to be created.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある数をその値を持つことができない整数の定数や変数の中へ入れようとするならば、初期状態では、スウィフトは無効な値がつくられるようにするのではなく、エラーを報告します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you try to retrieve an &lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt; value through optional chaining, an &lt;c2&gt;&lt;s3&gt;Int?&lt;/s3&gt;&lt;/c2&gt; is always returned, no matter how many levels of chaining are used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがオプショナル連鎖を通して&lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt;値を取り出そうと試すならば、&lt;c2&gt;&lt;s3&gt;Int?&lt;/s3&gt;&lt;/c2&gt;が常に返されます、どんなに多くの連鎖階層が使われようともです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you try to set the &lt;c0&gt;&lt;s1&gt;currentLevel&lt;/s1&gt;&lt;/c0&gt; of the &lt;e2&gt;right&lt;/e2&gt; channel to &lt;c3&gt;&lt;s4&gt;11&lt;/s4&gt;&lt;/c3&gt;, you can see that the right channel’s &lt;c5&gt;&lt;s6&gt;currentLevel&lt;/s6&gt;&lt;/c5&gt; property is capped to the maximum value of &lt;c7&gt;&lt;s8&gt;10&lt;/s8&gt;&lt;/c7&gt;, and the &lt;c9&gt;&lt;s10&gt;maxInputLevelForAllChannels&lt;/s10&gt;&lt;/c9&gt; type property is updated to equal &lt;c11&gt;&lt;s12&gt;10&lt;/s12&gt;&lt;/c11&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが&lt;e2&gt;右&lt;/e2&gt;のチャンネルの&lt;c0&gt;&lt;s1&gt;currentLevel&lt;/s1&gt;&lt;/c0&gt;を&lt;c3&gt;&lt;s4&gt;11&lt;/s4&gt;&lt;/c3&gt;に設定しようとするならば、あなたは右のチャンネルの&lt;c5&gt;&lt;s6&gt;currentLevel&lt;/s6&gt;&lt;/c5&gt;プロパティが最大値の&lt;c7&gt;&lt;s8&gt;10&lt;/s8&gt;&lt;/c7&gt;に制限されるのを見ることができます、そして型プロパティ&lt;c9&gt;&lt;s10&gt;maxInputLevelForAllChannels&lt;/s10&gt;&lt;/c9&gt;は&lt;c11&gt;&lt;s12&gt;10&lt;/s12&gt;&lt;/c11&gt;に等しくなるよう更新されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you try to use an implicitly unwrapped optional that has a value of &lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;, you’ll get a runtime error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが&lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;の値を持つ暗黙的にアンラップされるオプショナルを使うことを試みるならば、あなたは実行時エラーを得るでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use a capture list, you must also use the &lt;c0&gt;&lt;s1&gt;in&lt;/s1&gt;&lt;/c0&gt; keyword, even if you omit the parameter names, parameter types, and return type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがキャプチャリストを使うならば、あなたはまた&lt;c0&gt;&lt;s1&gt;in&lt;/s1&gt;&lt;/c0&gt;キーワードも使わなければなりません、たとえあなたがパラメータ名、パラメータ型、そして戻り型を省略するとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use a closure to initialize a property, remember that the rest of the instance has not yet been initialized at the point that the closure is executed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがプロパティを初期化するためにクロージャを使うならば、そのクロージャが実行される時点で、残りのインスタンスはまだ初期化されていないのを思い出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use an extension to add an initializer to a structure that was declared in another module, the new initializer can’t access &lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt; until it calls an initializer from the defining module.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが拡張を使ってイニシャライザを別のモジュールの中で宣言された構造体へと加えるならば、その新しいイニシャライザは&lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;にアクセスすることが、それがあるイニシャライザを定義されているモジュールから呼び出すまでは出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use an extension to add an initializer to a value type that provides default values for all of its stored properties and does not define any custom initializers, you can call the default initializer and memberwise initializer for that value type from within your extension’s initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが拡張を、その格納プロパティの全てに省略時の値を与えて全くあつらえのイニシャライザを定義しない値型に、イニシャライザを加えるために使うならば、あなたはその値型のための省略時のイニシャライザとメンバー関連イニシャライザを、あなたの拡張のイニシャライザ内から呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use more than one number sign to form a string delimited by extended delimiters, don’t place whitespace in between the number signs:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが１つ以上のシャープ記号を使って拡張区切り記号によって区切られる文字列を形成するならば、空白をシャープ記号の間に置かないでください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use multiple &lt;c4&gt;&lt;s5&gt;available&lt;/s5&gt;&lt;/c4&gt; attributes, the effective availability is the combination of the platform and Swift availabilities.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが複数の&lt;c4&gt;&lt;s5&gt;available&lt;/s5&gt;&lt;/c4&gt;属性を使うならば、有効な利用可能性はプラットホームとスウィフト利用可能性の組み合わせとなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you use these shorthand argument names within your closure expression, you can omit the closure’s argument list from its definition, and the number and type of the shorthand argument names will be inferred from the expected function type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがこれらの短縮形引数名をあなたのクロージャ式の中で使用するならば、あなたはクロージャの引数リストをその定義から省略することができます、そして、短縮形引数名の数と型は期待される関数型から推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want a custom subclass to present one or more of the same initializers as its superclass, you can provide a custom implementation of those initializers within the subclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが、あるあつらえのサブクラスにそれのスーパークラスと同じイニシャライザがひとつ以上存在することを望むならば、あなたはそれらのイニシャライザのあつらえの実装をそのサブクラスにおいて提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want a function to modify a parameter’s value, and you want those changes to persist after the function call has ended, define that parameter as an &lt;e0&gt;in-out parameter&lt;/e0&gt; instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある関数にパラメータの値を修正して欲しいならば、そしてあなたが関数呼び出しが終わった後それらの変化に存続して欲しいならば、代わりにそのパラメータを&lt;e0&gt;in-outパラメータ&lt;/e0&gt;として定義してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want a nested type within a public type to be publicly available, you must explicitly declare the nested type as public.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが公開型の内側で入れ子にされた型に公開的に利用できて欲しいならば、あなたは明確に入れ子にされた型を公開として宣言しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want a public type to be initializable with a no-argument initializer when used in another module, you must explicitly provide a public no-argument initializer yourself as part of the type’s definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある公開型を別のモジュール内で使うときに引数のないイニシャライザを使って初期化できるようにしたいならば、あなたはある公開の引数のないイニシャライザをあなた自身でその型定義の一部として明示的に提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want a type member to be public, you must explicitly mark it as such.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが型のメンバーに公開であって欲しいならば、あなたは明確にそれをそのように印しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want an autoclosure that is allowed to escape, use both the &lt;c0&gt;&lt;s1&gt;@autoclosure&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;@escaping&lt;/s3&gt;&lt;/c2&gt; attributes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが脱出を許可される自動クロージャを望むならば、&lt;c0&gt;&lt;s1&gt;@autoclosure&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;@escaping&lt;/s3&gt;&lt;/c2&gt;属性を両方とも使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to assign an explicit access level to a protocol type, do so at the point that you define the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが明確なアクセス水準をあるプロトコル型に割り当てたいならば、あなたがそのプロトコルを定義する時点でそうしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to observe changes to a property’s value, and you are already providing a custom setter for that property, you can simply observe any value changes from within the custom setter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがあるプロパティの値に対する変更を監視したい、そしてあなたが既にあつらえのセッターをそのプロパティのために提供しているならば、あなたは簡単にあつらえのセッター内からどんな値の変化でも監視することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to perform further optional chaining on this method’s return value, place the optional chaining question mark &lt;e0&gt;after&lt;/e0&gt; the method’s parentheses:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがこのメソッドの戻り値の上でさらにオプショナル連鎖を実行したいならば、メソッドの丸括弧の&lt;e0&gt;後に&lt;/e0&gt;オプショナル連鎖の疑問符を置いてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to remove the final item from an array, use the &lt;c0&gt;&lt;s1&gt;removeLast()&lt;/s1&gt;&lt;/c0&gt; method rather than the &lt;c2&gt;&lt;s3&gt;remove(at:)&lt;/s3&gt;&lt;/c2&gt; method to avoid the need to query the array’s &lt;c4&gt;&lt;s5&gt;count&lt;/s5&gt;&lt;/c4&gt; property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが配列から最後の項目を取り除きたいならば、&lt;c0&gt;&lt;s1&gt;removeLast()&lt;/s1&gt;&lt;/c0&gt;メソッドを&lt;c2&gt;&lt;s3&gt;remove(at:)&lt;/s3&gt;&lt;/c2&gt;メソッドよりむしろ使用して、配列の&lt;c4&gt;&lt;s5&gt;count&lt;/s5&gt;&lt;/c4&gt;プロパティについてたずねる必要を避けるようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to specify an explicit access level for a custom type, do so at the point that you define the type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがあつらえの型のために明示的にアクセス水準を指定したいならば、あなたが型を定義する時点でそうしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to swap two &lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt; values, or two &lt;c6&gt;&lt;s7&gt;Double&lt;/s7&gt;&lt;/c6&gt; values, you have to write more functions, such as the &lt;c8&gt;&lt;s9&gt;swapTwoStrings(_:_:)&lt;/s9&gt;&lt;/c8&gt; and &lt;c10&gt;&lt;s11&gt;swapTwoDoubles(_:_:)&lt;/s11&gt;&lt;/c10&gt; functions shown below:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが２つの&lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt;値、または２つの&lt;c6&gt;&lt;s7&gt;Double&lt;/s7&gt;&lt;/c6&gt;の値を交換したいならば、あなたはより多くの関数を書かなければなりません、例えば以下で示される&lt;c8&gt;&lt;s9&gt;swapTwoStrings(_:_:)&lt;/s9&gt;&lt;/c8&gt;と&lt;c10&gt;&lt;s11&gt;swapTwoDoubles(_:_:)&lt;/s11&gt;&lt;/c10&gt;関数のように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to use line breaks to make your source code easier to read, but you don’t want the line breaks to be part of the string’s value, write a backslash (&lt;c0&gt;&lt;s1&gt;\&lt;/s1&gt;&lt;/c0&gt;) at the end of those lines:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが改行を使うことであなたのソースコードを読みやすくしたい、しかしあなたがその改行に文字列の値の一部であることを望まないならば、バックスラッシュを（&lt;c0&gt;&lt;s1&gt;\&lt;/s1&gt;&lt;/c0&gt;）それらの行の終わりに書いてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want your custom value type to be initializable with the default initializer and memberwise initializer, and also with your own custom initializers, write your custom initializers in an extension rather than as part of the value type’s original implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが、あなたのあつらえの値型に省略時のイニシャライザとメンバー関連イニシャライザで、その上にあなた自身のあつらえのイニシャライザで初期化可能にされて欲しいならば、あなたのあつらえのイニシャライザを値型の元々の実装の一部としてではなく、ある拡張の中で書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you wanted to manipulate the value of &lt;c0&gt;&lt;s1&gt;actualNumber&lt;/s1&gt;&lt;/c0&gt; within the first branch of the &lt;c2&gt;&lt;s3&gt;if&lt;/s3&gt;&lt;/c2&gt; statement, you could write &lt;c4&gt;&lt;s5&gt;if&lt;/s5&gt; &lt;s6&gt;var&lt;/s6&gt; &lt;s7&gt;actualNumber&lt;/s7&gt;&lt;/c4&gt; instead, and the value contained within the optional would be made available as a variable rather than a constant.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが&lt;c0&gt;&lt;s1&gt;actualNumber&lt;/s1&gt;&lt;/c0&gt;の値を&lt;c2&gt;&lt;s3&gt;if&lt;/s3&gt;&lt;/c2&gt;文の最初の分岐内で取り扱うことを望むならば、あなたは&lt;c4&gt;&lt;s5&gt;if&lt;/s5&gt; &lt;s6&gt;var&lt;/s6&gt; &lt;s7&gt;actualNumber&lt;/s7&gt;&lt;/c4&gt;を代わりに書くことができたでしょう、そしてオプショナル内部に含まれる値は定数ではなく変数として利用可能にされたでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you write &lt;c0&gt;&lt;s1&gt;inout&lt;/s1&gt;&lt;/c0&gt; in front of a parameter’s type, the parameter can be modified inside the scope of the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが&lt;c0&gt;&lt;s1&gt;inout&lt;/s1&gt;&lt;/c0&gt;をパラメータの型のすぐ前に書くならば、そのパラメータは関数のスコープ内部において修正されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your code does contain conflicts, you’ll get a compile-time or runtime error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのコードが衝突を含むならば、あなたはコンパイル時または実行時エラーを得るでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your custom type has a stored property that is logically allowed to have “no value”—perhaps because its value cannot be set during initialization, or because it is allowed to have “no value” at some later point—declare the property with an &lt;e0&gt;optional&lt;/e0&gt; type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたの特注で作った型が論理的に「無い値」を持つことを許される格納プロパティを ― もしかしたらそれの値が初期化の間に設定されることができないかもしれないため、または後の時点でそれが「無い値」を持つことを許されるため ― 持つならば、そのプロパティを&lt;e0&gt;オプショナル&lt;/e0&gt;の型で宣言してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your data structure is likely to be more complex, model it as a class or structure, rather than as a tuple.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのデータ構造体がより複雑になるようならば、それをクラスまたは構造体として形作ってください、タプルとしてよりも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your subclass doesn’t define any designated initializers, it automatically inherits all of its superclass designated initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのサブクラスがまったく指定イニシャライザを定義しないならば、それは自動的にそれのスーパークラスの指定イニシャライザの全てを継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your subclass provides an implementation of &lt;e0&gt;all&lt;/e0&gt; of its superclass designated initializers—either by inheriting them as per rule 1, or by providing a custom implementation as part of its definition—then it automatically inherits all of the superclass convenience initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしあなたのサブクラスがそれのスーパークラスの指定イニシャライザの実装の&lt;e0&gt;全て&lt;/e0&gt;を ― 規則１に従ってそれらを継承することによって、またはあつらえの実装をそれの定義の一部として提供することによってのどちらかで ― 提供するならば、その時それは自動的にスーパークラスの便宜イニシャライザの全てを継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your turn ends at the bottom of a ladder, you move up that ladder.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたの番がはしごの下で終わるならば、あなたはそのはしごを上ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If your turn ends at the head of a snake, you move down that snake.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたの番がヘビの頭のところで終わるならば、あなたはそのヘビを下ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you’re implementing a prefix or postfix operator, you must also mark that method declaration with the corresponding &lt;c8&gt;&lt;s9&gt;prefix&lt;/s9&gt;&lt;/c8&gt; or &lt;c10&gt;&lt;s11&gt;postfix&lt;/s11&gt;&lt;/c10&gt; declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが接頭辞または接尾辞演算子を実装しているならば、あなたはまたそのメソッド宣言を対応する&lt;c8&gt;&lt;s9&gt;prefix&lt;/s9&gt;&lt;/c8&gt;または&lt;c10&gt;&lt;s11&gt;postfix&lt;/s11&gt;&lt;/c10&gt;宣言修飾子で印をしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you’re using multiline string literals to build up the lines of a longer string, you want every line in the string to end with a line break, including the last line.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが複数行文字列リテラルを使ってたくさんの行の長い文字列を作り上げようとしているならば、あなたはその文字列のすべての行を、最後の行を含めて改行で終わりたいと思うでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you’ve written concurrent or multithreaded code, conflicting access to memory might be a familiar problem.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが並列のまたはマルチスレッドのコードを書いたことがあるならば、メモリアクセスの衝突はおなじみの問題でしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implement an &lt;c4&gt;&lt;s5&gt;area()&lt;/s5&gt;&lt;/c4&gt; and a &lt;c6&gt;&lt;s7&gt;simpleDescription()&lt;/s7&gt;&lt;/c6&gt; method on the &lt;c8&gt;&lt;s9&gt;Circle&lt;/s9&gt;&lt;/c8&gt; class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;area()&lt;/s5&gt;&lt;/c4&gt;および&lt;c6&gt;&lt;s7&gt;simpleDescription()&lt;/s7&gt;&lt;/c6&gt;メソッドを&lt;c8&gt;&lt;s9&gt;Circle&lt;/s9&gt;&lt;/c8&gt;クラス上で実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implicit Member Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗黙のメンバー式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implicit Returns from Single-Expression Closures</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単一式のクロージャからの値を暗黙的に返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implicit returns from single-expression closures</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単一式のクロージャからの値を暗黙的に返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implicitly Assigned Raw Values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗黙的に割り当てられる生の値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implicitly Unwrapped Optional Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗黙的にアンラップされるオプショナルの型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implicitly Unwrapped Optionals</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗黙的にアンラップされるオプショナル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implicitly unwrapped optionals are useful when an optional’s value is confirmed to exist immediately after the optional is first defined and can definitely be assumed to exist at every point thereafter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗黙的にアンラップされるオプショナルは、あるオプショナルの値が存在するのをそのオプショナルが最初に定義された直後に確かめられて、それ以降あらゆる所で存在するのを自信を持って仮定出来るようにされる場合に役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Import Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インポート宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Important</seg>
      </tuv>
      <tuv lang="JA">
        <seg>重要</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Improved the discussion of autoclosures in the &lt;a0&gt;&lt;s1&gt;Autoclosures&lt;/s1&gt;&lt;/a0&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>自動クロージャの説明を&lt;a0&gt;&lt;s1&gt;自動クロージャ&lt;/s1&gt;&lt;/a0&gt;節において改善した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Blackjack, the Ace cards have a value of either one or eleven.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ブラックジャックにおいて、「エース」のカードは、１または11のどちらかの値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In C and Objective-C, you define static constants and variables associated with a type as &lt;e0&gt;global&lt;/e0&gt; static variables.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>CとObjective-Cでは、あなたは静的定数および&lt;e0&gt;グローバルな&lt;/e0&gt;静的変数として型と結びついた変数を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Objective-C, &lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt; is a pointer to a nonexistent object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cでは、&lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;は、ある存在しないオブジェクトへのポインターです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Objective-C, classes are the only types that can define methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cでは、クラスはメソッドを定義することができる唯一の型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Objective-C, you can define type-level methods only for Objective-C classes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cでは、あなたはObjective-Cクラスのためにだけ型レベルのメソッドを定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; statements don’t fall through the bottom of each case and into the next one.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;文は、それぞれのケース節の底を抜け落ちて次のものにいきません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, &lt;c6&gt;&lt;s7&gt;nil&lt;/s7&gt;&lt;/c6&gt; isn’t a pointer—it’s the absence of a value of a certain type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、&lt;c6&gt;&lt;s7&gt;nil&lt;/s7&gt;&lt;/c6&gt;はポインターではありません ― それは、ある特定の型のある値の不在です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, an enumeration to define product barcodes of either type might look like this:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおいて、両方の種類の製品バーコードを定義する列挙は、これのように見えるかもしれません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, as in C, the remainder operator (&lt;c4&gt;&lt;s5&gt;%&lt;/s5&gt;&lt;/c4&gt;) and the multiplication operator (&lt;c6&gt;&lt;s7&gt;*&lt;/s7&gt;&lt;/c6&gt;) have a higher precedence than the addition operator (&lt;c8&gt;&lt;s9&gt;+&lt;/s9&gt;&lt;/c8&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、Cでのように、剰余演算子（&lt;c4&gt;&lt;s5&gt;%&lt;/s5&gt;&lt;/c4&gt;）と乗算演算子（&lt;c6&gt;&lt;s7&gt;*&lt;/s7&gt;&lt;/c6&gt;）は、加算演算子（&lt;c8&gt;&lt;s9&gt;+&lt;/s9&gt;&lt;/c8&gt;）より高い優先順位を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, as in Objective-C, protocol conformance is global—it isn’t possible for a type to conform to a protocol in two different ways within the same program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおいて、Objective-Cにおいてと同様に、プロトコル準拠はグローバルです ― ひとつの型にとって、同じプログラム内でひとつのプロトコルに２つの異なる方法で準拠することは、可能ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, errors are represented by values of types that conform to the &lt;c0&gt;&lt;s1&gt;Error&lt;/s1&gt;&lt;/c0&gt; protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、エラーは&lt;c0&gt;&lt;s1&gt;Error&lt;/s1&gt;&lt;/c0&gt;プロトコルに準拠する型の値によって表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, every possible value of the control expression’s type must match the value of at least one pattern of a case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおいて、制御式のもつ型のあらゆる可能な値は、少なくともあるケース節の１つのパターンの値にマッチしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, however, type properties are written as part of the type’s definition, within the type’s outer curly braces, and each type property is explicitly scoped to the type it supports.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、しかしながら、型プロパティは、型の定義の一部として、型の外縁の波括弧の内部に書かれます、そして各型プロパティは、明確にそれが支持する型にスコープを定められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, most declarations are also definitions in the sense that they are implemented or initialized at the same time they are declared.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおいて、大部分の宣言はまた、それらが宣言されるのと同時にそれらが実装または初期化されるという意味で定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, the simplest form of a closure that can capture values is a nested function, written within the body of another function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおいて、値をキャプチャできるクロージャの最も単純な形式は、別の関数の本文内に書かれる、入れ子にされた関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, there are four kinds of expressions: prefix expressions, binary expressions, primary expressions, and postfix expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトには、４種類の式があります：接頭辞式、二項式、基本式、そして接尾辞式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, there are three kinds of statements: simple statements, compiler control statements, and control flow statements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトには、３種類の文があります：単純な文、コンパイラ制御文、そして制御の流れ文。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, there are two basic kinds of patterns: those that successfully match any kind of value, and those that may fail to match a specified value at runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトには、２つの基本的な種類のパターンがあります：あらゆる種類の値に成功裏にマッチするものたち、そして指定された値にマッチするのを実行時に失敗するものたち。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, there are two kinds of types: named types and compound types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトには、２つの種類の型：名前付きの型と複合の型があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, there are ways to modify a value that span several lines of code, making it possible to attempt to access a value in the middle of its own modification.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトには、複数コード行にまたがるある値を修正する方法があります、それが可能にするのはある値に対してそれ自身の修正の途中でアクセスを試みることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, this can be done in a single line:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおいて、これは１つの行でされることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, this would be written as:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、これはこのように書かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, type information can also flow in the opposite direction—from the root down to the leaves.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、型情報は逆方向にも流れます ― 根から下って葉っぱまで。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, you can choose whether to define a class, structure, or enumeration, and still have the flexibility to define methods on the type you create.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、あなたは、クラス、構造体、または列挙を定義すべきかを選択することができます、そしてまだあなたがつくる型でメソッドを定義する柔軟性を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, you can define type-level methods for all classes, structures, and enumerations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、あなたは全てのクラス、構造体、および列挙のために型レベルのメソッドを定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, you can even extend a protocol to provide implementations of its requirements or add additional functionality that conforming types can take advantage of.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、あなたはプロトコルを拡張してその要件の実装を提供することやそれの準拠型が利用することができる追加の機能性を加えることさえ可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, you can nest loops and conditional statements inside other loops and conditional statements to create complex control flow structures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、あなたはループおよび条件文を他のループおよび条件文の中に入れ子にして、複雑な制御の流れの構造を作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Swift, you define a structure or class in a single file, and the external interface to that class or structure is automatically made available for other code to use.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでは、あなたはある構造体またはクラスをある単一のファイルの中で定義します、そして、そのクラスまたは構造体への外部インタフェースは自動的に他のコードが使うことが可能にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Xcode, for example, the &lt;c2&gt;&lt;s3&gt;print(_:separator:terminator:)&lt;/s3&gt;&lt;/c2&gt; function prints its output in Xcode’s “console” pane.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、Xcodeでは、&lt;c2&gt;&lt;s3&gt;print(_:separator:terminator:)&lt;/s3&gt;&lt;/c2&gt;関数はその出力をXcodeの「コンソール」枠に表示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a &lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt; statement, the increment expression is still evaluated after the &lt;c2&gt;&lt;s3&gt;continue&lt;/s3&gt;&lt;/c2&gt; statement is executed, because the increment expression is evaluated after the execution of the loop’s body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;文において、増加式は&lt;c2&gt;&lt;s3&gt;continue&lt;/s3&gt;&lt;/c2&gt;文が実行されたあと依然として評価されます、なぜなら増加式がループの本文の実行の後に評価されるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a class declaration, the &lt;c4&gt;&lt;s5&gt;static&lt;/s5&gt;&lt;/c4&gt; keyword has the same effect as marking the declaration with both the &lt;c6&gt;&lt;s7&gt;class&lt;/s7&gt;&lt;/c6&gt; and &lt;c8&gt;&lt;s9&gt;final&lt;/s9&gt;&lt;/c8&gt; declaration modifiers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス宣言において、&lt;c4&gt;&lt;s5&gt;static&lt;/s5&gt;&lt;/c4&gt;キーワードは、宣言を&lt;c6&gt;&lt;s7&gt;class&lt;/s7&gt;&lt;/c6&gt;と&lt;c8&gt;&lt;s9&gt;final&lt;/s9&gt;&lt;/c8&gt;宣言修飾子の両方で印することと同じ効果を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a dictionary literal, the key and value in each key-value pair are separated by a colon.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書リテラルでは、それぞれの「キーと値」の対の中のキーと値は、コロンで区切られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a few cases, regular font text is used to describe the right-hand side of a grammar production rule.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２、３の場合には、標準活字のテキストが説明のために文法導出規則の右側で使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a multiline string literal, writing a backslash (&lt;c0&gt;&lt;s1&gt;\&lt;/s1&gt;&lt;/c0&gt;) at the end of a line omits that line break from the string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数行文字列リテラルにおいて、バックスラッシュ（&lt;c0&gt;&lt;s1&gt;\&lt;/s1&gt;&lt;/c0&gt;）を行の終わりで書くことはそのラインブレークを文字列から省きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a mutating method of a value type, you can assign a new instance of that value type to &lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値型の変更メソッドでは、あなたは&lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;にその値型の新しいインスタンスを代入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a nested tuple expression, identifiers at the same level of nesting must be unique.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>入れ子にされたタプル式において、同じ水準の入れ子での識別子それらは特有でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a nonthrowing function, an enclosing &lt;c7&gt;&lt;s8&gt;do&lt;/s8&gt;&lt;/c7&gt;-&lt;c9&gt;&lt;s10&gt;catch&lt;/s10&gt;&lt;/c9&gt; statement must handle the error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非スロー関数では、取り囲んでいる&lt;c7&gt;&lt;s8&gt;do&lt;/s8&gt;&lt;/c7&gt;-&lt;c9&gt;&lt;s10&gt;catch&lt;/s10&gt;&lt;/c9&gt;文がエラーを処理しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a protocol declaration or a protocol member declaration, the &lt;c0&gt;&lt;s1&gt;Self&lt;/s1&gt;&lt;/c0&gt; type refers to the eventual type that conforms to the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル宣言またはプロトコルメンバー宣言において、&lt;c0&gt;&lt;s1&gt;Self&lt;/s1&gt;&lt;/c0&gt;型は、そのプロトコルに準拠する結果として起こる型を参照します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a structure, class, or enumeration declaration, the &lt;c0&gt;&lt;s1&gt;Self&lt;/s1&gt;&lt;/c0&gt; type refers to the type introduced by the declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体、クラス、または列挙宣言において、&lt;c0&gt;&lt;s1&gt;Self&lt;/s1&gt;&lt;/c0&gt;型は、その宣言によって導入される型を参照します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a throwing function, either an enclosing &lt;c11&gt;&lt;s12&gt;do&lt;/s12&gt;&lt;/c11&gt;-&lt;c13&gt;&lt;s14&gt;catch&lt;/s14&gt;&lt;/c13&gt; statement or the caller must handle the error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スロー関数では、取り囲んでいる&lt;c11&gt;&lt;s12&gt;do&lt;/s12&gt;&lt;/c11&gt;-&lt;c13&gt;&lt;s14&gt;catch&lt;/s14&gt;&lt;/c13&gt;文または呼び出し側のどちらかがエラーを処理しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In a type method, &lt;c2&gt;&lt;s3&gt;self&lt;/s3&gt;&lt;/c2&gt; refers to the current type in which it occurs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型メソッドでは、&lt;c2&gt;&lt;s3&gt;self&lt;/s3&gt;&lt;/c2&gt;はそれが現れているところの現在の型に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to comparing against specific values, Swift provides several ways for each case to specify more complex matching patterns.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある特定の値に対して比較することに加えて、スウィフトは、それぞれのケース節のために、より複雑な適合パターンを指定するためのいくつかの方法を用意します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to familiar types, Swift introduces advanced types not found in Objective-C, such as tuples.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>よく知られている型に加えて、スウィフトはObjective-Cで見られない先進の型を導入します、例えばタプルのような。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to generic functions, Swift enables you to define your own &lt;e0&gt;generic types&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体関数に加えて、スウィフトはあなたに独自の&lt;e0&gt;総称体型&lt;/e0&gt;を定義することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to its list of protocols, a protocol composition can also contain one class type, which you can use to specify a required superclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いくつかのプロトコルからなるそれのリストに加えて、あるプロトコル合成はまた１つのクラス型を含むことができます、それはあなたが必要とされるスーパークラスを指定するのに使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to its type property and type methods, &lt;c0&gt;&lt;s1&gt;LevelTracker&lt;/s1&gt;&lt;/c0&gt; tracks an individual player’s progress through the game.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その型プロパティと型メソッドに加えて、&lt;c0&gt;&lt;s1&gt;LevelTracker&lt;/s1&gt;&lt;/c0&gt;は個々のプレーヤーのゲームを通しての進捗を追います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to matching a pattern with a value, you can extract part or all of a composite value and bind each part to a constant or variable name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パターンを値とマッチングすることに加えて、あなたはある複合値の部分または全てを抽出して、各部分を定数や変数の名前に結び付ける（束縛する）ことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to offering various levels of access control, Swift reduces the need to specify explicit access control levels by providing default access levels for typical scenarios.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アクセス制御のいろいろな水準を提供することに加えて、スウィフトは省略時のアクセス水準を典型的なシナリオのために用意することによって明示的にアクセス制御水準を指定する必要を減らします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to properties, you can use instance variables as a backing store for the values stored in a property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティに加えて、あなたはインスタンス変数をプロパティに格納される値に対する支援外部記憶として使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to simple properties that are stored, properties can have a getter and a setter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>格納される単純なプロパティに加えて、プロパティはゲッター（取得メソッド）とセッター（設定メソッド）を持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to specifying major version numbers like iOS 8 or macOS 10.10, you can specify minor versions numbers like iOS 11.2.6 and macOS 10.13.3.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メジャーなバージョン数をiOS 8やmacOS 10.10のように指定することに加えて、あなたはマイナーバージョン数を、iOS 11.2.6そしてmacOS 10.13.3のように指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to specifying requirements that conforming types must implement, you can extend a protocol to implement some of these requirements or to implement additional functionality that conforming types can take advantage of.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>準拠する型が実装しなければならない要件を指定することに加えて、あなたはあるプロトコルを拡張してそれらの要件のいくつかを実装したり、更なる機能性を実装したりできます、それらは、準拠する型それぞれで利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to stored properties, classes, structures, and enumerations can define &lt;e0&gt;computed properties&lt;/e0&gt;, which do not actually store a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>格納プロパティに加えて、クラス、構造体、および列挙は&lt;e0&gt;計算プロパティ&lt;/e0&gt;を定義することができます、それは、実際に値を格納しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to the characteristics it inherits, the &lt;c0&gt;&lt;s1&gt;Bicycle&lt;/s1&gt;&lt;/c0&gt; class defines a new stored property, &lt;c2&gt;&lt;s3&gt;hasBasket&lt;/s3&gt;&lt;/c2&gt;, with a default value of &lt;c4&gt;&lt;s5&gt;false&lt;/s5&gt;&lt;/c4&gt; (inferring a type of &lt;c6&gt;&lt;s7&gt;Bool&lt;/s7&gt;&lt;/c6&gt; for the property).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが継承する特徴に加えて、&lt;c0&gt;&lt;s1&gt;Bicycle&lt;/s1&gt;&lt;/c0&gt;クラスは新しい格納プロパティ、&lt;c2&gt;&lt;s3&gt;hasBasket&lt;/s3&gt;&lt;/c2&gt;を、&lt;c4&gt;&lt;s5&gt;false&lt;/s5&gt;&lt;/c4&gt;の省略時の値を使って定義します（このプロパティに対しては&lt;c6&gt;&lt;s7&gt;Bool&lt;/s7&gt;&lt;/c6&gt;の型が推論されます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to the operators described in &lt;a0&gt;&lt;s1&gt;Basic Operators&lt;/s1&gt;&lt;/a0&gt;, Swift provides several advanced operators that perform more complex value manipulation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;基本の演算子&lt;/s1&gt;&lt;/a0&gt;で記述される演算子に加えて、スウィフトはより複雑な値操作を実行するいくつかの先進の演算子を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to the standard library operators, you use &lt;c0&gt;&lt;s1&gt;&amp;&lt;/s1&gt;&lt;/c0&gt; immediately before the name of a variable that’s being passed as an in-out argument to a function call expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>標準ライブラリ演算子に加えて、あなたは&lt;c0&gt;&lt;s1&gt;&amp;&lt;/s1&gt;&lt;/c0&gt;を変数の名前の直前で使います、それはin-out引数として関数呼び出し式に渡されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to the wrapped value, a property wrapper can expose additional functionality by defining a &lt;e0&gt;projected value&lt;/e0&gt;—for example, a property wrapper that manages access to a database can expose a &lt;c1&gt;&lt;s2&gt;flushDatabaseConnection()&lt;/s2&gt;&lt;/c1&gt; method on its projected value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのラップされた値に加えて、プロパティラッパーは&lt;e0&gt;予測値&lt;/e0&gt;を定義することによっていっそうの機能性を露出できます — 例えば、データベースへのアクセスを管理するプロパティラッパーは、&lt;c1&gt;&lt;s2&gt;flushDatabaseConnection()&lt;/s2&gt;&lt;/c1&gt;メソッドをそれの見込値に関して露出できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to these two simple properties, the &lt;c0&gt;&lt;s1&gt;HTMLElement&lt;/s1&gt;&lt;/c0&gt; class defines a lazy property called &lt;c2&gt;&lt;s3&gt;asHTML&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの２つの単純なプロパティに加えて、&lt;c0&gt;&lt;s1&gt;HTMLElement&lt;/s1&gt;&lt;/c0&gt;クラスは、&lt;c2&gt;&lt;s3&gt;asHTML&lt;/s3&gt;&lt;/c2&gt;と呼ばれる遅延プロパティを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to user-defined named types, the Swift standard library defines many commonly used named types, including those that represent arrays, dictionaries, and optional values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユーザー定義の名前付きの型に加えて、スウィフト標準ライブラリは、配列、辞書、そしてオプショナル値を表すものたちを含む、多くの一般に使われる名前付きの型を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to verifying your expectations at runtime, assertions and preconditions also become a useful form of documentation within the code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたの期待を実行時で実証するのに加えて、表明と前提条件はまたコード内部での有用な文書化形式となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, Swift provides a &lt;c0&gt;&lt;s1&gt;do&lt;/s1&gt;&lt;/c0&gt; statement to introduce scope, and catch and handle errors, and a &lt;c2&gt;&lt;s3&gt;defer&lt;/s3&gt;&lt;/c2&gt; statement for running cleanup actions just before the current scope exits.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>加えて、スウィフトは、&lt;c0&gt;&lt;s1&gt;do&lt;/s1&gt;&lt;/c0&gt;文をスコープを導入し、それでエラーを捕えて処理するために、そして&lt;c2&gt;&lt;s3&gt;defer&lt;/s3&gt;&lt;/c2&gt;文を現在のスコープを脱出する直前にさまざまな片付け活動を実行するために提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, for classes that are defined in the same module, you can override any class member (method, property, initializer, or subscript) that’s visible in a certain access context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それに加えて、同じモジュールにおいて定義されるクラスに対して、あなたは特定のアクセス前後関係において可視であるあらゆるクラスメンバー（メソッド、プロパティ、イニシャライザ、または添え字）をオーバーライドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, subscripts can’t have in-out parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>加えて、添え字はin-outパラメータを持つことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, the &lt;c10&gt;&lt;s11&gt;catch&lt;/s11&gt;&lt;/c10&gt; clause must handle only errors thrown by one of the rethrowing function’s throwing parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>加えて、その&lt;c10&gt;&lt;s11&gt;catch&lt;/s11&gt;&lt;/c10&gt;節はスロー関数の持つスローパラメータの１つによってスローされるエラーのみを取り扱わなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, you can define property observers to monitor changes in a property’s value, which you can respond to with custom actions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それに加えて、あなたはプロパティオブザーバーを定義して、あるプロパティの値の変化を監視することができて、あなたはあつらえの動作でそれに応答することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In all other cases, &lt;c4&gt;&lt;s5&gt;dynamicallyCall(withArguments:)&lt;/s5&gt;&lt;/c4&gt; is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全ての他の場合には、&lt;c4&gt;&lt;s5&gt;dynamicallyCall(withArguments:)&lt;/s5&gt;&lt;/c4&gt;が呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In all other cases, the dice roll is a valid move.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の全ての場合には、さいころの目は有効な移動となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In all other cases, you must use an initializer expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべての他の場合では、あなたはイニシャライザ式を使う必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In all three functions, the types of &lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;b&lt;/s3&gt;&lt;/c2&gt; must be the same.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>３つの関数すべてにおいて、&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;b&lt;/s3&gt;&lt;/c2&gt;の型は同じでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In an &lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt; statement, the conditional must be a Boolean expression—this means that code such as &lt;c2&gt;&lt;s3&gt;if&lt;/s3&gt; &lt;s4&gt;score&lt;/s4&gt; &lt;s5&gt;{&lt;/s5&gt; &lt;s6&gt;...&lt;/s6&gt; &lt;s7&gt;}&lt;/s7&gt;&lt;/c2&gt; is an error, not an implicit comparison to zero.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt;文において、その条件を表すのはブール式でなければなりません ― これは&lt;c2&gt;&lt;s3&gt;if&lt;/s3&gt; &lt;s4&gt;score&lt;/s4&gt; &lt;s5&gt;{&lt;/s5&gt; &lt;s6&gt;...&lt;/s6&gt; &lt;s7&gt;}&lt;/s7&gt;&lt;/c2&gt;のようなコードがエラーになることを意味します、暗黙的なゼロとの比較はしないためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In an explicit member expression, if there isn’t a corresponding declaration for the named member, the expression is understood as a call to the type’s &lt;c0&gt;&lt;s1&gt;subscript(dynamicMemberLookup:)&lt;/s1&gt;&lt;/c0&gt; subscript, passing information about the member as the argument.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>明示的なメンバ式において、名前付きメンバに対して対応する宣言がないならば、式は型の持つ&lt;c0&gt;&lt;s1&gt;subscript(dynamicMemberLookup:)&lt;/s1&gt;&lt;/c0&gt;添え字に対する呼び出しとして理解されます、メンバについての情報を引数として渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In an initializer, constant properties can now only assign a value once.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある初期化において、定数プロパティは今ではただ一度しか値を割り当てることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In an initializer, subscript, or instance method, &lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt; refers to the current instance of the type in which it occurs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザ、添え字、またはインスタンスメソッドでは、&lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;はそれが現れているところの型の現在のインスタンスに言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In both cases, a write access to the tuple element requires a write access to the entire tuple.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方の場合において、タプル要素に対する書き込みアクセスは、タプル全体に対する書き込みアクセスを要求とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In both cases, it is written as &lt;c2&gt;&lt;s3&gt;(s1:&lt;/s3&gt; &lt;s4&gt;String,&lt;/s4&gt; &lt;s5&gt;s2:&lt;/s5&gt; &lt;s6&gt;String)&lt;/s6&gt; &lt;s7&gt;-&gt;&lt;/s7&gt; &lt;s8&gt;Bool&lt;/s8&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方の場合において、それは&lt;c2&gt;&lt;s3&gt;(s1:&lt;/s3&gt; &lt;s4&gt;String,&lt;/s4&gt; &lt;s5&gt;s2:&lt;/s5&gt; &lt;s6&gt;String)&lt;/s6&gt; &lt;s7&gt;-&gt;&lt;/s7&gt; &lt;s8&gt;Bool&lt;/s8&gt;&lt;/c2&gt;のように書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In both cases, program control is then transferred to the condition of the enclosing loop statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方の場合において、プログラム制御はそれから囲んでいるループ文の条件へ移されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In both cases, program control is then transferred to the first line of code following the enclosing loop or &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; statement, if any.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方の場合において、プログラム制御はそれから、もしあれば、それを囲んでいるループまたは&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;文に続くコードの最初の行へ移されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In both cases, the constant &lt;c0&gt;&lt;s1&gt;someArray&lt;/s1&gt;&lt;/c0&gt; is declared as an array of strings.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方の場合で、定数の&lt;c0&gt;&lt;s1&gt;someArray&lt;/s1&gt;&lt;/c0&gt;は、文字列の配列として宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In both cases, the constant &lt;c0&gt;&lt;s1&gt;someDictionary&lt;/s1&gt;&lt;/c0&gt; is declared as a dictionary with strings as keys and integers as values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方の場合で、定数&lt;c0&gt;&lt;s1&gt;someDictionary&lt;/s1&gt;&lt;/c0&gt;は、キーとして文字列そして値として整数を持つ辞書として宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In both cases, the letter &lt;c0&gt;&lt;s1&gt;é&lt;/s1&gt;&lt;/c0&gt; is represented as a single Swift &lt;c2&gt;&lt;s3&gt;Character&lt;/s3&gt;&lt;/c2&gt; value that represents an extended grapheme cluster.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方の場合で、文字&lt;c0&gt;&lt;s1&gt;é&lt;/s1&gt;&lt;/c0&gt;は、単一のスウィフトの&lt;c2&gt;&lt;s3&gt;Character&lt;/s3&gt;&lt;/c2&gt;値として表わされます、それはひとつの拡張書記素クラスタを表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In both cases, the value of the whole expression is an optional value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方の場合で、その全体の式の値は、オプショナルの値となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In both cases, the variable &lt;c0&gt;&lt;s1&gt;optionalInteger&lt;/s1&gt;&lt;/c0&gt; is declared to have the type of an optional integer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方の場合には、変数&lt;c0&gt;&lt;s1&gt;optionalInteger&lt;/s1&gt;&lt;/c0&gt;は、オプショナル整数の型を持つと宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In both cases, you add conformance to the standard library’s &lt;c15&gt;&lt;s16&gt;Equatable&lt;/s16&gt;&lt;/c15&gt; protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方の場合において、あなたは標準ライブラリのもつ&lt;c15&gt;&lt;s16&gt;Equatable&lt;/s16&gt;&lt;/c15&gt;プロトコルへの準拠を加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In both cases, you must mark the initializer implementation with the &lt;c0&gt;&lt;s1&gt;required&lt;/s1&gt;&lt;/c0&gt; modifier:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方の場合で、あなたはそのイニシャライザ実装を&lt;c0&gt;&lt;s1&gt;required&lt;/s1&gt;&lt;/c0&gt;修飾子で印しなければなりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In both of the examples above, the type information is passed up from the leaves of the expression tree to its root.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例の両方とも、型情報は、式ツリーの葉っぱから、その根までさかのぼって渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In certain constructs, operators with a leading &lt;c0&gt;&lt;s1&gt;&lt;&lt;/s1&gt;&lt;/c0&gt; or &lt;c2&gt;&lt;s3&gt;&gt;&lt;/s3&gt;&lt;/c2&gt; may be split into two or more tokens.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特定の構造物において、先導する&lt;c0&gt;&lt;s1&gt;&lt;&lt;/s1&gt;&lt;/c0&gt;または&lt;c2&gt;&lt;s3&gt;&gt;&lt;/s3&gt;&lt;/c2&gt;をもつ演算子は、２つ以上のトークンに分割されるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In code below, &lt;c8&gt;&lt;s9&gt;optionalString&lt;/s9&gt;&lt;/c8&gt; doesn’t have an explicit type so it’s an ordinary optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下のコードにおいて、&lt;c8&gt;&lt;s9&gt;optionalString&lt;/s9&gt;&lt;/c8&gt;は明示的な型を持ちません、それでそれは普通のオプショナルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast to optionals, which can use the presence or absence of a value to communicate success or failure of a function, error handling allows you to determine the underlying cause of failure, and, if necessary, propagate the error to another part of your program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルと対比して（それは値の有無を使って、ある関数の成否を伝えることができます）、エラー処理はあなたに根本的な失敗の原因を突き止めること、そして、必要ならば、そのエラーをあなたのプログラムの別の部分に伝えることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast to the &lt;c8&gt;&lt;s9&gt;willSet&lt;/s9&gt;&lt;/c8&gt; observer, the old value of the variable or property is passed to the &lt;c10&gt;&lt;s11&gt;didSet&lt;/s11&gt;&lt;/c10&gt; observer in case you still need access to it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c8&gt;&lt;s9&gt;willSet&lt;/s9&gt;&lt;/c8&gt;オブザーバーと対照的に、変数またはプロパティの古い値が、あなたがまだそれへのアクセスを必要とする場合に備えて&lt;c10&gt;&lt;s11&gt;didSet&lt;/s11&gt;&lt;/c10&gt;オブザーバーに渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast with &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; statements in C and Objective-C, &lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt; statements in Swift do not fall through the bottom of each case and into the next one by default.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>CおよびObjective-Cの&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;文とは対照的に、スウィフトの&lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt;文は、なにもしなくても、各ケース節の底を突き抜けて次のものに行ったりしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast with generic types, you don’t specify a generic argument clause when you use a generic function or initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体型と対照的に、あなたが総称体の関数やイニシャライザを使うとき、あなたは総称体引数節を指定しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, &lt;c8&gt;&lt;s9&gt;newString&lt;/s9&gt;&lt;/c8&gt; is a string—when it’s created from the substring, it has its own storage.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対照的に、&lt;c8&gt;&lt;s9&gt;newString&lt;/s9&gt;&lt;/c8&gt;は文字列です — それが下位文字列から作成されるとき、それはそれ独自のストレージを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, both lines of &lt;c8&gt;&lt;s9&gt;goodStart&lt;/s9&gt;&lt;/c8&gt; end with a line break, so when it’s combined with &lt;c10&gt;&lt;s11&gt;end&lt;/s11&gt;&lt;/c10&gt; the result has three lines, as expected.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対照的に、&lt;c8&gt;&lt;s9&gt;goodStart&lt;/s9&gt;&lt;/c8&gt;の行は両方とも改行で終わります、それでそれが&lt;c10&gt;&lt;s11&gt;end&lt;/s11&gt;&lt;/c10&gt;と結合される場合その結果は３行になります、予想通りに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, opaque types preserve the identity of the underlying type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対照的に、不透明型は基礎をなす型の同一性を保全します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, passing &lt;c6&gt;&lt;s7&gt;playerOneScore&lt;/s7&gt;&lt;/c6&gt; as the value for both parameters produces a conflict because it tries to perform two write accesses to the same location in memory at the same time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対照的に、&lt;c6&gt;&lt;s7&gt;playerOneScore&lt;/s7&gt;&lt;/c6&gt;をそれらパラメータ両方の値として渡すことは衝突を生み出します、なぜならそれは２つの書き込みアクセスをメモリ中の同じ位置に同じ時間に実行しようと試みるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, the closure passed to &lt;c8&gt;&lt;s9&gt;someFunctionWithNonescapingClosure(_:)&lt;/s9&gt;&lt;/c8&gt; is a nonescaping closure, which means it can refer to &lt;c10&gt;&lt;s11&gt;self&lt;/s11&gt;&lt;/c10&gt; implicitly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対照的に、&lt;c8&gt;&lt;s9&gt;someFunctionWithNonescapingClosure(_:)&lt;/s9&gt;&lt;/c8&gt;に渡されるクロージャは非脱出クロージャです、それは、それが&lt;c10&gt;&lt;s11&gt;self&lt;/s11&gt;&lt;/c10&gt;を暗黙的に参照できるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, the constants and variables created with a &lt;c4&gt;&lt;s5&gt;guard&lt;/s5&gt;&lt;/c4&gt; statement are available in the lines of code that follow the &lt;c6&gt;&lt;s7&gt;guard&lt;/s7&gt;&lt;/c6&gt; statement, as described in &lt;a8&gt;&lt;s9&gt;Early Exit&lt;/s9&gt;&lt;/a8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対照的に、&lt;c4&gt;&lt;s5&gt;guard&lt;/s5&gt;&lt;/c4&gt;文で作成された定数と変数は、その&lt;c6&gt;&lt;s7&gt;guard&lt;/s7&gt;&lt;/c6&gt;文以降のコード行において利用可能です、&lt;a8&gt;&lt;s9&gt;早期退出&lt;/s9&gt;&lt;/a8&gt;において議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, the two function calls marked “OK” don’t cause a compiler error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対照的に、「OK」と記される２つの関数呼び出しは、コンパイラエラーを引き起こしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, there is only one variable named &lt;c16&gt;&lt;s17&gt;b&lt;/s17&gt;&lt;/c16&gt;—the &lt;c18&gt;&lt;s19&gt;b&lt;/s19&gt;&lt;/c18&gt; in the outer scope—so changes from inside or outside the closure are visible in both places.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対照的に、&lt;c16&gt;&lt;s17&gt;b&lt;/s17&gt;&lt;/c16&gt;と名前を付けられるただ１つだけの変数があります ― 外側のスコープの中の&lt;c18&gt;&lt;s19&gt;b&lt;/s19&gt;&lt;/c18&gt; ― それでクロージャ内部および外部からの変更は、両方の場所で見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, two tuples of type &lt;c9&gt;&lt;s10&gt;(String,&lt;/s10&gt; &lt;s11&gt;Bool)&lt;/s11&gt;&lt;/c9&gt; can’t be compared with the &lt;c12&gt;&lt;s13&gt;&lt;&lt;/s13&gt;&lt;/c12&gt; operator because the &lt;c14&gt;&lt;s15&gt;&lt;&lt;/s15&gt;&lt;/c14&gt; operator can’t be applied to &lt;c16&gt;&lt;s17&gt;Bool&lt;/s17&gt;&lt;/c16&gt; values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対照的に、型&lt;c9&gt;&lt;s10&gt;(String,&lt;/s10&gt; &lt;s11&gt;Bool)&lt;/s11&gt;&lt;/c9&gt;の２つのタプルは&lt;c12&gt;&lt;s13&gt;&lt;&lt;/s13&gt;&lt;/c12&gt;演算子で比較できません、なぜなら&lt;c14&gt;&lt;s15&gt;&lt;&lt;/s15&gt;&lt;/c14&gt;演算子は&lt;c16&gt;&lt;s17&gt;Bool&lt;/s17&gt;&lt;/c16&gt;値に適用できるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, use an unowned reference when the other instance has the same lifetime or a longer lifetime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対照的に、非所有参照を他のインスタンスが同じ生涯またはより長い生涯を持つ場合に使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, value types are easier to reason about because all of the code that interacts with the same value is close together in your source files.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対照的に、値型について思考するのはより簡単です、なぜなら同じ値に相互作用するコードの全ては、あなたのソースファイルの中で近接しているからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, when creating a selector for a property’s setter, the &lt;e1&gt;property name&lt;/e1&gt; must be a reference to a variable property only.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対照的に、プロパティのセッターのためのセレクタを作成するとき、&lt;e1&gt;property name&lt;/e1&gt;は必ず変数プロパティへの参照でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In contrast, without parentheses, &lt;c8&gt;&lt;s9&gt;(Int,&lt;/s9&gt; &lt;s10&gt;Int)&lt;/s10&gt; &lt;s11&gt;-&gt;&lt;/s11&gt; &lt;s12&gt;Void&lt;/s12&gt;&lt;/c8&gt; is the type of a function that takes two &lt;c13&gt;&lt;s14&gt;Int&lt;/s14&gt;&lt;/c13&gt; parameters and doesn’t return any value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対して、丸括弧なしで、&lt;c8&gt;&lt;s9&gt;(Int,&lt;/s9&gt; &lt;s10&gt;Int)&lt;/s10&gt; &lt;s11&gt;-&gt;&lt;/s11&gt; &lt;s12&gt;Void&lt;/s12&gt;&lt;/c8&gt;は、２つの&lt;c13&gt;&lt;s14&gt;Int&lt;/s14&gt;&lt;/c13&gt;パラメータを取り、何ら値を返さない関数の型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In dot syntax, you write the property name immediately after the instance name, separated by a period (&lt;c1&gt;&lt;s2&gt;.&lt;/s2&gt;&lt;/c1&gt;), without any spaces:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ドット構文において、あなたはプロパティ名をインスタンス名の直後に、終止符（&lt;c1&gt;&lt;s2&gt;.&lt;/s2&gt;&lt;/c1&gt;）で区切り、どんな空白もなしで、書きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In each case, a new copy of the existing &lt;c8&gt;&lt;s9&gt;String&lt;/s9&gt;&lt;/c8&gt; value is created, and the new copy is passed or assigned, not the original version.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれの場合において、既存の&lt;c8&gt;&lt;s9&gt;String&lt;/s9&gt;&lt;/c8&gt;値の新しいコピーがつくられます、そしてその新しいコピーが渡されるか代入されます、元々のものではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In each case, the type parameter is replaced with an &lt;e6&gt;actual&lt;/e6&gt; type whenever the function is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれの場合において、型パラメータは、その関数が呼ばれるときはいつでも&lt;e6&gt;実際の&lt;/e6&gt;型と取り替えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In each form, the name of the operator can contain only the operator characters defined in &lt;a8&gt;&lt;s9&gt;Operators&lt;/s9&gt;&lt;/a8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各形式において、演算子の名前は&lt;a8&gt;&lt;s9&gt;演算子&lt;/s9&gt;&lt;/a8&gt;で定義される演算子文字だけを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In each form, the opening and closing braces are required.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各形式で、開始と終了の波括弧は必須です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In either case, if you delegate to another initializer that causes initialization to fail, the entire initialization process fails immediately, and no further initialization code is executed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どちらの場合においても、あなたが初期化失敗の原因となる別のイニシャライザに委任するならば、全体の初期化プロセスは直ちに失敗します、そしてそれ以上初期化コードが実行されることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In either case, the value of the postfix expression is still of an optional type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いずれにせよ、接尾辞式の値は、依然としてオプショナル型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In either case, these accesses cause the closure to “capture” &lt;c4&gt;&lt;s5&gt;self&lt;/s5&gt;&lt;/c4&gt;, creating a strong reference cycle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いずれにせよ、これらのアクセスは、クロージャが強い参照循環をつくって&lt;c4&gt;&lt;s5&gt;self&lt;/s5&gt;&lt;/c4&gt;を「捕獲する」ことを引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In essence, it’s the same problem as above—two strong references are keeping each other alive.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>本質において、それは上記と同じ問題です ― ２つの強い参照が、お互いを生かし続けています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, &lt;c2&gt;&lt;s3&gt;someFunction()&lt;/s3&gt;&lt;/c2&gt; won’t compile as written below:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実際、&lt;c2&gt;&lt;s3&gt;someFunction()&lt;/s3&gt;&lt;/c2&gt;は以下のように書かれるときコンパイルしないでしょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, all of the basic types in Swift—integers, floating-point numbers, Booleans, strings, arrays and dictionaries—are value types, and are implemented as structures behind the scenes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実際、スウィフトにおける基本の型の全て ― 整数、浮動小数点数、ブール、文字列、配列および辞書 ― は、値型であり、そして舞台裏では構造体として実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, if the &lt;e4&gt;first&lt;/e4&gt; value is &lt;c5&gt;&lt;s6&gt;false&lt;/s6&gt;&lt;/c5&gt;, the second value won’t even be evaluated, because it can’t possibly make the overall expression equate to &lt;c7&gt;&lt;s8&gt;true&lt;/s8&gt;&lt;/c7&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実際には、&lt;e4&gt;最初の&lt;/e4&gt;値が&lt;c5&gt;&lt;s6&gt;false&lt;/s6&gt;&lt;/c5&gt;ならば、２番目の値は評価されさえしません、なぜならそれがどうやっても式全体を&lt;c7&gt;&lt;s8&gt;true&lt;/s8&gt;&lt;/c7&gt;と等しくすることが出来ないためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, in cases where there isn’t a meaningful raw value, you don’t have to provide one.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実際、意味がある生の値がない状況の場合には、あなたはそれを提供する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, the point (0, 0) could match all &lt;e2&gt;four&lt;/e2&gt; of the cases in this example.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実際、点(0, 0)は、この例ではケース節の&lt;e2&gt;４つ&lt;/e2&gt;全てに適合することができました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, you’ve been using generics throughout the &lt;e0&gt;Language Guide&lt;/e0&gt;, even if you didn’t realize it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実際、たとえあなたがそれを実感しなかったとしても、あなたはこの&lt;e0&gt;言語ガイド&lt;/e0&gt;を通して総称体を使用していました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In its general form, the availability condition takes a list of platform names and versions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それの一般的な形式において、有効性条件はプラットホーム名とバージョンを取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In its initializer, the &lt;c4&gt;&lt;s5&gt;Hoverboard&lt;/s5&gt;&lt;/c4&gt; class sets only its &lt;c6&gt;&lt;s7&gt;color&lt;/s7&gt;&lt;/c6&gt; property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのイニシャライザにおいて、&lt;c4&gt;&lt;s5&gt;Hoverboard&lt;/s5&gt;&lt;/c4&gt;クラスはそれの&lt;c6&gt;&lt;s7&gt;color&lt;/s7&gt;&lt;/c6&gt;プロパティのみを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In its simplest form, a &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; statement compares a value against one or more values of the same type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その最も単純な形式では、&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;文は、ある値を、同じ型の１つ以上の値に対して比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In its simplest form, a stored property is a constant or variable that is stored as part of an instance of a particular class or structure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その最も単純な形式で、格納プロパティは、特定のクラスまたは構造体のあるひとつのインスタンスの一部として格納される定数または変数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In its simplest form, an initializer is like an instance method with no parameters, written using the &lt;c1&gt;&lt;s2&gt;init&lt;/s2&gt;&lt;/c1&gt; keyword:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その最も単純な形式では、イニシャライザはパラメータのないインスタンスメソッドのようです、そして&lt;c1&gt;&lt;s2&gt;init&lt;/s2&gt;&lt;/c1&gt;キーワードを使用して書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In its simplest form, the &lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt; statement has a single &lt;c2&gt;&lt;s3&gt;if&lt;/s3&gt;&lt;/c2&gt; condition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その最も単純な形式において、&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt;文はただ１つだけの&lt;c2&gt;&lt;s3&gt;if&lt;/s3&gt;&lt;/c2&gt;条件を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In library evolution mode, code that interacts with members of nonfrozen structures and enumerations is compiled in a way that allows it to continue working without recompiling even if a future version of the library adds, removes, or reorders some of that type’s members.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ライブラリ進化モードでは、非凍結の構造体および列挙のメンバーと相互作用するコードは、ある方法でコンパイルされます、それは、再コンパイルすることなしにそれに仕事を継続させます、たとえ将来のバージョンのライブラリが追加する、削除する、またはその型のもつメンバーのいくつかを再配置するとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In many simple cases, you can ask Swift to provide synthesized implementations of the equivalence operators for you.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>多くの単純な場合では、あなたはスウィフトに頼むことで、等価演算子の合成された実装をあなたに提供できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In most cases, &lt;c3&gt;&lt;s4&gt;wrappedValue&lt;/s4&gt;&lt;/c3&gt; is a computed value, but it can be a stored value instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ほとんどの場合には、&lt;c3&gt;&lt;s4&gt;wrappedValue&lt;/s4&gt;&lt;/c3&gt;は計算される値です、しかしそれは代わりに格納される値であることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In most cases, this means that memory management “just works” in Swift, and you do not need to think about memory management yourself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ほとんどの場合、これは、スウィフトにおいてメモリ管理が「正確に機能する」こと、そしてあなたはあなた自身でメモリ管理について考える必要がないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In most cases, tokens are generated from the characters of a Swift source file by considering the longest possible substring from the input text, within the constraints of the grammar that are specified below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ほとんどの場合、トークンは、スウィフトのソースファイルの文字から、下で指定される文法の制約の範囲内で、その入力テキストからの最も長く取ることのできる下位文字列を考慮することによって生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In most cases, type parameters have descriptive names, such as &lt;c0&gt;&lt;s1&gt;Key&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;Value&lt;/s3&gt;&lt;/c2&gt; in &lt;c4&gt;&lt;s5&gt;Dictionary&lt;Key,&lt;/s5&gt; &lt;s6&gt;Value&gt;&lt;/s6&gt;&lt;/c4&gt; and &lt;c7&gt;&lt;s8&gt;Element&lt;/s8&gt;&lt;/c7&gt; in &lt;c9&gt;&lt;s10&gt;Array&lt;Element&gt;&lt;/s10&gt;&lt;/c9&gt;, which tells the reader about the relationship between the type parameter and the generic type or function it’s used in.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ほとんどの場合には、型パラメータは描写的な名前を持ちます、たとえば&lt;c4&gt;&lt;s5&gt;Dictionary&lt;Key,&lt;/s5&gt; &lt;s6&gt;Value&gt;&lt;/s6&gt;&lt;/c4&gt;における&lt;c0&gt;&lt;s1&gt;Key&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;Value&lt;/s3&gt;&lt;/c2&gt;および&lt;c9&gt;&lt;s10&gt;Array&lt;Element&gt;&lt;/s10&gt;&lt;/c9&gt;における&lt;c7&gt;&lt;s8&gt;Element&lt;/s8&gt;&lt;/c7&gt;など、それは読み手に型パラメータとそれがその中で使われる総称体型や関数との関係について語ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In most cases, you don’t need to pick a specific size of integer to use in your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ほとんどの場合、あなたはあなたのコードにおいて使用するのに整数の特定のサイズを選択する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order for this rule to be satisfied, a designated initializer must make sure that all of its own properties are initialized before it hands off up the chain.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この規則が満たされるために、指定イニシャライザは、それがその連鎖を上って手渡す前に、それ自身のプロパティの全てが初期化されることを確認しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to work with them as their native type, you need to &lt;e12&gt;check&lt;/e12&gt; their type, or &lt;e13&gt;downcast&lt;/e13&gt; them to a different type, as described below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらをそれらの生来の型として取り扱うために、下で述べるように、あなたはそれらの型を&lt;e12&gt;調べる&lt;/e12&gt;こと、またはそれらを異なる型へ&lt;e13&gt;ダウンキャスト&lt;/e13&gt;することが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, the following two declarations are equivalent:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>言い換えると、以下の２つの宣言は、等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, a protocol can declare that conforming types must implement certain properties, methods, initializers, and subscripts.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に、プロトコルは、準拠している型が特定のプロパティ、メソッド、イニシャライザ、そして添え字を実装しなければならないと宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, the &lt;e4&gt;raw-value type&lt;/e4&gt; must conform to the &lt;c5&gt;&lt;s6&gt;Equatable&lt;/s6&gt;&lt;/c5&gt; protocol and one of the following protocols: &lt;c7&gt;&lt;s8&gt;ExpressibleByIntegerLiteral&lt;/s8&gt;&lt;/c7&gt; for integer literals, &lt;c9&gt;&lt;s10&gt;ExpressibleByFloatLiteral&lt;/s10&gt;&lt;/c9&gt; for floating-point literals, &lt;c11&gt;&lt;s12&gt;ExpressibleByStringLiteral&lt;/s12&gt;&lt;/c11&gt; for string literals that contain any number of characters, and &lt;c13&gt;&lt;s14&gt;ExpressibleByUnicodeScalarLiteral&lt;/s14&gt;&lt;/c13&gt; or &lt;c15&gt;&lt;s16&gt;ExpressibleByExtendedGraphemeClusterLiteral&lt;/s16&gt;&lt;/c15&gt; for string literals that contain only a single character.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に、&lt;e4&gt;生の値型&lt;/e4&gt;は、&lt;c5&gt;&lt;s6&gt;Equatable&lt;/s6&gt;&lt;/c5&gt;プロトコルおよび次のプロトコルの内の１つに準拠しなければなりません：整数リテラルのための&lt;c7&gt;&lt;s8&gt;ExpressibleByIntegerLiteral&lt;/s8&gt;&lt;/c7&gt;、浮動小数点リテラルのための&lt;c9&gt;&lt;s10&gt;ExpressibleByFloatLiteral&lt;/s10&gt;&lt;/c9&gt;、随意の数の文字を含む文字列リテラルのための&lt;c11&gt;&lt;s12&gt;ExpressibleByStringLiteral&lt;/s12&gt;&lt;/c11&gt;、そしてただ１つの文字だけを含む文字列リテラルのための&lt;c13&gt;&lt;s14&gt;ExpressibleByUnicodeScalarLiteral&lt;/s14&gt;&lt;/c13&gt;または&lt;c15&gt;&lt;s16&gt;ExpressibleByExtendedGraphemeClusterLiteral&lt;/s16&gt;&lt;/c15&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, the order you insert items into a &lt;c2&gt;&lt;s3&gt;Dictionary&lt;/s3&gt;&lt;/c2&gt; doesn’t define the order they are iterated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に、あなたが&lt;c2&gt;&lt;s3&gt;Dictionary&lt;/s3&gt;&lt;/c2&gt;へと項目を挿入する順序はそれらが反復される順序を定義しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In practice, most access to the properties of a structure can overlap safely.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実際には、構造体のプロパティに対するほとんどのアクセスは安全にオーバーラップできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In practice, this means most of the custom data types you define will be structures and enumerations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実際問題としては、これは、あなたが定義するほとんどのあつらえのデータ型は構造体や列挙になることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In practice, this means that you do not need to write initializer overrides in many common scenarios, and can inherit your superclass initializers with minimal effort whenever it is safe to do so.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実際問題として、これは、あなたが多くの通常の状況ではイニシャライザのオーバーライドを書く必要がなく、そしてそれが安全にそうできる時はいつでも最小の努力であなたのスーパークラスのイニシャライザを継承することができることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In practice, you don’t need to write &lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt; in your code very often.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実際問題として、あなたは頻繁にあなたのコードに&lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;を書く必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In production builds, the condition inside an assertion isn’t evaluated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロダクションビルドでは、表明内の条件は評価されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In situations where either type would be appropriate, &lt;c4&gt;&lt;s5&gt;Double&lt;/s5&gt;&lt;/c4&gt; is preferred.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どちらの型でも適切である状況では、&lt;c4&gt;&lt;s5&gt;Double&lt;/s5&gt;&lt;/c4&gt;が望ましいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some cases, this requirement is satisfied by inheriting one or more designated initializers from a superclass, as described in &lt;a0&gt;&lt;s1&gt;Automatic Initializer Inheritance&lt;/s1&gt;&lt;/a0&gt; below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>若干の場合には、この必要条件は、下記の&lt;a0&gt;&lt;s1&gt;自動的なイニシャライザ継承&lt;/s1&gt;&lt;/a0&gt;で記述されるように、あるスーパークラスから１つ以上の指定イニシャライザを継承することによって満たされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some generic contexts, types that get behavior from conditional conformance to a protocol don’t always use the specialized implementations of that protocol’s requirements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いくつかの総称体文脈では、あるプロトコルに対する条件準拠由来の挙動を持つ型は、そのプロトコルの要件の特殊化された実装を必ず使うとは限りません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some situations, you might not want to use closed ranges, which include both endpoints.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じ状況において、あなたは完結範囲を使いたいと思うかもしれません、それは両方の終端を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In systems that use garbage collection, weak pointers are sometimes used to implement a simple caching mechanism because objects with no strong references are deallocated only when memory pressure triggers garbage collection.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ガベージコレクションを使うシステムにおいて、時おり弱いポインタが簡単なキャッシュの仕組みを実装するために使われます、なぜなら強い参照を持たないオブジェクトは、メモリの逼迫がガベージコレクションを引き起こす時のみに割り当て解除されるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In that context, &lt;c4&gt;&lt;s5&gt;Self&lt;/s5&gt;&lt;/c4&gt; refers to the eventual type that conforms to the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その文脈で、&lt;c4&gt;&lt;s5&gt;Self&lt;/s5&gt;&lt;/c4&gt;はそのプロトコルに準拠する結果として生じる型に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the &lt;c0&gt;&lt;s1&gt;Apartment&lt;/s1&gt;&lt;/c0&gt; example above, it’s appropriate for an apartment to be able to have no tenant at some point in its lifetime, and so a weak reference is an appropriate way to break the reference cycle in this case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の&lt;c0&gt;&lt;s1&gt;Apartment&lt;/s1&gt;&lt;/c0&gt;例において、あるアパートがその生涯のどこかの時点で賃借人がいないことがあるというのは妥当です、なのでこの場合は弱い参照が参照循環を壊す適切な方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the &lt;c0&gt;&lt;s1&gt;CompassPoint&lt;/s1&gt;&lt;/c0&gt; example above, &lt;c2&gt;&lt;s3&gt;north&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;south&lt;/s5&gt;&lt;/c4&gt;, &lt;c6&gt;&lt;s7&gt;east&lt;/s7&gt;&lt;/c6&gt; and &lt;c8&gt;&lt;s9&gt;west&lt;/s9&gt;&lt;/c8&gt; don’t implicitly equal &lt;c10&gt;&lt;s11&gt;0&lt;/s11&gt;&lt;/c10&gt;, &lt;c12&gt;&lt;s13&gt;1&lt;/s13&gt;&lt;/c12&gt;, &lt;c14&gt;&lt;s15&gt;2&lt;/s15&gt;&lt;/c14&gt; and &lt;c16&gt;&lt;s17&gt;3&lt;/s17&gt;&lt;/c16&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の&lt;c0&gt;&lt;s1&gt;CompassPoint&lt;/s1&gt;&lt;/c0&gt;例で、&lt;c2&gt;&lt;s3&gt;north&lt;/s3&gt;&lt;/c2&gt;、&lt;c4&gt;&lt;s5&gt;south&lt;/s5&gt;&lt;/c4&gt;、&lt;c6&gt;&lt;s7&gt;east&lt;/s7&gt;&lt;/c6&gt;そして&lt;c8&gt;&lt;s9&gt;west&lt;/s9&gt;&lt;/c8&gt;は、暗黙のうちに&lt;c10&gt;&lt;s11&gt;0&lt;/s11&gt;&lt;/c10&gt;、&lt;c12&gt;&lt;s13&gt;1&lt;/s13&gt;&lt;/c12&gt;、&lt;c14&gt;&lt;s15&gt;2&lt;/s15&gt;&lt;/c14&gt;そして&lt;c16&gt;&lt;s17&gt;3&lt;/s17&gt;&lt;/c16&gt;に等しくはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the &lt;c0&gt;&lt;s1&gt;SmallNumber&lt;/s1&gt;&lt;/c0&gt; example above, if you try to set the property to a number that’s too large, the property wrapper adjusts the number before storing it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の&lt;c0&gt;&lt;s1&gt;SmallNumber&lt;/s1&gt;&lt;/c0&gt;例において、あなたがプロパティをある大きすぎる数へと設定しようとするならば、プロパティラッパーはその数を調節します、それを格納する前に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the &lt;c0&gt;&lt;s1&gt;nourish(with:)&lt;/s1&gt;&lt;/c0&gt; function, if &lt;c2&gt;&lt;s3&gt;vend(itemNamed:)&lt;/s3&gt;&lt;/c2&gt; throws an error that’s one of the cases of the &lt;c4&gt;&lt;s5&gt;VendingMachineError&lt;/s5&gt;&lt;/c4&gt; enumeration, &lt;c6&gt;&lt;s7&gt;nourish(with:)&lt;/s7&gt;&lt;/c6&gt; handles the error by printing a message.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;nourish(with:)&lt;/s1&gt;&lt;/c0&gt;関数において、&lt;c2&gt;&lt;s3&gt;vend(itemNamed:)&lt;/s3&gt;&lt;/c2&gt;が&lt;c4&gt;&lt;s5&gt;VendingMachineError&lt;/s5&gt;&lt;/c4&gt;列挙のケース節の１つであるエラーをスローするならば、&lt;c6&gt;&lt;s7&gt;nourish(with:)&lt;/s7&gt;&lt;/c6&gt;はそのエラーをメッセージを出力することによって取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the &lt;c0&gt;&lt;s1&gt;restoreHealth()&lt;/s1&gt;&lt;/c0&gt; method above, a write access to &lt;c2&gt;&lt;s3&gt;self&lt;/s3&gt;&lt;/c2&gt; starts at the beginning of the method and lasts until the method returns.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の&lt;c0&gt;&lt;s1&gt;restoreHealth()&lt;/s1&gt;&lt;/c0&gt;メソッドにおいて、&lt;c2&gt;&lt;s3&gt;self&lt;/s3&gt;&lt;/c2&gt;への書き込みアクセスはメソッドの始まりで開始してメソッドが返るまでの間続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the &lt;c0&gt;&lt;s1&gt;swapTwoValues(_:_:)&lt;/s1&gt;&lt;/c0&gt; example above, the placeholder type &lt;c2&gt;&lt;s3&gt;T&lt;/s3&gt;&lt;/c2&gt; is an example of a &lt;e4&gt;type parameter&lt;/e4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の&lt;c0&gt;&lt;s1&gt;swapTwoValues(_:_:)&lt;/s1&gt;&lt;/c0&gt;例で、プレースホルダ型&lt;c2&gt;&lt;s3&gt;T&lt;/s3&gt;&lt;/c2&gt;は&lt;e4&gt;型パラメータ&lt;/e4&gt;の一例です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the &lt;c12&gt;&lt;s13&gt;repeat&lt;/s13&gt;&lt;/c12&gt;-&lt;c14&gt;&lt;s15&gt;while&lt;/s15&gt;&lt;/c14&gt; loop above, &lt;c16&gt;&lt;s17&gt;square&lt;/s17&gt; &lt;s18&gt;+=&lt;/s18&gt; &lt;s19&gt;board[square]&lt;/s19&gt;&lt;/c16&gt; is always executed &lt;e20&gt;immediately after&lt;/e20&gt; the loop’s &lt;c21&gt;&lt;s22&gt;while&lt;/s22&gt;&lt;/c21&gt; condition confirms that &lt;c23&gt;&lt;s24&gt;square&lt;/s24&gt;&lt;/c23&gt; is still on the board.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の&lt;c12&gt;&lt;s13&gt;repeat&lt;/s13&gt;&lt;/c12&gt;-&lt;c14&gt;&lt;s15&gt;while&lt;/s15&gt;&lt;/c14&gt;ループにおいて、&lt;c16&gt;&lt;s17&gt;square&lt;/s17&gt; &lt;s18&gt;+=&lt;/s18&gt; &lt;s19&gt;board[square]&lt;/s19&gt;&lt;/c16&gt;は常に、このループの&lt;c21&gt;&lt;s22&gt;while&lt;/s22&gt;&lt;/c21&gt;条件が&lt;c23&gt;&lt;s24&gt;square&lt;/s24&gt;&lt;/c23&gt;はまだ盤上かを確認した&lt;e20&gt;直後&lt;/e20&gt;に実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the &lt;c2&gt;&lt;s3&gt;welcomeMessage&lt;/s3&gt;&lt;/c2&gt; example above, no initial value is provided, and so the type of the &lt;c4&gt;&lt;s5&gt;welcomeMessage&lt;/s5&gt;&lt;/c4&gt; variable is specified with a type annotation rather than being inferred from an initial value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の&lt;c2&gt;&lt;s3&gt;welcomeMessage&lt;/s3&gt;&lt;/c2&gt;の例では、初期値が提供されません、それで&lt;c4&gt;&lt;s5&gt;welcomeMessage&lt;/s5&gt;&lt;/c4&gt;変数の型は、最初の値から推論されるのではなく、型注釈で指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the above example, &lt;c0&gt;&lt;s1&gt;approximateCount&lt;/s1&gt;&lt;/c0&gt; is evaluated in a &lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt; statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、&lt;c0&gt;&lt;s1&gt;approximateCount&lt;/s1&gt;&lt;/c0&gt;は&lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt;文において評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the above example, the &lt;c0&gt;&lt;s1&gt;buyFavoriteSnack(person:vendingMachine:)&lt;/s1&gt;&lt;/c0&gt; function is called in a &lt;c2&gt;&lt;s3&gt;try&lt;/s3&gt;&lt;/c2&gt; expression, because it can throw an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例において、&lt;c0&gt;&lt;s1&gt;buyFavoriteSnack(person:vendingMachine:)&lt;/s1&gt;&lt;/c0&gt;関数は&lt;c2&gt;&lt;s3&gt;try&lt;/s3&gt;&lt;/c2&gt;式の中で呼び出されます、それがエラーをスローできるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the above example, the raw value of &lt;c0&gt;&lt;s1&gt;ExampleEnum.a&lt;/s1&gt;&lt;/c0&gt; is &lt;c2&gt;&lt;s3&gt;0&lt;/s3&gt;&lt;/c2&gt; and the value of &lt;c4&gt;&lt;s5&gt;ExampleEnum.b&lt;/s5&gt;&lt;/c4&gt; is &lt;c6&gt;&lt;s7&gt;1&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上記の例で、&lt;c0&gt;&lt;s1&gt;ExampleEnum.a&lt;/s1&gt;&lt;/c0&gt;の値は&lt;c2&gt;&lt;s3&gt;0&lt;/s3&gt;&lt;/c2&gt;です、そして&lt;c4&gt;&lt;s5&gt;ExampleEnum.b&lt;/s5&gt;&lt;/c4&gt;の値は&lt;c6&gt;&lt;s7&gt;1&lt;/s7&gt;&lt;/c6&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the above example, the raw value of &lt;c0&gt;&lt;s1&gt;GamePlayMode.cooperative&lt;/s1&gt;&lt;/c0&gt; is &lt;c2&gt;&lt;s3&gt;"cooperative"&lt;/s3&gt;&lt;/c2&gt;, the raw value of &lt;c4&gt;&lt;s5&gt;GamePlayMode.individual&lt;/s5&gt;&lt;/c4&gt; is &lt;c6&gt;&lt;s7&gt;"individual"&lt;/s7&gt;&lt;/c6&gt;, and the raw value of &lt;c8&gt;&lt;s9&gt;GamePlayMode.competitive&lt;/s9&gt;&lt;/c8&gt; is &lt;c10&gt;&lt;s11&gt;"competitive"&lt;/s11&gt;&lt;/c10&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例において、&lt;c0&gt;&lt;s1&gt;GamePlayMode.cooperative&lt;/s1&gt;&lt;/c0&gt;の生の値は&lt;c2&gt;&lt;s3&gt;"cooperative"&lt;/s3&gt;&lt;/c2&gt;です、&lt;c4&gt;&lt;s5&gt;GamePlayMode.individual&lt;/s5&gt;&lt;/c4&gt;の生の値は&lt;c6&gt;&lt;s7&gt;"individual"&lt;/s7&gt;&lt;/c6&gt;です、そして&lt;c8&gt;&lt;s9&gt;GamePlayMode.competitive&lt;/s9&gt;&lt;/c8&gt;の生の値は&lt;c10&gt;&lt;s11&gt;"competitive"&lt;/s11&gt;&lt;/c10&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the body of a method</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッドの本文において</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the body of the function, the copy is modified.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数の本体において、そのコピーが修正されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the case of the &lt;c0&gt;&lt;s1&gt;sorted(by:)&lt;/s1&gt;&lt;/c0&gt; method, the purpose of the closure is clear from the fact that sorting is taking place, and it is safe for a reader to assume that the closure is likely to be working with &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt; values, because it is assisting with the sorting of an array of strings.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;sorted(by:)&lt;/s1&gt;&lt;/c0&gt;メソッドの場合、クロージャの目的はソートが行われているという事実から明快です、そして、読者がクロージャは&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;値を扱っているようだと仮定しても差し支えありません、なぜならそれがいくつかの文字列からなる配列のソートを手伝っているからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the case where it equals &lt;c11&gt;&lt;s12&gt;.south&lt;/s12&gt;&lt;/c11&gt;, print &lt;c13&gt;&lt;s14&gt;"Watch&lt;/s14&gt; &lt;s15&gt;out&lt;/s15&gt; &lt;s16&gt;for&lt;/s16&gt; &lt;s17&gt;penguins"&lt;/s17&gt;&lt;/c13&gt;.”</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが&lt;c11&gt;&lt;s12&gt;.south&lt;/s12&gt;&lt;/c11&gt;に等しい場合には、&lt;c13&gt;&lt;s14&gt;"Watch&lt;/s14&gt; &lt;s15&gt;out&lt;/s15&gt; &lt;s16&gt;for&lt;/s16&gt; &lt;s17&gt;penguins"&lt;/s17&gt;&lt;/c13&gt;を出力する。」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the case where it equals &lt;c2&gt;&lt;s3&gt;.north&lt;/s3&gt;&lt;/c2&gt;, print &lt;c4&gt;&lt;s5&gt;"Lots&lt;/s5&gt; &lt;s6&gt;of&lt;/s6&gt; &lt;s7&gt;planets&lt;/s7&gt; &lt;s8&gt;have&lt;/s8&gt; &lt;s9&gt;a&lt;/s9&gt; &lt;s10&gt;north"&lt;/s10&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが&lt;c2&gt;&lt;s3&gt;.north&lt;/s3&gt;&lt;/c2&gt;に等しい場合には、&lt;c4&gt;&lt;s5&gt;"Lots&lt;/s5&gt; &lt;s6&gt;of&lt;/s6&gt; &lt;s7&gt;planets&lt;/s7&gt; &lt;s8&gt;have&lt;/s8&gt; &lt;s9&gt;a&lt;/s9&gt; &lt;s10&gt;north"&lt;/s10&gt;&lt;/c4&gt;を出力する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the code above, &lt;c0&gt;&lt;s1&gt;stepSize&lt;/s1&gt;&lt;/c0&gt; is a global variable, and it is normally accessible from within &lt;c2&gt;&lt;s3&gt;increment(_:)&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のコードにおいて、&lt;c0&gt;&lt;s1&gt;stepSize&lt;/s1&gt;&lt;/c0&gt;はグローバル変数です、そしてそれは通常は&lt;c2&gt;&lt;s3&gt;increment(_:)&lt;/s3&gt;&lt;/c2&gt;内部からアクセス可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the code above, both of the parameters to &lt;c0&gt;&lt;s1&gt;takesTwoFunctions(first:second:)&lt;/s1&gt;&lt;/c0&gt; are functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のコードにおいて、&lt;c0&gt;&lt;s1&gt;takesTwoFunctions(first:second:)&lt;/s1&gt;&lt;/c0&gt;へのパラメータは両方とも関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the code above, concatenating &lt;c0&gt;&lt;s1&gt;badStart&lt;/s1&gt;&lt;/c0&gt; with &lt;c2&gt;&lt;s3&gt;end&lt;/s3&gt;&lt;/c2&gt; produces a two-line string, which isn’t the desired result.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のコードにおいて、&lt;c0&gt;&lt;s1&gt;badStart&lt;/s1&gt;&lt;/c0&gt;を&lt;c2&gt;&lt;s3&gt;end&lt;/s3&gt;&lt;/c2&gt;と連結することは、２行の文字列を生成します、それは望んだ結果ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the code above, instead of calling the closure passed to it as its &lt;c0&gt;&lt;s1&gt;customerProvider&lt;/s1&gt;&lt;/c0&gt; argument, the &lt;c2&gt;&lt;s3&gt;collectCustomerProviders(_:)&lt;/s3&gt;&lt;/c2&gt; function appends the closure to the &lt;c4&gt;&lt;s5&gt;customerProviders&lt;/s5&gt;&lt;/c4&gt; array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のコードにおいて、それの&lt;c0&gt;&lt;s1&gt;customerProvider&lt;/s1&gt;&lt;/c0&gt;引数としてそれに渡されるクロージャを呼び出す代わりに、&lt;c2&gt;&lt;s3&gt;collectCustomerProviders(_:)&lt;/s3&gt;&lt;/c2&gt;関数は、そのクロージャを&lt;c4&gt;&lt;s5&gt;customerProviders&lt;/s5&gt;&lt;/c4&gt;配列に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the code above, the optional value &lt;c0&gt;&lt;s1&gt;assumedString&lt;/s1&gt;&lt;/c0&gt; is force-unwrapped before assigning its value to &lt;c2&gt;&lt;s3&gt;implicitString&lt;/s3&gt;&lt;/c2&gt; because &lt;c4&gt;&lt;s5&gt;implicitString&lt;/s5&gt;&lt;/c4&gt; has an explicit, non-optional type of &lt;c6&gt;&lt;s7&gt;String&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のコードにおいて、オプショナル値&lt;c0&gt;&lt;s1&gt;assumedString&lt;/s1&gt;&lt;/c0&gt;は強制アンラップされます、それの値を&lt;c2&gt;&lt;s3&gt;implicitString&lt;/s3&gt;&lt;/c2&gt;に割り当てる前にです、なぜなら&lt;c4&gt;&lt;s5&gt;implicitString&lt;/s5&gt;&lt;/c4&gt;はある明示的な、非オプショナル型の&lt;c6&gt;&lt;s7&gt;String&lt;/s7&gt;&lt;/c6&gt;を持つからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the code below, &lt;c6&gt;&lt;s7&gt;john&lt;/s7&gt;&lt;/c6&gt; has a &lt;c8&gt;&lt;s9&gt;residence&lt;/s9&gt;&lt;/c8&gt; property value of &lt;c10&gt;&lt;s11&gt;nil&lt;/s11&gt;&lt;/c10&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下記のコードにおいて、&lt;c6&gt;&lt;s7&gt;john&lt;/s7&gt;&lt;/c6&gt;は&lt;c10&gt;&lt;s11&gt;nil&lt;/s11&gt;&lt;/c10&gt;の&lt;c8&gt;&lt;s9&gt;residence&lt;/s9&gt;&lt;/c8&gt;プロパティ値を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the code below, the &lt;c2&gt;&lt;s3&gt;TwelveOrLess&lt;/s3&gt;&lt;/c2&gt; structure ensures that the value it wraps always contains a number less than or equal to 12.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下のコードにおいて、&lt;c2&gt;&lt;s3&gt;TwelveOrLess&lt;/s3&gt;&lt;/c2&gt;構造体は、それがラップする値が常に12より少ないか等しいある数を含むことを保証します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the code example below, the dictionary’s keys are decomposed into a constant called &lt;c10&gt;&lt;s11&gt;animalName&lt;/s11&gt;&lt;/c10&gt;, and the dictionary’s values are decomposed into a constant called &lt;c12&gt;&lt;s13&gt;legCount&lt;/s13&gt;&lt;/c12&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下のコード例において、辞書のキーは&lt;c10&gt;&lt;s11&gt;animalName&lt;/s11&gt;&lt;/c10&gt;と呼ばれる定数へと分解されます、そして辞書の値は&lt;c12&gt;&lt;s13&gt;legCount&lt;/s13&gt;&lt;/c12&gt;と呼ばれる定数へと分解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the context of &lt;c4&gt;&lt;s5&gt;Vector2D&lt;/s5&gt;&lt;/c4&gt;, it makes sense to consider “equal” as meaning “both instances have the same &lt;c6&gt;&lt;s7&gt;x&lt;/s7&gt;&lt;/c6&gt; values and &lt;c8&gt;&lt;s9&gt;y&lt;/s9&gt;&lt;/c8&gt; values”, and so this is the logic used by the operator implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;Vector2D&lt;/s5&gt;&lt;/c4&gt;の文脈では、「同等」を「両方のインスタンスが同じ&lt;c6&gt;&lt;s7&gt;x&lt;/s7&gt;&lt;/c6&gt;値と&lt;c8&gt;&lt;s9&gt;y&lt;/s9&gt;&lt;/c8&gt;値を持つ」ことを意味すると考えるのが道理にかなっています、なのでそれが演算子実装によって使われる論理です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the door access example above, it’s useful to add parentheses around the first part of the compound expression to make its intent explicit:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のドア・アクセスの例で、その意図を明確にするために複合式の最初の部分のまわりに丸括弧を加えることは、役に立ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, &lt;c0&gt;&lt;s1&gt;Ace&lt;/s1&gt;&lt;/c0&gt; is explicitly given a raw value of &lt;c2&gt;&lt;s3&gt;1&lt;/s3&gt;&lt;/c2&gt;, and the rest of the raw values are assigned in order.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例では、&lt;c0&gt;&lt;s1&gt;Ace&lt;/s1&gt;&lt;/c0&gt;は暗黙的に&lt;c2&gt;&lt;s3&gt;1&lt;/s3&gt;&lt;/c2&gt;の生の値を与えられます、そして残りの生の値は順に割り当てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, &lt;c0&gt;&lt;s1&gt;CompassPoint.south&lt;/s1&gt;&lt;/c0&gt; has an implicit raw value of &lt;c2&gt;&lt;s3&gt;"south"&lt;/s3&gt;&lt;/c2&gt;, and so on.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例において、&lt;c0&gt;&lt;s1&gt;CompassPoint.south&lt;/s1&gt;&lt;/c0&gt;は暗黙的な生の値の&lt;c2&gt;&lt;s3&gt;"south"&lt;/s3&gt;&lt;/c2&gt;をもちます、等々。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, &lt;c0&gt;&lt;s1&gt;Planet.mercury&lt;/s1&gt;&lt;/c0&gt; has an explicit raw value of &lt;c2&gt;&lt;s3&gt;1&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;Planet.venus&lt;/s5&gt;&lt;/c4&gt; has an implicit raw value of &lt;c6&gt;&lt;s7&gt;2&lt;/s7&gt;&lt;/c6&gt;, and so on.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例において、&lt;c0&gt;&lt;s1&gt;Planet.mercury&lt;/s1&gt;&lt;/c0&gt;は明示的な生の値の&lt;c2&gt;&lt;s3&gt;1&lt;/s3&gt;&lt;/c2&gt;を持ちます、&lt;c4&gt;&lt;s5&gt;Planet.venus&lt;/s5&gt;&lt;/c4&gt;は暗黙的な生の値の&lt;c6&gt;&lt;s7&gt;2&lt;/s7&gt;&lt;/c6&gt;を持ちます、等々。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, &lt;c0&gt;&lt;s1&gt;SomeClassOnlyProtocol&lt;/s1&gt;&lt;/c0&gt; can only be adopted by class types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、&lt;c0&gt;&lt;s1&gt;SomeClassOnlyProtocol&lt;/s1&gt;&lt;/c0&gt;はクラス型によってのみ採用されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, &lt;c0&gt;&lt;s1&gt;greeting&lt;/s1&gt;&lt;/c0&gt; is a string, which means it has a region of memory where the characters that make up the string are stored.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例において、&lt;c0&gt;&lt;s1&gt;greeting&lt;/s1&gt;&lt;/c0&gt;は文字列です、それはその文字列を作り上げる文字が格納されるところのメモリ領域をそれが持つことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, &lt;c0&gt;&lt;s1&gt;incrementBySeven&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;incrementByTen&lt;/s3&gt;&lt;/c2&gt; are constants, but the closures these constants refer to are still able to increment the &lt;c4&gt;&lt;s5&gt;runningTotal&lt;/s5&gt;&lt;/c4&gt; variables that they have captured.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、&lt;c0&gt;&lt;s1&gt;incrementBySeven&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;incrementByTen&lt;/s3&gt;&lt;/c2&gt;は定数です、しかしこれらの定数が言及するクロージャはそれでもなお、それらが捕獲した&lt;c4&gt;&lt;s5&gt;runningTotal&lt;/s5&gt;&lt;/c4&gt;変数を増加させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, &lt;c0&gt;&lt;s1&gt;index&lt;/s1&gt;&lt;/c0&gt; is a constant whose value is automatically set at the start of each iteration of the loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、&lt;c0&gt;&lt;s1&gt;index&lt;/s1&gt;&lt;/c0&gt;は、ループの各繰り返しの開始時点でその値が自動的に設定される定数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, &lt;c0&gt;&lt;s1&gt;let&lt;/s1&gt;&lt;/c0&gt; distributes to each identifier pattern in the tuple pattern &lt;c2&gt;&lt;s3&gt;(x,&lt;/s3&gt; &lt;s4&gt;y)&lt;/s4&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、&lt;c0&gt;&lt;s1&gt;let&lt;/s1&gt;&lt;/c0&gt;は、タプルパターン&lt;c2&gt;&lt;s3&gt;(x,&lt;/s3&gt; &lt;s4&gt;y)&lt;/s4&gt;&lt;/c2&gt;における各識別子パターンに分配されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, &lt;c3&gt;&lt;s4&gt;possiblePlanet&lt;/s4&gt;&lt;/c3&gt; is of type &lt;c5&gt;&lt;s6&gt;Planet?&lt;/s6&gt;&lt;/c5&gt;, or “optional &lt;c7&gt;&lt;s8&gt;Planet&lt;/s8&gt;&lt;/c7&gt;.”</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、&lt;c3&gt;&lt;s4&gt;possiblePlanet&lt;/s4&gt;&lt;/c3&gt;は型&lt;c5&gt;&lt;s6&gt;Planet?&lt;/s6&gt;&lt;/c5&gt;、すなわち「オプショナルの&lt;c7&gt;&lt;s8&gt;Planet&lt;/s8&gt;&lt;/c7&gt;」です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, &lt;c6&gt;&lt;s7&gt;length&lt;/s7&gt;&lt;/c6&gt; is initialized when the new range is created and cannot be changed thereafter, because it is a constant property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、&lt;c6&gt;&lt;s7&gt;length&lt;/s7&gt;&lt;/c6&gt;は新しい範囲が作成される時に初期化されます、そしてその後は変更されることが出来ません、なぜならそれが変数プロパティだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, Oscar’s health and energy are passed as the two in-out parameters to &lt;c0&gt;&lt;s1&gt;balance(_:_:)&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例において、Oscarの体力とエネルギーは２つのin-outパラメータとして&lt;c0&gt;&lt;s1&gt;balance(_:_:)&lt;/s1&gt;&lt;/c0&gt;に渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, an empty string (&lt;c9&gt;&lt;s10&gt;""&lt;/s10&gt;&lt;/c9&gt;) is a valid, non-optional &lt;c11&gt;&lt;s12&gt;String&lt;/s12&gt;&lt;/c11&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例において、空の文字列（&lt;c9&gt;&lt;s10&gt;""&lt;/s10&gt;&lt;/c9&gt;）は有効な、オプショナルでない&lt;c11&gt;&lt;s12&gt;String&lt;/s12&gt;&lt;/c11&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, calling &lt;c0&gt;&lt;s1&gt;balance(_:_:)&lt;/s1&gt;&lt;/c0&gt; on the elements of a tuple produces a conflict because there are overlapping write accesses to &lt;c2&gt;&lt;s3&gt;playerInformation&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例において、&lt;c0&gt;&lt;s1&gt;balance(_:_:)&lt;/s1&gt;&lt;/c0&gt;をタプルの要素上で呼び出すことは衝突を生み出します、なぜなら&lt;c2&gt;&lt;s3&gt;playerInformation&lt;/s3&gt;&lt;/c2&gt;に対するオーパーラップ書き込みアクセスが存在するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, calling the &lt;c0&gt;&lt;s1&gt;shareHealth(with:)&lt;/s1&gt;&lt;/c0&gt; method for Oscar’s player to share health with Maria’s player doesn’t cause a conflict.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例において、&lt;c0&gt;&lt;s1&gt;shareHealth(with:)&lt;/s1&gt;&lt;/c0&gt;メソッドをOscarのプレイヤーに対して呼びだしてMariaのプレイヤーと体力を共有することは、衝突を引き起こしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, even though the entire multiline string literal is indented, the first and last lines in the string don’t begin with any whitespace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例において、たとえ複数行リテラル全体が字下げされるとしても、その文字列の最初と最後の行は全く空白で始まりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, it is guaranteed that &lt;c4&gt;&lt;s5&gt;number&lt;/s5&gt; &lt;s6&gt;%&lt;/s6&gt; &lt;s7&gt;10&lt;/s7&gt;&lt;/c4&gt; will always be a valid subscript key for the &lt;c8&gt;&lt;s9&gt;digitNames&lt;/s9&gt;&lt;/c8&gt; dictionary, and so an exclamation point is used to force-unwrap the &lt;c10&gt;&lt;s11&gt;String&lt;/s11&gt;&lt;/c10&gt; value stored in the subscript’s optional return value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で&lt;c4&gt;&lt;s5&gt;number&lt;/s5&gt; &lt;s6&gt;%&lt;/s6&gt; &lt;s7&gt;10&lt;/s7&gt;&lt;/c4&gt;は常に&lt;c8&gt;&lt;s9&gt;digitNames&lt;/s9&gt;&lt;/c8&gt;辞書のための有効な添え字キーであることを求められます、なのでその添え字のオプショナルの戻り値に保管した&lt;c10&gt;&lt;s11&gt;String&lt;/s11&gt;&lt;/c10&gt;値を強制アンラップするために感嘆符が使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, it is the choice of closure that &lt;c1&gt;&lt;s2&gt;incrementByTen&lt;/s2&gt;&lt;/c1&gt; &lt;e3&gt;refers to&lt;/e3&gt; that is constant, and not the contents of the closure itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例では、それは「クロージャの選択」です、それが&lt;c1&gt;&lt;s2&gt;incrementByTen&lt;/s2&gt;&lt;/c1&gt;が&lt;e3&gt;参照するもの&lt;/e3&gt;であり、それは定数であり、そしてクロージャ自身の内容ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, the &lt;c0&gt;&lt;s1&gt;Size&lt;/s1&gt;&lt;/c0&gt; structure has a default value for both its &lt;c2&gt;&lt;s3&gt;height&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;width&lt;/s5&gt;&lt;/c4&gt; properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例において、&lt;c0&gt;&lt;s1&gt;Size&lt;/s1&gt;&lt;/c0&gt;構造体は省略時の値をそれの&lt;c2&gt;&lt;s3&gt;height&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;width&lt;/s5&gt;&lt;/c4&gt;プロパティの両方に対して持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, the &lt;c0&gt;&lt;s1&gt;Suffix&lt;/s1&gt;&lt;/c0&gt; associated type for &lt;c2&gt;&lt;s3&gt;Stack&lt;/s3&gt;&lt;/c2&gt; is also &lt;c4&gt;&lt;s5&gt;Stack&lt;/s5&gt;&lt;/c4&gt;, so the suffix operation on &lt;c6&gt;&lt;s7&gt;Stack&lt;/s7&gt;&lt;/c6&gt; returns another &lt;c8&gt;&lt;s9&gt;Stack&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例において、&lt;c2&gt;&lt;s3&gt;Stack&lt;/s3&gt;&lt;/c2&gt;のための&lt;c0&gt;&lt;s1&gt;Suffix&lt;/s1&gt;&lt;/c0&gt;関連型もまた&lt;c4&gt;&lt;s5&gt;Stack&lt;/s5&gt;&lt;/c4&gt;です、それで&lt;c6&gt;&lt;s7&gt;Stack&lt;/s7&gt;&lt;/c6&gt;上のsuffix演算は別の&lt;c8&gt;&lt;s9&gt;Stack&lt;/s9&gt;&lt;/c8&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, the &lt;c10&gt;&lt;s11&gt;allItemsMatch(_:_:)&lt;/s11&gt;&lt;/c10&gt; function correctly reports that all of the items in the two containers match.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、&lt;c10&gt;&lt;s11&gt;allItemsMatch(_:_:)&lt;/s11&gt;&lt;/c10&gt;関数は、２つのコンテナの中の項目の全てが一致すると正しく報告します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, the &lt;c10&gt;&lt;s11&gt;description&lt;/s11&gt;&lt;/c10&gt; property correctly reports that the Ace of Spades has a value of &lt;c12&gt;&lt;s13&gt;1&lt;/s13&gt;&lt;/c12&gt; or &lt;c14&gt;&lt;s15&gt;11&lt;/s15&gt;&lt;/c14&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、&lt;c10&gt;&lt;s11&gt;description&lt;/s11&gt;&lt;/c10&gt;プロパティは、スペードのエースが&lt;c12&gt;&lt;s13&gt;1&lt;/s13&gt;&lt;/c12&gt;または&lt;c14&gt;&lt;s15&gt;11&lt;/s15&gt;&lt;/c14&gt;の値を持つことを正しく報告します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, the &lt;c16&gt;&lt;s17&gt;Key&lt;/s17&gt;&lt;/c16&gt; type parameter is constrained to conform to the &lt;c18&gt;&lt;s19&gt;Hashable&lt;/s19&gt;&lt;/c18&gt; protocol and therefore &lt;c20&gt;&lt;s21&gt;String&lt;/s21&gt;&lt;/c20&gt; must also conform to the &lt;c22&gt;&lt;s23&gt;Hashable&lt;/s23&gt;&lt;/c22&gt; protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、&lt;c16&gt;&lt;s17&gt;Key&lt;/s17&gt;&lt;/c16&gt;型パラメータは、&lt;c18&gt;&lt;s19&gt;Hashable&lt;/s19&gt;&lt;/c18&gt;プロトコルに準拠することを強制されます、したがって&lt;c20&gt;&lt;s21&gt;String&lt;/s21&gt;&lt;/c20&gt;もまた&lt;c22&gt;&lt;s23&gt;Hashable&lt;/s23&gt;&lt;/c22&gt;プロトコルに準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, the compiler infers that &lt;c0&gt;&lt;s1&gt;myVariable&lt;/s1&gt;&lt;/c0&gt; is an integer because its initial value is an integer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、コンパイラは&lt;c0&gt;&lt;s1&gt;myVariable&lt;/s1&gt;&lt;/c0&gt;が整数であると推測します、その最初の値が整数であるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, the first three decimal &lt;c0&gt;&lt;s1&gt;codeUnit&lt;/s1&gt;&lt;/c0&gt; values (&lt;c2&gt;&lt;s3&gt;68&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;111&lt;/s5&gt;&lt;/c4&gt;, &lt;c6&gt;&lt;s7&gt;103&lt;/s7&gt;&lt;/c6&gt;) represent the characters &lt;c8&gt;&lt;s9&gt;D&lt;/s9&gt;&lt;/c8&gt;, &lt;c10&gt;&lt;s11&gt;o&lt;/s11&gt;&lt;/c10&gt;, and &lt;c12&gt;&lt;s13&gt;g&lt;/s13&gt;&lt;/c12&gt;, whose UTF-8 representation is the same as their ASCII representation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例において、最初の３つの10進の&lt;c0&gt;&lt;s1&gt;codeUnit&lt;/s1&gt;&lt;/c0&gt;値（&lt;c2&gt;&lt;s3&gt;68&lt;/s3&gt;&lt;/c2&gt;、&lt;c4&gt;&lt;s5&gt;111&lt;/s5&gt;&lt;/c4&gt;、&lt;c6&gt;&lt;s7&gt;103&lt;/s7&gt;&lt;/c6&gt;）は、文字&lt;c8&gt;&lt;s9&gt;D&lt;/s9&gt;&lt;/c8&gt;、&lt;c10&gt;&lt;s11&gt;o&lt;/s11&gt;&lt;/c10&gt;、そして&lt;c12&gt;&lt;s13&gt;g&lt;/s13&gt;&lt;/c12&gt;を表わします、これらのUTF-８叙述はそれらのASCII叙述と同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, the operator is used to determine an initial value for a &lt;c8&gt;&lt;s9&gt;String&lt;/s9&gt;&lt;/c8&gt; variable called &lt;c10&gt;&lt;s11&gt;colorNameToUse&lt;/s11&gt;&lt;/c10&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、この演算子は&lt;c10&gt;&lt;s11&gt;colorNameToUse&lt;/s11&gt;&lt;/c10&gt;と呼ばれるある&lt;c8&gt;&lt;s9&gt;String&lt;/s9&gt;&lt;/c8&gt;変数の初期値を確定するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, the use of an implicitly unwrapped optional means that all of the two-phase class initializer requirements are satisfied.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、暗黙的にアンラップされるオプショナルの使用は、２段階のクラスイニシャライザの必要とする条件の全てが満たされることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, the value of &lt;c0&gt;&lt;s1&gt;multiplier&lt;/s1&gt;&lt;/c0&gt; is inserted into a string literal as &lt;c2&gt;&lt;s3&gt;\(multiplier)&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、&lt;c0&gt;&lt;s1&gt;multiplier&lt;/s1&gt;&lt;/c0&gt;の値は、文字列リテラルに&lt;c2&gt;&lt;s3&gt;\(multiplier)&lt;/s3&gt;&lt;/c2&gt;として差し込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, you can see the left-to-right comparison behavior on the first line.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例において、あなたは左から右への比較挙動を最初の行において見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, you place the optional chaining question mark &lt;e0&gt;after&lt;/e0&gt; the parentheses, because the optional value you are chaining on is the &lt;c1&gt;&lt;s2&gt;buildingIdentifier()&lt;/s2&gt;&lt;/c1&gt; method’s return value, and not the &lt;c3&gt;&lt;s4&gt;buildingIdentifier()&lt;/s4&gt;&lt;/c3&gt; method itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、あなたは丸括弧の&lt;e0&gt;後に&lt;/e0&gt;オプショナル連鎖の疑問符を置きます、なぜなら、あなたがその上に連鎖しているオプショナルの値は&lt;c1&gt;&lt;s2&gt;buildingIdentifier()&lt;/s2&gt;&lt;/c1&gt;メソッドの戻り値であって、&lt;c3&gt;&lt;s4&gt;buildingIdentifier()&lt;/s4&gt;&lt;/c3&gt;メソッドそれ自体ではないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example above, you write &lt;c0&gt;&lt;s1&gt;Beverage.allCases&lt;/s1&gt;&lt;/c0&gt; to access a collection that contains all of the cases of the &lt;c2&gt;&lt;s3&gt;Beverage&lt;/s3&gt;&lt;/c2&gt; enumeration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例において、あなたは&lt;c0&gt;&lt;s1&gt;Beverage.allCases&lt;/s1&gt;&lt;/c0&gt;を書いて、&lt;c2&gt;&lt;s3&gt;Beverage&lt;/s3&gt;&lt;/c2&gt;列挙のケース節の全てを含むコレクションにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, &lt;c10&gt;&lt;s11&gt;oneAndTwo&lt;/s11&gt;&lt;/c10&gt; is an instance of &lt;c12&gt;&lt;s13&gt;Pair&lt;String&gt;&lt;/s13&gt;&lt;/c12&gt;, which conforms to &lt;c14&gt;&lt;s15&gt;TitledLoggable&lt;/s15&gt;&lt;/c14&gt; because &lt;c16&gt;&lt;s17&gt;String&lt;/s17&gt;&lt;/c16&gt; conforms to &lt;c18&gt;&lt;s19&gt;TitledLoggable&lt;/s19&gt;&lt;/c18&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例において、&lt;c10&gt;&lt;s11&gt;oneAndTwo&lt;/s11&gt;&lt;/c10&gt;は&lt;c12&gt;&lt;s13&gt;Pair&lt;String&gt;&lt;/s13&gt;&lt;/c12&gt;のインスタンスです、それは&lt;c14&gt;&lt;s15&gt;TitledLoggable&lt;/s15&gt;&lt;/c14&gt;に準拠します、なぜなら&lt;c16&gt;&lt;s17&gt;String&lt;/s17&gt;&lt;/c16&gt;は&lt;c18&gt;&lt;s19&gt;TitledLoggable&lt;/s19&gt;&lt;/c18&gt;に準拠するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, class &lt;c0&gt;&lt;s1&gt;A&lt;/s1&gt;&lt;/c0&gt; is a public class with a file-private method called &lt;c2&gt;&lt;s3&gt;someMethod()&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下記の例で、クラス&lt;c0&gt;&lt;s1&gt;A&lt;/s1&gt;&lt;/c0&gt;は公開のクラスです、それは&lt;c2&gt;&lt;s3&gt;someMethod()&lt;/s3&gt;&lt;/c2&gt;と呼ばれるあるファイル外非公開のメソッドを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, the &lt;c0&gt;&lt;s1&gt;CompassPoint&lt;/s1&gt;&lt;/c0&gt; enumeration has an explicit access level of public.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例において、&lt;c0&gt;&lt;s1&gt;CompassPoint&lt;/s1&gt;&lt;/c0&gt;列挙は明示的な公開のアクセス水準を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, the &lt;c0&gt;&lt;s1&gt;VendingMachine&lt;/s1&gt;&lt;/c0&gt; class has a &lt;c2&gt;&lt;s3&gt;vend(itemNamed:)&lt;/s3&gt;&lt;/c2&gt; method that throws an appropriate &lt;c4&gt;&lt;s5&gt;VendingMachineError&lt;/s5&gt;&lt;/c4&gt; if the requested item is not available, is out of stock, or has a cost that exceeds the current deposited amount:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例において、&lt;c0&gt;&lt;s1&gt;VendingMachine&lt;/s1&gt;&lt;/c0&gt;クラスは&lt;c2&gt;&lt;s3&gt;vend(itemNamed:)&lt;/s3&gt;&lt;/c2&gt;メソッドを持ちます、それは、要求された項目が利用可能でない、在庫切れ、または現在預け入れされた総額を超える価格を持つならば対応する&lt;c4&gt;&lt;s5&gt;VendingMachineError&lt;/s5&gt;&lt;/c4&gt;をスローします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, the constant &lt;c0&gt;&lt;s1&gt;twoThousand&lt;/s1&gt;&lt;/c0&gt; is of type &lt;c2&gt;&lt;s3&gt;UInt16&lt;/s3&gt;&lt;/c2&gt;, whereas the constant &lt;c4&gt;&lt;s5&gt;one&lt;/s5&gt;&lt;/c4&gt; is of type &lt;c6&gt;&lt;s7&gt;UInt8&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下記の例で、定数&lt;c0&gt;&lt;s1&gt;twoThousand&lt;/s1&gt;&lt;/c0&gt;は&lt;c2&gt;&lt;s3&gt;型UInt16&lt;/s3&gt;&lt;/c2&gt;ですが、定数&lt;c4&gt;&lt;s5&gt;one&lt;/s5&gt;&lt;/c4&gt;は型&lt;c6&gt;&lt;s7&gt;UInt8&lt;/s7&gt;&lt;/c6&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, the first &lt;c0&gt;&lt;s1&gt;Bool&lt;/s1&gt;&lt;/c0&gt; value (&lt;c2&gt;&lt;s3&gt;hasDoorKey&lt;/s3&gt;&lt;/c2&gt;) is &lt;c4&gt;&lt;s5&gt;false&lt;/s5&gt;&lt;/c4&gt;, but the second value (&lt;c6&gt;&lt;s7&gt;knowsOverridePassword&lt;/s7&gt;&lt;/c6&gt;) is &lt;c8&gt;&lt;s9&gt;true&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下記の例で、最初の&lt;c0&gt;&lt;s1&gt;Bool&lt;/s1&gt;&lt;/c0&gt;値（&lt;c2&gt;&lt;s3&gt;hasDoorKey&lt;/s3&gt;&lt;/c2&gt;）は&lt;c4&gt;&lt;s5&gt;false&lt;/s5&gt;&lt;/c4&gt;です、しかし、第二の値（&lt;c6&gt;&lt;s7&gt;knowsOverridePassword&lt;/s7&gt;&lt;/c6&gt;）は&lt;c8&gt;&lt;s9&gt;true&lt;/s9&gt;&lt;/c8&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, the values of &lt;c0&gt;&lt;s1&gt;firstBits&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;otherBits&lt;/s3&gt;&lt;/c2&gt; each have a bit set to &lt;c4&gt;&lt;s5&gt;1&lt;/s5&gt;&lt;/c4&gt; in a location that the other does not.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下記の例で、&lt;c0&gt;&lt;s1&gt;firstBits&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;otherBits&lt;/s3&gt;&lt;/c2&gt;それぞれの値は、他のものがそうでない場所で、ビットを&lt;c4&gt;&lt;s5&gt;1&lt;/s5&gt;&lt;/c4&gt;に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, the values of &lt;c0&gt;&lt;s1&gt;firstSixBits&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;lastSixBits&lt;/s3&gt;&lt;/c2&gt; both have four middle bits equal to &lt;c4&gt;&lt;s5&gt;1&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下記の例で、&lt;c0&gt;&lt;s1&gt;firstSixBits&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;lastSixBits&lt;/s3&gt;&lt;/c2&gt;の値は、&lt;c4&gt;&lt;s5&gt;1&lt;/s5&gt;&lt;/c4&gt;と等しい４つの中間のビットを両方とも持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, the values of &lt;c0&gt;&lt;s1&gt;someBits&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;moreBits&lt;/s3&gt;&lt;/c2&gt; have different bits set to &lt;c4&gt;&lt;s5&gt;1&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下記の例で、&lt;c0&gt;&lt;s1&gt;someBits&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;moreBits&lt;/s3&gt;&lt;/c2&gt;の値は、&lt;c4&gt;&lt;s5&gt;1&lt;/s5&gt;&lt;/c4&gt;に設定される異なるビットを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the example below, when &lt;c0&gt;&lt;s1&gt;c&lt;/s1&gt;&lt;/c0&gt; is not &lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;, its value is unwrapped and used to evaluate &lt;c4&gt;&lt;s5&gt;.property&lt;/s5&gt;&lt;/c4&gt;, the value of which is used to evaluate &lt;c6&gt;&lt;s7&gt;.performAction()&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下記の例で、&lt;c0&gt;&lt;s1&gt;c&lt;/s1&gt;&lt;/c0&gt;が&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;でないとき、その値はアンラップされて&lt;c4&gt;&lt;s5&gt;.property&lt;/s5&gt;&lt;/c4&gt;を評価するために使われ、その値が&lt;c6&gt;&lt;s7&gt;.performAction()&lt;/s7&gt;&lt;/c6&gt;を評価するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the examples above, ARC is able to track the number of references to the new &lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt; instance you create and to deallocate that &lt;c2&gt;&lt;s3&gt;Person&lt;/s3&gt;&lt;/c2&gt; instance when it’s no longer needed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、ARCはあなたがつくる新しい&lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt;インスタンスへの参照の数を追跡して、その&lt;c2&gt;&lt;s3&gt;Person&lt;/s3&gt;&lt;/c2&gt;インスタンスをそれがもはや必要でないとき割り当て解除することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the expression &lt;c1&gt;&lt;s2&gt;1&lt;/s2&gt; &lt;s3&gt;+&lt;/s3&gt; &lt;s4&gt;2&lt;/s4&gt;&lt;/c1&gt;, the &lt;c5&gt;&lt;s6&gt;+&lt;/s6&gt;&lt;/c5&gt; symbol is a binary operator and its two operands are the values &lt;c7&gt;&lt;s8&gt;1&lt;/s8&gt;&lt;/c7&gt; and &lt;c9&gt;&lt;s10&gt;2&lt;/s10&gt;&lt;/c9&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>式&lt;c1&gt;&lt;s2&gt;1&lt;/s2&gt; &lt;s3&gt;+&lt;/s3&gt; &lt;s4&gt;2&lt;/s4&gt;&lt;/c1&gt;において、記号&lt;c5&gt;&lt;s6&gt;+&lt;/s6&gt;&lt;/c5&gt;は二項演算子です、そしてその２つの演算数は値&lt;c7&gt;&lt;s8&gt;1&lt;/s8&gt;&lt;/c7&gt;と&lt;c9&gt;&lt;s10&gt;2&lt;/s10&gt;&lt;/c9&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the extension, you must implement all of the adopted protocol’s requirements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張において、あなたは採用されたプロトコルの要件の全てを実装しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the first case, a type identifier refers to a type alias of a named or compound type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第一の場合には、型識別子は、名前付きまたは複合の型の型エイリアスに言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the first case, the cluster contains a single scalar; in the second case, it’s a cluster of two scalars:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の場合では、クラスタは、ただ１つだけのスカラーを含みます；２番目の場合には、それは、２つのスカラーのクラスタ（１つの房、群れ）です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the first example, the expression &lt;c0&gt;&lt;s1&gt;someTuple&lt;/s1&gt;&lt;/c0&gt; is specified to have the tuple type &lt;c2&gt;&lt;s3&gt;(Double,&lt;/s3&gt; &lt;s4&gt;Double)&lt;/s4&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の例で、式&lt;c0&gt;&lt;s1&gt;someTuple&lt;/s1&gt;&lt;/c0&gt;は、タプル型&lt;c2&gt;&lt;s3&gt;(Double,&lt;/s3&gt; &lt;s4&gt;Double)&lt;/s4&gt;&lt;/c2&gt;を持つと指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the first of these two checks, the &lt;c0&gt;&lt;s1&gt;didSet&lt;/s1&gt;&lt;/c0&gt; observer sets &lt;c2&gt;&lt;s3&gt;currentLevel&lt;/s3&gt;&lt;/c2&gt; to a different value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの２つのチェックで最初のものにおいて、&lt;c0&gt;&lt;s1&gt;didSet&lt;/s1&gt;&lt;/c0&gt;オブザーバーは、&lt;c2&gt;&lt;s3&gt;currentLevel&lt;/s3&gt;&lt;/c2&gt;を異なる値に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the first phase, each stored property is assigned an initial value by the class that introduced it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の段階では、各格納プロパティは、それを導入したクラスによって、初期値を代入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following example, for instance, the explicit type annotation (&lt;c0&gt;&lt;s1&gt;:&lt;/s1&gt; &lt;s2&gt;Float&lt;/s2&gt;&lt;/c0&gt;) on the constant &lt;c3&gt;&lt;s4&gt;eFloat&lt;/s4&gt;&lt;/c3&gt; causes the numeric literal &lt;c5&gt;&lt;s6&gt;2.71828&lt;/s6&gt;&lt;/c5&gt; to have an inferred type of &lt;c7&gt;&lt;s8&gt;Float&lt;/s8&gt;&lt;/c7&gt; instead of &lt;c9&gt;&lt;s10&gt;Double&lt;/s10&gt;&lt;/c9&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、以下の例において、定数&lt;c3&gt;&lt;s4&gt;eFloat&lt;/s4&gt;&lt;/c3&gt;での明示的な型注釈（&lt;c0&gt;&lt;s1&gt;:&lt;/s1&gt; &lt;s2&gt;Float&lt;/s2&gt;&lt;/c0&gt;）は、数値リテラル&lt;c5&gt;&lt;s6&gt;2.71828&lt;/s6&gt;&lt;/c5&gt;を&lt;c7&gt;&lt;s8&gt;Float&lt;/s8&gt;&lt;/c7&gt;の推論される型を持つようにします、&lt;c9&gt;&lt;s10&gt;Double&lt;/s10&gt;&lt;/c9&gt;ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the implementation of &lt;c4&gt;&lt;s5&gt;makeOpaqueContainer(item:)&lt;/s5&gt;&lt;/c4&gt;, the underlying type of the opaque container is &lt;c6&gt;&lt;s7&gt;[T]&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;makeOpaqueContainer(item:)&lt;/s5&gt;&lt;/c4&gt;の実装において、不透明コンテナの基礎をなす型は、&lt;c6&gt;&lt;s7&gt;[T]&lt;/s7&gt;&lt;/c6&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the line of code that says &lt;c8&gt;&lt;s9&gt;return&lt;/s9&gt; &lt;s10&gt;greeting&lt;/s10&gt;&lt;/c8&gt;, the function finishes its execution and returns the current value of &lt;c11&gt;&lt;s12&gt;greeting&lt;/s12&gt;&lt;/c11&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c8&gt;&lt;s9&gt;return&lt;/s9&gt; &lt;s10&gt;greeting&lt;/s10&gt;&lt;/c8&gt;を告げるコード行において、関数はその実行を終えて&lt;c11&gt;&lt;s12&gt;greeting&lt;/s12&gt;&lt;/c11&gt;の現在の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the members of a class declaration, &lt;c4&gt;&lt;s5&gt;Self&lt;/s5&gt;&lt;/c4&gt; can appear only as follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス宣言のメンバーにおいて、&lt;c4&gt;&lt;s5&gt;Self&lt;/s5&gt;&lt;/c4&gt;は以下のようにのみ現れることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the previous example, it’s not easy to see that &lt;c2&gt;&lt;s3&gt;someAddress&lt;/s3&gt;&lt;/c2&gt; is never evaluated, because accessing a constant doesn’t have any side effects.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>前の例において、&lt;c2&gt;&lt;s3&gt;someAddress&lt;/s3&gt;&lt;/c2&gt;が決して評価されないというのはわかりやすいとはいえません、なぜならある定数を代入することは、何ら副作用を持たないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the scope of a class declaration, writing the &lt;c0&gt;&lt;s1&gt;static&lt;/s1&gt;&lt;/c0&gt; modifier on a member declaration has the same effect as writing the &lt;c2&gt;&lt;s3&gt;class&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;final&lt;/s5&gt;&lt;/c4&gt; modifiers on that member declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス宣言のスコープにおいて、&lt;c0&gt;&lt;s1&gt;static&lt;/s1&gt;&lt;/c0&gt;修飾子をメンバー宣言上で書くことは、&lt;c2&gt;&lt;s3&gt;class&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;final&lt;/s5&gt;&lt;/c4&gt;修飾子をそのメンバー宣言上で書くことと同じ効果を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the second case, a type identifier uses dot (&lt;c0&gt;&lt;s1&gt;.&lt;/s1&gt;&lt;/c0&gt;) syntax to refer to named types declared in other modules or nested within other types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第二の場合には、型識別子は、他のモジュールで宣言される、または他の型の内部で入れ子にされる名前付きの型を参照するためにドット（&lt;c0&gt;&lt;s1&gt;.&lt;/s1&gt;&lt;/c0&gt;）構文を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the second example, the parameter &lt;c5&gt;&lt;s6&gt;a&lt;/s6&gt;&lt;/c5&gt; to the function &lt;c7&gt;&lt;s8&gt;someFunction&lt;/s8&gt;&lt;/c7&gt; is specified to have the type &lt;c9&gt;&lt;s10&gt;Int&lt;/s10&gt;&lt;/c9&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第二の例で関数&lt;c7&gt;&lt;s8&gt;someFunction&lt;/s8&gt;&lt;/c7&gt;のためのパラメータ&lt;c5&gt;&lt;s6&gt;a&lt;/s6&gt;&lt;/c5&gt;は、型&lt;c9&gt;&lt;s10&gt;Int&lt;/s10&gt;&lt;/c9&gt;を持つ指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the setter for &lt;c0&gt;&lt;s1&gt;perimeter&lt;/s1&gt;&lt;/c0&gt;, the new value has the implicit name &lt;c2&gt;&lt;s3&gt;newValue&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;perimeter&lt;/s1&gt;&lt;/c0&gt;のためのセッターにおいて、新しい値は、隠された名前&lt;c2&gt;&lt;s3&gt;newValue&lt;/s3&gt;&lt;/c2&gt;を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the two examples below, &lt;c0&gt;&lt;s1&gt;T&lt;/s1&gt;&lt;/c0&gt; is inferred to be &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt; respectively:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の２つの例で、&lt;c0&gt;&lt;s1&gt;T&lt;/s1&gt;&lt;/c0&gt;はそれぞれ&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;Stringで&lt;/s5&gt;&lt;/c4&gt;あると推測されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In these cases, it’s useful to remove the need to check and unwrap the optional’s value every time it’s accessed, because it can be safely assumed to have a value all of the time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの場合には、オプショナルの値をそれがアクセスされるたびに確認してアンラップする必要を無くすことは役に立ちます、なぜならそれがいつでも値を持つと安全に仮定されることが出来るためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In these cases, you can omit the value from one side of the range operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの場合、あなたは範囲演算子の１つの側から値を省くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, &lt;c4&gt;&lt;s5&gt;Element&lt;/s5&gt;&lt;/c4&gt; is used as a placeholder in three places:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この場合、&lt;c4&gt;&lt;s5&gt;Element&lt;/s5&gt;&lt;/c4&gt;はプレースホルダとして３つの場所で使われます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, &lt;c8&gt;&lt;s9&gt;T&lt;/s9&gt;&lt;/c8&gt; is &lt;c10&gt;&lt;s11&gt;Int&lt;/s11&gt;&lt;/c10&gt;, so the return value is an array of integers and the &lt;c12&gt;&lt;s13&gt;Item&lt;/s13&gt;&lt;/c12&gt; associated type is inferred to be &lt;c14&gt;&lt;s15&gt;Int&lt;/s15&gt;&lt;/c14&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この場合に、&lt;c8&gt;&lt;s9&gt;T&lt;/s9&gt;&lt;/c8&gt;は&lt;c10&gt;&lt;s11&gt;Int&lt;/s11&gt;&lt;/c10&gt;です、それで戻り値は整数からなるある配列です、そして&lt;c12&gt;&lt;s13&gt;Item&lt;/s13&gt;&lt;/c12&gt;関連型は&lt;c14&gt;&lt;s15&gt;Int&lt;/s15&gt;&lt;/c14&gt;と推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, because the image is shipped with the application, no error will be thrown at runtime, so it is appropriate to disable error propagation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この場合、画像はアプリケーションとともに出荷されるので、エラーが実行時にスローされることはありません、それでふさわしいのはエラー伝達を抑制することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, if the &lt;c0&gt;&lt;s1&gt;init(name:)&lt;/s1&gt;&lt;/c0&gt; initializer of the superclass were ever called with an empty string as the name, the forced unwrapping operation would result in a runtime error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この場合、スーパークラスの&lt;c0&gt;&lt;s1&gt;init(name:)&lt;/s1&gt;&lt;/c0&gt;イニシャライザがもしかその名前として空の文字列で呼び出されたならば、強制アンラップ操作は実行時エラーという結果になるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, it isn’t possible to retrieve a planet with a position of &lt;c15&gt;&lt;s16&gt;11&lt;/s16&gt;&lt;/c15&gt;, and so the &lt;c17&gt;&lt;s18&gt;else&lt;/s18&gt;&lt;/c17&gt; branch is executed instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この場合、&lt;c15&gt;&lt;s16&gt;11&lt;/s16&gt;&lt;/c15&gt;の位置で惑星を取り出すことは可能ではありません、それで&lt;c17&gt;&lt;s18&gt;else&lt;/s18&gt;&lt;/c17&gt;分岐が代わりに実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the array literal contains two &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; values and nothing else.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この場合、配列リテラルは、２つの&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;値を含んでいて他には何も含みません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the capture list is &lt;c4&gt;&lt;s5&gt;[unowned&lt;/s5&gt; &lt;s6&gt;self]&lt;/s6&gt;&lt;/c4&gt;, which means “capture self as an unowned reference rather than a strong reference”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この場合、捕獲リストは&lt;c4&gt;&lt;s5&gt;[unowned&lt;/s5&gt; &lt;s6&gt;self]&lt;/s6&gt;&lt;/c4&gt;です、それは、「selfを強い参照ではなく非所有参照として捕獲する」ことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the expression is written as &lt;c8&gt;&lt;s9&gt;\(Double(multiplier)&lt;/s9&gt; &lt;s10&gt;*&lt;/s10&gt; &lt;s11&gt;2.5)&lt;/s11&gt;&lt;/c8&gt; when it’s included inside the string literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この場合、式は、それが文字列リテラルに含められる時、&lt;c8&gt;&lt;s9&gt;\(Double(multiplier)&lt;/s9&gt; &lt;s10&gt;*&lt;/s10&gt; &lt;s11&gt;2.5)&lt;/s11&gt;&lt;/c8&gt;と書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the loop contains only one statement, which prints an entry from the five-times table for the current value of &lt;c10&gt;&lt;s11&gt;index&lt;/s11&gt;&lt;/c10&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この場合では、ループは１つの文だけを含みます、それは、&lt;c10&gt;&lt;s11&gt;index&lt;/s11&gt;&lt;/c10&gt;の現在の値に対する九九の５の段の項を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the underlying type of the return value varies depending on &lt;c0&gt;&lt;s1&gt;T&lt;/s1&gt;&lt;/c0&gt;: Whatever shape is passed it, &lt;c2&gt;&lt;s3&gt;repeat(shape:count:)&lt;/s3&gt;&lt;/c2&gt; creates and returns an array of that shape.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この場合には、戻り値のその基礎をなす型は&lt;c0&gt;&lt;s1&gt;T&lt;/s1&gt;&lt;/c0&gt;に依存して変動します：どんな形状がそれに渡されても、&lt;c2&gt;&lt;s3&gt;repeat(shape:count:)&lt;/s3&gt;&lt;/c2&gt;はその形状からなるある配列を作成して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, there’s no other code inside &lt;c4&gt;&lt;s5&gt;restoreHealth()&lt;/s5&gt;&lt;/c4&gt; that could have an overlapping access to the properties of a &lt;c6&gt;&lt;s7&gt;Player&lt;/s7&gt;&lt;/c6&gt; instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この場合には、&lt;c4&gt;&lt;s5&gt;restoreHealth()&lt;/s5&gt;&lt;/c4&gt;内部の他のコードで、&lt;c6&gt;&lt;s7&gt;Player&lt;/s7&gt;&lt;/c6&gt;インスタンスのプロパティに対するオーバーラップするアクセスを持つことができるものはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this data model, a customer may or may not have a credit card, but a credit card will &lt;e8&gt;always&lt;/e8&gt; be associated with a customer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このデータ・モデルにおいて、顧客はクレジットカードを持っているかもしれないし、持っていないかもしれません、しかし、クレジットカードは&lt;e8&gt;常に&lt;/e8&gt;ひとりの顧客と結び付けられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this data model, every country must always have a capital city, and every city must always belong to a country.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このデータ・モデルにおいて、あらゆる国に常に主都がなければなりません、そして、あらゆる都市は常に国に属していなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this dictionary, the keys are three-letter International Air Transport Association codes, and the values are airport names:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この辞書では、キーは３文字の国際航空運送協会コードです、そして値は空港名です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, &lt;c0&gt;&lt;s1&gt;(404,&lt;/s1&gt; &lt;s2&gt;"Not&lt;/s2&gt; &lt;s3&gt;Found")&lt;/s3&gt;&lt;/c0&gt; is a tuple that describes an &lt;e4&gt;HTTP status code&lt;/e4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、&lt;c0&gt;&lt;s1&gt;(404,&lt;/s1&gt; &lt;s2&gt;"Not&lt;/s2&gt; &lt;s3&gt;Found")&lt;/s3&gt;&lt;/c0&gt;がひとつのタプルです、それは&lt;e4&gt;HTTP状態コード&lt;/e4&gt;を記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, &lt;c0&gt;&lt;s1&gt;firstNumber&lt;/s1&gt;&lt;/c0&gt; is a named constant for the value &lt;c2&gt;&lt;s3&gt;10&lt;/s3&gt;&lt;/c2&gt;, and &lt;c4&gt;&lt;s5&gt;secondNumber&lt;/s5&gt;&lt;/c4&gt; is a named constant for the value &lt;c6&gt;&lt;s7&gt;42&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、&lt;c0&gt;&lt;s1&gt;firstNumber&lt;/s1&gt;&lt;/c0&gt;は、値&lt;c2&gt;&lt;s3&gt;10&lt;/s3&gt;&lt;/c2&gt;のための名前をつけられた定数です、そして、&lt;c4&gt;&lt;s5&gt;secondNumber&lt;/s5&gt;&lt;/c4&gt;は値&lt;c6&gt;&lt;s7&gt;42&lt;/s7&gt;&lt;/c6&gt;のための名前をつけられた定数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, &lt;c0&gt;&lt;s1&gt;someResolution.width&lt;/s1&gt;&lt;/c0&gt; refers to the &lt;c2&gt;&lt;s3&gt;width&lt;/s3&gt;&lt;/c2&gt; property of &lt;c4&gt;&lt;s5&gt;someResolution&lt;/s5&gt;&lt;/c4&gt;, and returns its default initial value of &lt;c6&gt;&lt;s7&gt;0&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、&lt;c0&gt;&lt;s1&gt;someResolution.width&lt;/s1&gt;&lt;/c0&gt;は&lt;c4&gt;&lt;s5&gt;someResolution&lt;/s5&gt;&lt;/c4&gt;の&lt;c2&gt;&lt;s3&gt;width&lt;/s3&gt;&lt;/c2&gt;プロパティに言及して、その省略時の初期値の&lt;c6&gt;&lt;s7&gt;0&lt;/s7&gt;&lt;/c6&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, &lt;c11&gt;&lt;s12&gt;PrettyTextRepresentable&lt;/s12&gt;&lt;/c11&gt; adds a single requirement to provide a gettable property called &lt;c13&gt;&lt;s14&gt;prettyTextualDescription&lt;/s14&gt;&lt;/c13&gt; that returns a &lt;c15&gt;&lt;s16&gt;String&lt;/s16&gt;&lt;/c15&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、&lt;c11&gt;&lt;s12&gt;PrettyTextRepresentable&lt;/s12&gt;&lt;/c11&gt;は１つの要件を加えて、&lt;c15&gt;&lt;s16&gt;String&lt;/s16&gt;&lt;/c15&gt;を返す&lt;c13&gt;&lt;s14&gt;prettyTextualDescription&lt;/s14&gt;&lt;/c13&gt;と呼ばれる取得可能なプロパティを提供するようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, &lt;c7&gt;&lt;s8&gt;actualNumber&lt;/s8&gt;&lt;/c7&gt; is simply used to print the result of the conversion.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、&lt;c7&gt;&lt;s8&gt;actualNumber&lt;/s8&gt;&lt;/c7&gt;は単にその変換の結果を出力するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, a &lt;c0&gt;&lt;s1&gt;Double&lt;/s1&gt;&lt;/c0&gt; value of &lt;c2&gt;&lt;s3&gt;1.0&lt;/s3&gt;&lt;/c2&gt; is considered to represent “one meter”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、&lt;c2&gt;&lt;s3&gt;1.0&lt;/s3&gt;&lt;/c2&gt;の&lt;c0&gt;&lt;s1&gt;Double&lt;/s1&gt;&lt;/c0&gt;値は「１メートル」を表すと考慮されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, a new instance of &lt;c0&gt;&lt;s1&gt;TimesTable&lt;/s1&gt;&lt;/c0&gt; is created to represent the three-times-table.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、&lt;c0&gt;&lt;s1&gt;TimesTable&lt;/s1&gt;&lt;/c0&gt;の新しいインスタンスは、九九の３の段を表すためにつくられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, code execution continues if &lt;c0&gt;&lt;s1&gt;age&lt;/s1&gt; &lt;s2&gt;&gt;=&lt;/s2&gt; &lt;s3&gt;0&lt;/s3&gt;&lt;/c0&gt; evaluates to &lt;c4&gt;&lt;s5&gt;true&lt;/s5&gt;&lt;/c4&gt;, that is, if the value of &lt;c6&gt;&lt;s7&gt;age&lt;/s7&gt;&lt;/c6&gt; is nonnegative.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例において、コード実行は&lt;c0&gt;&lt;s1&gt;age&lt;/s1&gt; &lt;s2&gt;&gt;=&lt;/s2&gt; &lt;s3&gt;0&lt;/s3&gt;&lt;/c0&gt;が&lt;c4&gt;&lt;s5&gt;true&lt;/s5&gt;&lt;/c4&gt;に評価されるならば、すなわち&lt;c6&gt;&lt;s7&gt;age&lt;/s7&gt;&lt;/c6&gt;の値が負でないならば継続します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, depending on whether you wanted the original total amount or the updated total amount, either $5 or $320 could be the correct answer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、あなたが望んだのが元の総支出額か更新後の総支出額かにより、5ドルか320ドルのどちらかが正しい答えとなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, each item in the array might be a &lt;c0&gt;&lt;s1&gt;Movie&lt;/s1&gt;&lt;/c0&gt;, or it might be a &lt;c2&gt;&lt;s3&gt;Song&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、配列の各項目は&lt;c0&gt;&lt;s1&gt;Movie&lt;/s1&gt;&lt;/c0&gt;であるかもしれませんし、それは&lt;c2&gt;&lt;s3&gt;Song&lt;/s3&gt;&lt;/c2&gt;であるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, initialization begins with a call to a convenience initializer on the subclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、初期化はサブクラス上での便宜イニシャライザへの呼び出しから始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, it checks whether &lt;c14&gt;&lt;s15&gt;game&lt;/s15&gt;&lt;/c14&gt; is actually an instance of &lt;c16&gt;&lt;s17&gt;SnakesAndLadders&lt;/s17&gt;&lt;/c16&gt; behind the scenes, and prints an appropriate message if so.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、&lt;c14&gt;&lt;s15&gt;game&lt;/s15&gt;&lt;/c14&gt;が実際に舞台裏で&lt;c16&gt;&lt;s17&gt;SnakesAndLadders&lt;/s17&gt;&lt;/c16&gt;のインスタンスであるかどうか調べて、もしそうならば適切なメッセージを出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, it simply prints out the value that is about to be set.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、それは単に設定されようとしている値を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, it would be preferable to write the sorting closure inline, using closure expression syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、クロージャ式構文を使って、ソート・クロージャを行内に書くことがずっと好ましいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, the &lt;c0&gt;&lt;s1&gt;Named&lt;/s1&gt;&lt;/c0&gt; protocol has a single requirement for a gettable &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt; property called &lt;c4&gt;&lt;s5&gt;name&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例において、&lt;c0&gt;&lt;s1&gt;Named&lt;/s1&gt;&lt;/c0&gt;プロトコルは、取得可能な&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;プロパティで&lt;c4&gt;&lt;s5&gt;name&lt;/s5&gt;&lt;/c4&gt;と呼ばれるものに対するただ１つの要件を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, the &lt;c0&gt;&lt;s1&gt;buyFavoriteSnack(person:&lt;/s1&gt; &lt;s2&gt;vendingMachine:)&lt;/s2&gt;&lt;/c0&gt; function looks up a given person’s favorite snack and tries to buy it for them by calling the &lt;c3&gt;&lt;s4&gt;vend(itemNamed:)&lt;/s4&gt;&lt;/c3&gt; method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例において、&lt;c0&gt;&lt;s1&gt;buyFavoriteSnack(person:&lt;/s1&gt; &lt;s2&gt;vendingMachine:)&lt;/s2&gt;&lt;/c0&gt;関数は指定された個人のお気に入りのスナックを探してそれを彼らのために仕入れることを&lt;c3&gt;&lt;s4&gt;vend(itemNamed:)&lt;/s4&gt;&lt;/c3&gt;メソッドを呼ぶことによって試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, the &lt;c0&gt;&lt;s1&gt;makeASandwich()&lt;/s1&gt;&lt;/c0&gt; function will throw an error if no clean dishes are available or if any ingredients are missing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例において、&lt;c0&gt;&lt;s1&gt;makeASandwich()&lt;/s1&gt;&lt;/c0&gt;関数は、綺麗な皿が利用可能でないならばまたは何の食材も見つからないならばエラーをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, the attempt to set the &lt;c0&gt;&lt;s1&gt;address&lt;/s1&gt;&lt;/c0&gt; property of &lt;c2&gt;&lt;s3&gt;john.residence&lt;/s3&gt;&lt;/c2&gt; will fail, because &lt;c4&gt;&lt;s5&gt;john.residence&lt;/s5&gt;&lt;/c4&gt; is currently &lt;c6&gt;&lt;s7&gt;nil&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例において、&lt;c2&gt;&lt;s3&gt;john.residence&lt;/s3&gt;&lt;/c2&gt;の&lt;c0&gt;&lt;s1&gt;address&lt;/s1&gt;&lt;/c0&gt;プロパティを設定する試みは失敗します、なぜなら&lt;c4&gt;&lt;s5&gt;john.residence&lt;/s5&gt;&lt;/c4&gt;が現在&lt;c6&gt;&lt;s7&gt;nil&lt;/s7&gt;&lt;/c6&gt;だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, the attempt to set the &lt;c0&gt;&lt;s1&gt;address&lt;/s1&gt;&lt;/c0&gt; property of &lt;c2&gt;&lt;s3&gt;john.residence&lt;/s3&gt;&lt;/c2&gt; will succeed, because the value of &lt;c4&gt;&lt;s5&gt;john.residence&lt;/s5&gt;&lt;/c4&gt; currently contains a valid &lt;c6&gt;&lt;s7&gt;Residence&lt;/s7&gt;&lt;/c6&gt; instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例において、&lt;c2&gt;&lt;s3&gt;john.residence&lt;/s3&gt;&lt;/c2&gt;の&lt;c0&gt;&lt;s1&gt;address&lt;/s1&gt;&lt;/c0&gt;プロパティを設定しようとする試みは成功します、なぜなら&lt;c4&gt;&lt;s5&gt;john.residence&lt;/s5&gt;&lt;/c4&gt;の値は現在は有効な&lt;c6&gt;&lt;s7&gt;Residence&lt;/s7&gt;&lt;/c6&gt;インスタンスを含むからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, the closing &lt;c9&gt;&lt;s10&gt;&gt;&lt;/s10&gt;&lt;/c9&gt; characters are not treated as a single token that may then be misinterpreted as a bit shift &lt;c11&gt;&lt;s12&gt;&gt;&gt;&lt;/s12&gt;&lt;/c11&gt; operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例において、閉じ&lt;c9&gt;&lt;s10&gt;&gt;&lt;/s10&gt;&lt;/c9&gt;文字たちは、単一のトークンとして見なされることはなく、それでビットシフト演算子&lt;c11&gt;&lt;s12&gt;&gt;&gt;&lt;/s12&gt;&lt;/c11&gt;と誤解されることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, the maximum number of allowed login attempts is declared as a constant, because the maximum value never changes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例において、許可されるログインの試みの最大数は、最大の値が決して変わらないので、定数として宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, the number &lt;c4&gt;&lt;s5&gt;5&lt;/s5&gt;&lt;/c4&gt; is correctly identified as a prime number.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、数&lt;c4&gt;&lt;s5&gt;5&lt;/s5&gt;&lt;/c4&gt;は正しく素数と確認されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, the property wrapper exposes only one piece of information—whether the number was adjusted—so it exposes that Boolean value as its projected value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、プロパティラッパーは情報の一片だけを露出します — その数が調節されたかどうか — それでそれはそのブール値をそれの予測値として露出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, the superclass for &lt;c0&gt;&lt;s1&gt;RecipeIngredient&lt;/s1&gt;&lt;/c0&gt; is &lt;c2&gt;&lt;s3&gt;Food&lt;/s3&gt;&lt;/c2&gt;, which has a single convenience initializer called &lt;c4&gt;&lt;s5&gt;init()&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、&lt;c0&gt;&lt;s1&gt;RecipeIngredient&lt;/s1&gt;&lt;/c0&gt;のためのスーパークラスは&lt;c2&gt;&lt;s3&gt;Food&lt;/s3&gt;&lt;/c2&gt;です、それは、&lt;c4&gt;&lt;s5&gt;init()&lt;/s5&gt;&lt;/c4&gt;と呼ばれる１つの便宜イニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, the value of &lt;c0&gt;&lt;s1&gt;friendlyWelcome&lt;/s1&gt;&lt;/c0&gt; is changed from &lt;c2&gt;&lt;s3&gt;"Hello!"&lt;/s3&gt;&lt;/c2&gt; to &lt;c4&gt;&lt;s5&gt;"Bonjour!"&lt;/s5&gt;&lt;/c4&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、&lt;c0&gt;&lt;s1&gt;friendlyWelcome&lt;/s1&gt;&lt;/c0&gt;の値は、&lt;c2&gt;&lt;s3&gt;"Hello!"&lt;/s3&gt;&lt;/c2&gt;から&lt;c4&gt;&lt;s5&gt;"Bonjour!"&lt;/s5&gt;&lt;/c4&gt;に変えられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this example, the variable &lt;c0&gt;&lt;s1&gt;number&lt;/s1&gt;&lt;/c0&gt; is initialized with the value of the closure’s &lt;c2&gt;&lt;s3&gt;number&lt;/s3&gt;&lt;/c2&gt; parameter, so that the value can be modified within the closure body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例では、変数&lt;c0&gt;&lt;s1&gt;number&lt;/s1&gt;&lt;/c0&gt;はこのクロージャの持つ&lt;c2&gt;&lt;s3&gt;number&lt;/s3&gt;&lt;/c2&gt;パラメータの値を使って初期化されます、それでその値はクロージャ本体の内部で修正されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this figure, the left channel has a current level of &lt;c4&gt;&lt;s5&gt;9&lt;/s5&gt;&lt;/c4&gt;, and the right channel has a current level of &lt;c6&gt;&lt;s7&gt;7&lt;/s7&gt;&lt;/c6&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この図には、左のチャンネルに現在&lt;c4&gt;&lt;s5&gt;9&lt;/s5&gt;&lt;/c4&gt;のレベルがあり、右のチャンネルに現在&lt;c6&gt;&lt;s7&gt;7&lt;/s7&gt;&lt;/c6&gt;のレベルがあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this form, each case block consists of the &lt;c0&gt;&lt;s1&gt;case&lt;/s1&gt;&lt;/c0&gt; keyword followed by one or more enumeration cases, separated by commas.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この形式では、それぞれのケース節ブロックはキーワード&lt;c0&gt;&lt;s1&gt;case&lt;/s1&gt;&lt;/c0&gt;とそれに続く１つ以上の、コンマで区切られた、列挙ケース節から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this form, each case block consists of the &lt;c0&gt;&lt;s1&gt;case&lt;/s1&gt;&lt;/c0&gt; keyword, followed by one or more enumeration cases, separated by commas.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この形式では、それぞれのケース節ブロックはキーワード&lt;c0&gt;&lt;s1&gt;case&lt;/s1&gt;&lt;/c0&gt;、それに続けて、コンマで区切られる１つ以上の列挙ケース節から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this implementation, the input parameters are named &lt;c0&gt;&lt;s1&gt;left&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;right&lt;/s3&gt;&lt;/c2&gt; to represent the &lt;c4&gt;&lt;s5&gt;Vector2D&lt;/s5&gt;&lt;/c4&gt; instances that will be on the left side and right side of the &lt;c6&gt;&lt;s7&gt;+&lt;/s7&gt;&lt;/c6&gt; operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この実装において、入力パラメータは、&lt;c0&gt;&lt;s1&gt;left&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;right&lt;/s3&gt;&lt;/c2&gt;という名前をつけられ、&lt;c6&gt;&lt;s7&gt;+&lt;/s7&gt;&lt;/c6&gt;演算子の左側と右側にある&lt;c4&gt;&lt;s5&gt;Vector2D&lt;/s5&gt;&lt;/c4&gt;インスタンスを表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this protocol, &lt;c0&gt;&lt;s1&gt;Suffix&lt;/s1&gt;&lt;/c0&gt; is an associated type, like the &lt;c2&gt;&lt;s3&gt;Item&lt;/s3&gt;&lt;/c2&gt; type in the &lt;c4&gt;&lt;s5&gt;Container&lt;/s5&gt;&lt;/c4&gt; example above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルにおいて、&lt;c0&gt;&lt;s1&gt;Suffix&lt;/s1&gt;&lt;/c0&gt;は関連型です、上の&lt;c4&gt;&lt;s5&gt;Container&lt;/s5&gt;&lt;/c4&gt;例での&lt;c2&gt;&lt;s3&gt;Item&lt;/s3&gt;&lt;/c2&gt;型のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this scenario, it’s useful to combine an unowned property on one class with an implicitly unwrapped optional property on the other class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この筋書きにおいて、一方のクラス上の非所有プロパティと他方のクラス上の暗黙的にアンラップされるオプショナルのプロパティを結合することは、役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this situation, the parameter name takes precedence, and it becomes necessary to refer to the property in a more qualified way.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この状況には、パラメータ名が優先されます、そして、より対象を限定するやり方でプロパティに言及することが必要になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this version of the game, the &lt;e0&gt;first&lt;/e0&gt; action in the loop is to check for a ladder or a snake.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ゲームのこの改作において、ループでの&lt;e0&gt;最初&lt;/e0&gt;の活動は、はしごまたはヘビについて調べることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In-Out Parameters</seg>
      </tuv>
      <tuv lang="JA">
        <seg>In-Outパラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In-out parameters are an alternative way for a function to have an effect outside of the scope of its function body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>in-outパラメータは、その関数本体のスコープの外で効果を持つようにする関数のための代替の方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In-out parameters are discussed in &lt;a4&gt;&lt;s5&gt;In-Out Parameters&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>in-outパラメータは、&lt;a4&gt;&lt;s5&gt;in-outパラメータ&lt;/s5&gt;&lt;/a4&gt;で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In-out parameters are discussed in detail in &lt;a2&gt;&lt;s3&gt;In-Out Parameters&lt;/s3&gt;&lt;/a2&gt;, below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>in-outパラメータは詳細に、下で、&lt;a2&gt;&lt;s3&gt;in-outパラメータ&lt;/s3&gt;&lt;/a2&gt;において議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In-out parameters are not the same as returning a value from a function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>in-outパラメータは、関数からある値が返されることと同じではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In-out parameters are passed as follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>in-outパラメータは、以下のように渡されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In-out parameters cannot have default values, and variadic parameters cannot be marked as &lt;c0&gt;&lt;s1&gt;inout&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>In-outパラメータは省略時の値を持つことができません、そして可変長パラメータは&lt;c0&gt;&lt;s1&gt;inout&lt;/s1&gt;&lt;/c0&gt;として印されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Includes a new section on &lt;a4&gt;&lt;s5&gt;Extended Grapheme Clusters&lt;/s5&gt;&lt;/a4&gt; and more information about &lt;a6&gt;&lt;s7&gt;Unicode Scalar Values&lt;/s7&gt;&lt;/a6&gt; and &lt;a8&gt;&lt;s9&gt;Comparing Strings&lt;/s9&gt;&lt;/a8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a4&gt;&lt;s5&gt;拡張書記素クラスタ&lt;/s5&gt;&lt;/a4&gt;に関する新しい節そして&lt;a6&gt;&lt;s7&gt;ユニコードスカラー値&lt;/s7&gt;&lt;/a6&gt;と&lt;a8&gt;&lt;s9&gt;文字列を比較する&lt;/s9&gt;&lt;/a8&gt;についての更なる情報を含めました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Including a &lt;c4&gt;&lt;s5&gt;default&lt;/s5&gt;&lt;/c4&gt; or &lt;c6&gt;&lt;s7&gt;@unknown&lt;/s7&gt; &lt;s8&gt;default&lt;/s8&gt;&lt;/c6&gt; case when switching over a frozen enumeration produces a warning because that code is never executed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;default&lt;/s5&gt;&lt;/c4&gt;または&lt;c6&gt;&lt;s7&gt;@unknown&lt;/s7&gt; &lt;s8&gt;default&lt;/s8&gt;&lt;/c6&gt;ケース節を、凍結列挙に対してスイッチしている時に含めることは、警告を生成します、なぜならそのコードは決して遂行されないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Indeed, if you are writing a single-target app, you may not need to specify explicit access control levels at all.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実際に、あなたが単一ターゲットのアプリを書いているならば、明確なアクセス制御水準を指定する必要はまったくありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Indeed, if you delete the &lt;c16&gt;&lt;s17&gt;typealias&lt;/s17&gt; &lt;s18&gt;Item&lt;/s18&gt; &lt;s19&gt;=&lt;/s19&gt; &lt;s20&gt;Int&lt;/s20&gt;&lt;/c16&gt; line from the code above, everything still works, because it’s clear what type should be used for &lt;c21&gt;&lt;s22&gt;Item&lt;/s22&gt;&lt;/c21&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>本当に、あなたが上のコードから行&lt;c16&gt;&lt;s17&gt;typealias&lt;/s17&gt; &lt;s18&gt;Item&lt;/s18&gt; &lt;s19&gt;=&lt;/s19&gt; &lt;s20&gt;Int&lt;/s20&gt;&lt;/c16&gt;を削除するならば、すべては依然として働きます、なぜなら、どんな型が&lt;c21&gt;&lt;s22&gt;Item&lt;/s22&gt;&lt;/c21&gt;のために使われなければならないかは明白であるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Indeed, if you tried to access the instance, your app would most likely crash.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実はそれどころか、あなたがそのインスタンスにアクセスしようとするならば、あなたのアプリはたぶんクラッシュするでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Indentation at the start of each quoted line is removed, as long as it matches the indentation of the closing quotation marks.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各引用された行の始まりでの字下げは、それが終了引用符の字下げと合致する分だけは、取り除かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inferring Type From Context</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文脈から型を推論する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inferring parameter and return value types from context</seg>
      </tuv>
      <tuv lang="JA">
        <seg>前後関係からパラメータおよび戻り値の型を推論する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Infix &lt;a0&gt;&lt;s1&gt;Operator Methods&lt;/s1&gt;&lt;/a0&gt; no longer require the &lt;c2&gt;&lt;s3&gt;@infix&lt;/s3&gt;&lt;/c2&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接中辞&lt;a0&gt;&lt;s1&gt;演算子メソッド&lt;/s1&gt;&lt;/a0&gt;はもはや&lt;c2&gt;&lt;s3&gt;@infix&lt;/s3&gt;&lt;/c2&gt;属性を必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Infix operators can optionally specify a precedence group.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接中辞演算子は、任意に優先順位グループを指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inheritance</seg>
      </tuv>
      <tuv lang="JA">
        <seg>継承</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inheritance enables one class to inherit the characteristics of another.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>継承は、あるクラスが他のものの特徴を受け継ぐのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inheritance is a fundamental behavior that differentiates classes from other types in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>継承は、スウィフトにおいてクラスを他の型と区別する基本的挙動です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initial values for the properties of the new instance can be passed to the memberwise initializer by name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しいインスタンスのプロパティのための初期値は、名前でメンバー関連イニシャライザに渡されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initial values for the properties of the new instance can be passed to the memberwise initializer by name:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しいインスタンスのプロパティのための最初の値は、名前によってメンバー関連イニシャライザに渡されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initialization</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initialization Parameters</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期化パラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initialization failure propagates through initializer delegation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期化失敗は、イニシャライザ委任を通じて伝えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initialization parameters have the same capabilities and syntax as function and method parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期化パラメータは、関数およびメソッドのパラメータと同じ能力と構文を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializer Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザ宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializer Delegation for Class Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス型のためのイニシャライザ委任</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializer Delegation for Value Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値型のためのイニシャライザ委任</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializer Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザ式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializer Inheritance and Overriding</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザの継承およびオーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializer Parameters Without Argument Labels</seg>
      </tuv>
      <tuv lang="JA">
        <seg>引数ラベルのないイニシャライザ・パラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializer Requirements</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザ要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializer declarations are declared using the &lt;c1&gt;&lt;s2&gt;init&lt;/s2&gt;&lt;/c1&gt; keyword and have two basic forms.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザ宣言は、キーワード&lt;c1&gt;&lt;s2&gt;init&lt;/s2&gt;&lt;/c1&gt;を使って宣言されて、２つの基本の書式を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializers are described in more detail in &lt;a0&gt;&lt;s1&gt;Initialization&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザは、更に詳細に&lt;a0&gt;&lt;s1&gt;初期化&lt;/s1&gt;&lt;/a0&gt;で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializers are now able to access &lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt; and can modify its properties, call its instance methods, and so on.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザは、今では&lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;にアクセスすることができます、そしてそれのプロパティを修正すること、それのインスタンスをメソッドを呼び出すこと、などが行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializers can call other initializers to perform part of an instance’s initialization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザは、あるインスタンスの初期化の一部を実行するために他のイニシャライザを呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializers can delegate to other initializers in the enumeration, but the initialization process is complete only after an initializer assigns one of the enumeration cases to &lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザは、その列挙の中の他のイニシャライザに委任することができます、しかしその初期化処理はあるイニシャライザが列挙ケース節のうちの１つを&lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;に代入した後になって初めて終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializers in structures and enumerations can call other declared initializers to delegate part or all of the initialization process.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体および列挙のイニシャライザは、初期化プロセスの一部または全てを委任するために他の宣言済みイニシャライザを呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializing an Empty String</seg>
      </tuv>
      <tuv lang="JA">
        <seg>空の文字列を初期化する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initializing from a Raw Value</seg>
      </tuv>
      <tuv lang="JA">
        <seg>生の値から初期化する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inlinable code can interact with &lt;c0&gt;&lt;s1&gt;public&lt;/s1&gt;&lt;/c0&gt; symbols declared in any module, and it can interact with &lt;c2&gt;&lt;s3&gt;internal&lt;/s3&gt;&lt;/c2&gt; symbols declared in the same module that are marked with the &lt;c4&gt;&lt;s5&gt;usableFromInline&lt;/s5&gt;&lt;/c4&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インライン可能コードは、何らかのモジュールにおいて宣言される&lt;c0&gt;&lt;s1&gt;public&lt;/s1&gt;&lt;/c0&gt;シンボルと相互作用できます、そしてそれは同じモジュールにおいて宣言される&lt;c2&gt;&lt;s3&gt;internal&lt;/s3&gt;&lt;/c2&gt;シンボルで、&lt;c4&gt;&lt;s5&gt;usableFromInline&lt;/s5&gt;&lt;/c4&gt;属性で印されるものと相互作用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inlinable code can’t interact with &lt;c6&gt;&lt;s7&gt;private&lt;/s7&gt;&lt;/c6&gt; or &lt;c8&gt;&lt;s9&gt;fileprivate&lt;/s9&gt;&lt;/c8&gt; symbols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インライン可能コードは、&lt;c6&gt;&lt;s7&gt;private&lt;/s7&gt;&lt;/c6&gt;または&lt;c8&gt;&lt;s9&gt;fileprivate&lt;/s9&gt;&lt;/c8&gt;シンボルと相互作用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inserting &lt;c0&gt;&lt;s1&gt;-9&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;4&lt;/s3&gt;&lt;/c2&gt; into the equation yields:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;-9&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;4&lt;/s3&gt;&lt;/c2&gt;を等式に入れることは、以下を生じます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inserting &lt;c0&gt;&lt;s1&gt;9&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;4&lt;/s3&gt;&lt;/c2&gt; into this equation yields:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;9&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;4&lt;/s3&gt;&lt;/c2&gt;をこの等式に入れることは、以下を生じます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inserting and Removing</seg>
      </tuv>
      <tuv lang="JA">
        <seg>差し込みと削除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inside a closure with no explicit parameter names, the parameters are implicitly named &lt;c0&gt;&lt;s1&gt;$0&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;$1&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;$2&lt;/s5&gt;&lt;/c4&gt;, and so on.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>明確なパラメータ名のないクロージャの内部で、パラメータは暗黙のうちに&lt;c0&gt;&lt;s1&gt;$0&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;$1&lt;/s3&gt;&lt;/c2&gt;、&lt;c4&gt;&lt;s5&gt;$2&lt;/s5&gt;&lt;/c4&gt;、などと名前をつけられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inside a function, the value of &lt;c0&gt;&lt;s1&gt;#function&lt;/s1&gt;&lt;/c0&gt; is the name of that function, inside a method it is the name of that method, inside a property getter or setter it is the name of that property, inside special members like &lt;c2&gt;&lt;s3&gt;init&lt;/s3&gt;&lt;/c2&gt; or &lt;c4&gt;&lt;s5&gt;subscript&lt;/s5&gt;&lt;/c4&gt; it is the name of that keyword, and at the top level of a file it is the name of the current module.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数の内側では、&lt;c0&gt;&lt;s1&gt;#function&lt;/s1&gt;&lt;/c0&gt;の値は、その関数の名前であり、メソッドの内側ではそれはそのメソッドの名前であり、プロパティゲッターやセッターの内側ではそれはそのプロパティの名前であり、&lt;c2&gt;&lt;s3&gt;init&lt;/s3&gt;&lt;/c2&gt;または&lt;c4&gt;&lt;s5&gt;subscript&lt;/s5&gt;&lt;/c4&gt;のような特別なメンバーの内側ではそれはそのキーワードの名前であり、そしてあるファイルのトップレベルではそれは現在のモジュールの名前です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inside a nested type declaration, the &lt;c0&gt;&lt;s1&gt;Self&lt;/s1&gt;&lt;/c0&gt; type refers to the type introduced by the innermost type declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>入れ子にされた型宣言の内部で、&lt;c0&gt;&lt;s1&gt;Self&lt;/s1&gt;&lt;/c0&gt;型は、最も内側の型宣言によって導入された型を参照します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inside a protocol declaration, a type alias can give a shorter and more convenient name to a type that is used frequently.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル宣言の内部で、型エイリアスはより短くより便利な名前を頻繁に使われる型に提供できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inside the &lt;c4&gt;&lt;s5&gt;do&lt;/s5&gt;&lt;/c4&gt; block, you mark code that can throw an error by writing &lt;c6&gt;&lt;s7&gt;try&lt;/s7&gt;&lt;/c6&gt; in front of it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;do&lt;/s5&gt;&lt;/c4&gt;ブロックの内部で、あなたはエラーをスローできるコードを、それの前に&lt;c6&gt;&lt;s7&gt;try&lt;/s7&gt;&lt;/c6&gt;を書くことによって印します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inside the &lt;c8&gt;&lt;s9&gt;catch&lt;/s9&gt;&lt;/c8&gt; block, the error is automatically given the name &lt;c10&gt;&lt;s11&gt;error&lt;/s11&gt;&lt;/c10&gt; unless you give it a different name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c8&gt;&lt;s9&gt;catch&lt;/s9&gt;&lt;/c8&gt;ブロック内部で、エラーは、あなたがそれに別の名前を与えるのでない限り、自動的に名前&lt;c10&gt;&lt;s11&gt;error&lt;/s11&gt;&lt;/c10&gt;を与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inside the declaration for a member of a type, the &lt;c2&gt;&lt;s3&gt;Self&lt;/s3&gt;&lt;/c2&gt; type refers to that type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型のメンバーに対する宣言の内部で、&lt;c2&gt;&lt;s3&gt;Self&lt;/s3&gt;&lt;/c2&gt;型は、その型を参照します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inside the switch, the enumeration case is referred to by the abbreviated form &lt;c6&gt;&lt;s7&gt;.hearts&lt;/s7&gt;&lt;/c6&gt; because the value of &lt;c8&gt;&lt;s9&gt;self&lt;/s9&gt;&lt;/c8&gt; is already known to be a suit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スイッチの内側では、列挙のケース節は省略された形式&lt;c6&gt;&lt;s7&gt;.hearts&lt;/s7&gt;&lt;/c6&gt;によって参照されます、なぜなら&lt;c8&gt;&lt;s9&gt;self&lt;/s9&gt;&lt;/c8&gt;の値がすでに組み札のひとつ（スペード、クラブ、ハート、ダイヤのどれか）であるということがわかっているからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instance Methods</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インスタンスメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instance methods added with an extension can also modify (or &lt;e0&gt;mutate&lt;/e0&gt;) the instance itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張を使って加えられるインスタンスメソッドは、また、インスタンスそれ自体を修正（または&lt;e0&gt;変更&lt;/e0&gt;）することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instance methods have exactly the same syntax as functions, as described in &lt;a1&gt;&lt;s2&gt;Functions&lt;/s2&gt;&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インスタンスメソッドは、関数と正確に同じ構文を持ちます、&lt;a1&gt;&lt;s2&gt;関数&lt;/s2&gt;&lt;/a1&gt;で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instance methods, as described above, are methods that you call on an instance of a particular type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インスタンスメソッドは、上で記述されるように、あなたが特定の型のインスタンス上で呼び出すメソッドです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instance properties are properties that belong to an instance of a particular type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インスタンスプロパティは、ある特定の型のあるひとつのインスタンスに属しているプロパティです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instance subscripts, as described above, are subscripts that you call on an instance of a particular type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インスタンス添え字は、上で記述されるように、あなたがある特定の型のインスタンス上で呼び出す添え字です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instances of &lt;c0&gt;&lt;s1&gt;FixedLengthRange&lt;/s1&gt;&lt;/c0&gt; have a variable stored property called &lt;c2&gt;&lt;s3&gt;firstValue&lt;/s3&gt;&lt;/c2&gt; and a constant stored property called &lt;c4&gt;&lt;s5&gt;length&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;FixedLengthRange&lt;/s1&gt;&lt;/c0&gt;のインスタンスは&lt;c2&gt;&lt;s3&gt;firstValue&lt;/s3&gt;&lt;/c2&gt;と呼ばれる変数格納プロパティと&lt;c4&gt;&lt;s5&gt;length&lt;/s5&gt;&lt;/c4&gt;と呼ばれる定数格納プロパティをもちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instances of &lt;c0&gt;&lt;s1&gt;Hamster&lt;/s1&gt;&lt;/c0&gt; can now be used wherever &lt;c2&gt;&lt;s3&gt;TextRepresentable&lt;/s3&gt;&lt;/c2&gt; is the required type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;TextRepresentable&lt;/s3&gt;&lt;/c2&gt;が必要な型であるどこででも、&lt;c0&gt;&lt;s1&gt;Hamster&lt;/s1&gt;&lt;/c0&gt;のインスタンスが現在使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instances of class types can also implement a &lt;e0&gt;deinitializer&lt;/e0&gt;, which performs any custom cleanup just before an instance of that class is deallocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス型のインスタンスはまた、&lt;e0&gt;デイニシャライザ&lt;/e0&gt;を実装することができます、それは、そのクラスのインスタンスの割り当て解除がされる直前に、何らかのあつらえのクリーンアップ作業を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of generating a random number, it starts with a &lt;c0&gt;&lt;s1&gt;diceRoll&lt;/s1&gt;&lt;/c0&gt; value of &lt;c2&gt;&lt;s3&gt;0&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>無作為な数を生成する代わりに、それは&lt;c2&gt;&lt;s3&gt;0&lt;/s3&gt;&lt;/c2&gt;の&lt;c0&gt;&lt;s1&gt;diceRoll&lt;/s1&gt;&lt;/c0&gt;値から始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of making a copy immediately, these collections share the memory where the elements are stored between the original instance and any copies.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるコピーを直接に作る代わりに、それらコレクションは要素が格納されるところのメモリを、元のインスタンスと何らかのコピーの間で共有します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of making an explicit call to &lt;c8&gt;&lt;s9&gt;super.init()&lt;/s9&gt;&lt;/c8&gt;, this initializer relies on an implicit call to its superclass’s initializer to complete the process.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c8&gt;&lt;s9&gt;super.init()&lt;/s9&gt;&lt;/c8&gt;への明示的な呼び出しをする代わりに、このイニシャライザはそれのスーパークラスの持つイニシャライザへの暗黙的な呼び出しを当てにすることで、その過程を完了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of providing a concrete type as the function’s return type, the return value is described in terms of the protocols it supports.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある具象型を関数のもつ戻り型として提供する代わりに、戻り値はそれがサポートするプロトコルそれらの観点から記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead of returning a new point, this method actually modifies the point on which it is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい点を返す代わりに、このメソッドは、それが呼び出された点を実際に修正します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, &lt;c12&gt;&lt;s13&gt;Rect&lt;/s13&gt;&lt;/c12&gt; defines a custom getter and setter for a computed variable called &lt;c14&gt;&lt;s15&gt;center&lt;/s15&gt;&lt;/c14&gt;, to enable you to work with the rectangle’s &lt;c16&gt;&lt;s17&gt;center&lt;/s17&gt;&lt;/c16&gt; as if it were a real stored property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その代わりに、&lt;c12&gt;&lt;s13&gt;Rect&lt;/s13&gt;&lt;/c12&gt;は、&lt;c14&gt;&lt;s15&gt;center&lt;/s15&gt;&lt;/c14&gt;と呼ばれる計算される変数のためにあつらえのゲッターとセッターを定義して、矩形の&lt;c16&gt;&lt;s17&gt;center&lt;/s17&gt;&lt;/c16&gt;をそれがまったく格納プロパティであるかのようにあなたが扱うことができるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, a literal is parsed as having infinite precision and Swift’s type inference attempts to infer a type for the literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうではなく、リテラルは無限精度を持つものとして解析されて、スウィフトの型推論はそのリテラルの型を推測することを試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, it makes more sense to create the &lt;c6&gt;&lt;s7&gt;DataImporter&lt;/s7&gt;&lt;/c6&gt; instance if and when it is first used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その代わりに、それが最初に必要とされる時になれば&lt;c6&gt;&lt;s7&gt;DataImporter&lt;/s7&gt;&lt;/c6&gt;を作成するほうが筋が通ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, make an explicit check against &lt;c8&gt;&lt;s9&gt;nil&lt;/s9&gt;&lt;/c8&gt; with the &lt;c10&gt;&lt;s11&gt;==&lt;/s11&gt;&lt;/c10&gt; or &lt;c12&gt;&lt;s13&gt;!=&lt;/s13&gt;&lt;/c12&gt; operators to find out if an optional contains a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その代わりに、&lt;c8&gt;&lt;s9&gt;nil&lt;/s9&gt;&lt;/c8&gt;に備えて、&lt;c10&gt;&lt;s11&gt;==&lt;/s11&gt;&lt;/c10&gt;または&lt;c12&gt;&lt;s13&gt;!=&lt;/s13&gt;&lt;/c12&gt;演算子を使ってオプショナルが値を持つかどうか確認するために明示的に調べてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the &lt;c0&gt;&lt;s1&gt;Stack&lt;/s1&gt;&lt;/c0&gt; type’s existing type parameter name, &lt;c2&gt;&lt;s3&gt;Element&lt;/s3&gt;&lt;/c2&gt;, is used within the extension to indicate the optional type of the &lt;c4&gt;&lt;s5&gt;topItem&lt;/s5&gt;&lt;/c4&gt; computed property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうしなくても、&lt;c0&gt;&lt;s1&gt;Stack&lt;/s1&gt;&lt;/c0&gt;型の既存の型パラメーター名、&lt;c2&gt;&lt;s3&gt;Element&lt;/s3&gt;&lt;/c2&gt;は、拡張の内部で&lt;c4&gt;&lt;s5&gt;topItem&lt;/s5&gt;&lt;/c4&gt;計算プロパティの元々の型を指し示すために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the addition assignment operator method takes advantage of the existing addition operator method, and uses it to set the left value to be the left value plus the right value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代わりに、追加代入演算子メソッドは、既存の加算演算子メソッドを利用して、左の値を右の値を加えた左の値に設定するためにそれを使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the different enumeration cases are values in their own right, with an explicitly defined type of &lt;c18&gt;&lt;s19&gt;CompassPoint&lt;/s19&gt;&lt;/c18&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その代わりに、異なる列挙ケース節それらは、ある明示的に定義された&lt;c18&gt;&lt;s19&gt;CompassPoint&lt;/s19&gt;&lt;/c18&gt;の型を持つ、自分だけのものである値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the entire &lt;c4&gt;&lt;s5&gt;switch&lt;/s5&gt;&lt;/c4&gt; statement finishes its execution as soon as the first matching &lt;c6&gt;&lt;s7&gt;switch&lt;/s7&gt;&lt;/c6&gt; case is completed, without requiring an explicit &lt;c8&gt;&lt;s9&gt;break&lt;/s9&gt;&lt;/c8&gt; statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その代わりに、最初のマッチしている&lt;c4&gt;&lt;s5&gt;switch&lt;/s5&gt;&lt;/c4&gt;ケース節の部分が完了されるとすぐに、&lt;c6&gt;&lt;s7&gt;switch&lt;/s7&gt;&lt;/c6&gt;文の全体がその実行を終えます、明確な&lt;c8&gt;&lt;s9&gt;break&lt;/s9&gt;&lt;/c8&gt;文を必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the loop is executed until a particular condition is satisfied.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その代わりに、このループは特定の条件が満たされるまで実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the protocol’s own access level is used to provide the default access level for each protocol requirement implementation within the extension.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その代わりに、プロトコル自身のアクセス水準が、省略時のアクセス水準を拡張内の各プロトコル要件実施のために提供するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the type parameter list from the &lt;e0&gt;original&lt;/e0&gt; type definition is available within the body of the extension, and the original type parameter names are used to refer to the type parameters from the original definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうしなくても、&lt;e0&gt;元々の&lt;/e0&gt;型定義からの型パラメーターリストは、その拡張の本文内で利用可能です、そして元々の型パラメーター名は、元々の定義からの型パラメーターを参照するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, these references are defined like any other constant or variable in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その代わりに、これらの参照は、スウィフトにおけるあらゆる他の定数または変数と同じように定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, they are called only when the value is set outside of an initialization context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうではなく、値が初期化の文脈の外で設定されるときにだけ、それらは呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, they provide a getter and an optional setter to retrieve and set other properties and values indirectly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その代わりに、それらは他のプロパティや値を間接的に取得したり設定したりするためにゲッターと任意のセッターを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, this example calls &lt;c8&gt;&lt;s9&gt;UInt16(one)&lt;/s9&gt;&lt;/c8&gt; to create a new &lt;c10&gt;&lt;s11&gt;UInt16&lt;/s11&gt;&lt;/c10&gt; initialized with the value of &lt;c12&gt;&lt;s13&gt;one&lt;/s13&gt;&lt;/c12&gt;, and uses this value in place of the original:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その代わりに、この例は&lt;c12&gt;&lt;s13&gt;one&lt;/s13&gt;&lt;/c12&gt;の値で初期化される新しい&lt;c10&gt;&lt;s11&gt;UInt16&lt;/s11&gt;&lt;/c10&gt;を作るために&lt;c8&gt;&lt;s9&gt;UInt16(one)&lt;/s9&gt;&lt;/c8&gt;を呼んで、オリジナルの代わりにこの値を使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, use separate &lt;c2&gt;&lt;s3&gt;available&lt;/s3&gt;&lt;/c2&gt; attributes to specify a Swift version availability and one or more platform availabilities.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代わりに、&lt;c2&gt;&lt;s3&gt;available&lt;/s3&gt;&lt;/c2&gt;属性を使うことで、スウィフトバージョン利用可能性と１つ以上のプラットホーム利用可能性を指定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, use the &lt;c4&gt;&lt;s5&gt;append(_:)&lt;/s5&gt;&lt;/c4&gt; method, or append a single-item array with the &lt;c6&gt;&lt;s7&gt;+=&lt;/s7&gt;&lt;/c6&gt; operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その代わりに、&lt;c4&gt;&lt;s5&gt;append(_:)&lt;/s5&gt;&lt;/c4&gt;メソッドを使ってください、または単一項目の配列を&lt;c6&gt;&lt;s7&gt;+=&lt;/s7&gt;&lt;/c6&gt;演算子を使って加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integer Bounds</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数の限界</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integer Conversion</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integer Literals</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数リテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integer and Floating-Point Conversion</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数と浮動小数点の変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integer literals can be written as:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数リテラルは、次のように書かれることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integer literals can begin with leading zeros (&lt;c2&gt;&lt;s3&gt;0&lt;/s3&gt;&lt;/c2&gt;), but they’re likewise ignored and don’t affect the base or value of the literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数リテラルは、いくつかのゼロ（&lt;c2&gt;&lt;s3&gt;0&lt;/s3&gt;&lt;/c2&gt;）を先頭に始まることができます、しかしそれらは同様に無視されて、リテラルの基数または値に影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integers are checked for overflow.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数は、オーバーフローを確認される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Integers are either &lt;e5&gt;signed&lt;/e5&gt; (positive, zero, or negative) or &lt;e6&gt;unsigned&lt;/e6&gt; (positive or zero).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数は、&lt;e5&gt;符号つき&lt;/e5&gt;（正、ゼロ、または負）または&lt;e6&gt;符号なし&lt;/e6&gt;（正またはゼロ）のどちらかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interface Builder attributes are declaration attributes used by Interface Builder to synchronize with Xcode.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いくつかのインターフェイスビルダー属性は、Xcodeと同期するためにインターフェイスビルダーによって使用される宣言属性です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interval Matching</seg>
      </tuv>
      <tuv lang="JA">
        <seg>区間マッチング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It adds a &lt;c4&gt;&lt;s5&gt;director&lt;/s5&gt;&lt;/c4&gt; property on top of the base &lt;c6&gt;&lt;s7&gt;MediaItem&lt;/s7&gt;&lt;/c6&gt; class, with a corresponding initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、対応するイニシャライザを使って、基盤クラス&lt;c6&gt;&lt;s7&gt;MediaItem&lt;/s7&gt;&lt;/c6&gt;の上に&lt;c4&gt;&lt;s5&gt;director&lt;/s5&gt;&lt;/c4&gt;プロパティを加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also cannot transfer control into a case block whose pattern contains value binding patterns.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはまた、パターンが値束縛パターンを含むケース節ブロックに制御を移すことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also defines a computed property called &lt;c6&gt;&lt;s7&gt;description&lt;/s7&gt;&lt;/c6&gt;, which uses the values stored in &lt;c8&gt;&lt;s9&gt;rank&lt;/s9&gt;&lt;/c8&gt; and &lt;c10&gt;&lt;s11&gt;suit&lt;/s11&gt;&lt;/c10&gt; to build a description of the name and value of the card.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはまた、&lt;c6&gt;&lt;s7&gt;description&lt;/s7&gt;&lt;/c6&gt;と呼ばれる計算プロパティを定義します、それは、&lt;c8&gt;&lt;s9&gt;rank&lt;/s9&gt;&lt;/c8&gt;と&lt;c10&gt;&lt;s11&gt;suit&lt;/s11&gt;&lt;/c10&gt;に保管される値を使って、カードの名前と説明の値を作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also defines an array of integers, ready to be converted into strings.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはまた、文字列に変換される準備ができている整数の配列も定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also means you can be confident about the type of values you will retrieve from a collection.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはまた、あなたがコレクションから取り出す値の型をあなたが確信できることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also offers two methods—&lt;c4&gt;&lt;s5&gt;distribute(coins:)&lt;/s5&gt;&lt;/c4&gt; and &lt;c6&gt;&lt;s7&gt;receive(coins:)&lt;/s7&gt;&lt;/c6&gt;—to handle the distribution and collection of coins.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはまた、２つのメソッド ― &lt;c4&gt;&lt;s5&gt;distribute(coins:)&lt;/s5&gt;&lt;/c4&gt;と&lt;c6&gt;&lt;s7&gt;receive(coins:)&lt;/s7&gt;&lt;/c6&gt;— ― を提供して、コインの配布と回収を取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also provides a method called &lt;c4&gt;&lt;s5&gt;complete(level:)&lt;/s5&gt;&lt;/c4&gt;, which is called whenever a player completes a particular level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはまた&lt;c4&gt;&lt;s5&gt;complete(level:)&lt;/s5&gt;&lt;/c4&gt;と呼ばれるメソッドを提供します、それは、プレーヤーが特定のレベルを完了するときはいつでも呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also tracks the current level for an individual player.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはまた、個々のプレーヤーのために現在のレベルを追跡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It appends a colon and a line break, and uses this as the start of its pretty text representation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはコロンと改行を追加します、そしてそれのきれいなテキスト表示のスタートとして、これを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It calculates the last digit of &lt;c2&gt;&lt;s3&gt;number&lt;/s3&gt;&lt;/c2&gt; by using the remainder operator (&lt;c4&gt;&lt;s5&gt;number&lt;/s5&gt; &lt;s6&gt;%&lt;/s6&gt; &lt;s7&gt;10&lt;/s7&gt;&lt;/c4&gt;), and uses this digit to look up an appropriate string in the &lt;c8&gt;&lt;s9&gt;digitNames&lt;/s9&gt;&lt;/c8&gt; dictionary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、&lt;c2&gt;&lt;s3&gt;number&lt;/s3&gt;&lt;/c2&gt;の最後の桁を剰余演算子を使用することによって計算して（&lt;c4&gt;&lt;s5&gt;number&lt;/s5&gt; &lt;s6&gt;%&lt;/s6&gt; &lt;s7&gt;10&lt;/s7&gt;&lt;/c4&gt;）、この桁を&lt;c8&gt;&lt;s9&gt;digitNames&lt;/s9&gt;&lt;/c8&gt;辞書で適切な文字列を捜すために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It calls the provided function with the values &lt;c8&gt;&lt;s9&gt;3&lt;/s9&gt;&lt;/c8&gt; and &lt;c10&gt;&lt;s11&gt;5&lt;/s11&gt;&lt;/c10&gt;, and prints the result of &lt;c12&gt;&lt;s13&gt;8&lt;/s13&gt;&lt;/c12&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、提供された関数を値&lt;c8&gt;&lt;s9&gt;3&lt;/s9&gt;&lt;/c8&gt;と&lt;c10&gt;&lt;s11&gt;5&lt;/s11&gt;&lt;/c10&gt;を使って呼び出して、結果の&lt;c12&gt;&lt;s13&gt;8&lt;/s13&gt;&lt;/c12&gt;を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can accept member names using an argument of a type that conforms to the &lt;a14&gt;&lt;c15&gt;&lt;s16&gt;ExpressibleByStringLiteral&lt;/s16&gt;&lt;/c15&gt;&lt;/a14&gt;&lt;s17&gt; [https://developer.apple.com/documentation/swift/expressiblebystringliteral]&lt;/s17&gt; protocol—in most cases, &lt;c18&gt;&lt;s19&gt;String&lt;/s19&gt;&lt;/c18&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはメンバー名を、&lt;a14&gt;&lt;c15&gt;&lt;s16&gt;ExpressibleByStringLiteral&lt;/s16&gt;&lt;/c15&gt;&lt;/a14&gt;&lt;s17&gt; [https://developer.apple.com/documentation/swift/expressiblebystringliteral]&lt;/s17&gt;プロトコルに準拠する型 — ほとんどの場合、&lt;c18&gt;&lt;s19&gt;String&lt;/s19&gt;&lt;/c18&gt; — の引数を使って受け入れ可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can also be useful to define requirements for associated types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連型のために要件を定義することは、また同様に役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can also match a value with a range of values, by checking whether the value is contained within the range, as the following example shows.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはまた、ある値をある範囲の値と照合することが、その値がその範囲に含まれるかどうかを調べることによって可能です、以下の例が示すように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be described as “a tuple of type &lt;c8&gt;&lt;s9&gt;(Int,&lt;/s9&gt; &lt;s10&gt;String)&lt;/s10&gt;&lt;/c8&gt;”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは型&lt;c8&gt;&lt;s9&gt;(Int,&lt;/s9&gt; &lt;s10&gt;String)&lt;/s10&gt;&lt;/c8&gt;のタプルとして記述されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be read as “not &lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt;&lt;/c0&gt;”, as seen in the following example:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、「&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt;&lt;/c0&gt;でない」のように読まれることができます、下記の例では見られるように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be useful to require a type to conform to multiple protocols at the same time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型に複数のプロトコルに一時に従うことを要求することは、役に立つことがありえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can do this with a control transfer statement such as &lt;c4&gt;&lt;s5&gt;return&lt;/s5&gt;&lt;/c4&gt;, &lt;c6&gt;&lt;s7&gt;break&lt;/s7&gt;&lt;/c6&gt;, &lt;c8&gt;&lt;s9&gt;continue&lt;/s9&gt;&lt;/c8&gt;, or &lt;c10&gt;&lt;s11&gt;throw&lt;/s11&gt;&lt;/c10&gt;, or it can call a function or method that doesn’t return, such as &lt;c12&gt;&lt;s13&gt;fatalError(_:file:line:)&lt;/s13&gt;&lt;/c12&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはこれを制御移動文&lt;c4&gt;&lt;s5&gt;return&lt;/s5&gt;&lt;/c4&gt;、&lt;c6&gt;&lt;s7&gt;break&lt;/s7&gt;&lt;/c6&gt;、&lt;c8&gt;&lt;s9&gt;continue&lt;/s9&gt;&lt;/c8&gt;、または&lt;c10&gt;&lt;s11&gt;throw&lt;/s11&gt;&lt;/c10&gt;などで行えます、またはそれは復帰しない関数やメソッド、例えば&lt;c12&gt;&lt;s13&gt;fatalError(_:file:line:)&lt;/s13&gt;&lt;/c12&gt;を呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can sometimes be useful to find out whether two constants or variables refer to exactly the same instance of a class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つの定数または変数が正確にあるクラスの同じインスタンスに言及するかどうかについて、探り出すことは時々役に立つことがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It cannot be called in isolation without an existing instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、単独で既存のインスタンスなしで呼ばれることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It cannot be modified by a subclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、サブクラスによって修正されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can’t call any other initializers of the same class, and if the class has a superclass, it must call one of the superclass’s designated initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは同じクラスの他のどのイニシャライザも呼ぶことができません、そしてそのクラスがスーパークラスを持つならば、それはスーパークラスの指定イニシャライザのうちの１つを呼ばなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can’t contain three unescaped double quotation marks next to each other.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、お互いは別として３つのエスケープされない二重引用符を含むことが出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It compares the new value of &lt;c4&gt;&lt;s5&gt;totalSteps&lt;/s5&gt;&lt;/c4&gt; against the old value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、&lt;c4&gt;&lt;s5&gt;totalSteps&lt;/s5&gt;&lt;/c4&gt;の新しい値をその古い値と比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It consists of a period (&lt;c1&gt;&lt;s2&gt;.&lt;/s2&gt;&lt;/c1&gt;) between the item and the identifier of its member.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、その項目とそれのメンバーの識別子の間のピリオド（&lt;c1&gt;&lt;s2&gt;.&lt;/s2&gt;&lt;/c1&gt;）から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It delegates across to a designated initializer from the same class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、横の同じクラスの指定イニシャライザに向かって委任します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It does this by capturing a &lt;e6&gt;reference&lt;/e6&gt; to &lt;c7&gt;&lt;s8&gt;runningTotal&lt;/s8&gt;&lt;/c7&gt; and &lt;c9&gt;&lt;s10&gt;amount&lt;/s10&gt;&lt;/c9&gt; from the surrounding function and using them within its own function body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、それを囲んでいる関数から&lt;c7&gt;&lt;s8&gt;runningTotal&lt;/s8&gt;&lt;/c7&gt;と&lt;c9&gt;&lt;s10&gt;amount&lt;/s10&gt;&lt;/c9&gt;への&lt;e6&gt;参照&lt;/e6&gt;を捕獲して、それらをそれ自身の関数本文内で使うことによってこれを行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It does this by implementing the optional &lt;c4&gt;&lt;s5&gt;fixedIncrement&lt;/s5&gt;&lt;/c4&gt; property requirement:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、オプショナルの&lt;c4&gt;&lt;s5&gt;fixedIncrement&lt;/s5&gt;&lt;/c4&gt;プロパティ要件を実装することによってこれをします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It doesn’t make sense for &lt;c10&gt;&lt;s11&gt;volume&lt;/s11&gt;&lt;/c10&gt; to be settable, because it would be ambiguous as to which values of &lt;c12&gt;&lt;s13&gt;width&lt;/s13&gt;&lt;/c12&gt;, &lt;c14&gt;&lt;s15&gt;height&lt;/s15&gt;&lt;/c14&gt;, and &lt;c16&gt;&lt;s17&gt;depth&lt;/s17&gt;&lt;/c16&gt; should be used for a particular &lt;c18&gt;&lt;s19&gt;volume&lt;/s19&gt;&lt;/c18&gt; value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c10&gt;&lt;s11&gt;volume&lt;/s11&gt;&lt;/c10&gt;が設定可能であることは意味をなしません、なぜなら特定の&lt;c18&gt;&lt;s19&gt;volume&lt;/s19&gt;&lt;/c18&gt;値に対して&lt;c12&gt;&lt;s13&gt;width&lt;/s13&gt;&lt;/c12&gt;、&lt;c14&gt;&lt;s15&gt;height&lt;/s15&gt;&lt;/c14&gt;、そして&lt;c16&gt;&lt;s17&gt;depth&lt;/s17&gt;&lt;/c16&gt;にどの値が使われなければならないかはあいまいだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It doesn’t matter that &lt;c10&gt;&lt;s11&gt;"zebra"&lt;/s11&gt;&lt;/c10&gt; isn’t less than &lt;c12&gt;&lt;s13&gt;"apple"&lt;/s13&gt;&lt;/c12&gt;, because the comparison is already determined by the tuples’ first elements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c10&gt;&lt;s11&gt;"zebra"&lt;/s11&gt;&lt;/c10&gt;が&lt;c12&gt;&lt;s13&gt;"apple"&lt;/s13&gt;&lt;/c12&gt;より少ないことは問題ではありません、この比較はすでにタプルの最初の要素によって決定されているからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It doesn’t matter what that function’s implementation actually does—it matters only that the function is of the correct type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その関数の実装が実際に何をするかは、重要ではありません ― ただ関数が正しい型であるのが重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It doesn’t take any arguments, and when it’s called, it returns the value of the expression that’s wrapped inside of it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、全く引数を取りません、そしてそれが呼ばれる時、その内部に包み込まれた式の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It doubles the &lt;c6&gt;&lt;s7&gt;x&lt;/s7&gt;&lt;/c6&gt; and &lt;c8&gt;&lt;s9&gt;y&lt;/s9&gt;&lt;/c8&gt; values of a &lt;c10&gt;&lt;s11&gt;Vector2D&lt;/s11&gt;&lt;/c10&gt; instance, by adding the vector to itself with the addition assignment operator defined earlier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは&lt;c10&gt;&lt;s11&gt;Vector2D&lt;/s11&gt;&lt;/c10&gt;インスタンスの&lt;c6&gt;&lt;s7&gt;x&lt;/s7&gt;&lt;/c6&gt;と&lt;c8&gt;&lt;s9&gt;y&lt;/s9&gt;&lt;/c8&gt;値を、そのベクトルをそれ自体へと以前に定義される加算代入演算子を使って加えることによって２倍にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It enables you to represent almost any character from any language in a standardized form, and to read and write those characters to and from an external source such as a text file or web page.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、あなたにほとんどどんな文字でもどんな言語のものでも標準化された方式で表わすこと、そしてそれらの文字を、テキスト・ファイルやウェブ・ページのような外部のソースへ書き込んだり、それらから読み込んだりすることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It evaluates an addition or multiplication by evaluating the expression on the left-hand side, evaluating the expression on the right-hand side, and then adding them or multiplying them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは加算や乗算を、左手側の式を評価し、右手側の式を評価して、それからそれらを加算や乗算することで評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It executes a set of statements only if that condition is &lt;c4&gt;&lt;s5&gt;true&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、その条件が&lt;c4&gt;&lt;s5&gt;true&lt;/s5&gt;&lt;/c4&gt;の場合にだけ、あるひとまとめにした文を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It explicitly converts the count from &lt;c6&gt;&lt;s7&gt;Int&lt;/s7&gt;&lt;/c6&gt; to &lt;c8&gt;&lt;s9&gt;Double&lt;/s9&gt;&lt;/c8&gt; to be able to do floating-point division.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、明示的に総数を&lt;c6&gt;&lt;s7&gt;Int&lt;/s7&gt;&lt;/c6&gt;から&lt;c8&gt;&lt;s9&gt;Double&lt;/s9&gt;&lt;/c8&gt;へ変換して、浮動小数点除算ができるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It has already been initialized with the value contained &lt;e4&gt;within&lt;/e4&gt; the optional, and so there’s no need to use the &lt;c5&gt;&lt;s6&gt;!&lt;/s6&gt;&lt;/c5&gt; suffix to access its value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、すでにオプショナルの&lt;e4&gt;内部に&lt;/e4&gt;含まれる値で初期化されています、それでその値にアクセスするために&lt;c5&gt;&lt;s6&gt;!&lt;/s6&gt;&lt;/c5&gt;接尾辞を使う必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It has one of the following forms:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、以下の書式のうちの１つを持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It has the following forms:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、以下の各形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It illustrates how the designated initializers in this hierarchy act as “funnel” points for class initialization, simplifying the interrelationships among classes in the chain:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、この階層の中の指定イニシャライザが、どのようにクラス初期化のために「漏斗」地点の働きをして、この連鎖におけるクラス間の相互関係を単純化しているかを図示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It introduces an &lt;c6&gt;&lt;s7&gt;Int&lt;/s7&gt;&lt;/c6&gt; property called &lt;c8&gt;&lt;s9&gt;quantity&lt;/s9&gt;&lt;/c8&gt; (in addition to the &lt;c10&gt;&lt;s11&gt;name&lt;/s11&gt;&lt;/c10&gt; property it inherits from &lt;c12&gt;&lt;s13&gt;Food&lt;/s13&gt;&lt;/c12&gt;) and defines two initializers for creating &lt;c14&gt;&lt;s15&gt;RecipeIngredient&lt;/s15&gt;&lt;/c14&gt; instances:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、&lt;c8&gt;&lt;s9&gt;quantity&lt;/s9&gt;&lt;/c8&gt;と呼ばれる&lt;c6&gt;&lt;s7&gt;Int&lt;/s7&gt;&lt;/c6&gt;プロパティ（加えてそれが&lt;c12&gt;&lt;s13&gt;Food&lt;/s13&gt;&lt;/c12&gt;から受け継ぐ&lt;c10&gt;&lt;s11&gt;name&lt;/s11&gt;&lt;/c10&gt;プロパティ）を導入して、そして&lt;c14&gt;&lt;s15&gt;RecipeIngredient&lt;/s15&gt;&lt;/c14&gt;インスタンスをつくるために２つのイニシャライザを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is a single-player game, but can store information for multiple players on a single device.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはシングルプレーヤーのゲームです、しかし１つの装置上で複数のプレーヤーのために情報を蓄えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is always better to be specific about the types you expect to work with in your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いつでもより望ましいのは、あなたのコードで扱うことをあなたが期待する型について明確にすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is always possible to infer the parameter types and return type when passing a closure to a function or method as an inline closure expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャを関数やメソッドに行内クロージャ式として渡すとき、パラメータ型と戻り型を推論することは常に可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is automatically assigned a default value of &lt;c6&gt;&lt;s7&gt;nil&lt;/s7&gt;&lt;/c6&gt;, meaning “no string yet”, when a new instance of &lt;c8&gt;&lt;s9&gt;SurveyQuestion&lt;/s9&gt;&lt;/c8&gt; is initialized.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、&lt;c8&gt;&lt;s9&gt;SurveyQuestion&lt;/s9&gt;&lt;/c8&gt;の新しいインスタンスは初期化される時に、「まだ無い文字列」を意味する、省略時の値の&lt;c6&gt;&lt;s7&gt;nil&lt;/s7&gt;&lt;/c6&gt;を自動的に代入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is explained in detail below in &lt;a0&gt;&lt;s1&gt;Capturing Values&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、下で詳細に&lt;a0&gt;&lt;s1&gt;値を捕獲する（キャプチャする）&lt;/s1&gt;&lt;/a0&gt;の中で説明されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is good practice to create immutable collections in all cases where the collection does not need to change.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのコレクションを変更する必要がないすべての場合において不変のコレクションを作成することは良い習慣です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is implicitly declared simply by its inclusion in the loop declaration, without the need for a &lt;c4&gt;&lt;s5&gt;let&lt;/s5&gt;&lt;/c4&gt; declaration keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはループ宣言にひっくるめることによって、&lt;c4&gt;&lt;s5&gt;let&lt;/s5&gt;&lt;/c4&gt;宣言キーワードの必要なしで、簡易に暗黙のうちに宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is important to consider each operator’s precedence and associativity when working out the order in which a compound expression will be calculated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複合の式が計算される順番を解決するとき、各演算子の優先順位と結合性を考慮することは、重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not appropriate to set &lt;c1&gt;&lt;s2&gt;threeTimesTable[someIndex]&lt;/s2&gt;&lt;/c1&gt; to a new value, and so the subscript for &lt;c3&gt;&lt;s4&gt;TimesTable&lt;/s4&gt;&lt;/c3&gt; is defined as a read-only subscript.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c1&gt;&lt;s2&gt;threeTimesTable[someIndex]&lt;/s2&gt;&lt;/c1&gt;を新しい値に設定することは適切ではありません、なので&lt;c3&gt;&lt;s4&gt;TimesTable&lt;/s4&gt;&lt;/c3&gt;のための添え字は、読み出し専用の添え字として定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not strictly necessary to use the &lt;c0&gt;&lt;s1&gt;gameLoop&lt;/s1&gt;&lt;/c0&gt; label when calling &lt;c2&gt;&lt;s3&gt;continue&lt;/s3&gt; &lt;s4&gt;gameLoop&lt;/s4&gt;&lt;/c2&gt; to jump to the next iteration of the loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ループの次の繰り返しへジャンプするために&lt;c2&gt;&lt;s3&gt;continue&lt;/s3&gt; &lt;s4&gt;gameLoop&lt;/s4&gt;&lt;/c2&gt;を呼ぶとき、&lt;c0&gt;&lt;s1&gt;gameLoop&lt;/s1&gt;&lt;/c0&gt;ラベルを使用することは厳密には必要ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not valid to write the following code, because the first case is empty:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初のケース節が空であるので、以下のコードを書くことは、有効ではありません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is often useful to execute different pieces of code based on certain conditions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特定の状況に基づいて異なるコード小片を実行することは、しばしば役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is possible for a &lt;c0&gt;&lt;s1&gt;DataManager&lt;/s1&gt;&lt;/c0&gt; instance to manage its data without ever importing data from a file, so there is no need to create a new &lt;c2&gt;&lt;s3&gt;DataImporter&lt;/s3&gt;&lt;/c2&gt; instance when the &lt;c4&gt;&lt;s5&gt;DataManager&lt;/s5&gt;&lt;/c4&gt; itself is created.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;DataManager&lt;/s1&gt;&lt;/c0&gt;インスタンスがそれのもつデータを管理することはデータをファイルから一度もインポートしなくとも可能ですので、&lt;c4&gt;&lt;s5&gt;DataManager&lt;/s5&gt;&lt;/c4&gt;自体がつくられるときに、新しい&lt;c2&gt;&lt;s3&gt;DataImporter&lt;/s3&gt;&lt;/c2&gt;インスタンスをつくる必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is sometimes useful to define a class, structure, or enumeration for which initialization can fail.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それに対するイニシャライザが失敗できるクラス、構造体、または列挙を定義することは時として便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is then incremented by &lt;c8&gt;&lt;s9&gt;1&lt;/s9&gt;&lt;/c8&gt; using the overflow addition operator (&lt;c10&gt;&lt;s11&gt;&amp;+&lt;/s11&gt;&lt;/c10&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、それからオーバフロー加算演算子（&lt;c10&gt;&lt;s11&gt;&amp;+&lt;/s11&gt;&lt;/c10&gt;）を使って&lt;c8&gt;&lt;s9&gt;1&lt;/s9&gt;&lt;/c8&gt;だけ増やされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is therefore appropriate to write this initializer as &lt;c2&gt;&lt;s3&gt;init(_&lt;/s3&gt; &lt;s4&gt;celsius:&lt;/s4&gt; &lt;s5&gt;Double)&lt;/s5&gt;&lt;/c2&gt; so that it can be called by providing an unnamed &lt;c6&gt;&lt;s7&gt;Double&lt;/s7&gt;&lt;/c6&gt; value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>したがって、適切なのはこのイニシャライザを&lt;c2&gt;&lt;s3&gt;init(_&lt;/s3&gt; &lt;s4&gt;celsius:&lt;/s4&gt; &lt;s5&gt;Double)&lt;/s5&gt;&lt;/c2&gt;のように書くことであり、それによってそれは名前のない&lt;c6&gt;&lt;s7&gt;Double&lt;/s7&gt;&lt;/c6&gt;値を提供することで呼び出されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It isn’t possible to overload the default assignment operator (&lt;c0&gt;&lt;s1&gt;=&lt;/s1&gt;&lt;/c0&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もとからある代入演算子（&lt;c0&gt;&lt;s1&gt;=&lt;/s1&gt;&lt;/c0&gt;）をオーバーロードすることは不可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It iterates over the items in the container to add them up, and divides by the container’s count to compute the average.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、コンテナの中の項目すべてにわたって繰り返していき、それらを合計します、そしてコンテナの総数で除算することで平均を計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It lets you write the code that’s typically executed without wrapping it in an &lt;c4&gt;&lt;s5&gt;else&lt;/s5&gt;&lt;/c4&gt; block, and it lets you keep the code that handles a violated requirement next to the requirement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはあなたにコードをそれが概ね&lt;c4&gt;&lt;s5&gt;else&lt;/s5&gt;&lt;/c4&gt;ブロックの内にそれを包み込むことなしに実行されるように書かせて、尚且つそれはあなたにコードをそれがある破られた要件から次の要件を取り扱うように保ったままにさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It makes for shorter, clearer initializers and enables you to infer the type of the property from its default value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、より短い、より明白なイニシャライザを作り、あなたにその省略時の値からプロパティの型を推論するのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It may seem an unusual way to represent negative numbers, but it has several advantages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは負数を表す普通でない方法のようかもしれません、しかしそれはいくつかの利点を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It multiplies a starting value of &lt;c4&gt;&lt;s5&gt;1&lt;/s5&gt;&lt;/c4&gt; (that is, &lt;c6&gt;&lt;s7&gt;3&lt;/s7&gt;&lt;/c6&gt; to the power of &lt;c8&gt;&lt;s9&gt;0&lt;/s9&gt;&lt;/c8&gt;) by &lt;c10&gt;&lt;s11&gt;3&lt;/s11&gt;&lt;/c10&gt;, ten times, using a closed range that starts with &lt;c12&gt;&lt;s13&gt;1&lt;/s13&gt;&lt;/c12&gt; and ends with &lt;c14&gt;&lt;s15&gt;10&lt;/s15&gt;&lt;/c14&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは開始値の&lt;c4&gt;&lt;s5&gt;1&lt;/s5&gt;&lt;/c4&gt;（すなわち、&lt;c6&gt;&lt;s7&gt;3&lt;/s7&gt;&lt;/c6&gt;の&lt;c8&gt;&lt;s9&gt;0&lt;/s9&gt;&lt;/c8&gt;乗）に&lt;c10&gt;&lt;s11&gt;3&lt;/s11&gt;&lt;/c10&gt;を掛けることを、10回、&lt;c12&gt;&lt;s13&gt;1&lt;/s13&gt;&lt;/c12&gt;から始まり&lt;c14&gt;&lt;s15&gt;10&lt;/s15&gt;&lt;/c14&gt;で終わる完結範囲を使って行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It must be possible to access a count of the items in the container through a &lt;c0&gt;&lt;s1&gt;count&lt;/s1&gt;&lt;/c0&gt; property that returns an &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt; value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンテナの中の項目の総数にアクセスすることが&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;値を返す&lt;c0&gt;&lt;s1&gt;count&lt;/s1&gt;&lt;/c0&gt;プロパティを通して可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It must be possible to add a new item to the container with an &lt;c0&gt;&lt;s1&gt;append(_:)&lt;/s1&gt;&lt;/c0&gt; method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい項目をコンテナに加えることが&lt;c0&gt;&lt;s1&gt;append(_:)&lt;/s1&gt;&lt;/c0&gt;メソッドで可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It must be possible to retrieve each item in the container with a subscript that takes an &lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt; index value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンテナの中の各項目を取り出すことが&lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt;インデックス値をとる添え字で可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It provides a gettable &lt;c4&gt;&lt;s5&gt;dice&lt;/s5&gt;&lt;/c4&gt; property and a &lt;c6&gt;&lt;s7&gt;play()&lt;/s7&gt;&lt;/c6&gt; method in order to conform to the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、プロトコルに従うために取得可能な&lt;c4&gt;&lt;s5&gt;dice&lt;/s5&gt;&lt;/c4&gt;プロパティと&lt;c6&gt;&lt;s7&gt;play()&lt;/s7&gt;&lt;/c6&gt;メソッドを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It reserves the flexibility to return values of multiple types:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは複数の型の値を返す柔軟性を確保します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It resets a &lt;c4&gt;&lt;s5&gt;numberOfTurns&lt;/s5&gt;&lt;/c4&gt; property to zero when the game starts, increments it each time a new turn begins, and prints out the total number of turns once the game has ended.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、ゲームが始まるとき&lt;c4&gt;&lt;s5&gt;numberOfTurns&lt;/s5&gt;&lt;/c4&gt;プロパティをゼロに再設定します、新しいターンが開始するときそれぞれそれを増加させます、そしてひとたびゲームが終わってしまったならばターンの総数を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns &lt;c4&gt;&lt;s5&gt;true&lt;/s5&gt;&lt;/c4&gt; if the &lt;e6&gt;expression&lt;/e6&gt; can be cast to the specified &lt;e7&gt;type&lt;/e7&gt;; otherwise, it returns &lt;c8&gt;&lt;s9&gt;false&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、&lt;e6&gt;式&lt;/e6&gt;が指定された&lt;e7&gt;型&lt;/e7&gt;へキャストできるならば&lt;c4&gt;&lt;s5&gt;true&lt;/s5&gt;&lt;/c4&gt;を返します；そうでなければ&lt;c8&gt;&lt;s9&gt;false&lt;/s9&gt;&lt;/c8&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns a new number whose bits are set to &lt;c3&gt;&lt;s4&gt;1&lt;/s4&gt;&lt;/c3&gt; only if the bits were equal to &lt;c5&gt;&lt;s6&gt;1&lt;/s6&gt;&lt;/c5&gt; in &lt;e7&gt;both&lt;/e7&gt; input numbers:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはある新しい数を返します、それのビットは&lt;e7&gt;両方の&lt;/e7&gt;入力数においてビットが&lt;c5&gt;&lt;s6&gt;1&lt;/s6&gt;&lt;/c5&gt;と等しかった場合にだけ&lt;c3&gt;&lt;s4&gt;1&lt;/s4&gt;&lt;/c3&gt;に設定されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns an integer value to indicate the actual number of coins that were provided.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、提供されたコインの実際の数を示す整数値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns either the enumeration case matching the raw value or &lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt; if there is no matching &lt;c4&gt;&lt;s5&gt;Rank&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、その生の値に合致する列挙ケース節、または合致する&lt;c4&gt;&lt;s5&gt;Rank&lt;/s5&gt;&lt;/c4&gt;がないならば&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;のどちらかを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It says “I am done with the current loop iteration” without leaving the loop altogether.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、そのループをすっかり止めてしまわずに「私は、現在のループ繰り返しを終えた」と言います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It starts by calculating an appropriate origin point based on a &lt;c4&gt;&lt;s5&gt;center&lt;/s5&gt;&lt;/c4&gt; point and a &lt;c6&gt;&lt;s7&gt;size&lt;/s7&gt;&lt;/c6&gt; value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、&lt;c4&gt;&lt;s5&gt;center&lt;/s5&gt;&lt;/c4&gt;地点と&lt;c6&gt;&lt;s7&gt;size&lt;/s7&gt;&lt;/c6&gt;値に基づいて適切な原点を計算することによって始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It starts with an initial value of &lt;c5&gt;&lt;s6&gt;0&lt;/s6&gt;&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、初期値の&lt;c5&gt;&lt;s6&gt;0&lt;/s6&gt;&lt;/c5&gt;から始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It states that it adopts the &lt;c2&gt;&lt;s3&gt;FullyNamed&lt;/s3&gt;&lt;/c2&gt; protocol as part of the first line of its definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、その定義の最初の行の部分でそれが&lt;c2&gt;&lt;s3&gt;FullyNamed&lt;/s3&gt;&lt;/c2&gt;プロトコルを採用すると述べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It then calls (or &lt;e8&gt;delegates&lt;/e8&gt;) to the &lt;c9&gt;&lt;s10&gt;init(origin:size:)&lt;/s10&gt;&lt;/c9&gt; initializer, which stores the new origin and size values in the appropriate properties:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、それから&lt;c9&gt;&lt;s10&gt;init(origin:size:)&lt;/s10&gt;&lt;/c9&gt;イニシャライザに呼び出し（または&lt;e8&gt;委任&lt;/e8&gt;）をします、それは、新しい原点とサイズ値を適切なプロパティに格納します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It then calls a designated initializer on its superclass to continue the initialization up the chain.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはそれから、連鎖を上って初期化を続けるために、そのスーパークラス上で指定イニシャライザを呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It then continues to repeat the loop until the condition is &lt;c7&gt;&lt;s8&gt;false&lt;/s8&gt;&lt;/c7&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはそれから、条件が&lt;c7&gt;&lt;s8&gt;false&lt;/s8&gt;&lt;/c7&gt;になるまでループを繰り返し続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It then declares a variable called &lt;c0&gt;&lt;s1&gt;cinema&lt;/s1&gt;&lt;/c0&gt; and sets it to the current value of &lt;c2&gt;&lt;s3&gt;hd&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、それから&lt;c0&gt;&lt;s1&gt;cinema&lt;/s1&gt;&lt;/c0&gt;と呼ばれる変数を宣言して、それを&lt;c2&gt;&lt;s3&gt;hd&lt;/s3&gt;&lt;/c2&gt;の現在の値に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It then executes an appropriate block of code, based on the first pattern that matches successfully.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはそれから、うまく合う最初のパターンに基づいて、適切なコードのブロックを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It then iterates through the array of board squares, and appends a geometric shape to represent the contents of each square:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、それからボードの正方形の配列の端から端まで繰り返して、ある幾何学形を各正方形の内容を表わすために追加します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It then uses the &lt;c12&gt;&lt;s13&gt;fallthrough&lt;/s13&gt;&lt;/c12&gt; keyword to “fall into” the &lt;c14&gt;&lt;s15&gt;default&lt;/s15&gt;&lt;/c14&gt; case as well.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはそれから&lt;c12&gt;&lt;s13&gt;fallthrough&lt;/s13&gt;&lt;/c12&gt;キーワードを使って、&lt;c14&gt;&lt;s15&gt;default&lt;/s15&gt;&lt;/c14&gt;ケース節にもまた「落ちていく」ようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It uses an instance property called &lt;c2&gt;&lt;s3&gt;currentLevel&lt;/s3&gt;&lt;/c2&gt; to track the level that a player is currently playing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは&lt;c2&gt;&lt;s3&gt;currentLevel&lt;/s3&gt;&lt;/c2&gt;と呼ばれるインスタンスプロパティをプレーヤーが現在プレイしているレベルを追跡するために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It uses special values for &lt;c8&gt;&lt;s9&gt;jack&lt;/s9&gt;&lt;/c8&gt;, &lt;c10&gt;&lt;s11&gt;queen&lt;/s11&gt;&lt;/c10&gt;, &lt;c12&gt;&lt;s13&gt;king&lt;/s13&gt;&lt;/c12&gt;, and &lt;c14&gt;&lt;s15&gt;ace&lt;/s15&gt;&lt;/c14&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、&lt;c8&gt;&lt;s9&gt;jack&lt;/s9&gt;&lt;/c8&gt;、&lt;c10&gt;&lt;s11&gt;queen&lt;/s11&gt;&lt;/c10&gt;、&lt;c12&gt;&lt;s13&gt;king&lt;/s13&gt;&lt;/c12&gt;、そして&lt;c14&gt;&lt;s15&gt;ace&lt;/s15&gt;&lt;/c14&gt;のために特別な値を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It uses these methods to keep track of the number of turns a game has taken.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、あるゲームがとったターンの数の情報を得続けるためにこれらのメソッドを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It would be much more useful to define a &lt;e4&gt;generic&lt;/e4&gt; &lt;c5&gt;&lt;s6&gt;Stack&lt;/s6&gt;&lt;/c5&gt; class, that can manage a stack of &lt;e7&gt;any&lt;/e7&gt; type of value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それをもっと役に立つようにするには、&lt;e4&gt;総称体&lt;/e4&gt;&lt;c5&gt;&lt;s6&gt;Stack&lt;/s6&gt;&lt;/c5&gt;クラスを定義することです、それは&lt;e7&gt;あらゆる&lt;/e7&gt;型の値のスタックを管理することができるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Iterating Over a Dictionary</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書じゅうを繰り返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Iterating Over a Set</seg>
      </tuv>
      <tuv lang="JA">
        <seg>集合全体を繰り返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Iterating Over an Array</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列じゅうを繰り返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Iterating over Enumeration Cases</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙ケース節の全てにわたって反復する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its combination of safety and speed make Swift an excellent choice for everything from “Hello, world!” to an entire operating system.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その安全とスピードの連携は、スウィフトを「Hello, world!」からオペレーティングシステム全体までのあらゆることに対する素晴らしい選択とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its conciseness can lead to hard-to-read code if overused.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その簡潔さは、濫用されるならば、読み辛いコードに至る可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its keys are of type &lt;c3&gt;&lt;s4&gt;Int&lt;/s4&gt;&lt;/c3&gt;, and its values are of type &lt;c5&gt;&lt;s6&gt;String&lt;/s6&gt;&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのキーは&lt;c3&gt;&lt;s4&gt;Int&lt;/s4&gt;&lt;/c3&gt;型です、そしてその値は&lt;c5&gt;&lt;s6&gt;String&lt;/s6&gt;&lt;/c5&gt;型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its parameters are then implicitly named &lt;c0&gt;&lt;s1&gt;$&lt;/s1&gt;&lt;/c0&gt; followed by their position: &lt;c2&gt;&lt;s3&gt;$0&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;$1&lt;/s5&gt;&lt;/c4&gt;, &lt;c6&gt;&lt;s7&gt;$2&lt;/s7&gt;&lt;/c6&gt;, and so on.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのパラメータは、それから暗黙のうちに&lt;c0&gt;&lt;s1&gt;$&lt;/s1&gt;&lt;/c0&gt;の後にそれらの位置が続く名前：&lt;c2&gt;&lt;s3&gt;$0&lt;/s3&gt;&lt;/c2&gt;、&lt;c4&gt;&lt;s5&gt;$1&lt;/s5&gt;&lt;/c4&gt;、&lt;c6&gt;&lt;s7&gt;$2&lt;/s7&gt;&lt;/c6&gt;、などをつけられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its size is based on a constant called &lt;c2&gt;&lt;s3&gt;finalSquare&lt;/s3&gt;&lt;/c2&gt;, which is used to initialize the array and also to check for a win condition later in the example.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その大きさは&lt;c2&gt;&lt;s3&gt;finalSquare&lt;/s3&gt;&lt;/c2&gt;と呼ばれる定数に基づきます、そして、それがこの配列を初期化して、さらにこの例の後半で勝利したかどうか調べるために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It’s a compile-time error to override a method without the &lt;c2&gt;&lt;s3&gt;override&lt;/s3&gt;&lt;/c2&gt; modifier or to use the &lt;c4&gt;&lt;s5&gt;override&lt;/s5&gt;&lt;/c4&gt; modifier on a method that doesn’t override a superclass method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;override&lt;/s3&gt;&lt;/c2&gt;宣言修飾子なしでメソッドをオーバーライドするか、スーパークラスメソッドをオーバーライドしないメソッドで&lt;c4&gt;&lt;s5&gt;override&lt;/s5&gt;&lt;/c4&gt;宣言修飾子を使用することは、コンパイル時エラーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It’s a compile-time error to write a structure or enumeration definition that tries to adopt &lt;c2&gt;&lt;s3&gt;SomeClassOnlyProtocol&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;SomeClassOnlyProtocol&lt;/s3&gt;&lt;/c2&gt;を採用しようと試みる構造体や列挙定義を書くことは、コンパイル時エラーになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It’s a safe, fast, and interactive programming language that combines the best in modern language thinking with wisdom from the wider Apple engineering culture and the diverse contributions from its open-source community.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、安全で、高速な、そしてインタラクティブなプログラミング言語であり、現代の言語の最良の思想を、幅広いアップル工学文化由来の知的資産およびそのオープンソース・コミュニティからの多様な貢献と結合するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It’s a shortcut for evaluating one of two expressions based on whether &lt;c7&gt;&lt;s8&gt;question&lt;/s8&gt;&lt;/c7&gt; is true or false.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、&lt;c7&gt;&lt;s8&gt;question&lt;/s8&gt;&lt;/c7&gt;が真実であるか間違っているかに基づいて、２つの式のうちの１つを評価することに対する近道です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It’s an industrial-quality programming language that’s as expressive and enjoyable as a scripting language.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、スクリプティング言語と同じくらい表現豊かで楽しい、工業品質のプログラミング言語です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It’s applied to a class to indicate that the class can’t be subclassed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはクラスに適用されて、そのクラスがサブクラスを作られることができないのを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It’s applied to a property, method, or subscript of a class to indicate that a class member can’t be overridden in any subclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはプロパティ、メソッド、またはクラスの添え字に適用されて、そのクラスメンバーがあらゆるサブクラスにおいてオーバーライドされることができないのを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It’s common to &lt;e0&gt;call&lt;/e0&gt; functions that take autoclosures, but it’s not common to &lt;e1&gt;implement&lt;/e1&gt; that kind of function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>自動クロージャを取る関数を&lt;e0&gt;呼び出す&lt;/e0&gt;のは普通です、しかしそのような関数を&lt;e1&gt;実装する&lt;/e1&gt;のは一般的ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It’s convenient for an inventory tracking system to store UPC barcodes as a tuple of four integers, and QR code barcodes as a string of any length.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>UPCバーコードを４つの整数のタプルとして、そしてQRコード・バーコードを任意の長さの文字列として格納できるのは、在庫追跡システムにとって便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It’s either an &lt;c19&gt;&lt;s20&gt;Int&lt;/s20&gt;&lt;/c19&gt;, or it’s nothing at all.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはひとつの&lt;c19&gt;&lt;s20&gt;Int&lt;/s20&gt;&lt;/c19&gt;、またはそれは全く何も無いかのどちらかです。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It’s even valid for a subclass member to call a superclass member that has lower access permissions than the subclass member, as long as the call to the superclass’s member takes place within an allowed access level context (that is, within the same source file as the superclass for a file-private member call, or within the same module as the superclass for an internal member call):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラスのメンバーへの呼び出しがある許されるアクセス水準文脈内で（すなわち、ファイル外非公開メンバー呼び出しのためのスーパークラスと同じソースファイル内で、または内部メンバー呼び出しのためのスーパークラスと同じモジュール内で）起こる限り、サブクラスメンバーより低いアクセス許可を持つスーパークラスメンバーを呼び出すことは、サブクラスメンバーにとってさえ有効です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It’s more useful, and considerably more flexible, to write a single function that swaps two values of &lt;e0&gt;any&lt;/e0&gt; type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらに役に立ち、そしてよりずっと柔軟であるのは、&lt;e0&gt;あらゆる&lt;/e0&gt;型の２つの値を交換できるただ１つの関数を書くことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It’s not of type &lt;c4&gt;&lt;s5&gt;Dice&lt;/s5&gt;&lt;/c4&gt;, or &lt;c6&gt;&lt;s7&gt;DiceGame&lt;/s7&gt;&lt;/c6&gt;, or &lt;c8&gt;&lt;s9&gt;Hamster&lt;/s9&gt;&lt;/c8&gt;, even if the actual instance behind the scenes is of one of those types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは型&lt;c4&gt;&lt;s5&gt;Dice&lt;/s5&gt;&lt;/c4&gt;、または&lt;c6&gt;&lt;s7&gt;DiceGame&lt;/s7&gt;&lt;/c6&gt;、または&lt;c8&gt;&lt;s9&gt;Hamster&lt;/s9&gt;&lt;/c8&gt;ではありません、たとえ舞台裏の実際のインスタンスがそれらの型のうちの１つであるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It’s not valid to mark the definition of &lt;c0&gt;&lt;s1&gt;someFunction()&lt;/s1&gt;&lt;/c0&gt; with the &lt;c2&gt;&lt;s3&gt;public&lt;/s3&gt;&lt;/c2&gt; or &lt;c4&gt;&lt;s5&gt;internal&lt;/s5&gt;&lt;/c4&gt; modifiers, or to use the default setting of internal, because public or internal users of the function might not have appropriate access to the private class used in the function’s return type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;someFunction()&lt;/s1&gt;&lt;/c0&gt;の定義が&lt;c2&gt;&lt;s3&gt;public&lt;/s3&gt;&lt;/c2&gt;または&lt;c4&gt;&lt;s5&gt;internal&lt;/s5&gt;&lt;/c4&gt;を使って印されること、または省略時設定の内部を使うことは有効ではありません、なぜなら、この関数の公開や内部のユーザーは適切なアクセスを関数の戻り型の中で使われる非公開クラスに対して持たないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It’s not valid to write a public property with a private type, for example.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば、非公開の型で公開のプロパティを書くことは、有効ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It’s now possible to iterate over the items in the array, and print each item’s textual description:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>現在この配列の項目の上に繰り返して、各項目のもつ説明テキストを出力することが可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It’s possible that the dice roll may have moved the player beyond square 25, in which case the game is over.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さいころを振ることが正方形25を越えてプレーヤーを動かす可能性はあり得ます、その場合にはゲームは終了です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It’s rare that you need to write type annotations in practice.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが型注釈を書く必要があることは実際問題として、まれです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It’s said to be &lt;e9&gt;half-open&lt;/e9&gt; because it contains its first value, but not its final value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが&lt;e9&gt;半開&lt;/e9&gt;と言われるのは、それがその最初の値を含むけれども、その最後の値は含まないためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It’s set to be interlaced, its name is set to &lt;c8&gt;&lt;s9&gt;"1080i"&lt;/s9&gt;&lt;/c8&gt;, and its frame rate is set to &lt;c10&gt;&lt;s11&gt;25.0&lt;/s11&gt;&lt;/c10&gt; frames per second.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それはインターレースされるように設定されます、それの名前は&lt;c8&gt;&lt;s9&gt;"1080i"&lt;/s9&gt;&lt;/c8&gt;に設定されます、そしてそれのフレームレートは&lt;c10&gt;&lt;s11&gt;25.0&lt;/s11&gt;&lt;/c10&gt;フレーム毎秒に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It’s sometimes necessary for a method to modify (or &lt;e0&gt;mutate&lt;/e0&gt;) the instance it belongs to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッドがそれが属しているインスタンスを修正する（または&lt;e0&gt;変化させる&lt;/e0&gt;）ことは、時々必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It’s sometimes useful to include parentheses when they’re not strictly needed, to make the intention of a complex expression easier to read.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複雑な式をより簡単に読めるようにするため、丸括弧をそれらが厳密には必要とされないとき含むことは、時々役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It’s the &lt;c22&gt;&lt;s23&gt;frameRate&lt;/s23&gt;&lt;/c22&gt; property of the underlying &lt;c24&gt;&lt;s25&gt;VideoMode&lt;/s25&gt;&lt;/c24&gt; that is changed, not the values of the constant references to that &lt;c26&gt;&lt;s27&gt;VideoMode&lt;/s27&gt;&lt;/c26&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、根底にある&lt;c24&gt;&lt;s25&gt;VideoMode&lt;/s25&gt;&lt;/c24&gt;の&lt;c22&gt;&lt;s23&gt;frameRate&lt;/s23&gt;&lt;/c22&gt;プロパティです、それは変更可能です、その&lt;c26&gt;&lt;s27&gt;VideoMode&lt;/s27&gt;&lt;/c26&gt;に対する参照をもつこれら定数の値ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just before this happens, its deinitializer is called automatically, and its coins are returned to the bank.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これが起こる直前に、そのデイニシャライザは自動的に呼ばれます、そしてそのコインは胴元に返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just like functions and methods, initializers can throw or rethrow errors.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数やメソッドのように、イニシャライザはエラーをスローまたは再スローできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just like when you include a value on both sides, the final value isn’t part of the range.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ちょうどあなたが両方の側で１つの値を含める場合のように、最後の値はその範囲の一部分ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keeping the sign bit the same during this shift means that negative integers remain negative as their value moves closer to zero.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このシフトの間に符号ビットを同じに保つことは、それの値がゼロの近くに動くとき、負整数が負のままであることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Key-Path Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キーパス式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Key-Path String Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キーパス文字列式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keywords and Punctuation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キーワードと句読点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keywords other than &lt;c2&gt;&lt;s3&gt;inout&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;var&lt;/s5&gt;&lt;/c4&gt;, and &lt;c6&gt;&lt;s7&gt;let&lt;/s7&gt;&lt;/c6&gt; can be used as parameter names in a function declaration or function call without being escaped with backticks.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;inout&lt;/s3&gt;&lt;/c2&gt;、&lt;c4&gt;&lt;s5&gt;var&lt;/s5&gt;&lt;/c4&gt;、そして&lt;c6&gt;&lt;s7&gt;let&lt;/s7&gt;&lt;/c6&gt;以外のキーワードは、パラメータ名として関数宣言または関数呼び出しにおいてバッククォートでエスケープされることなく使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keywords reserved in particular contexts: &lt;c0&gt;&lt;s1&gt;associativity&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;convenience&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;dynamic&lt;/s5&gt;&lt;/c4&gt;, &lt;c6&gt;&lt;s7&gt;didSet&lt;/s7&gt;&lt;/c6&gt;, &lt;c8&gt;&lt;s9&gt;final&lt;/s9&gt;&lt;/c8&gt;, &lt;c10&gt;&lt;s11&gt;get&lt;/s11&gt;&lt;/c10&gt;, &lt;c12&gt;&lt;s13&gt;infix&lt;/s13&gt;&lt;/c12&gt;, &lt;c14&gt;&lt;s15&gt;indirect&lt;/s15&gt;&lt;/c14&gt;, &lt;c16&gt;&lt;s17&gt;lazy&lt;/s17&gt;&lt;/c16&gt;, &lt;c18&gt;&lt;s19&gt;left&lt;/s19&gt;&lt;/c18&gt;, &lt;c20&gt;&lt;s21&gt;mutating&lt;/s21&gt;&lt;/c20&gt;, &lt;c22&gt;&lt;s23&gt;none&lt;/s23&gt;&lt;/c22&gt;, &lt;c24&gt;&lt;s25&gt;nonmutating&lt;/s25&gt;&lt;/c24&gt;, &lt;c26&gt;&lt;s27&gt;optional&lt;/s27&gt;&lt;/c26&gt;, &lt;c28&gt;&lt;s29&gt;override&lt;/s29&gt;&lt;/c28&gt;, &lt;c30&gt;&lt;s31&gt;postfix&lt;/s31&gt;&lt;/c30&gt;, &lt;c32&gt;&lt;s33&gt;precedence&lt;/s33&gt;&lt;/c32&gt;, &lt;c34&gt;&lt;s35&gt;prefix&lt;/s35&gt;&lt;/c34&gt;, &lt;c36&gt;&lt;s37&gt;Protocol&lt;/s37&gt;&lt;/c36&gt;, &lt;c38&gt;&lt;s39&gt;required&lt;/s39&gt;&lt;/c38&gt;, &lt;c40&gt;&lt;s41&gt;right&lt;/s41&gt;&lt;/c40&gt;, &lt;c42&gt;&lt;s43&gt;set&lt;/s43&gt;&lt;/c42&gt;, &lt;c44&gt;&lt;s45&gt;Type&lt;/s45&gt;&lt;/c44&gt;, &lt;c46&gt;&lt;s47&gt;unowned&lt;/s47&gt;&lt;/c46&gt;, &lt;c48&gt;&lt;s49&gt;weak&lt;/s49&gt;&lt;/c48&gt;, and &lt;c50&gt;&lt;s51&gt;willSet&lt;/s51&gt;&lt;/c50&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特定の前後関係において予約されるキーワード：&lt;c0&gt;&lt;s1&gt;associativity&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;convenience&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;dynamic&lt;/s5&gt;&lt;/c4&gt;, &lt;c6&gt;&lt;s7&gt;didSet&lt;/s7&gt;&lt;/c6&gt;, &lt;c8&gt;&lt;s9&gt;final&lt;/s9&gt;&lt;/c8&gt;, &lt;c10&gt;&lt;s11&gt;get&lt;/s11&gt;&lt;/c10&gt;, &lt;c12&gt;&lt;s13&gt;infix&lt;/s13&gt;&lt;/c12&gt;, &lt;c14&gt;&lt;s15&gt;indirect&lt;/s15&gt;&lt;/c14&gt;, &lt;c16&gt;&lt;s17&gt;lazy&lt;/s17&gt;&lt;/c16&gt;, &lt;c18&gt;&lt;s19&gt;left&lt;/s19&gt;&lt;/c18&gt;, &lt;c20&gt;&lt;s21&gt;mutating&lt;/s21&gt;&lt;/c20&gt;, &lt;c22&gt;&lt;s23&gt;none&lt;/s23&gt;&lt;/c22&gt;, &lt;c24&gt;&lt;s25&gt;nonmutating&lt;/s25&gt;&lt;/c24&gt;, &lt;c26&gt;&lt;s27&gt;optional&lt;/s27&gt;&lt;/c26&gt;, &lt;c28&gt;&lt;s29&gt;override&lt;/s29&gt;&lt;/c28&gt;, &lt;c30&gt;&lt;s31&gt;postfix&lt;/s31&gt;&lt;/c30&gt;, &lt;c32&gt;&lt;s33&gt;precedence&lt;/s33&gt;&lt;/c32&gt;, &lt;c34&gt;&lt;s35&gt;prefix&lt;/s35&gt;&lt;/c34&gt;, &lt;c36&gt;&lt;s37&gt;Protocol&lt;/s37&gt;&lt;/c36&gt;, &lt;c38&gt;&lt;s39&gt;required&lt;/s39&gt;&lt;/c38&gt;, &lt;c40&gt;&lt;s41&gt;right&lt;/s41&gt;&lt;/c40&gt;, &lt;c42&gt;&lt;s43&gt;set&lt;/s43&gt;&lt;/c42&gt;, &lt;c44&gt;&lt;s45&gt;Type&lt;/s45&gt;&lt;/c44&gt;, &lt;c46&gt;&lt;s47&gt;unowned&lt;/s47&gt;&lt;/c46&gt;, &lt;c48&gt;&lt;s49&gt;weak&lt;/s49&gt;&lt;/c48&gt;, そして&lt;c50&gt;&lt;s51&gt;willSet&lt;/s51&gt;&lt;/c50&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keywords that begin with a number sign (&lt;c0&gt;&lt;s1&gt;#&lt;/s1&gt;&lt;/c0&gt;): &lt;c2&gt;&lt;s3&gt;#available&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;#colorLiteral&lt;/s5&gt;&lt;/c4&gt;, &lt;c6&gt;&lt;s7&gt;#column&lt;/s7&gt;&lt;/c6&gt;, &lt;c8&gt;&lt;s9&gt;#else&lt;/s9&gt;&lt;/c8&gt;, &lt;c10&gt;&lt;s11&gt;#elseif&lt;/s11&gt;&lt;/c10&gt;, &lt;c12&gt;&lt;s13&gt;#endif&lt;/s13&gt;&lt;/c12&gt;, &lt;c14&gt;&lt;s15&gt;#error&lt;/s15&gt;&lt;/c14&gt;, &lt;c16&gt;&lt;s17&gt;#file&lt;/s17&gt;&lt;/c16&gt;, &lt;c18&gt;&lt;s19&gt;#fileLiteral&lt;/s19&gt;&lt;/c18&gt;, &lt;c20&gt;&lt;s21&gt;#function&lt;/s21&gt;&lt;/c20&gt;, &lt;c22&gt;&lt;s23&gt;#if&lt;/s23&gt;&lt;/c22&gt;, &lt;c24&gt;&lt;s25&gt;#imageLiteral&lt;/s25&gt;&lt;/c24&gt;, &lt;c26&gt;&lt;s27&gt;#line&lt;/s27&gt;&lt;/c26&gt;, &lt;c28&gt;&lt;s29&gt;#selector&lt;/s29&gt;&lt;/c28&gt;, &lt;c30&gt;&lt;s31&gt;#sourceLocation&lt;/s31&gt;&lt;/c30&gt;, and &lt;c32&gt;&lt;s33&gt;#warning&lt;/s33&gt;&lt;/c32&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シャープ記号（&lt;c0&gt;&lt;s1&gt;#&lt;/s1&gt;&lt;/c0&gt;）で始まるキーワード：&lt;c2&gt;&lt;s3&gt;#available&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;#colorLiteral&lt;/s5&gt;&lt;/c4&gt;, &lt;c6&gt;&lt;s7&gt;#column&lt;/s7&gt;&lt;/c6&gt;, &lt;c8&gt;&lt;s9&gt;#else&lt;/s9&gt;&lt;/c8&gt;, &lt;c10&gt;&lt;s11&gt;#elseif&lt;/s11&gt;&lt;/c10&gt;, &lt;c12&gt;&lt;s13&gt;#endif&lt;/s13&gt;&lt;/c12&gt;, &lt;c14&gt;&lt;s15&gt;#error&lt;/s15&gt;&lt;/c14&gt;, &lt;c16&gt;&lt;s17&gt;#file&lt;/s17&gt;&lt;/c16&gt;, &lt;c18&gt;&lt;s19&gt;#fileLiteral&lt;/s19&gt;&lt;/c18&gt;, &lt;c20&gt;&lt;s21&gt;#function&lt;/s21&gt;&lt;/c20&gt;, &lt;c22&gt;&lt;s23&gt;#if&lt;/s23&gt;&lt;/c22&gt;, &lt;c24&gt;&lt;s25&gt;#imageLiteral&lt;/s25&gt;&lt;/c24&gt;, &lt;c26&gt;&lt;s27&gt;#line&lt;/s27&gt;&lt;/c26&gt;, &lt;c28&gt;&lt;s29&gt;#selector&lt;/s29&gt;&lt;/c28&gt;, &lt;c30&gt;&lt;s31&gt;#sourceLocation&lt;/s31&gt;&lt;/c30&gt;, そして &lt;c32&gt;&lt;s33&gt;#warning&lt;/s33&gt;&lt;/c32&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keywords used in declarations: &lt;c0&gt;&lt;s1&gt;associatedtype&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;class&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;deinit&lt;/s5&gt;&lt;/c4&gt;, &lt;c6&gt;&lt;s7&gt;enum&lt;/s7&gt;&lt;/c6&gt;, &lt;c8&gt;&lt;s9&gt;extension&lt;/s9&gt;&lt;/c8&gt;, &lt;c10&gt;&lt;s11&gt;fileprivate&lt;/s11&gt;&lt;/c10&gt;, &lt;c12&gt;&lt;s13&gt;func&lt;/s13&gt;&lt;/c12&gt;, &lt;c14&gt;&lt;s15&gt;import&lt;/s15&gt;&lt;/c14&gt;, &lt;c16&gt;&lt;s17&gt;init&lt;/s17&gt;&lt;/c16&gt;, &lt;c18&gt;&lt;s19&gt;inout&lt;/s19&gt;&lt;/c18&gt;, &lt;c20&gt;&lt;s21&gt;internal&lt;/s21&gt;&lt;/c20&gt;, &lt;c22&gt;&lt;s23&gt;let&lt;/s23&gt;&lt;/c22&gt;, &lt;c24&gt;&lt;s25&gt;open&lt;/s25&gt;&lt;/c24&gt;, &lt;c26&gt;&lt;s27&gt;operator&lt;/s27&gt;&lt;/c26&gt;, &lt;c28&gt;&lt;s29&gt;private&lt;/s29&gt;&lt;/c28&gt;, &lt;c30&gt;&lt;s31&gt;protocol&lt;/s31&gt;&lt;/c30&gt;, &lt;c32&gt;&lt;s33&gt;public&lt;/s33&gt;&lt;/c32&gt;, &lt;c34&gt;&lt;s35&gt;rethrows&lt;/s35&gt;&lt;/c34&gt;, &lt;c36&gt;&lt;s37&gt;static&lt;/s37&gt;&lt;/c36&gt;, &lt;c38&gt;&lt;s39&gt;struct&lt;/s39&gt;&lt;/c38&gt;, &lt;c40&gt;&lt;s41&gt;subscript&lt;/s41&gt;&lt;/c40&gt;, &lt;c42&gt;&lt;s43&gt;typealias&lt;/s43&gt;&lt;/c42&gt;, and &lt;c44&gt;&lt;s45&gt;var&lt;/s45&gt;&lt;/c44&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言において使用されるキーワード：&lt;c0&gt;&lt;s1&gt;associatedtype&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;class&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;deinit&lt;/s5&gt;&lt;/c4&gt;, &lt;c6&gt;&lt;s7&gt;enum&lt;/s7&gt;&lt;/c6&gt;, &lt;c8&gt;&lt;s9&gt;extension&lt;/s9&gt;&lt;/c8&gt;, &lt;c10&gt;&lt;s11&gt;fileprivate&lt;/s11&gt;&lt;/c10&gt;, &lt;c12&gt;&lt;s13&gt;func&lt;/s13&gt;&lt;/c12&gt;, &lt;c14&gt;&lt;s15&gt;import&lt;/s15&gt;&lt;/c14&gt;, &lt;c16&gt;&lt;s17&gt;init&lt;/s17&gt;&lt;/c16&gt;, &lt;c18&gt;&lt;s19&gt;inout&lt;/s19&gt;&lt;/c18&gt;, &lt;c20&gt;&lt;s21&gt;internal&lt;/s21&gt;&lt;/c20&gt;, &lt;c22&gt;&lt;s23&gt;let&lt;/s23&gt;&lt;/c22&gt;, &lt;c24&gt;&lt;s25&gt;open&lt;/s25&gt;&lt;/c24&gt;, &lt;c26&gt;&lt;s27&gt;operator&lt;/s27&gt;&lt;/c26&gt;, &lt;c28&gt;&lt;s29&gt;private&lt;/s29&gt;&lt;/c28&gt;, &lt;c30&gt;&lt;s31&gt;protocol&lt;/s31&gt;&lt;/c30&gt;, &lt;c32&gt;&lt;s33&gt;public&lt;/s33&gt;&lt;/c32&gt;, &lt;c34&gt;&lt;s35&gt;rethrows&lt;/s35&gt;&lt;/c34&gt;, &lt;c36&gt;&lt;s37&gt;static&lt;/s37&gt;&lt;/c36&gt;, &lt;c38&gt;&lt;s39&gt;struct&lt;/s39&gt;&lt;/c38&gt;, &lt;c40&gt;&lt;s41&gt;subscript&lt;/s41&gt;&lt;/c40&gt;, &lt;c42&gt;&lt;s43&gt;typealias&lt;/s43&gt;&lt;/c42&gt;, そして&lt;c44&gt;&lt;s45&gt;var&lt;/s45&gt;&lt;/c44&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keywords used in expressions and types: &lt;c0&gt;&lt;s1&gt;as&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;Any&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;catch&lt;/s5&gt;&lt;/c4&gt;, &lt;c6&gt;&lt;s7&gt;false&lt;/s7&gt;&lt;/c6&gt;, &lt;c8&gt;&lt;s9&gt;is&lt;/s9&gt;&lt;/c8&gt;, &lt;c10&gt;&lt;s11&gt;nil&lt;/s11&gt;&lt;/c10&gt;, &lt;c12&gt;&lt;s13&gt;super&lt;/s13&gt;&lt;/c12&gt;, &lt;c14&gt;&lt;s15&gt;self&lt;/s15&gt;&lt;/c14&gt;, &lt;c16&gt;&lt;s17&gt;Self&lt;/s17&gt;&lt;/c16&gt;, &lt;c18&gt;&lt;s19&gt;throw&lt;/s19&gt;&lt;/c18&gt;, &lt;c20&gt;&lt;s21&gt;throws&lt;/s21&gt;&lt;/c20&gt;, &lt;c22&gt;&lt;s23&gt;true&lt;/s23&gt;&lt;/c22&gt;, and &lt;c24&gt;&lt;s25&gt;try&lt;/s25&gt;&lt;/c24&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>式と型において使用されるキーワード：&lt;c0&gt;&lt;s1&gt;as&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;Any&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;catch&lt;/s5&gt;&lt;/c4&gt;, &lt;c6&gt;&lt;s7&gt;false&lt;/s7&gt;&lt;/c6&gt;, &lt;c8&gt;&lt;s9&gt;is&lt;/s9&gt;&lt;/c8&gt;, &lt;c10&gt;&lt;s11&gt;nil&lt;/s11&gt;&lt;/c10&gt;, &lt;c12&gt;&lt;s13&gt;super&lt;/s13&gt;&lt;/c12&gt;, &lt;c14&gt;&lt;s15&gt;self&lt;/s15&gt;&lt;/c14&gt;, &lt;c16&gt;&lt;s17&gt;Self&lt;/s17&gt;&lt;/c16&gt;, &lt;c18&gt;&lt;s19&gt;throw&lt;/s19&gt;&lt;/c18&gt;, &lt;c20&gt;&lt;s21&gt;throws&lt;/s21&gt;&lt;/c20&gt;, &lt;c22&gt;&lt;s23&gt;true&lt;/s23&gt;&lt;/c22&gt;, そして&lt;c24&gt;&lt;s25&gt;try&lt;/s25&gt;&lt;/c24&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keywords used in patterns: &lt;c0&gt;&lt;s1&gt;_&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パターンにおいて使用されるキーワード：&lt;c0&gt;&lt;s1&gt;_&lt;/s1&gt;&lt;/c0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keywords used in statements: &lt;c0&gt;&lt;s1&gt;break&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;case&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;continue&lt;/s5&gt;&lt;/c4&gt;, &lt;c6&gt;&lt;s7&gt;default&lt;/s7&gt;&lt;/c6&gt;, &lt;c8&gt;&lt;s9&gt;defer&lt;/s9&gt;&lt;/c8&gt;, &lt;c10&gt;&lt;s11&gt;do&lt;/s11&gt;&lt;/c10&gt;, &lt;c12&gt;&lt;s13&gt;else&lt;/s13&gt;&lt;/c12&gt;, &lt;c14&gt;&lt;s15&gt;fallthrough&lt;/s15&gt;&lt;/c14&gt;, &lt;c16&gt;&lt;s17&gt;for&lt;/s17&gt;&lt;/c16&gt;, &lt;c18&gt;&lt;s19&gt;guard&lt;/s19&gt;&lt;/c18&gt;, &lt;c20&gt;&lt;s21&gt;if&lt;/s21&gt;&lt;/c20&gt;, &lt;c22&gt;&lt;s23&gt;in&lt;/s23&gt;&lt;/c22&gt;, &lt;c24&gt;&lt;s25&gt;repeat&lt;/s25&gt;&lt;/c24&gt;, &lt;c26&gt;&lt;s27&gt;return&lt;/s27&gt;&lt;/c26&gt;, &lt;c28&gt;&lt;s29&gt;switch&lt;/s29&gt;&lt;/c28&gt;, &lt;c30&gt;&lt;s31&gt;where&lt;/s31&gt;&lt;/c30&gt;, and &lt;c32&gt;&lt;s33&gt;while&lt;/s33&gt;&lt;/c32&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文において使用されるキーワード：&lt;c0&gt;&lt;s1&gt;break&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;case&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;continue&lt;/s5&gt;&lt;/c4&gt;, &lt;c6&gt;&lt;s7&gt;default&lt;/s7&gt;&lt;/c6&gt;, &lt;c8&gt;&lt;s9&gt;defer&lt;/s9&gt;&lt;/c8&gt;, &lt;c10&gt;&lt;s11&gt;do&lt;/s11&gt;&lt;/c10&gt;, &lt;c12&gt;&lt;s13&gt;else&lt;/s13&gt;&lt;/c12&gt;, &lt;c14&gt;&lt;s15&gt;fallthrough&lt;/s15&gt;&lt;/c14&gt;, &lt;c16&gt;&lt;s17&gt;for&lt;/s17&gt;&lt;/c16&gt;, &lt;c18&gt;&lt;s19&gt;guard&lt;/s19&gt;&lt;/c18&gt;, &lt;c20&gt;&lt;s21&gt;if&lt;/s21&gt;&lt;/c20&gt;, &lt;c22&gt;&lt;s23&gt;in&lt;/s23&gt;&lt;/c22&gt;, &lt;c24&gt;&lt;s25&gt;repeat&lt;/s25&gt;&lt;/c24&gt;, &lt;c26&gt;&lt;s27&gt;return&lt;/s27&gt;&lt;/c26&gt;, &lt;c28&gt;&lt;s29&gt;switch&lt;/s29&gt;&lt;/c28&gt;, &lt;c30&gt;&lt;s31&gt;where&lt;/s31&gt;&lt;/c30&gt;, そして&lt;c32&gt;&lt;s33&gt;while&lt;/s33&gt;&lt;/c32&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Labeled Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ラベルをつけられた文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Labeled Statements</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ラベルをつけられた文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Language Guide</seg>
      </tuv>
      <tuv lang="JA">
        <seg>言語ガイド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Language Reference</seg>
      </tuv>
      <tuv lang="JA">
        <seg>言語リファレンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Large integer literal initialization expressions are inferred to be of the correct integer type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>大きな整数リテラル初期化式は、正しい整数型のものであるように推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lazy Stored Properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>遅延格納プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lazy properties are also useful when the initial value for a property requires complex or computationally expensive setup that should not be performed unless or until it is needed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>遅延プロパティはまた、プロパティのための最初の値が、それが必要でないなら、あるいは必要になるまで、実行されるべきではない複雑なまたはコンピュータ処理的に高くつく準備を必要とするときに役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lazy properties are useful when the initial value for a property is dependent on outside factors whose values are not known until after an instance’s initialization is complete.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>遅延プロパティが役に立つのは、プロパティのための最初の値がインスタンスの初期化が終了する後まで値が知られない外部の要因に依存しているときです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Less than (&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt; &lt;s2&gt;&lt;&lt;/s2&gt; &lt;s3&gt;b&lt;/s3&gt;&lt;/c0&gt;)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より小さい、未満 (&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt; &lt;s2&gt;&lt;&lt;/s2&gt; &lt;s3&gt;b&lt;/s3&gt;&lt;/c0&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Less than or equal to (&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt; &lt;s2&gt;&lt;=&lt;/s2&gt; &lt;s3&gt;b&lt;/s3&gt;&lt;/c0&gt;)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より小さいか等しい、以下 (&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt; &lt;s2&gt;&lt;=&lt;/s2&gt; &lt;s3&gt;b&lt;/s3&gt;&lt;/c0&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lexical Structure</seg>
      </tuv>
      <tuv lang="JA">
        <seg>語彙の構造</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like C, Swift has only one ternary operator, the ternary conditional operator (&lt;c1&gt;&lt;s2&gt;a&lt;/s2&gt; &lt;s3&gt;?&lt;/s3&gt; &lt;s4&gt;b&lt;/s4&gt; &lt;s5&gt;:&lt;/s5&gt; &lt;s6&gt;c&lt;/s6&gt;&lt;/c1&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Cのように、スウィフトはただ１つの三項演算子、三項条件演算子（&lt;c1&gt;&lt;s2&gt;a&lt;/s2&gt; &lt;s3&gt;?&lt;/s3&gt; &lt;s4&gt;b&lt;/s4&gt; &lt;s5&gt;:&lt;/s5&gt; &lt;s6&gt;c&lt;/s6&gt;&lt;/c1&gt;）だけをもちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like C, Swift provides &lt;e0&gt;compound assignment operators&lt;/e0&gt; that combine assignment (&lt;c1&gt;&lt;s2&gt;=&lt;/s2&gt;&lt;/c1&gt;) with another operation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Cのように、スウィフトは&lt;e0&gt;複合代入演算子&lt;/e0&gt;を提供します、それは、代入（&lt;c1&gt;&lt;s2&gt;=&lt;/s2&gt;&lt;/c1&gt;）を別の演算と組み合わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like C, Swift uses variables to store and refer to values by an identifying name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Cのように、スウィフトはひとつの識別名によっていろいろな値を保管したり引用したりするために、変数を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like a &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; statement, the compiler attempts to infer whether &lt;c2&gt;&lt;s3&gt;catch&lt;/s3&gt;&lt;/c2&gt; clauses are exhaustive.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;文のように、コンパイラは&lt;c2&gt;&lt;s3&gt;catch&lt;/s3&gt;&lt;/c2&gt;節が網羅的であるか推論を試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like a function declaration, a closure contains statements, and it captures constants and variables from its enclosing scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数宣言の様に、クロージャはいくつかの文を含みます、そしてそれは、定数と変数をそれの取り囲むスコープからキャプチャします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like a function, an initializer can be used as a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数のように、イニシャライザは値として使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like a weak reference, an &lt;e0&gt;unowned reference&lt;/e0&gt; does not keep a strong hold on the instance it refers to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>弱い参照のように、&lt;e0&gt;非所有参照&lt;/e0&gt;は、それが言及するインスタンスに対する強い支配力を保ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like a weak reference, the type of the property or value must be a class type; unlike a weak reference, the type is non-optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>弱い参照のように、プロパティや値の型はクラス型でなければなりません；弱い参照と違って、その型は非オプショナルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like all types in Swift, these integer types have capitalized names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおける全ての型のように、これらの整数型は頭文字を使った名前を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like classes and all other named types, enumerations can have methods associated with them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスや全ての他の名前をつけられた型のように、列挙はそれと結びつけられるメソッドを持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like functions, subscripts can take a varying number of parameters and provide default values for their parameters, as discussed in &lt;a0&gt;&lt;s1&gt;Variadic Parameters&lt;/s1&gt;&lt;/a0&gt; and &lt;a2&gt;&lt;s3&gt;Default Parameter Values&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数のように、添え字は可変数のパラメータを取りそしてそれらのパラメータに対して省略時の値を提供できます、&lt;a0&gt;&lt;s1&gt;可変長パラメータ&lt;/s1&gt;&lt;/a0&gt;および&lt;a2&gt;&lt;s3&gt;省略時のパラメータ値&lt;/s3&gt;&lt;/a2&gt;で議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like other types in Swift, their names (such as &lt;c0&gt;&lt;s1&gt;CompassPoint&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;Planet&lt;/s3&gt;&lt;/c2&gt;) start with a capital letter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおける他の型のように、それらの名前（例えば&lt;c0&gt;&lt;s1&gt;CompassPoint&lt;/s1&gt;&lt;/c0&gt;および&lt;c2&gt;&lt;s3&gt;Planet&lt;/s3&gt;&lt;/c2&gt;）は、大文字から始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like strings, each substring has a region of memory where the characters that make up the substring are stored.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列のように、下位文字列それぞれはメモリのある領域を持ち、そこで下位文字列を作り上げる文字が格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like structures but unlike classes, enumerations are value types; instances of an enumeration are copied when assigned to variables or constants, or when passed as arguments to a function call.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体のように、しかしクラスとは違い、列挙は値型です；列挙のインスタンスは、変数や定数に代入されるとき、または関数呼び出しに引数として渡されるときにコピーされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like the &lt;c0&gt;&lt;s1&gt;public&lt;/s1&gt;&lt;/c0&gt; access level modifier, this attribute exposes the declaration as part of the module’s public interface.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;public&lt;/s1&gt;&lt;/c0&gt;アクセス水準修飾子のように、この属性は宣言をモジュールの公開インターフェイスの一部として露出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like the &lt;c6&gt;&lt;s7&gt;remove(at:)&lt;/s7&gt;&lt;/c6&gt; method, &lt;c8&gt;&lt;s9&gt;removeLast()&lt;/s9&gt;&lt;/c8&gt; returns the removed item:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;removeAtIndex(_:)&lt;/s7&gt;&lt;/c6&gt;メソッドのように、&lt;c8&gt;&lt;s9&gt;remove(at:)&lt;/s9&gt;&lt;/c8&gt;は取り除かれた項目を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like the Logical AND operator above, the Logical OR operator uses short-circuit evaluation to consider its expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の論理積演算子のように、論理和演算子はその式を考慮するために短絡評価を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like the body of an &lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt; statement, each &lt;c2&gt;&lt;s3&gt;case&lt;/s3&gt;&lt;/c2&gt; is a separate branch of code execution.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt;文の本文のように、各&lt;c2&gt;&lt;s3&gt;case&lt;/s3&gt;&lt;/c2&gt;は別々の分岐のコード実行です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Like the subscript examples above, the &lt;c2&gt;&lt;s3&gt;updateValue(_:forKey:)&lt;/s3&gt;&lt;/c2&gt; method sets a value for a key if none exists, or updates the value if that key already exists.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の添え字の例のように、&lt;c2&gt;&lt;s3&gt;updateValue(_:forKey:)&lt;/s3&gt;&lt;/c2&gt;メソッドは、まったく何も存在しないならばあるキーに対して値を設定します、またはキーがすでに存在するならばその値を更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, because &lt;c15&gt;&lt;s16&gt;Void&lt;/s16&gt;&lt;/c15&gt; is a type alias for &lt;c17&gt;&lt;s18&gt;()&lt;/s18&gt;&lt;/c17&gt;, the function type &lt;c19&gt;&lt;s20&gt;(Void)&lt;/s20&gt; &lt;s21&gt;-&gt;&lt;/s21&gt; &lt;s22&gt;Void&lt;/s22&gt;&lt;/c19&gt; is the same as &lt;c23&gt;&lt;s24&gt;(())&lt;/s24&gt; &lt;s25&gt;-&gt;&lt;/s25&gt; &lt;s26&gt;()&lt;/s26&gt;&lt;/c23&gt;—a function that takes a single argument that is an empty tuple.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に、&lt;c15&gt;&lt;s16&gt;Void&lt;/s16&gt;&lt;/c15&gt;が&lt;c17&gt;&lt;s18&gt;()&lt;/s18&gt;&lt;/c17&gt;に対する型エイリアスであることから、関数型&lt;c19&gt;&lt;s20&gt;(Void)&lt;/s20&gt; &lt;s21&gt;-&gt;&lt;/s21&gt; &lt;s22&gt;Void&lt;/s22&gt;&lt;/c19&gt;は&lt;c23&gt;&lt;s24&gt;(())&lt;/s24&gt; &lt;s25&gt;-&gt;&lt;/s25&gt; &lt;s26&gt;()&lt;/s26&gt;&lt;/c23&gt; — ただ１つの引数を取りそれが空のタプルである関数、と同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, if any of the structure’s stored properties are file private, the initializer is file private.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に、構造体の持つ格納プロパティのいずれかがファイル外非公開ならば、イニシャライザはファイル外非公開です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, if you don’t specify a type for a floating-point literal, Swift infers that you want to create a &lt;c0&gt;&lt;s1&gt;Double&lt;/s1&gt;&lt;/c0&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に、あなたがある浮動小数点リテラルのために型を指定しないならば、スウィフトはあなたが&lt;c0&gt;&lt;s1&gt;Double&lt;/s1&gt;&lt;/c0&gt;をつくりたいと推測します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, if you made a subclass of &lt;c8&gt;&lt;s9&gt;Location&lt;/s9&gt;&lt;/c8&gt; that didn’t conform to the &lt;c10&gt;&lt;s11&gt;Named&lt;/s11&gt;&lt;/c10&gt; protocol, calling &lt;c12&gt;&lt;s13&gt;beginConcert(in:)&lt;/s13&gt;&lt;/c12&gt; with an instance of that type is also invalid.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に、あなたが&lt;c8&gt;&lt;s9&gt;Location&lt;/s9&gt;&lt;/c8&gt;のサブクラスで&lt;c10&gt;&lt;s11&gt;Named&lt;/s11&gt;&lt;/c10&gt;プロトコルに準拠しないものを作成したならば、&lt;c12&gt;&lt;s13&gt;beginConcert(in:)&lt;/s13&gt;&lt;/c12&gt;をその型のインスタンスで呼び出すことはまた無効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, method and function declarations are written the same way.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらにまた、メソッドおよび関数の宣言も同じやり方で書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, the &lt;c4&gt;&lt;s5&gt;willSet&lt;/s5&gt;&lt;/c4&gt; clause is optional when you provide a &lt;c6&gt;&lt;s7&gt;didSet&lt;/s7&gt;&lt;/c6&gt; clause.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に、あなたが&lt;c6&gt;&lt;s7&gt;didSet&lt;/s7&gt;&lt;/c6&gt;節を提供するとき、&lt;c4&gt;&lt;s5&gt;willSet&lt;/s5&gt;&lt;/c4&gt;節は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, the failable initializer for &lt;c8&gt;&lt;s9&gt;Product&lt;/s9&gt;&lt;/c8&gt; checks the &lt;c10&gt;&lt;s11&gt;name&lt;/s11&gt;&lt;/c10&gt; value, and the initializer process fails immediately if &lt;c12&gt;&lt;s13&gt;name&lt;/s13&gt;&lt;/c12&gt; is the empty string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、&lt;c8&gt;&lt;s9&gt;Product&lt;/s9&gt;&lt;/c8&gt;のための失敗できるイニシャライザは、&lt;c10&gt;&lt;s11&gt;name&lt;/s11&gt;&lt;/c10&gt;値を確認して、&lt;c12&gt;&lt;s13&gt;name&lt;/s13&gt;&lt;/c12&gt;が空の文字列ならば初期化処理は直ちに失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, type safety prevents you from accidentally passing an optional &lt;c5&gt;&lt;s6&gt;String&lt;/s6&gt;&lt;/c5&gt; to a piece of code that requires a non-optional &lt;c7&gt;&lt;s8&gt;String&lt;/s8&gt;&lt;/c7&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらに、型安全はあなたがうっかりしてオプショナル&lt;c5&gt;&lt;s6&gt;String&lt;/s6&gt;&lt;/c5&gt;を、非オプショナル&lt;c7&gt;&lt;s8&gt;String&lt;/s8&gt;&lt;/c7&gt;を要求するコード部分に渡すことを防ぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, you can use &lt;c12&gt;&lt;s13&gt;SuperClass&lt;/s13&gt; &lt;s14&gt;&amp;&lt;/s14&gt; &lt;s15&gt;ProtocolA&lt;/s15&gt;&lt;/c12&gt; instead of declaring a new protocol that is a subclass of &lt;c16&gt;&lt;s17&gt;SuperClass&lt;/s17&gt;&lt;/c16&gt; and conforms to &lt;c18&gt;&lt;s19&gt;ProtocolA&lt;/s19&gt;&lt;/c18&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に、あなたは&lt;c12&gt;&lt;s13&gt;SuperClass&lt;/s13&gt; &lt;s14&gt;&amp;&lt;/s14&gt; &lt;s15&gt;ProtocolA&lt;/s15&gt;&lt;/c12&gt;を使うことが、&lt;c16&gt;&lt;s17&gt;SuperClass&lt;/s17&gt;&lt;/c16&gt;のサブクラスで&lt;c18&gt;&lt;s19&gt;ProtocolA&lt;/s19&gt;&lt;/c18&gt;に準拠する新しいプロトコルを宣言する代わりに行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Line Control Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>行制御文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Line breaks in a multiline string literal are normalized to use the line feed character.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数行文字列リテラルの中のラインブレークは、正規化されて、ラインフィード文字を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Line feed (&lt;c0&gt;&lt;s1&gt;\n&lt;/s1&gt;&lt;/c0&gt;)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ラインフィード「字送り文字」（&lt;c0&gt;&lt;s1&gt;\n&lt;/s1&gt;&lt;/c0&gt;）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Linking Multiple Levels of Chaining</seg>
      </tuv>
      <tuv lang="JA">
        <seg>連鎖の複数の階層を結ぶ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Literal</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Literal Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リテラル式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Literal words and punctuation are indicated by boldface &lt;c0&gt;&lt;s1&gt;constant&lt;/s1&gt; &lt;s2&gt;width&lt;/s2&gt;&lt;/c0&gt; text and appear only on the right-hand side of a grammar production rule.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リテラルの単語と句読点は、太字体の&lt;c0&gt;&lt;s1&gt;等幅&lt;/s1&gt;&lt;/c0&gt;テキストによって示されて、文法導出規則の右側だけに現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Literals</seg>
      </tuv>
      <tuv lang="JA">
        <seg>様々なリテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Local and global variables can’t use property wrappers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ローカルおよびグローバル変数は、プロパティラッパーを使用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Local constants and variables are never computed lazily.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ローカルな定数と変数は、決して遅延して計算されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Local variables are variables that are defined within a function, method, or closure context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ローカル変数は、関数、メソッド、またはクロージャの文脈の範囲内で定義される変数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Logical AND (&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt; &lt;s2&gt;&amp;&amp;&lt;/s2&gt; &lt;s3&gt;b&lt;/s3&gt;&lt;/c0&gt;)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>論理積（&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt; &lt;s2&gt;&amp;&amp;&lt;/s2&gt; &lt;s3&gt;b&lt;/s3&gt;&lt;/c0&gt;）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Logical AND Operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>論理積演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Logical NOT (&lt;c0&gt;&lt;s1&gt;!a&lt;/s1&gt;&lt;/c0&gt;)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>論理否定（&lt;c0&gt;&lt;s1&gt;!a&lt;/s1&gt;&lt;/c0&gt;）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Logical NOT Operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>論理否定演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Logical OR (&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt; &lt;s2&gt;||&lt;/s2&gt; &lt;s3&gt;b&lt;/s3&gt;&lt;/c0&gt;)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>論理和（&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt; &lt;s2&gt;||&lt;/s2&gt; &lt;s3&gt;b&lt;/s3&gt;&lt;/c0&gt;）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Logical OR Operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>論理和演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Logical Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>論理演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Loop Statements</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ループ文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Loop statements allow a block of code to be executed repeatedly, branch statements allow a certain block of code to be executed only when certain conditions are met, and control transfer statements provide a way to alter the order in which code is executed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ループ文はコードの１ブロックが繰り返して実行されるようにします、分岐文はコードの特定のブロックを特定の条件が満たされるときにだけ実行されるようにします、そして制御移動文はコードが実行される順番を変える方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Loop statements allow a block of code to be executed repeatedly, depending on the conditions specified in the loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ループ文は、ループにおいて指定される条件に従って、コードの１ブロックを繰り返して実行するようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Make an existing type conform to a protocol</seg>
      </tuv>
      <tuv lang="JA">
        <seg>既存の型をプロトコルに準拠させる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Make another subclass of &lt;c0&gt;&lt;s1&gt;NamedShape&lt;/s1&gt;&lt;/c0&gt; called &lt;c2&gt;&lt;s3&gt;Circle&lt;/s3&gt;&lt;/c2&gt; that takes a radius and a name as arguments to its initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;NamedShape&lt;/s1&gt;&lt;/c0&gt;の別のサブクラス、&lt;c2&gt;&lt;s3&gt;Circle&lt;/s3&gt;&lt;/c2&gt;と呼ばれるものを作ってください、それはそのイニシャライザに対する引数として半径と名前をとるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Marking a class as open explicitly indicates that you’ve considered the impact of code from other modules using that class as a superclass, and that you’ve designed your class’s code accordingly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるクラスを明示的に開放とすることが指し示すのは、あなたが、そのクラスをスーパークラスとして使っている、他のモジュール由来のコードの影響を考慮に入れるということです、そしてあなたがあなたのクラスのコードをそれに従って設計するということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Marking a closure with &lt;c0&gt;&lt;s1&gt;@escaping&lt;/s1&gt;&lt;/c0&gt; means you have to refer to &lt;c2&gt;&lt;s3&gt;self&lt;/s3&gt;&lt;/c2&gt; explicitly within the closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるクロージャを&lt;c0&gt;&lt;s1&gt;@escaping&lt;/s1&gt;&lt;/c0&gt;で印することは、あなたがそのクロージャ内部で&lt;c2&gt;&lt;s3&gt;self&lt;/s3&gt;&lt;/c2&gt;を明示的に参照しなければならないのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Marking a structure or enumeration as frozen gives up this flexibility to gain performance: Future versions of the library can make only limited changes to the type, but the compiler can make additional optimizations in code that interacts with the type’s members.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体または列挙を凍結されると印することは、この柔軟性を諦めることで性能を手に入れます：ライブラリの将来のバージョンは、制限された変更だけしか型に対して出来ません、しかしコンパイラは追加的な最適化を、型のもつメンバーと相互作用するコードにすることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Marking the protocol as class-only lets the &lt;c6&gt;&lt;s7&gt;SnakesAndLadders&lt;/s7&gt;&lt;/c6&gt; class later in this chapter declare that its delegate must use a weak reference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルをクラス専用とすることは、&lt;c6&gt;&lt;s7&gt;SnakesAndLadders&lt;/s7&gt;&lt;/c6&gt;クラスに後でこの章においてその委任先が弱い参照を使わなければならないことを宣言させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Matched values in a &lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt; case can be bound to temporary constants or variables for use within the case’s body, and complex matching conditions can be expressed with a &lt;c4&gt;&lt;s5&gt;where&lt;/s5&gt;&lt;/c4&gt; clause for each case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある&lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt;ケース節においてマッチされた値は、そのケース節内の本文で使われるために一時的な定数や変数に結び付けられることができます、そして複雑なマッチ条件が各ケース節に対して&lt;c4&gt;&lt;s5&gt;where&lt;/s5&gt;&lt;/c4&gt;節を使って表わされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Matching Enumeration Values with a Switch Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙値をスイッチ文で照合する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Members of a superclass that have this modifier and don’t have the &lt;c0&gt;&lt;s1&gt;final&lt;/s1&gt;&lt;/c0&gt; modifier can be overridden by subclasses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この修飾子を持つそして&lt;c0&gt;&lt;s1&gt;final&lt;/s1&gt;&lt;/c0&gt;修飾子を持たないスーパークラスのメンバーは、サブクラスによってオーバーライドされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Memberwise Initializers for Structure Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体型のためのメンバー関連イニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Memory Safety</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メモリ安全</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Memory for a new instance of that class is allocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのクラスの新しいインスタンスに対するメモリが割り当てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Memory is managed automatically.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メモリは、自動的に管理される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Memory safety is the desired guarantee, but exclusive access is a stricter requirement than memory safety—which means some code preserves memory safety, even though it violates exclusive access to memory.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メモリ安全は望まれる保証です、しかし排他アクセスはメモリ安全より厳格な要件です — それが意味するのは、あるコードはたとえそれがメモリに対する排他アクセスを破るとしてもメモリ安全を守るということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Metatype Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メタタイプ型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Method Requirements</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッド要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Methods</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Methods associated with a type rather than an instance of a type must be marked with the &lt;c0&gt;&lt;s1&gt;static&lt;/s1&gt;&lt;/c0&gt; declaration modifier for enumerations and structures, or with either the &lt;c2&gt;&lt;s3&gt;static&lt;/s3&gt;&lt;/c2&gt; or &lt;c4&gt;&lt;s5&gt;class&lt;/s5&gt;&lt;/c4&gt; declaration modifier for classes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型のインスタンスとではなく、ある型と結び付けられるメソッドは、列挙と構造体では&lt;c0&gt;&lt;s1&gt;static&lt;/s1&gt;&lt;/c0&gt;宣言修飾子で、またクラスでは&lt;c2&gt;&lt;s3&gt;static&lt;/s3&gt;&lt;/c2&gt;または&lt;c4&gt;&lt;s5&gt;class&lt;/s5&gt;&lt;/c4&gt;どちらかの宣言修飾子で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Methods on a subclass that override the superclass’s implementation are marked with &lt;c0&gt;&lt;s1&gt;override&lt;/s1&gt;&lt;/c0&gt;—overriding a method by accident, without &lt;c2&gt;&lt;s3&gt;override&lt;/s3&gt;&lt;/c2&gt;, is detected by the compiler as an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるサブクラスのメソッドで、そのスーパークラスの実装をオーバーライド（再定義）するものは、&lt;c0&gt;&lt;s1&gt;override&lt;/s1&gt;&lt;/c0&gt;で印を付けられます ― &lt;c2&gt;&lt;s3&gt;override&lt;/s3&gt;&lt;/c2&gt;なしで、偶然にメソッドをオーバーライドすることは、コンパイラによってエラーとして検出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Methods on an enumeration or a structure that modify &lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt; must be marked with the &lt;c2&gt;&lt;s3&gt;mutating&lt;/s3&gt;&lt;/c2&gt; declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙または構造体での&lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;を修正するメソッドは、&lt;c2&gt;&lt;s3&gt;mutating&lt;/s3&gt;&lt;/c2&gt;宣言修飾子で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Methods that override a superclass method must be marked with the &lt;c0&gt;&lt;s1&gt;override&lt;/s1&gt;&lt;/c0&gt; declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラスのメソッドをオーバーライドするメソッドは、&lt;c0&gt;&lt;s1&gt;override&lt;/s1&gt;&lt;/c0&gt;宣言修飾子で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Methods with Special Names</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特殊名を持つメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Methods, properties, or subscripts that you add to a class in an extension can also be marked as final within the extension’s definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある拡張においてクラスに加えるメソッド、プロパティ、または添え字は、また、拡張の定義内で最終版として印されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modify the &lt;c0&gt;&lt;s1&gt;anyCommonElements(_:_:)&lt;/s1&gt;&lt;/c0&gt; function to make a function that returns an array of the elements that any two sequences have in common.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>共通したなんらかの２つの連続物である要素たちをもつある配列を返す関数になるように、&lt;c0&gt;&lt;s1&gt;anyCommonElements(_:_:)&lt;/s1&gt;&lt;/c0&gt;関数を修正してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modifying Value Types from Within Instance Methods</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値型をインスタンスメソッド内から修正する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modules and Source Files</seg>
      </tuv>
      <tuv lang="JA">
        <seg>モジュールとソースファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More generally, any unqualified method and property names that you use within the body of a type method will refer to other type-level methods and properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より一般的に言えば、あなたがある型メソッドの本文内で使うどんな非修飾のメソッドやプロパティ名でも、他の型レベルのメソッドやプロパティに言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moreover, &lt;c0&gt;&lt;s1&gt;IntStack&lt;/s1&gt;&lt;/c0&gt; specifies that for this implementation of &lt;c2&gt;&lt;s3&gt;Container&lt;/s3&gt;&lt;/c2&gt;, the appropriate &lt;c4&gt;&lt;s5&gt;Item&lt;/s5&gt;&lt;/c4&gt; to use is a type of &lt;c6&gt;&lt;s7&gt;Int&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらに、&lt;c0&gt;&lt;s1&gt;IntStack&lt;/s1&gt;&lt;/c0&gt;は、&lt;c2&gt;&lt;s3&gt;Container&lt;/s3&gt;&lt;/c2&gt;のこの実施のために、適切な&lt;c4&gt;&lt;s5&gt;Item&lt;/s5&gt;&lt;/c4&gt;として使用するのは&lt;c6&gt;&lt;s7&gt;Int&lt;/s7&gt;&lt;/c6&gt;型であることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most code should use the &lt;c0&gt;&lt;s1&gt;objc&lt;/s1&gt;&lt;/c0&gt; attribute instead, to expose only the declarations that are needed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ほとんどのコードは、&lt;c0&gt;&lt;s1&gt;objc&lt;/s1&gt;&lt;/c0&gt;属性を代わりに使って、必要とされる宣言だけを露出するべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most memory access is instantaneous.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ほとんどのメモリアクセスは即時的です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most of the time, a type identifier directly refers to a named type with the same name as the identifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ほとんどの場合、型識別子は、名前付きの型に、その識別子と同じ名前で直接に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiline String Literals</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数行文字列リテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiline comments begin with &lt;c2&gt;&lt;s3&gt;/*&lt;/s3&gt;&lt;/c2&gt; and end with &lt;c4&gt;&lt;s5&gt;*/&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数行コメントは&lt;c2&gt;&lt;s3&gt;/*&lt;/s3&gt;&lt;/c2&gt;で始まり&lt;c4&gt;&lt;s5&gt;*/&lt;/s5&gt;&lt;/c4&gt;で終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiline comments start with a forward-slash followed by an asterisk (&lt;c0&gt;&lt;s1&gt;/*&lt;/s1&gt;&lt;/c0&gt;) and end with an asterisk followed by a forward-slash (&lt;c2&gt;&lt;s3&gt;*/&lt;/s3&gt;&lt;/c2&gt;):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数行コメントは、スラッシュに続く星印（&lt;c0&gt;&lt;s1&gt;/*&lt;/s1&gt;&lt;/c0&gt;）で始まり、星印に続くスラッシュ（&lt;c2&gt;&lt;s3&gt;*/&lt;/s3&gt;&lt;/c2&gt;）で終わります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiline string literals that you create using extended delimiters have the same indentation requirements as regular multiline string literals.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが拡張区切り記号を使って作成する複数行文字列リテラルは、通常の複数行文字列リテラルと同じ字下げ要件を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple accesses to a location in memory at the same time can produce unpredictable or inconsistent behavior.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メモリの同じ位置への同時での複数のアクセスは、予期されないまたは一貫性のない挙動を生じ得ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple cases can appear on a single line, separated by commas:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数のケース節は、コンマで区切られて、ただ１つの行に現れることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple extensions on a concrete type can’t add conformance to the same protocol, even if the extensions’ requirements are mutually exclusive.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある具象型上の複数の拡張は、同じプロトコルに対して準拠を加えることはできません、たとえそれら拡張の持つ要件が相互に排他的であるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple optional bindings can now appear in a single &lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt; statement as a comma-separated list of assignment expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数のオプショナル束縛は、今では単一の&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt;文においてコンマ区切りの代入式のリストとして現れることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple protocols can be listed, and are separated by commas:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数のプロトコルが、コンマで区切られて、リストされることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple queries can be chained together, and the entire chain fails gracefully if any link in the chain is &lt;c7&gt;&lt;s8&gt;nil&lt;/s8&gt;&lt;/c7&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数の問い合わせが一緒に鎖で繋げられることができます、そして連鎖の中のどれかの輪が&lt;c7&gt;&lt;s8&gt;nil&lt;/s8&gt;&lt;/c7&gt;ならば、その連鎖全体がいさぎよく失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple switch cases that share the same body can be combined by writing several patterns after &lt;c0&gt;&lt;s1&gt;case&lt;/s1&gt;&lt;/c0&gt;, with a comma between each of the patterns.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じ本文を共有する複数のケース節は、&lt;c0&gt;&lt;s1&gt;case&lt;/s1&gt;&lt;/c0&gt;の後にそれぞれのパターンを、それぞれのパターンの間のコンマとともに書くことによって結合されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiplication (&lt;c0&gt;&lt;s1&gt;*&lt;/s1&gt;&lt;/c0&gt;)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>乗算（&lt;c0&gt;&lt;s1&gt;*&lt;/s1&gt;&lt;/c0&gt;）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mutability of Collections</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コレクションの可変性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mutating Instance Methods</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変更インスタンスメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mutating Method Requirements</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変更メソッド要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mutating methods can assign an entirely new instance to the implicit &lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt; property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変更メソッドは、まったく新しいインスタンスを暗黙の&lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;プロパティに代入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Mutating methods for enumerations can set the implicit &lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt; parameter to be a different case from the same enumeration:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙のための変更メソッドは、暗黙の&lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;パラメータを同じ列挙からの異なるケース節に設定することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Named types include classes, structures, enumerations, and protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>名前付きの型は、クラス、構造体、列挙、そしてプロトコルを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Naming Constants and Variables</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数と変数に名をつける</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Naming Type Parameters</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型パラメータに名をつける</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Negative floating-point literals are expressed by prepending a minus sign (&lt;c0&gt;&lt;s1&gt;-&lt;/s1&gt;&lt;/c0&gt;) to a floating-point literal, as in &lt;c2&gt;&lt;s3&gt;-42.5&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>負の浮動小数点数は、浮動小数点リテラルに単項マイナス演算子（&lt;c0&gt;&lt;s1&gt;-&lt;/s1&gt;&lt;/c0&gt;）を前につけることによって表わされます、&lt;c2&gt;&lt;s3&gt;-42.5&lt;/s3&gt;&lt;/c2&gt;のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Negative integers literals are expressed by prepending a minus sign (&lt;c0&gt;&lt;s1&gt;-&lt;/s1&gt;&lt;/c0&gt;) to an integer literal, as in &lt;c2&gt;&lt;s3&gt;-42&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>負整数リテラルは、負符号（&lt;c0&gt;&lt;s1&gt;-&lt;/s1&gt;&lt;/c0&gt;）をリテラル整数の前に付けることによって表されます、&lt;c2&gt;&lt;s3&gt;-42&lt;/s3&gt;&lt;/c2&gt;のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Negative numbers, however, are stored differently.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>負の数は、しかし異なって格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Neither parameter is marked &lt;c2&gt;&lt;s3&gt;@escaping&lt;/s3&gt;&lt;/c2&gt;, so they’re both nonescaping as a result.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どちらのものも&lt;c2&gt;&lt;s3&gt;@escaping&lt;/s3&gt;&lt;/c2&gt;と印されません、それでそれらは両方とも非脱出です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Neither type of formatting affects the underlying value of the literal:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>書式整形のどちらの種類も、もととなるリテラルの値に影響を及ぼしません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested Functions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>入れ子にされた関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>入れ子にされた型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested Types in Action</seg>
      </tuv>
      <tuv lang="JA">
        <seg>入れ子にされた型の動作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested functions are closures that have a name and can capture values from their enclosing function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>入れ子にされた関数は、名前を持ち、それを囲んでいる関数から値を捕獲することができるクロージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested functions are hidden from the outside world by default, but can still be called and used by their enclosing function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>入れ子にされた関数は、初期状態では外界から隠されます、しかしそれにもかかわらず、それらを囲む関数によって呼び出されて使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested functions have access to variables that were declared in the outer function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>入れ子にされた関数は、外側の関数において宣言された変数に、アクセスをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested functions, as introduced in &lt;a0&gt;&lt;s1&gt;Nested Functions&lt;/s1&gt;&lt;/a0&gt;, are a convenient means of naming and defining self-contained blocks of code as part of a larger function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;入れ子にされた関数&lt;/s1&gt;&lt;/a0&gt;は、入れ子にされた関数の中で紹介されるように、より大きい関数の一部として、いろいろな完全独立のコードの塊を名前をつけて定義する便利な手段です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested multiline comments enable you to comment out large blocks of code quickly and easily, even if the code already contains multiline comments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>入れ子にされた複数行コメントによって、たとえコードがすでに複数行コメントを含むとしても、あなたは速く簡単にコードの大きなブロックをコメントアウトすることが可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested types defined within a public type have an automatic access level of internal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>公開型の内側で定義される入れ子にされた型は、自動的なアクセス水準として内部を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nesting multiline comments is allowed, but the comment markers must be balanced.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数行コメントが入れ子にされることは許されます、しかしコメント目印が釣り合っている必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nevertheless, the return value always has the same underlying type of &lt;c4&gt;&lt;s5&gt;[T]&lt;/s5&gt;&lt;/c4&gt;, so it follows the requirement that functions with opaque return types must return values of only a single type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それにもかかわらず、戻り値は常に同じ基礎をなす型の&lt;c4&gt;&lt;s5&gt;[T]&lt;/s5&gt;&lt;/c4&gt;を持ちます、それでそれは、不透明戻り型をもつ関数はもっぱら単一の型の値だけを返さなければならないという要件に従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New document that describes Swift 1.0, Apple’s new programming language for building iOS and OS X apps.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>iOSおよびOS Xアプリ構築のためのAppleの新しいプログラミング言語、スウィフト 1.0を解説する新しい文書。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New operators are declared at a global level using the &lt;c0&gt;&lt;s1&gt;operator&lt;/s1&gt;&lt;/c0&gt; keyword, and are marked with the &lt;c2&gt;&lt;s3&gt;prefix&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;infix&lt;/s5&gt;&lt;/c4&gt; or &lt;c6&gt;&lt;s7&gt;postfix&lt;/s7&gt;&lt;/c6&gt; modifiers:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい演算子は&lt;c0&gt;&lt;s1&gt;operator&lt;/s1&gt;&lt;/c0&gt;キーワードを使ってグローバル水準で宣言されます、そして&lt;c2&gt;&lt;s3&gt;prefix&lt;/s3&gt;&lt;/c2&gt;、&lt;c4&gt;&lt;s5&gt;infix&lt;/s5&gt;&lt;/c4&gt;または&lt;c6&gt;&lt;s7&gt;postfix&lt;/s7&gt;&lt;/c6&gt;修飾子で印されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, &lt;c0&gt;&lt;s1&gt;tenEighty&lt;/s1&gt;&lt;/c0&gt; is assigned to a new constant, called &lt;c2&gt;&lt;s3&gt;alsoTenEighty&lt;/s3&gt;&lt;/c2&gt;, and the frame rate of &lt;c4&gt;&lt;s5&gt;alsoTenEighty&lt;/s5&gt;&lt;/c4&gt; is modified:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次に、&lt;c0&gt;&lt;s1&gt;tenEighty&lt;/s1&gt;&lt;/c0&gt;は、新しい定数、&lt;c2&gt;&lt;s3&gt;alsoTenEighty&lt;/s3&gt;&lt;/c2&gt;と呼ばれるものに代入されます、そして&lt;c4&gt;&lt;s5&gt;alsoTenEighty&lt;/s5&gt;&lt;/c4&gt;のフレームレートが修正されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, the &lt;c0&gt;&lt;s1&gt;width&lt;/s1&gt;&lt;/c0&gt; property of &lt;c2&gt;&lt;s3&gt;cinema&lt;/s3&gt;&lt;/c2&gt; is amended to be the width of the slightly wider 2K standard used for digital cinema projection (2048 pixels wide and 1080 pixels high):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次に、&lt;c2&gt;&lt;s3&gt;cinema&lt;/s3&gt;&lt;/c2&gt;の&lt;c0&gt;&lt;s1&gt;width&lt;/s1&gt;&lt;/c0&gt;プロパティは、デジタル映画館投影のために使われるわずかにより広い2Kの標準の幅（2048ピクセル幅の広さで1080ピクセルの高さ）になるように改められます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nil-Coalescing Operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>nil合体演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No Implicit Fallthrough</seg>
      </tuv>
      <tuv lang="JA">
        <seg>知らずに突き抜けない（フォールスルーしない）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No further code from the current iteration of the loop is executed, and no further iterations of the loop are started.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ループの現在の繰り返しからそれ以上のコードは実行されません、そしてループのそれ以上の繰り返しは始まりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No ladder on the board takes the player straight to square 25, and so it isn’t possible to win the game by moving up a ladder.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>盤上のはしごは、プレーヤーをまっすぐ正方形25に連れて行きません、なので、はしごを上がることでゲームに勝つことは可能ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No other properties or variables are still referring to the &lt;c10&gt;&lt;s11&gt;Player&lt;/s11&gt;&lt;/c10&gt; instance, and so it is deallocated in order to free up its memory.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他のいかなるプロパティまたは変数も、もはや&lt;c10&gt;&lt;s11&gt;Player&lt;/s11&gt;&lt;/c10&gt;インスタンスに言及していません、なのでそれは、それのもつメモリを開放するために順次割り当て解除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nonassociative operators of the same precedence level can’t appear adjacent to each to other.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じ優先順位レベルを持つ非結合演算子は、互いに隣同士に現れることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nonetheless, because it’s of type &lt;c10&gt;&lt;s11&gt;TextRepresentable&lt;/s11&gt;&lt;/c10&gt;, and anything that is &lt;c12&gt;&lt;s13&gt;TextRepresentable&lt;/s13&gt;&lt;/c12&gt; is known to have a &lt;c14&gt;&lt;s15&gt;textualDescription&lt;/s15&gt;&lt;/c14&gt; property, it’s safe to access &lt;c16&gt;&lt;s17&gt;thing.textualDescription&lt;/s17&gt;&lt;/c16&gt; each time through the loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それでもなお、それが&lt;c10&gt;&lt;s11&gt;TextRepresentable&lt;/s11&gt;&lt;/c10&gt;型であり、そして、&lt;c12&gt;&lt;s13&gt;TextRepresentable&lt;/s13&gt;&lt;/c12&gt;であるもの全てが&lt;c14&gt;&lt;s15&gt;textualDescription&lt;/s15&gt;&lt;/c14&gt;プロパティを持つと知られているので、それがループの各回で&lt;c16&gt;&lt;s17&gt;thing.textualDescription&lt;/s17&gt;&lt;/c16&gt;にアクセスするのは安全です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nonetheless, class &lt;c8&gt;&lt;s9&gt;B&lt;/s9&gt;&lt;/c8&gt; provides an override of &lt;c10&gt;&lt;s11&gt;someMethod()&lt;/s11&gt;&lt;/c10&gt; with an access level of “internal”, which is &lt;e12&gt;higher&lt;/e12&gt; than the original implementation of &lt;c13&gt;&lt;s14&gt;someMethod()&lt;/s14&gt;&lt;/c13&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それにもかかわらず、クラス&lt;c8&gt;&lt;s9&gt;B&lt;/s9&gt;&lt;/c8&gt;は、「内部」のアクセス水準を持つ&lt;c10&gt;&lt;s11&gt;someMethod()&lt;/s11&gt;&lt;/c10&gt;のオーバーライドを提供します、それは元々の&lt;c13&gt;&lt;s14&gt;someMethod()&lt;/s14&gt;&lt;/c13&gt;の実装よりも&lt;e12&gt;より高い&lt;/e12&gt;です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nonetheless, it is useful for a &lt;c20&gt;&lt;s21&gt;Cuboid&lt;/s21&gt;&lt;/c20&gt; to provide a read-only computed property to enable external users to discover its current calculated volume.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それでもなお、&lt;c20&gt;&lt;s21&gt;Cuboid&lt;/s21&gt;&lt;/c20&gt;が外部のユーザーにその現在の計算された体積を見つけられるように読み出し専用の計算プロパティを提供することは、役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nonetheless, many parts of Swift will be familiar from your experience of developing in C and Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>にもかかわらず、スウィフトの多くの部分は、あなたのCとObjective-Cでの開発経験からきっとお馴染みのものでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nonetheless, the &lt;c9&gt;&lt;s10&gt;Item&lt;/s10&gt;&lt;/c9&gt; alias provides a way to refer to the type of the items in a &lt;c11&gt;&lt;s12&gt;Container&lt;/s12&gt;&lt;/c11&gt;, and to define a type for use with the &lt;c13&gt;&lt;s14&gt;append(_:)&lt;/s14&gt;&lt;/c13&gt; method and subscript, to ensure that the expected behavior of any &lt;c15&gt;&lt;s16&gt;Container&lt;/s16&gt;&lt;/c15&gt; is enforced.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それでもなお、&lt;c9&gt;&lt;s10&gt;Item&lt;/s10&gt;&lt;/c9&gt;エイリアスは、&lt;c11&gt;&lt;s12&gt;Container&lt;/s12&gt;&lt;/c11&gt;の中の項目の型に言及するための、そして&lt;c13&gt;&lt;s14&gt;append(_:)&lt;/s14&gt;&lt;/c13&gt;メソッドと添え字で使うための型を定義するための、ひとつの方法を提供します、それによってあらゆる&lt;c15&gt;&lt;s16&gt;Container&lt;/s16&gt;&lt;/c15&gt;が期待される挙動を強制されることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nonetheless, they’re all classes, and so instances of all three types can be used to initialize an array that stores values of type &lt;c6&gt;&lt;s7&gt;AnyObject&lt;/s7&gt;&lt;/c6&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それでもなお、それらは全てクラスです、なので、３つの型全てのインスタンスは、型&lt;c6&gt;&lt;s7&gt;AnyObject&lt;/s7&gt;&lt;/c6&gt;の値を格納するある配列を初期化するために使用できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nonetheless, you can still make the types explicit if you wish, and doing so is encouraged if it avoids ambiguity for readers of your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それでもなお、あなたが望むならば、依然としてあなたは型を明確にすることができます、そして、それがあなたのコードの読者のために曖昧さを避けるならば、そうすることは推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nonetheless, you can use protocols as a fully fledged types in your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それにもかかわらず、あなたはプロトコルを完全に一人前の型としてあなたのコードにおいて使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nonreturning functions and methods either cause an irrecoverable error or begin a sequence of work that continues indefinitely.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非復帰関数およびメソッドは、回復不能のエラーを起こすかまたは無期限に続く一連の作業を始めるかのどちらかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nor can they begin with a number, although numbers may be included elsewhere within the name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そしてそれらは数字から始まることもできません、けれども数字が名前内のどこか他で含まれることはできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nor can you change a constant into a variable or a variable into a constant.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そして、あなたはある定数を変数に、またはある変数を定数に変更することもできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not all possible &lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt; values will find a matching planet, however.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、全ての可能な&lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt;値が、適合する惑星を見つけるというわけでありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not equal to (&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt; &lt;s2&gt;!=&lt;/s2&gt; &lt;s3&gt;b&lt;/s3&gt;&lt;/c0&gt;)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同等でない (&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt; &lt;s2&gt;!=&lt;/s2&gt; &lt;s3&gt;b&lt;/s3&gt;&lt;/c0&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not every type in Swift can be compared with the equal to operator (&lt;c5&gt;&lt;s6&gt;==&lt;/s6&gt;&lt;/c5&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの中のすべての型が、同等演算子（&lt;c5&gt;&lt;s6&gt;==&lt;/s6&gt;&lt;/c5&gt;）で比較されることができるというわけでありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not identical to (&lt;c0&gt;&lt;s1&gt;!==&lt;/s1&gt;&lt;/c0&gt;)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同一でない（&lt;c0&gt;&lt;s1&gt;!==&lt;/s1&gt;&lt;/c0&gt;）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not only are optionals safer and more expressive than &lt;c5&gt;&lt;s6&gt;nil&lt;/s6&gt;&lt;/c5&gt; pointers in Objective-C, they’re at the heart of many of Swift’s most powerful features.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルはObjective-Cでの&lt;c5&gt;&lt;s6&gt;nil&lt;/s6&gt;&lt;/c5&gt;ポインターより安全でさらに表現豊かであるだけでなく、それはスウィフトのたくさんある非常に強力な特徴のうち核心的なものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note</seg>
      </tuv>
      <tuv lang="JA">
        <seg>注意</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note also that you cannot provide both an overriding setter and an overriding property observer for the same property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが同じプロパティに対してオーバーライドしたセッターとオーバーライドしたプロパティオブザーバーの両方を提供することができない点にまた、注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note how the generic version of &lt;c0&gt;&lt;s1&gt;Stack&lt;/s1&gt;&lt;/c0&gt; is essentially the same as the nongeneric version, but with a type parameter called &lt;c2&gt;&lt;s3&gt;Element&lt;/s3&gt;&lt;/c2&gt; instead of an actual type of &lt;c4&gt;&lt;s5&gt;Int&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Stack&lt;/s1&gt;&lt;/c0&gt;の総称体版が、本質的にどれほど非総称体版と同じものであるかに注意してください、しかし&lt;c2&gt;&lt;s3&gt;Element&lt;/s3&gt;&lt;/c2&gt;と呼ばれる型パラメータを実際の型&lt;c4&gt;&lt;s5&gt;Int&lt;/s5&gt;&lt;/c4&gt;の代わりに持つことは除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that &lt;c0&gt;&lt;s1&gt;tenEighty&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;alsoTenEighty&lt;/s3&gt;&lt;/c2&gt; are declared as &lt;e4&gt;constants&lt;/e4&gt;, rather than variables.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;tenEighty&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;alsoTenEighty&lt;/s3&gt;&lt;/c2&gt;が、変数ではなく、&lt;e4&gt;定数&lt;/e4&gt;として宣言される点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that &lt;c12&gt;&lt;s13&gt;x&lt;/s13&gt;&lt;/c12&gt; and &lt;c14&gt;&lt;s15&gt;y&lt;/s15&gt;&lt;/c14&gt; are an optional of whatever type &lt;c16&gt;&lt;s17&gt;someThrowingFunction()&lt;/s17&gt;&lt;/c16&gt; returns.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c12&gt;&lt;s13&gt;x&lt;/s13&gt;&lt;/c12&gt;と&lt;c14&gt;&lt;s15&gt;y&lt;/s15&gt;&lt;/c14&gt;は、たとえどんなものでも&lt;c16&gt;&lt;s17&gt;someThrowingFunction()&lt;/s17&gt;&lt;/c16&gt;が返す型のオプショナルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that &lt;c5&gt;&lt;s6&gt;@objc&lt;/s6&gt;&lt;/c5&gt; protocols can be adopted only by classes that inherit from Objective-C classes or other &lt;c7&gt;&lt;s8&gt;@objc&lt;/s8&gt;&lt;/c7&gt; classes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c5&gt;&lt;s6&gt;@objc&lt;/s6&gt;&lt;/c5&gt;プロトコルがObjective-Cクラスや他の&lt;c7&gt;&lt;s8&gt;@objc&lt;/s8&gt;&lt;/c7&gt;クラスから継承するクラスによってのみ採用される点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that &lt;e0&gt;identical to&lt;/e0&gt; (represented by three equals signs, or &lt;c1&gt;&lt;s2&gt;===&lt;/s2&gt;&lt;/c1&gt;) doesn’t mean the same thing as &lt;e3&gt;equal to&lt;/e3&gt; (represented by two equals signs, or &lt;c4&gt;&lt;s5&gt;==&lt;/s5&gt;&lt;/c4&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;同一である&lt;/e0&gt;（３つの等号、つまり&lt;c1&gt;&lt;s2&gt;===&lt;/s2&gt;&lt;/c1&gt;によって表されるもの）は&lt;e3&gt;同等である&lt;/e3&gt;（２つの等号、つまり&lt;c4&gt;&lt;s5&gt;==&lt;/s5&gt;&lt;/c4&gt;によって表されるもの）と同じことを意味しないのに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that &lt;e0&gt;two&lt;/e0&gt; levels of optional chaining are at play here.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここで&lt;e0&gt;２つの&lt;/e0&gt;階層のオプショナル連鎖が働いていることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that Swift infers a type of &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; for the &lt;c2&gt;&lt;s3&gt;someString&lt;/s3&gt;&lt;/c2&gt; constant because it’s initialized with a string literal value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトが型&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;を&lt;c2&gt;&lt;s3&gt;someString&lt;/s3&gt;&lt;/c2&gt;定数に対して推論することに注意してください、それが文字列リテラル値で初期化されるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that Swift’s use of extended grapheme clusters for &lt;c0&gt;&lt;s1&gt;Character&lt;/s1&gt;&lt;/c0&gt; values means that string concatenation and modification may not always affect a string’s character count.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの&lt;c0&gt;&lt;s1&gt;Character&lt;/s1&gt;&lt;/c0&gt;値に対する拡張書記素クラスタの使用は、文字列の連結と修正が常に文字列の文字数に影響を与えないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that an exclamation point (&lt;c0&gt;&lt;s1&gt;!&lt;/s1&gt;&lt;/c0&gt;) is used to unwrap and access the instances stored inside the &lt;c2&gt;&lt;s3&gt;john&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;unit4A&lt;/s5&gt;&lt;/c4&gt; optional variables, so that the properties of those instances can be set:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>感嘆符（&lt;c0&gt;&lt;s1&gt;!&lt;/s1&gt;&lt;/c0&gt;）が使われることに注意してください、そうすることでオプショナル変数の&lt;c2&gt;&lt;s3&gt;john&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;unit4A&lt;/s5&gt;&lt;/c4&gt;に格納されるインスタンスがアンラップされてアクセスされるようになります、それでそれらのインスタンスのプロパティが設定されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if you define a custom initializer for a value type, you will no longer have access to the default initializer (or the memberwise initializer, if it is a structure) for that type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある値型のためにあつらえのイニシャライザを定義するならば、あなたがもはやその型の省略時のイニシャライザに（および、それが構造体の場合には、メンバー関連イニシャライザにも）アクセスをしない点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if you override a failable superclass initializer with a nonfailable subclass initializer, the only way to delegate up to the superclass initializer is to force-unwrap the result of the failable superclass initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>注意することは、あなたが失敗できるスーパークラス・イニシャライザを、失敗できないサブクラス・イニシャライザでオーバーライドする場合、唯一の方法としてスーパークラスのイニシャライザにまで委任するには、失敗できるスーパークラスイニシャライザの結果を強制アンラップすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that in the example above, you are trying to retrieve the value of the &lt;c0&gt;&lt;s1&gt;street&lt;/s1&gt;&lt;/c0&gt; property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例で、あなたが&lt;c0&gt;&lt;s1&gt;street&lt;/s1&gt;&lt;/c0&gt;プロパティの値を取り出そうとしている点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that it is not possible to call these initializers without using argument labels.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>引数ラベルを使用することなくこれらのイニシャライザを呼び出すことは可能でない点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that neither deinitializer was called when you set these two variables to &lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがこれらの２つの変数を&lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;に設定したとき、どちらのデイニシャライザも呼ばれなかった点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that no whitespace may appear between the type and the &lt;c0&gt;&lt;s1&gt;!&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>空白が型と&lt;c0&gt;&lt;s1&gt;!&lt;/s1&gt;&lt;/c0&gt;の間に現れないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that no whitespace may appear between the type and the &lt;c2&gt;&lt;s3&gt;?&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>空白が型と&lt;c2&gt;&lt;s3&gt;?&lt;/s3&gt;&lt;/c2&gt;の間に現れないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that not all 21-bit Unicode scalar values are assigned to a character—some scalars are reserved for future assignment or for use in UTF-16 encoding.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全ての21ビットのユニコードスカラー値がひとつの文字に割り当てられる訳ではないことに注意してください ― いくつかのスカラーは将来の割り当てのためにまたはUTF-16符号化で使うために取っておかれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the &lt;c0&gt;&lt;s1&gt;delegate&lt;/s1&gt;&lt;/c0&gt; property is defined as an &lt;e2&gt;optional&lt;/e2&gt; &lt;c3&gt;&lt;s4&gt;DiceGameDelegate&lt;/s4&gt;&lt;/c3&gt;, because a delegate isn’t required in order to play the game.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;delegate&lt;/s1&gt;&lt;/c0&gt;プロパティが、&lt;e2&gt;オプショナル&lt;/e2&gt;の&lt;c3&gt;&lt;s4&gt;DiceGameDelegate&lt;/s4&gt;&lt;/c3&gt;として定義される点に注意してください、delegateがゲームをプレイするために必須でないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the &lt;c0&gt;&lt;s1&gt;thing&lt;/s1&gt;&lt;/c0&gt; constant is of type &lt;c2&gt;&lt;s3&gt;TextRepresentable&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;thing&lt;/s1&gt;&lt;/c0&gt;定数が型&lt;c2&gt;&lt;s3&gt;TextRepresentable&lt;/s3&gt;&lt;/c2&gt;であることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the array contains four items, but &lt;c0&gt;&lt;s1&gt;0..&lt;count&lt;/s1&gt;&lt;/c0&gt; only counts as far as &lt;c2&gt;&lt;s3&gt;3&lt;/s3&gt;&lt;/c2&gt; (the index of the last item in the array), because it’s a half-open range.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この配列が４つの項目を含む点に注意してください、しかし&lt;c0&gt;&lt;s1&gt;0..&lt;count&lt;/s1&gt;&lt;/c0&gt;は&lt;c2&gt;&lt;s3&gt;3&lt;/s3&gt;&lt;/c2&gt;（この配列の最後の項目のインデックス）まで数えるだけです、なぜならそれが半開範囲であるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the closure’s end curly brace is followed by an empty pair of parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャの閉じ波括弧に、一対の空の丸括弧が続くことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the declaration of parameters and return type for this inline closure is identical to the declaration from the &lt;c0&gt;&lt;s1&gt;backward(_:_:)&lt;/s1&gt;&lt;/c0&gt; function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>行内クロージャのためのパラメータと戻り型の宣言が、&lt;c0&gt;&lt;s1&gt;backward(_:_:)&lt;/s1&gt;&lt;/c0&gt;関数の宣言と同一であることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the entire function type is wrapped in the optional, not the method’s return value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッドの戻り値ではなく、その関数型の全体がオプショナルの中のラップされることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the message &lt;c0&gt;&lt;s1&gt;"John&lt;/s1&gt; &lt;s2&gt;Appleseed&lt;/s2&gt; &lt;s3&gt;is&lt;/s3&gt; &lt;s4&gt;being&lt;/s4&gt; &lt;s5&gt;initialized"&lt;/s5&gt;&lt;/c0&gt; is printed at the point that you call the &lt;c6&gt;&lt;s7&gt;Person&lt;/s7&gt;&lt;/c6&gt; class’s initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが&lt;c6&gt;&lt;s7&gt;Person&lt;/s7&gt;&lt;/c6&gt;クラスのイニシャライザを呼んだ時点で、メッセージ&lt;c0&gt;&lt;s1&gt;"John&lt;/s1&gt; &lt;s2&gt;Appleseed&lt;/s2&gt; &lt;s3&gt;is&lt;/s3&gt; &lt;s4&gt;being&lt;/s4&gt; &lt;s5&gt;initialized"&lt;/s5&gt;&lt;/c0&gt;が出力されるという点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the message in the &lt;c0&gt;&lt;s1&gt;HTMLElement&lt;/s1&gt;&lt;/c0&gt; deinitializer is not printed, which shows that the &lt;c2&gt;&lt;s3&gt;HTMLElement&lt;/s3&gt;&lt;/c2&gt; instance is not deallocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;HTMLElement&lt;/s1&gt;&lt;/c0&gt;デイニシャライザにおけるメッセージが出力されないことに注意してください、それは、&lt;c2&gt;&lt;s3&gt;HTMLElement&lt;/s3&gt;&lt;/c2&gt;インスタンスが割り当て解除されないことを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the names of &lt;c4&gt;&lt;s5&gt;someInt&lt;/s5&gt;&lt;/c4&gt; and &lt;c6&gt;&lt;s7&gt;anotherInt&lt;/s7&gt;&lt;/c6&gt; are prefixed with an ampersand when they are passed to the &lt;c8&gt;&lt;s9&gt;swapTwoInts(_:_:)&lt;/s9&gt;&lt;/c8&gt; function:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;someInt&lt;/s5&gt;&lt;/c4&gt;と&lt;c6&gt;&lt;s7&gt;anotherInt&lt;/s7&gt;&lt;/c6&gt;の名前が、それらが&lt;c8&gt;&lt;s9&gt;swapTwoInts(_:_:)&lt;/s9&gt;&lt;/c8&gt;関数に渡される時に、アンパサンドで接頭辞を付けられるという点に注意してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the return type of this function is still &lt;c4&gt;&lt;s5&gt;Int?&lt;/s5&gt;&lt;/c4&gt;, because the function returns an optional index number, not an optional value from the array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数の戻り型が以前として&lt;c4&gt;&lt;s5&gt;Int?&lt;/s5&gt;&lt;/c4&gt;であるという点に注意してください、なぜなら、この関数がオプショナルのインデックス番号（配列からのオプショナルの値でない）を返すからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the tuple’s members do not need to be named at the point that the tuple is returned from the function, because their names are already specified as part of the function’s return type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプルの構成要素が、タプルがその関数から返される時点で名前をつけられる必要がない点に注意してください、なぜなら、それらの名前が関数の戻り型の一部としてすでに指定されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the type of &lt;c2&gt;&lt;s3&gt;customerProvider&lt;/s3&gt;&lt;/c2&gt; is not &lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt; but &lt;c6&gt;&lt;s7&gt;()&lt;/s7&gt; &lt;s8&gt;-&gt;&lt;/s8&gt; &lt;s9&gt;String&lt;/s9&gt;&lt;/c6&gt;—a function with no parameters that returns a string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>注意すべきは、&lt;c2&gt;&lt;s3&gt;customerProvider&lt;/s3&gt;&lt;/c2&gt;の型は&lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt;ではなく&lt;c6&gt;&lt;s7&gt;()&lt;/s7&gt; &lt;s8&gt;-&gt;&lt;/s8&gt; &lt;s9&gt;String&lt;/s9&gt;&lt;/c6&gt; — ある文字列を返すパラメータのない関数 — であることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the type of the &lt;c0&gt;&lt;s1&gt;someInts&lt;/s1&gt;&lt;/c0&gt; variable is inferred to be &lt;c2&gt;&lt;s3&gt;[Int]&lt;/s3&gt;&lt;/c2&gt; from the type of the initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;someInts&lt;/s1&gt;&lt;/c0&gt;変数の型が、そのイニシャライザの型から&lt;c2&gt;&lt;s3&gt;[Int]&lt;/s3&gt;&lt;/c2&gt;であると推測される点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the underlying objects aren’t changed by the casting process.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>根底にあるオブジェクトがキャスト処理によって変更されない点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this extension doesn’t define a type parameter list.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この拡張は型パラメーターリストを定義しないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this function is distinct from the &lt;c10&gt;&lt;s11&gt;greet(person:)&lt;/s11&gt;&lt;/c10&gt; function shown in an earlier section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数が前の節で見せた&lt;c10&gt;&lt;s11&gt;greet(person:)&lt;/s11&gt;&lt;/c10&gt;関数と別個のものであることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this is true even though &lt;c0&gt;&lt;s1&gt;numberOfRooms&lt;/s1&gt;&lt;/c0&gt; is a non-optional &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえ&lt;c0&gt;&lt;s1&gt;numberOfRooms&lt;/s1&gt;&lt;/c0&gt;が非オプショナルの&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;であるとしても、これが当てはまることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that you can assign an explicit access level for both a getter and a setter if required.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは明示的なアクセス水準をゲッターとセッターの両方に割り当てることが、必要ならば可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that you cannot call a mutating method on a constant of structure type, because its properties cannot be changed, even if they are variable properties, as described in &lt;a0&gt;&lt;s1&gt;Stored Properties of Constant Structure Instances&lt;/s1&gt;&lt;/a0&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが定数の構造体型で変更メソッドを呼ぶことができないということに注意してください、なぜなら、&lt;a0&gt;&lt;s1&gt;定数構造体インスタンスの格納プロパティ&lt;/s1&gt;&lt;/a0&gt;で記述されるように、そのプロパティは、たとえそれらが変数プロパティであるとしても変わることができないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that, because &lt;c0&gt;&lt;s1&gt;Optional&lt;/s1&gt;&lt;/c0&gt; is implemented as an enumeration, &lt;c2&gt;&lt;s3&gt;.none&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;.some&lt;/s5&gt;&lt;/c4&gt; can appear in the same switch as the cases of the enumeration type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>注意することとして、&lt;c0&gt;&lt;s1&gt;Optional&lt;/s1&gt;&lt;/c0&gt;が列挙として実装されることから、&lt;c2&gt;&lt;s3&gt;.none&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;.some&lt;/s5&gt;&lt;/c4&gt;が同じスイッチ文の中に列挙型のケース節として現れることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nothing else is required of the instance you assign to this property, except that the instance must adopt the &lt;c7&gt;&lt;s8&gt;RandomNumberGenerator&lt;/s8&gt;&lt;/c7&gt; protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのインスタンスが&lt;c7&gt;&lt;s8&gt;RandomNumberGenerator&lt;/s8&gt;&lt;/c7&gt;プロトコルを採用しなければならないことをのぞいては、あなたがこのプロパティに代入するところのインスタンスに必要とされるものは他に何もありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice how &lt;c0&gt;&lt;s1&gt;let&lt;/s1&gt;&lt;/c0&gt; can be used in a pattern to assign the value that matched the pattern to a constant.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どのように&lt;c0&gt;&lt;s1&gt;let&lt;/s1&gt;&lt;/c0&gt;がパターン内で使われて、パターンに合致した値を定数に割り当てることができるかに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice how &lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt; is used to distinguish the &lt;c2&gt;&lt;s3&gt;name&lt;/s3&gt;&lt;/c2&gt; property from the &lt;c4&gt;&lt;s5&gt;name&lt;/s5&gt;&lt;/c4&gt; argument to the initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どのように&lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;が&lt;c2&gt;&lt;s3&gt;name&lt;/s3&gt;&lt;/c2&gt;プロパティをイニシャライザのための&lt;c4&gt;&lt;s5&gt;name&lt;/s5&gt;&lt;/c4&gt;引数と区別するために使われるかに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice how the sunrise and sunset times are extracted from the &lt;c0&gt;&lt;s1&gt;ServerResponse&lt;/s1&gt;&lt;/c0&gt; value as part of matching the value against the switch cases.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どのように日の出と日没の時間が&lt;c0&gt;&lt;s1&gt;ServerResponse&lt;/s1&gt;&lt;/c0&gt;の値から、その値をスイッチの各条件と比較することの一環として抽出されるかに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice that the initializer for the &lt;c0&gt;&lt;s1&gt;EquilateralTriangle&lt;/s1&gt;&lt;/c0&gt; class has three different steps:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;EquilateralTriangle&lt;/s1&gt;&lt;/c0&gt;クラスのためのイニシャライザが３つの異なる段階を持つことに注意してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice the two ways that the &lt;c0&gt;&lt;s1&gt;hearts&lt;/s1&gt;&lt;/c0&gt; case of the enumeration is referred to above: When assigning a value to the &lt;c2&gt;&lt;s3&gt;hearts&lt;/s3&gt;&lt;/c2&gt; constant, the enumeration case &lt;c4&gt;&lt;s5&gt;Suit.hearts&lt;/s5&gt;&lt;/c4&gt; is referred to by its full name because the constant doesn’t have an explicit type specified.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上記で列挙の&lt;c0&gt;&lt;s1&gt;hearts&lt;/s1&gt;&lt;/c0&gt;ケース節が参照される２つの方法に注意してください：定数の&lt;c2&gt;&lt;s3&gt;hearts&lt;/s3&gt;&lt;/c2&gt;に値を代入するとき、列挙のケース節&lt;c4&gt;&lt;s5&gt;Suit.hearts&lt;/s5&gt;&lt;/c4&gt;はそのフルネームによって参照されます、なぜならこの定数には明確に指定される型がないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice the use of the &lt;c0&gt;&lt;s1&gt;mutating&lt;/s1&gt;&lt;/c0&gt; keyword in the declaration of &lt;c2&gt;&lt;s3&gt;SimpleStructure&lt;/s3&gt;&lt;/c2&gt; to mark a method that modifies the structure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;SimpleStructure&lt;/s3&gt;&lt;/c2&gt;の宣言における&lt;c0&gt;&lt;s1&gt;mutating&lt;/s1&gt;&lt;/c0&gt;キーワードに注意してください、それはその構造体を修正するメソッドに印を付けるためのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now that &lt;c0&gt;&lt;s1&gt;moveNearerToZero&lt;/s1&gt;&lt;/c0&gt; refers to the correct function, it can be used to count to zero:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;moveNearerToZero&lt;/s1&gt;&lt;/c0&gt;が正しい関数に言及する今、それはゼロまで数えるために使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now you can call the function as if it took a &lt;c6&gt;&lt;s7&gt;String&lt;/s7&gt;&lt;/c6&gt; argument instead of a closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>今やあなたはこの関数を、まるでそれがクロージャではなく&lt;c6&gt;&lt;s7&gt;String&lt;/s7&gt;&lt;/c6&gt;引数を取るかのように呼び出せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Null character (&lt;c0&gt;&lt;s1&gt;\0&lt;/s1&gt;&lt;/c0&gt;)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>null文字（&lt;c0&gt;&lt;s1&gt;\0&lt;/s1&gt;&lt;/c0&gt;）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numbers can overflow in both the positive and negative direction.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>数は正と負の向きの両方においてオーバフローすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numeric Literals</seg>
      </tuv>
      <tuv lang="JA">
        <seg>数のリテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numeric Type Conversion</seg>
      </tuv>
      <tuv lang="JA">
        <seg>数の型変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numeric literals can contain extra formatting to make them easier to read.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>数のリテラルは、それらをより簡単に読めるように書式を整える追加のものを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Objects and Classes</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オブジェクトとクラス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Omitting Argument Labels</seg>
      </tuv>
      <tuv lang="JA">
        <seg>引数ラベルの省略</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Omitting the &lt;c0&gt;&lt;s1&gt;return&lt;/s1&gt;&lt;/c0&gt; from a getter follows the same rules as omitting &lt;c2&gt;&lt;s3&gt;return&lt;/s3&gt;&lt;/c2&gt; from a function, as described in &lt;a4&gt;&lt;s5&gt;Functions With an Implicit Return&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;return&lt;/s1&gt;&lt;/c0&gt;をゲッターから省くことは、&lt;c2&gt;&lt;s3&gt;return&lt;/s3&gt;&lt;/c2&gt;を関数から省くのと同じ規則に従います、&lt;a4&gt;&lt;s5&gt;暗黙的なreturnをもつ関数&lt;/s5&gt;&lt;/a4&gt;で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Omitting the version number indicates that the declaration is currently deprecated, without giving any information about when the deprecation occurred.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>バージョン番号の省略は、宣言が現れた時についてのどんな情報も与えることなく、その宣言が現在は非推奨であることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On a 32-bit platform, &lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt; is the same size as &lt;c2&gt;&lt;s3&gt;Int32&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>32ビットのプラットホーム上で、&lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt;は&lt;c2&gt;&lt;s3&gt;Int32&lt;/s3&gt;&lt;/c2&gt;と同じサイズです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On a 32-bit platform, &lt;c0&gt;&lt;s1&gt;UInt&lt;/s1&gt;&lt;/c0&gt; is the same size as &lt;c2&gt;&lt;s3&gt;UInt32&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>32ビットのプラットホーム上で、&lt;c0&gt;&lt;s1&gt;UInt&lt;/s1&gt;&lt;/c0&gt;は&lt;c2&gt;&lt;s3&gt;UInt32&lt;/s3&gt;&lt;/c2&gt;と同じサイズです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On a 64-bit platform, &lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt; is the same size as &lt;c2&gt;&lt;s3&gt;Int64&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>64ビットのプラットホーム上で、&lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt;は&lt;c2&gt;&lt;s3&gt;Int64&lt;/s3&gt;&lt;/c2&gt;と同じサイズです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On a 64-bit platform, &lt;c0&gt;&lt;s1&gt;UInt&lt;/s1&gt;&lt;/c0&gt; is the same size as &lt;c2&gt;&lt;s3&gt;UInt64&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>64ビットのプラットホーム上で、&lt;c0&gt;&lt;s1&gt;UInt&lt;/s1&gt;&lt;/c0&gt;は&lt;c2&gt;&lt;s3&gt;UInt64&lt;/s3&gt;&lt;/c2&gt;と同じサイズです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On a Mac with Xcode installed, or on an iPad with Swift Playgrounds, you can open this chapter as a playground.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>XcodeがインストールされたMac上で、またはSwift Playgroundsを備えたiPad上で、あなたはこの章をプレイグラウンドとして開くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On each pass, the &lt;c2&gt;&lt;s3&gt;for&lt;/s3&gt;&lt;/c2&gt;-&lt;c4&gt;&lt;s5&gt;in&lt;/s5&gt;&lt;/c4&gt; loop sets the &lt;c6&gt;&lt;s7&gt;item&lt;/s7&gt;&lt;/c6&gt; constant to the next &lt;c8&gt;&lt;s9&gt;MediaItem&lt;/s9&gt;&lt;/c8&gt; in the array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各段階で、この&lt;c2&gt;&lt;s3&gt;for&lt;/s3&gt;&lt;/c2&gt;-&lt;c4&gt;&lt;s5&gt;in&lt;/s5&gt;&lt;/c4&gt;ループは&lt;c6&gt;&lt;s7&gt;item&lt;/s7&gt;&lt;/c6&gt;定数を次の&lt;c8&gt;&lt;s9&gt;MediaItem&lt;/s9&gt;&lt;/c8&gt;に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On those occasions, you can write &lt;c0&gt;&lt;s1&gt;try!&lt;/s1&gt;&lt;/c0&gt; before the expression to disable error propagation and wrap the call in a runtime assertion that no error will be thrown.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの場合には、あなたは&lt;c0&gt;&lt;s1&gt;try!&lt;/s1&gt;&lt;/c0&gt;をその式の前に書くことによって、エラー伝達を抑制して、エラーはスローされないという実行時表明の中にその呼び出しを包み込みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once &lt;c4&gt;&lt;s5&gt;directionToHead&lt;/s5&gt;&lt;/c4&gt; is declared as a &lt;c6&gt;&lt;s7&gt;CompassPoint&lt;/s7&gt;&lt;/c6&gt;, you can set it to a different &lt;c8&gt;&lt;s9&gt;CompassPoint&lt;/s9&gt;&lt;/c8&gt; value using a shorter dot syntax:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一旦&lt;c4&gt;&lt;s5&gt;directionToHead&lt;/s5&gt;&lt;/c4&gt;が、ある&lt;c6&gt;&lt;s7&gt;CompassPoint&lt;/s7&gt;&lt;/c6&gt;として宣言されるならば、あなたはそれをより短いドット構文を使って、異なる&lt;c8&gt;&lt;s9&gt;CompassPoint&lt;/s9&gt;&lt;/c8&gt;値に設定することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once a constant property is assigned a value, it can’t be further modified.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いったん定数プロパティが値を割り当てられるならば、それはそれ以上変更されることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once it completes the sorting process, the &lt;c2&gt;&lt;s3&gt;sorted(by:)&lt;/s3&gt;&lt;/c2&gt; method returns a new array of the same type and size as the old one, with its elements in the correct sorted order.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一旦それがソート処理を完了するならば、&lt;c2&gt;&lt;s3&gt;sorted(by:)&lt;/s3&gt;&lt;/c2&gt;メソッドは、古いものと同じ型と大きさの新しい配列を返します、そしてその要素は正しく分類された順序を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the counter reaches zero, no more counting takes place:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとたびcounterがゼロに達するならば、それ以上数えることは起こりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the initial state for every stored property has been determined, the second phase begins, and each class is given the opportunity to customize its stored properties further before the new instance is considered ready for use.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一旦あらゆる格納プロパティのための最初の状態が決定されるならば、第２の段階が始まります、そして各クラスは、新しいインスタンスが使用する準備ができているとみなされる前に、さらにその格納プロパティを好みに合わせて作り変える機会を与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the superclass’s designated initializer is finished, the subclass’s designated initializer can perform additional customization (although again, it does not have to).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一旦スーパークラスの指定イニシャライザが作業をし終えるならば、サブクラスの指定イニシャライザは追加の改良を実行することができます（しかし再び、そうしなければならない訳ではない）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the top of the chain is reached, and the final class in the chain has ensured that all of its stored properties have a value, the instance’s memory is considered to be fully initialized, and phase 1 is complete.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いったん連鎖の最上部に届き、そして連鎖の中の最終的なクラスがその格納プロパティの全てが値を持つことを確実にしたならば、インスタンスのメモリは充分に初期化されるとみなされます、そして、第１段階は完了です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once you define a type alias, you can use the alias anywhere you might use the original name:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一旦あなたがある型エイリアスを定義するならば、あなたが本来の名前を使うであろうどこにでも、あなたはそのエイリアスを使用することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once you specify a type parameter, you can use it to define the type of a function’s parameters (such as the &lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;b&lt;/s3&gt;&lt;/c2&gt; parameters of the &lt;c4&gt;&lt;s5&gt;swapTwoValues(_:_:)&lt;/s5&gt;&lt;/c4&gt; function), or as the function’s return type, or as a type annotation within the body of the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一旦あなたが型パラメータを指定するならば、あなたはそれを、関数のパラメータの型を定義するために（例えば、 &lt;c4&gt;&lt;s5&gt;swapTwoValues(_:_:)&lt;/s5&gt;&lt;/c4&gt;関数の&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;b&lt;/s3&gt;&lt;/c2&gt;パラメータのように）、または関数の戻り型として、あるいは関数の本文内の型注釈として使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once you’re sure that the optional &lt;e0&gt;does&lt;/e0&gt; contain a value, you can access its underlying value by adding an exclamation point (&lt;c1&gt;&lt;s2&gt;!&lt;/s2&gt;&lt;/c1&gt;) to the end of the optional’s name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一旦あなたがそのオプショナルが値を含んで&lt;e0&gt;いる&lt;/e0&gt;ことを確かめたなら、あなたは感嘆符（&lt;c1&gt;&lt;s2&gt;!&lt;/s2&gt;&lt;/c1&gt;）をオプショナルの名前の終わりに加えることによって、それに内在する値にアクセスすることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once you’ve declared a constant or variable of a certain type, you can’t declare it again with the same name, or change it to store values of a different type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一旦あなたが特定の型のある定数または変数を宣言してしまったならば、あなたは同じ名前でもう一度それを宣言し直すこと、またはそれを異なる型の値を格納するように変更することは出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One consequence of this long-term write access is that you can’t access the original variable that was passed as in-out, even if scoping rules and access control would otherwise permit it—any access to the original creates a conflict.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この長期書き込みアクセスの１つの帰結として、あなたはin-outとして渡された元の変数にアクセス出来ません、たとえスコープ規則とアクセス制御がその他の点ではそれを許すとしてもです — 元のものに対するどんなアクセスも衝突を作り出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One convenience initializer calls another convenience initializer, which in turn calls the single designated initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>１つの便宜イニシャライザは、別の便宜イニシャライザを呼びます、それは、今度は１つだけある指定イニシャライザを呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One example is the &lt;e3&gt;addition assignment operator&lt;/e3&gt; (&lt;c4&gt;&lt;s5&gt;+=&lt;/s5&gt;&lt;/c4&gt;):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>１つの例は、&lt;e3&gt;加算代入演算子&lt;/e3&gt;（&lt;c4&gt;&lt;s5&gt;+=&lt;/s5&gt;&lt;/c4&gt;）です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One kilometer is the same as 1,000 meters, so the &lt;c0&gt;&lt;s1&gt;km&lt;/s1&gt;&lt;/c0&gt; computed property multiplies the value by &lt;c2&gt;&lt;s3&gt;1_000.00&lt;/s3&gt;&lt;/c2&gt; to convert into a number expressed in meters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>１キロメートルは1,000メートルと同じものですので、&lt;c0&gt;&lt;s1&gt;km&lt;/s1&gt;&lt;/c0&gt;計算プロパティは&lt;c2&gt;&lt;s3&gt;1_000.00&lt;/s3&gt;&lt;/c2&gt;を掛けられて、メートルで表される数に変換されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of the most important differences between structures and classes is that structures are always copied when they are passed around in your code, but classes are passed by reference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体とクラスの間の１つの最も重要な違いは、それらがあなたのコードにおいてあちこち渡されるとき、構造体は常にコピーされるということです、それに対してクラスは参照によって渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of these classes is defined as internal, and the other is defined as private.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらのクラスのうちの１つは内部として定義されます、そして別のものは非公開として定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of these two branches is always executed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの２つの分岐のうちの１つは、常に実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One way is to use &lt;c0&gt;&lt;s1&gt;do&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;catch&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>１つの方法は、&lt;c0&gt;&lt;s1&gt;do&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;catch&lt;/s3&gt;&lt;/c2&gt;を使うことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One way that a closure can escape is by being stored in a variable that is defined outside the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャが脱出できる１つの方法は、関数の外側で定義される変数に格納されることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One way to fix &lt;c8&gt;&lt;s9&gt;invalidFlip(_:)&lt;/s9&gt;&lt;/c8&gt; is to move the special case for squares into the implementation of &lt;c10&gt;&lt;s11&gt;FlippedShape&lt;/s11&gt;&lt;/c10&gt;, which lets this function always return a &lt;c12&gt;&lt;s13&gt;FlippedShape&lt;/s13&gt;&lt;/c12&gt; value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c8&gt;&lt;s9&gt;invalidFlip(_:)&lt;/s9&gt;&lt;/c8&gt;を修正する１つの方法は、正方形の特別な事例を&lt;c10&gt;&lt;s11&gt;FlippedShape&lt;/s11&gt;&lt;/c10&gt;の実装へと移動することです、それはこの関数に常に&lt;c12&gt;&lt;s13&gt;FlippedShape&lt;/s13&gt;&lt;/c12&gt;値を返させます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One way to provide the sorting closure is to write a normal function of the correct type, and to pass it in as an argument to the &lt;c0&gt;&lt;s1&gt;sorted(by:)&lt;/s1&gt;&lt;/c0&gt; method:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ソート・クロージャを提供する１つの方法は、通常の関数を正しい型で記述することです、そしてそれを１つの引数として&lt;c0&gt;&lt;s1&gt;sorted(by:)&lt;/s1&gt;&lt;/c0&gt;メソッドに渡すことになります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One way to solve this conflict is to make an explicit copy of &lt;c0&gt;&lt;s1&gt;stepSize&lt;/s1&gt;&lt;/c0&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この衝突を解決する１つの方法は、明示的に&lt;c0&gt;&lt;s1&gt;stepSize&lt;/s1&gt;&lt;/c0&gt;のコピーを作ることです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One-Sided Ranges</seg>
      </tuv>
      <tuv lang="JA">
        <seg>片側範囲</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One-sided ranges can be used in other contexts, not just in subscripts.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>片側範囲は、添え字とは違い、他の文脈で使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only the compound assignment operators can be overloaded.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複合代入演算子だけが、オーバーロードされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only throwing functions can propagate errors.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スロー関数だけがエラーを伝えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Opaque Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>不透明型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Opaque Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>不透明型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Opaque types appear as the return type of a function or subscript, or the type of a property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>不透明型は、関数または添え字の戻り型、またはあるプロパティの型として現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Opaque types can’t appear as part of a tuple type or a generic type, such as the element type of an array or the wrapped type of an optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>不透明型は、タプル型または総称体型の一部として現れることができません、たとえば配列の要素型、またはオプショナルのラップ型などの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Opaque types have the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>不透明型は以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open access applies only to classes and class members, and it differs from public access by allowing code outside the module to subclass and override, as discussed below in &lt;a0&gt;&lt;s1&gt;Subclassing&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>解放アクセスは、クラスとクラスメンバにのみ適用されます、そしてそれは公開アクセスとは、モジュールの外側のコードにサブクラス作成およびオーバーライドをさせることによって異なります、下の&lt;a0&gt;&lt;s1&gt;サブクラスをつくる&lt;/s1&gt;&lt;/a0&gt;で議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open access is the highest (least restrictive) access level and private access is the lowest (most restrictive) access level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>開放アクセスは最も高い（制限の最も少ない）アクセス水準であり、非公開アクセスは最も低い（制限の最も多い）アクセス水準です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator &lt;e0&gt;associativity&lt;/e0&gt; defines how operators of the same precedence are grouped together—either grouped from the left, or grouped from the right.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子&lt;e0&gt;結合性&lt;/e0&gt;は、同じ優先順位の演算子がまとめられる方法を定義します ― 左からまとめられるか右からまとめられるかのどちらか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator &lt;e0&gt;precedence&lt;/e0&gt; gives some operators higher priority than others; these operators are applied first.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;演算子優先順位&lt;/e0&gt;は、ある演算子に他のものよりも高い優先権を与えます；これらの演算子は最初に適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator Methods</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operator functions for &lt;a0&gt;&lt;s1&gt;Compound Assignment Operators&lt;/s1&gt;&lt;/a0&gt; no longer use the &lt;c2&gt;&lt;s3&gt;@assignment&lt;/s3&gt;&lt;/c2&gt; attribute when defining the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;複合代入演算子&lt;/s1&gt;&lt;/a0&gt;のための演算子関数は、もはや関数を定義する時に&lt;c2&gt;&lt;s3&gt;@assignment&lt;/s3&gt;&lt;/c2&gt;属性を使いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators are unary, binary, or ternary:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子には、単項、二項、または三項があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators from those precedence groups can’t be used next to each other without grouping parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの優先順位グループ由来の演算子は、グループ化括弧なしで互いにすぐ隣に使われることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that are left-associative group left-to-right.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>左結合である演算子は、左から右へとグループにまとめられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Operators that are right-associative group right-to-left, and operators that are specified with an associativity of &lt;c25&gt;&lt;s26&gt;none&lt;/s26&gt;&lt;/c25&gt; don’t associate at all.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>右結合の演算子は右から左にグループにされます、そして&lt;c25&gt;&lt;s26&gt;none&lt;/s26&gt;&lt;/c25&gt;の関係性を指定される演算子は全く結合しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional Binding</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルを束縛する（定数・変数と結び付ける）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional Chaining</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional Chaining as an Alternative to Forced Unwrapping</seg>
      </tuv>
      <tuv lang="JA">
        <seg>強制アンラップに代わるものとしてのオプショナル連鎖</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional Pattern</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルパターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional Property Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルプロパティ型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional Protocol Requirements</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルのプロトコル要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional Tuple Return Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルタプルの戻り型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional binding can be used with &lt;c1&gt;&lt;s2&gt;if&lt;/s2&gt;&lt;/c1&gt; and &lt;c3&gt;&lt;s4&gt;while&lt;/s4&gt;&lt;/c3&gt; statements to check for a value inside an optional, and to extract that value into a constant or variable, as part of a single action.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル束縛は、&lt;c1&gt;&lt;s2&gt;if&lt;/s2&gt;&lt;/c1&gt;や&lt;c3&gt;&lt;s4&gt;while&lt;/s4&gt;&lt;/c3&gt;文と一緒に使用して、オプショナルの内部の値を確認すること、そしてその値を定数または変数に抽出することを、一回の動作で可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional chaining in Swift is similar to messaging &lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt; in Objective-C, but in a way that works for any type, and that can be checked for success or failure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにおけるオプショナル連鎖は、どんな型のためにでも働きそして成功か失敗を確認されることができるというようなことを除いて、Objective-Cにおける&lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;にメッセージを送ることに似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional chaining provides an alternative way to access the value of &lt;c0&gt;&lt;s1&gt;numberOfRooms&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖は、&lt;c0&gt;&lt;s1&gt;numberOfRooms&lt;/s1&gt;&lt;/c0&gt;の値にアクセスする代わりの方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional patterns consist of an identifier pattern followed immediately by a question mark and appear in the same places as enumeration case patterns.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルパターンは、１つの識別子パターンに直接に１つの疑問符が続くものから成ります、そして列挙ケース節パターンと同じ場所に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional requirements are available so that you can write code that interoperates with Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル要件が利用可能なことから、あなたはObjective-Cと相互運用するコードを書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional requirements are prefixed by the &lt;c1&gt;&lt;s2&gt;optional&lt;/s2&gt;&lt;/c1&gt; modifier as part of the protocol’s definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルの要件は、そのプロトコル定義において&lt;c1&gt;&lt;s2&gt;optional&lt;/s2&gt;&lt;/c1&gt;修飾子を前に置かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional syntactic categories and literals are marked by a trailing subscript, &lt;e0&gt;opt&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>任意である統語論のカテゴリーとリテラルは後に続く下つき文字、&lt;e0&gt;opt&lt;/e0&gt;によって印されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional-Chaining Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional-chaining expressions must appear within a postfix expression, and they cause the postfix expression to be evaluated in a special way.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖式は、接尾辞式の中に現れなければなりません、そしてそれはその接尾辞式を特別なやり方で評価されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optionals</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optionals are used to represent the absence of a value, but when an operation fails, it’s often useful to understand what caused the failure, so that your code can respond accordingly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルは、ある値の欠如を表すために使われます、しかしある操作が失敗する時、何がその失敗をもたらしたのか理解するのはしばしば役に立ちます、それであなたのコードはそれに適切に応答することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optionals can be checked with an &lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt; statement to see if a value exists, and can be conditionally unwrapped with optional binding to access the optional’s value if it does exist.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルは、値が存在しているかどうか見るために、&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt;文を使って調べられることが出来ます、そしてオプショナルの持つ値にそれが存在するならばアクセスするために、オプショナル束縛を使って条件に応じてアンラップされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optionals ensure that &lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt; values are handled explicitly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルが、&lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;値が明確に取り扱われるのを確実にする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optionals of &lt;e8&gt;any&lt;/e8&gt; type can be set to &lt;c9&gt;&lt;s10&gt;nil&lt;/s10&gt;&lt;/c9&gt;, not just object types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e8&gt;すべての&lt;/e8&gt;型のオプショナルが、&lt;c9&gt;&lt;s10&gt;nil&lt;/s10&gt;&lt;/c9&gt;に設定されることができます、単にオブジェクト型だけでなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optionals say either “there &lt;e0&gt;is&lt;/e0&gt; a value, and it equals &lt;e1&gt;x&lt;/e1&gt;” or “there &lt;e2&gt;isn’t&lt;/e2&gt; a value at all”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルであるものは、「ひとつの値が&lt;e0&gt;ある&lt;/e0&gt;、そしてそれは&lt;e1&gt;x&lt;/e1&gt;に等しい」または「まったく値が&lt;e2&gt;ない&lt;/e2&gt;」のどちらかを伝えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other Swift functions can’t be converted to the C calling convention.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他のスウィフト関数は、C呼出規約に変換されることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other named types can only inherit from or conform to a list of protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の名前付きの型は、プロトコルのリストから継承し準拠することだけができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other products are labeled with 2D barcodes in QR code format, which can use any ISO 8859-1 character and can encode a string up to 2,953 characters long:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>別の製品はQRコード形式の二次元バーコードでラベルをつけられます、それはどんなISO 8859-1の文字でも使うことができて、2,953文字までの長さの文字列をコード化することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other units require some conversion to be expressed as a value measured in meters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の単位は、メートルで計られる値として表されるためにいくらかの変換を必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other valid versions of this function could return values of different types when flipping multiple instances of the same shape.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数の他の有効なバージョンそれらは、異なる型の値を返すことが、同じ形状の複数のインスタンスを裏返す時にありえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, &lt;c8&gt;&lt;s9&gt;nourish(with:)&lt;/s9&gt;&lt;/c8&gt; propagates the error to its call site.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうでなければ、&lt;c8&gt;&lt;s9&gt;nourish(with:)&lt;/s9&gt;&lt;/c8&gt;はそのエラーをそれの呼出地点へと伝達します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, a runtime error is raised.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうでなければ、実行時エラーが引き起こされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, it evaluates the second expression and returns its value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうでなければ、それは第二の式を評価して、その値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, no message is printed, and code execution continues after the &lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt; statement’s closing brace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうでなければ、メッセージは出力されません、そしてコードの実行は&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt;文の閉じ波括弧の後に続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the &lt;c12&gt;&lt;s13&gt;species&lt;/s13&gt;&lt;/c12&gt; property’s value is set, and initialization succeeds:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうでなければ、&lt;c12&gt;&lt;s13&gt;species&lt;/s13&gt;&lt;/c12&gt;プロパティの値は設定されて、初期化は成功します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the closure expression is escaping.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それ以外では、クロージャ式は脱出です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the error can propagate out of the containing scope, which means the error must be handled by an enclosing &lt;c4&gt;&lt;s5&gt;catch&lt;/s5&gt;&lt;/c4&gt; clause or the containing function must be declared with &lt;c6&gt;&lt;s7&gt;throws&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうでなければ、エラーはそれを収容しているスコープの外に伝えられることができます、それが意味するのは、エラーは囲んでいる&lt;c4&gt;&lt;s5&gt;catch&lt;/s5&gt;&lt;/c4&gt;節によって取り扱われなければならない、または収容している関数が&lt;c6&gt;&lt;s7&gt;throws&lt;/s7&gt;&lt;/c6&gt;で宣言されなければならないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the initializer has an access level of internal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうでなければ、イニシャライザは内部のアクセス水準を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the nested function is an escaping function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それ以外では、入れ子にされた関数は脱出関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the optional value is unwrapped and assigned to the constant after &lt;c4&gt;&lt;s5&gt;let&lt;/s5&gt;&lt;/c4&gt;, which makes the unwrapped value available inside the block of code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうでなければ、そのオプショナルの値は包装を取られて（アンラップされて）、&lt;c4&gt;&lt;s5&gt;let&lt;/s5&gt;&lt;/c4&gt;の後の定数に代入されます、そしてそれはコードのブロックの内側で利用できる包装を取られた値（アンラップ値）になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the optional value is unwrapped, and everything after the &lt;c10&gt;&lt;s11&gt;?&lt;/s11&gt;&lt;/c10&gt; acts on the unwrapped value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうでなければ、オプショナルの値は包装を取られます（アンラップされます）、そして&lt;c10&gt;&lt;s11&gt;?&lt;/s11&gt;&lt;/c10&gt;の後のすべてのものは包装を取られた値（アンラップ値）に作用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the program does not perform assignment or execute the &lt;e13&gt;statements&lt;/e13&gt;, and it is finished executing the &lt;c14&gt;&lt;s15&gt;for&lt;/s15&gt;&lt;/c14&gt;-&lt;c16&gt;&lt;s17&gt;in&lt;/s17&gt;&lt;/c16&gt; statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうでなければ、プログラムは代入を実行しませんし、&lt;e13&gt;文&lt;/e13&gt;を実行しません、そしてそれは&lt;c14&gt;&lt;s15&gt;for&lt;/s15&gt;&lt;/c14&gt;-&lt;c16&gt;&lt;s17&gt;in&lt;/s17&gt;&lt;/c16&gt;文の実行を終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the result is an optional containing the value that the function returned.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうでなければ、結果は関数が返した値を含んでいるオプショナルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the square’s value is &lt;c0&gt;&lt;s1&gt;0&lt;/s1&gt;&lt;/c0&gt;, and it’s a “free” square, represented by &lt;c2&gt;&lt;s3&gt;○&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一方、正方形の値は&lt;c0&gt;&lt;s1&gt;0&lt;/s1&gt;&lt;/c0&gt;ならば、それは「自由」な正方形であって、&lt;c2&gt;&lt;s3&gt;○&lt;/s3&gt;&lt;/c2&gt;によって表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the subscript returns &lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうでなければ、添え字は&lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the value of &lt;c8&gt;&lt;s9&gt;x&lt;/s9&gt;&lt;/c8&gt; and &lt;c10&gt;&lt;s11&gt;y&lt;/s11&gt;&lt;/c10&gt; is the value that the function returned.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうでなければ、&lt;c8&gt;&lt;s9&gt;x&lt;/s9&gt;&lt;/c8&gt;と&lt;c10&gt;&lt;s11&gt;y&lt;/s11&gt;&lt;/c10&gt;の値はこの関数が返す値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the value of the optional-try expression is &lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうでなければ、オプショナルtry式の値は&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, when set to &lt;c3&gt;&lt;s4&gt;false&lt;/s4&gt;&lt;/c3&gt; or omitted, operators in the precedence group follows the same optional chaining rules as operators that don’t perform assignment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうせずに、&lt;c3&gt;&lt;s4&gt;false&lt;/s4&gt;&lt;/c3&gt;に設定するか省略する場合は、その優先順位グループの演算子は代入を実行しない演算子と同じオプショナル連鎖規則に従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Our goals for Swift are ambitious.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのための私達のゴールは、野心的です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Outside the context in which they appear in the grammar, they can be used as identifiers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そこにおいてそれらが文法の中に現れる文脈外では、それらは識別子として使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overflow Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オーバフロー演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overflow addition (&lt;c0&gt;&lt;s1&gt;&amp;+&lt;/s1&gt;&lt;/c0&gt;)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オーバフロー加算（&lt;c0&gt;&lt;s1&gt;&amp;+&lt;/s1&gt;&lt;/c0&gt;）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overflow also occurs for signed integers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オーバフローはまた、符号つき整数に対しても起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overflow behavior is trapped and reported as an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オーバフロー挙動は、エラーとして捕まえられて報告されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overflow multiplication (&lt;c0&gt;&lt;s1&gt;&amp;*&lt;/s1&gt;&lt;/c0&gt;)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オーバフロー乗算（&lt;c0&gt;&lt;s1&gt;&amp;*&lt;/s1&gt;&lt;/c0&gt;）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overflow subtraction (&lt;c0&gt;&lt;s1&gt;&amp;-&lt;/s1&gt;&lt;/c0&gt;)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オーバフロー減算（&lt;c0&gt;&lt;s1&gt;&amp;-&lt;/s1&gt;&lt;/c0&gt;）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overlapping accesses appear primarily in code that uses in-out parameters in functions and methods or mutating methods of a structure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オーバーラップするアクセスは、関数およびメソッドにおいてまたは構造体の変更メソッドにおいてin-outパラメータを使うコードに主に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overridden Requirements Aren’t Used in Some Generic Contexts</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オーバーライドされた要件はいくつかの総称体文脈では使われません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overridden properties, methods, subscripts, and designated initializers must be marked with the &lt;c0&gt;&lt;s1&gt;override&lt;/s1&gt;&lt;/c0&gt; declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティ、メソッド、添え字、そして指定イニシャライザのオーバーライドは、&lt;c0&gt;&lt;s1&gt;override&lt;/s1&gt;&lt;/c0&gt;宣言修飾子で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overriding</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overriding Methods</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッドのオーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overriding Properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティのオーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overriding Property Getters and Setters</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティゲッターとセッターのオーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overriding Property Observers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティオブザーバーのオーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overriding a Failable Initializer</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗できるイニシャライザのオーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overriding by accident can cause unexpected behavior, and any overrides without the &lt;c2&gt;&lt;s3&gt;override&lt;/s3&gt;&lt;/c2&gt; keyword are diagnosed as an error when your code is compiled.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>誤って偶然にオーバーライドすることは予想外の挙動を引き起こすことがありえます、なので、あなたのコードがコンパイルされるとき、&lt;c2&gt;&lt;s3&gt;override&lt;/s3&gt;&lt;/c2&gt;キーワードのないどんなオーバーライドもエラーとして診断されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overusing autoclosures can make your code hard to understand.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>自動クロージャの使いすぎは、あなたのコードを理解しにくくする可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameter Names</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータ名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameter Names and Argument Labels</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータ名と引数ラベル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameters can be ignored, take a variable number of values, and provide default values using the following forms:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータは、無視されること、可変の数の値をとること、そして以下の形式を使って省略時の値を提供することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameters can provide default values to simplify function calls and can be passed as in-out parameters, which modify a passed variable once the function has completed its execution.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータは、関数呼び出しを単純化するために初期値を提供することができます、そしてひとたび関数がその実行を完了し終えれば渡された変数を修正するin-outパラメータとして渡されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parameters that don’t have default values are usually more important to the function’s meaning—writing them first makes it easier to recognize that the same function is being called, regardless of whether any default parameters are omitted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時の値を持たないパラメータは、関数の意味するところにとって通常より重要です—それらを最初に書くことは、何らかの省略時のパラメータが省かれているかどうかに関係なく、同じ関数が呼び出されているのをよりわかり易くします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parentheses around the condition or loop variable are optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>条件またはループ変数のまわりの丸括弧は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parenthesized Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>括弧に入れられた式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Part of the functionality of the &lt;c0&gt;&lt;s1&gt;DataManager&lt;/s1&gt;&lt;/c0&gt; class is the ability to import data from a file.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;DataManager&lt;/s1&gt;&lt;/c0&gt;クラスの機能性の一部は、データをファイルからインポートする能力です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Passing &lt;c0&gt;&lt;s1&gt;birthdayPerson&lt;/s1&gt;&lt;/c0&gt; to the &lt;c2&gt;&lt;s3&gt;beginConcert(in:)&lt;/s3&gt;&lt;/c2&gt; function is invalid because &lt;c4&gt;&lt;s5&gt;Person&lt;/s5&gt;&lt;/c4&gt; isn’t a subclass of &lt;c6&gt;&lt;s7&gt;Location&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;birthdayPerson&lt;/s1&gt;&lt;/c0&gt;を&lt;c2&gt;&lt;s3&gt;beginConcert(in:)&lt;/s3&gt;&lt;/c2&gt;関数に渡すことは無効です、なぜなら&lt;c4&gt;&lt;s5&gt;Person&lt;/s5&gt;&lt;/c4&gt;は&lt;c6&gt;&lt;s7&gt;Location&lt;/s7&gt;&lt;/c6&gt;のサブクラスではないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Patterns</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Performing Set Operations</seg>
      </tuv>
      <tuv lang="JA">
        <seg>集合演算の実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Phase 1</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第１段階</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Phase 2</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第２段階</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Place parameters that don’t have default values at the beginning of a function’s parameter list, before the parameters that have default values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時の値を持たないパラメータを関数のもつパラメータリストの始まりに、省略時の値を持つパラメータの前に、置いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Place the capture list before a closure’s parameter list and return type if they are provided:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらが提供されるならばクロージャのパラメータ・リストと戻り型の前に、捕獲リストを置いてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Platform condition</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プラットホーム条件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Playground literals in plain text outside of Xcode are represented using a special literal syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Xcodeの外部のプレーンテキストの中のプレイグラウンドリテラルは、特別なリテラル構文を使って表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Playgrounds allow you to edit the code listings and see the result immediately.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プレイグラウンドは、あなたがコードリストを編集してすぐにその結果を見られるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pointers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ポインター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Popping a value from the stack removes and returns the top value, &lt;c0&gt;&lt;s1&gt;"cuatro"&lt;/s1&gt;&lt;/c0&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このスタックから値をボップすることは、一番上の値、&lt;c0&gt;&lt;s1&gt;"cuatro"&lt;/s1&gt;&lt;/c0&gt;を削除して、返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Positive numbers are stored in exactly the same way as for unsigned integers, counting upwards from &lt;c1&gt;&lt;s2&gt;0&lt;/s2&gt;&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>正の数は符号なし整数と正確に同じ方法で格納されて、&lt;c1&gt;&lt;s2&gt;0&lt;/s2&gt;&lt;/c1&gt;から上方へ数えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Postfix Expressions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接尾辞表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Postfix Self Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接尾辞self式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Postfix expressions, like prefix and binary expressions, let you build up more complex expressions using postfixes such as function calls and member access.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接尾辞式は、接頭辞や二項の式に似て、関数呼び出しやメンバー・アクセスのような接尾辞を使うことで、あなたにより複雑な式を組み立てさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Postfix operators are nonassociative.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接尾辞演算子は非結合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Precedence Group Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>優先順位グループ定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Precedence and Associativity</seg>
      </tuv>
      <tuv lang="JA">
        <seg>優先順位と結合性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Precedence for Custom Infix Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あつらえの接中辞演算子の優先順位</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Precedence groups related to each other using &lt;e0&gt;lower group names&lt;/e0&gt; and &lt;e1&gt;higher group names&lt;/e1&gt; must fit into a single relational hierarchy, but they &lt;e2&gt;don’t&lt;/e2&gt; have to form a linear hierarchy.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;下方グループ名&lt;/e0&gt;と&lt;e1&gt;上方グループ名&lt;/e1&gt;を使って互いに関係のある優先順位グループは、単一の関係階層へはめ込まなければなりません、しかしそれらは線形階層を形作る必要は&lt;e2&gt;ありません&lt;/e2&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Prefix Expressions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接頭辞式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Prefix and Postfix Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接頭辞と接尾辞演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Prefix and Suffix Equality</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接頭辞と接尾辞等式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Prefix and binary expressions let you apply operators to smaller expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接頭辞と二項式は、あなたに演算子をより小さい式に適用させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Prefix operators are nonassociative.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接頭辞演算子は非結合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Prefix operators declarations don’t specify a precedence level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接頭辞演算子宣言は、優先順位レベルを指定しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Prefix operators take one argument, the expression that follows them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接頭辞演算子は、１つの引数（それらの後に続く式）をとります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Preventing Overrides</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オーバーライドを防ぐ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Primary Expressions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>基本式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Primary expressions are conceptually the simplest kind of expression, and they provide a way to access values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>基本式は、概念的に最も単純な種類の式で、それらはアクセス手段をさまざまな値に提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Printing Constants and Variables</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数と変数を出力する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Printing the description of each item in the array shows that their default states have been set as expected.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列の各項目の説明を出力することは、予想されるようにそれらの省略時の状態が設定されたことを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Private Members in Extensions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張の中の非公開メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Private members declared in the type’s declaration can be accessed from extensions, and private members declared in one extension can be accessed from other extensions and from the type’s declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型の持つ宣言において宣言される非公開メンバは拡張からアクセスできます、そして一方の拡張において宣言される非公開メンバは他方の拡張からそしてその型のもつ宣言からアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Program execution continues at the point immediately following the function or method call.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プログラム実行は、関数またはメソッド呼び出しに直ちに続いている地点に続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Program execution continues to the next case even if the patterns of the case label do not match the value of the &lt;c10&gt;&lt;s11&gt;switch&lt;/s11&gt;&lt;/c10&gt; statement’s control expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえケース節ラベルのパターンが&lt;c10&gt;&lt;s11&gt;switch&lt;/s11&gt;&lt;/c10&gt;文のもつ制御式の値にマッチしないとしても、プログラム実行は次のケース節に続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Program execution does not continue or “fall through” to the next case or default case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プログラム実行は続きません、あるいは、次のケース節または省略時のケース節に「抜け落ちる」ことはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Projecting a Value From a Property Wrapper</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値をプロパティラッパーから予測する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Propagating Errors Using Throwing Functions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スロー関数を使ってエラーを伝える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Propagation of Initialization Failure</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期化失敗の伝播</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Properties can only be accessed, and methods can only be called, once the class instance is known to be valid at the end of the first phase.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一旦クラスインスタンスが第１段階の終わりに有効であるということを知られる場合にのみ、プロパティはアクセスされることができ、そしてメソッドは呼ばれることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Properties of a structure instance can be accessed using dot (&lt;c0&gt;&lt;s1&gt;.&lt;/s1&gt;&lt;/c0&gt;) syntax, as described in &lt;a2&gt;&lt;s3&gt;Accessing Properties&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスインスタンスのプロパティにドット（&lt;c0&gt;&lt;s1&gt;.&lt;/s1&gt;&lt;/c0&gt;）構文でアクセスされることができます、&lt;a2&gt;&lt;s3&gt;プロパティにアクセスする&lt;/s3&gt;&lt;/a2&gt;で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Properties of optional type are automatically initialized with a value of &lt;c1&gt;&lt;s2&gt;nil&lt;/s2&gt;&lt;/c1&gt;, indicating that the property is deliberately intended to have “no value yet” during initialization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルの型のプロパティは、&lt;c1&gt;&lt;s2&gt;nil&lt;/s2&gt;&lt;/c1&gt;の値で自動的に初期化されて、そのプロパティは初期化の時には「まだ無い値」を故意に持つつもりであることを示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Properties, methods, and initializers of an existing type can’t be overridden in an extension of that type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>既存の型のプロパティ、メソッド、そしてイニシャライザは、その型の拡張においてオーバーライドされることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Property Observers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティオブザーバー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Property Requirements</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティ要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Property Wrappers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティラッパー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Property observers are called every time a property’s value is set, even if the new value is the same as the property’s current value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティオブザーバーは、あるプロパティの値が設定されるたびに、たとえ新しい値がそのプロパティの現在の値と同じものであるとしても、呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Property observers aren’t called when ARC sets a weak reference to &lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティオブザーバーは、ARCが弱い参照を&lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;に設定するとき呼び出されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Property observers can be added to any property, regardless of whether it was originally defined as a stored or computed property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティオブザーバーは、どんなプロパティにでも加えられることができます、それが格納または計算プロパティとして元々定義されたかどうかは関係ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Property observers can be added to stored properties you define yourself, and also to properties that a subclass inherits from its superclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティオブザーバーは、あなたがあなた自身で定義する格納プロパティに、そのうえにサブクラスがそのスーパークラスから継承するプロパティにも加えられることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Property observers observe and respond to changes in a property’s value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティオブザーバーは、あるプロパティの値の変化を観察して、応答します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Property overriding is described in &lt;a0&gt;&lt;s1&gt;Overriding&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティをオーバーライドすることは&lt;a0&gt;&lt;s1&gt;オーバーライド&lt;/s1&gt;&lt;/a0&gt;で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Property requirements are always declared as variable properties, prefixed with the &lt;c0&gt;&lt;s1&gt;var&lt;/s1&gt;&lt;/c0&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティ要件は常に変数プロパティとして宣言されます、それで&lt;c0&gt;&lt;s1&gt;var&lt;/s1&gt;&lt;/c0&gt;キーワードを前に置かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol Associated Type Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル関連型宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol Composition</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル合成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol Composition Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル合成型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol Conformance</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル準拠</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol Conformance Must Not Be Redundant</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル準拠は冗長であってはいけません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol Extensions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル拡張</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol Inheritance</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル継承</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol Initializer Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルイニシャライザ宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol Method Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルメソッド宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol Property Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルプロパティ宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol Subscript Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル添え字宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol Syntax</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol casts are no longer limited to &lt;c0&gt;&lt;s1&gt;@objc&lt;/s1&gt;&lt;/c0&gt; protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルのキャストは、もはや&lt;c0&gt;&lt;s1&gt;@objc&lt;/s1&gt;&lt;/c0&gt;プロトコルに制限されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol composition types have the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル合成型は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol composition types may be used only when specifying a type in type annotations, in generic parameter clauses, and in generic &lt;c1&gt;&lt;s2&gt;where&lt;/s2&gt;&lt;/c1&gt; clauses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル合成型は、型注釈において、総称体パラメータ節において、そして総称体&lt;c1&gt;&lt;s2&gt;where&lt;/s2&gt;&lt;/c1&gt;節において型を指定する場合にのみ使われるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol compositions behave as if you defined a temporary local protocol that has the combined requirements of all protocols in the composition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル合成は、あなたが全てのプロトコルの要件を結合したものをその合成物の中に持っている一時的なローカルプロトコルを定義したかのように振る舞います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol compositions don’t define any new protocol types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル合成は、何ら新しいプロトコル型を定義しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol compositions have the form &lt;c0&gt;&lt;s1&gt;SomeProtocol&lt;/s1&gt; &lt;s2&gt;&amp;&lt;/s2&gt; &lt;s3&gt;AnotherProtocol&lt;/s3&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル合成は、形式&lt;c0&gt;&lt;s1&gt;SomeProtocol&lt;/s1&gt; &lt;s2&gt;&amp;&lt;/s2&gt; &lt;s3&gt;AnotherProtocol&lt;/s3&gt;&lt;/c0&gt;を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol declarations are declared at global scope using the &lt;c1&gt;&lt;s2&gt;protocol&lt;/s2&gt;&lt;/c1&gt; keyword and have the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル宣言は、グローバルなスコープでキーワード&lt;c1&gt;&lt;s2&gt;protocol&lt;/s2&gt;&lt;/c1&gt;を使って宣言されて、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol declarations can’t contain class, structure, enumeration, or other protocol declarations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル宣言は、クラス、構造体、列挙、または他のプロトコル宣言を含むことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol declarations can’t include opaque types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル宣言は、不透明型を含むことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol extensions can add implementations to conforming types but can’t make a protocol extend or inherit from another protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル拡張は、実装を加えることによって型に準拠が可能です、しかしあるプロトコルを別のプロトコルから拡張したり継承したりはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol inheritance is always specified in the protocol declaration itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル継承は、常にプロトコル宣言それ自体の中で指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol initializer declarations have the same form as initializer declarations, except they don’t include the initializer’s body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルイニシャライザ宣言は、それらがイニシャライザ本文を含めないことを除いて、イニシャライザ宣言と同じ形式を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol method declarations have the same form as function declarations, with two exceptions: They don’t include a function body, and you can’t provide any default parameter values as part of the function declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルメソッド宣言は、２つの例外を除いて、関数宣言と同じ形式を持ちます：それらは関数本体を含むことができません、そして、あなたは関数宣言の一部として省略時のパラメータ値をまったく提供することができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol property declarations have a special form of a variable declaration:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルプロパティ宣言は、変数宣言の特別な形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol requirements with default implementations provided by extensions are distinct from optional protocol requirements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張によって提供される省略時の実装を持つプロトコル要件は、オプショナルプロトコル要件とは異なったものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol subscript declarations have a special form of a subscript declaration:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル添え字宣言は、添え字宣言の特別な形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol types can inherit from any number of other protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル型は、いくらかの他のプロトコルから継承することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols and Extensions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルと拡張</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols are named types, and thus they can appear in all the same places in your code as other named types, as discussed in &lt;a0&gt;&lt;s1&gt;Protocols as Types&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは名前をつけられた型です、したがってそれらはあなたのコードにおいて他の名前をつけられた型と同じ場所の全てにおいて現れることができます、&lt;a0&gt;&lt;s1&gt;型としてのプロトコル&lt;/s1&gt;&lt;/a0&gt;で議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols as Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型としてのプロトコル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols can also declare special kinds of type aliases, called &lt;e1&gt;associated types&lt;/e1&gt;, that can specify relationships among the various declarations of the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルはまた、特別な種類の型エイリアス、そのプロトコルのいろいろな宣言の間での関係を指定することができる&lt;e1&gt;関連型&lt;/e1&gt;と呼ばれるものを宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols can be extended to provide method, initializer, subscript, and computed property implementations to conforming types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは拡張されることによって、準拠している型にメソッド、イニシャライザ、添え字、そして計算プロパティの実装を提供できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols can be restricted to a certain context, as can global constants, variables, and functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは特定の前後関係に制限されることができます、グローバルな定数、変数、そして関数も同じようにされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols can define failable initializer requirements for conforming types, as defined in &lt;a0&gt;&lt;s1&gt;Failable Initializers&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは、&lt;a0&gt;&lt;s1&gt;失敗できるイニシャライザ&lt;/s1&gt;&lt;/a0&gt;で記述されるように、準拠している型に対して失敗できるイニシャライザ要件を定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols can require specific initializers to be implemented by conforming types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは、準拠型によって特定のイニシャライザが実装されるように要求することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols can require specific instance methods and type methods to be implemented by conforming types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは、準拠型によって特定のインスタンスメソッドと型メソッドが実装されるように要求することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols declare associated types using the &lt;c0&gt;&lt;s1&gt;associatedtype&lt;/s1&gt;&lt;/c0&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは、関連型をキーワード&lt;c0&gt;&lt;s1&gt;associatedtype&lt;/s1&gt;&lt;/c0&gt;を使って宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols declare that conforming types must implement a method by including a protocol method declaration in the body of the protocol declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルが宣言するのは、準拠している型は、プロトコル宣言の本文中のプロトコルメソッド宣言を含めることによって、あるメソッドを実装する必要があるということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols declare that conforming types must implement a property by including a &lt;e0&gt;protocol property declaration&lt;/e0&gt; in the body of the protocol declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは、準拠している型がそのプロトコル宣言の本文の中の&lt;e0&gt;プロトコルプロパティ宣言&lt;/e0&gt;を含めることによってプロパティを実装しなければならないことを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols declare that conforming types must implement a subscript by including a protocol subscript declaration in the body of the protocol declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは、準拠している型がそのプロトコル宣言の本文の中のプロトコル添え字宣言を含めることによって添え字を実装しなければならないと宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols declare that conforming types must implement an initializer by including a protocol initializer declaration in the body of the protocol declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは、準拠している型がそのプロトコル宣言の本文の中のプロトコルイニシャライザ宣言を含めることによってイニシャライザを実装しなければならないと宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols don’t actually implement any functionality themselves.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは、実際に少しの機能性も実装しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocols that are marked with the &lt;c4&gt;&lt;s5&gt;objc&lt;/s5&gt;&lt;/c4&gt; attribute can’t inherit from protocols that aren’t marked with this attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;objc&lt;/s5&gt;&lt;/c4&gt;属性で印されるプロトコルは、この属性で印されないプロトコルから継承できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Provide new initializers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しいイニシャライザを提供する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Providing Default Implementations</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時の実装を提供する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Providing a value when you create a constant or variable lets the compiler infer its type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが定数または変数をつくる時に値を提供することは、コンパイラにその型を推論させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Providing error handling when values get too large or too small gives you much more flexibility when coding for boundary value conditions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値があまりに大きいかあまりに小さくなる時にエラー処理を提供することは、境界値条件のためのコードを書くとき、あなたにずっと多くの柔軟性を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Providing more detail limits which symbols are imported—you can specify a specific submodule or a specific declaration within a module or submodule.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より詳細な記述を提供することは、どのシンボルがインポートされるかを制限します ― あなたは、あるモジュールまたはサブモジュール内で、特定のサブモジュールまたは特定の宣言を指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Put another way, &lt;c10&gt;&lt;s11&gt;protoFlip(_:)&lt;/s11&gt;&lt;/c10&gt; makes a much looser API contract with its caller than &lt;c12&gt;&lt;s13&gt;flip(_:)&lt;/s13&gt;&lt;/c12&gt; makes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>言い換えれば、&lt;c10&gt;&lt;s11&gt;protoFlip(_:)&lt;/s11&gt;&lt;/c10&gt;は、それの呼び出し側とずっとゆるいAPI契約をします、&lt;c12&gt;&lt;s13&gt;flip(_:)&lt;/s13&gt;&lt;/c12&gt;がするよりも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Querying and Setting Type Properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型プロパティを問い合わせて、設定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Range Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>範囲演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rather than a copy, a reference to the same existing instance is used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コピーではなく、既存の同じインスタンスに対する参照が使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rather than moving the player immediately, the loop uses a &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; statement to consider the result of the move and to determine whether the move is allowed:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>直ちにプレーヤーを動かすのではなく、ループは&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;文を使うことで、移動の結果を考慮して、移動が許可されるかどうか判断します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rather than placing an exclamation point after the optional’s name when you use it, you place an exclamation point after the optional’s type when you declare it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがそれを使う時にそのオプショナルのもつ名前の後に感嘆符を置くよりも、あなたがそれを宣言する時にそのオプショナルのもつ型の後に感嘆符を書きたいとあなたは思うでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rather than returning an existing value, the getter actually calculates and returns a new &lt;c8&gt;&lt;s9&gt;Point&lt;/s9&gt;&lt;/c8&gt; to represent the center of the square.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>既存の値を返すのではなく、このゲッターは正方形の中心を表すために実際に計算して新しい&lt;c8&gt;&lt;s9&gt;Point&lt;/s9&gt;&lt;/c8&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rather, it reports a compile-time error that &lt;c8&gt;&lt;s9&gt;case&lt;/s9&gt; &lt;s10&gt;"a":&lt;/s10&gt;&lt;/c8&gt; does not contain any executable statements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうではなく、それは&lt;c8&gt;&lt;s9&gt;case&lt;/s9&gt; &lt;s10&gt;"a":&lt;/s10&gt;&lt;/c8&gt;が実行可能な文を何も含まないという、コンパイル時エラーを報告します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rather, their role is to ensure that &lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt; is fully and correctly initialized by the time that initialization ends.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>というより、それの役割は、初期化が終わるまでに&lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;が完全にそして正確に初期化されることを確実にすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Raw Values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>生の値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Raw Values and Associated Values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>生の値と関連値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Raw values are &lt;e0&gt;not&lt;/e0&gt; the same as associated values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>生の値は、関連値と同じもので&lt;e0&gt;ない&lt;/e0&gt;点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Raw values are set to prepopulated values when you first define the enumeration in your code, like the three ASCII codes above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>生の値は、上の３つのASCIIコードの様に、あなたがあなたのコードにおいて最初に列挙を定義するとき、あらかじめ入れられた値に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Raw values can be strings, characters, or any of the integer or floating-point number types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>生の値は、文字列、文字、または何らかの整数や浮動小数点数型であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read-Only Computed Properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>読み出し専用の計算プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Readability is always preferred over brevity; use parentheses where they help to make your intentions clear.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>読みやすさは、常に簡潔さよりも好まれます；それらがあなたの意図を明確にする助けとなるところに丸括弧を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reading the total amount during the process of adding an item gives you incorrect information.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある項目を追加する処理の間に総支出額を読み出すことは、あなたに正しくない情報を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Recursive Enumerations</seg>
      </tuv>
      <tuv lang="JA">
        <seg>再帰列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reference counting allows more than one reference to a class instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>参照カウントは、あるクラスインスタンスに対する１つ以上の参照を許します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reference counting applies only to instances of classes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>参照カウントが唯一適用されるのは、クラスのインスタンスに対してです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Referring to Nested Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>入れ子にされた型を参照する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remainder Operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>剰余演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remainder and multiplication both associate with the expression to their left.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>剰余と乗算は、両方とも式をそれらの左と結びつけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Remove the &lt;c0&gt;&lt;s1&gt;day&lt;/s1&gt;&lt;/c0&gt; parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;day&lt;/s1&gt;&lt;/c0&gt;パラメータを取り除いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removed a duplicate description of the valid set of operator characters from &lt;a4&gt;&lt;s5&gt;Custom Operators&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>有効な演算子の一式の重複する説明を&lt;a4&gt;&lt;s5&gt;あつらえの演算子&lt;/s5&gt;&lt;/a4&gt;から取り除きました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removed a note to the contrary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これに反する注意書きを取り除きました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removed discussion of C-style &lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt; loops, the &lt;c2&gt;&lt;s3&gt;++&lt;/s3&gt;&lt;/c2&gt; prefix and postfix operators, and the &lt;c4&gt;&lt;s5&gt;--&lt;/s5&gt;&lt;/c4&gt; prefix and postfix operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>C形式&lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;ループ、&lt;c2&gt;&lt;s3&gt;++&lt;/s3&gt;&lt;/c2&gt;接頭辞および接尾辞演算子、そして&lt;c4&gt;&lt;s5&gt;--&lt;/s5&gt;&lt;/c4&gt;接頭辞および接尾辞演算子の議論を削除した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removed discussion of variable function arguments and the special syntax for curried functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変数関数引数とカリー化関数のための特別な構文の議論を削除した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removed the Dynamic Type Expression section from the &lt;a0&gt;&lt;s1&gt;Expressions&lt;/s1&gt;&lt;/a0&gt; chapter, now that &lt;c2&gt;&lt;s3&gt;type(of:)&lt;/s3&gt;&lt;/c2&gt; is a Swift standard library function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「動的型式」の節を&lt;a0&gt;&lt;s1&gt;式&lt;/s1&gt;&lt;/a0&gt;の章から削除した、今では&lt;c2&gt;&lt;s3&gt;type(of:)&lt;/s3&gt;&lt;/c2&gt;はスウィフト標準ライブラリ関数であるので。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removed the discussion of explicitly using &lt;c0&gt;&lt;s1&gt;let&lt;/s1&gt;&lt;/c0&gt; in function parameters from the &lt;a2&gt;&lt;s3&gt;Function Declaration&lt;/s3&gt;&lt;/a2&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>明示的に&lt;c0&gt;&lt;s1&gt;let&lt;/s1&gt;&lt;/c0&gt;を関数パラメータにおいて使用することの解説を節&lt;a2&gt;&lt;s3&gt;関数宣言&lt;/s3&gt;&lt;/a2&gt;から削除した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removed the discussion of the &lt;c0&gt;&lt;s1&gt;Boolean&lt;/s1&gt;&lt;/c0&gt; protocol from the &lt;a2&gt;&lt;s3&gt;Statements&lt;/s3&gt;&lt;/a2&gt; chapter, now that the protocol has been removed from the Swift standard library.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Boolean&lt;/s1&gt;&lt;/c0&gt;プロトコルの解説を&lt;a2&gt;&lt;s3&gt;文&lt;/s3&gt;&lt;/a2&gt;の章から削除した、今ではこのプロトコルはスウィフト標準ライブラリから削除されてしまったので。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removed the overflow division (&lt;c0&gt;&lt;s1&gt;&amp;/&lt;/s1&gt;&lt;/c0&gt;) and overflow remainder (&lt;c2&gt;&lt;s3&gt;&amp;%&lt;/s3&gt;&lt;/c2&gt;) operators from &lt;a4&gt;&lt;s5&gt;Overflow Operators&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オーバフロー除算（&lt;c0&gt;&lt;s1&gt;&amp;/&lt;/s1&gt;&lt;/c0&gt;）とオーバフロー剰余（&lt;c2&gt;&lt;s3&gt;&amp;%&lt;/s3&gt;&lt;/c2&gt;）演算子を&lt;a4&gt;&lt;s5&gt;オーバフロー演算子&lt;/s5&gt;&lt;/a4&gt;から削除しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Repeat-While</seg>
      </tuv>
      <tuv lang="JA">
        <seg>終わりに評価</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Repeat-While Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>repeat-while文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Representing and Throwing Errors</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーの表現とスロー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Required Initializers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>必須イニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Requiring exhaustiveness ensures that enumeration cases aren’t accidentally omitted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>網羅性を要求することは、列挙ケース節のどれかがうっかり書き落とされないことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Resolving Explicit Redundancy</seg>
      </tuv>
      <tuv lang="JA">
        <seg>明示的な冗長性を解決する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Resolving Implicit Redundancy</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗黙的な冗長性を解決する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Resolving Strong Reference Cycles Between Class Instances</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスインスタンス間の強い参照循環の解消</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Resolving Strong Reference Cycles for Closures</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャのための強い参照循環の解消</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Restrictions for Nonescaping Closures</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非脱出クロージャに対する規制</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rethrowing Functions and Methods</seg>
      </tuv>
      <tuv lang="JA">
        <seg>再スローを行う関数とメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rethrowing functions and methods must have at least one throwing function parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>再スロー関数とメソッドは、少なくとも１つのスロー関数パラメーターを持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Retrieve a value from the array by using &lt;e0&gt;subscript syntax&lt;/e0&gt;, passing the index of the value you want to retrieve within square brackets immediately after the name of the array:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;添え字構文&lt;/e0&gt;を使うことで、ひとつの値をこの配列から取り出してください、あなたが取り出したい値の添え字（インデックス、指数）を、配列の名前の直後の角括弧内に入れて渡してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Return Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>復帰文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Return values can be ignored, but a function that says it will return a value must always do so.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>戻り値は無視されることができます、しかし値を返すつもりだと言う関数は、常にそうしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returning an Opaque Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>不透明型を返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returning an opaque type looks very similar to using a protocol type as the return type of a function, but these two kinds of return type differ in whether they preserve type identity.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>不透明型を返すことは、プロトコル型を関数の戻り型として使うことと大変よく似て見えます、しかしこれら２つの種類の戻り型は、それらが型同一性を保全するかどうかにおいて異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Revision History</seg>
      </tuv>
      <tuv lang="JA">
        <seg>改訂履歴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rewrite the closure to return zero for all odd numbers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このクロージャを、全ての奇数に対してゼロを返すように書き直してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rewrote the &lt;a0&gt;&lt;s1&gt;Inheritance&lt;/s1&gt;&lt;/a0&gt; chapter to remove its introductory coverage of initializer overrides.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>章&lt;a0&gt;&lt;s1&gt;継承&lt;/s1&gt;&lt;/a0&gt;を書き直して、それの前置きのイニシャライザのオーバーライドを扱った部分を取り除きました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rule 1</seg>
      </tuv>
      <tuv lang="JA">
        <seg>規則１</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rule 2</seg>
      </tuv>
      <tuv lang="JA">
        <seg>規則２</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rule 3</seg>
      </tuv>
      <tuv lang="JA">
        <seg>規則３</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Safety check 1</seg>
      </tuv>
      <tuv lang="JA">
        <seg>安全点検１</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Safety check 2</seg>
      </tuv>
      <tuv lang="JA">
        <seg>安全点検２</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Safety check 3</seg>
      </tuv>
      <tuv lang="JA">
        <seg>安全点検３</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Safety check 4</seg>
      </tuv>
      <tuv lang="JA">
        <seg>安全点検４</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scalar values that have been assigned to a character typically also have a name, such as &lt;c0&gt;&lt;s1&gt;LATIN&lt;/s1&gt; &lt;s2&gt;SMALL&lt;/s2&gt; &lt;s3&gt;LETTER&lt;/s3&gt; &lt;s4&gt;A&lt;/s4&gt;&lt;/c0&gt; and &lt;c5&gt;&lt;s6&gt;FRONT-FACING&lt;/s6&gt; &lt;s7&gt;BABY&lt;/s7&gt; &lt;s8&gt;CHICK&lt;/s8&gt;&lt;/c5&gt; in the examples above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある文字に割り当てられるスカラー値は、たいてい名前を持っています、例えば以前の例での&lt;c0&gt;&lt;s1&gt;LATIN&lt;/s1&gt; &lt;s2&gt;SMALL&lt;/s2&gt; &lt;s3&gt;LETTER&lt;/s3&gt; &lt;s4&gt;A&lt;/s4&gt;&lt;/c0&gt;と&lt;c5&gt;&lt;s6&gt;FRONT-FACING&lt;/s6&gt; &lt;s7&gt;BABY&lt;/s7&gt; &lt;s8&gt;CHICK&lt;/s8&gt;&lt;/c5&gt;など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Second, even if &lt;c13&gt;&lt;s14&gt;dataSource&lt;/s14&gt;&lt;/c13&gt; &lt;e15&gt;does&lt;/e15&gt; exist, there’s no guarantee that it implements &lt;c16&gt;&lt;s17&gt;increment(forCount:)&lt;/s17&gt;&lt;/c16&gt;, because it’s an optional requirement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第２に、たとえ&lt;c13&gt;&lt;s14&gt;dataSource&lt;/s14&gt;&lt;/c13&gt;が&lt;e15&gt;存在する&lt;/e15&gt;としても、それが&lt;c16&gt;&lt;s17&gt;increment(forCount:)&lt;/s17&gt;&lt;/c16&gt;を実装する保証はありません、それがオプショナルの要件であるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Second, the two’s complement representation also lets you shift the bits of negative numbers to the left and right like positive numbers, and still end up doubling them for every shift you make to the left, or halving them for every shift you make to the right.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第２に、２の補数表現はまた、あなたに負数のビットを左や右に正の数のようにシフトさせます、そして依然としてあなたが左へとするシフトは全てそれを２倍にすることで、またあなたが右へとするシフトは全てそれを半分にすることで終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See &lt;a0&gt;&lt;s1&gt;Precedence and Associativity&lt;/s1&gt;&lt;/a0&gt; for an explanation of how these characteristics affect an infix operator’s interaction with other infix operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;優先順位と結合性&lt;/s1&gt;&lt;/a0&gt;をどのようにそれらの特徴が接中辞演算子の他の接中辞演算子との相互作用に影響を及ぼすかの解説として見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See &lt;a0&gt;&lt;s1&gt;Special Characters in String Literals&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>更なる情報として、&lt;a0&gt;&lt;s1&gt;文字列リテラル内の特別な文字&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See &lt;a4&gt;&lt;s5&gt;Overflow Operators&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a4&gt;&lt;s5&gt;オーバフロー演算子&lt;/s5&gt;&lt;/a4&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also &lt;a0&gt;&lt;s1&gt;Function Declaration&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>また、&lt;a0&gt;&lt;s1&gt;関数宣言&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also &lt;a0&gt;&lt;s1&gt;Initializer Declaration&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>また、&lt;a0&gt;&lt;s1&gt;イニシャライザ宣言&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also &lt;a0&gt;&lt;s1&gt;Protocol Associated Type Declaration&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>また、&lt;a0&gt;&lt;s1&gt;プロトコル関連型宣言&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also &lt;a0&gt;&lt;s1&gt;Subscript Declaration&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>また、&lt;a0&gt;&lt;s1&gt;添え字宣言&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also &lt;a0&gt;&lt;s1&gt;Type Alias Declaration&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>また、&lt;a0&gt;&lt;s1&gt;型エイリアス宣言&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also &lt;a0&gt;&lt;s1&gt;Variable Declaration&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>また、&lt;a0&gt;&lt;s1&gt;変数の宣言&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Selector Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セレクタ式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Self Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>self式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Self Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Self型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Semicolons</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セミコロン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Separate each requirement in the list with a comma.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リストの中の各要件をコンマで区切ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Set &lt;c24&gt;&lt;s25&gt;b&lt;/s25&gt;&lt;/c24&gt; and set &lt;c26&gt;&lt;s27&gt;c&lt;/s27&gt;&lt;/c26&gt; are &lt;e28&gt;disjoint&lt;/e28&gt; with one another, because they share no elements in common.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>集合&lt;c24&gt;&lt;s25&gt;b&lt;/s25&gt;&lt;/c24&gt;と集合&lt;c26&gt;&lt;s27&gt;c&lt;/s27&gt;&lt;/c26&gt;は、他のものと&lt;e28&gt;互いに素&lt;/e28&gt;です（交わりを持たない）、なぜならそれらが共通の要素を共有しないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Set &lt;c6&gt;&lt;s7&gt;a&lt;/s7&gt;&lt;/c6&gt; is a &lt;e8&gt;superset&lt;/e8&gt; of set &lt;c9&gt;&lt;s10&gt;b&lt;/s10&gt;&lt;/c9&gt;, because &lt;c11&gt;&lt;s12&gt;a&lt;/s12&gt;&lt;/c11&gt; contains all elements in &lt;c13&gt;&lt;s14&gt;b&lt;/s14&gt;&lt;/c13&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>集合&lt;c6&gt;&lt;s7&gt;a&lt;/s7&gt;&lt;/c6&gt;は集合&lt;c9&gt;&lt;s10&gt;b&lt;/s10&gt;&lt;/c9&gt;の&lt;e8&gt;上位集合&lt;/e8&gt;です、なぜなら&lt;c11&gt;&lt;s12&gt;a&lt;/s12&gt;&lt;/c11&gt;が&lt;c13&gt;&lt;s14&gt;b&lt;/s14&gt;&lt;/c13&gt;のすべての要素を含むからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Set Membership and Equality</seg>
      </tuv>
      <tuv lang="JA">
        <seg>集合の帰属と等価性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Set Type Syntax</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Set型構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sets</seg>
      </tuv>
      <tuv lang="JA">
        <seg>集合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sets are unordered collections of unique values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>集合は、順番をつけられないそれぞれが異なった値のコレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting Initial Values for Stored Properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期値を格納プロパティに設定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting Initial Values for Wrapped Properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ラップされたプロパティに初期値を設定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting a Default Property Value with a Closure or Function</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時のプロパティ値をクロージャまたは関数を使って設定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting the &lt;c5&gt;&lt;s6&gt;center&lt;/s6&gt;&lt;/c5&gt; property calls the setter for &lt;c7&gt;&lt;s8&gt;center&lt;/s8&gt;&lt;/c7&gt;, which modifies the &lt;c9&gt;&lt;s10&gt;x&lt;/s10&gt;&lt;/c9&gt; and &lt;c11&gt;&lt;s12&gt;y&lt;/s12&gt;&lt;/c11&gt; values of the stored &lt;c13&gt;&lt;s14&gt;origin&lt;/s14&gt;&lt;/c13&gt; property, and moves the square to its new position.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c5&gt;&lt;s6&gt;center&lt;/s6&gt;&lt;/c5&gt;プロパティを設定することは、&lt;c7&gt;&lt;s8&gt;center&lt;/s8&gt;&lt;/c7&gt;のためのセッターを呼び出します、そしてそれは、格納された&lt;c13&gt;&lt;s14&gt;origin&lt;/s14&gt;&lt;/c13&gt;プロパティの&lt;c9&gt;&lt;s10&gt;x&lt;/s10&gt;&lt;/c9&gt;と&lt;c11&gt;&lt;s12&gt;y&lt;/s12&gt;&lt;/c11&gt;値を修正して、正方形をその新しい位置へと動かします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting the value of properties that the subclass declares.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブクラスが宣言するプロパティの値を設定する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Several methods that have special names enable syntactic sugar for function call syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特殊名を持つ幾つかのメソッドは、関数呼び出し構文に対して構文糖を可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Several of the &lt;c14&gt;&lt;s15&gt;switch&lt;/s15&gt;&lt;/c14&gt; statement’s cases bind their matched value to a constant of the specified type to enable its value to be printed:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c14&gt;&lt;s15&gt;switch&lt;/s15&gt;&lt;/c14&gt;文のケース節のいくつかは、それらが適合した値を指定された型のある定数に結び付け、その値を出力できるようにします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shifting Behavior for Signed Integers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>符号つき整数のためのシフト挙動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shifting Behavior for Unsigned Integers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>符号なし整数のためのシフト挙動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shifting an integer’s bits to the left by one position doubles its value, whereas shifting it to the right by one position halves its value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数のビットを位置１つだけ左へ移すことはその値を２倍にします、一方それを位置１つだけ右へ移すことはその値を半分にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shorthand Argument Names</seg>
      </tuv>
      <tuv lang="JA">
        <seg>短縮形引数名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shorthand Getter Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>短縮形ゲッター宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shorthand Setter Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>短縮形セッター宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Shorthand argument names</seg>
      </tuv>
      <tuv lang="JA">
        <seg>短縮形引数名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Signed integers use their first bit (known as the &lt;e0&gt;sign bit&lt;/e0&gt;) to indicate whether the integer is positive or negative.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>符号つき整数は、それらの最初のビット（&lt;e0&gt;符号ビット&lt;/e0&gt;として知られるもの）を使って、その整数が正であるか負であるかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to an &lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt; statement, you can add multiple conditional branches to test for different compilation conditions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt;文と同様に、あなたは複数の条件分岐を加えて、異なるコンパイル条件に対してテストすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, &lt;c10&gt;&lt;s11&gt;###"Line1\###nLine2"###&lt;/s11&gt;&lt;/c10&gt; also breaks the line.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に、&lt;c10&gt;&lt;s11&gt;###"Line1\###nLine2"###&lt;/s11&gt;&lt;/c10&gt;もまた行を改めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, &lt;c11&gt;&lt;s12&gt;0xFp-2&lt;/s12&gt;&lt;/c11&gt; represents 15 x 2&lt;s13&gt;-2&lt;/s13&gt;, which evaluates to &lt;c14&gt;&lt;s15&gt;3.75&lt;/s15&gt;&lt;/c14&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、&lt;c11&gt;&lt;s12&gt;0xFp-2&lt;/s12&gt;&lt;/c11&gt;は15 × 2&lt;s13&gt;-2&lt;/s13&gt;を表します、それは&lt;c14&gt;&lt;s15&gt;3.75&lt;/s15&gt;&lt;/c14&gt;に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, &lt;c11&gt;&lt;s12&gt;1.25e-2&lt;/s12&gt;&lt;/c11&gt; represents 1.25 x 10&lt;s13&gt;-2&lt;/s13&gt;, which evaluates to &lt;c14&gt;&lt;s15&gt;0.0125&lt;/s15&gt;&lt;/c14&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、&lt;c11&gt;&lt;s12&gt;1.25e-2&lt;/s12&gt;&lt;/c11&gt;は1.25 × 10&lt;s13&gt;-2&lt;/s13&gt;を表します、それは&lt;c14&gt;&lt;s15&gt;0.0125&lt;/s15&gt;&lt;/c14&gt;に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, &lt;c12&gt;&lt;s13&gt;item&lt;/s13&gt; &lt;s14&gt;is&lt;/s14&gt; &lt;s15&gt;Song&lt;/s15&gt;&lt;/c12&gt; checks whether the item is a &lt;c16&gt;&lt;s17&gt;Song&lt;/s17&gt;&lt;/c16&gt; instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、&lt;c12&gt;&lt;s13&gt;item&lt;/s13&gt; &lt;s14&gt;is&lt;/s14&gt; &lt;s15&gt;Song&lt;/s15&gt;&lt;/c12&gt;はその項目が&lt;c16&gt;&lt;s17&gt;Song&lt;/s17&gt;&lt;/c16&gt;インスタンスであるか調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, a method marked with the &lt;c8&gt;&lt;s9&gt;nonobjc&lt;/s9&gt;&lt;/c8&gt; attribute can’t satisfy a protocol requirement for a method marked with the &lt;c10&gt;&lt;s11&gt;objc&lt;/s11&gt;&lt;/c10&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に、&lt;c8&gt;&lt;s9&gt;nonobjc&lt;/s9&gt;&lt;/c8&gt;属性で印されるメソッドは、&lt;c10&gt;&lt;s11&gt;objc&lt;/s11&gt;&lt;/c10&gt;属性で印されるメソッドに対するプロトコル要件を満たすことは出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, a stack allows items to be removed only from the end of the collection (known as &lt;e5&gt;popping&lt;/e5&gt; a value off the stack).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、スタックは項目をコレクションの終わりからだけ取り除かれることが許されます（値をスタックから&lt;e5&gt;ポップ&lt;/e5&gt;するとして知られます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, a subclass failable initializer can delegate up to a superclass failable initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、サブクラスの失敗できるイニシャライザは、スーパークラスの失敗できるイニシャライザにさかのぼって委任することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, a subscript can’t be more public than either its index type or return type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、添え字はそのインデックス型や戻り型よりも公開であることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, every &lt;c0&gt;&lt;s1&gt;Apartment&lt;/s1&gt;&lt;/c0&gt; instance has a &lt;c2&gt;&lt;s3&gt;unit&lt;/s3&gt;&lt;/c2&gt; property of type &lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt; and has an optional &lt;c6&gt;&lt;s7&gt;tenant&lt;/s7&gt;&lt;/c6&gt; property that is initially &lt;c8&gt;&lt;s9&gt;nil&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、あらゆる&lt;c0&gt;&lt;s1&gt;Apartment&lt;/s1&gt;&lt;/c0&gt;インスタンスは、型&lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt;の&lt;c2&gt;&lt;s3&gt;unit&lt;/s3&gt;&lt;/c2&gt;プロパティを持って、初期時には&lt;c8&gt;&lt;s9&gt;nil&lt;/s9&gt;&lt;/c8&gt;であるオプショナルの&lt;c6&gt;&lt;s7&gt;tenant&lt;/s7&gt;&lt;/c6&gt;プロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, if you have multiple nested loops, it can be useful to be explicit about which loop the &lt;c4&gt;&lt;s5&gt;continue&lt;/s5&gt;&lt;/c4&gt; statement should affect.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、あなたが複数の入れ子にされたループを持つならば、&lt;c4&gt;&lt;s5&gt;continue&lt;/s5&gt;&lt;/c4&gt;文が影響を及ぼさなければならないループはどれかについて明確にすることは役に立つでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, if you implement a &lt;c0&gt;&lt;s1&gt;didSet&lt;/s1&gt;&lt;/c0&gt; observer, it’s passed a constant parameter containing the old property value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、あなたが&lt;c0&gt;&lt;s1&gt;didSet&lt;/s1&gt;&lt;/c0&gt;オブザーバーを実装するならば、それは古いプロパティ値を含んでいる定数パラメータを渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, if you try to create a &lt;c0&gt;&lt;s1&gt;CartItem&lt;/s1&gt;&lt;/c0&gt; instance with an empty &lt;c2&gt;&lt;s3&gt;name&lt;/s3&gt;&lt;/c2&gt; value, the superclass &lt;c4&gt;&lt;s5&gt;Product&lt;/s5&gt;&lt;/c4&gt; initializer causes initialization to fail:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同様に、あなたが&lt;c0&gt;&lt;s1&gt;CartItem&lt;/s1&gt;&lt;/c0&gt;インスタンスを空の&lt;c2&gt;&lt;s3&gt;name&lt;/s3&gt;&lt;/c2&gt;値で作成することを試みるならば、スーパークラスの&lt;c4&gt;&lt;s5&gt;Product&lt;/s5&gt;&lt;/c4&gt;イニシャライザは初期化が失敗する原因となります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, if you try to retrieve an &lt;c0&gt;&lt;s1&gt;Int?&lt;/s1&gt;&lt;/c0&gt; value through optional chaining, an &lt;c2&gt;&lt;s3&gt;Int?&lt;/s3&gt;&lt;/c2&gt; is always returned, no matter how many levels of chaining are used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、あなたがオプショナル連鎖を通して&lt;c0&gt;&lt;s1&gt;Int?&lt;/s1&gt;&lt;/c0&gt;値を取り出そうと試すならば、&lt;c2&gt;&lt;s3&gt;Int?&lt;/s3&gt;&lt;/c2&gt;が常に返されます、どんなに多くの連鎖階層が使われようともです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, it can be convenient to define utility classes and structures purely for use within the context of a more complex type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、あくまでもより複雑な型の文脈内で使用するだけの有用なクラスや構造体を定義することは、便利でありえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, its second case matches all lowercase English consonants.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、その第二のケース節は、小文字の英語の子音すべてにマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, the &lt;c0&gt;&lt;s1&gt;SnakesAndLadders&lt;/s1&gt;&lt;/c0&gt; game class can be extended to adopt and conform to the &lt;c2&gt;&lt;s3&gt;TextRepresentable&lt;/s3&gt;&lt;/c2&gt; protocol:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、&lt;c0&gt;&lt;s1&gt;SnakesAndLadders&lt;/s1&gt;&lt;/c0&gt;ゲーム・クラスは、拡張されることで、&lt;c2&gt;&lt;s3&gt;TextRepresentable&lt;/s3&gt;&lt;/c2&gt;プロトコルを採用して準拠することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, the green component is obtained by performing a bitwise AND between the numbers &lt;c0&gt;&lt;s1&gt;0xCC6699&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;0x00FF00&lt;/s3&gt;&lt;/c2&gt;, which gives an output value of &lt;c4&gt;&lt;s5&gt;0x006600&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、緑の構成要素は数&lt;c0&gt;&lt;s1&gt;0xCC6699&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;0x00FF00&lt;/s3&gt;&lt;/c2&gt;との間のビット単位の論理積を実行することによって得られます、それは、&lt;c4&gt;&lt;s5&gt;0x006600&lt;/s5&gt;&lt;/c4&gt;の出力値を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, the second case, &lt;c21&gt;&lt;s22&gt;case&lt;/s22&gt; &lt;s23&gt;(0,&lt;/s23&gt; &lt;s24&gt;let&lt;/s24&gt; &lt;s25&gt;y)&lt;/s25&gt;&lt;/c21&gt;, matches any point with an &lt;c26&gt;&lt;s27&gt;x&lt;/s27&gt;&lt;/c26&gt; value of &lt;c28&gt;&lt;s29&gt;0&lt;/s29&gt;&lt;/c28&gt; and assigns the point’s &lt;c30&gt;&lt;s31&gt;y&lt;/s31&gt;&lt;/c30&gt; value to the temporary constant &lt;c32&gt;&lt;s33&gt;y&lt;/s33&gt;&lt;/c32&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、第二のケース節、&lt;c21&gt;&lt;s22&gt;case&lt;/s22&gt; &lt;s23&gt;(0,&lt;/s23&gt; &lt;s24&gt;let&lt;/s24&gt; &lt;s25&gt;y)&lt;/s25&gt;&lt;/c21&gt;は、&lt;c28&gt;&lt;s29&gt;0&lt;/s29&gt;&lt;/c28&gt;の&lt;c26&gt;&lt;s27&gt;x&lt;/s27&gt;&lt;/c26&gt;値をもつどんなポイントにでも適合して、そのポイントの&lt;c30&gt;&lt;s31&gt;y&lt;/s31&gt;&lt;/c30&gt;値を一時的な定数&lt;c32&gt;&lt;s33&gt;y&lt;/s33&gt;&lt;/c32&gt;に代入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, the ternary conditional operator (&lt;c2&gt;&lt;s3&gt;a&lt;/s3&gt; &lt;s4&gt;?&lt;/s4&gt; &lt;s5&gt;b&lt;/s5&gt; &lt;s6&gt;:&lt;/s6&gt; &lt;s7&gt;c&lt;/s7&gt;&lt;/c2&gt;) can’t be overloaded.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように三項条件演算子（&lt;c2&gt;&lt;s3&gt;a&lt;/s3&gt; &lt;s4&gt;?&lt;/s4&gt; &lt;s5&gt;b&lt;/s5&gt; &lt;s6&gt;:&lt;/s6&gt; &lt;s7&gt;c&lt;/s7&gt;&lt;/c2&gt;)は、オーバーロードされることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, there are 3.28084 feet in a meter, and so the &lt;c4&gt;&lt;s5&gt;ft&lt;/s5&gt;&lt;/c4&gt; computed property divides the underlying &lt;c6&gt;&lt;s7&gt;Double&lt;/s7&gt;&lt;/c6&gt; value by &lt;c8&gt;&lt;s9&gt;3.28084&lt;/s9&gt;&lt;/c8&gt;, to convert it from feet to meters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、１メートルは3.28084フィートあります、なので&lt;c4&gt;&lt;s5&gt;ft&lt;/s5&gt;&lt;/c4&gt;計算プロパティは、もとの&lt;c6&gt;&lt;s7&gt;Double&lt;/s7&gt;&lt;/c6&gt;値を&lt;c8&gt;&lt;s9&gt;3.28084&lt;/s9&gt;&lt;/c8&gt;で割って、それをフィートからメートルに変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, type methods on structures and enumerations can access type properties by using the type property’s name without a type name prefix.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、構造体と列挙の型メソッドは、型名前接頭辞なしで型プロパティの名前を使用することによって型プロパティにアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, use the &lt;c0&gt;&lt;s1&gt;hasSuffix(_:)&lt;/s1&gt;&lt;/c0&gt; method to count the number of scenes that take place in or around Capulet’s mansion and Friar Lawrence’s cell:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、&lt;c0&gt;&lt;s1&gt;hasSuffix(_:)&lt;/s1&gt;&lt;/c0&gt;メソッドを、キャビュレットの邸宅と修道士ローレンスの独居房の中または周囲で起こる場面の数を数えるために使用してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, you can create a dictionary to store values of any specified type, and there are no limitations on what that type can be.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、あなたはどんな指定された型の値たちでも保管する辞書を作成することができます、そしてその型が何であることができるか制限がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, you can omit part of a type when the full type can be inferred from context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、前後関係から完全に型が推論されることができるとき、あなたはある型の一部を省略することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, you can try to set a new value through a subscript with optional chaining:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、あなたはオプショナル連鎖を使う添え字を通して、新しい値の設定を試みることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, you remove an item from the array with the &lt;c0&gt;&lt;s1&gt;remove(at:)&lt;/s1&gt;&lt;/c0&gt; method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じように、あなたは&lt;c0&gt;&lt;s1&gt;remove(at:)&lt;/s1&gt;&lt;/c0&gt;メソッドを使って配列から項目を取り除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Simple Values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単純な値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Simple statements are the most common and consist of either an expression or a declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単純な文は、もっとも普通のもので、ひとつの式もしくはひとつの宣言から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Single line comments begin with &lt;c0&gt;&lt;s1&gt;//&lt;/s1&gt;&lt;/c0&gt; and continue until a line feed (U+000A) or carriage return (U+000D).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一行コメントは&lt;c0&gt;&lt;s1&gt;//&lt;/s1&gt;&lt;/c0&gt;で始まります、そして行送り（U+000A）または復帰（U+000D）まで続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Single quotation mark (&lt;c0&gt;&lt;s1&gt;\'&lt;/s1&gt;&lt;/c0&gt;)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一重引用符（&lt;c0&gt;&lt;s1&gt;\'&lt;/s1&gt;&lt;/c0&gt;０</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Single statement closures implicitly return the value of their only statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとつだけの文のクロージャは、暗黙のうちにそのただ１つの文の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Single-expression closures can implicitly return the result of their single expression by omitting the &lt;c0&gt;&lt;s1&gt;return&lt;/s1&gt;&lt;/c0&gt; keyword from their declaration, as in this version of the previous example:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単一の式のクロージャは、前の例のこの改作のように、&lt;c0&gt;&lt;s1&gt;return&lt;/s1&gt;&lt;/c0&gt;キーワードをそれらの宣言から省略することによって、暗黙的にそれのただ１つの式の結果を返すことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some declaration attributes accept arguments that specify more information about the attribute and how it applies to a particular declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>若干の宣言属性は、属性に関するより多くの情報とそれが特定の宣言に適用される方法を指定する引数を受け入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some operations aren’t guaranteed to always complete execution or produce a useful output.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いくつかの操作は、常に実行を完了することや役に立つ出力を生成することを保証されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some products are labeled with 1D barcodes in UPC format, which uses the numbers &lt;c0&gt;&lt;s1&gt;0&lt;/s1&gt;&lt;/c0&gt; to &lt;c2&gt;&lt;s3&gt;9&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある製品はUPC形式の一次元バーコードでラベルをつけられます、それは&lt;c0&gt;&lt;s1&gt;0&lt;/s1&gt;&lt;/c0&gt;から&lt;c2&gt;&lt;s3&gt;9&lt;/s3&gt;&lt;/c2&gt;までの数字を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some squares are then set to have more specific values for the snakes and ladders.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いくつかの正方形は、それからヘビとはしごのためのより独特な値を持つように設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some users might want fewer tick marks in their UI.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>幾人かのユーザは、より少ない目盛りを彼らのUIに望むかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Something similar happens when an unsigned integer is allowed to overflow in the negative direction.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>符号なし整数が負の向きにおいてオーバフローを認められるときに同じようなことが起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes it’s clear from a program’s structure that an optional will &lt;e0&gt;always&lt;/e0&gt; have a value, after that value is first set.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>時々、プログラムの構造から、あるオプショナルが&lt;e0&gt;必ず&lt;/e0&gt;値を持つことが、その値が最初に設定される結果として、はっきりしていることがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes you know a throwing function or method won’t, in fact, throw an error at runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>時にはあなたはあるスロー関数またはメソッドが、実際のところ、実行時にエラーをスローすることがないのを知っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Special Characters in String Literals</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列リテラル内の特別な文字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Special Kinds of Methods</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特別な種類のメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Special Kinds of Parameters</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特別な種類のパラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Special characters can be included in string literals of both the single-line and multiline forms using the following escape sequences:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特殊文字は、単一行および複数行形式の両方の文字列リテラルの中に以下のエスケープシーケンスを使って含められます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Special characters in a string delimited by extended delimiters appear in the resulting string as normal characters rather than as special characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張区切り記号によって区切られた文字列は、結果文字列において普通の文字として現れます、特殊文字としてではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifically, a conflict occurs if you have two accesses that meet all of the following conditions:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とりわけ、あなたが２つのアクセスを持ち以下の条件のすべてに出会う場合に、ある衝突が起こります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifically, if a failable initializer delegates to an initializer that fails and returns &lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;, then the initializer that delegated also fails and implicitly returns &lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>具体的には、失敗できるイニシャライザが、ある失敗して&lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;を返すイニシャライザへ委任するならば、その時その委任した側のイニシャライザもまた失敗して暗黙的に&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifically, it can prove that overlapping access to properties of a structure is safe if the following conditions apply:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とりわけ、関数のプロパティに対するオーバーラップアクセスが安全であることは、以下の条件が当てはまるならば立証できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifically, it declares a &lt;c2&gt;&lt;s3&gt;name&lt;/s3&gt;&lt;/c2&gt; property of type &lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt;, and an &lt;c6&gt;&lt;s7&gt;init&lt;/s7&gt; &lt;s8&gt;name&lt;/s8&gt;&lt;/c6&gt; initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に、それは型&lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt;の&lt;c2&gt;&lt;s3&gt;name&lt;/s3&gt;&lt;/c2&gt;プロパティ、そして&lt;c6&gt;&lt;s7&gt;init&lt;/s7&gt; &lt;s8&gt;name&lt;/s8&gt;&lt;/c6&gt;イニシャライザを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifically, it expresses whether the number is negative, zero, or positive.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>具体的には、それはその数が負、ゼロ、または正かを表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifically, it must ensure that only items of the right type are added to the container, and it must be clear about the type of the items returned by its subscript.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>具体的には、それは正しい型の項目だけがコンテナに加えられることを確実にしなければなりません、そして、それはそれの添え字によって返される項目の型についてはっきりわかっていなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifically, the property observer chooses a gear that is the new &lt;c8&gt;&lt;s9&gt;currentSpeed&lt;/s9&gt;&lt;/c8&gt; value divided by &lt;c10&gt;&lt;s11&gt;10&lt;/s11&gt;&lt;/c10&gt;, rounded down to the nearest integer, plus &lt;c12&gt;&lt;s13&gt;1&lt;/s13&gt;&lt;/c12&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>具体的には、プロパティオブザーバーは、新しい&lt;c8&gt;&lt;s9&gt;currentSpeed&lt;/s9&gt;&lt;/c8&gt;値を&lt;c10&gt;&lt;s11&gt;10&lt;/s11&gt;&lt;/c10&gt;で割って、最も近い整数に丸めて、&lt;c12&gt;&lt;s13&gt;1&lt;/s13&gt;&lt;/c12&gt;を加えたギアを選びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifically, the result of an optional chaining call is of the same type as the expected return value, but wrapped in an optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>具体的には、オプショナル連鎖の呼び出しの結果は、期待される戻り値と同じ型ですが、オプショナルの中にラップされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifically, you can use a key path expression whose root type is &lt;c0&gt;&lt;s1&gt;SomeType&lt;/s1&gt;&lt;/c0&gt; and whose path produces a value of type &lt;c2&gt;&lt;s3&gt;Value&lt;/s3&gt;&lt;/c2&gt;, instead of a function or closure of type &lt;c4&gt;&lt;s5&gt;(SomeType)&lt;/s5&gt; &lt;s6&gt;-&gt;&lt;/s6&gt; &lt;s7&gt;Value&lt;/s7&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とりわけ、あなたはそれのルート型が&lt;c0&gt;&lt;s1&gt;SomeType&lt;/s1&gt;&lt;/c0&gt;でそれのパスが型&lt;c2&gt;&lt;s3&gt;Value&lt;/s3&gt;&lt;/c2&gt;の値を生み出すキーパス式を、型&lt;c4&gt;&lt;s5&gt;(SomeType)&lt;/s5&gt; &lt;s6&gt;-&gt;&lt;/s6&gt; &lt;s7&gt;Value&lt;/s7&gt;&lt;/c4&gt;の関数またはクロージャの代わりに使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifying Argument Labels</seg>
      </tuv>
      <tuv lang="JA">
        <seg>引数ラベルを指定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifying Cleanup Actions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クリーンアップ動作の指定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Square 3 contains the bottom of a ladder that moves you up to square 11.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>正方形３は、正方形11まであなたを動かすはしごの底を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Squares with a ladder base have a positive number to move you up the board, whereas squares with a snake head have a negative number to move you back down the board.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>はしごの接地面がある正方形は、あなたを盤の上方に動かすために正の番号を持ちます、一方でヘビの頭のある正方形は、あなたを逆に盤の下に動かすために負の数を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Statements</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Static string literals can’t use features like string interpolation or concatenation, but they can use the multiline string literal syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>静的文字列リテラルは、文字列補間や連結のような機能を使えません、しかしそれらは複数行文字列リテラル構文を使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stopping execution as soon as an invalid state is detected also helps limit the damage caused by that invalid state.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>無効な状態が検知されるやいなや実行を停止することはまた、その無効な状態によって起こされる被害を抑えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stored Properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>格納プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stored Properties and Instance Variables</seg>
      </tuv>
      <tuv lang="JA">
        <seg>格納プロパティとインスタンス変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stored Properties of Constant Structure Instances</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数構造体インスタンスの格納プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stored Variable Observers and Property Observers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>格納された変数オブザーバーとプロパティオブザーバー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stored Variables and Stored Variable Properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>格納変数と格納変数プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stored and computed properties are usually associated with instances of a particular type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>格納されるもしくは計算されるプロパティは、通常は特定の型のインスタンスに結び付けられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stored properties are constants or variables that are bundled up and stored as part of the structure or class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>格納プロパティは、構造体またはクラスの一部としてまとめられて格納される定数または変数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stored properties are provided only by classes and structures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>格納プロパティは、クラスと構造体だけで提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stored properties can be either &lt;e0&gt;variable stored properties&lt;/e0&gt; (introduced by the &lt;c1&gt;&lt;s2&gt;var&lt;/s2&gt;&lt;/c1&gt; keyword) or &lt;e3&gt;constant stored properties&lt;/e3&gt; (introduced by the &lt;c4&gt;&lt;s5&gt;let&lt;/s5&gt;&lt;/c4&gt; keyword).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>格納プロパティは、&lt;e0&gt;変数格納プロパティ&lt;/e0&gt;（&lt;c1&gt;&lt;s2&gt;var&lt;/s2&gt;&lt;/c1&gt;キーワードによって導入される）か&lt;e3&gt;定数格納プロパティ&lt;/e3&gt;（&lt;c4&gt;&lt;s5&gt;let&lt;/s5&gt;&lt;/c4&gt;キーワードによって導入される）であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stored properties cannot be left in an indeterminate state.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>格納プロパティは、不確定な状態のままにされることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stored properties store constant and variable values as part of an instance, whereas computed properties calculate (rather than store) a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>格納プロパティは、あるインスタンスの一部として定数と変数の値を格納します、一方で、計算プロパティは、値を（たくわえておくのではなく）計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stored type properties are lazily initialized on their first access.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>格納型プロパティは、それらの最初のアクセスにおいて遅延して初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stored type properties can be variables or constants.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>格納プロパティは、変数または定数であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stored variables, like stored properties, provide storage for a value of a certain type and allow that value to be set and retrieved.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>格納変数は、格納プロパティの様に、保管場所を特定の型のひとつの値のために用意して、その値の設定と取得を可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Storing the number 10 into &lt;c8&gt;&lt;s9&gt;rectangle.height&lt;/s9&gt;&lt;/c8&gt; succeeds because it’s a small number.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>数10を&lt;c8&gt;&lt;s9&gt;rectangle.height&lt;/s9&gt;&lt;/c8&gt;へと格納することは成功します、なぜならそれは小さな数だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strictly speaking, initializers do not return a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>厳密にいえば、イニシャライザは値を返しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strictly speaking, this version of the &lt;c0&gt;&lt;s1&gt;greet(person:)&lt;/s1&gt;&lt;/c0&gt; function &lt;e2&gt;does&lt;/e2&gt; still return a value, even though no return value is defined.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>厳密に言って、たとえ戻り値が定義されないとしても、このバージョンの&lt;c0&gt;&lt;s1&gt;greet(person:)&lt;/s1&gt;&lt;/c0&gt;関数は、まだ値を&lt;e2&gt;返します&lt;/e2&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strictly speaking, you can write a custom class that conforms to &lt;c0&gt;&lt;s1&gt;CounterDataSource&lt;/s1&gt;&lt;/c0&gt; without implementing &lt;e2&gt;either&lt;/e2&gt; protocol requirement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>厳密に言って、あなたは&lt;c0&gt;&lt;s1&gt;CounterDataSource&lt;/s1&gt;&lt;/c0&gt;に準拠する特注のクラスを書くことが&lt;e2&gt;両方の&lt;/e2&gt;プロトコル要件を満たすことなく可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String Indices</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列インデックス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String Interpolation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列補間</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String Literals</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列リテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String Mutability</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列の可変性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String and Character Equality</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列と文字の同等性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String and character comparisons in Swift are not locale-sensitive.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列および文字の比較はスウィフトではロケールに影響されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String and character equality is checked with the “equal to” operator (&lt;c0&gt;&lt;s1&gt;==&lt;/s1&gt;&lt;/c0&gt;) and the “not equal to” operator (&lt;c2&gt;&lt;s3&gt;!=&lt;/s3&gt;&lt;/c2&gt;), as described in &lt;a4&gt;&lt;s5&gt;Comparison Operators&lt;/s5&gt;&lt;/a4&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列と文字の同等性は、「同等」演算子（&lt;c0&gt;&lt;s1&gt;==&lt;/s1&gt;&lt;/c0&gt;）および「不等」演算子（&lt;c2&gt;&lt;s3&gt;!=&lt;/s3&gt;&lt;/c2&gt;）で調べられます、これは&lt;a4&gt;&lt;s5&gt;比較演算子&lt;/s5&gt;&lt;/a4&gt;で記述されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String literals can include the following special characters:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列リテラルは、以下の特別な文字を含むことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String literals can’t contain an unescaped double quotation mark (&lt;c0&gt;&lt;s1&gt;"&lt;/s1&gt;&lt;/c0&gt;), an unescaped backslash (&lt;c2&gt;&lt;s3&gt;\&lt;/s3&gt;&lt;/c2&gt;), a carriage return, or a line feed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列リテラルは、エスケープされない二重引用符（&lt;c0&gt;&lt;s1&gt;"&lt;/s1&gt;&lt;/c0&gt;）、エスケープされないバックスラッシュ（&lt;c2&gt;&lt;s3&gt;\&lt;/s3&gt;&lt;/c2&gt;）、キャリッジリターン、またはラインフィードを含むことが出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String literals created using extended delimiters can also be multiline string literals.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張区切り文字を使って作成される文字列リテラルは、また複数行文字列リテラルであることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String literals that are concatenated by the &lt;c0&gt;&lt;s1&gt;+&lt;/s1&gt;&lt;/c0&gt; operator are concatenated at compile time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;+&lt;/s1&gt;&lt;/c0&gt;演算子によって連結される文字列リテラルは、コンパイル時に連結されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strings Are Value Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列は値型です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strings and Characters</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列と文字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strong Reference Cycles Between Class Instances</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスインスタンス間の強い参照循環</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strong Reference Cycles for Closures</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャのための強い参照循環</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structure Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structure and Class Instances</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体とクラスのインスタンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structure and enumeration methods that modify &lt;c1&gt;&lt;s2&gt;self&lt;/s2&gt;&lt;/c1&gt; or its properties must mark the instance method as &lt;c3&gt;&lt;s4&gt;mutating&lt;/s4&gt;&lt;/c3&gt;, just like mutating methods from an original implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c1&gt;&lt;s2&gt;self&lt;/s2&gt;&lt;/c1&gt;またはそのプロパティを修正する構造および列挙メソッドは、ちょうど最初の実施からの変更メソッドのように、そのインスタンスメソッドに&lt;c3&gt;&lt;s4&gt;mutating&lt;/s4&gt;&lt;/c3&gt;として印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structure declarations are declared using the &lt;c1&gt;&lt;s2&gt;struct&lt;/s2&gt;&lt;/c1&gt; keyword and have the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体宣言は、キーワード&lt;c1&gt;&lt;s2&gt;struct&lt;/s2&gt;&lt;/c1&gt;を使って宣言されて、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structure declarations can’t contain deinitializer or protocol declarations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造宣言は、デイニシャライザまたはプロトコル宣言を含むことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structure types automatically receive a &lt;e0&gt;memberwise initializer&lt;/e0&gt; if they don’t define any of their own custom initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体型は、それが独自のあつらえのイニシャライザを何ら定義しないならば、自動的に&lt;e0&gt;メンバー関連イニシャライザ&lt;/e0&gt;を受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structure types can adopt any number of protocols, but can’t inherit from classes, enumerations, or other structures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体型は、随意の数のプロトコルに準拠することができます、しかしクラス、列挙、または他の構造体から継承することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structure, enumeration, and class types can have any number of initializers, but the rules and associated behavior for class initializers are different.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体、列挙、そしてクラス型は、随意の数のイニシャライザを持つことができます、しかし、クラスイニシャライザのための規則および関連する挙動は異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structures and Classes</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体とクラス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structures and Enumerations Are Value Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体と列挙は値型です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structures and classes both use initializer syntax for new instances.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体とクラスは両方とも、新しいインスタンスのためにイニシャライザ構文を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structures and classes have a similar definition syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体とクラスは、類似した定義構文を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structures and classes in Swift have many things in common.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでの構造体とクラスは、多くのものを共通して持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structures and enumerations are &lt;e0&gt;value types&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体と列挙は、&lt;e0&gt;値型&lt;/e0&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structures and enumerations are value types, not reference types, and are not stored and passed by reference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造と列挙は値型であって、参照型ではありません、そして参照によって格納されたり渡されたりしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structures and enumerations that conform to the protocol declare the method with the &lt;c2&gt;&lt;s3&gt;static&lt;/s3&gt;&lt;/c2&gt; keyword, and classes that conform to the protocol declare the method with either the &lt;c4&gt;&lt;s5&gt;static&lt;/s5&gt;&lt;/c4&gt; or &lt;c6&gt;&lt;s7&gt;class&lt;/s7&gt;&lt;/c6&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのプロトコルに準拠する構造体と列挙は、&lt;c2&gt;&lt;s3&gt;static&lt;/s3&gt;&lt;/c2&gt;キーワードでメソッドを宣言します、そしてそのプロトコルに準拠するクラスは、&lt;c4&gt;&lt;s5&gt;static&lt;/s5&gt;&lt;/c4&gt;または&lt;c6&gt;&lt;s7&gt;class&lt;/s7&gt;&lt;/c6&gt;キーワードのどちらかでメソッドを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structures and enumerations that conform to the protocol declare the property with the &lt;c2&gt;&lt;s3&gt;static&lt;/s3&gt;&lt;/c2&gt; keyword, and classes that conform to the protocol declare the property with either the &lt;c4&gt;&lt;s5&gt;static&lt;/s5&gt;&lt;/c4&gt; or &lt;c6&gt;&lt;s7&gt;class&lt;/s7&gt;&lt;/c6&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのプロトコルに準拠する構造体と列挙は、&lt;c2&gt;&lt;s3&gt;static&lt;/s3&gt;&lt;/c2&gt;キーワードでプロパティを宣言します、そしてそのプロトコルに準拠するクラスは、&lt;c4&gt;&lt;s5&gt;static&lt;/s5&gt;&lt;/c4&gt;または&lt;c6&gt;&lt;s7&gt;class&lt;/s7&gt;&lt;/c6&gt;キーワードのどちらかでプロパティを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structures and enumerations that conform to the protocol declare the subscript with the &lt;c2&gt;&lt;s3&gt;static&lt;/s3&gt;&lt;/c2&gt; keyword, and classes that conform to the protocol declare the subscript with either the &lt;c4&gt;&lt;s5&gt;static&lt;/s5&gt;&lt;/c4&gt; or &lt;c6&gt;&lt;s7&gt;class&lt;/s7&gt;&lt;/c6&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのプロトコルに準拠する構造体と列挙は、&lt;c2&gt;&lt;s3&gt;static&lt;/s3&gt;&lt;/c2&gt;キーワードで添え字を宣言します、そしてそのプロトコルに準拠するクラスは、&lt;c4&gt;&lt;s5&gt;static&lt;/s5&gt;&lt;/c4&gt;または&lt;c6&gt;&lt;s7&gt;class&lt;/s7&gt;&lt;/c6&gt;キーワードのどちらかで添え字を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structures are value types; instances of a structure are copied when assigned to variables or constants, or when passed as arguments to a function call.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体は、値型です；構造体のインスタンスは、変数や定数に代入される時、または関数呼び出しの引数として渡される時にコピーされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structures support many of the same behaviors as classes, including methods and initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体は、クラスと同じ挙動の多くを、メソッドとイニシャライザも含めてサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structures that have only stored properties that conform to the &lt;c0&gt;&lt;s1&gt;Equatable&lt;/s1&gt;&lt;/c0&gt; protocol</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Equatable&lt;/s1&gt;&lt;/c0&gt;プロトコルに準拠する格納プロパティだけを持つ構造体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subclasses can modify inherited variable properties during initialization, but can not modify inherited constant properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブクラスは、初期化の間に継承された変数プロパティを修正することできます、しかし継承された定数プロパティを変更することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subclasses can themselves be subclassed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブクラスは、それ自身サブクラスを作られることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subclasses can use a superclass expression in their implementation of members, subscripting, and initializers to make use of the implementation in their superclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブクラスは、そのメンバー、添え字、そしてイニシャライザの実装においてスーパークラス式を使うことで、それらのスーバークラス内の実装を活用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subclasses include their superclass name after their class name, separated by a colon.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブクラスたちはそれらのクラス名の後に、コロンで区切られて、それらのスーパークラス名を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subclassing</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブクラスをつくる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscript Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscript Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscript Options</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字オプション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscript Syntax</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字の構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscript Usage</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字の使用法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscript declarations are declared using the &lt;c1&gt;&lt;s2&gt;subscript&lt;/s2&gt;&lt;/c1&gt; keyword and have the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字宣言は、キーワード&lt;c1&gt;&lt;s2&gt;subscript&lt;/s2&gt;&lt;/c1&gt;を使って宣言されて、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscript declarations can appear only in the context of a class, structure, enumeration, extension, or protocol declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字宣言は、クラス、構造体、列挙、拡張、またはプロトコル宣言の文脈においてだけ、現れることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscript declarations only declare the minimum getter and setter implementation requirements for types that conform to the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字宣言は、プロトコルに準拠する型のための最小限のゲッターとセッター実装要件を宣言するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscript parameters follow the same rules as function parameters, with two exceptions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字パラメータは、関数パラメータと同じ規則に従います、２つの例外で。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripts</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripts are not limited to a single dimension, and you can define subscripts with multiple input parameters to suit your custom type’s needs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字は１つの次元に制限されません、なのであなたは複数の入力パラメータをもつ添え字を定義して、あなたのあつらえの型の必要を満たすことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripts are typically used as a shortcut for accessing the member elements in a collection, list, or sequence.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字は、一般的に、コレクション、リスト、またはシーケンスの中のメンバー要素にアクセスするための近道として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripts can also return a value of any type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字はまた、任意の型の値を返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripts can be generic, and they can include generic &lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt; clauses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字は総称体であることができます、そしてそれらは総称体&lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt;節を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripts can take any number of input parameters, and these input parameters can be of any type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字は、任意の数の入力パラメータをとることができます、そしてこれらの入力パラメータはどんな型でもかまいません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subscripts enable you to query instances of a type by writing one or more values in square brackets after the instance name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字は、あなたにそのインスタンス名の後で角括弧の中に１つ以上の値を書くことによって、ある型のインスタンスに問い合わせることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Substrings</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下位文字列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Substrings in Swift have most of the same methods as strings, which means you can work with substrings the same way you work with strings.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでの下位文字列は、文字列とほとんど同じメソッドを持ちます、それはあなたが下位文字列を、文字列を扱うのと同じ方法で扱えることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subtracting &lt;c6&gt;&lt;s7&gt;1&lt;/s7&gt;&lt;/c6&gt; from this binary number with the overflow operator gives a binary value of &lt;c8&gt;&lt;s9&gt;01111111&lt;/s9&gt;&lt;/c8&gt;, which toggles the sign bit and gives positive &lt;c10&gt;&lt;s11&gt;127&lt;/s11&gt;&lt;/c10&gt;, the maximum positive value that an &lt;c12&gt;&lt;s13&gt;Int8&lt;/s13&gt;&lt;/c12&gt; can hold.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この２進数からオーバフロー演算子を使って&lt;c6&gt;&lt;s7&gt;1&lt;/s7&gt;&lt;/c6&gt;を減ずることは、２進数の&lt;c8&gt;&lt;s9&gt;01111111&lt;/s9&gt;&lt;/c8&gt;を与えます、それは符号ビットを切り替えて正の&lt;c10&gt;&lt;s11&gt;127&lt;/s11&gt;&lt;/c10&gt;、&lt;c12&gt;&lt;s13&gt;Int8&lt;/s13&gt;&lt;/c12&gt;が持つことができる最大限の正の値、を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subtraction (&lt;c0&gt;&lt;s1&gt;-&lt;/s1&gt;&lt;/c0&gt;)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>減算（&lt;c0&gt;&lt;s1&gt;-&lt;/s1&gt;&lt;/c0&gt;）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such properties are known as type properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのようなプロパティは、型プロパティとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Summary of the Grammar</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文法の概要</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Superclass Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラス式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Superclass deinitializers are always called, even if a subclass does not provide its own deinitializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラスのデイニシャライザは、たとえサブクラスがそれ自身のデイニシャライザを提供しないとしても、常に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Superclass deinitializers are inherited by their subclasses, and the superclass deinitializer is called automatically at the end of a subclass deinitializer implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラスのデイニシャライザは、それらのサブクラスたちによって継承されます、そして、スーパークラスのデイニシャライザはサブクラスのデイニシャライザ実施の終わりに自動的に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Superclass initializers &lt;e0&gt;are&lt;/e0&gt; inherited in certain circumstances, but only when it is safe and appropriate to do so.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラスのイニシャライザはある特定の状況において継承&lt;e0&gt;されます&lt;/e0&gt;、しかしそれが安全にそして適切にそうできる時だけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift allows this memory-safe code if the compiler can prove that the nonexclusive access to memory is still safe.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、メモリへの非排他アクセスが依然として安全であるとコンパイラが立証できるならば、このメモリ安全コードを許可します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift also handles all memory management involved in disposing of variables when they are no longer needed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトはまた、それがもはや必要とされないとき変数を処分することに関わるすべての記憶管理を取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift also introduces optional types, which handle the absence of a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトはまたオプショナルの型を導入します、それは値の欠如を取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift also makes extensive use of variables whose values can’t be changed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトはまた、それの値が変更されることができない変数を広範囲に利用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift also makes sure that multiple accesses to the same area of memory don’t conflict, by requiring code that modifies a location in memory to have exclusive access to that memory.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトはまた、同じメモリ領域に対する複数のアクセスが衝突しないことを、メモリ中の位置を修正するコードにそのメモリに対する排他的アクセスを持つよう要求することによって確保します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift also provides &lt;e1&gt;unsafe&lt;/e1&gt; unowned references for cases where you need to disable runtime safety checks—for example, for performance reasons.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトはまた&lt;e1&gt;unsafe&lt;/e1&gt;非所有参照を、あなたが実行時安全確認を無効にする必要がある場合のために提供します — 例えば、性能上の理由のために。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift also provides a &lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt; loop that makes it easy to iterate over arrays, dictionaries, ranges, strings, and other sequences.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトはまた、&lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt;ループを提供します、それは、配列、辞書、範囲、文字列、およびその他のシーケンス（連続したもの）の全体にわたって繰り返し処理するのを簡単にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift also provides an unsigned integer type, &lt;c0&gt;&lt;s1&gt;UInt&lt;/s1&gt;&lt;/c0&gt;, which has the same size as the current platform’s native word size:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトはまた、符号なし整数型、&lt;c0&gt;&lt;s1&gt;UInt&lt;/s1&gt;&lt;/c0&gt;を提供します、そしてそれは、現在のプラットホーム固有のワードサイズと同じ大きさを持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift also provides powerful versions of the three primary collection types, &lt;c10&gt;&lt;s11&gt;Array&lt;/s11&gt;&lt;/c10&gt;, &lt;c12&gt;&lt;s13&gt;Set&lt;/s13&gt;&lt;/c12&gt;, and &lt;c14&gt;&lt;s15&gt;Dictionary&lt;/s15&gt;&lt;/c14&gt;, as described in &lt;a16&gt;&lt;s17&gt;Collection Types&lt;/s17&gt;&lt;/a16&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトはまた、３つの主要なコレクション型、&lt;c10&gt;&lt;s11&gt;Array&lt;/s11&gt;&lt;/c10&gt;、&lt;c12&gt;&lt;s13&gt;Set&lt;/s13&gt;&lt;/c12&gt;、そして&lt;c14&gt;&lt;s15&gt;Dictionary&lt;/s15&gt;&lt;/c14&gt;の強力なバージョンを提供します、それは&lt;a16&gt;&lt;s17&gt;「コレクション型」&lt;/s17&gt;&lt;/a16&gt;で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift also provides range operators that aren’t found in C, such as &lt;c0&gt;&lt;s1&gt;a..&lt;b&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;a...b&lt;/s3&gt;&lt;/c2&gt;, as a shortcut for expressing a range of values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトはまた、Cでは見られない範囲演算子、例えば&lt;c0&gt;&lt;s1&gt;a..&lt;b&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;a...b&lt;/s3&gt;&lt;/c2&gt;を、値の範囲を表す近道として提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift also provides two &lt;e0&gt;identity operators&lt;/e0&gt; (&lt;c1&gt;&lt;s2&gt;===&lt;/s2&gt;&lt;/c1&gt; and &lt;c3&gt;&lt;s4&gt;!==&lt;/s4&gt;&lt;/c3&gt;), which you use to test whether two object references both refer to the same object instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトはまた、２つの&lt;e0&gt;同一性演算子&lt;/e0&gt;を提供します（&lt;c1&gt;&lt;s2&gt;===&lt;/s2&gt;&lt;/c1&gt;と&lt;c3&gt;&lt;s4&gt;!==&lt;/s4&gt;&lt;/c3&gt;）、それはあなたが２つのオブジェクト参照が両方とも同じオブジェクト・インスタンスに言及するかどうかについて調べるために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift always chooses &lt;c0&gt;&lt;s1&gt;Double&lt;/s1&gt;&lt;/c0&gt; (rather than &lt;c2&gt;&lt;s3&gt;Float&lt;/s3&gt;&lt;/c2&gt;) when inferring the type of floating-point numbers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>浮動小数点数の型を推論するとき、スウィフトは常に&lt;c0&gt;&lt;s1&gt;Double&lt;/s1&gt;&lt;/c0&gt;を選びます（&lt;c2&gt;&lt;s3&gt;Float&lt;/s3&gt;&lt;/c2&gt;ではなく）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift automatically deallocates your instances when they are no longer needed, to free up resources.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは自動的に、それらがもはや必要とされない場合はあなたのインスタンスを割り当て解除して、資源を自由に使えるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift automatically propagates errors out of their current scope until they’re handled by a &lt;c0&gt;&lt;s1&gt;catch&lt;/s1&gt;&lt;/c0&gt; clause.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは自動的に、エラーをそれの現在のスコープの外に、それが&lt;c0&gt;&lt;s1&gt;catch&lt;/s1&gt;&lt;/c0&gt;節によって取り扱われるまで伝えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift automatically provides shorthand argument names to inline closures, which can be used to refer to the values of the closure’s arguments by the names &lt;c0&gt;&lt;s1&gt;$0&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;$1&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;$2&lt;/s5&gt;&lt;/c4&gt;, and so on.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは行内クロージャに自動的に短縮形引数名を提供します、そしてそれは、名前&lt;c0&gt;&lt;s1&gt;$0&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;$1&lt;/s3&gt;&lt;/c2&gt;、&lt;c4&gt;&lt;s5&gt;$2&lt;/s5&gt;&lt;/c4&gt;、などにでクロージャの引数の値に言及するために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift can infer associated types, which lets you use an opaque return value in places where a protocol type can’t be used as a return value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは関連型を推論できます、それはあなたに不透明戻り値を、プロトコル型が戻り値として使われることができないところあちこちで使用させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift can therefore infer that &lt;c6&gt;&lt;s7&gt;Element&lt;/s7&gt;&lt;/c6&gt; is the appropriate type to use as the &lt;c8&gt;&lt;s9&gt;Item&lt;/s9&gt;&lt;/c8&gt; for this particular container.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、したがって&lt;c6&gt;&lt;s7&gt;Element&lt;/s7&gt;&lt;/c6&gt;が、この特定のコンテナのための&lt;c8&gt;&lt;s9&gt;Item&lt;/s9&gt;&lt;/c8&gt;として使うのに適当な型であると推測することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift classes do not inherit from a universal base class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのクラスたちは、ひとつの共通の基盤クラスから継承はしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift code is compiled and optimized to get the most out of modern hardware.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトコードは、モダンなハードウェアを最大限活用するようにコンパイルおよび最適化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift combines powerful type inference and pattern matching with a modern, lightweight syntax, allowing complex ideas to be expressed in a clear and concise manner.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、強力な型インターフェイスおよびパターンマッチングをモダンで、軽量な構文と結び付けて、複雑なアイデアが明瞭で簡潔な流儀で表されるようにしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift defines a &lt;c0&gt;&lt;s1&gt;Never&lt;/s1&gt;&lt;/c0&gt; type, which indicates that a function or method doesn’t return to its caller.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは&lt;c0&gt;&lt;s1&gt;Never&lt;/s1&gt;&lt;/c0&gt;型を定義します、それはある関数またはメソッドがそれの呼び出し側に帰らないことを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift defines away large classes of common programming errors by adopting modern programming patterns:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、よくあるプログラミング過失のうちの主要な種類を、以下のモダンなプログラミングパターンを採用することによって遠ざけます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift defines numerous precedence groups to go along with the operators provided by the standard library.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、標準ライブラリによって提供される演算子と一緒にやっていくために、多数の優先順位グループを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift defines two kinds of initializers for class types to help ensure all stored properties receive an initial value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、クラス型のために２種類のイニシャライザを定義して、全ての格納プロパティが初期値を受け取ることを確実にするのを手伝います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift enumeration cases don’t have an integer value set by default, unlike languages like C and Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト列挙は、CおよびObjective-Cのような言語と違い、初期状態で設定される整数値を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift enumerations are particularly well suited to modeling a group of related error conditions, with associated values allowing for additional information about the nature of an error to be communicated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト列挙は、関連値がエラーの性質についての追加の情報と通信可能にすることを含め、関係のあるエラー状況のグループを作るのにとりわけ適します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift exposes a collection of all the cases as an &lt;c3&gt;&lt;s4&gt;allCases&lt;/s4&gt;&lt;/c3&gt; property of the enumeration type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、ケース節すべてからなるコレクションを、列挙型の&lt;c3&gt;&lt;s4&gt;allCases&lt;/s4&gt;&lt;/c3&gt;プロパティとして公開します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift gives you a warning if you use an optional value where a value of type &lt;c2&gt;&lt;s3&gt;Any&lt;/s3&gt;&lt;/c2&gt; is expected.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、あなたがオプショナル値を型&lt;c2&gt;&lt;s3&gt;Any&lt;/s3&gt;&lt;/c2&gt;が期待されるところで使うならば警告を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift gives you the freedom to define your own custom infix, prefix, postfix, and assignment operators, with custom precedence and associativity values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、あなたに、特注の優先順位と結合性値で、あなた自身のあつらえの接中辞、接頭辞、接尾辞、そして代入演算子を定義する自由を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift handles all of the memory management of capturing for you.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、キャプチャ（その瞬間の保存）の記憶管理の全てを、あなたのために取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift handles the memory management of instances through &lt;e0&gt;automatic reference counting&lt;/e0&gt; (&lt;e1&gt;ARC&lt;/e1&gt;), as described in &lt;a2&gt;&lt;s3&gt;Automatic Reference Counting&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、&lt;a2&gt;&lt;s3&gt;自動参照カウント&lt;/s3&gt;&lt;/a2&gt;で記述されるように、インスタンスのメモリ管理を&lt;e0&gt;自動参照カウント&lt;/e0&gt;（&lt;e1&gt;ARC&lt;/e1&gt;）を通して取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift has a basic &lt;e0&gt;Boolean&lt;/e0&gt; type, called &lt;c1&gt;&lt;s2&gt;Bool&lt;/s2&gt;&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、ひとつの基本的な&lt;e0&gt;ブール&lt;/e0&gt;型を持ちます、それは&lt;c1&gt;&lt;s2&gt;Bool&lt;/s2&gt;&lt;/c1&gt;と呼ばれるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift has been years in the making, and it continues to evolve with new features and capabilities.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトはその作成に幾年かを費やしています、そしてそれは新しい特徴と能力で発展し続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift has built-in support for checking API availability, which ensures that you don’t accidentally use APIs that are unavailable on a given deployment target.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、API有効性確認のための組み込みのサポートを持ちます、それはあなたが特定の開発対象で有効でないAPIをうっかり使うことがないのを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift has five control transfer statements:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、５つの制御移動文を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift has five control transfer statements: a &lt;c0&gt;&lt;s1&gt;break&lt;/s1&gt;&lt;/c0&gt; statement, a &lt;c2&gt;&lt;s3&gt;continue&lt;/s3&gt;&lt;/c2&gt; statement, a &lt;c4&gt;&lt;s5&gt;fallthrough&lt;/s5&gt;&lt;/c4&gt; statement, a &lt;c6&gt;&lt;s7&gt;return&lt;/s7&gt;&lt;/c6&gt; statement, and a &lt;c8&gt;&lt;s9&gt;throw&lt;/s9&gt;&lt;/c8&gt; statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、５つの制御移動文を持ちます：&lt;c0&gt;&lt;s1&gt;break&lt;/s1&gt;&lt;/c0&gt;文、&lt;c2&gt;&lt;s3&gt;continue&lt;/s3&gt;&lt;/c2&gt;文、&lt;c4&gt;&lt;s5&gt;fallthrough&lt;/s5&gt;&lt;/c4&gt;文、&lt;c6&gt;&lt;s7&gt;return&lt;/s7&gt;&lt;/c6&gt;文、そして&lt;c8&gt;&lt;s9&gt;throw&lt;/s9&gt;&lt;/c8&gt;文。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift has three branch statements: an &lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt; statement, a &lt;c2&gt;&lt;s3&gt;guard&lt;/s3&gt;&lt;/c2&gt; statement, and a &lt;c4&gt;&lt;s5&gt;switch&lt;/s5&gt;&lt;/c4&gt; statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、３つの分岐文を持ちます：&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt;文、&lt;c2&gt;&lt;s3&gt;guard&lt;/s3&gt;&lt;/c2&gt;文、そして&lt;c4&gt;&lt;s5&gt;switch&lt;/s5&gt;&lt;/c4&gt;文。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift has three compiler control statements: a conditional compilation block a line control statement, and a compile-time diagnostic statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、３つのコンパイラ制御文：条件コンパイルブロック、行制御文、そしてコンパイル時診断文を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift has three loop statements: a &lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt; statement, a &lt;c4&gt;&lt;s5&gt;while&lt;/s5&gt;&lt;/c4&gt; statement, and a &lt;c6&gt;&lt;s7&gt;repeat&lt;/s7&gt;&lt;/c6&gt;-&lt;c8&gt;&lt;s9&gt;while&lt;/s9&gt;&lt;/c8&gt; statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、３つのループ文を持ちます：&lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt;文、&lt;c4&gt;&lt;s5&gt;while&lt;/s5&gt;&lt;/c4&gt;文、そして&lt;c6&gt;&lt;s7&gt;repeat&lt;/s7&gt;&lt;/c6&gt;-&lt;c8&gt;&lt;s9&gt;while&lt;/s9&gt;&lt;/c8&gt;文。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift helps to ensure your overrides are correct by checking that the override definition has a matching superclass definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、あなたの無効化が正しいものであることを、その無効化定義がスーパークラス定義に合致するのを確認することによって確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift includes several &lt;e0&gt;range operators&lt;/e0&gt;, which are shortcuts for expressing a range of values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、いくつかの&lt;e0&gt;範囲演算子&lt;/e0&gt;を含みます、それらは値の範囲を表す近道です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift is a &lt;e0&gt;type-safe&lt;/e0&gt; language, which means the language helps you to be clear about the types of values your code can work with.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは&lt;e0&gt;型安全&lt;/e0&gt;な言語です、それが意味するのは、この言語があなたを助けて、あなたのコードが扱うことができる値の型について明確であるようにすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift is a &lt;e0&gt;type-safe&lt;/e0&gt; language.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、&lt;e0&gt;型安全&lt;/e0&gt;な言語です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift is a fantastic way to write software, whether it’s for phones, desktops, servers, or anything else that runs code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトはソフトウェアを記述する素晴らしい方法です、コードを実行するのが電話、デスクトップ、サーバー、または何か他のものであろうともです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift is a new programming language for iOS, macOS, watchOS, and tvOS app development.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、iOS、macOS、watchOS、そしてtvOSアプリ開発のための新しいプログラミング言語です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift is a type-safe language, and doesn’t allow (for example) a variable of type &lt;c8&gt;&lt;s9&gt;String&lt;/s9&gt;&lt;/c8&gt; and a variable of type &lt;c10&gt;&lt;s11&gt;Double&lt;/s11&gt;&lt;/c10&gt; to swap values with each other.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは型安全な言語です、それで（例えば）型&lt;c8&gt;&lt;s9&gt;String&lt;/s9&gt;&lt;/c8&gt;の変数と型&lt;c10&gt;&lt;s11&gt;Double&lt;/s11&gt;&lt;/c10&gt;の変数にお互いに値を交換させることをしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift is friendly to new programmers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、新規プログラマーに好意的です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift makes it easy to provide tailored implementations of these operators and to determine exactly what their behavior should be for each type you create.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、それら演算子の注文仕立ての実装を提供することについて、そしてそれらの挙動があなたがつくる各型のために正確にどういったものでなければならないかについて決定することを簡単にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift marks redundant protocol conformances as an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、冗長なプロトコル準拠をエラーであると印します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift now has a &lt;a0&gt;&lt;s1&gt;Nil-Coalescing Operator&lt;/s1&gt;&lt;/a0&gt; (&lt;c2&gt;&lt;s3&gt;a&lt;/s3&gt; &lt;s4&gt;??&lt;/s4&gt; &lt;s5&gt;b&lt;/s5&gt;&lt;/c2&gt;), which unwraps an optional’s value if it exists, or returns a default value if the optional is &lt;c6&gt;&lt;s7&gt;nil&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは今や&lt;a0&gt;&lt;s1&gt;nil合体演算子&lt;/s1&gt;&lt;/a0&gt;（&lt;c2&gt;&lt;s3&gt;a&lt;/s3&gt; &lt;s4&gt;??&lt;/s4&gt; &lt;s5&gt;b&lt;/s5&gt;&lt;/c2&gt;）をもちます、それはあるオプショナルの値を、もしそれが存在するならばアンラップします、またはそのオプショナルが&lt;c6&gt;&lt;s7&gt;nil&lt;/s7&gt;&lt;/c6&gt;ならばある省略時の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift now has a native &lt;c0&gt;&lt;s1&gt;Set&lt;/s1&gt;&lt;/c0&gt; collection type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは今では持って生まれた&lt;c0&gt;&lt;s1&gt;Set&lt;/s1&gt;&lt;/c0&gt;コレクション型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift now includes the &lt;c0&gt;&lt;s1&gt;as?&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;as!&lt;/s3&gt;&lt;/c2&gt; failable downcast operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは今では失敗できるダウンキャスト演算子&lt;c0&gt;&lt;s1&gt;as?&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;as!&lt;/s3&gt;&lt;/c2&gt;を含めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift picks which implementation of &lt;c4&gt;&lt;s5&gt;log()&lt;/s5&gt;&lt;/c4&gt; to call by consulting only the minimum requirements that &lt;c6&gt;&lt;s7&gt;Pair&lt;/s7&gt;&lt;/c6&gt; needs to conform to &lt;c8&gt;&lt;s9&gt;Loggable&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、&lt;c4&gt;&lt;s5&gt;log()&lt;/s5&gt;&lt;/c4&gt;の実装のどれを呼び出すかの選択を、&lt;c6&gt;&lt;s7&gt;Pair&lt;/s7&gt;&lt;/c6&gt;が&lt;c8&gt;&lt;s9&gt;Loggable&lt;/s9&gt;&lt;/c8&gt;に準拠するために必要とする最小限の要件のみを考慮することで行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift produces a warning if the default case matches any enumeration case that is known at compiler time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは警告を生成します、もしそのdefaultケース節がコンパイル時に既知である何らかの列挙ケース節に合致するならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides a &lt;e0&gt;default initializer&lt;/e0&gt; for any structure or class that provides default values for all of its properties and does not provide at least one initializer itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、それのもつプロパティの全てに省略時の値を与えて、ともかく１つのイニシャライザもそれ自身では提供しないあらゆる構造体またはクラスのために、&lt;e0&gt;省略時のイニシャライザ&lt;/e0&gt;を用意します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides a variety of control flow statements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、さまざまな制御の流れ文を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides an additional integer type, &lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt;, which has the same size as the current platform’s native word size:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは追加の整数型、&lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt;を提供します、そしてそれは、現在のプラットホーム固有のワードサイズと同じ大きさを持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides an elegant solution to this problem, known as a &lt;e0&gt;closure capture list&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトはこの問題の洗練された解答、&lt;e0&gt;クロージャ捕獲リスト&lt;/e0&gt;として知られるものを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides first-class support for throwing, catching, propagating, and manipulating recoverable errors at runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、回復可能なエラーのスロー、キャッチ、伝達、そして取り扱いに対してファーストクラスのサポートを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides five different &lt;e0&gt;access levels&lt;/e0&gt; for entities within your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、５つの異なる&lt;e0&gt;アクセス水準&lt;/e0&gt;をあなたのコード内の実在に対して用意します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides five levels of access control: open, public, internal, file private, and private.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、５つの水準のアクセス制御を提供します：公開、内部、そして非公開。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides its own versions of all fundamental C and Objective-C types, including &lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt; for integers, &lt;c2&gt;&lt;s3&gt;Double&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;Float&lt;/s5&gt;&lt;/c4&gt; for floating-point values, &lt;c6&gt;&lt;s7&gt;Bool&lt;/s7&gt;&lt;/c6&gt; for Boolean values, and &lt;c8&gt;&lt;s9&gt;String&lt;/s9&gt;&lt;/c8&gt; for textual data.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、全ての基本的なCおよびObjective-C型に関してそれ自身のバージョンを提供します、それには、整数のための&lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt;、浮動小数点値のための&lt;c2&gt;&lt;s3&gt;Double&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;Float&lt;/s5&gt;&lt;/c4&gt;、ブール値のための&lt;c6&gt;&lt;s7&gt;Bool&lt;/s7&gt;&lt;/c6&gt;、そして、文字情報データのための&lt;c8&gt;&lt;s9&gt;String&lt;/s9&gt;&lt;/c8&gt;を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides several different ways to access Unicode representations of strings.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、文字列のUnicode表現にアクセスするためにいくつかの異なる方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides signed and unsigned integers in 8, 16, 32, and 64 bit forms.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、８、16、32、そして64ビット形式で、符号つきおよび符号なし整数を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides synthesized implementations for the following kinds of custom types:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、合成された実装を以下の種類のあつらえの方に対して提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides the following Interface Builder attributes: &lt;c0&gt;&lt;s1&gt;IBAction&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;IBSegueAction&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;IBOutlet&lt;/s5&gt;&lt;/c4&gt;, &lt;c6&gt;&lt;s7&gt;IBDesignable&lt;/s7&gt;&lt;/c6&gt;, and &lt;c8&gt;&lt;s9&gt;IBInspectable&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、以下のインターフェイスビルダー属性を提供します：&lt;c0&gt;&lt;s1&gt;IBAction&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;IBSegueAction&lt;/s3&gt;&lt;/c2&gt;、&lt;c4&gt;&lt;s5&gt;IBOutlet&lt;/s5&gt;&lt;/c4&gt;、&lt;c6&gt;&lt;s7&gt;IBDesignable&lt;/s7&gt;&lt;/c6&gt;、そして&lt;c8&gt;&lt;s9&gt;IBInspectable&lt;/s9&gt;&lt;/c8&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides three arithmetic &lt;e0&gt;overflow operators&lt;/e0&gt; that opt in to the overflow behavior for integer calculations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、整数計算のためにオーバフロー挙動を選択する３つの&lt;e0&gt;算術オーバフロー演算子&lt;/e0&gt;を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides three primary &lt;e0&gt;collection types&lt;/e0&gt;, known as arrays, sets, and dictionaries, for storing collections of values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは３つの主要な&lt;e0&gt;コレクション型&lt;/e0&gt;を提供します、それらは配列、集合、そして辞書として知られ、値の集まり（コレクション）をしまっておくためのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides three ways to compare textual values: string and character equality, prefix equality, and suffix equality.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、テキスト関連の値を比較する３つの方法を提供します：文字列および文字の等式、接頭辞等式、そして接尾辞等式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides two Boolean constant values, &lt;c4&gt;&lt;s5&gt;true&lt;/s5&gt;&lt;/c4&gt; and &lt;c6&gt;&lt;s7&gt;false&lt;/s7&gt;&lt;/c6&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは２つのブールの定数値、&lt;c4&gt;&lt;s5&gt;true&lt;/s5&gt;&lt;/c4&gt;と&lt;c6&gt;&lt;s7&gt;false&lt;/s7&gt;&lt;/c6&gt;を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides two forms of syntactic sugar for initialization of a property wrapper.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、２つの形式の糖衣構文をプロパティラッパーの初期化に対して提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides two kinds of &lt;c4&gt;&lt;s5&gt;while&lt;/s5&gt;&lt;/c4&gt; loops:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは２種類の&lt;c4&gt;&lt;s5&gt;while&lt;/s5&gt;&lt;/c4&gt;ループを提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides two signed floating-point number types:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、２つの符号つき浮動小数点数型を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides two special types for working with nonspecific types:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、２つの特別な型を「不特定」の型を扱うために提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides two ways to add conditional branches to your code: the &lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt; statement and the &lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt; statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは条件分岐をあなたのコードに加える２つの方法：&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt;文と&lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt;文を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift provides two ways to resolve strong reference cycles when you work with properties of class type: weak references and unowned references.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがクラス型のプロパティを扱うとき、スウィフトは強い参照循環を解消する２つの道を提供します：弱い参照と非所有参照。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift reports an error at compile time if you try to use an API that isn’t available.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、あなたが有効でないAPIを使おうと試みるならば、コンパイル時にエラーを報告します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift requires you to write &lt;c0&gt;&lt;s1&gt;self.someProperty&lt;/s1&gt;&lt;/c0&gt; or &lt;c2&gt;&lt;s3&gt;self.someMethod()&lt;/s3&gt;&lt;/c2&gt; (rather than just &lt;c4&gt;&lt;s5&gt;someProperty&lt;/s5&gt;&lt;/c4&gt; or &lt;c6&gt;&lt;s7&gt;someMethod()&lt;/s7&gt;&lt;/c6&gt;) whenever you refer to a member of &lt;c8&gt;&lt;s9&gt;self&lt;/s9&gt;&lt;/c8&gt; within a closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトはあなたに&lt;c0&gt;&lt;s1&gt;self.someProperty&lt;/s1&gt;&lt;/c0&gt;または&lt;c2&gt;&lt;s3&gt;self.someMethod()&lt;/s3&gt;&lt;/c2&gt;（ただ単に&lt;c4&gt;&lt;s5&gt;someProperty&lt;/s5&gt;&lt;/c4&gt;または&lt;c6&gt;&lt;s7&gt;someMethod()&lt;/s7&gt;&lt;/c6&gt;ではなく）を書くことを、あなたがクロージャ内で&lt;c8&gt;&lt;s9&gt;self&lt;/s9&gt;&lt;/c8&gt;のメンバーに言及するときはいつでも、要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift strings are represented by the &lt;c6&gt;&lt;s7&gt;String&lt;/s7&gt;&lt;/c6&gt; type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの文字列は&lt;c6&gt;&lt;s7&gt;String&lt;/s7&gt;&lt;/c6&gt;型によって表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift supports all of the bitwise operators found in C, as described below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、下記のように、Cで見つけられるビット単位演算子の全てをサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift supports all standard C &lt;e0&gt;comparison operators&lt;/e0&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、標準的なC &lt;e0&gt;比較演算子&lt;/e0&gt;の全てをサポートします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift supports most standard C operators and improves several capabilities to eliminate common coding errors.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、ほとんどの標準のC演算子をサポートして、一般的なコード記述エラーを排除するためにいくつかの能力を向上させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift supports the four standard &lt;e0&gt;arithmetic operators&lt;/e0&gt; for all number types:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、４つの標準の&lt;e0&gt;算術演算子&lt;/e0&gt;を数の型すべてに対してサポートします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift supports the three standard logical operators found in C-based languages:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、Cに基づく言語で見られる３つの標準の論理演算子をサポートします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift treats the assignment like a &lt;c0&gt;&lt;s1&gt;wrappedValue&lt;/s1&gt;&lt;/c0&gt; argument and uses the initializer that accepts the arguments you include.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、その代入を&lt;c0&gt;&lt;s1&gt;wrappedValue&lt;/s1&gt;&lt;/c0&gt;引数のように扱います、そしてあなたが含める引数を受け入れるイニシャライザを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift unifies these concepts into a single property declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、これらの概念をだだ１つのプロパティ宣言に統一します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift uses &lt;e0&gt;Automatic Reference Counting&lt;/e0&gt; (ARC) to track and manage your app’s memory usage.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、あなたのアプリのメモリ使用を追跡して管理するために、&lt;e0&gt;自動参照カウント（ARC）&lt;/e0&gt;を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift uses &lt;e0&gt;capture lists&lt;/e0&gt; to break these strong reference cycles.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、これらの強い参照循環を壊すために&lt;e0&gt;捕獲リスト&lt;/e0&gt;を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift uses &lt;e0&gt;string interpolation&lt;/e0&gt; to include the name of a constant or variable as a placeholder in a longer string, and to prompt Swift to replace it with the current value of that constant or variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは、定数または変数の名前をより長い文字列の中にプレースホルダーとして含めるために、そしてそれをその定数または変数の現在の値と取り替えることをスウィフトに促すために、&lt;e0&gt;文字列補間&lt;/e0&gt;を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift uses &lt;e0&gt;type inference&lt;/e0&gt; extensively, allowing you to omit the type or part of the type of many variables and expressions in your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトは広く&lt;e0&gt;型推論&lt;/e0&gt;を使います、そして、あなたのコードにおいて多くの変数および式の型または型の一部をあなたが省略できるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s &lt;c0&gt;&lt;s1&gt;Array&lt;/s1&gt;&lt;/c0&gt; type already provides an &lt;c2&gt;&lt;s3&gt;append(_:)&lt;/s3&gt;&lt;/c2&gt; method, a &lt;c4&gt;&lt;s5&gt;count&lt;/s5&gt;&lt;/c4&gt; property, and a subscript with an &lt;c6&gt;&lt;s7&gt;Int&lt;/s7&gt;&lt;/c6&gt; index to retrieve its elements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの&lt;c0&gt;&lt;s1&gt;Array&lt;/s1&gt;&lt;/c0&gt;型は、すでに&lt;c2&gt;&lt;s3&gt;append(_:)&lt;/s3&gt;&lt;/c2&gt;メソッド、&lt;c4&gt;&lt;s5&gt;count&lt;/s5&gt;&lt;/c4&gt;プロパティ、そしてその要素を取り出すために&lt;c6&gt;&lt;s7&gt;Int&lt;/s7&gt;&lt;/c6&gt;インデックスを使う添え字を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s &lt;c0&gt;&lt;s1&gt;Array&lt;/s1&gt;&lt;/c0&gt; type also provides an initializer for creating an array of a certain size with all of its values set to the same default value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの&lt;c0&gt;&lt;s1&gt;Array&lt;/s1&gt;&lt;/c0&gt;型はまた、その値の全てが提供された同じ初期値に設定される、特定の大きさの配列をつくるためにイニシャライザを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s &lt;c0&gt;&lt;s1&gt;Array&lt;/s1&gt;&lt;/c0&gt; type is bridged to Foundation’s &lt;c2&gt;&lt;s3&gt;NSArray&lt;/s3&gt;&lt;/c2&gt; class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの&lt;c0&gt;&lt;s1&gt;Array&lt;/s1&gt;&lt;/c0&gt;型はFoundationの&lt;c2&gt;&lt;s3&gt;NSArray&lt;/s3&gt;&lt;/c2&gt;クラスにブリッジ（橋渡し）されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s &lt;c0&gt;&lt;s1&gt;Array&lt;/s1&gt;&lt;/c0&gt; type now has full value semantics.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの&lt;c0&gt;&lt;s1&gt;Array&lt;/s1&gt;&lt;/c0&gt;型は現在は完全な値意味論を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s &lt;c0&gt;&lt;s1&gt;Dictionary&lt;/s1&gt;&lt;/c0&gt; type does not have a defined ordering.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの&lt;c0&gt;&lt;s1&gt;Dictionary&lt;/s1&gt;&lt;/c0&gt;型は、決まった順序を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s &lt;c0&gt;&lt;s1&gt;Dictionary&lt;/s1&gt;&lt;/c0&gt; type implements its key-value subscripting as a subscript that takes and returns an &lt;e2&gt;optional&lt;/e2&gt; type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの&lt;c0&gt;&lt;s1&gt;Dictionary&lt;/s1&gt;&lt;/c0&gt;型は、それの「キーと値」に関する添え字を、&lt;e2&gt;オプショナル&lt;/e2&gt;型を受け取り返す添え字として実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s &lt;c0&gt;&lt;s1&gt;Dictionary&lt;/s1&gt;&lt;/c0&gt; type is bridged to Foundation’s &lt;c2&gt;&lt;s3&gt;NSDictionary&lt;/s3&gt;&lt;/c2&gt; class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの&lt;c0&gt;&lt;s1&gt;Dictionary&lt;/s1&gt;&lt;/c0&gt;型は、Foundationの&lt;c2&gt;&lt;s3&gt;NSDictionary&lt;/s3&gt;&lt;/c2&gt;クラスにブリッジ（橋渡し）します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s &lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt; type has an initializer which tries to convert a &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt; value into an &lt;c4&gt;&lt;s5&gt;Int&lt;/s5&gt;&lt;/c4&gt; value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの&lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt;型はあるイニシャライザを持ちます、それは&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;値を&lt;c4&gt;&lt;s5&gt;Int値&lt;/s5&gt;&lt;/c4&gt;に変換することを試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s &lt;c0&gt;&lt;s1&gt;Set&lt;/s1&gt;&lt;/c0&gt; type does not have a defined ordering.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの&lt;c0&gt;&lt;s1&gt;Set&lt;/s1&gt;&lt;/c0&gt;型は、決まった順番を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s &lt;c0&gt;&lt;s1&gt;Set&lt;/s1&gt;&lt;/c0&gt; type is bridged to Foundation’s &lt;c2&gt;&lt;s3&gt;NSSet&lt;/s3&gt;&lt;/c2&gt; class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの&lt;c0&gt;&lt;s1&gt;Set&lt;/s1&gt;&lt;/c0&gt;型は、Foundationの&lt;c2&gt;&lt;s3&gt;NSSet&lt;/s3&gt;&lt;/c2&gt;クラスにブリッジ（橋渡し）されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;Character&lt;/s3&gt;&lt;/c2&gt; types provide a fast, Unicode-compliant way to work with text in your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;および&lt;c2&gt;&lt;s3&gt;Character&lt;/s3&gt;&lt;/c2&gt;型は、あなたのコードにおいてテキストを処理するために、ある高速な、Unicodeに対応したやり方を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; type is a &lt;e2&gt;value type&lt;/e2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;型は、&lt;e2&gt;値型&lt;/e2&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; type is bridged with Foundation’s &lt;c2&gt;&lt;s3&gt;NSString&lt;/s3&gt;&lt;/c2&gt; class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;型は、&lt;c2&gt;&lt;s3&gt;Foundation&lt;/s3&gt;&lt;/c2&gt;のNSStringクラスを使って橋渡しをされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s &lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt; isn’t the same as &lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt; in Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの&lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;は、Objective-Cでの&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;と同じものではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; statement is considerably more powerful than its counterpart in many C-like languages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;文は、多くのCに似た言語において相当する物よりずっと強力です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s &lt;c1&gt;&lt;s2&gt;String&lt;/s2&gt;&lt;/c1&gt; and &lt;c3&gt;&lt;s4&gt;Character&lt;/s4&gt;&lt;/c3&gt; types are fully Unicode-compliant, as described in this section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの&lt;c1&gt;&lt;s2&gt;String&lt;/s2&gt;&lt;/c1&gt;と&lt;c3&gt;&lt;s4&gt;Character&lt;/s4&gt;&lt;/c3&gt;型は、この節で記述されるように、完全にUnicodeに対応しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s &lt;c1&gt;&lt;s2&gt;String&lt;/s2&gt;&lt;/c1&gt; type defines its string-specific implementation of the greater-than operator (&lt;c3&gt;&lt;s4&gt;&gt;&lt;/s4&gt;&lt;/c3&gt;) as a method that has two parameters of type &lt;c5&gt;&lt;s6&gt;String&lt;/s6&gt;&lt;/c5&gt;, and returns a value of type &lt;c7&gt;&lt;s8&gt;Bool&lt;/s8&gt;&lt;/c7&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの&lt;c1&gt;&lt;s2&gt;String&lt;/s2&gt;&lt;/c1&gt;型は、それの文字列特有の実装の「大なり」演算子（&lt;c3&gt;&lt;s4&gt;&gt;&lt;/s4&gt;&lt;/c3&gt;）をメソッドとして定義します、それは型&lt;c5&gt;&lt;s6&gt;String&lt;/s6&gt;&lt;/c5&gt;の２つのパラメータを持ち、型&lt;c7&gt;&lt;s8&gt;Bool&lt;/s8&gt;&lt;/c7&gt;の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s access control model is based on the concept of modules and source files.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのアクセス制御モデルは、モジュールとソースファイルの概念に基づきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s approach prevents a situation in which a simple initializer from a superclass is inherited by a more specialized subclass and is used to create a new instance of the subclass that is not fully or correctly initialized.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの取り組み方は、スーパークラスのもつ単純なイニシャライザがより特殊化されたサブクラスによって継承されて、充分にまたは正しく初期化されない状態の、サブクラスの新しいインスタンスをつくるのに使われる状況を防ぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s array, set, and dictionary types are implemented as &lt;e0&gt;generic collections&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの配列、集合、そして辞書型は、&lt;e0&gt;総称体のコレクション&lt;/e0&gt;として実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s closure expressions have a clean, clear style, with optimizations that encourage brief, clutter-free syntax in common scenarios.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのクロージャ式は、最適化された、きれいな、明白なスタイルを持ちます、それは、通常さまざまに予想される状況において、簡潔な、混乱のない構文を助長します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s compiler performs four helpful safety-checks to make sure that two-phase initialization is completed without error:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのコンパイラは、２段階初期化がエラーなしで完了されることを確認するために４つの役に立つ安全点検を実行します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s copy-by-default &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; behavior ensures that when a function or method passes you a &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt; value, it’s clear that you own that exact &lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt; value, regardless of where it came from.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの省略時コピーの&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;挙動は、関数またはメソッドがあなたに&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;値を渡すとき、それが来たところに関係なく、あなたがその正確な写しの&lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt;値を所有することが明白なのを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s initialization flow is more flexible in that it lets you set custom initial values, and can cope with types for which &lt;c4&gt;&lt;s5&gt;0&lt;/s5&gt;&lt;/c4&gt; or &lt;c6&gt;&lt;s7&gt;nil&lt;/s7&gt;&lt;/c6&gt; is not a valid default value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それがあなたに好みに合わせた初期値を設定させて、&lt;c4&gt;&lt;s5&gt;0&lt;/s5&gt;&lt;/c4&gt;または&lt;c6&gt;&lt;s7&gt;nil&lt;/s7&gt;&lt;/c6&gt;が有効な省略時の値でない型に対処することができるという点で、スウィフトの初期化の流れはより柔軟です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s native &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; type no longer has an &lt;c2&gt;&lt;s3&gt;uppercaseString&lt;/s3&gt;&lt;/c2&gt; or &lt;c4&gt;&lt;s5&gt;lowercaseString&lt;/s5&gt;&lt;/c4&gt; property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの生粋の&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;型はもはや&lt;c2&gt;&lt;s3&gt;uppercaseString&lt;/s3&gt;&lt;/c2&gt;または&lt;c4&gt;&lt;s5&gt;lowercaseString&lt;/s5&gt;&lt;/c4&gt;プロパティを持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s operator precedences and associativity rules are simpler and more predictable than those found in C and Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの演算子優先順位と結合性規則は、CとObjective-Cで見つけられるそれらより単純でより予測できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s optionals let you indicate the absence of a value for &lt;e6&gt;any type at all&lt;/e6&gt;, without the need for special constants.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトのオプショナルは、あなたに特別な定数の必要なしに&lt;e6&gt;あらゆる全ての型&lt;/e6&gt;の値の欠如を示させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s standard library provides a method called &lt;c0&gt;&lt;s1&gt;sorted(by:)&lt;/s1&gt;&lt;/c0&gt;, which sorts an array of values of a known type, based on the output of a sorting closure that you provide.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの標準ライブラリは&lt;c0&gt;&lt;s1&gt;sorted(by:)&lt;/s1&gt;&lt;/c0&gt;と呼ばれるメソッドを提供します、それは、ある既知の型の値からなる配列の分類を、あなたが提供するあるソート（分類）を行うクロージャの出力に基づき行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s two-phase initialization process is similar to initialization in Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの２段階初期化プロセスは、Objective-Cでの初期化に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s type checker is able to deduce that &lt;c8&gt;&lt;s9&gt;Movie&lt;/s9&gt;&lt;/c8&gt; and &lt;c10&gt;&lt;s11&gt;Song&lt;/s11&gt;&lt;/c10&gt; have a common superclass of &lt;c12&gt;&lt;s13&gt;MediaItem&lt;/s13&gt;&lt;/c12&gt;, and so it infers a type of &lt;c14&gt;&lt;s15&gt;[MediaItem]&lt;/s15&gt;&lt;/c14&gt; for the &lt;c16&gt;&lt;s17&gt;library&lt;/s17&gt;&lt;/c16&gt; array:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの型チェッカーは&lt;c8&gt;&lt;s9&gt;Movie&lt;/s9&gt;&lt;/c8&gt;と&lt;c10&gt;&lt;s11&gt;Song&lt;/s11&gt;&lt;/c10&gt;が共通のスーパークラス&lt;c12&gt;&lt;s13&gt;MediaItem&lt;/s13&gt;&lt;/c12&gt;を持つと推論することができます、なのでそれは&lt;c16&gt;&lt;s17&gt;library&lt;/s17&gt;&lt;/c16&gt;配列に対して&lt;c14&gt;&lt;s15&gt;[MediaItem]&lt;/s15&gt;&lt;/c14&gt;型を推論します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s type safety prevents non-Boolean values from being substituted for &lt;c0&gt;&lt;s1&gt;Bool&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの型安全は、非ブール値が&lt;c0&gt;&lt;s1&gt;Bool&lt;/s1&gt;&lt;/c0&gt;の代用にされるのを妨げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Swift’s unified function syntax is flexible enough to express anything from a simple C-style function with no parameter names to a complex Objective-C-style method with names and argument labels for each parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの統合された関数構文は、十分な柔軟性があり、パラメータ名を持たない単純なCスタイルの関数から、各パラメータに対して名前および引数ラベルをもつ複雑なObjective-Cスタイルのメソッドまで、何でも表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Switch</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スイッチ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Switch Case Attributes</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スイッチケース節属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Switch Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スイッチ文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Switch Statements Must Be Exhaustive</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スイッチ文は徹底的でなければなりません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Switches support any kind of data and a wide variety of comparison operations—they aren’t limited to integers and tests for equality.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スイッチ（条件分岐）は、あらゆる種類のデータおよび多種多様な比較操作をサポートします ― それは、整数および同等性に対する検査に限られていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Switching Over Future Enumeration Cases</seg>
      </tuv>
      <tuv lang="JA">
        <seg>未来列挙ケース節に対してスイッチする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Switching over a nonfrozen enumeration requires extra consideration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非凍結列挙に対してスイッチすることは、余分な考慮を必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Syntactic categories are indicated by &lt;e0&gt;italic&lt;/e0&gt; text and appear on both sides of a grammar production rule.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>統語論のカテゴリーは、&lt;e0&gt;イタリック&lt;/e0&gt;のテキストによって示されて、文法導出規則の両側に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Syntactically, a variadic parameter consists of a base type name followed immediately by three dots (&lt;c1&gt;&lt;s2&gt;...&lt;/s2&gt;&lt;/c1&gt;), as in &lt;c3&gt;&lt;s4&gt;Int...&lt;/s4&gt;&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>統語的には、可変長パラメータは、&lt;c3&gt;&lt;s4&gt;Int...&lt;/s4&gt;&lt;/c3&gt;のように、基となる型名に直ちに３つの点（&lt;c1&gt;&lt;s2&gt;...&lt;/s2&gt;&lt;/c1&gt;）が続くものから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Syntactically, every primary expression is also a postfix expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>統語論的に、あらゆる基本式は、また、接尾辞式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Syntax for Designated and Convenience Initializers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定および便宜イニシャライザのための構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Taken together, these constraints mean that the value passed for the &lt;c0&gt;&lt;s1&gt;indices&lt;/s1&gt;&lt;/c0&gt; parameter is a sequence of integers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総合すると、これらの制約が意味するのは、&lt;c0&gt;&lt;s1&gt;indices&lt;/s1&gt;&lt;/c0&gt;パラメータに対して渡される値は整数からなるシーケンスであるということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Terminology</seg>
      </tuv>
      <tuv lang="JA">
        <seg>用語</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ternary Conditional Operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>三項条件演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thanks to Swift’s type inference, you don’t actually need to declare a concrete &lt;c0&gt;&lt;s1&gt;Item&lt;/s1&gt;&lt;/c0&gt; of &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt; as part of the definition of &lt;c4&gt;&lt;s5&gt;IntStack&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの型推論のおかげで、あなたは実際には&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;である具体的な&lt;c0&gt;&lt;s1&gt;Item&lt;/s1&gt;&lt;/c0&gt;を&lt;c4&gt;&lt;s5&gt;IntStack&lt;/s5&gt;&lt;/c4&gt;の定義の一部として宣言する必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thanks to Swift’s type inference, you don’t have to write the type of the array if you’re initializing it with an array literal containing values of the same type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの型推論のおかげで、あなたが同じ型の値を含んでいる配列リテラルでそれを初期化しているのならば、あなたは配列の型を書く必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That branch must transfer control to exit the code block in which the &lt;c2&gt;&lt;s3&gt;guard&lt;/s3&gt;&lt;/c2&gt; statement appears.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その分岐は、制御を移して、&lt;c2&gt;&lt;s3&gt;guard&lt;/s3&gt;&lt;/c2&gt;文が現れているコードブロックを脱出する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That function’s caller can then &lt;e1&gt;catch&lt;/e1&gt; the error and respond appropriately.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その関数の呼び出し側はそのときそのエラーを&lt;e1&gt;キャッチして&lt;/e1&gt;（捕まえて）適切に応答することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, an implementation of &lt;c10&gt;&lt;s11&gt;==&lt;/s11&gt;&lt;/c10&gt; must satisfy the following three conditions, for all values &lt;c12&gt;&lt;s13&gt;a&lt;/s13&gt;&lt;/c12&gt;, &lt;c14&gt;&lt;s15&gt;b&lt;/s15&gt;&lt;/c14&gt;, and &lt;c16&gt;&lt;s17&gt;c&lt;/s17&gt;&lt;/c16&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すなわち、&lt;c10&gt;&lt;s11&gt;==&lt;/s11&gt;&lt;/c10&gt;の実装は、以下の３つの条件を&lt;c12&gt;&lt;s13&gt;a&lt;/s13&gt;&lt;/c12&gt;、&lt;c14&gt;&lt;s15&gt;b&lt;/s15&gt;&lt;/c14&gt;、および&lt;c16&gt;&lt;s17&gt;c&lt;/s17&gt;&lt;/c16&gt;すべての値に対して満足させなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, every possible value of the type being considered must be matched by one of the &lt;c3&gt;&lt;s4&gt;switch&lt;/s4&gt;&lt;/c3&gt; cases.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すなわち、考察されている型のすべてのあり得る値が、&lt;c3&gt;&lt;s4&gt;switch&lt;/s4&gt;&lt;/c3&gt;ケース節のうちの１つと適合しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, it must provide a way to make itself uniquely representable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すなわち、それはそれ自身を特有に表わすことを可能にする方法を提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, the code in the first &lt;c8&gt;&lt;s9&gt;defer&lt;/s9&gt;&lt;/c8&gt; statement executes last, the code in the second &lt;c10&gt;&lt;s11&gt;defer&lt;/s11&gt;&lt;/c10&gt; statement executes second to last, and so on.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すなわち、最初の&lt;c8&gt;&lt;s9&gt;defer&lt;/s9&gt;&lt;/c8&gt;文のコードが最後に実行され、２番目の&lt;c10&gt;&lt;s11&gt;defer&lt;/s11&gt;&lt;/c10&gt;文のコードが最後から２番目に実行され、等々。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, the entire &lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt; statement completes its execution as soon as the first matching case is completed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すなわち、最初の適合するケース節が完了されるとすぐに、&lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt;文の全体がその実行を完了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, the type must conform to one of the following Swift standard library protocols: &lt;c0&gt;&lt;s1&gt;ExpressibleByIntegerLiteral&lt;/s1&gt;&lt;/c0&gt; for integer literals, &lt;c2&gt;&lt;s3&gt;ExpressibleByFloatLiteral&lt;/s3&gt;&lt;/c2&gt; for floating-point literals, &lt;c4&gt;&lt;s5&gt;ExpressibleByStringLiteral&lt;/s5&gt;&lt;/c4&gt; for string literals, &lt;c6&gt;&lt;s7&gt;ExpressibleByBooleanLiteral&lt;/s7&gt;&lt;/c6&gt; for Boolean literals, &lt;c8&gt;&lt;s9&gt;ExpressibleByUnicodeScalarLiteral&lt;/s9&gt;&lt;/c8&gt; for string literals that contain only a single Unicode scalar, and &lt;c10&gt;&lt;s11&gt;ExpressibleByExtendedGraphemeClusterLiteral&lt;/s11&gt;&lt;/c10&gt; for string literals that contain only a single extended grapheme cluster.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すなわち、その型は以下のスウィフト標準ライブラリのプロトコルの１つに準拠しなければなりません：整数リテラルに対して&lt;c0&gt;&lt;s1&gt;ExpressibleByIntegerLiteral&lt;/s1&gt;&lt;/c0&gt;、浮動小数点リテラルに対して&lt;c2&gt;&lt;s3&gt;ExpressibleByFloatLiteral&lt;/s3&gt;&lt;/c2&gt;、文字列リテラルに対して&lt;c4&gt;&lt;s5&gt;ExpressibleByStringLiteral&lt;/s5&gt;&lt;/c4&gt;、ブールのリテラルに対して&lt;c6&gt;&lt;s7&gt;ExpressibleByBooleanLiteral&lt;/s7&gt;&lt;/c6&gt;、ただ１つのユニコードスカラーだけを含む文字列リテラルに対して&lt;c8&gt;&lt;s9&gt;ExpressibleByUnicodeScalarLiteral&lt;/s9&gt;&lt;/c8&gt;、そしてただ１つの拡張書記素クラスタだけを含む文字列リテラルに対して&lt;c10&gt;&lt;s11&gt;ExpressibleByExtendedGraphemeClusterLiteral&lt;/s11&gt;&lt;/c10&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, the type of &lt;c0&gt;&lt;s1&gt;x&lt;/s1&gt;&lt;/c0&gt; in &lt;c2&gt;&lt;s3&gt;var&lt;/s3&gt; &lt;s4&gt;x:&lt;/s4&gt; &lt;s5&gt;Int&lt;/s5&gt; &lt;s6&gt;=&lt;/s6&gt; &lt;s7&gt;0&lt;/s7&gt;&lt;/c2&gt; is inferred by first checking the type of &lt;c8&gt;&lt;s9&gt;0&lt;/s9&gt;&lt;/c8&gt; and then passing this type information up to the root (the variable &lt;c10&gt;&lt;s11&gt;x&lt;/s11&gt;&lt;/c10&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すなわち、&lt;c2&gt;&lt;s3&gt;var&lt;/s3&gt; &lt;s4&gt;x:&lt;/s4&gt; &lt;s5&gt;Int&lt;/s5&gt; &lt;s6&gt;=&lt;/s6&gt; &lt;s7&gt;0&lt;/s7&gt;&lt;/c2&gt;の中の&lt;c0&gt;&lt;s1&gt;x&lt;/s1&gt;&lt;/c0&gt;の型は、最初に&lt;c8&gt;&lt;s9&gt;0&lt;/s9&gt;&lt;/c8&gt;の型を調べて、それからこの型情報を根（変数&lt;c10&gt;&lt;s11&gt;x&lt;/s11&gt;&lt;/c10&gt;）までさかのぼって渡すことによって推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That means it can’t use any methods or properties that are defined by the underlying type of the generator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは意味するのは、それが生成子の基礎をなす型によって定義されるどんなメソッドまたはプロパティも使用できないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That said, a nonthrowing method can override a throwing method, and a nonthrowing method can satisfy a protocol requirement for a throwing method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とは言え、非スローメソッドはスローメソッドをオーバーライドできます、そして非スローメソッドはスローメソッドのプロトコル要件を満たすことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That said, a rethrowing method can override a throwing method, and a rethrowing method can satisfy a protocol requirement for a throwing method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とは言え、再スローメソッドはスローメソッドをオーバーライドできます、そして再スローメソッドはスローメソッド用のプロトコル要件を満たすことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That said, because protocols don’t implement their members, most protocol members are declarations only.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とは言え、プロトコルがそれらのメンバーを実装しないので、大部分のプロトコル・メンバーは宣言だけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That said, if a constant is initialized with a class object, the object itself can change, but the binding between the constant name and the object it refers to can’t.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうは言っても、定数がクラスオブジェクトで初期化されるならば、そのオブジェクト自体は変わることができます、しかし、定数名とそれが言及するオブジェクトの間の束縛はそうすることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That said, if a subclass initializes all of its stored properties with default values and doesn’t define any initializers of its own, it inherits all of the superclass’s initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とは言え、サブクラスがそれの格納プロパティのすべてを省略時の値で初期化して、それ自身のイニシャライザを全く定義しないならば、それはそのスーパークラスのイニシャライザのすべてを継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That said, if no initializer &lt;e2&gt;expression&lt;/e2&gt; is present, the variable declaration must include an explicit type annotation (&lt;c3&gt;&lt;s4&gt;:&lt;/s4&gt;&lt;/c3&gt; &lt;e5&gt;type&lt;/e5&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とは言え、イニシャライザ&lt;e2&gt;式&lt;/e2&gt;が存在しないならば、変数の宣言は明確な型注釈（&lt;c3&gt;&lt;s4&gt;:&lt;/s4&gt;&lt;/c3&gt; &lt;e5&gt;type&lt;/e5&gt;）を含まなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That said, if the type you’re extending is defined in another module, an initializer declaration must delegate to an initializer already defined in that module to ensure members of that type are properly initialized.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とは言え、 あなたが拡張している型が別のモジュールにおいて定義されるならば、イニシャライザ宣言はそのモジュールですでに定義されるイニシャライザに委任して、その型のメンバーが正しく初期化されることを確実にしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That said, if you assign a value to a variable or property within its own &lt;c12&gt;&lt;s13&gt;didSet&lt;/s13&gt;&lt;/c12&gt; observer clause, that new value that you assign will replace the one that was just set and passed to the &lt;c14&gt;&lt;s15&gt;willSet&lt;/s15&gt;&lt;/c14&gt; observer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とは言え、あなたが&lt;c12&gt;&lt;s13&gt;didSet&lt;/s13&gt;&lt;/c12&gt;オブザーバー節自身の内部である値を変数またはプロパティに代入するならば、あなたが代入するその新しい値は、ちょうど設定されたばかりの&lt;c14&gt;&lt;s15&gt;willSet&lt;/s15&gt;&lt;/c14&gt;オブザーバーに渡されたものを置き換えることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That said, if you provide a setter clause, you must also provide a getter clause.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とは言え、 あなたがセッター節を提供するならば、あなたはまたゲッター節も提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That said, if you want execution to continue from one case to the next, explicitly include a &lt;c2&gt;&lt;s3&gt;fallthrough&lt;/s3&gt;&lt;/c2&gt; statement, which simply consists of the &lt;c4&gt;&lt;s5&gt;fallthrough&lt;/s5&gt;&lt;/c4&gt; keyword, in the case from which you want execution to continue.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それでもやはり、あなたが実行に１つのケース節から次のものまで続いて欲しいならば、あなたが実行に続いて欲しいケース節で明示的に&lt;c2&gt;&lt;s3&gt;fallthrough&lt;/s3&gt;&lt;/c2&gt;文を含めてください、それは、単にキーワード&lt;c4&gt;&lt;s5&gt;fallthrough&lt;/s5&gt;&lt;/c4&gt;から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That said, it can’t contain any cases that are also marked with the &lt;c2&gt;&lt;s3&gt;indirect&lt;/s3&gt;&lt;/c2&gt; modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とは言うものの、それは&lt;c2&gt;&lt;s3&gt;indirect&lt;/s3&gt;&lt;/c2&gt;修飾子でさらに印されるどんなケース節も含むことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That said, the following changes are available only to code that uses Swift 5.2 or later:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とはいえ、以下の変更はSwift 5.2以降を使用するコードでのみ利用可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That said, the initialization processes must end with a call to a designated initializer that ultimately initializes the class’s properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とは言え、 初期化プロセスは、最終的にそのクラスのプロパティを初期化する指定イニシャライザに対する呼び出しで終わらなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That said, you can mark these protocol member declarations with the &lt;c0&gt;&lt;s1&gt;optional&lt;/s1&gt;&lt;/c0&gt; declaration modifier to specify that their implementation by a conforming type is optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とは言え、 あなたはこれらのプロトコルメンバー宣言を&lt;c0&gt;&lt;s1&gt;optional&lt;/s1&gt;&lt;/c0&gt;宣言修飾子を使って印して、ある準拠型にとってそれらの実装が随意であると指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That said, you can overload a function based on whether a function &lt;e0&gt;parameter&lt;/e0&gt; can throw an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とは言え、あなたは関数を、ある関数&lt;e0&gt;パラメーター&lt;/e0&gt;がエラーをスローできるかどうかに基づいてオーバーロードすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That said, you can use parentheses to be explicit about the scope of the operator’s application.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とは言うものの、あなたは丸括弧を使って演算子の適用範囲について明確にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;"""&lt;/s1&gt;&lt;/c0&gt; that ends the literal determines the indentation: Every nonblank line in the literal must begin with exactly the same indentation that appears before the closing &lt;c2&gt;&lt;s3&gt;"""&lt;/s3&gt;&lt;/c2&gt;; there’s no conversion between tabs and spaces.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リテラルの終わりの&lt;c0&gt;&lt;s1&gt;"""&lt;/s1&gt;&lt;/c0&gt;はその字下げを決定します：リテラルの中のあらゆる空でない行は、閉じている&lt;c2&gt;&lt;s3&gt;"""&lt;/s3&gt;&lt;/c2&gt;の前に現れるのと正確に同じ字下げで始まらなければなりません；タブと空白の間の変換はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;(404,&lt;/s1&gt; &lt;s2&gt;"Not&lt;/s2&gt; &lt;s3&gt;Found")&lt;/s3&gt;&lt;/c0&gt; tuple groups together an &lt;c4&gt;&lt;s5&gt;Int&lt;/s5&gt;&lt;/c4&gt; and a &lt;c6&gt;&lt;s7&gt;String&lt;/s7&gt;&lt;/c6&gt; to give the HTTP status code two separate values: a number and a human-readable description.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この&lt;c0&gt;&lt;s1&gt;(404,&lt;/s1&gt; &lt;s2&gt;"Not&lt;/s2&gt; &lt;s3&gt;Found")&lt;/s3&gt;&lt;/c0&gt;タプルは&lt;c4&gt;&lt;s5&gt;Int&lt;/s5&gt;&lt;/c4&gt;と&lt;c6&gt;&lt;s7&gt;String&lt;/s7&gt;&lt;/c6&gt;をひとつにまとめて、HTTP状態コードに２つの別々の値：数と人間の読める説明を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;@optional&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;@lazy&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;@final&lt;/s5&gt;&lt;/c4&gt;, and &lt;c6&gt;&lt;s7&gt;@required&lt;/s7&gt;&lt;/c6&gt; attributes are now the &lt;c8&gt;&lt;s9&gt;optional&lt;/s9&gt;&lt;/c8&gt;, &lt;c10&gt;&lt;s11&gt;lazy&lt;/s11&gt;&lt;/c10&gt;, &lt;c12&gt;&lt;s13&gt;final&lt;/s13&gt;&lt;/c12&gt;, and &lt;c14&gt;&lt;s15&gt;required&lt;/s15&gt;&lt;/c14&gt; &lt;a16&gt;&lt;s17&gt;Declaration Modifiers&lt;/s17&gt;&lt;/a16&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;@optional&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;@lazy&lt;/s3&gt;&lt;/c2&gt;、&lt;c4&gt;&lt;s5&gt;@final&lt;/s5&gt;&lt;/c4&gt;、そして&lt;c6&gt;&lt;s7&gt;@required&lt;/s7&gt;&lt;/c6&gt;属性は今や&lt;c8&gt;&lt;s9&gt;optional&lt;/s9&gt;&lt;/c8&gt;、&lt;c10&gt;&lt;s11&gt;lazy&lt;/s11&gt;&lt;/c10&gt;、&lt;c12&gt;&lt;s13&gt;final&lt;/s13&gt;&lt;/c12&gt;、そして&lt;c14&gt;&lt;s15&gt;required&lt;/s15&gt;&lt;/c14&gt;&lt;a16&gt;&lt;s17&gt;宣言修飾子です&lt;/s17&gt;&lt;/a16&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;@prefix&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;@postfix&lt;/s3&gt;&lt;/c2&gt; attributes for &lt;a4&gt;&lt;s5&gt;Prefix and Postfix Operators&lt;/s5&gt;&lt;/a4&gt; have been replaced by &lt;c6&gt;&lt;s7&gt;prefix&lt;/s7&gt;&lt;/c6&gt; and &lt;c8&gt;&lt;s9&gt;postfix&lt;/s9&gt;&lt;/c8&gt; declaration modifiers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;@prefix&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;@postfix&lt;/s3&gt;&lt;/c2&gt;属性は&lt;a4&gt;&lt;s5&gt;接頭辞および接尾辞演算子&lt;/s5&gt;&lt;/a4&gt;に対して、&lt;c6&gt;&lt;s7&gt;prefix&lt;/s7&gt;&lt;/c6&gt;と&lt;c8&gt;&lt;s9&gt;postfix&lt;/s9&gt;&lt;/c8&gt;宣言修飾子によって置き換えられました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Address&lt;/s1&gt;&lt;/c0&gt; class also provides a method called &lt;c2&gt;&lt;s3&gt;buildingIdentifier()&lt;/s3&gt;&lt;/c2&gt;, which has a return type of &lt;c4&gt;&lt;s5&gt;String?&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Address&lt;/s1&gt;&lt;/c0&gt;クラスはまた、&lt;c2&gt;&lt;s3&gt;buildingIdentifier()&lt;/s3&gt;&lt;/c2&gt;と呼ばれるメソッドを提供します、それは、&lt;c4&gt;&lt;s5&gt;String?&lt;/s5&gt;&lt;/c4&gt;の戻り型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Any&lt;/s1&gt;&lt;/c0&gt; type represents values of any type, including optional types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Any&lt;/s1&gt;&lt;/c0&gt;型は、オプショナル型を含む、何らかの型の値を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;AudioChannel&lt;/s1&gt;&lt;/c0&gt; structure also defines a stored instance property called &lt;c2&gt;&lt;s3&gt;currentLevel&lt;/s3&gt;&lt;/c2&gt;, which represents the channel’s current audio level on a scale of &lt;c4&gt;&lt;s5&gt;0&lt;/s5&gt;&lt;/c4&gt; to &lt;c6&gt;&lt;s7&gt;10&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;AudioChannel&lt;/s1&gt;&lt;/c0&gt;構造体はまた、&lt;c2&gt;&lt;s3&gt;currentLevel&lt;/s3&gt;&lt;/c2&gt;と呼ばれる格納インスタンスプロパティを定義します、それは、&lt;c4&gt;&lt;s5&gt;0&lt;/s5&gt;&lt;/c4&gt;から&lt;c6&gt;&lt;s7&gt;10&lt;/s7&gt;&lt;/c6&gt;までの目盛りでチャンネルの現在の音声レベルを表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;AudioChannel&lt;/s1&gt;&lt;/c0&gt; structure defines two stored type properties to support its functionality.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;AudioChannel&lt;/s1&gt;&lt;/c0&gt;構造体は、その機能性を支えるために２つの格納型プロパティを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;AutomaticallyNamedDocument&lt;/s1&gt;&lt;/c0&gt; overrides its superclass’s failable &lt;c2&gt;&lt;s3&gt;init?(name:)&lt;/s3&gt;&lt;/c2&gt; initializer with a nonfailable &lt;c4&gt;&lt;s5&gt;init(name:)&lt;/s5&gt;&lt;/c4&gt; initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;AutomaticallyNamedDocument&lt;/s1&gt;&lt;/c0&gt;は、それのスーパークラスの失敗できる&lt;c2&gt;&lt;s3&gt;init?(name:)&lt;/s3&gt;&lt;/c2&gt;イニシャライザを、失敗できない&lt;c4&gt;&lt;s5&gt;init(name:)&lt;/s5&gt;&lt;/c4&gt;イニシャライザでオーバーライドします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Bicycle&lt;/s1&gt;&lt;/c0&gt; subclass defines a custom designated initializer, &lt;c2&gt;&lt;s3&gt;init()&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Bicycle&lt;/s1&gt;&lt;/c0&gt;サブクラスはあつらえの指定イニシャライザ、&lt;c2&gt;&lt;s3&gt;init()&lt;/s3&gt;&lt;/c2&gt;を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;BlackjackCard&lt;/s1&gt;&lt;/c0&gt; structure itself has two properties—&lt;c2&gt;&lt;s3&gt;rank&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;suit&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;BlackjackCard&lt;/s1&gt;&lt;/c0&gt;構造体は、２つのプロパティ ― &lt;c2&gt;&lt;s3&gt;rank&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;suit&lt;/s5&gt;&lt;/c4&gt;を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Circle&lt;/s1&gt;&lt;/c0&gt; class implements the &lt;c2&gt;&lt;s3&gt;area&lt;/s3&gt;&lt;/c2&gt; property requirement as a computed property, based on a stored &lt;c4&gt;&lt;s5&gt;radius&lt;/s5&gt;&lt;/c4&gt; property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Circle&lt;/s1&gt;&lt;/c0&gt;クラスは&lt;c2&gt;&lt;s3&gt;area&lt;/s3&gt;&lt;/c2&gt;プロパティ要件を、格納&lt;c4&gt;&lt;s5&gt;radius&lt;/s5&gt;&lt;/c4&gt;プロパティに基づいて計算プロパティとして、満たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Circle&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;Country&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;Animal&lt;/s5&gt;&lt;/c4&gt; classes don’t have a shared base class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Circle&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;Country&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;Animal&lt;/s5&gt;&lt;/c4&gt;クラスには、共有の基盤クラスがありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Container&lt;/s1&gt;&lt;/c0&gt; protocol defines three required capabilities that any container must provide:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Container&lt;/s1&gt;&lt;/c0&gt;プロトコルは、あらゆるコンテナ（容れ物）が提供しなければならない３つの必須の能力を定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Counter&lt;/s1&gt;&lt;/c0&gt; class also declares a variable property, &lt;c2&gt;&lt;s3&gt;count&lt;/s3&gt;&lt;/c2&gt;, to keep track of the current counter value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Counter&lt;/s1&gt;&lt;/c0&gt;クラスはまた、変数プロパティ、&lt;c2&gt;&lt;s3&gt;count&lt;/s3&gt;&lt;/c2&gt;を宣言して、現在のカウンターの値の情報を得続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Counter&lt;/s1&gt;&lt;/c0&gt; class defines three instance methods:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Counter&lt;/s1&gt;&lt;/c0&gt;クラスは、３つのインスタンスメソッドを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Counter&lt;/s1&gt;&lt;/c0&gt; class stores its current value in a variable property called &lt;c2&gt;&lt;s3&gt;count&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Counter&lt;/s1&gt;&lt;/c0&gt;クラスは、その現在の値を&lt;c2&gt;&lt;s3&gt;count&lt;/s3&gt;&lt;/c2&gt;と呼ばれる変数プロパティに保管します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Counter&lt;/s1&gt;&lt;/c0&gt; class, defined below, has an optional &lt;c2&gt;&lt;s3&gt;dataSource&lt;/s3&gt;&lt;/c2&gt; property of type &lt;c4&gt;&lt;s5&gt;CounterDataSource?&lt;/s5&gt;&lt;/c4&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下で定義される、&lt;c0&gt;&lt;s1&gt;Counter&lt;/s1&gt;&lt;/c0&gt;クラスは、型&lt;c4&gt;&lt;s5&gt;CounterDataSource?&lt;/s5&gt;&lt;/c4&gt;のオプショナルの&lt;c2&gt;&lt;s3&gt;dataSource&lt;/s3&gt;&lt;/c2&gt;プロパティを持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;CounterDataSource&lt;/s1&gt;&lt;/c0&gt; protocol defines an optional method requirement called &lt;c2&gt;&lt;s3&gt;increment(forCount:)&lt;/s3&gt;&lt;/c2&gt; and an optional property requirement called &lt;c4&gt;&lt;s5&gt;fixedIncrement&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;CounterDataSource&lt;/s1&gt;&lt;/c0&gt;プロトコルは、&lt;c2&gt;&lt;s3&gt;incrementForCount(_:)&lt;/s3&gt;&lt;/c2&gt;と呼ばれるオプショナルのメソッド要件と&lt;c4&gt;&lt;s5&gt;fixedIncrement&lt;/s5&gt;&lt;/c4&gt;と呼ばれるオプショナルのプロパティ要件を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Customer&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;CreditCard&lt;/s3&gt;&lt;/c2&gt; example shows a situation where one property that is allowed to be &lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt; and another property that cannot be &lt;c6&gt;&lt;s7&gt;nil&lt;/s7&gt;&lt;/c6&gt; have the potential to cause a strong reference cycle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Customer&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;CreditCard&lt;/s3&gt;&lt;/c2&gt;の例は、&lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;であることを許されるあるプロパティと&lt;c6&gt;&lt;s7&gt;nil&lt;/s7&gt;&lt;/c6&gt;であることができないもう１つのプロパティが強い参照循環を引き起こす可能性をもつ状況を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Customer&lt;/s1&gt;&lt;/c0&gt; instance now has a strong reference to the &lt;c2&gt;&lt;s3&gt;CreditCard&lt;/s3&gt;&lt;/c2&gt; instance, and the &lt;c4&gt;&lt;s5&gt;CreditCard&lt;/s5&gt;&lt;/c4&gt; instance has an unowned reference to the &lt;c6&gt;&lt;s7&gt;Customer&lt;/s7&gt;&lt;/c6&gt; instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Customer&lt;/s1&gt;&lt;/c0&gt;インスタンスは現在&lt;c2&gt;&lt;s3&gt;CreditCard&lt;/s3&gt;&lt;/c2&gt;インスタンスへの強い参照を持ちます、そして、&lt;c4&gt;&lt;s5&gt;CreditCard&lt;/s5&gt;&lt;/c4&gt;インスタンスは&lt;c6&gt;&lt;s7&gt;Customer&lt;/s7&gt;&lt;/c6&gt;インスタンスへの非所有参照を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;DataManager&lt;/s1&gt;&lt;/c0&gt; class has a stored property called &lt;c2&gt;&lt;s3&gt;data&lt;/s3&gt;&lt;/c2&gt;, which is initialized with a new, empty array of &lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt; values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;DataManager&lt;/s1&gt;&lt;/c0&gt;クラスは&lt;c2&gt;&lt;s3&gt;data&lt;/s3&gt;&lt;/c2&gt;と呼ばれる格納プロパティを持ちます、それは、&lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt;値の、新規の、空の配列で初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Dice&lt;/s1&gt;&lt;/c0&gt; class from above can be extended to adopt and conform to &lt;c2&gt;&lt;s3&gt;TextRepresentable&lt;/s3&gt;&lt;/c2&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の&lt;c0&gt;&lt;s1&gt;Dice&lt;/s1&gt;&lt;/c0&gt;クラスは、拡張されることで、&lt;c2&gt;&lt;s3&gt;TextRepresentable&lt;/s3&gt;&lt;/c2&gt;を採用して準拠することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;DiceGame&lt;/s1&gt;&lt;/c0&gt; protocol is a protocol that can be adopted by any game that involves dice.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;DiceGame&lt;/s1&gt;&lt;/c0&gt;プロトコルは、さいころが関わるどんなゲームによってでも採用されることができるプロトコルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;DiceGameDelegate&lt;/s1&gt;&lt;/c0&gt; protocol can be adopted to track the progress of a &lt;c2&gt;&lt;s3&gt;DiceGame&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;DiceGameDelegate&lt;/s1&gt;&lt;/c0&gt;プロトコルが採用されることで、&lt;c2&gt;&lt;s3&gt;DiceGame&lt;/s3&gt;&lt;/c2&gt;の進捗を追いかけることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Food&lt;/s1&gt;&lt;/c0&gt; class also provides a &lt;e2&gt;convenience&lt;/e2&gt; initializer, &lt;c3&gt;&lt;s4&gt;init()&lt;/s4&gt;&lt;/c3&gt;, with no arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Food&lt;/s1&gt;&lt;/c0&gt;クラスはまた、引数のない&lt;e2&gt;便宜&lt;/e2&gt;イニシャライザ、&lt;c3&gt;&lt;s4&gt;init()&lt;/s4&gt;&lt;/c3&gt;を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;FullyNamed&lt;/s1&gt;&lt;/c0&gt; protocol requires a conforming type to provide a fully qualified name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;FullyNamed&lt;/s1&gt;&lt;/c0&gt;プロトコルは、完全修飾名を提供するある準拠型を要件とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;HTMLElement&lt;/s1&gt;&lt;/c0&gt; class defines a &lt;c2&gt;&lt;s3&gt;name&lt;/s3&gt;&lt;/c2&gt; property, which indicates the name of the element, such as &lt;c4&gt;&lt;s5&gt;"h1"&lt;/s5&gt;&lt;/c4&gt; for a heading element, &lt;c6&gt;&lt;s7&gt;"p"&lt;/s7&gt;&lt;/c6&gt; for a paragraph element, or &lt;c8&gt;&lt;s9&gt;"br"&lt;/s9&gt;&lt;/c8&gt; for a line break element.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;HTMLElement&lt;/s1&gt;&lt;/c0&gt;クラスは&lt;c2&gt;&lt;s3&gt;name&lt;/s3&gt;&lt;/c2&gt;プロパティを定義します、それは、要素の名前を示します、例えばヘッダ要素の&lt;c4&gt;&lt;s5&gt;"h1"&lt;/s5&gt;&lt;/c4&gt;、段落要素のための&lt;c6&gt;&lt;s7&gt;"p"&lt;/s7&gt;&lt;/c6&gt;、またはあるいは、改行のための&lt;c8&gt;&lt;s9&gt;"br"&lt;/s9&gt;&lt;/c8&gt;要素など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;HTMLElement&lt;/s1&gt;&lt;/c0&gt; class provides a single initializer, which takes a &lt;c2&gt;&lt;s3&gt;name&lt;/s3&gt;&lt;/c2&gt; argument and (if desired) a &lt;c4&gt;&lt;s5&gt;text&lt;/s5&gt;&lt;/c4&gt; argument to initialize a new element.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;HTMLElement&lt;/s1&gt;&lt;/c0&gt;クラスは１つのイニシャライザを提供します、それは、&lt;c2&gt;&lt;s3&gt;name&lt;/s3&gt;&lt;/c2&gt;引数と（希望する場合には）&lt;c4&gt;&lt;s5&gt;text&lt;/s5&gt;&lt;/c4&gt;引数をとって新しい要素を初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;IntStack&lt;/s1&gt;&lt;/c0&gt; type implements all three of the &lt;c2&gt;&lt;s3&gt;Container&lt;/s3&gt;&lt;/c2&gt; protocol’s requirements, and in each case wraps part of the &lt;c4&gt;&lt;s5&gt;IntStack&lt;/s5&gt;&lt;/c4&gt; type’s existing functionality to satisfy these requirements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;IntStack&lt;/s1&gt;&lt;/c0&gt;型は、&lt;c2&gt;&lt;s3&gt;Container&lt;/s3&gt;&lt;/c2&gt;プロトコルの要件の３つすべてを実装します、そしてそれぞれの場合において、これらの要件を満たすために&lt;c4&gt;&lt;s5&gt;IntStack&lt;/s5&gt;&lt;/c4&gt;型がもつ既存の機能性の一部をラップしています（内部で利用して外側を包む）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;IntStack&lt;/s1&gt;&lt;/c0&gt; type shown above can only be used with &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt; values, however.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、上で示される&lt;c0&gt;&lt;s1&gt;IntStack&lt;/s1&gt;&lt;/c0&gt;型は、&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;値で使われることができるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Item&lt;/s1&gt;&lt;/c0&gt; for &lt;c2&gt;&lt;s3&gt;C1&lt;/s3&gt;&lt;/c2&gt; must be the same as the &lt;c4&gt;&lt;s5&gt;Item&lt;/s5&gt;&lt;/c4&gt; for &lt;c6&gt;&lt;s7&gt;C2&lt;/s7&gt;&lt;/c6&gt; (written as &lt;c8&gt;&lt;s9&gt;C1.Item&lt;/s9&gt; &lt;s10&gt;==&lt;/s10&gt; &lt;s11&gt;C2.Item&lt;/s11&gt;&lt;/c8&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;C1&lt;/s3&gt;&lt;/c2&gt;のための&lt;c0&gt;&lt;s1&gt;Item&lt;/s1&gt;&lt;/c0&gt;は、&lt;c6&gt;&lt;s7&gt;C2&lt;/s7&gt;&lt;/c6&gt;のための&lt;c4&gt;&lt;s5&gt;Item&lt;/s5&gt;&lt;/c4&gt;と同じものでなければなりません（&lt;c8&gt;&lt;s9&gt;C1.Item&lt;/s9&gt; &lt;s10&gt;==&lt;/s10&gt; &lt;s11&gt;C2.Item&lt;/s11&gt;&lt;/c8&gt;のように書かれます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Item&lt;/s1&gt;&lt;/c0&gt; for &lt;c2&gt;&lt;s3&gt;C1&lt;/s3&gt;&lt;/c2&gt; must conform to the &lt;c4&gt;&lt;s5&gt;Equatable&lt;/s5&gt;&lt;/c4&gt; protocol (written as &lt;c6&gt;&lt;s7&gt;C1.Item:&lt;/s7&gt; &lt;s8&gt;Equatable&lt;/s8&gt;&lt;/c6&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;C1&lt;/s3&gt;&lt;/c2&gt;のための&lt;c0&gt;&lt;s1&gt;Item&lt;/s1&gt;&lt;/c0&gt;は、&lt;c4&gt;&lt;s5&gt;Equatable&lt;/s5&gt;&lt;/c4&gt;プロトコルに準拠しなければなりません（&lt;c6&gt;&lt;s7&gt;C1.Item:&lt;/s7&gt; &lt;s8&gt;Equatable&lt;/s8&gt;&lt;/c6&gt;のように書かれます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;LevelTracker&lt;/s1&gt;&lt;/c0&gt; structure is used with the &lt;c2&gt;&lt;s3&gt;Player&lt;/s3&gt;&lt;/c2&gt; class, shown below, to track and update the progress of an individual player:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;LevelTracker&lt;/s1&gt;&lt;/c0&gt;構造体は&lt;c2&gt;&lt;s3&gt;Player&lt;/s3&gt;&lt;/c2&gt;クラスとともに使用され、下で示されるように、個々のプレーヤーの進捗を追跡して更新します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;LevelTracker&lt;/s1&gt;&lt;/c0&gt; structure keeps track of the highest level that any player has unlocked.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;LevelTracker&lt;/s1&gt;&lt;/c0&gt;構造体は、プレーヤーのだれかが鍵を開けた最も高いレベルの情報を得続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;LevelTracker&lt;/s1&gt;&lt;/c0&gt; structure uses type properties and methods to keep track of which levels of the game have been unlocked.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;LevelTracker&lt;/s1&gt;&lt;/c0&gt;構造体は、そのゲームのどのレベルが鍵を開けられているかを追跡し続けるために型プロパティとメソッドを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Matrix&lt;/s1&gt;&lt;/c0&gt; subscript’s getter and setter both contain an assertion to check that the subscript’s &lt;c2&gt;&lt;s3&gt;row&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;column&lt;/s5&gt;&lt;/c4&gt; values are valid.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Matrix&lt;/s1&gt;&lt;/c0&gt;添え字のゲッターとセッターは両方とも、添え字のもつ&lt;c2&gt;&lt;s3&gt;row&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;column&lt;/s5&gt;&lt;/c4&gt;値が有効なことを確認するためにひとつの表明を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;NSCopying&lt;/s1&gt;&lt;/c0&gt; attribute behaves in a way similar to the Objective-C &lt;c2&gt;&lt;s3&gt;copy&lt;/s3&gt;&lt;/c2&gt; property attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;NSCopying&lt;/s1&gt;&lt;/c0&gt;属性は、Objective-Cの&lt;c2&gt;&lt;s3&gt;copy&lt;/s3&gt;&lt;/c2&gt;プロパティ属性に似たやり方でふるまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;NSString&lt;/s1&gt;&lt;/c0&gt; &lt;c2&gt;&lt;s3&gt;length&lt;/s3&gt;&lt;/c2&gt; property is now mapped onto Swift’s native &lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt; type as &lt;c6&gt;&lt;s7&gt;utf16Count&lt;/s7&gt;&lt;/c6&gt;, not &lt;c8&gt;&lt;s9&gt;utf16count&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;NSString&lt;/s1&gt;&lt;/c0&gt;の&lt;c2&gt;&lt;s3&gt;length&lt;/s3&gt;&lt;/c2&gt;プロパティは現在ではスウィフトの生粋の&lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt;型と&lt;c6&gt;&lt;s7&gt;utf16Count&lt;/s7&gt;&lt;/c6&gt;として対応づけられます、&lt;c8&gt;&lt;s9&gt;utf16count&lt;/s9&gt;&lt;/c8&gt;ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Pair&lt;/s1&gt;&lt;/c0&gt; structure conforms to &lt;c2&gt;&lt;s3&gt;Loggable&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;TitledLoggable&lt;/s5&gt;&lt;/c4&gt; whenever its generic type conforms to &lt;c6&gt;&lt;s7&gt;Loggable&lt;/s7&gt;&lt;/c6&gt; or &lt;c8&gt;&lt;s9&gt;TitledLoggable&lt;/s9&gt;&lt;/c8&gt;, respectively.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Pair&lt;/s1&gt;&lt;/c0&gt;構造体は、&lt;c2&gt;&lt;s3&gt;Loggable&lt;/s3&gt;&lt;/c2&gt;および&lt;c4&gt;&lt;s5&gt;TitledLoggable&lt;/s5&gt;&lt;/c4&gt;に準拠します、それの総称体型がそれぞれ&lt;c6&gt;&lt;s7&gt;Loggable&lt;/s7&gt;&lt;/c6&gt;または&lt;c8&gt;&lt;s9&gt;TitledLoggable&lt;/s9&gt;&lt;/c8&gt;に準拠する時はいつでも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;Apartment&lt;/s3&gt;&lt;/c2&gt; example shows a situation where two properties, both of which are allowed to be &lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;, have the potential to cause a strong reference cycle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;Apartment&lt;/s3&gt;&lt;/c2&gt;の例は、２つのプロパティ、両方とも&lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;であることを許されるものが強い参照循環を引き起こす可能性をもつ状況を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt; class has an initializer that sets the instance’s &lt;c2&gt;&lt;s3&gt;name&lt;/s3&gt;&lt;/c2&gt; property and prints a message to indicate that initialization is underway.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt;クラスは、インスタンスの&lt;c2&gt;&lt;s3&gt;name&lt;/s3&gt;&lt;/c2&gt;プロパティを設定して、初期化が進行中であることを示すためにメッセージを出力するイニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt; class is defined in the same way as before:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt;クラスは、前の通りに定義されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt; instance now has a strong reference to the &lt;c2&gt;&lt;s3&gt;Apartment&lt;/s3&gt;&lt;/c2&gt; instance, and the &lt;c4&gt;&lt;s5&gt;Apartment&lt;/s5&gt;&lt;/c4&gt; instance has a strong reference to the &lt;c6&gt;&lt;s7&gt;Person&lt;/s7&gt;&lt;/c6&gt; instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt;インスタンスは現在&lt;c2&gt;&lt;s3&gt;Apartment&lt;/s3&gt;&lt;/c2&gt;インスタンスへの強い参照を持ちます、そして、&lt;c4&gt;&lt;s5&gt;Apartment&lt;/s5&gt;&lt;/c4&gt;インスタンスは&lt;c6&gt;&lt;s7&gt;Person&lt;/s7&gt;&lt;/c6&gt;インスタンスへの強い参照を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt; instance still has a strong reference to the &lt;c2&gt;&lt;s3&gt;Apartment&lt;/s3&gt;&lt;/c2&gt; instance, but the &lt;c4&gt;&lt;s5&gt;Apartment&lt;/s5&gt;&lt;/c4&gt; instance now has a &lt;e6&gt;weak&lt;/e6&gt; reference to the &lt;c7&gt;&lt;s8&gt;Person&lt;/s8&gt;&lt;/c7&gt; instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt;インスタンスは依然として&lt;c2&gt;&lt;s3&gt;Apartment&lt;/s3&gt;&lt;/c2&gt;インスタンスへの強い参照を持ちます、しかし、&lt;c4&gt;&lt;s5&gt;Apartment&lt;/s5&gt;&lt;/c4&gt;インスタンスは現在は&lt;c7&gt;&lt;s8&gt;Person&lt;/s8&gt;&lt;/c7&gt;インスタンスへの&lt;e6&gt;弱い&lt;/e6&gt;参照を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Player&lt;/s1&gt;&lt;/c0&gt; class creates a new instance of &lt;c2&gt;&lt;s3&gt;LevelTracker&lt;/s3&gt;&lt;/c2&gt; to track that player’s progress.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Player&lt;/s1&gt;&lt;/c0&gt;クラスは、そのプレーヤーの進捗を追うために&lt;c2&gt;&lt;s3&gt;LevelTracker&lt;/s3&gt;&lt;/c2&gt;の新しいインスタンスをつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Player&lt;/s1&gt;&lt;/c0&gt; class defines a &lt;c2&gt;&lt;s3&gt;win(coins:)&lt;/s3&gt;&lt;/c2&gt; method, which retrieves a certain number of coins from the bank and adds them to the player’s purse.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Player&lt;/s1&gt;&lt;/c0&gt;クラスは&lt;c2&gt;&lt;s3&gt;win(coins:)&lt;/s3&gt;&lt;/c2&gt;メソッドを定義します、それは、胴元からコインの特定の数を取り戻して、それらをプレーヤーの財布に加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Player&lt;/s1&gt;&lt;/c0&gt; class describes a player in the game.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Player&lt;/s1&gt;&lt;/c0&gt;クラスは、ゲームにおけるプレーヤーを記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Point&lt;/s1&gt;&lt;/c0&gt; structure above defines a mutating &lt;c2&gt;&lt;s3&gt;moveBy(x:y:)&lt;/s3&gt;&lt;/c2&gt; method, which moves a &lt;c4&gt;&lt;s5&gt;Point&lt;/s5&gt;&lt;/c4&gt; instance by a certain amount.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の&lt;c0&gt;&lt;s1&gt;Point構&lt;/s1&gt;&lt;/c0&gt;造体は変更&lt;c2&gt;&lt;s3&gt;moveBy(x:y:)&lt;/s3&gt;&lt;/c2&gt;メソッドを定義します、それは、&lt;c4&gt;&lt;s5&gt;Point&lt;/s5&gt;&lt;/c4&gt;インスタンスを特定の量だけ動かします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;RandomNumberGenerator&lt;/s1&gt;&lt;/c0&gt; protocol doesn’t make any assumptions about how each random number will be generated—it simply requires the generator to provide a standard way to generate a new random number.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;RandomNumberGenerator&lt;/s1&gt;&lt;/c0&gt;プロトコルは、乱数それぞれが生成される方法について、全く仮定しません ― それは単に生成器に新しい乱数を生み出す標準の方法を提供することを要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Rank&lt;/s1&gt;&lt;/c0&gt; enumeration describes the thirteen possible playing card ranks, together with a raw &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt; value to represent their face value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Rank&lt;/s1&gt;&lt;/c0&gt;列挙は、13のあり得るトランプカードの等級を、それらの額面を表す生の&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;値と共に記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;RecipeIngredient&lt;/s1&gt;&lt;/c0&gt; class has a single designated initializer, &lt;c2&gt;&lt;s3&gt;init(name:&lt;/s3&gt; &lt;s4&gt;String,&lt;/s4&gt; &lt;s5&gt;quantity:&lt;/s5&gt; &lt;s6&gt;Int)&lt;/s6&gt;&lt;/c2&gt;, which can be used to populate all of the properties of a new &lt;c7&gt;&lt;s8&gt;RecipeIngredient&lt;/s8&gt;&lt;/c7&gt; instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;RecipeIngredient&lt;/s1&gt;&lt;/c0&gt;クラスは、１つの指定イニシャライザ、&lt;c2&gt;&lt;s3&gt;init(name:&lt;/s3&gt; &lt;s4&gt;String,&lt;/s4&gt; &lt;s5&gt;quantity:&lt;/s5&gt; &lt;s6&gt;Int)&lt;/s6&gt;&lt;/c2&gt;を持ちます、それは、新しい&lt;c7&gt;&lt;s8&gt;RecipeIngredient&lt;/s8&gt;&lt;/c7&gt;インスタンスのプロパティの全てに何か入れるために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Rect&lt;/s1&gt;&lt;/c0&gt; structure also provides a computed property called &lt;c2&gt;&lt;s3&gt;center&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Rect&lt;/s1&gt;&lt;/c0&gt;構造体はまた、&lt;c2&gt;&lt;s3&gt;center&lt;/s3&gt;&lt;/c2&gt;（中心）と呼ばれる計算プロパティを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Residence&lt;/s1&gt;&lt;/c0&gt; class is more complex than before.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Residence&lt;/s1&gt;&lt;/c0&gt;クラスは、前より複雑です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Resolution&lt;/s1&gt;&lt;/c0&gt; structure definition and the &lt;c2&gt;&lt;s3&gt;VideoMode&lt;/s3&gt;&lt;/c2&gt; class definition only describe what a &lt;c4&gt;&lt;s5&gt;Resolution&lt;/s5&gt;&lt;/c4&gt; or &lt;c6&gt;&lt;s7&gt;VideoMode&lt;/s7&gt;&lt;/c6&gt; will look like.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Resolution&lt;/s1&gt;&lt;/c0&gt;構造体定義と&lt;c2&gt;&lt;s3&gt;VideoMode&lt;/s3&gt;&lt;/c2&gt;クラス定義は、&lt;c4&gt;&lt;s5&gt;Resolution&lt;/s5&gt;&lt;/c4&gt;または&lt;c6&gt;&lt;s7&gt;VideoMode&lt;/s7&gt;&lt;/c6&gt;がどのようなものかについて記述するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Room&lt;/s1&gt;&lt;/c0&gt; class used for the &lt;c2&gt;&lt;s3&gt;rooms&lt;/s3&gt;&lt;/c2&gt; array is a simple class with one property called &lt;c4&gt;&lt;s5&gt;name&lt;/s5&gt;&lt;/c4&gt;, and an initializer to set that property to a suitable room name:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;rooms&lt;/s3&gt;&lt;/c2&gt;配列のために使用される&lt;c0&gt;&lt;s1&gt;Room&lt;/s1&gt;&lt;/c0&gt;クラスは、&lt;c4&gt;&lt;s5&gt;name&lt;/s5&gt;&lt;/c4&gt;と呼ばれる１つのプロパティ、そしてそのプロパティを適切な部屋名に設定するイニシャライザをもつ単純なクラスです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Self&lt;/s1&gt;&lt;/c0&gt; type isn’t a specific type, but rather lets you conveniently refer to the current type without repeating or knowing that type’s name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Self&lt;/s1&gt;&lt;/c0&gt;型は、特定の型ではありません、しかしいくぶんあなたに便利に現在の型を参照させます、その型の名前を繰り返すことまたは知ることなしに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Self&lt;/s1&gt;&lt;/c0&gt; type refers to the same type as the &lt;a2&gt;&lt;c3&gt;&lt;s4&gt;type(of:)&lt;/s4&gt;&lt;/c3&gt;&lt;/a2&gt;&lt;s5&gt; [https://developer.apple.com/documentation/swift/2885064-type]&lt;/s5&gt; function in the Swift standard library.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Self&lt;/s1&gt;&lt;/c0&gt;型は、スウィフト標準ライブラリの中の&lt;a2&gt;&lt;c3&gt;&lt;s4&gt;type(of:)&lt;/s4&gt;&lt;/c3&gt;&lt;/a2&gt;&lt;s5&gt; [https://developer.apple.com/documentation/swift/2885064-type]&lt;/s5&gt;関数と同じ型を参照します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Size&lt;/s1&gt;&lt;/c0&gt; structure automatically receives an &lt;c2&gt;&lt;s3&gt;init(width:height:)&lt;/s3&gt;&lt;/c2&gt; memberwise initializer, which you can use to initialize a new &lt;c4&gt;&lt;s5&gt;Size&lt;/s5&gt;&lt;/c4&gt; instance:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Size&lt;/s1&gt;&lt;/c0&gt;構造体は自動的にメンバー関連イニシャライザ&lt;c2&gt;&lt;s3&gt;init(width:height:)&lt;/s3&gt;&lt;/c2&gt;を受け取ります、それは、あなたが新しい&lt;c4&gt;&lt;s5&gt;Size&lt;/s5&gt;&lt;/c4&gt;インスタンスを初期化するために使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;SnakesAndLadders&lt;/s1&gt;&lt;/c0&gt; class can be extended to adopt and conform to &lt;c2&gt;&lt;s3&gt;PrettyTextRepresentable&lt;/s3&gt;&lt;/c2&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;SnakesAndLadders&lt;/s1&gt;&lt;/c0&gt;クラスは、拡張されることで&lt;c2&gt;&lt;s3&gt;PrettyTextRepresentable&lt;/s3&gt;&lt;/c2&gt;を採用して準拠するようにできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;StepCounter&lt;/s1&gt;&lt;/c0&gt; class declares a &lt;c2&gt;&lt;s3&gt;totalSteps&lt;/s3&gt;&lt;/c2&gt; property of type &lt;c4&gt;&lt;s5&gt;Int&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;StepCounter&lt;/s1&gt;&lt;/c0&gt;クラスは、型&lt;c4&gt;&lt;s5&gt;Int&lt;/s5&gt;&lt;/c4&gt;の&lt;c2&gt;&lt;s3&gt;totalSteps&lt;/s3&gt;&lt;/c2&gt;プロパティを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Suit&lt;/s1&gt;&lt;/c0&gt; enumeration describes the four common playing card suits, together with a raw &lt;c2&gt;&lt;s3&gt;Character&lt;/s3&gt;&lt;/c2&gt; value to represent their symbol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Suit&lt;/s1&gt;&lt;/c0&gt;列挙は、トランプの４つの通常のスート（組み札）を、それらの記号を表す生の&lt;c2&gt;&lt;s3&gt;Character&lt;/s3&gt;&lt;/c2&gt;値と共に記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;TowardsZeroSource&lt;/s1&gt;&lt;/c0&gt; class implements the optional &lt;c2&gt;&lt;s3&gt;increment(forCount:)&lt;/s3&gt;&lt;/c2&gt; method from the &lt;c4&gt;&lt;s5&gt;CounterDataSource&lt;/s5&gt;&lt;/c4&gt; protocol and uses the &lt;c6&gt;&lt;s7&gt;count&lt;/s7&gt;&lt;/c6&gt; argument value to work out which direction to count in.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;TowardsZeroSource&lt;/s1&gt;&lt;/c0&gt;クラスは、&lt;c4&gt;&lt;s5&gt;CounterDataSource&lt;/s5&gt;&lt;/c4&gt;プロトコルからのオプショナルの&lt;c2&gt;&lt;s3&gt;increment(forCount:)&lt;/s3&gt;&lt;/c2&gt;メソッドを実装して、どの方向に数えるべきか解決するために&lt;c6&gt;&lt;s7&gt;count&lt;/s7&gt;&lt;/c6&gt;引数値を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;TrackedString&lt;/s1&gt;&lt;/c0&gt; structure and the &lt;c2&gt;&lt;s3&gt;value&lt;/s3&gt;&lt;/c2&gt; property don’t provide an explicit access-level modifier, and so they both receive the default access level of internal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;TrackedString&lt;/s1&gt;&lt;/c0&gt;構造体と&lt;c2&gt;&lt;s3&gt;value&lt;/s3&gt;&lt;/c2&gt;プロパティは明確なアクセス水準修飾子を提供しません、なので、それらは両方とも省略時のアクセス水準である内部を受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;TrackedString&lt;/s1&gt;&lt;/c0&gt; structure defines a stored string property called &lt;c2&gt;&lt;s3&gt;value&lt;/s3&gt;&lt;/c2&gt;, with an initial value of &lt;c4&gt;&lt;s5&gt;""&lt;/s5&gt;&lt;/c4&gt; (an empty string).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;TrackedString&lt;/s1&gt;&lt;/c0&gt;構造体は、&lt;c2&gt;&lt;s3&gt;value&lt;/s3&gt;&lt;/c2&gt;と呼ばれる格納文字列プロパティを、&lt;c4&gt;&lt;s5&gt;""&lt;/s5&gt;&lt;/c4&gt;（空の文字列）の初期値で定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Vehicle&lt;/s1&gt;&lt;/c0&gt; base class also defines a method called &lt;c2&gt;&lt;s3&gt;makeNoise&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Vehicle&lt;/s1&gt;&lt;/c0&gt;クラスはまた、&lt;c2&gt;&lt;s3&gt;makeNoise&lt;/s3&gt;&lt;/c2&gt;と呼ばれるメソッドを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Vehicle&lt;/s1&gt;&lt;/c0&gt; class defines common characteristics for an arbitrary vehicle, but is not much use in itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Vehicle&lt;/s1&gt;&lt;/c0&gt;クラスは、任意の乗物のためのありふれた特徴を定義します、しかしそれ自体では余り役に立ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;Vehicle&lt;/s1&gt;&lt;/c0&gt; class provides a default value for its only stored property, and does not provide any custom initializers itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Vehicle&lt;/s1&gt;&lt;/c0&gt;クラスは、それの格納プロパティのためにのみ省略時の値を提供します、そしてそれ自身では何らあつらえのイニシャライザを提供しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;_height&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;_width&lt;/s3&gt;&lt;/c2&gt; properties store an instance of the property wrapper, &lt;c4&gt;&lt;s5&gt;TwelveOrLess&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;_height&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;_width&lt;/s3&gt;&lt;/c2&gt;プロパティは、プロパティラッパー、&lt;c4&gt;&lt;s5&gt;TwelveOrLess&lt;/s5&gt;&lt;/c4&gt;のインスタンスを格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;addTwoInts(_:_:)&lt;/s1&gt;&lt;/c0&gt; function has the same type as the &lt;c2&gt;&lt;s3&gt;mathFunction&lt;/s3&gt;&lt;/c2&gt; variable, and so this assignment is allowed by Swift’s type-checker.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;addTwoInts(_:_:)&lt;/s1&gt;&lt;/c0&gt;関数は&lt;c2&gt;&lt;s3&gt;mathFunction&lt;/s3&gt;&lt;/c2&gt;変数と同じ型を持ちます、なので、この代入はスウィフトの型チェッカーによって認められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;addition&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;multiplication&lt;/s3&gt;&lt;/c2&gt; cases have associated values that are also arithmetic expressions—these associated values make it possible to nest expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;addition&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;multiplication&lt;/s3&gt;&lt;/c2&gt;ケース節は、それもまた算術式である関連値を持ちます—これらの関連値がそれを入れ子式可能なものにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;airports&lt;/s1&gt;&lt;/c0&gt; dictionary is declared as a variable (with the &lt;c2&gt;&lt;s3&gt;var&lt;/s3&gt;&lt;/c2&gt; introducer), and not a constant (with the &lt;c4&gt;&lt;s5&gt;let&lt;/s5&gt;&lt;/c4&gt; introducer), because more airports are added to the dictionary in the examples below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;airports&lt;/s1&gt;&lt;/c0&gt;辞書は、変数として（&lt;c2&gt;&lt;s3&gt;var&lt;/s3&gt;&lt;/c2&gt;導入子を使って）宣言されます、定数（&lt;c4&gt;&lt;s5&gt;let&lt;/s5&gt;&lt;/c4&gt;導入子を使って）ではなく、なぜならより多くの空港が下記の例でこの辞書に加えられるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;airports&lt;/s1&gt;&lt;/c0&gt; dictionary is declared as having a type of &lt;c2&gt;&lt;s3&gt;[String:&lt;/s3&gt; &lt;s4&gt;String]&lt;/s4&gt;&lt;/c2&gt;, which means “a &lt;c5&gt;&lt;s6&gt;Dictionary&lt;/s6&gt;&lt;/c5&gt; whose keys are of type &lt;c7&gt;&lt;s8&gt;String&lt;/s8&gt;&lt;/c7&gt;, and whose values are also of type &lt;c9&gt;&lt;s10&gt;String&lt;/s10&gt;&lt;/c9&gt;”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;airports&lt;/s1&gt;&lt;/c0&gt;辞書は、&lt;c2&gt;&lt;s3&gt;[String:&lt;/s3&gt; &lt;s4&gt;String]&lt;/s4&gt;&lt;/c2&gt;の型を持つとして宣言されます、それは「キーが型&lt;c7&gt;&lt;s8&gt;String&lt;/s8&gt;&lt;/c7&gt;であり、値もまた型&lt;c9&gt;&lt;s10&gt;String&lt;/s10&gt;&lt;/c9&gt;である&lt;c5&gt;&lt;s6&gt;Dictionary&lt;/s6&gt;&lt;/c5&gt;」を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;airports&lt;/s1&gt;&lt;/c0&gt; dictionary is initialized with a dictionary literal containing two key-value pairs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;airports&lt;/s1&gt;&lt;/c0&gt;辞書は、２つの「キーと値」の対を含んでいるひとつの辞書リテラルで初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;allEqual()&lt;/s1&gt;&lt;/c0&gt; method returns &lt;c2&gt;&lt;s3&gt;true&lt;/s3&gt;&lt;/c2&gt; only if all the elements in the collection are equal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;allEqual()&lt;/s1&gt;&lt;/c0&gt;メソッドが&lt;c2&gt;&lt;s3&gt;true&lt;/s3&gt;&lt;/c2&gt;を返すのは、そのコレクションの中の要素すべてが同等である場合のみです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;allItemsMatch(_:_:)&lt;/s1&gt;&lt;/c0&gt; function starts by checking that both containers contain the same number of items.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;allItemsMatch(_:_:)&lt;/s1&gt;&lt;/c0&gt;関数は、両方のコンテナが同じ数の項目を含むことを確認することによって始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;arch(arm)&lt;/s1&gt;&lt;/c0&gt; platform condition does not return &lt;c2&gt;&lt;s3&gt;true&lt;/s3&gt;&lt;/c2&gt; for ARM 64 devices.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;arch(arm)&lt;/s1&gt;&lt;/c0&gt;プラットホーム条件は、ARM 64機器に対して&lt;c2&gt;&lt;s3&gt;true&lt;/s3&gt;&lt;/c2&gt;を返しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;as!&lt;/s1&gt;&lt;/c0&gt; operator performs a forced cast of the &lt;e2&gt;expression&lt;/e2&gt; to the specified &lt;e3&gt;type&lt;/e3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;as!&lt;/s1&gt;&lt;/c0&gt;演算子は&lt;e2&gt;式&lt;/e2&gt;の指定された&lt;e3&gt;型&lt;/e3&gt;への強制的なキャストを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;as!&lt;/s1&gt;&lt;/c0&gt; version of the downcast operator forces the downcast to the protocol type and triggers a runtime error if the downcast doesn’t succeed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;as!&lt;/s1&gt;&lt;/c0&gt;版のダウンキャスト演算子は、そのプロトコル型へのダウンキャストを強制して、ダウンキャストが成功しなかったならば実行時エラーの引き金を引きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;as&lt;/s1&gt;&lt;/c0&gt; operator performs a cast when it is known at compile time that the cast always succeeds, such as upcasting or bridging.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;as&lt;/s1&gt;&lt;/c0&gt;演算子は、コンパイル時にそのキャストが常に成功することを知られているキャストを実行します、例えばアップキャストやブリッジなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;as&lt;/s1&gt;&lt;/c0&gt; pattern matches a value if the type of that value at runtime is the same as the type specified in the right-hand side of the &lt;c2&gt;&lt;s3&gt;as&lt;/s3&gt;&lt;/c2&gt; pattern—or a subclass of that type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;as&lt;/s1&gt;&lt;/c0&gt;パターンは、ある値にマッチします、もしその値の実行時での型が&lt;c2&gt;&lt;s3&gt;as&lt;/s3&gt;&lt;/c2&gt;パターンの右側で指定される型 ― または、それの型のサブクラス ― と同じものであるならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;as?&lt;/s1&gt;&lt;/c0&gt; operator performs a conditional cast of the &lt;e2&gt;expression&lt;/e2&gt; to the specified &lt;e3&gt;type&lt;/e3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;as?&lt;/s1&gt;&lt;/c0&gt;演算子は&lt;e2&gt;式&lt;/e2&gt;の指定された&lt;e3&gt;型&lt;/e3&gt;への条件付きキャストを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;as?&lt;/s1&gt;&lt;/c0&gt; version of the downcast operator returns an optional value of the protocol’s type, and this value is &lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt; if the instance doesn’t conform to that protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;as?&lt;/s1&gt;&lt;/c0&gt;版のダウンキャスト演算子は、そのプロトコルの型のオプショナルの値を返します、そしてインスタンスがそのプロトコルに準拠しないならばその値は&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;asHTML&lt;/s1&gt;&lt;/c0&gt; property is declared as a lazy property, because it’s only needed if and when the element actually needs to be rendered as a string value for some HTML output target.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;asHTML&lt;/s1&gt;&lt;/c0&gt;プロパティは遅延プロパティとして宣言されます、なぜなら、要素が何らかのHTML出力対象のために実際に文字列値として解釈される必要がもしもあるときのみそれが必要なだけだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;asHTML&lt;/s1&gt;&lt;/c0&gt; property is named and used somewhat like an instance method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;asHTML&lt;/s1&gt;&lt;/c0&gt;プロパティは、いくぶんインスタンスメソッドのように名前をつけられて、使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;available&lt;/s1&gt;&lt;/c0&gt; attribute always appears with a list of two or more comma-separated attribute arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;available&lt;/s1&gt;&lt;/c0&gt;属性は、常に２つ以上のコンマで区切られた属性引数とともに現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;balance(_:_:)&lt;/s1&gt;&lt;/c0&gt; function above modifies its two parameters to divide the total value evenly between them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の&lt;c0&gt;&lt;s1&gt;balance(_:_:)&lt;/s1&gt;&lt;/c0&gt;関数は、それの２つのパラメータを修正して、それらの間でその合計値を均等に分割するようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;beginConcert(in:)&lt;/s1&gt;&lt;/c0&gt; function takes a parameter of type &lt;c2&gt;&lt;s3&gt;Location&lt;/s3&gt; &lt;s4&gt;&amp;&lt;/s4&gt; &lt;s5&gt;Named&lt;/s5&gt;&lt;/c2&gt;, which means “any type that’s a subclass of &lt;c6&gt;&lt;s7&gt;Location&lt;/s7&gt;&lt;/c6&gt; and that conforms to the &lt;c8&gt;&lt;s9&gt;Named&lt;/s9&gt;&lt;/c8&gt; protocol.” In this case, &lt;c10&gt;&lt;s11&gt;City&lt;/s11&gt;&lt;/c10&gt; satisfies both requirements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;beginConcert(in:)&lt;/s1&gt;&lt;/c0&gt;関数は、型&lt;c2&gt;&lt;s3&gt;Location&lt;/s3&gt; &lt;s4&gt;&amp;&lt;/s4&gt; &lt;s5&gt;Named&lt;/s5&gt;&lt;/c2&gt;のパラメータを１つとります、それは「&lt;c6&gt;&lt;s7&gt;Location&lt;/s7&gt;&lt;/c6&gt;のサブクラスであり、&lt;c8&gt;&lt;s9&gt;Named&lt;/s9&gt;&lt;/c8&gt;プロトコルに準拠する何らかの型」を意味します。この場合では、&lt;c10&gt;&lt;s11&gt;City&lt;/s11&gt;&lt;/c10&gt;は両方の要件を満たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;block&lt;/s1&gt;&lt;/c0&gt; argument indicates an Objective-C compatible block reference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;block&lt;/s1&gt;&lt;/c0&gt;引数は、Objective-C互換ブロック参照を指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;boardColors&lt;/s1&gt;&lt;/c0&gt; array is initialized with a closure to set up its color values:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;boardColors&lt;/s1&gt;&lt;/c0&gt;配列は、その色値を設定するために、クロージャで初期化されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;break&lt;/s1&gt; &lt;s2&gt;gameLoop&lt;/s2&gt;&lt;/c0&gt; statement transfers control to the first line of code outside of the &lt;c3&gt;&lt;s4&gt;while&lt;/s4&gt;&lt;/c3&gt; loop, which ends the game.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;break&lt;/s1&gt; &lt;s2&gt;gameLoop&lt;/s2&gt;&lt;/c0&gt;文は、制御を&lt;c3&gt;&lt;s4&gt;while&lt;/s4&gt;&lt;/c3&gt;ループの外側のコードの最初の行へ移します、そしてゲームを終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;break&lt;/s1&gt;&lt;/c0&gt; statement ends execution of an entire control flow statement immediately.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;break&lt;/s1&gt;&lt;/c0&gt;文は、ある制御の流れに関する文まるまる全体の実行を直ちに終えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;c&lt;/s1&gt;&lt;/c0&gt; argument indicates a C function reference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;c&lt;/s1&gt;&lt;/c0&gt;引数は、C関数参照を指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;capitalCity&lt;/s1&gt;&lt;/c0&gt; property can be used and accessed like a non-optional value once initialization is complete, while still avoiding a strong reference cycle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;capitalCity&lt;/s1&gt;&lt;/c0&gt;プロパティは、一旦初期化が完了すれば、非オプショナルの値のように使用およびアクセスされることが可能です、その一方で依然として強い参照循環を防ぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;case&lt;/s1&gt;&lt;/c0&gt; above has two patterns: &lt;c2&gt;&lt;s3&gt;(let&lt;/s3&gt; &lt;s4&gt;distance,&lt;/s4&gt; &lt;s5&gt;0)&lt;/s5&gt;&lt;/c2&gt; matches points on the x-axis and &lt;c6&gt;&lt;s7&gt;(0,&lt;/s7&gt; &lt;s8&gt;let&lt;/s8&gt; &lt;s9&gt;distance)&lt;/s9&gt;&lt;/c6&gt; matches points on the y-axis.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の&lt;c0&gt;&lt;s1&gt;case&lt;/s1&gt;&lt;/c0&gt;は、２つのパターンを持ちます：&lt;c2&gt;&lt;s3&gt;(let&lt;/s3&gt; &lt;s4&gt;distance,&lt;/s4&gt; &lt;s5&gt;0)&lt;/s5&gt;&lt;/c2&gt;はx軸上の点にマッチします、そして&lt;c6&gt;&lt;s7&gt;(0,&lt;/s7&gt; &lt;s8&gt;let&lt;/s8&gt; &lt;s9&gt;distance)&lt;/s9&gt;&lt;/c6&gt;はy軸上の点にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;catch&lt;/s1&gt;&lt;/c0&gt; clauses don’t have to handle every possible error that the code in the &lt;c2&gt;&lt;s3&gt;do&lt;/s3&gt;&lt;/c2&gt; clause can throw.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;catch&lt;/s1&gt;&lt;/c0&gt;節は、&lt;c2&gt;&lt;s3&gt;do&lt;/s3&gt;&lt;/c2&gt;節の中のコードがスロー可能なすべての起こりうるエラーを取り扱う必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;center&lt;/s1&gt;&lt;/c0&gt; property is then set to a new value of &lt;c2&gt;&lt;s3&gt;(15,&lt;/s3&gt; &lt;s4&gt;15)&lt;/s4&gt;&lt;/c2&gt;, which moves the square up and to the right, to the new position shown by the orange square in the diagram below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;center&lt;/s1&gt;&lt;/c0&gt;プロパティは、それから新しい値&lt;c2&gt;&lt;s3&gt;(15,&lt;/s3&gt; &lt;s4&gt;15)&lt;/s4&gt;&lt;/c2&gt;に設定されます、それは、正方形を上にそして右に、下記の図においてオレンジの正方形によって示される新しい位置へと動かします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;continue&lt;/s1&gt;&lt;/c0&gt; statement tells a loop to stop what it is doing and start again at the beginning of the next iteration through the loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;continue&lt;/s1&gt;&lt;/c0&gt;文は、あるループにそれがしていることを止めて、そのループの次の繰り返しの始めのところで再び始めるように言います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;continue&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;break&lt;/s3&gt;&lt;/c2&gt;, and &lt;c4&gt;&lt;s5&gt;fallthrough&lt;/s5&gt;&lt;/c4&gt; statements are described below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;continue&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;break&lt;/s3&gt;&lt;/c2&gt;、そして&lt;c4&gt;&lt;s5&gt;fallthrough&lt;/s5&gt;&lt;/c4&gt;文は、以下で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;convention&lt;/s1&gt;&lt;/c0&gt; attribute always appears with one of the following arguments:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;convention&lt;/s1&gt;&lt;/c0&gt;属性は常に以下の引数の１つと共に現れます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;currentLevel&lt;/s1&gt;&lt;/c0&gt; property has a &lt;c2&gt;&lt;s3&gt;didSet&lt;/s3&gt;&lt;/c2&gt; property observer to check the value of &lt;c4&gt;&lt;s5&gt;currentLevel&lt;/s5&gt;&lt;/c4&gt; whenever it is set.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;currentLevel&lt;/s1&gt;&lt;/c0&gt;プロパティは&lt;c2&gt;&lt;s3&gt;didSet&lt;/s3&gt;&lt;/c2&gt;プロパティオブザーバーを持ち、&lt;c4&gt;&lt;s5&gt;currentLevel&lt;/s5&gt;&lt;/c4&gt;の値をそれが設定されるときはいつでも調べるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;deprecated&lt;/s1&gt;&lt;/c0&gt; argument indicates the first version of the specified platform or language in which the declaration was deprecated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;deprecated&lt;/s1&gt;&lt;/c0&gt;引数は、そこにおいてその宣言が非推奨とされたところの、指定されたプラットホームまたは言語の最初のバージョンを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;didSet&lt;/s1&gt;&lt;/c0&gt; clause is optional when you provide a &lt;c2&gt;&lt;s3&gt;willSet&lt;/s3&gt;&lt;/c2&gt; clause.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが&lt;c2&gt;&lt;s3&gt;willSet&lt;/s3&gt;&lt;/c2&gt;節を提供するとき、&lt;c0&gt;&lt;s1&gt;didSet&lt;/s1&gt;&lt;/c0&gt;節は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;didSet&lt;/s1&gt;&lt;/c0&gt; observer is called after the value of &lt;c2&gt;&lt;s3&gt;totalSteps&lt;/s3&gt;&lt;/c2&gt; is updated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;didSet&lt;/s1&gt;&lt;/c0&gt;オブザーバーは、&lt;c2&gt;&lt;s3&gt;totalSteps&lt;/s3&gt;&lt;/c2&gt;の値が更新された後に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;distribute(coins:)&lt;/s1&gt;&lt;/c0&gt; method checks that there are enough coins in the bank before distributing them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;distribute(coins:)&lt;/s1&gt;&lt;/c0&gt;メソッドは、十分なコインがそれらを配布する前に胴元にあることを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;do&lt;/s1&gt;&lt;/c0&gt; statement is used to introduce a new scope and can optionally contain one or more &lt;c2&gt;&lt;s3&gt;catch&lt;/s3&gt;&lt;/c2&gt; clauses, which contain patterns that match against defined error conditions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;do&lt;/s1&gt;&lt;/c0&gt;文は、ある新しいスコープを導入するために使われます、そして随意に１つ以上の&lt;c2&gt;&lt;s3&gt;catch&lt;/s3&gt;&lt;/c2&gt;節を含むことができ、それは定義されたエラー条件にマッチするパターンを複数含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;else&lt;/s1&gt;&lt;/c0&gt; clause of a &lt;c2&gt;&lt;s3&gt;guard&lt;/s3&gt;&lt;/c2&gt; statement is required, and must either call a function with the &lt;c4&gt;&lt;s5&gt;Never&lt;/s5&gt;&lt;/c4&gt; return type or transfer program control outside the guard statement’s enclosing scope using one of the following statements:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;guard&lt;/s3&gt;&lt;/c2&gt;文の&lt;c0&gt;&lt;s1&gt;else&lt;/s1&gt;&lt;/c0&gt;節は必ず必要です、そして&lt;c4&gt;&lt;s5&gt;Never&lt;/s5&gt;&lt;/c4&gt;戻り型を持つ関数を呼び出すか、プログラム制御をguard文の囲むスコープの外側に以下の文のうちの１つを使って移すか、どちらかをする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;fallthrough&lt;/s1&gt;&lt;/c0&gt; keyword does not check the case conditions for the &lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt; case that it causes execution to fall into.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;fallthrough&lt;/s1&gt;&lt;/c0&gt;キーワードは、それが実行を落としていく先の&lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt;ケース節のためのケース節条件を調べません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;favoriteGenres&lt;/s1&gt;&lt;/c0&gt; set is declared as a variable (with the &lt;c2&gt;&lt;s3&gt;var&lt;/s3&gt;&lt;/c2&gt; introducer) and not a constant (with the &lt;c4&gt;&lt;s5&gt;let&lt;/s5&gt;&lt;/c4&gt; introducer) because items are added and removed in the examples below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;favoriteGenres&lt;/s1&gt;&lt;/c0&gt;集合は、定数（&lt;c4&gt;&lt;s5&gt;let&lt;/s5&gt;&lt;/c4&gt;導入子を使って）ではなく変数として（&lt;c2&gt;&lt;s3&gt;var&lt;/s3&gt;&lt;/c2&gt;導入子を使って）宣言されます、項目が下の例で加えられたり取り除かれたりするためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;favoriteGenres&lt;/s1&gt;&lt;/c0&gt; variable is declared as “a set of &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt; values”, written as &lt;c4&gt;&lt;s5&gt;Set&lt;String&gt;&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;favoriteGenres&lt;/s1&gt;&lt;/c0&gt;変数は、&lt;c4&gt;&lt;s5&gt;Set&lt;String&gt;&lt;/s5&gt;&lt;/c4&gt;のように書かれ、「&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;値の集合」として宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;findIndex(of:in:)&lt;/s1&gt;&lt;/c0&gt; function now compiles successfully and can be used with any type that is &lt;c2&gt;&lt;s3&gt;Equatable&lt;/s3&gt;&lt;/c2&gt;, such as &lt;c4&gt;&lt;s5&gt;Double&lt;/s5&gt;&lt;/c4&gt; or &lt;c6&gt;&lt;s7&gt;String&lt;/s7&gt;&lt;/c6&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;findIndex(of:in:)&lt;/s1&gt;&lt;/c0&gt;関数は、今やうまくコンパイルして、&lt;c2&gt;&lt;s3&gt;Equatable&lt;/s3&gt;&lt;/c2&gt;であるどんな型とでも使われることができます、例えば&lt;c4&gt;&lt;s5&gt;Double&lt;/s5&gt;&lt;/c4&gt;や&lt;c6&gt;&lt;s7&gt;String&lt;/s7&gt;&lt;/c6&gt;など：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;findIndex(ofString:in:)&lt;/s1&gt;&lt;/c0&gt; function can be used to find a string value in an array of strings:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;findIndex(ofString:in:)&lt;/s1&gt;&lt;/c0&gt;関数は、文字列の配列の中をある文字列値がないか捜すために使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt; loop is described in &lt;a4&gt;&lt;s5&gt;For-In Loops&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt;ループは&lt;a4&gt;&lt;s5&gt;for-inループ&lt;/s5&gt;&lt;/a4&gt;で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;gameDidStart(_:)&lt;/s1&gt;&lt;/c0&gt; method also accesses the &lt;c2&gt;&lt;s3&gt;dice&lt;/s3&gt;&lt;/c2&gt; property of the passed &lt;c4&gt;&lt;s5&gt;game&lt;/s5&gt;&lt;/c4&gt; parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;gameDidStart(_:)&lt;/s1&gt;&lt;/c0&gt;メソッドはまた、渡された&lt;c4&gt;&lt;s5&gt;game&lt;/s5&gt;&lt;/c4&gt;パラメータの&lt;c2&gt;&lt;s3&gt;dice&lt;/s3&gt;&lt;/c2&gt;プロパティにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;generator&lt;/s1&gt;&lt;/c0&gt; property is of type &lt;c2&gt;&lt;s3&gt;RandomNumberGenerator&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;generator&lt;/s1&gt;&lt;/c0&gt;プロパティは、型&lt;c2&gt;&lt;s3&gt;RandomNumberGenerator&lt;/s3&gt;&lt;/c2&gt;のものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;hasPrefix(_:)&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;hasSuffix(_:)&lt;/s3&gt;&lt;/c2&gt; methods perform a character-by-character canonical equivalence comparison between the extended grapheme clusters in each string, as described in &lt;a4&gt;&lt;s5&gt;String and Character Equality&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;hasPrefix(_:)&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;hasSuffix(_:)&lt;/s3&gt;&lt;/c2&gt;は、各文字列の拡張書記素クラスタ間で文字ごとの正準等価比較を実行します、そのことは&lt;a4&gt;&lt;s5&gt;文字列と文字の同等性&lt;/s5&gt;&lt;/a4&gt;で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;height&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;width&lt;/s3&gt;&lt;/c2&gt; properties get their initial values from the definition of &lt;c4&gt;&lt;s5&gt;TwelveOrLess&lt;/s5&gt;&lt;/c4&gt;, which sets &lt;c6&gt;&lt;s7&gt;TwelveOrLess.number&lt;/s7&gt;&lt;/c6&gt; to zero.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;height&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;width&lt;/s3&gt;&lt;/c2&gt;プロパティは、それらの初期値を&lt;c4&gt;&lt;s5&gt;TwelveOrLess&lt;/s5&gt;&lt;/c4&gt;の定義から取得します、それは&lt;c6&gt;&lt;s7&gt;TwelveOrLess.number&lt;/s7&gt;&lt;/c6&gt;をゼロに設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt; statement can provide an alternative set of statements, known as an &lt;e2&gt;else clause&lt;/e2&gt;, for situations when the &lt;c3&gt;&lt;s4&gt;if&lt;/s4&gt;&lt;/c3&gt; condition is &lt;c5&gt;&lt;s6&gt;false&lt;/s6&gt;&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt;文は、代替のひとそろいの文、&lt;e2&gt;else節&lt;/e2&gt;として知られるものを&lt;c3&gt;&lt;s4&gt;if&lt;/s4&gt;&lt;/c3&gt;条件が&lt;c5&gt;&lt;s6&gt;false&lt;/s6&gt;&lt;/c5&gt;の場合の状況のために提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;in&lt;/s1&gt;&lt;/c0&gt; keyword can also be omitted, because the closure expression is made up entirely of its body:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;in&lt;/s1&gt;&lt;/c0&gt;キーワードもまた、クロージャ式がもっぱらその本文から成り立つので、省略されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;increment()&lt;/s1&gt;&lt;/c0&gt; method first tries to retrieve an increment amount by looking for an implementation of the &lt;c2&gt;&lt;s3&gt;increment(forCount:)&lt;/s3&gt;&lt;/c2&gt; method on its data source.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;increment()&lt;/s1&gt;&lt;/c0&gt;メソッドは、最初にそれのデータ・ソース上で&lt;c2&gt;&lt;s3&gt;increment(forCount:)&lt;/s3&gt;&lt;/c2&gt;メソッドの実装を捜すことによって増加量を取り出そうと試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;increment()&lt;/s1&gt;&lt;/c0&gt; method in the example above could have been written like this:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例における&lt;c0&gt;&lt;s1&gt;increment()&lt;/s1&gt;&lt;/c0&gt;メソッドは、このように記述されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;incrementer()&lt;/s1&gt;&lt;/c0&gt; function doesn’t have any parameters, and yet it refers to &lt;c2&gt;&lt;s3&gt;runningTotal&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;amount&lt;/s5&gt;&lt;/c4&gt; from within its function body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;incrementer()&lt;/s1&gt;&lt;/c0&gt;関数には全くパラメータがありません、それなのに、それはその関数本文内から&lt;c2&gt;&lt;s3&gt;runningTotal&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;amount&lt;/s5&gt;&lt;/c4&gt;に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;init()&lt;/s1&gt;&lt;/c0&gt; initializer for &lt;c2&gt;&lt;s3&gt;Bicycle&lt;/s3&gt;&lt;/c2&gt; starts by calling &lt;c4&gt;&lt;s5&gt;super.init()&lt;/s5&gt;&lt;/c4&gt;, which calls the default initializer for the &lt;c6&gt;&lt;s7&gt;Bicycle&lt;/s7&gt;&lt;/c6&gt; class’s superclass, &lt;c8&gt;&lt;s9&gt;Vehicle&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;Bicycle&lt;/s3&gt;&lt;/c2&gt;のための&lt;c0&gt;&lt;s1&gt;init()&lt;/s1&gt;&lt;/c0&gt;イニシャライザは、&lt;c4&gt;&lt;s5&gt;super.init()&lt;/s5&gt;&lt;/c4&gt;を呼ぶことによって始まります、それは、&lt;c6&gt;&lt;s7&gt;Bicycle&lt;/s7&gt;&lt;/c6&gt;クラスのスーパークラス、&lt;c8&gt;&lt;s9&gt;Vehicle&lt;/s9&gt;&lt;/c8&gt;のための省略時のイニシャライザを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;init(center:size:)&lt;/s1&gt;&lt;/c0&gt; initializer could have assigned the new values of &lt;c2&gt;&lt;s3&gt;origin&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;size&lt;/s5&gt;&lt;/c4&gt; to the appropriate properties itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;init(center:size:)&lt;/s1&gt;&lt;/c0&gt;イニシャライザは、それ自体で&lt;c2&gt;&lt;s3&gt;origin&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;size&lt;/s5&gt;&lt;/c4&gt;の新しい値を適切なプロパティに代入することができました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;init(name:&lt;/s1&gt; &lt;s2&gt;String)&lt;/s2&gt;&lt;/c0&gt; convenience initializer provided by &lt;c3&gt;&lt;s4&gt;RecipeIngredient&lt;/s4&gt;&lt;/c3&gt; takes the same parameters as the &lt;c5&gt;&lt;s6&gt;init(name:&lt;/s6&gt; &lt;s7&gt;String)&lt;/s7&gt;&lt;/c5&gt; &lt;e8&gt;designated&lt;/e8&gt; initializer from &lt;c9&gt;&lt;s10&gt;Food&lt;/s10&gt;&lt;/c9&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c3&gt;&lt;s4&gt;RecipeIngredient&lt;/s4&gt;&lt;/c3&gt;によって提供される便宜イニシャライザ&lt;c0&gt;&lt;s1&gt;init(name:&lt;/s1&gt; &lt;s2&gt;String)&lt;/s2&gt;&lt;/c0&gt;は、&lt;c9&gt;&lt;s10&gt;Food&lt;/s10&gt;&lt;/c9&gt;からの&lt;e8&gt;指定&lt;/e8&gt;イニシャライザ&lt;c5&gt;&lt;s6&gt;init(name:&lt;/s6&gt; &lt;s7&gt;String)&lt;/s7&gt;&lt;/c5&gt;と同じパラメータを取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;init(name:&lt;/s1&gt; &lt;s2&gt;String)&lt;/s2&gt;&lt;/c0&gt; initializer from the &lt;c3&gt;&lt;s4&gt;Food&lt;/s4&gt;&lt;/c3&gt; class is provided as a &lt;e5&gt;designated&lt;/e5&gt; initializer, because it ensures that all stored properties of a new &lt;c6&gt;&lt;s7&gt;Food&lt;/s7&gt;&lt;/c6&gt; instance are fully initialized.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;init(name:&lt;/s1&gt; &lt;s2&gt;String)&lt;/s2&gt;&lt;/c0&gt;イニシャライザは、この&lt;c3&gt;&lt;s4&gt;Food&lt;/s4&gt;&lt;/c3&gt;クラス由来で、&lt;e5&gt;指定&lt;/e5&gt;イニシャライザとして提供されます、なぜならそれは新しい&lt;c6&gt;&lt;s7&gt;Food&lt;/s7&gt;&lt;/c6&gt;インスタンスのすべての格納プロパティが完全に初期化されるのを確実にするからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;introduced&lt;/s1&gt;&lt;/c0&gt; argument indicates the first version of the specified platform or language in which the declaration was introduced.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;introduced&lt;/s1&gt;&lt;/c0&gt;引数は、そこにおいてその宣言が導入されたところの、指定されたプラットホームまたは言語の最初のバージョンを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;is&lt;/s1&gt;&lt;/c0&gt; operator checks at runtime whether the &lt;e2&gt;expression&lt;/e2&gt; can be cast to the specified &lt;e3&gt;type&lt;/e3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;is&lt;/s1&gt;&lt;/c0&gt;演算子は実行時に&lt;e2&gt;式&lt;/e2&gt;が指定された&lt;e3&gt;型&lt;/e3&gt;へとキャスト可能かどうかを調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;is&lt;/s1&gt;&lt;/c0&gt; operator returns &lt;c2&gt;&lt;s3&gt;true&lt;/s3&gt;&lt;/c2&gt; if an instance conforms to a protocol and returns &lt;c4&gt;&lt;s5&gt;false&lt;/s5&gt;&lt;/c4&gt; if it doesn’t.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;is&lt;/s1&gt;&lt;/c0&gt;演算子は、あるインスタンスがプロトコルに準拠するならば&lt;c2&gt;&lt;s3&gt;true&lt;/s3&gt;&lt;/c2&gt;を返して、それがそうしないならば&lt;c4&gt;&lt;s5&gt;false&lt;/s5&gt;&lt;/c4&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;is&lt;/s1&gt;&lt;/c0&gt; pattern matches a value if the type of that value at runtime is the same as the type specified in the right-hand side of the &lt;c2&gt;&lt;s3&gt;is&lt;/s3&gt;&lt;/c2&gt; pattern—or a subclass of that type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;is&lt;/s1&gt;&lt;/c0&gt;パターンは、ある値にマッチします、もしその値の実行時での型が&lt;c2&gt;&lt;s3&gt;is&lt;/s3&gt;&lt;/c2&gt;パターンの右側で指定される型 ― またはそれの型のサブクラス ― と同じものであるならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;john&lt;/s1&gt;&lt;/c0&gt; variable now has a strong reference to the new &lt;c2&gt;&lt;s3&gt;Person&lt;/s3&gt;&lt;/c2&gt; instance, and the &lt;c4&gt;&lt;s5&gt;unit4A&lt;/s5&gt;&lt;/c4&gt; variable has a strong reference to the new &lt;c6&gt;&lt;s7&gt;Apartment&lt;/s7&gt;&lt;/c6&gt; instance:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;john&lt;/s1&gt;&lt;/c0&gt;変数は現在新しい&lt;c2&gt;&lt;s3&gt;Person&lt;/s3&gt;&lt;/c2&gt;インスタンスへの強い参照を持ちます、そして&lt;c4&gt;&lt;s5&gt;unit4A&lt;/s5&gt;&lt;/c4&gt;変数は新しい&lt;c6&gt;&lt;s7&gt;Apartment&lt;/s7&gt;&lt;/c6&gt;インスタンスへの強い参照を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;makeIncrementer(forIncrement:)&lt;/s1&gt;&lt;/c0&gt; function defines an integer variable called &lt;c2&gt;&lt;s3&gt;runningTotal&lt;/s3&gt;&lt;/c2&gt;, to store the current running total of the incrementer that will be returned.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;makeIncrementer(forIncrement:)&lt;/s1&gt;&lt;/c0&gt;関数は、返されるincrementerの現時点での合計を格納するために、&lt;c2&gt;&lt;s3&gt;runningTotal&lt;/s3&gt;&lt;/c2&gt;と呼ばれる整数変数を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;makeIncrementer(forIncrement:)&lt;/s1&gt;&lt;/c0&gt; function has a single &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt; parameter with an argument label of &lt;c4&gt;&lt;s5&gt;forIncrement&lt;/s5&gt;&lt;/c4&gt;, and a parameter name of &lt;c6&gt;&lt;s7&gt;amount&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;makeIncrementer(forIncrement:)&lt;/s1&gt;&lt;/c0&gt;関数は、&lt;c4&gt;&lt;s5&gt;forIncrement&lt;/s5&gt;&lt;/c4&gt;の引数ラベル、そして&lt;c6&gt;&lt;s7&gt;amount&lt;/s7&gt;&lt;/c6&gt;のパラメータ名を持つ、ただ１つの&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;パラメータを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;makeIterator()&lt;/s1&gt;&lt;/c0&gt; method is called on the &lt;e2&gt;collection&lt;/e2&gt; expression to obtain a value of an iterator type—that is, a type that conforms to the &lt;a3&gt;&lt;c4&gt;&lt;s5&gt;IteratorProtocol&lt;/s5&gt;&lt;/c4&gt;&lt;/a3&gt;&lt;s6&gt; [https://developer.apple.com/documentation/swift/iteratorprotocol]&lt;/s6&gt; protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;makeIterator()&lt;/s1&gt;&lt;/c0&gt;メソッドが&lt;e2&gt;collection（コレクション）&lt;/e2&gt;式の上で呼ばれて、イテレータ型 ― すなわち、&lt;a3&gt;&lt;c4&gt;&lt;s5&gt;IteratorProtocol&lt;/s5&gt;&lt;/c4&gt;&lt;/a3&gt;&lt;s6&gt; [https://developer.apple.com/documentation/swift/iteratorprotocol]&lt;/s6&gt;プロトコルに準拠する型、に属する１つの値を取得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;makeTrapezoid()&lt;/s1&gt;&lt;/c0&gt; function in this example declares its return type as &lt;c2&gt;&lt;s3&gt;some&lt;/s3&gt; &lt;s4&gt;Shape&lt;/s4&gt;&lt;/c2&gt;; as a result, the function returns a value of some given type that conforms to the &lt;c5&gt;&lt;s6&gt;Shape&lt;/s6&gt;&lt;/c5&gt; protocol, without specifying any particular concrete type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例での&lt;c0&gt;&lt;s1&gt;makeTrapezoid()&lt;/s1&gt;&lt;/c0&gt;関数は、それの戻り型を&lt;c2&gt;&lt;s3&gt;some&lt;/s3&gt; &lt;s4&gt;Shape&lt;/s4&gt;&lt;/c2&gt;として宣言します；その結果、関数は、&lt;c5&gt;&lt;s6&gt;Shape&lt;/s6&gt;&lt;/c5&gt;プロトコルに準拠するある与えられた型の値を返します、何らかの特定の具象型を指定することなしに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;map(_:)&lt;/s1&gt;&lt;/c0&gt; method calls the closure expression once for each item in the array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;map(_:)&lt;/s1&gt;&lt;/c0&gt;メソッドは、配列の中の各項目に対して一度だけクロージャ式を呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;message&lt;/s1&gt;&lt;/c0&gt; argument provides a textual message that the compiler displays when emitting a warning or error about the use of a deprecated or obsoleted declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;message&lt;/s1&gt;&lt;/c0&gt;引数は、あるテキストメッセージを提供します、それはコンパイラが非推奨または廃止された宣言の使用についての警告またはエラーを発するときに表示するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;minMax(array:)&lt;/s1&gt;&lt;/c0&gt; function above returns a tuple containing two &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt; values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の&lt;c0&gt;&lt;s1&gt;minMax(array:)&lt;/s1&gt;&lt;/c0&gt;関数は、２つの&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;値を含んでいるタプルを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;minMax(array:)&lt;/s1&gt;&lt;/c0&gt; function returns a tuple containing two &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt; values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;minMax(array:)&lt;/s1&gt;&lt;/c0&gt;関数は、２つの&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;値を含んでいる１つのタプルを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;number&lt;/s1&gt;&lt;/c0&gt; property of the &lt;c2&gt;&lt;s3&gt;CreditCard&lt;/s3&gt;&lt;/c2&gt; class is defined with a type of &lt;c4&gt;&lt;s5&gt;UInt64&lt;/s5&gt;&lt;/c4&gt; rather than &lt;c6&gt;&lt;s7&gt;Int&lt;/s7&gt;&lt;/c6&gt;, to ensure that the &lt;c8&gt;&lt;s9&gt;number&lt;/s9&gt;&lt;/c8&gt; property’s capacity is large enough to store a 16-digit card number on both 32-bit and 64-bit systems.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;CreditCard&lt;/s3&gt;&lt;/c2&gt;クラスの&lt;c0&gt;&lt;s1&gt;number&lt;/s1&gt;&lt;/c0&gt;プロパティは、&lt;c4&gt;&lt;s5&gt;UInt64&lt;/s5&gt;&lt;/c4&gt;の型で定義されます、&lt;c6&gt;&lt;s7&gt;Int&lt;/s7&gt;&lt;/c6&gt;ではなく、それによって&lt;c8&gt;&lt;s9&gt;number&lt;/s9&gt;&lt;/c8&gt;プロパティの容量が32bitと64bitシステムの両方で16桁のカード番号を格納するのに十分に大きいことを保証します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;number&lt;/s1&gt;&lt;/c0&gt; variable is then divided by &lt;c2&gt;&lt;s3&gt;10&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;number&lt;/s1&gt;&lt;/c0&gt;変数は、それから&lt;c2&gt;&lt;s3&gt;10&lt;/s3&gt;&lt;/c2&gt;で割られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;objc&lt;/s1&gt;&lt;/c0&gt; attribute is also implicitly added in the following cases:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;objc&lt;/s1&gt;&lt;/c0&gt;属性はまた、以下の場合において暗黙的に加えられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;objc&lt;/s1&gt;&lt;/c0&gt; attribute optionally accepts a single attribute argument, which consists of an identifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;objc&lt;/s1&gt;&lt;/c0&gt;属性は、任意にただ１つだけ属性引数を受け入れます、それはひとつの識別子から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;objc&lt;/s1&gt;&lt;/c0&gt; attribute tells the compiler that a declaration is available to use in Objective-C code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;objc&lt;/s1&gt;&lt;/c0&gt;属性は、コンパイラにある宣言がObjective-Cコードにおいて使われることが可能であるのを伝えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;objects&lt;/s1&gt;&lt;/c0&gt; array can now be iterated, and each object in the array can be checked to see if it conforms to the &lt;c2&gt;&lt;s3&gt;HasArea&lt;/s3&gt;&lt;/c2&gt; protocol:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;objects&lt;/s1&gt;&lt;/c0&gt;配列は、今や繰り返されることができます、そして配列の各オブジェクトはそれが&lt;c2&gt;&lt;s3&gt;HasArea&lt;/s3&gt;&lt;/c2&gt;プロトコルに従うかどうかを確認されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;objects&lt;/s1&gt;&lt;/c0&gt; array is initialized with an array literal containing a &lt;c2&gt;&lt;s3&gt;Circle&lt;/s3&gt;&lt;/c2&gt; instance with a radius of 2 units; a &lt;c4&gt;&lt;s5&gt;Country&lt;/s5&gt;&lt;/c4&gt; instance initialized with the surface area of the United Kingdom in square kilometers; and an &lt;c6&gt;&lt;s7&gt;Animal&lt;/s7&gt;&lt;/c6&gt; instance with four legs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;objects&lt;/s1&gt;&lt;/c0&gt;配列は、単位２の半径をもつ&lt;c2&gt;&lt;s3&gt;Circle&lt;/s3&gt;&lt;/c2&gt;インスタンスを含んでいる配列リテラル；平方キロメートルでの英国の面積で初期化される&lt;c4&gt;&lt;s5&gt;Country&lt;/s5&gt;&lt;/c4&gt;インスタンス；そして、４本脚の&lt;c6&gt;&lt;s7&gt;Animal&lt;/s7&gt;&lt;/c6&gt;インスタンス；を含んでいる配列リテラルで初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;obsoleted&lt;/s1&gt;&lt;/c0&gt; argument indicates the first version of the specified platform or language in which the declaration was obsoleted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;obsoleted&lt;/s1&gt;&lt;/c0&gt;引数は、そこにおいてその宣言が廃止とされたところの、指定されたプラットホームまたは言語の最初のバージョンを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;override&lt;/s1&gt;&lt;/c0&gt; keyword also prompts the Swift compiler to check that your overriding class’s superclass (or one of its parents) has a declaration that matches the one you provided for the override.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;override&lt;/s1&gt;&lt;/c0&gt;キーワードはまた、あなたのオーバーライドしているクラスのスーパークラス（またはその親のうちの１つ）が、そのオーバーライドのためにあなたが提供するものと合致する宣言を持っていることを確認するように、スウィフトのコンパイラを促します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;paragraph&lt;/s1&gt;&lt;/c0&gt; variable above is defined as an &lt;e2&gt;optional&lt;/e2&gt; &lt;c3&gt;&lt;s4&gt;HTMLElement&lt;/s4&gt;&lt;/c3&gt;, so that it can be set to &lt;c5&gt;&lt;s6&gt;nil&lt;/s6&gt;&lt;/c5&gt; below to demonstrate the presence of a strong reference cycle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上記の&lt;c0&gt;&lt;s1&gt;paragraph&lt;/s1&gt;&lt;/c0&gt;変数は、&lt;e2&gt;オプショナル&lt;/e2&gt;の&lt;c3&gt;&lt;s4&gt;HTMLElement&lt;/s4&gt;&lt;/c3&gt;として定義されます、それでそれは下で強い参照循環の存在を例示するために&lt;c5&gt;&lt;s6&gt;nil&lt;/s6&gt;&lt;/c5&gt;に設定されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;prettyTextualDescription&lt;/s1&gt;&lt;/c0&gt; property can now be used to print a pretty text description of any &lt;c2&gt;&lt;s3&gt;SnakesAndLadders&lt;/s3&gt;&lt;/c2&gt; instance:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この&lt;c0&gt;&lt;s1&gt;prettyTextualDescription&lt;/s1&gt;&lt;/c0&gt;プロパティは、現在あらゆる&lt;c2&gt;&lt;s3&gt;SnakesAndLadders&lt;/s3&gt;&lt;/c2&gt;インスタンスのきれいなテキスト解説を出力するために使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;print(_:separator:terminator:)&lt;/s1&gt;&lt;/c0&gt; function doesn’t have a label for its first argument, and its other arguments are optional because they have a default value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;print(_:separator:terminator:)&lt;/s1&gt;&lt;/c0&gt;関数は、それの最初の引数に対してラベルを持ちません、そしてそれの他の引数は任意です、それらが省略時の値を持つからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;print(_:separator:terminator:)&lt;/s1&gt;&lt;/c0&gt; function is a global function that prints one or more values to an appropriate output.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;print(_:separator:terminator:)&lt;/s1&gt;&lt;/c0&gt;関数は、ひとつ以上の値を適切な出力先に出力するグローバルな関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;printNumberOfRooms()&lt;/s1&gt;&lt;/c0&gt; method on the &lt;c2&gt;&lt;s3&gt;Residence&lt;/s3&gt;&lt;/c2&gt; class prints the current value of &lt;c4&gt;&lt;s5&gt;numberOfRooms&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;Residence&lt;/s3&gt;&lt;/c2&gt;クラス上の&lt;c0&gt;&lt;s1&gt;printNumberOfRooms()&lt;/s1&gt;&lt;/c0&gt;メソッドは、&lt;c4&gt;&lt;s5&gt;numberOfRooms&lt;/s5&gt;&lt;/c4&gt;の現在の値を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;receive(coins:)&lt;/s1&gt;&lt;/c0&gt; method simply adds the received number of coins back into the bank’s coin store.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;receive(coins:)&lt;/s1&gt;&lt;/c0&gt;メソッドは、単純に受け取ったコインの数を胴元のコインの蓄えに戻すよう加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;renamed&lt;/s1&gt;&lt;/c0&gt; argument provides a textual message that indicates the new name for a declaration that’s been renamed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;renamed&lt;/s1&gt;&lt;/c0&gt;引数は、あるテキストメッセージを提供します、それは改名された宣言に対する新しい名前を指し示すものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;repeat&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;while&lt;/s3&gt;&lt;/c2&gt; loop in Swift is analogous to a &lt;c4&gt;&lt;s5&gt;do&lt;/s5&gt;&lt;/c4&gt;-&lt;c6&gt;&lt;s7&gt;while&lt;/s7&gt;&lt;/c6&gt; loop in other languages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの&lt;c0&gt;&lt;s1&gt;repeat&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;while&lt;/s3&gt;&lt;/c2&gt;ループは、他の言語の&lt;c4&gt;&lt;s5&gt;do&lt;/s5&gt;&lt;/c4&gt;-&lt;c6&gt;&lt;s7&gt;while&lt;/s7&gt;&lt;/c6&gt;ループと類似したものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;repetitions(task:)&lt;/s1&gt;&lt;/c0&gt; method takes a single argument of type &lt;c2&gt;&lt;s3&gt;()&lt;/s3&gt; &lt;s4&gt;-&gt;&lt;/s4&gt; &lt;s5&gt;Void&lt;/s5&gt;&lt;/c2&gt;, which indicates a function that has no parameters and does not return a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;repetitions(task:)&lt;/s1&gt;&lt;/c0&gt;メソッドは型&lt;c2&gt;&lt;s3&gt;()&lt;/s3&gt; &lt;s4&gt;-&gt;&lt;/s4&gt; &lt;s5&gt;Void&lt;/s5&gt;&lt;/c2&gt;の引数をひとつだけとります、それは、パラメータを持たず、値を返さない関数であることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt; expression is an explicit reference to the current type or instance of the type in which it occurs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;式は、それがその中に現れているところの現在の型や型のインスタンスへの明確な参照です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt; expression is used to specify scope when accessing members, providing disambiguation when there is another variable of the same name in scope, such as a function parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;式は、メンバーにアクセスする時にスコープを指定するために使われて、関数パラメータなど、同じ名前の別の変数がスコープ内にある場合に一義化を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;serve(customer:)&lt;/s1&gt;&lt;/c0&gt; function in the listing above takes an explicit closure that returns a customer’s name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上で記載される&lt;c0&gt;&lt;s1&gt;serve(customer:)&lt;/s1&gt;&lt;/c0&gt;関数は、次の顧客の名前を返す、ある明示的なクロージャを取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;shoppingList&lt;/s1&gt;&lt;/c0&gt; array is declared as a variable (with the &lt;c2&gt;&lt;s3&gt;var&lt;/s3&gt;&lt;/c2&gt; introducer) and not a constant (with the &lt;c4&gt;&lt;s5&gt;let&lt;/s5&gt;&lt;/c4&gt; introducer) because more items are added to the shopping list in the examples below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;shoppingList&lt;/s1&gt;&lt;/c0&gt;配列は、変数として（&lt;c2&gt;&lt;s3&gt;var&lt;/s3&gt;&lt;/c2&gt;導入子を使って）宣言されます、定数（&lt;c4&gt;&lt;s5&gt;let&lt;/s5&gt;&lt;/c4&gt;導入子を使って）ではなく、なぜならより多くの項目が下記の例で購入品目リストに加えられるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;shoppingList&lt;/s1&gt;&lt;/c0&gt; variable is declared as “an array of string values”, written as &lt;c2&gt;&lt;s3&gt;[String]&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;shoppingList&lt;/s1&gt;&lt;/c0&gt;変数は、「String値の配列」として宣言され、&lt;c2&gt;&lt;s3&gt;[String]&lt;/s3&gt;&lt;/c2&gt;のように書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;someFunctionWithEscapingClosure(_:)&lt;/s1&gt;&lt;/c0&gt; function takes a closure as its argument and adds it to an array that’s declared outside the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;someFunctionWithEscapingClosure(_:)&lt;/s1&gt;&lt;/c0&gt;関数は、クロージャをそれの引数として取ります、そしてそれを関数の外側で宣言される配列に加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;sorted(by:)&lt;/s1&gt;&lt;/c0&gt; method accepts a closure that takes two arguments of the same type as the array’s contents, and returns a &lt;c2&gt;&lt;s3&gt;Bool&lt;/s3&gt;&lt;/c2&gt; value to say whether the first value should appear before or after the second value once the values are sorted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;sorted(by:)&lt;/s1&gt;&lt;/c0&gt;メソッドは、配列の内容物と同じ型の２つの引数をとり、そしてひとたび値が分類されるならば最初の値が第２の値の前か後のどちらに現れなければならないのかを伝える&lt;c2&gt;&lt;s3&gt;Bool&lt;/s3&gt;&lt;/c2&gt;値を返すクロージャを受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;sorted(by:)&lt;/s1&gt;&lt;/c0&gt; method is being called on an array of strings, so its argument must be a function of type &lt;c2&gt;&lt;s3&gt;(String,&lt;/s3&gt; &lt;s4&gt;String)&lt;/s4&gt; &lt;s5&gt;-&gt;&lt;/s5&gt; &lt;s6&gt;Bool&lt;/s6&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この&lt;c0&gt;&lt;s1&gt;sorted(by:)&lt;/s1&gt;&lt;/c0&gt;メソッドは文字列の配列上で呼ばれています、それでそれの引数は型&lt;c2&gt;&lt;s3&gt;(String,&lt;/s3&gt; &lt;s4&gt;String)&lt;/s4&gt; &lt;s5&gt;-&gt;&lt;/s5&gt; &lt;s6&gt;Bool&lt;/s6&gt;&lt;/c2&gt;の関数でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;square&lt;/s1&gt;&lt;/c0&gt; variable’s &lt;c2&gt;&lt;s3&gt;center&lt;/s3&gt;&lt;/c2&gt; property is then accessed through dot syntax (&lt;c4&gt;&lt;s5&gt;square.center&lt;/s5&gt;&lt;/c4&gt;), which causes the getter for &lt;c6&gt;&lt;s7&gt;center&lt;/s7&gt;&lt;/c6&gt; to be called, to retrieve the current property value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;square&lt;/s1&gt;&lt;/c0&gt;変数の&lt;c2&gt;&lt;s3&gt;center&lt;/s3&gt;&lt;/c2&gt;プロパティは、それからドット構文（&lt;c4&gt;&lt;s5&gt;square.center&lt;/s5&gt;&lt;/c4&gt;）を通してアクセスされます、それによって&lt;c6&gt;&lt;s7&gt;center&lt;/s7&gt;&lt;/c6&gt;のためのゲッターが呼び出されて、現在のプロパティ値を取り出すことになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;startsWith(_:)&lt;/s1&gt;&lt;/c0&gt; method first makes sure that the container has at least one item, and then it checks whether the first item in the container matches the given item.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;startsWith(_:)&lt;/s1&gt;&lt;/c0&gt;メソッドはまず、コンテナが少なくとも１つの項目を持つことを確かめます、それからそれはそのコンテナの最初の項目が与えられた項目と合致するかどうか調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;subscript(dynamicMemberLookup:)&lt;/s1&gt;&lt;/c0&gt; subscript enables syntactic sugar for member lookup, as described in &lt;a2&gt;&lt;s3&gt;dynamicMemberLookup&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;subscript(dynamicMemberLookup:)&lt;/s1&gt;&lt;/c0&gt;添え字は、メンバー検索に対する構文糖を可能にします、&lt;a2&gt;&lt;s3&gt;dynamicMemberLookup&lt;/s3&gt;&lt;/a2&gt;で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;swapTwoInts(_:_:)&lt;/s1&gt;&lt;/c0&gt; function is useful, but it can only be used with &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt; values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;swapTwoInts(_:_:)&lt;/s1&gt;&lt;/c0&gt;関数は役に立ちます、しかし、それは&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;値で使われることができるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;swapTwoInts(_:_:)&lt;/s1&gt;&lt;/c0&gt; function simply swaps the value of &lt;c2&gt;&lt;s3&gt;b&lt;/s3&gt;&lt;/c2&gt; into &lt;c4&gt;&lt;s5&gt;a&lt;/s5&gt;&lt;/c4&gt;, and the value of &lt;c6&gt;&lt;s7&gt;a&lt;/s7&gt;&lt;/c6&gt; into &lt;c8&gt;&lt;s9&gt;b&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;swapTwoInts(_:_:)&lt;/s1&gt;&lt;/c0&gt;関数は、単に&lt;c2&gt;&lt;s3&gt;b&lt;/s3&gt;&lt;/c2&gt;の値を&lt;c4&gt;&lt;s5&gt;a&lt;/s5&gt;&lt;/c4&gt;の中に、そして&lt;c6&gt;&lt;s7&gt;a&lt;/s7&gt;&lt;/c6&gt;の値を&lt;c8&gt;&lt;s9&gt;b&lt;/s9&gt;&lt;/c8&gt;の中へと入れ替えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;swapTwoInts(_:_:)&lt;/s1&gt;&lt;/c0&gt; function swaps the original value of &lt;c2&gt;&lt;s3&gt;b&lt;/s3&gt;&lt;/c2&gt; into &lt;c4&gt;&lt;s5&gt;a&lt;/s5&gt;&lt;/c4&gt;, and the original value of &lt;c6&gt;&lt;s7&gt;a&lt;/s7&gt;&lt;/c6&gt; into &lt;c8&gt;&lt;s9&gt;b&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;swapTwoInts(_:_:)&lt;/s1&gt;&lt;/c0&gt;関数は、&lt;c2&gt;&lt;s3&gt;b&lt;/s3&gt;&lt;/c2&gt;の元々の値を&lt;c4&gt;&lt;s5&gt;a&lt;/s5&gt;&lt;/c4&gt;の中へ、そして&lt;c6&gt;&lt;s7&gt;a&lt;/s7&gt;&lt;/c6&gt;の元々の値を&lt;c8&gt;&lt;s9&gt;b&lt;/s9&gt;&lt;/c8&gt;の中へと交換します、そして、最初の値のにb。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;swapTwoInts&lt;/s1&gt;&lt;/c0&gt; example above does not define a return type or return a value, but it still modifies the values of &lt;c2&gt;&lt;s3&gt;someInt&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;anotherInt&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の&lt;c0&gt;&lt;s1&gt;swapTwoInts&lt;/s1&gt;&lt;/c0&gt;例は、戻り型を定義しないし、また値を返しません、しかしそれでもそれは&lt;c2&gt;&lt;s3&gt;someInt&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;anotherInt&lt;/s5&gt;&lt;/c4&gt;の値を修正します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;swapTwoValues(_:_:)&lt;/s1&gt;&lt;/c0&gt; function and the &lt;c2&gt;&lt;s3&gt;Stack&lt;/s3&gt;&lt;/c2&gt; type can work with any type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;swapTwoValues(_:_:)&lt;/s1&gt;&lt;/c0&gt;関数と&lt;c2&gt;&lt;s3&gt;Stack&lt;/s3&gt;&lt;/c2&gt;型は、どんな型でも扱うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;swapTwoValues(_:_:)&lt;/s1&gt;&lt;/c0&gt; function can now be called in the same way as &lt;c2&gt;&lt;s3&gt;swapTwoInts&lt;/s3&gt;&lt;/c2&gt;, except that it can be passed two values of &lt;e4&gt;any&lt;/e4&gt; type, as long as both of those values are of the same type as each other.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;swapTwoValues(_:_:)&lt;/s1&gt;&lt;/c0&gt;関数は現在&lt;c2&gt;&lt;s3&gt;swapTwoInts&lt;/s3&gt;&lt;/c2&gt;と同じやり方で呼ばれることができます、しかしそれが&lt;e4&gt;あらゆる&lt;/e4&gt;型の２つの値を渡されることが、それらの値の両方が互いに同じ型である限り可能であるのを除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;swapTwoValues(_:_:)&lt;/s1&gt;&lt;/c0&gt; function defined above is inspired by a generic function called &lt;c2&gt;&lt;s3&gt;swap&lt;/s3&gt;&lt;/c2&gt;, which is part of the Swift standard library, and is automatically made available for you to use in your apps.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上で定義される&lt;c0&gt;&lt;s1&gt;swapTwoValues(_:_:)&lt;/s1&gt;&lt;/c0&gt;関数は&lt;c2&gt;&lt;s3&gt;swap&lt;/s3&gt;&lt;/c2&gt;と呼ばれる総称体関数に着想を得たものです、それは、スウィフト標準ライブラリの一部であって、あなたのアプリにおいて自動的にあなたが使うことが可能にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;swift&lt;/s1&gt;&lt;/c0&gt; argument indicates a Swift function reference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;swift&lt;/s1&gt;&lt;/c0&gt;引数はあるスウィフト関数参照を指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; statement determines whether the point is at the origin (0, 0), on the red x-axis, on the orange y-axis, inside the blue 4-by-4 box centered on the origin, or outside of the box.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;文は、そのポイントがあるのは、原点(0, 0)、赤いx-軸上、オレンジのy-軸上、原点を中心とした青の４×４の四角の内側、または四角の外側かどうかを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; statement determines whether the point is on the green diagonal line where &lt;c2&gt;&lt;s3&gt;x&lt;/s3&gt; &lt;s4&gt;==&lt;/s4&gt; &lt;s5&gt;y&lt;/s5&gt;&lt;/c2&gt;, on the purple diagonal line where &lt;c6&gt;&lt;s7&gt;x&lt;/s7&gt; &lt;s8&gt;==&lt;/s8&gt; &lt;s9&gt;-y&lt;/s9&gt;&lt;/c6&gt;, or neither.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;文は、そのポイントが、&lt;c2&gt;&lt;s3&gt;x&lt;/s3&gt; &lt;s4&gt;==&lt;/s4&gt; &lt;s5&gt;y&lt;/s5&gt;&lt;/c2&gt;であるところの緑の斜線上、あるいは&lt;c6&gt;&lt;s7&gt;x&lt;/s7&gt; &lt;s8&gt;==&lt;/s8&gt; &lt;s9&gt;-y&lt;/s9&gt;&lt;/c6&gt;であるところの紫の斜線上にあるかどうかを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; statement determines whether the point is on the red x-axis, on the orange y-axis, or elsewhere (on neither axis).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;文は、この地点が、赤のx-軸上、オレンジのy-軸上、または他のどこか（どちらの軸上でもない）かを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; statement’s first case matches all five lowercase vowels in the English language.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;文の最初のケース節は、英語における５つの小文字の母音字すべてにマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; statement’s first case matches the first letter of the English alphabet, &lt;c2&gt;&lt;s3&gt;a&lt;/s3&gt;&lt;/c2&gt;, and its second case matches the last letter, &lt;c4&gt;&lt;s5&gt;z&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;文の最初のケース節は、英語アルファペットの最初の文字、&lt;c2&gt;&lt;s3&gt;a&lt;/s3&gt;&lt;/c2&gt;にマッチします、そしてそれの２番目のケース節は最後の文字、&lt;c4&gt;&lt;s5&gt;z&lt;/s5&gt;&lt;/c4&gt;にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;targetEnvironment()&lt;/s1&gt;&lt;/c0&gt; platform condition returns &lt;c2&gt;&lt;s3&gt;true&lt;/s3&gt;&lt;/c2&gt; when code is compiled for a simulator; otherwise, it returns &lt;c4&gt;&lt;s5&gt;false&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;targetEnvironment()&lt;/s1&gt;&lt;/c0&gt;プラットホーム条件は、コードがシミュレータに対してコンパイルされる場合は&lt;c2&gt;&lt;s3&gt;true&lt;/s3&gt;&lt;/c2&gt;を返します、そうでなければ、それは&lt;c4&gt;&lt;s5&gt;false&lt;/s5&gt;&lt;/c4&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;things&lt;/s1&gt;&lt;/c0&gt; array contains two &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt; values, two &lt;c4&gt;&lt;s5&gt;Double&lt;/s5&gt;&lt;/c4&gt; values, a &lt;c6&gt;&lt;s7&gt;String&lt;/s7&gt;&lt;/c6&gt; value, a tuple of type &lt;c8&gt;&lt;s9&gt;(Double,&lt;/s9&gt; &lt;s10&gt;Double)&lt;/s10&gt;&lt;/c8&gt;, the movie “Ghostbusters”, and a closure expression that takes a &lt;c11&gt;&lt;s12&gt;String&lt;/s12&gt;&lt;/c11&gt; value and returns another &lt;c13&gt;&lt;s14&gt;String&lt;/s14&gt;&lt;/c13&gt; value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;things&lt;/s1&gt;&lt;/c0&gt;配列は、２つの&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;値、２つの&lt;c4&gt;&lt;s5&gt;Double&lt;/s5&gt;&lt;/c4&gt;値、１つの&lt;c6&gt;&lt;s7&gt;String&lt;/s7&gt;&lt;/c6&gt;値、型&lt;c8&gt;&lt;s9&gt;(Double,&lt;/s9&gt; &lt;s10&gt;Double)&lt;/s10&gt;&lt;/c8&gt;のタプル、映画「ゴーストバスターズ」、そして&lt;c11&gt;&lt;s12&gt;String&lt;/s12&gt;&lt;/c11&gt;値をとって別の&lt;c13&gt;&lt;s14&gt;String&lt;/s14&gt;&lt;/c13&gt;値を返す１つのクロージャ式を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;throws&lt;/s1&gt;&lt;/c0&gt; keyword is part of a function’s type, and nonthrowing functions are subtypes of throwing functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;throws&lt;/s1&gt;&lt;/c0&gt;キーワードは関数の型の一部です、そしてスローを行わない関数はスロー関数の下位型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;toggle()&lt;/s1&gt;&lt;/c0&gt; method is marked with the &lt;c2&gt;&lt;s3&gt;mutating&lt;/s3&gt;&lt;/c2&gt; keyword as part of the &lt;c4&gt;&lt;s5&gt;Togglable&lt;/s5&gt;&lt;/c4&gt; protocol definition, to indicate that the method is expected to mutate the state of a conforming instance when it’s called:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;toggle()&lt;/s1&gt;&lt;/c0&gt;メソッドは、&lt;c4&gt;&lt;s5&gt;Togglable&lt;/s5&gt;&lt;/c4&gt;プロトコル定義の一部として&lt;c2&gt;&lt;s3&gt;mutating&lt;/s3&gt;&lt;/c2&gt;キーワードで印されます、それによってそのメソッドが、それが呼ばれるとき準拠インスタンスの状態を変化させることを予期されるようにします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;topItem&lt;/s1&gt;&lt;/c0&gt; computed property can now be used with any &lt;c2&gt;&lt;s3&gt;Stack&lt;/s3&gt;&lt;/c2&gt; instance to access and query its top item without removing it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;topItem&lt;/s1&gt;&lt;/c0&gt;計算プロパティは、今やあらゆる&lt;c2&gt;&lt;s3&gt;Stack&lt;/s3&gt;&lt;/c2&gt;インスタンスで、それの一番上の項目にそれを取り除くことなくアクセスおよび問い合わせるために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;topItem&lt;/s1&gt;&lt;/c0&gt; property returns an optional value of type &lt;c2&gt;&lt;s3&gt;Element&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;topItem&lt;/s1&gt;&lt;/c0&gt;プロパティは型&lt;c2&gt;&lt;s3&gt;Element&lt;/s3&gt;&lt;/c2&gt;のオプショナルの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;try?&lt;/s1&gt;&lt;/c0&gt; expression doesn’t introduce an extra level of optionality to expressions that already return optionals.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;try?&lt;/s1&gt;&lt;/c0&gt;式は、既にオプショナルを返す式に、余分な水準の随意性を導入しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;unavailable&lt;/s1&gt;&lt;/c0&gt; argument indicates that the declaration isn’t available on the specified platform.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;unavailable&lt;/s1&gt;&lt;/c0&gt;引数は、その宣言が指定されたプラットホーム上で利用可能でないことを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;updateValue(_:forKey:)&lt;/s1&gt;&lt;/c0&gt; method returns an optional value of the dictionary’s value type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;updateValue(_:forKey:)&lt;/s1&gt;&lt;/c0&gt;メソッドは、その辞書の値型のオプショナルの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;userDefinedColorName&lt;/s1&gt;&lt;/c0&gt; variable is defined as an optional &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;, with a default value of &lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;userDefinedColorName&lt;/s1&gt;&lt;/c0&gt;変数は、省略時の値の&lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;を持つ、あるオプショナルの&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;として定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;value&lt;/s1&gt;&lt;/c0&gt; properties for the first three &lt;c2&gt;&lt;s3&gt;UnicodeScalar&lt;/s3&gt;&lt;/c2&gt; values (&lt;c4&gt;&lt;s5&gt;68&lt;/s5&gt;&lt;/c4&gt;, &lt;c6&gt;&lt;s7&gt;111&lt;/s7&gt;&lt;/c6&gt;, &lt;c8&gt;&lt;s9&gt;103&lt;/s9&gt;&lt;/c8&gt;) once again represent the characters &lt;c10&gt;&lt;s11&gt;D&lt;/s11&gt;&lt;/c10&gt;, &lt;c12&gt;&lt;s13&gt;o&lt;/s13&gt;&lt;/c12&gt;, and &lt;c14&gt;&lt;s15&gt;g&lt;/s15&gt;&lt;/c14&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の３つの&lt;c2&gt;&lt;s3&gt;UnicodeScalar&lt;/s3&gt;&lt;/c2&gt;値（&lt;c4&gt;&lt;s5&gt;68&lt;/s5&gt;&lt;/c4&gt;、&lt;c6&gt;&lt;s7&gt;111&lt;/s7&gt;&lt;/c6&gt;、&lt;c8&gt;&lt;s9&gt;103&lt;/s9&gt;&lt;/c8&gt;）のための&lt;c0&gt;&lt;s1&gt;value&lt;/s1&gt;&lt;/c0&gt;プロパティは、またふたたび文字&lt;c10&gt;&lt;s11&gt;D&lt;/s11&gt;&lt;/c10&gt;、&lt;c12&gt;&lt;s13&gt;o&lt;/s13&gt;&lt;/c12&gt;、そして&lt;c14&gt;&lt;s15&gt;g&lt;/s15&gt;&lt;/c14&gt;を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;value&lt;/s1&gt;&lt;/c0&gt; property of the fifth and final &lt;c2&gt;&lt;s3&gt;UnicodeScalar&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;128054&lt;/s5&gt;&lt;/c4&gt;, is a decimal equivalent of the hexadecimal value &lt;c6&gt;&lt;s7&gt;1F436&lt;/s7&gt;&lt;/c6&gt;, which represents the Unicode scalar &lt;c8&gt;&lt;s9&gt;U+1F436&lt;/s9&gt;&lt;/c8&gt; for the &lt;c10&gt;&lt;s11&gt;DOG&lt;/s11&gt; &lt;s12&gt;FACE&lt;/s12&gt;&lt;/c10&gt; character.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>５番目で最後の&lt;c2&gt;&lt;s3&gt;UnicodeScalar&lt;/s3&gt;&lt;/c2&gt;の&lt;c0&gt;&lt;s1&gt;value&lt;/s1&gt;&lt;/c0&gt;プロパティ、&lt;c4&gt;&lt;s5&gt;128054&lt;/s5&gt;&lt;/c4&gt;は、16進の値&lt;c6&gt;&lt;s7&gt;1F436&lt;/s7&gt;&lt;/c6&gt;の10進の等価物です、そしてそれは、&lt;c10&gt;&lt;s11&gt;DOG&lt;/s11&gt; &lt;s12&gt;FACE&lt;/s12&gt;&lt;/c10&gt;文字のためのユニコード・スカラー&lt;c8&gt;&lt;s9&gt;U+1F436&lt;/s9&gt;&lt;/c8&gt;を表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;welcomeMessage&lt;/s1&gt;&lt;/c0&gt; variable can now be set to any string value without error:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;welcomeMessage&lt;/s1&gt;&lt;/c0&gt;変数は、現在エラーなしでどんな文字列値にでも設定されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;while&lt;/s1&gt;&lt;/c0&gt; loop’s condition is &lt;c2&gt;&lt;s3&gt;while&lt;/s3&gt; &lt;s4&gt;square&lt;/s4&gt; &lt;s5&gt;!=&lt;/s5&gt; &lt;s6&gt;finalSquare&lt;/s6&gt;&lt;/c2&gt;, to reflect that you must land exactly on square 25.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;while&lt;/s1&gt;&lt;/c0&gt;ループの条件は、あなたが正確に正方形25に到着しなければならないことを反映する、&lt;c2&gt;&lt;s3&gt;while&lt;/s3&gt; &lt;s4&gt;square&lt;/s4&gt; &lt;s5&gt;!=&lt;/s5&gt; &lt;s6&gt;finalSquare&lt;/s6&gt;&lt;/c2&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;willSet&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;didSet&lt;/s3&gt;&lt;/c2&gt; observers for &lt;c4&gt;&lt;s5&gt;totalSteps&lt;/s5&gt;&lt;/c4&gt; are called whenever the property is assigned a new value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;totalSteps&lt;/s5&gt;&lt;/c4&gt;のための&lt;c0&gt;&lt;s1&gt;willSet&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;didSet&lt;/s3&gt;&lt;/c2&gt;オブザーバーは、プロパティが新しい値を代入されるときはいつでも呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;willSet&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;didSet&lt;/s3&gt;&lt;/c2&gt; observers of superclass properties are called when a property is set in a subclass initializer, after the superclass initializer has been called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラスプロパティの&lt;c0&gt;&lt;s1&gt;willSet&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;didSet&lt;/s3&gt;&lt;/c2&gt;オブザーバーは、スーパークラスイニシャライザが呼び出され終わった後、あるプロパティがサプクラスのイニシャライザにおいて設定される時に呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;willSet&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;didSet&lt;/s3&gt;&lt;/c2&gt; observers provide a way to observe (and to respond appropriately) when the value of a variable or property is being set.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;willSet&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;didSet&lt;/s3&gt;&lt;/c2&gt;オブザーバーは、変数またはプロパティの値が設定されている時に監視する（そして適切に応答する）方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c0&gt;&lt;s1&gt;wiseWords&lt;/s1&gt;&lt;/c0&gt; constant contains two escaped double quotation marks.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数の&lt;c0&gt;&lt;s1&gt;wiseWords&lt;/s1&gt;&lt;/c0&gt;は、２つのエスケープされた二重引用符文字を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c10&gt;&lt;s11&gt;Car&lt;/s11&gt;&lt;/c10&gt; class also overrides the &lt;c12&gt;&lt;s13&gt;description&lt;/s13&gt;&lt;/c12&gt; property it inherits from &lt;c14&gt;&lt;s15&gt;Vehicle&lt;/s15&gt;&lt;/c14&gt;, to provide a custom description that includes the current gear:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c10&gt;&lt;s11&gt;Car&lt;/s11&gt;&lt;/c10&gt;クラスはまた、それが&lt;c14&gt;&lt;s15&gt;Vehicle&lt;/s15&gt;&lt;/c14&gt;から継承する&lt;c12&gt;&lt;s13&gt;description&lt;/s13&gt;&lt;/c12&gt;プロパティをオーバーライドして、現在のギアーを示すあつらえの説明を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c10&gt;&lt;s11&gt;apartment&lt;/s11&gt;&lt;/c10&gt; property is optional, because a person may not always have an apartment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>人は必ずしもアパートを持つわけではないので、&lt;c10&gt;&lt;s11&gt;apartment&lt;/s11&gt;&lt;/c10&gt;プロパティはオプショナルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c10&gt;&lt;s11&gt;makeIncrementer&lt;/s11&gt;&lt;/c10&gt; function defines a nested function called &lt;c12&gt;&lt;s13&gt;incrementer&lt;/s13&gt;&lt;/c12&gt;, which performs the actual incrementing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c10&gt;&lt;s11&gt;makeIncrementer&lt;/s11&gt;&lt;/c10&gt;関数は&lt;c12&gt;&lt;s13&gt;incrementer&lt;/s13&gt;&lt;/c12&gt;と呼ばれる入れ子にされた関数を定義します、それは、実際に増やすことを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c10&gt;&lt;s11&gt;switch&lt;/s11&gt;&lt;/c10&gt; case matches the current value of &lt;c12&gt;&lt;s13&gt;point&lt;/s13&gt;&lt;/c12&gt; only if the &lt;c14&gt;&lt;s15&gt;where&lt;/s15&gt;&lt;/c14&gt; clause’s condition evaluates to &lt;c16&gt;&lt;s17&gt;true&lt;/s17&gt;&lt;/c16&gt; for that value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この&lt;c10&gt;&lt;s11&gt;switch&lt;/s11&gt;&lt;/c10&gt;ケース節は、&lt;c12&gt;&lt;s13&gt;point&lt;/s13&gt;&lt;/c12&gt;の現在の値に、&lt;c14&gt;&lt;s15&gt;where&lt;/s15&gt;&lt;/c14&gt;節の条件が&lt;c16&gt;&lt;s17&gt;true&lt;/s17&gt;&lt;/c16&gt;に評価する場合にのみ適合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c11&gt;&lt;s12&gt;fixedIncrement&lt;/s12&gt;&lt;/c11&gt; property is also an optional requirement, so its value is an optional &lt;c13&gt;&lt;s14&gt;Int&lt;/s14&gt;&lt;/c13&gt; value, even though &lt;c15&gt;&lt;s16&gt;fixedIncrement&lt;/s16&gt;&lt;/c15&gt; is defined as a non-optional &lt;c17&gt;&lt;s18&gt;Int&lt;/s18&gt;&lt;/c17&gt; property as part of the &lt;c19&gt;&lt;s20&gt;CounterDataSource&lt;/s20&gt;&lt;/c19&gt; protocol definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c11&gt;&lt;s12&gt;fixedIncrement&lt;/s12&gt;&lt;/c11&gt;プロパティもまたオプショナルの要件です、なのでその値はオプショナルの&lt;c13&gt;&lt;s14&gt;Int&lt;/s14&gt;&lt;/c13&gt;値です、たとえ&lt;c15&gt;&lt;s16&gt;fixedIncrement&lt;/s16&gt;&lt;/c15&gt;が非オプショナルの&lt;c17&gt;&lt;s18&gt;Int&lt;/s18&gt;&lt;/c17&gt;プロパティであると&lt;c19&gt;&lt;s20&gt;CounterDataSource&lt;/s20&gt;&lt;/c19&gt;プロトコル定義の部分では定義されるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c12&gt;&lt;s13&gt;description&lt;/s13&gt;&lt;/c12&gt; property uses optional binding to check whether there is a second value to display, and if so, inserts additional description detail for that second value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c12&gt;&lt;s13&gt;description&lt;/s13&gt;&lt;/c12&gt;プロパティは、オプショナル束縛を使って、表示する第２の値があるかどうか調べます、そしてもしそうなら、その第２の値に関する追加の記述詳細を差し込みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c16&gt;&lt;s17&gt;Country&lt;/s17&gt;&lt;/c16&gt; initializer can therefore pass &lt;c18&gt;&lt;s19&gt;self&lt;/s19&gt;&lt;/c18&gt; as one of the parameters for the &lt;c20&gt;&lt;s21&gt;City&lt;/s21&gt;&lt;/c20&gt; initializer when the &lt;c22&gt;&lt;s23&gt;Country&lt;/s23&gt;&lt;/c22&gt; initializer is setting its own &lt;c24&gt;&lt;s25&gt;capitalCity&lt;/s25&gt;&lt;/c24&gt; property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c16&gt;&lt;s17&gt;Country&lt;/s17&gt;&lt;/c16&gt;イニシャライザはしたがって、&lt;c18&gt;&lt;s19&gt;self&lt;/s19&gt;&lt;/c18&gt;を&lt;c20&gt;&lt;s21&gt;City&lt;/s21&gt;&lt;/c20&gt;イニシャライザのパラメータの１つとして渡すことが、&lt;c22&gt;&lt;s23&gt;Country&lt;/s23&gt;&lt;/c22&gt;イニシャライザが自身の&lt;c24&gt;&lt;s25&gt;capitalCity&lt;/s25&gt;&lt;/c24&gt;プロパティを設定しているときに可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c16&gt;&lt;s17&gt;default&lt;/s17&gt;&lt;/c16&gt; case adds some extra text to the end of the description, and the &lt;c18&gt;&lt;s19&gt;switch&lt;/s19&gt;&lt;/c18&gt; statement is complete.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c16&gt;&lt;s17&gt;default&lt;/s17&gt;&lt;/c16&gt;ケース節はこの解説（description）の終わりに追加の若干のテキストを加えます、そして&lt;c18&gt;&lt;s19&gt;switch&lt;/s19&gt;&lt;/c18&gt;文は終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c1&gt;&lt;s2&gt;continue&lt;/s2&gt; &lt;s3&gt;gameLoop&lt;/s3&gt;&lt;/c1&gt; statement ends the current &lt;c4&gt;&lt;s5&gt;while&lt;/s5&gt;&lt;/c4&gt; loop iteration and begins the next iteration of the loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c1&gt;&lt;s2&gt;continue&lt;/s2&gt; &lt;s3&gt;gameLoop&lt;/s3&gt;&lt;/c1&gt;文は、現在の&lt;c4&gt;&lt;s5&gt;while&lt;/s5&gt;&lt;/c4&gt;ループ繰り返しを終えて、ループの次の繰り返しを開始します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c20&gt;&lt;s21&gt;name&lt;/s21&gt;&lt;/c20&gt; property is automatically given a default value of &lt;c22&gt;&lt;s23&gt;nil&lt;/s23&gt;&lt;/c22&gt;, or “no &lt;c24&gt;&lt;s25&gt;name&lt;/s25&gt;&lt;/c24&gt; value”, because it’s of an optional type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c20&gt;&lt;s21&gt;name&lt;/s21&gt;&lt;/c20&gt;プロパティは省略時の値の&lt;c22&gt;&lt;s23&gt;nil&lt;/s23&gt;&lt;/c22&gt;、つまり「&lt;c24&gt;&lt;s25&gt;name&lt;/s25&gt;&lt;/c24&gt;値なし」を自動的に与えられます、なぜならそれがオプショナル型であるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c29&gt;&lt;s30&gt;COMBINING&lt;/s30&gt; &lt;s31&gt;ACUTE&lt;/s31&gt; &lt;s32&gt;ACCENT&lt;/s32&gt;&lt;/c29&gt; scalar is graphically applied to the scalar that precedes it, turning an &lt;c33&gt;&lt;s34&gt;e&lt;/s34&gt;&lt;/c33&gt; into an &lt;c35&gt;&lt;s36&gt;é&lt;/s36&gt;&lt;/c35&gt; when it’s rendered by a Unicode-aware text-rendering system.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c29&gt;&lt;s30&gt;COMBINING&lt;/s30&gt; &lt;s31&gt;ACUTE&lt;/s31&gt; &lt;s32&gt;ACCENT&lt;/s32&gt;&lt;/c29&gt;スカラーは、それの前のスカラーに追加筆記され、&lt;c33&gt;&lt;s34&gt;e&lt;/s34&gt;&lt;/c33&gt;を、それがユニコードに通じたテキスト描画システムによって表わされる時に、&lt;c35&gt;&lt;s36&gt;é&lt;/s36&gt;&lt;/c35&gt;にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;&lt;s3&gt;BlackjackCard&lt;/s3&gt;&lt;/c2&gt; structure contains two nested enumeration types called &lt;c4&gt;&lt;s5&gt;Suit&lt;/s5&gt;&lt;/c4&gt; and &lt;c6&gt;&lt;s7&gt;Rank&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;BlackjackCard&lt;/s3&gt;&lt;/c2&gt;構造体は、&lt;c4&gt;&lt;s5&gt;Suit&lt;/s5&gt;&lt;/c4&gt;と&lt;c6&gt;&lt;s7&gt;Rank&lt;/s7&gt;&lt;/c6&gt;と呼ばれる２つの入れ子にされた列挙型を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;&lt;s3&gt;Celsius&lt;/s3&gt;&lt;/c2&gt; structure implements two custom initializers called &lt;c4&gt;&lt;s5&gt;init(fromFahrenheit:)&lt;/s5&gt;&lt;/c4&gt; and &lt;c6&gt;&lt;s7&gt;init(fromKelvin:)&lt;/s7&gt;&lt;/c6&gt;, which initialize a new instance of the structure with a value from a different temperature scale:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;Celsius&lt;/s3&gt;&lt;/c2&gt;構造体は、&lt;c4&gt;&lt;s5&gt;init(fromFahrenheit:)&lt;/s5&gt;&lt;/c4&gt;と&lt;c6&gt;&lt;s7&gt;init(fromKelvin:)&lt;/s7&gt;&lt;/c6&gt;と呼ばれる２つのあつらえのイニシャライザを実装します、それは、その構造体の新しいインスタンスを異なる温度尺度の値を使って初期化します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;&lt;s3&gt;Container&lt;/s3&gt;&lt;/c2&gt; protocol needs to specify that any value passed to the &lt;c4&gt;&lt;s5&gt;append(_:)&lt;/s5&gt;&lt;/c4&gt; method must have the same type as the container’s element type, and that the value returned by the container’s subscript will be of the same type as the container’s element type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;Container&lt;/s3&gt;&lt;/c2&gt;プロトコルは、&lt;c4&gt;&lt;s5&gt;append(_:)&lt;/s5&gt;&lt;/c4&gt;メソッドに渡されるあらゆる値がそのコンテナの要素の型と同じ型を持たなければならないこと、そしてコンテナの添え字によって返される値がコンテナの要素型と同じ型のものになることを指定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;&lt;s3&gt;Fahrenheit&lt;/s3&gt;&lt;/c2&gt; structure has one stored property, &lt;c4&gt;&lt;s5&gt;temperature&lt;/s5&gt;&lt;/c4&gt;, which is of type &lt;c6&gt;&lt;s7&gt;Double&lt;/s7&gt;&lt;/c6&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;Fahrenheit&lt;/s3&gt;&lt;/c2&gt;構造体は、１つの格納プロパティ、&lt;c4&gt;&lt;s5&gt;temperature&lt;/s5&gt;&lt;/c4&gt;を持ちます、それは&lt;c6&gt;&lt;s7&gt;Double&lt;/s7&gt;&lt;/c6&gt;型です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;&lt;s3&gt;Food&lt;/s3&gt;&lt;/c2&gt; class introduces a single &lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt; property called &lt;c6&gt;&lt;s7&gt;name&lt;/s7&gt;&lt;/c6&gt; and provides two initializers for creating &lt;c8&gt;&lt;s9&gt;Food&lt;/s9&gt;&lt;/c8&gt; instances:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;Food&lt;/s3&gt;&lt;/c2&gt;クラスは、&lt;c6&gt;&lt;s7&gt;name&lt;/s7&gt;&lt;/c6&gt;と呼ばれる１つの&lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt;プロパティを導入して、２つのイニシャライザを&lt;c8&gt;&lt;s9&gt;Food&lt;/s9&gt;&lt;/c8&gt;インスタンスをつくるために提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;&lt;s3&gt;Point&lt;/s3&gt;&lt;/c2&gt; example shown above could have been written in the following way instead:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上で示される&lt;c2&gt;&lt;s3&gt;Point&lt;/s3&gt;&lt;/c2&gt;の例は、その代わりに以下のようにして書かれることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;&lt;s3&gt;anotherGreeting(for:)&lt;/s3&gt;&lt;/c2&gt; function returns the same greeting message, using the &lt;c4&gt;&lt;s5&gt;return&lt;/s5&gt;&lt;/c4&gt; keyword like a longer function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;anotherGreeting(for:)&lt;/s3&gt;&lt;/c2&gt;関数は、同じ挨拶メッセージを返します、もっと長い関数のように&lt;c4&gt;&lt;s5&gt;return&lt;/s5&gt;&lt;/c4&gt;キーワードを使って。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;&lt;s3&gt;break&lt;/s3&gt;&lt;/c2&gt; statement can be used inside a &lt;c4&gt;&lt;s5&gt;switch&lt;/s5&gt;&lt;/c4&gt; or loop statement when you want to terminate the execution of the &lt;c6&gt;&lt;s7&gt;switch&lt;/s7&gt;&lt;/c6&gt; or loop statement earlier than would otherwise be the case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;break&lt;/s3&gt;&lt;/c2&gt;文は、これを使わなかった場合よりも早く&lt;c4&gt;&lt;s5&gt;switch&lt;/s5&gt;&lt;/c4&gt;またはループ文の実行をあなたが終了したい時に、&lt;c6&gt;&lt;s7&gt;switch&lt;/s7&gt;&lt;/c6&gt;やループ文の内側で使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;&lt;s3&gt;dollarSign&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;blackHeart&lt;/s5&gt;&lt;/c4&gt;, and &lt;c6&gt;&lt;s7&gt;sparklingHeart&lt;/s7&gt;&lt;/c6&gt; constants demonstrate the Unicode scalar format:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;dollarSign&lt;/s3&gt;&lt;/c2&gt;、&lt;c4&gt;&lt;s5&gt;blackHeart&lt;/s5&gt;&lt;/c4&gt;、そして&lt;c6&gt;&lt;s7&gt;sparklingHeart&lt;/s7&gt;&lt;/c6&gt;定数は、Unicodeスカラーの書式を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;&lt;s3&gt;dynamicCallable&lt;/s3&gt;&lt;/c2&gt; attribute’s methods specify only the type used to hold the array of arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;dynamicCallable&lt;/s3&gt;&lt;/c2&gt;属性のもつメソッドは、引数それらからなる配列を保持するために使われる型だけを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;&lt;s3&gt;grid&lt;/s3&gt;&lt;/c2&gt; array for this &lt;c4&gt;&lt;s5&gt;Matrix&lt;/s5&gt;&lt;/c4&gt; instance is effectively a flattened version of the matrix, as read from top left to bottom right:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この&lt;c4&gt;&lt;s5&gt;Matrix&lt;/s5&gt;&lt;/c4&gt;インスタンスのための&lt;c2&gt;&lt;s3&gt;grid&lt;/s3&gt;&lt;/c2&gt;配列は、実際にはこのMatrix 行列の、左上から右下へと読まれる、平らにされた改変板です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;&lt;s3&gt;let&lt;/s3&gt;&lt;/c2&gt; keyword is only used for constant properties, to indicate that their values cannot be changed once they are set as part of instance initialization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;let&lt;/s3&gt;&lt;/c2&gt;キーワードは定数プロパティのためにだけ使われます、そして一旦それがインスタンス初期化の一部として設定されるならば、その値が変わることができないことを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;&lt;s3&gt;lowerThan&lt;/s3&gt;&lt;/c2&gt; precedence group attribute may only be used to refer to precedence groups declared outside of the current module.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;lowerThan&lt;/s3&gt;&lt;/c2&gt;優先順位グループ属性は、現在のモジュールの外側で宣言される優先順位グループを参照するのに使われるだけでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;&lt;s3&gt;nonobjc&lt;/s3&gt;&lt;/c2&gt; attribute tells the compiler to make the declaration unavailable in Objective-C code, even though it’s possible to represent it in Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;nonobjc&lt;/s3&gt;&lt;/c2&gt;属性は、コンパイラにその宣言がObjective-Cコードにおいて利用不可にされることを伝えます、たとえそれがObjective-Cにおいて表現可能であってもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;&lt;s3&gt;optional&lt;/s3&gt;&lt;/c2&gt; modifier can be applied only to members that are marked with the &lt;c4&gt;&lt;s5&gt;objc&lt;/s5&gt;&lt;/c4&gt; attribute, and only to members of protocols that are marked with the &lt;c6&gt;&lt;s7&gt;objc&lt;/s7&gt;&lt;/c6&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;optional&lt;/s3&gt;&lt;/c2&gt;修飾子は、&lt;c4&gt;&lt;s5&gt;objc&lt;/s5&gt;&lt;/c4&gt;属性で印されるメンバにだけ、そして&lt;c6&gt;&lt;s7&gt;objc&lt;/s7&gt;&lt;/c6&gt;属性で印されるプロトコルのメンバにだけ適用されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;&lt;s3&gt;possibleIntegerValue&lt;/s3&gt;&lt;/c2&gt; variable has an implicit initial value of &lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt; by virtue of being an optional type, and so the optional binding will succeed only if &lt;c6&gt;&lt;s7&gt;possibleIntegerValue&lt;/s7&gt;&lt;/c6&gt; was set to an actual value by one of the &lt;c8&gt;&lt;s9&gt;switch&lt;/s9&gt;&lt;/c8&gt; statement’s first four cases.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;possibleIntegerValue&lt;/s3&gt;&lt;/c2&gt;変数は、オプショナル型であることの長所によって暗黙的な初期値の&lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;を持ちます、そのため&lt;c6&gt;&lt;s7&gt;possibleIntegerValue&lt;/s7&gt;&lt;/c6&gt;が&lt;c8&gt;&lt;s9&gt;switch&lt;/s9&gt;&lt;/c8&gt;文の最初の４つのケース節の内の１つによって実際の値に設定された場合にのみこのオプショナル束縛は成功します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c2&gt;&lt;s3&gt;throws&lt;/s3&gt;&lt;/c2&gt; keyword is part of a function’s type, and nonthrowing functions are subtypes of throwing functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;throws&lt;/s3&gt;&lt;/c2&gt;キーワードは関数の型の一部です、そしてスローを行わない関数はスロー関数の下位型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;&lt;s5&gt;@escaping&lt;/s5&gt;&lt;/c4&gt; attribute is described above in &lt;a6&gt;&lt;s7&gt;Escaping Closures&lt;/s7&gt;&lt;/a6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;@escaping&lt;/s5&gt;&lt;/c4&gt;属性は、上の&lt;a6&gt;&lt;s7&gt;脱出クロージャ&lt;/s7&gt;&lt;/a6&gt;で解説されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;&lt;s5&gt;AutomaticCar&lt;/s5&gt;&lt;/c4&gt; class represents a car with an automatic gearbox, which automatically selects an appropriate gear to use based on the current speed:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;AutomaticCar&lt;/s5&gt;&lt;/c4&gt;クラスはオートマチック・ギアボックスをもつ車を表します、それは、現在の速度に基づいて自動的に使用するのに適切なギアを選びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;&lt;s5&gt;AutomaticallyNamedDocument&lt;/s5&gt;&lt;/c4&gt; subclass overrides both of the designated initializers introduced by &lt;c6&gt;&lt;s7&gt;Document&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;AutomaticallyNamedDocument&lt;/s5&gt;&lt;/c4&gt;サブクラスは、&lt;c6&gt;&lt;s7&gt;Document&lt;/s7&gt;&lt;/c6&gt;で導入される指定イニシャライザを両方ともオーバーライドします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;&lt;s5&gt;Bank&lt;/s5&gt;&lt;/c4&gt; class manages a made-up currency, which can never have more than 10,000 coins in circulation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;Bank&lt;/s5&gt;&lt;/c4&gt;クラスは、ある架空の通貨を管理します、そしてそれは、流通する10,000個以上のコインを決して持つことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;&lt;s5&gt;Car&lt;/s5&gt;&lt;/c4&gt; class introduces a new stored property called &lt;c6&gt;&lt;s7&gt;gear&lt;/s7&gt;&lt;/c6&gt;, with a default integer value of &lt;c8&gt;&lt;s9&gt;1&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;Car&lt;/s5&gt;&lt;/c4&gt;クラスは、&lt;c6&gt;&lt;s7&gt;gear&lt;/s7&gt;&lt;/c6&gt;と呼ばれる、&lt;c8&gt;&lt;s9&gt;1&lt;/s9&gt;&lt;/c8&gt;の省略時の値を持つ、新しい格納プロパティを導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;&lt;s5&gt;CartItem&lt;/s5&gt;&lt;/c4&gt; class models an item in an online shopping cart.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;CartItem&lt;/s5&gt;&lt;/c4&gt;クラスは、あるオンライン買物かごの中のひとつの項目をモデル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;&lt;s5&gt;Counter&lt;/s5&gt;&lt;/c4&gt; class also defines a method called &lt;c6&gt;&lt;s7&gt;increment&lt;/s7&gt;&lt;/c6&gt;, which increments the &lt;c8&gt;&lt;s9&gt;count&lt;/s9&gt;&lt;/c8&gt; property every time the method is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;Counter&lt;/s5&gt;&lt;/c4&gt;クラスはまた、&lt;c6&gt;&lt;s7&gt;increment&lt;/s7&gt;&lt;/c6&gt;と呼ばれるメソッドを定義します、それは、メソッドが呼ばれるたびに&lt;c8&gt;&lt;s9&gt;count&lt;/s9&gt;&lt;/c8&gt;プロパティを増加させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;&lt;s5&gt;Matrix&lt;/s5&gt;&lt;/c4&gt; structure’s subscript takes two integer parameters:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;Matrix&lt;/s5&gt;&lt;/c4&gt;構造体の添え字は、２つの整数パラメータをとります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;&lt;s5&gt;Person&lt;/s5&gt;&lt;/c4&gt; class also has a deinitializer that prints a message when an instance of the class is deallocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;Person&lt;/s5&gt;&lt;/c4&gt;クラスはまた、クラスのインスタンスが割り当て解除されるとき、メッセージを出力するデイニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;&lt;s5&gt;Player&lt;/s5&gt;&lt;/c4&gt; class also implements a deinitializer, which is called just before a &lt;c6&gt;&lt;s7&gt;Player&lt;/s7&gt;&lt;/c6&gt; instance is deallocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;Player&lt;/s5&gt;&lt;/c4&gt;クラスはまた、デイニシャライザを実装します、それは&lt;c6&gt;&lt;s7&gt;Player&lt;/s7&gt;&lt;/c6&gt;インスタンスが割り当て解除される直前に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;&lt;s5&gt;RecipeIngredient&lt;/s5&gt;&lt;/c4&gt; class models an ingredient in a cooking recipe.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;RecipeIngredient&lt;/s5&gt;&lt;/c4&gt;クラスは、料理のレシピの材料をモデル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;&lt;s5&gt;ShoppingListItem&lt;/s5&gt;&lt;/c4&gt; class models a recipe ingredient as it appears in a shopping list.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;ShoppingListItem&lt;/s5&gt;&lt;/c4&gt;クラスは、それが購入品目リストに現れるように、レシピの材料をモデル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;&lt;s5&gt;Values&lt;/s5&gt;&lt;/c4&gt; structure defines two properties to represent this:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;Values&lt;/s5&gt;&lt;/c4&gt;構造体は、これを表すために２つのプロパティを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;&lt;s5&gt;a&lt;/s5&gt;&lt;/c4&gt; in the inner scope is initialized with the value of the &lt;c6&gt;&lt;s7&gt;a&lt;/s7&gt;&lt;/c6&gt; in the outer scope when the closure is created, but their values are not connected in any special way.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>内側のスコープの中の&lt;c4&gt;&lt;s5&gt;a&lt;/s5&gt;&lt;/c4&gt;は、クロージャが作成される時に外側のスコープの中の&lt;c6&gt;&lt;s7&gt;a&lt;/s7&gt;&lt;/c6&gt;の値で初期化されます、しかしそれらの値は何ら特別な方法で結びつけられません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;&lt;s5&gt;arch(i386)&lt;/s5&gt;&lt;/c4&gt; platform condition returns &lt;c6&gt;&lt;s7&gt;true&lt;/s7&gt;&lt;/c6&gt; when code is compiled for the 32–bit iOS simulator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;arch(i386)&lt;/s5&gt;&lt;/c4&gt;プラットホーム条件は、コードが32ビットiOSシミュレーターに対してコンパイルされるとき&lt;c6&gt;&lt;s7&gt;true&lt;/s7&gt;&lt;/c6&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;&lt;s5&gt;as!&lt;/s5&gt;&lt;/c4&gt; operator returns a value of the specified &lt;e6&gt;type&lt;/e6&gt;, not an optional type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;as!&lt;/s5&gt;&lt;/c4&gt;演算子は指定された&lt;e6&gt;型&lt;/e6&gt;の値を返します、オプショナル型ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;&lt;s5&gt;as?&lt;/s5&gt;&lt;/c4&gt; operator returns an optional of the specified &lt;e6&gt;type&lt;/e6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;as?&lt;/s5&gt;&lt;/c4&gt;演算子は、指定された&lt;e6&gt;型&lt;/e6&gt;のオプショナルを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;&lt;s5&gt;fallthrough&lt;/s5&gt;&lt;/c4&gt; keyword simply causes code execution to move directly to the statements inside the next case (or &lt;c6&gt;&lt;s7&gt;default&lt;/s7&gt;&lt;/c6&gt; case) block, as in C’s standard &lt;c8&gt;&lt;s9&gt;switch&lt;/s9&gt;&lt;/c8&gt; statement behavior.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;fallthrough&lt;/s5&gt;&lt;/c4&gt;キーワードは、Cの標準の&lt;c8&gt;&lt;s9&gt;switch&lt;/s9&gt;&lt;/c8&gt;文の挙動でのように、単に次のケース節（または&lt;c6&gt;&lt;s7&gt;default&lt;/s7&gt;&lt;/c6&gt;ケース節）ブロックの中の文へ、コード実行を直接に移すことを引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;&lt;s5&gt;game&lt;/s5&gt;&lt;/c4&gt; parameter has a type of &lt;c6&gt;&lt;s7&gt;DiceGame&lt;/s7&gt;&lt;/c6&gt;, not &lt;c8&gt;&lt;s9&gt;SnakesAndLadders&lt;/s9&gt;&lt;/c8&gt;, and so &lt;c10&gt;&lt;s11&gt;gameDidStart(_:)&lt;/s11&gt;&lt;/c10&gt; can access and use only methods and properties that are implemented as part of the &lt;c12&gt;&lt;s13&gt;DiceGame&lt;/s13&gt;&lt;/c12&gt; protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;game&lt;/s5&gt;&lt;/c4&gt;パラメータは、型&lt;c6&gt;&lt;s7&gt;DiceGame&lt;/s7&gt;&lt;/c6&gt;を持ちます、&lt;c8&gt;&lt;s9&gt;SnakesAndLadders&lt;/s9&gt;&lt;/c8&gt;ではありません、なので、&lt;c10&gt;&lt;s11&gt;gameDidStart(_:)&lt;/s11&gt;&lt;/c10&gt;は&lt;c12&gt;&lt;s13&gt;DiceGame&lt;/s13&gt;&lt;/c12&gt;プロトコルの一部として実施されるメソッドとプロパティだけにアクセスして使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;&lt;s5&gt;increment()&lt;/s5&gt;&lt;/c4&gt; method uses optional chaining to try to call &lt;c6&gt;&lt;s7&gt;increment(forCount:)&lt;/s7&gt;&lt;/c6&gt;, and passes the current &lt;c8&gt;&lt;s9&gt;count&lt;/s9&gt;&lt;/c8&gt; value as the method’s single argument.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;increment()&lt;/s5&gt;&lt;/c4&gt;メソッドは、オプショナル連鎖を使って&lt;c6&gt;&lt;s7&gt;increment(forCount:)&lt;/s7&gt;&lt;/c6&gt;を呼ぶことを試みます、そしてメソッドのもつただ１つの引数として現在の&lt;c8&gt;&lt;s9&gt;count&lt;/s9&gt;&lt;/c8&gt;値を渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;&lt;s5&gt;is&lt;/s5&gt;&lt;/c4&gt; pattern appears only in &lt;c6&gt;&lt;s7&gt;switch&lt;/s7&gt;&lt;/c6&gt; statement case labels.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;is&lt;/s5&gt;&lt;/c4&gt;パターンは、&lt;c6&gt;&lt;s7&gt;switch&lt;/s7&gt;&lt;/c6&gt;文のケース節ラベルだけで見かけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;&lt;s5&gt;is&lt;/s5&gt;&lt;/c4&gt; pattern behaves like the &lt;c6&gt;&lt;s7&gt;is&lt;/s7&gt;&lt;/c6&gt; operator in that they both perform a type cast but discard the returned type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;is&lt;/s5&gt;&lt;/c4&gt;パターンは、それらが両方とも型キャストを実行するが返された型を捨てるという点において、&lt;c6&gt;&lt;s7&gt;is&lt;/s7&gt;&lt;/c6&gt;演算子のようにふるまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;&lt;s5&gt;makeIterator()&lt;/s5&gt;&lt;/c4&gt; function provides access to a container’s iterator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;makeIterator()&lt;/s5&gt;&lt;/c4&gt;関数は、コンテナの持つイテレータに対するアクセスを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;&lt;s5&gt;mutating&lt;/s5&gt;&lt;/c4&gt; keyword is only used by structures and enumerations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;mutating&lt;/s5&gt;&lt;/c4&gt;キーワードは、構造体と列挙によって使われるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;&lt;s5&gt;objcMembers&lt;/s5&gt;&lt;/c4&gt; attribute is a convenience for libraries that make heavy use of the introspection facilities of the Objective-C runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;objcMembers&lt;/s5&gt;&lt;/c4&gt;属性は、Objective-Cランタイムの自己観察便宜の重度の使用を生じさせるライブラリにとって好都合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;&lt;s5&gt;separator&lt;/s5&gt;&lt;/c4&gt; and &lt;c6&gt;&lt;s7&gt;terminator&lt;/s7&gt;&lt;/c6&gt; parameter have default values, so you can omit them when you call this function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;separator&lt;/s5&gt;&lt;/c4&gt;と&lt;c6&gt;&lt;s7&gt;terminator&lt;/s7&gt;&lt;/c6&gt;パラメータは省略時の値を持ちます、それであなたはそれらを省略することが、この関数をあなたが呼び出す時に可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;&lt;s5&gt;someContainer&lt;/s5&gt;&lt;/c4&gt; argument is of type &lt;c6&gt;&lt;s7&gt;C1&lt;/s7&gt;&lt;/c6&gt;, and the &lt;c8&gt;&lt;s9&gt;anotherContainer&lt;/s9&gt;&lt;/c8&gt; argument is of type &lt;c10&gt;&lt;s11&gt;C2&lt;/s11&gt;&lt;/c10&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;someContainer&lt;/s5&gt;&lt;/c4&gt;引数は型&lt;c6&gt;&lt;s7&gt;C1&lt;/s7&gt;&lt;/c6&gt;です、そして&lt;c8&gt;&lt;s9&gt;anotherContainer&lt;/s9&gt;&lt;/c8&gt;引数は型&lt;c10&gt;&lt;s11&gt;C2&lt;/s11&gt;&lt;/c10&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;&lt;s5&gt;square&lt;/s5&gt;&lt;/c4&gt; variable is initialized with an origin point of &lt;c6&gt;&lt;s7&gt;(0,&lt;/s7&gt; &lt;s8&gt;0)&lt;/s8&gt;&lt;/c6&gt;, and a width and height of &lt;c9&gt;&lt;s10&gt;10&lt;/s10&gt;&lt;/c9&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;square&lt;/s5&gt;&lt;/c4&gt;変数は、&lt;c6&gt;&lt;s7&gt;(0,&lt;/s7&gt; &lt;s8&gt;0)&lt;/s8&gt;&lt;/c6&gt;の原点、そして&lt;c9&gt;&lt;s10&gt;10&lt;/s10&gt;&lt;/c9&gt;の幅と高さで初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;&lt;s5&gt;stepForward(_:)&lt;/s5&gt;&lt;/c4&gt; function returns a value one more than its input value, and the &lt;c6&gt;&lt;s7&gt;stepBackward(_:)&lt;/s7&gt;&lt;/c6&gt; function returns a value one less than its input value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;stepForward(_:)&lt;/s5&gt;&lt;/c4&gt;関数は、その入力された値より１大きい値を返します、そして&lt;c6&gt;&lt;s7&gt;stepBackward(_:)&lt;/s7&gt;&lt;/c6&gt;関数はその入力された値より１小さい値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;&lt;s5&gt;suffix(_:)&lt;/s5&gt;&lt;/c4&gt; method returns a given number of elements from the end of the container, storing them in an instance of the &lt;c6&gt;&lt;s7&gt;Suffix&lt;/s7&gt;&lt;/c6&gt; type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;suffix(_:)&lt;/s5&gt;&lt;/c4&gt;メソッドは、コンテナの終わりから指定の数の要素を、それらを&lt;c6&gt;&lt;s7&gt;Suffix&lt;/s7&gt;&lt;/c6&gt;型のインスタンスの中に格納して、返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;&lt;s5&gt;switch&lt;/s5&gt;&lt;/c4&gt; statement determines which branch should be selected.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;switch&lt;/s5&gt;&lt;/c4&gt;文は、どの分岐が選ばれるべきか決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c4&gt;&lt;s5&gt;while&lt;/s5&gt;&lt;/c4&gt; loop has a statement label called &lt;c6&gt;&lt;s7&gt;gameLoop&lt;/s7&gt;&lt;/c6&gt; to indicate that it is the main game loop for the Snakes and Ladders game.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;while&lt;/s5&gt;&lt;/c4&gt;ループは、&lt;c6&gt;&lt;s7&gt;gameLoop&lt;/s7&gt;&lt;/c6&gt;と呼ばれる文ラベルを持ち、それが「ヘビとはしご」ゲームのための主なゲーム・ループであることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c5&gt;&lt;s6&gt;init()&lt;/s6&gt;&lt;/c5&gt; initializer provides a default placeholder name for a new food by delegating across to the &lt;c7&gt;&lt;s8&gt;Food&lt;/s8&gt;&lt;/c7&gt; class’s &lt;c9&gt;&lt;s10&gt;init(name:&lt;/s10&gt; &lt;s11&gt;String)&lt;/s11&gt;&lt;/c9&gt; with a &lt;c12&gt;&lt;s13&gt;name&lt;/s13&gt;&lt;/c12&gt; value of &lt;c14&gt;&lt;s15&gt;[Unnamed]&lt;/s15&gt;&lt;/c14&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c5&gt;&lt;s6&gt;init()&lt;/s6&gt;&lt;/c5&gt;イニシャライザは、&lt;c7&gt;&lt;s8&gt;Food&lt;/s8&gt;&lt;/c7&gt;クラスの&lt;c9&gt;&lt;s10&gt;init(name:&lt;/s10&gt; &lt;s11&gt;String)&lt;/s11&gt;&lt;/c9&gt;に&lt;c14&gt;&lt;s15&gt;[Unnamed]&lt;/s15&gt;&lt;/c14&gt;の&lt;c12&gt;&lt;s13&gt;name&lt;/s13&gt;&lt;/c12&gt;値を使って横に委任することで、省略時のプレースホルダ名を新しい食物のために用意します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c6&gt;&lt;s7&gt;Address&lt;/s7&gt;&lt;/c6&gt; class type for this property is defined below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロパティのための&lt;c6&gt;&lt;s7&gt;Address&lt;/s7&gt;&lt;/c6&gt;クラス型は、下で定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c6&gt;&lt;s7&gt;Aged&lt;/s7&gt;&lt;/c6&gt; protocol has a single requirement for a gettable &lt;c8&gt;&lt;s9&gt;Int&lt;/s9&gt;&lt;/c8&gt; property called &lt;c10&gt;&lt;s11&gt;age&lt;/s11&gt;&lt;/c10&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;Aged&lt;/s7&gt;&lt;/c6&gt;プロトコルは、取得可能な&lt;c8&gt;&lt;s9&gt;Int&lt;/s9&gt;&lt;/c8&gt;プロパティで&lt;c10&gt;&lt;s11&gt;age&lt;/s11&gt;&lt;/c10&gt;と呼ばれるものに対するただ１つの要件を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c6&gt;&lt;s7&gt;Animal&lt;/s7&gt;&lt;/c6&gt; structure also defines a failable initializer with a single parameter called &lt;c8&gt;&lt;s9&gt;species&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;Animal&lt;/s7&gt;&lt;/c6&gt;構造体はまた、&lt;c8&gt;&lt;s9&gt;species&lt;/s9&gt;&lt;/c8&gt;と呼ばれるただ１つのパラメータを持つ、失敗できるイニシャライザを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c6&gt;&lt;s7&gt;Country&lt;/s7&gt;&lt;/c6&gt; class implements the &lt;c8&gt;&lt;s9&gt;area&lt;/s9&gt;&lt;/c8&gt; requirement directly as a stored property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;Country&lt;/s7&gt;&lt;/c6&gt;クラスは、&lt;c8&gt;&lt;s9&gt;area&lt;/s9&gt;&lt;/c8&gt;要件を格納プロパティとして直接に満たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c6&gt;&lt;s7&gt;Equatable&lt;/s7&gt;&lt;/c6&gt; protocol requires any conforming implementation of &lt;c8&gt;&lt;s9&gt;==&lt;/s9&gt;&lt;/c8&gt; to be an equivalence relation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;Equatable&lt;/s7&gt;&lt;/c6&gt;プロトコルは、&lt;c8&gt;&lt;s9&gt;==&lt;/s9&gt;&lt;/c8&gt;のどんな準拠実装もひとつの同等性関係であることを要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c6&gt;&lt;s7&gt;Tandem&lt;/s7&gt;&lt;/c6&gt; subclass also adds a new stored property called &lt;c8&gt;&lt;s9&gt;currentNumberOfPassengers&lt;/s9&gt;&lt;/c8&gt;, with a default value of &lt;c10&gt;&lt;s11&gt;0&lt;/s11&gt;&lt;/c10&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;Tandem&lt;/s7&gt;&lt;/c6&gt;サブクラスはまた、&lt;c8&gt;&lt;s9&gt;currentNumberOfPassengers&lt;/s9&gt;&lt;/c8&gt;と呼ばれる新しい格納プロパティを、&lt;c10&gt;&lt;s11&gt;0&lt;/s11&gt;&lt;/c10&gt;の省略時の値を使って追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c6&gt;&lt;s7&gt;chooseStepFunction(backward:)&lt;/s7&gt;&lt;/c6&gt; function returns the &lt;c8&gt;&lt;s9&gt;stepForward(_:)&lt;/s9&gt;&lt;/c8&gt; function or the &lt;c10&gt;&lt;s11&gt;stepBackward(_:)&lt;/s11&gt;&lt;/c10&gt; function based on a Boolean parameter called &lt;c12&gt;&lt;s13&gt;backward&lt;/s13&gt;&lt;/c12&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;chooseStepFunction(backward:)&lt;/s7&gt;&lt;/c6&gt;は&lt;c8&gt;&lt;s9&gt;stepForward(_:)&lt;/s9&gt;&lt;/c8&gt;関数あるいは&lt;c10&gt;&lt;s11&gt;stepBackward(_:)&lt;/s11&gt;&lt;/c10&gt;関数を、&lt;c12&gt;&lt;s13&gt;backward&lt;/s13&gt;&lt;/c12&gt;と呼ばれるブールのパラメータに基づいて返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c6&gt;&lt;s7&gt;didSet&lt;/s7&gt;&lt;/c6&gt; observer does not provide a custom parameter name for the old value, and the default name of &lt;c8&gt;&lt;s9&gt;oldValue&lt;/s9&gt;&lt;/c8&gt; is used instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;didSet&lt;/s7&gt;&lt;/c6&gt;オブザーバーはあつらえのパラメータ名を古い値のために用意しません、そして省略時の名前の&lt;c8&gt;&lt;s9&gt;oldValue&lt;/s9&gt;&lt;/c8&gt;がその代わりに使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c6&gt;&lt;s7&gt;didSet&lt;/s7&gt;&lt;/c6&gt; observer is called immediately after the new value is set.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;didSet&lt;/s7&gt;&lt;/c6&gt;オブザーバーは、新しい値が設定された直後に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c6&gt;&lt;s7&gt;endIndex&lt;/s7&gt;&lt;/c6&gt; property is the position after the last character in a &lt;c8&gt;&lt;s9&gt;String&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;endIndex&lt;/s7&gt;&lt;/c6&gt;プロパティは、ある&lt;c8&gt;&lt;s9&gt;String&lt;/s9&gt;&lt;/c8&gt;の最後の文字の後の位置を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c6&gt;&lt;s7&gt;findIndex(ofString:in:)&lt;/s7&gt;&lt;/c6&gt; function returns an optional &lt;c8&gt;&lt;s9&gt;Int&lt;/s9&gt;&lt;/c8&gt; value, which will be the index of the first matching string in the array if it’s found, or &lt;c10&gt;&lt;s11&gt;nil&lt;/s11&gt;&lt;/c10&gt; if the string can’t be found:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;findIndex(ofString:in:)&lt;/s7&gt;&lt;/c6&gt;関数は、オプショナルの&lt;c8&gt;&lt;s9&gt;Int&lt;/s9&gt;&lt;/c8&gt;値を返します、それは、それが見つけられるならば配列での最初の合致している文字列のインデックスです、または文字列が見つけられることができないならば&lt;c10&gt;&lt;s11&gt;nil&lt;/s11&gt;&lt;/c10&gt;です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c6&gt;&lt;s7&gt;mutating&lt;/s7&gt;&lt;/c6&gt; keyword is added to its definition to enable it to modify its properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;mutating&lt;/s7&gt;&lt;/c6&gt;キーワードがその定義に加えられ、それにそのプロパティを修正するのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c6&gt;&lt;s7&gt;objectWithArea&lt;/s7&gt;&lt;/c6&gt; constant is known to be of type &lt;c8&gt;&lt;s9&gt;HasArea&lt;/s9&gt;&lt;/c8&gt;, and so its &lt;c10&gt;&lt;s11&gt;area&lt;/s11&gt;&lt;/c10&gt; property can be accessed and printed in a type-safe way.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数の&lt;c6&gt;&lt;s7&gt;objectWithArea&lt;/s7&gt;&lt;/c6&gt;は、型&lt;c8&gt;&lt;s9&gt;HasArea&lt;/s9&gt;&lt;/c8&gt;であるということを知られています、なので、その&lt;c10&gt;&lt;s11&gt;area&lt;/s11&gt;&lt;/c10&gt;プロパティは型安全な方法でアクセスされて出力されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c6&gt;&lt;s7&gt;return&lt;/s7&gt;&lt;/c6&gt; statement is described in &lt;a8&gt;&lt;s9&gt;Functions&lt;/s9&gt;&lt;/a8&gt;, and the &lt;c10&gt;&lt;s11&gt;throw&lt;/s11&gt;&lt;/c10&gt; statement is described in &lt;a12&gt;&lt;s13&gt;Propagating Errors Using Throwing Functions&lt;/s13&gt;&lt;/a12&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;return&lt;/s7&gt;&lt;/c6&gt;文は&lt;a8&gt;&lt;s9&gt;関数&lt;/s9&gt;&lt;/a8&gt;において、そして&lt;c10&gt;&lt;s11&gt;throw&lt;/s11&gt;&lt;/c10&gt;文は&lt;a12&gt;&lt;s13&gt;スロー関数を使ってエラーを伝える&lt;/s13&gt;&lt;/a12&gt;において記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c6&gt;&lt;s7&gt;switch&lt;/s7&gt;&lt;/c6&gt; statement is better suited to more complex conditions with multiple possible permutations and is useful in situations where pattern matching can help select an appropriate code branch to execute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;switch&lt;/s7&gt;&lt;/c6&gt;文は、複数の可能な起こりうる組み合わせを伴うさらに複雑な状況によりよく適します、そして、パターンマッチングが適切なコード分岐を選択して実行する助けとなり得る状況において役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c7&gt;&lt;s8&gt;Dictionary&lt;/s8&gt;&lt;/c7&gt; type uses an optional subscript type to model the fact that not every key will have a value, and to give a way to delete a value for a key by assigning a &lt;c9&gt;&lt;s10&gt;nil&lt;/s10&gt;&lt;/c9&gt; value for that key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c7&gt;&lt;s8&gt;Dictionary&lt;/s8&gt;&lt;/c7&gt;型は、すべてのキーに値があるというわけでないという事実をモデル化するために、そしてあるキーに対する値を削除する方法をそのキーに対して&lt;c9&gt;&lt;s10&gt;nil&lt;/s10&gt;&lt;/c9&gt;の値を代入することで提供するために、オプショナルの添え字型を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c8&gt;&lt;s9&gt;*&lt;/s9&gt;&lt;/c8&gt; argument is required and specifies that on any other platform, the body of the code block guarded by the availability condition executes on the minimum deployment target specified by your target.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c8&gt;&lt;s9&gt;*&lt;/s9&gt;&lt;/c8&gt;引数は必須であらゆる他のプラットホーム上を指定します、有効性条件によって保護されたコード・ブロックの本文はあなたのターゲットによって指定される最小の開発ターゲット上で実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c8&gt;&lt;s9&gt;Car&lt;/s9&gt;&lt;/c8&gt; class’s version of &lt;c10&gt;&lt;s11&gt;description&lt;/s11&gt;&lt;/c10&gt; then adds some extra text onto the end of this description to provide information about the current gear.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c8&gt;&lt;s9&gt;Car&lt;/s9&gt;&lt;/c8&gt;クラス版の&lt;c10&gt;&lt;s11&gt;description&lt;/s11&gt;&lt;/c10&gt;は、それからこの説明の最後に現在のギアーについての情報を提供するために追加のテキストを加えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c8&gt;&lt;s9&gt;Food&lt;/s9&gt;&lt;/c8&gt; class does not have a superclass, and so the &lt;c10&gt;&lt;s11&gt;init(name:&lt;/s11&gt; &lt;s12&gt;String)&lt;/s12&gt;&lt;/c10&gt; initializer does not need to call &lt;c13&gt;&lt;s14&gt;super.init()&lt;/s14&gt;&lt;/c13&gt; to complete its initialization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c8&gt;&lt;s9&gt;Food&lt;/s9&gt;&lt;/c8&gt;クラスには、スーパークラスがありません、なので、&lt;c10&gt;&lt;s11&gt;init(name:&lt;/s11&gt; &lt;s12&gt;String)&lt;/s12&gt;&lt;/c10&gt;イニシャライザはその初期化を完了するために&lt;c13&gt;&lt;s14&gt;super.init()&lt;/s14&gt;&lt;/c13&gt;を呼ぶ必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c8&gt;&lt;s9&gt;advance(to:)&lt;/s9&gt;&lt;/c8&gt; method returns a Boolean value to indicate whether or not it was actually able to set &lt;c10&gt;&lt;s11&gt;currentLevel&lt;/s11&gt;&lt;/c10&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c8&gt;&lt;s9&gt;advance(to:)&lt;/s9&gt;&lt;/c8&gt;メソッドは、それが実際に&lt;c10&gt;&lt;s11&gt;currentLevel&lt;/s11&gt;&lt;/c10&gt;を設定することができたかどうか示すためにブールの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c8&gt;&lt;s9&gt;asHTML&lt;/s9&gt;&lt;/c8&gt; property is of type &lt;c10&gt;&lt;s11&gt;()&lt;/s11&gt; &lt;s12&gt;-&gt;&lt;/s12&gt; &lt;s13&gt;String&lt;/s13&gt;&lt;/c10&gt;, or “a function that takes no parameters, and returns a &lt;c14&gt;&lt;s15&gt;String&lt;/s15&gt;&lt;/c14&gt; value”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c8&gt;&lt;s9&gt;asHTML&lt;/s9&gt;&lt;/c8&gt;プロパティは型&lt;c10&gt;&lt;s11&gt;()&lt;/s11&gt; &lt;s12&gt;-&gt;&lt;/s12&gt; &lt;s13&gt;String&lt;/s13&gt;&lt;/c10&gt;です、あるいは「パラメータをとらなくて、&lt;c14&gt;&lt;s15&gt;String&lt;/s15&gt;&lt;/c14&gt;値を返す関数」。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c8&gt;&lt;s9&gt;currentSpeed&lt;/s9&gt;&lt;/c8&gt; property’s value is used by a read-only computed &lt;c10&gt;&lt;s11&gt;String&lt;/s11&gt;&lt;/c10&gt; property called &lt;c12&gt;&lt;s13&gt;description&lt;/s13&gt;&lt;/c12&gt; to create a description of the vehicle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c8&gt;&lt;s9&gt;currentSpeed&lt;/s9&gt;&lt;/c8&gt;プロパティの値は、&lt;c12&gt;&lt;s13&gt;description&lt;/s13&gt;&lt;/c12&gt;と呼ばれる読み込み専用の計算&lt;c10&gt;&lt;s11&gt;String&lt;/s11&gt;&lt;/c10&gt;プロパティによってその乗り物の解説を作成するために使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c8&gt;&lt;s9&gt;fullName&lt;/s9&gt;&lt;/c8&gt; property uses the &lt;c10&gt;&lt;s11&gt;prefix&lt;/s11&gt;&lt;/c10&gt; value if it exists, and prepends it to the beginning of &lt;c12&gt;&lt;s13&gt;name&lt;/s13&gt;&lt;/c12&gt; to create a full name for the starship.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c8&gt;&lt;s9&gt;fullName&lt;/s9&gt;&lt;/c8&gt;プロパティは、&lt;c10&gt;&lt;s11&gt;prefix&lt;/s11&gt;&lt;/c10&gt;値を、それが存在するならば使います、そしてそれを&lt;c12&gt;&lt;s13&gt;name&lt;/s13&gt;&lt;/c12&gt;の始めに付けて、その宇宙船の完全な名前をつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c8&gt;&lt;s9&gt;is&lt;/s9&gt;&lt;/c8&gt; and &lt;c10&gt;&lt;s11&gt;as&lt;/s11&gt;&lt;/c10&gt; patterns have the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c8&gt;&lt;s9&gt;is&lt;/s9&gt;&lt;/c8&gt;と&lt;c10&gt;&lt;s11&gt;as&lt;/s11&gt;&lt;/c10&gt;パターンは以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c8&gt;&lt;s9&gt;numberOfWheels&lt;/s9&gt;&lt;/c8&gt; property is used by a computed property called &lt;c10&gt;&lt;s11&gt;description&lt;/s11&gt;&lt;/c10&gt; to create a &lt;c12&gt;&lt;s13&gt;String&lt;/s13&gt;&lt;/c12&gt; description of the vehicle’s characteristics:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c8&gt;&lt;s9&gt;numberOfWheels&lt;/s9&gt;&lt;/c8&gt;プロパティは&lt;c10&gt;&lt;s11&gt;description&lt;/s11&gt;&lt;/c10&gt;と呼ばれる計算プロパティによって使用されて、この乗り物の特徴のある&lt;c12&gt;&lt;s13&gt;String&lt;/s13&gt;&lt;/c12&gt;の解説を作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;c8&gt;&lt;s9&gt;shareHealth(with:)&lt;/s9&gt;&lt;/c8&gt; method below takes another &lt;c10&gt;&lt;s11&gt;Player&lt;/s11&gt;&lt;/c10&gt; instance as an in-out parameter, creating the possibility of overlapping accesses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の&lt;c8&gt;&lt;s9&gt;shareHealth(with:)&lt;/s9&gt;&lt;/c8&gt;メソッドは、別の&lt;c10&gt;&lt;s11&gt;Player&lt;/s11&gt;&lt;/c10&gt;インスタンスをin-outパラメータとして取り、オーバーラップアクセスの可能性を作り出しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;Snakes and Ladders&lt;/e0&gt; game board setup takes place within the class’s &lt;c1&gt;&lt;s2&gt;init()&lt;/s2&gt;&lt;/c1&gt; initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;ヘビとはしご&lt;/e0&gt;ゲーム盤設定は、このクラスの&lt;c1&gt;&lt;s2&gt;init()&lt;/s2&gt;&lt;/c1&gt;イニシャライザ内で行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;assignment operator&lt;/e0&gt; (&lt;c1&gt;&lt;s2&gt;a&lt;/s2&gt; &lt;s3&gt;=&lt;/s3&gt; &lt;s4&gt;b&lt;/s4&gt;&lt;/c1&gt;) initializes or updates the value of &lt;c5&gt;&lt;s6&gt;a&lt;/s6&gt;&lt;/c5&gt; with the value of &lt;c7&gt;&lt;s8&gt;b&lt;/s8&gt;&lt;/c7&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;代入演算子&lt;/e0&gt;（&lt;c1&gt;&lt;s2&gt;a&lt;/s2&gt; &lt;s3&gt;=&lt;/s3&gt; &lt;s4&gt;b&lt;/s4&gt;&lt;/c1&gt;)）は、&lt;c5&gt;&lt;s6&gt;a&lt;/s6&gt;&lt;/c5&gt;の値を&lt;c7&gt;&lt;s8&gt;b&lt;/s8&gt;&lt;/c7&gt;の値で初期化または更新します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;assignment operator&lt;/e0&gt; sets a new value for a given expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;代入演算子&lt;/e0&gt;は、指定された式に対してある新しい値を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;assignment&lt;/e0&gt; of a precedence group specifies the precedence of an operator when used in an operation that includes optional chaining.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>優先順位グループの&lt;e0&gt;assignment&lt;/e0&gt;は、オプショナル連鎖を含む演算において使われる時ある演算子の優先順位を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;associativity&lt;/e0&gt; of an operator specifies how a sequence of operators with the same precedence level are grouped together in the absence of grouping parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子の&lt;e0&gt;結合性&lt;/e0&gt;は、グループ括弧がない場合に同じ優先順位レベルを持つひと連なりの演算子がどのようにまとめられるかを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;bitwise AND operator&lt;/e0&gt; (&lt;c1&gt;&lt;s2&gt;&amp;&lt;/s2&gt;&lt;/c1&gt;) combines the bits of two numbers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;ビット単位の論理積演算子&lt;/e0&gt;（&lt;c1&gt;&lt;s2&gt;&amp;&lt;/s2&gt;&lt;/c1&gt;）は、２つの数のビットを結合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;bitwise NOT operator&lt;/e0&gt; (&lt;c1&gt;&lt;s2&gt;~&lt;/s2&gt;&lt;/c1&gt;) inverts all bits in a number:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;ビット単位の論理否定演算子&lt;/e0&gt;（&lt;c1&gt;&lt;s2&gt;~&lt;/s2&gt;&lt;/c1&gt;）は、ある数の中の全てのビットを逆にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;bitwise OR operator&lt;/e0&gt; (&lt;c1&gt;&lt;s2&gt;|&lt;/s2&gt;&lt;/c1&gt;) compares the bits of two numbers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;ビット単位&lt;/e0&gt;の論理和演算子（&lt;c1&gt;&lt;s2&gt;|&lt;/s2&gt;&lt;/c1&gt;）は、２つの数のビットを比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;bitwise XOR operator&lt;/e0&gt;, or “exclusive OR operator” (&lt;c1&gt;&lt;s2&gt;^&lt;/s2&gt;&lt;/c1&gt;), compares the bits of two numbers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;ビット単位の排他的論理和（XOR）演算子&lt;/e0&gt;、あるいは「排他的論理和演算子」（&lt;c1&gt;&lt;s2&gt;^&lt;/s2&gt;&lt;/c1&gt;）は、２つの数のビットを比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;bitwise left shift operator&lt;/e0&gt; (&lt;c1&gt;&lt;s2&gt;&lt;&lt;&lt;/s2&gt;&lt;/c1&gt;) and &lt;e3&gt;bitwise right shift operator&lt;/e3&gt; (&lt;c4&gt;&lt;s5&gt;&gt;&gt;&lt;/s5&gt;&lt;/c4&gt;) move all bits in a number to the left or the right by a certain number of places, according to the rules defined below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;ビット単位の左シフト演算子&lt;/e0&gt;（&lt;c1&gt;&lt;s2&gt;&lt;&lt;&lt;/s2&gt;&lt;/c1&gt;）と&lt;e3&gt;ビット単位の右シフト演算子&lt;/e3&gt;（&lt;c4&gt;&lt;s5&gt;&gt;&gt;&lt;/s5&gt;&lt;/c4&gt;）は、下で定義される規則に従ってある数の中の全てのビットを左または右に特定の桁数だけ移動します（シフト：移す、ずらす）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;closed range operator&lt;/e0&gt; (&lt;c1&gt;&lt;s2&gt;a...b&lt;/s2&gt;&lt;/c1&gt;) defines a range that runs from &lt;c3&gt;&lt;s4&gt;a&lt;/s4&gt;&lt;/c3&gt; to &lt;c5&gt;&lt;s6&gt;b&lt;/s6&gt;&lt;/c5&gt;, and includes the values &lt;c7&gt;&lt;s8&gt;a&lt;/s8&gt;&lt;/c7&gt; and &lt;c9&gt;&lt;s10&gt;b&lt;/s10&gt;&lt;/c9&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;完結範囲演算子&lt;/e0&gt;（&lt;c1&gt;&lt;s2&gt;a...b&lt;/s2&gt;&lt;/c1&gt;）は、&lt;c3&gt;&lt;s4&gt;a&lt;/s4&gt;&lt;/c3&gt;から&lt;c5&gt;&lt;s6&gt;b&lt;/s6&gt;&lt;/c5&gt;まで続く範囲を定義します、それは&lt;c7&gt;&lt;s8&gt;a&lt;/s8&gt;&lt;/c7&gt;と&lt;c9&gt;&lt;s10&gt;b&lt;/s10&gt;&lt;/c9&gt;の値を含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;compilation condition&lt;/e0&gt; can include the &lt;c1&gt;&lt;s2&gt;true&lt;/s2&gt;&lt;/c1&gt; and &lt;c3&gt;&lt;s4&gt;false&lt;/s4&gt;&lt;/c3&gt; Boolean literals, an identifier used with the &lt;c5&gt;&lt;s6&gt;-D&lt;/s6&gt;&lt;/c5&gt; command line flag, or any of the platform conditions listed in the table below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;compilation condition&lt;/e0&gt;は、&lt;c1&gt;&lt;s2&gt;true&lt;/s2&gt;&lt;/c1&gt;と&lt;c3&gt;&lt;s4&gt;false&lt;/s4&gt;&lt;/c3&gt;のブールのリテラル、&lt;c5&gt;&lt;s6&gt;-D&lt;/s6&gt;&lt;/c5&gt;コマンドラインフラグと共に使われる識別子、もしくは以下の表で列記されるプラットホーム条件を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;condition&lt;/e0&gt; is evaluated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;条件&lt;/e0&gt;が評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;constraint&lt;/e0&gt; is a class type, protocol type, protocol composition type, or &lt;c1&gt;&lt;s2&gt;Any&lt;/s2&gt;&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;constraint（制約）&lt;/e0&gt;は、クラス型、プロトコル型、プロトコル合成型、または&lt;c1&gt;&lt;s2&gt;Any&lt;/s2&gt;&lt;/c1&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;constraint&lt;/e0&gt; specifies that a type parameter inherits from a specific class or conforms to a protocol or protocol composition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;制約&lt;/e0&gt;は、型パラメータが特定のクラスから継承する、もしくはあるプロトコルまたはプロトコル合成に準拠することを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;control expression&lt;/e0&gt; of the &lt;c1&gt;&lt;s2&gt;switch&lt;/s2&gt;&lt;/c1&gt; statement is evaluated and then compared with the patterns specified in each case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c1&gt;&lt;s2&gt;switch&lt;/s2&gt;&lt;/c1&gt;文の&lt;e0&gt;制御式&lt;/e0&gt;は、評価されて、それからそれぞれのケース節（case）で指定されるパターンと比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;fixity&lt;/e0&gt; of an operator specifies the relative position of an operator to its operands.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子の&lt;e0&gt;定着性&lt;/e0&gt;は、その演算子の演算数に対する相対位置を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;function name&lt;/e0&gt; can be any expression whose value is of a function type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;関数名&lt;/e0&gt;は、値がその関数型であるどんな式でもかまいません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;generic argument list&lt;/e0&gt; is a comma-separated list of type arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;総称体引数リスト&lt;/e0&gt;は、型引数のコンマで区切られたリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;generic parameter list&lt;/e0&gt; is a comma-separated list of generic parameters, each of which has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;総称体パラメータリスト&lt;/e0&gt;は、コンマで区切られた総称体パラメータのリストです、そしてそのそれぞれは以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;half-open range operator&lt;/e0&gt; (&lt;c1&gt;&lt;s2&gt;a..&lt;b&lt;/s2&gt;&lt;/c1&gt;) defines a range that runs from &lt;c3&gt;&lt;s4&gt;a&lt;/s4&gt;&lt;/c3&gt; to &lt;c5&gt;&lt;s6&gt;b&lt;/s6&gt;&lt;/c5&gt;, but doesn’t include &lt;c7&gt;&lt;s8&gt;b&lt;/s8&gt;&lt;/c7&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;半開範囲演算子&lt;/e0&gt;（&lt;c1&gt;&lt;s2&gt;a..&lt;b&lt;/s2&gt;&lt;/c1&gt;）は、&lt;c3&gt;&lt;s4&gt;a&lt;/s4&gt;&lt;/c3&gt;から&lt;c5&gt;&lt;s6&gt;b&lt;/s6&gt;&lt;/c5&gt;まで続く範囲を定義します、しかし&lt;c7&gt;&lt;s8&gt;b&lt;/s8&gt;&lt;/c7&gt;の値を含みません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;lexical structure&lt;/e0&gt; of Swift describes what sequence of characters form valid tokens of the language.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの&lt;e0&gt;語彙の構造&lt;/e0&gt;は、どんな文字の連なりがこの言語の公式のトークン（個々の語、最少単位の語）を作り上げるかについて述べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;logical AND operator&lt;/e0&gt; (&lt;c1&gt;&lt;s2&gt;a&lt;/s2&gt; &lt;s3&gt;&amp;&amp;&lt;/s3&gt; &lt;s4&gt;b&lt;/s4&gt;&lt;/c1&gt;) creates logical expressions where both values must be &lt;c5&gt;&lt;s6&gt;true&lt;/s6&gt;&lt;/c5&gt; for the overall expression to also be &lt;c7&gt;&lt;s8&gt;true&lt;/s8&gt;&lt;/c7&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;論理積演算子&lt;/e0&gt;（&lt;c1&gt;&lt;s2&gt;a&lt;/s2&gt; &lt;s3&gt;&amp;&amp;&lt;/s3&gt; &lt;s4&gt;b&lt;/s4&gt;&lt;/c1&gt;）は、論理式をつくります、そこにおいて全体的な式もまた&lt;c5&gt;&lt;s6&gt;true&lt;/s6&gt;&lt;/c5&gt;になるためには、両方の値が&lt;c7&gt;&lt;s8&gt;true&lt;/s8&gt;&lt;/c7&gt;でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;logical NOT operator&lt;/e0&gt; (&lt;c1&gt;&lt;s2&gt;!a&lt;/s2&gt;&lt;/c1&gt;) inverts a Boolean value so that &lt;c3&gt;&lt;s4&gt;true&lt;/s4&gt;&lt;/c3&gt; becomes &lt;c5&gt;&lt;s6&gt;false&lt;/s6&gt;&lt;/c5&gt;, and &lt;c7&gt;&lt;s8&gt;false&lt;/s8&gt;&lt;/c7&gt; becomes &lt;c9&gt;&lt;s10&gt;true&lt;/s10&gt;&lt;/c9&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;論理否定演算子&lt;/e0&gt;（&lt;c1&gt;&lt;s2&gt;!a&lt;/s2&gt;&lt;/c1&gt;）は１つのブール値を逆にします、それで&lt;c3&gt;&lt;s4&gt;true&lt;/s4&gt;&lt;/c3&gt;は&lt;c5&gt;&lt;s6&gt;false&lt;/s6&gt;&lt;/c5&gt;に、&lt;c7&gt;&lt;s8&gt;false&lt;/s8&gt;&lt;/c7&gt;は&lt;c9&gt;&lt;s10&gt;true&lt;/s10&gt;&lt;/c9&gt;になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;logical OR operator&lt;/e0&gt; (&lt;c1&gt;&lt;s2&gt;a&lt;/s2&gt; &lt;s3&gt;||&lt;/s3&gt; &lt;s4&gt;b&lt;/s4&gt;&lt;/c1&gt;) is an infix operator made from two adjacent pipe characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;論理和演算子&lt;/e0&gt;（&lt;c1&gt;&lt;s2&gt;a&lt;/s2&gt; &lt;s3&gt;||&lt;/s3&gt; &lt;s4&gt;b&lt;/s4&gt;&lt;/c1&gt;）は、２つの隣接したパイプ文字から作られる接中辞演算子です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;lower group names&lt;/e0&gt; and &lt;e1&gt;higher group names&lt;/e1&gt; lists specify the new precedence group’s relation to existing precedence groups.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;下方グループ名&lt;/e0&gt;および&lt;e1&gt;上方グループ名&lt;/e1&gt;リストは、新しい優先順位グループのもつ関係を既存の優先順位グループに対して指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;message&lt;/e0&gt; consists of a string literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;message&lt;/e0&gt;は、文字列リテラルから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;method name&lt;/e0&gt; and &lt;e1&gt;property name&lt;/e1&gt; must be a reference to a method or a property that is available in the Objective-C runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;method name&lt;/e0&gt;と&lt;e1&gt;property name&lt;/e1&gt;は、あるメソッドおよびプロパティへの参照で、それはObjective-Cランタイムにおいて利用可能なものでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;method name&lt;/e0&gt; can contain parentheses for grouping, as well the &lt;c1&gt;&lt;s2&gt;as&lt;/s2&gt;&lt;/c1&gt; operator to disambiguate between methods that share a name but have different type signatures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;method name&lt;/e0&gt;は、グループにまとめるための丸括弧、その上に、名前を共有するが異なる型シグネチャを持つメソッド間の違いを明確にするために&lt;c1&gt;&lt;s2&gt;as&lt;/s2&gt;&lt;/c1&gt;演算子を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;new name&lt;/e0&gt; consists of a string literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;新しい名前&lt;/e0&gt;は文字列リテラルからなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;nil-coalescing operator&lt;/e0&gt; (&lt;c1&gt;&lt;s2&gt;a&lt;/s2&gt; &lt;s3&gt;??&lt;/s3&gt; &lt;s4&gt;b&lt;/s4&gt;&lt;/c1&gt;) unwraps an optional &lt;c5&gt;&lt;s6&gt;a&lt;/s6&gt;&lt;/c5&gt; if it contains a value, or returns a default value &lt;c7&gt;&lt;s8&gt;b&lt;/s8&gt;&lt;/c7&gt; if &lt;c9&gt;&lt;s10&gt;a&lt;/s10&gt;&lt;/c9&gt; is &lt;c11&gt;&lt;s12&gt;nil&lt;/s12&gt;&lt;/c11&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;nil合体演算子&lt;/e0&gt;（&lt;c1&gt;&lt;s2&gt;a&lt;/s2&gt; &lt;s3&gt;??&lt;/s3&gt; &lt;s4&gt;b&lt;/s4&gt;&lt;/c1&gt;）は、それが値を持つならばオプショナルの&lt;c5&gt;&lt;s6&gt;a&lt;/s6&gt;&lt;/c5&gt;をアンラップします、または&lt;c9&gt;&lt;s10&gt;a&lt;/s10&gt;&lt;/c9&gt;が&lt;c11&gt;&lt;s12&gt;nil&lt;/s12&gt;&lt;/c11&gt;ならば省略時の値の&lt;c7&gt;&lt;s8&gt;b&lt;/s8&gt;&lt;/c7&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;parameter type&lt;/e0&gt; is comma-separated list of types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;parameter type&lt;/e0&gt;はコンマ区切りの型のリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;parameters&lt;/e0&gt; have the same form as the parameters in a function declaration, as described in &lt;a1&gt;&lt;s2&gt;Function Declaration&lt;/s2&gt;&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;パラメータ&lt;/e0&gt;は、関数宣言で記述されるように、&lt;a1&gt;&lt;s2&gt;関数宣言でのパラメータ&lt;/s2&gt;&lt;/a1&gt;と同じ形式を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;parameters&lt;/e0&gt; in closure expression syntax can be in-out parameters, but they can’t have a default value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャ式構文中の&lt;e0&gt;parameters&lt;/e0&gt;はin-outパラメータであることができます、しかしそれらは省略時の値を持つことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;parameters&lt;/e0&gt; specify one or more indexes used to access elements of the corresponding type in a subscript expression (for example, the &lt;c1&gt;&lt;s2&gt;i&lt;/s2&gt;&lt;/c1&gt; in the expression &lt;c3&gt;&lt;s4&gt;object[i]&lt;/s4&gt;&lt;/c3&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;パラメータ&lt;/e0&gt;は、対応する型の要素にアクセスするために添え字式において使用する一種類以上のインデックスを指定します（例えば、式&lt;c3&gt;&lt;s4&gt;object[i]&lt;/s4&gt;&lt;/c3&gt;における&lt;c1&gt;&lt;s2&gt;i&lt;/s2&gt;&lt;/c1&gt;など）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;path&lt;/e0&gt; can contain multiple property names, separated by periods, to refer to a property of a property’s value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;path&lt;/e0&gt;は、ピリオドで区切った複数のプロパティ名を含むことで、あるプロパティの持つ値に属するプロパティを参照できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;path&lt;/e0&gt; can include subscripts using brackets, as long as the subscript’s parameter type conforms to the &lt;c1&gt;&lt;s2&gt;Hashable&lt;/s2&gt;&lt;/c1&gt; protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;path&lt;/e0&gt;は角括弧を使う添え字を含むことができます、その添え字の持つパラメータ型が&lt;c1&gt;&lt;s2&gt;Hashable&lt;/s2&gt;&lt;/c1&gt;プロトコルに準拠する限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;path&lt;/e0&gt; can refer to &lt;c1&gt;&lt;s2&gt;self&lt;/s2&gt;&lt;/c1&gt; to create the identity key path (&lt;c3&gt;&lt;s4&gt;\.self&lt;/s4&gt;&lt;/c3&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;path&lt;/e0&gt;は、&lt;c1&gt;&lt;s2&gt;self&lt;/s2&gt;&lt;/c1&gt;を参照することで、同一性キーパス（&lt;c3&gt;&lt;s4&gt;\.self&lt;/s4&gt;&lt;/c3&gt;）を作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;path&lt;/e0&gt; can use optional chaining and forced unwrapping.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;path&lt;/e0&gt;は、オプショナル連鎖と強制アンラップを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;path&lt;/e0&gt; consists of property names, subscripts, optional-chaining expressions, and forced unwrapping expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;path&lt;/e0&gt;は、プロパティ名、添え字、「オプショナル連鎖」式、そして強制アンラップ式からなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;projected value&lt;/e0&gt; for a wrapped property is a second value that a property wrapper can use to expose additional functionality.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるラップされたプロパティに対する&lt;e0&gt;予測値&lt;/e0&gt;は、２番目の値です、それはプロパティラッパーが使用することで追加的機能性を露出できるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;property name&lt;/e0&gt; must be a reference to a property that is available in the Objective-C runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;property name&lt;/e0&gt;は、Objective-Cランタイムにおいて利用可能であるプロパティへの参照でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;remainder operator&lt;/e0&gt; (&lt;c1&gt;&lt;s2&gt;a&lt;/s2&gt; &lt;s3&gt;%&lt;/s3&gt; &lt;s4&gt;b&lt;/s4&gt;&lt;/c1&gt;) works out how many multiples of &lt;c5&gt;&lt;s6&gt;b&lt;/s6&gt;&lt;/c5&gt; will fit inside &lt;c7&gt;&lt;s8&gt;a&lt;/s8&gt;&lt;/c7&gt; and returns the value that is left over (known as the &lt;e9&gt;remainder&lt;/e9&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;剰余演算子&lt;/e0&gt;（&lt;c1&gt;&lt;s2&gt;a&lt;/s2&gt; &lt;s3&gt;%&lt;/s3&gt; &lt;s4&gt;b&lt;/s4&gt;&lt;/c1&gt;）は、どのくらい多くの&lt;c5&gt;&lt;s6&gt;b&lt;/s6&gt;&lt;/c5&gt;の倍数が&lt;c7&gt;&lt;s8&gt;a&lt;/s8&gt;&lt;/c7&gt;の内部に収まるかを計算して、残された値（&lt;e9&gt;余り&lt;/e9&gt;として知られるもの）を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;requirements&lt;/e0&gt; in a generic &lt;c1&gt;&lt;s2&gt;where&lt;/s2&gt;&lt;/c1&gt; clause specify that a type parameter inherits from a class or conforms to a protocol or protocol composition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体&lt;c1&gt;&lt;s2&gt;where&lt;/s2&gt;&lt;/c1&gt;節の中の&lt;e0&gt;要件&lt;/e0&gt;が指定するのは、型パラメータがクラスから継承するかまたはプロトコルやプロトコル合成に準拠するということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;setter name&lt;/e0&gt; and enclosing parentheses are optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;セッター名&lt;/e0&gt;と囲んでいる括弧は、任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;setter name&lt;/e0&gt; and enclosing parentheses in the &lt;c1&gt;&lt;s2&gt;willSet&lt;/s2&gt;&lt;/c1&gt; and &lt;c3&gt;&lt;s4&gt;didSet&lt;/s4&gt;&lt;/c3&gt; clauses are optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c1&gt;&lt;s2&gt;willSet&lt;/s2&gt;&lt;/c1&gt;と&lt;c3&gt;&lt;s4&gt;didSet&lt;/s4&gt;&lt;/c3&gt;節の中の&lt;e0&gt;セッター名&lt;/e0&gt;と囲んでいる丸括弧は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;setter name&lt;/e0&gt; and enclosing parentheses is optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;セッター名&lt;/e0&gt;、そして囲んでいる丸括弧は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;statements&lt;/e0&gt; inside a code block include declarations, expressions, and other kinds of statements and are executed in order of their appearance in source code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コード・ブロックの内側の&lt;e0&gt;文&lt;/e0&gt;は、宣言、式、そして他の種類の文を含みます、そしてソース・コードにおいてそれらの現れる順に実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;ternary conditional operator&lt;/e0&gt; evaluates to one of two given values based on the value of a condition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;三項条件演算子&lt;/e0&gt;は、ある条件の値に基づいて、２つの与えられた値のうちの１つへと評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;ternary conditional operator&lt;/e0&gt; is a special operator with three parts, which takes the form &lt;c1&gt;&lt;s2&gt;question&lt;/s2&gt; &lt;s3&gt;?&lt;/s3&gt; &lt;s4&gt;answer1&lt;/s4&gt; &lt;s5&gt;:&lt;/s5&gt; &lt;s6&gt;answer2&lt;/s6&gt;&lt;/c1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;三項条件演算子&lt;/e0&gt;は３つの部分をもつ特別な演算子です、それは形式&lt;c1&gt;&lt;s2&gt;question&lt;/s2&gt; &lt;s3&gt;?&lt;/s3&gt; &lt;s4&gt;answer1&lt;/s4&gt; &lt;s5&gt;:&lt;/s5&gt; &lt;s6&gt;answer2&lt;/s6&gt;&lt;/c1&gt;をとります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;type name&lt;/e0&gt; can be omitted in contexts where type inference can determine the implied type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;type name&lt;/e0&gt;は、型推論が暗黙の型を判定できるところの文脈では省略できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;type name&lt;/e0&gt; is the name of a concrete type, including any generic parameters, such as &lt;c1&gt;&lt;s2&gt;String&lt;/s2&gt;&lt;/c1&gt;, &lt;c3&gt;&lt;s4&gt;[Int]&lt;/s4&gt;&lt;/c3&gt;, or &lt;c5&gt;&lt;s6&gt;Set&lt;Int&gt;&lt;/s6&gt;&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;type name&lt;/e0&gt;は、ある具象型の名前で、何らかの総称体パラメータを含みます、例えば&lt;c1&gt;&lt;s2&gt;String&lt;/s2&gt;&lt;/c1&gt;、&lt;c3&gt;&lt;s4&gt;[Int]&lt;/s4&gt;&lt;/c3&gt;、または&lt;c5&gt;&lt;s6&gt;Set&lt;Int&gt;&lt;/s6&gt;&lt;/c5&gt;など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;unary plus operator&lt;/e0&gt; (&lt;c1&gt;&lt;s2&gt;+&lt;/s2&gt;&lt;/c1&gt;) simply returns the value it operates on, without any change:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;単項プラス演算子&lt;/e0&gt;（&lt;c1&gt;&lt;s2&gt;+&lt;/s2&gt;&lt;/c1&gt;）は、それが作用する値を、どんな変更もせずに、ただ単純に返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e0&gt;version number&lt;/e0&gt; consists of one to three positive integers, separated by periods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;バージョン番号&lt;/e0&gt;は、ビリオドで区切られた、１つから３つの正の整数から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e1&gt;superclass&lt;/e1&gt; appears first after the &lt;e2&gt;class name&lt;/e2&gt; and colon, followed by any &lt;e3&gt;adopted protocols&lt;/e3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e1&gt;スーパークラス&lt;/e1&gt;がまず&lt;e2&gt;クラス名&lt;/e2&gt;とコロンの後に現れ、続いて随意の&lt;e3&gt;準拠するプロトコル&lt;/e3&gt;が続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e1&gt;type&lt;/e1&gt; annotation is optional when the type can be inferred from the initializer &lt;e2&gt;expression&lt;/e2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e1&gt;型&lt;/e1&gt;注釈は、その型が初期化&lt;e2&gt;式&lt;/e2&gt;から推論されることができる場合は随意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e2&gt;existing type&lt;/e2&gt; can be a named type or a compound type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e2&gt;既存の型&lt;/e2&gt;は、名前付きの型または複合の型でありえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e2&gt;protocol member declarations&lt;/e2&gt; are discussed in detail below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e2&gt;プロトコルメンバー宣言&lt;/e2&gt;は、詳細に下で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e2&gt;wrapped value&lt;/e2&gt; of the property is the value that the getter and setter for this property expose.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのプロパティの&lt;e2&gt;ラップされた値&lt;/e2&gt;は、このプロパティに対するゲッターとセッターが露出する値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e4&gt;line number&lt;/e4&gt; changes the value of &lt;c5&gt;&lt;s6&gt;#line&lt;/s6&gt;&lt;/c5&gt; and is any integer literal greater than zero.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e4&gt;line number（行番号）&lt;/e4&gt;は、&lt;c5&gt;&lt;s6&gt;#line&lt;/s6&gt;&lt;/c5&gt;の値を変更します、そして0より大きい何らかの整数リテラルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e5&gt;return type&lt;/e5&gt; specifies the type of the element being accessed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e5&gt;戻り型&lt;/e5&gt;は、アクセスされている要素の型を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;e7&gt;filename&lt;/e7&gt; changes the value of &lt;c8&gt;&lt;s9&gt;#file&lt;/s9&gt;&lt;/c8&gt; and is a string literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e7&gt;filename（ファイル名）&lt;/e7&gt;は、&lt;c8&gt;&lt;s9&gt;#file&lt;/s9&gt;&lt;/c8&gt;の値を変更します、そしてひとつの文字列リテラルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Basics</seg>
      </tuv>
      <tuv lang="JA">
        <seg>基本</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The CSS color value &lt;c4&gt;&lt;s5&gt;#CC6699&lt;/s5&gt;&lt;/c4&gt; is written as &lt;c6&gt;&lt;s7&gt;0xCC6699&lt;/s7&gt;&lt;/c6&gt; in Swift’s hexadecimal number representation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>CSS色値&lt;c4&gt;&lt;s5&gt;#CC6699&lt;/s5&gt;&lt;/c4&gt;は、スウィフトの16進数表現では&lt;c6&gt;&lt;s7&gt;0xCC6699&lt;/s7&gt;&lt;/c6&gt;のように書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DSO (dynamic shared object) handle in use where it appears.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>DSO（動的共有オブジェクト）は、使用されている場所で取り扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Problem That Generics Solve</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体が解決する問題</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Problem That Opaque Types Solve</seg>
      </tuv>
      <tuv lang="JA">
        <seg>不透明型が解決する問題</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Sorted Method</seg>
      </tuv>
      <tuv lang="JA">
        <seg>分類メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Swift language defines the postfix &lt;c0&gt;&lt;s1&gt;!&lt;/s1&gt;&lt;/c0&gt; as syntactic sugar for the named type &lt;c2&gt;&lt;s3&gt;Optional&lt;Wrapped&gt;&lt;/s3&gt;&lt;/c2&gt;, which is defined in the Swift standard library, with the additional behavior that it’s automatically unwrapped when it’s accessed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト言語は、接尾辞&lt;c0&gt;&lt;s1&gt;!&lt;/s1&gt;&lt;/c0&gt;を糖衣構文としてスウィフト標準ライブラリで定義される名前付きの型&lt;c2&gt;&lt;s3&gt;Optional&lt;Wrapped&gt;&lt;/s3&gt;&lt;/c2&gt;に対して定義します、それはそれがアクセスされるとき自動的にアンラップされるという追加の挙動を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Swift language defines the postfix &lt;c0&gt;&lt;s1&gt;?&lt;/s1&gt;&lt;/c0&gt; as syntactic sugar for the named type &lt;c2&gt;&lt;s3&gt;Optional&lt;Wrapped&gt;&lt;/s3&gt;&lt;/c2&gt;, which is defined in the Swift standard library.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト言語は、接尾辞&lt;c0&gt;&lt;s1&gt;?&lt;/s1&gt;&lt;/c0&gt;を糖衣構文として名前付きの型&lt;c2&gt;&lt;s3&gt;Optional&lt;Wrapped&gt;&lt;/s3&gt;&lt;/c2&gt;に対して定義します、それは、スウィフト標準ライブラリで定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Swift language is relatively small, because many common types, functions, and operators that appear virtually everywhere in Swift code are actually defined in the Swift standard library.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト言語は比較的小さいです、スウィフトのコードのほとんど至る所で見かける多くの通常の型、関数、そして演算子がスウィフト標準ライブラリで実際には定義されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Swift language provides the following syntactic sugar for the Swift standard library &lt;c0&gt;&lt;s1&gt;Array&lt;Element&gt;&lt;/s1&gt;&lt;/c0&gt; type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト言語は、スウィフト標準ライブラリの&lt;c0&gt;&lt;s1&gt;Array&lt;Element&gt;&lt;/s1&gt;&lt;/c0&gt;型のために以下の糖衣構文を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Swift language provides the following syntactic sugar for the Swift standard library &lt;c0&gt;&lt;s1&gt;Dictionary&lt;Key,&lt;/s1&gt; &lt;s2&gt;Value&gt;&lt;/s2&gt;&lt;/c0&gt; type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト言語は、以下の糖衣構文をスウィフト標準ライブラリ&lt;c0&gt;&lt;s1&gt;Dictionary&lt;Key,&lt;/s1&gt; &lt;s2&gt;Value&gt;&lt;/s2&gt;&lt;/c0&gt;型に提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Swift logical operators &lt;c0&gt;&lt;s1&gt;&amp;&amp;&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;||&lt;/s3&gt;&lt;/c2&gt; are left-associative, meaning that compound expressions with multiple logical operators evaluate the leftmost subexpression first.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの論理演算子&lt;c0&gt;&lt;s1&gt;&amp;&amp;&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;||&lt;/s3&gt;&lt;/c2&gt;は、左結合です、複数の論理演算子を持つ複合式が最も左の下位の式を最初に評価することを意味しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Swift standard library also defines a &lt;c2&gt;&lt;s3&gt;Float&lt;/s3&gt;&lt;/c2&gt; type, which represents a 32-bit floating-point number.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト標準ライブラリはまた&lt;c2&gt;&lt;s3&gt;Float&lt;/s3&gt;&lt;/c2&gt;型も定義します、それは、32ビットの浮動小数点数を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Swift standard library also defines types for various sizes of signed and unsigned integers, as described in &lt;a2&gt;&lt;s3&gt;Integers&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a2&gt;&lt;s3&gt;整数&lt;/s3&gt;&lt;/a2&gt;で記述されるように、スウィフト標準ライブラリはまた、さまざまな大きさの符号つきおよび符号なし整数のために、いろいろな型を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Swift standard library defines a number of operators for your use, many of which are discussed in &lt;a0&gt;&lt;s1&gt;Basic Operators&lt;/s1&gt;&lt;/a0&gt; and &lt;a2&gt;&lt;s3&gt;Advanced Operators&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト標準ライブラリは、いくつかの演算子をあなたが使うために定義します、その多くは&lt;a0&gt;&lt;s1&gt;基本の演算子&lt;/s1&gt;&lt;/a0&gt;と&lt;a2&gt;&lt;s3&gt;先進の演算子&lt;/s3&gt;&lt;/a2&gt;で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Swift standard library defines a protocol called &lt;c0&gt;&lt;s1&gt;Equatable&lt;/s1&gt;&lt;/c0&gt;, which requires any conforming type to implement the equal to operator (&lt;c2&gt;&lt;s3&gt;==&lt;/s3&gt;&lt;/c2&gt;) and the not equal to operator (&lt;c4&gt;&lt;s5&gt;!=&lt;/s5&gt;&lt;/c4&gt;) to compare any two values of that type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト標準ライブラリは、&lt;c0&gt;&lt;s1&gt;Equatable&lt;/s1&gt;&lt;/c0&gt;と呼ばれるプロトコルを定義します、それは、それに準拠している全ての型に対してその型のあらゆる２つの値を比較するために同等演算子（&lt;c2&gt;&lt;s3&gt;==&lt;/s3&gt;&lt;/c2&gt;）と不等演算子（&lt;c4&gt;&lt;s5&gt;!=&lt;/s5&gt;&lt;/c4&gt;）を実装することを要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Swift standard library includes tuple comparison operators for tuples with fewer than seven elements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト標準ライブラリは、いくらかのタプル比較演算子を、７要素より少数でのタプルに対して含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The above example uses a &lt;c0&gt;&lt;s1&gt;defer&lt;/s1&gt;&lt;/c0&gt; statement to ensure that the &lt;c2&gt;&lt;s3&gt;open(_:)&lt;/s3&gt;&lt;/c2&gt; function has a corresponding call to &lt;c4&gt;&lt;s5&gt;close(_:)&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、&lt;c0&gt;&lt;s1&gt;defer&lt;/s1&gt;&lt;/c0&gt;文を使って、&lt;c2&gt;&lt;s3&gt;open(_:)&lt;/s3&gt;&lt;/c2&gt;関数がそれと対応する&lt;c4&gt;&lt;s5&gt;close(_:)&lt;/s5&gt;&lt;/c4&gt;への呼び出しを持つことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The access control level of a type also affects the default access level of that type’s &lt;e0&gt;members&lt;/e0&gt; (its properties, methods, initializers, and subscripts).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型のアクセス制御水準はまた、その型の&lt;e0&gt;メンバー&lt;/e0&gt;（それのプロパティ、メソッド、イニシャライザ、そして添え字）の省略時のアクセス水準に影響を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The access level for a function type is calculated as the most restrictive access level of the function’s parameter types and return type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数型のためのアクセス水準は、その関数のパラメータ型と戻り型での最も制限の多いアクセス水準と同じに算出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The access level for a generic type or generic function is the minimum of the access level of the generic type or function itself and the access level of any type constraints on its type parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体型または総称体関数のためのアクセス水準は、総称体型または関数自身のアクセス水準およびその型パラメータ上のあらゆる型制約のアクセス水準の最少のものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The access level for a tuple type is the most restrictive access level of all types used in that tuple.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプル型のためのアクセス水準は、そのタプルで使われる全ての型での最も制限的なアクセス水準です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The access level of a nested type is the same as its containing type, unless the containing type is public.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>入れ子にされた型のアクセス水準は、それの容れ物である型と同じです、容れ物である型が公開である場合を除いて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The access level of each requirement within a protocol definition is automatically set to the same access level as the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル定義内の各要件のアクセス水準は、自動的にプロトコルと同じアクセス水準に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The actual type to use for that associated type isn’t specified until the protocol is adopted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その関連型のために使われる実際の型は、プロトコルが採用されるまでは指定されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The actual type to use in place of &lt;c21&gt;&lt;s22&gt;T&lt;/s22&gt;&lt;/c21&gt; is determined each time the &lt;c23&gt;&lt;s24&gt;swapTwoValues(_:_:)&lt;/s24&gt;&lt;/c23&gt; function is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c21&gt;&lt;s22&gt;T&lt;/s22&gt;&lt;/c21&gt;の代わりに実際に使われる型は、&lt;c23&gt;&lt;s24&gt;swapTwoValues(_:_:)&lt;/s24&gt;&lt;/c23&gt;関数が呼ばれるたびに決定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The addition operator is also supported for &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; concatenation:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>加算演算子は、また、&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;連結に対してもサポートされます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The additional capabilities that classes support come at the cost of increased complexity.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスがサポートする追加の能力は、複雑さの増加という犠牲を伴います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The appropriate choice of weak or unowned depends on the relationships between the different parts of your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>弱いまたは非所有の適切な選択は、あなたのコードの異なる部分間の関係に依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The appropriate floating-point type to use depends on the nature and range of values you need to work with in your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>使うのに適切な浮動小数点型は、あなたのコードにおいて扱わなければならない値の種別と幅に依ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The appropriate form to use depends on the scope at which the variable is declared and the kind of variable you intend to declare.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>使用するのに適切な形式は、その変数が宣言されるスコープとあなたが宣言するつもりである変数の種類に依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The argument for the &lt;c0&gt;&lt;s1&gt;canImport()&lt;/s1&gt;&lt;/c0&gt; platform condition is the name of a module that may not be present on all platforms.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;canImport()&lt;/s1&gt;&lt;/c0&gt;プラットホーム条件に対する引数は、全てのプラットホームには含まれないかもしれないあるモジュールの名前です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The argument is automatically converted to a closure, because the &lt;c8&gt;&lt;s9&gt;customerProvider&lt;/s9&gt;&lt;/c8&gt; parameter’s type is marked with the &lt;c10&gt;&lt;s11&gt;@autoclosure&lt;/s11&gt;&lt;/c10&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>引数は、自動的にクロージャに変換されます、なぜなら&lt;c8&gt;&lt;s9&gt;customerProvider&lt;/s9&gt;&lt;/c8&gt;パラメータの型は&lt;c10&gt;&lt;s11&gt;@autoclosure&lt;/s11&gt;&lt;/c10&gt;属性で印されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The argument label is used when calling the function; each argument is written in the function call with its argument label before it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>引数ラベルは、関数を呼び出すときに使われます；各引数は、関数呼び出しにおいてそれの前のそれの引数ラベルとともに書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The argument to the &lt;c0&gt;&lt;s1&gt;objc&lt;/s1&gt;&lt;/c0&gt; attribute can also change the runtime name for that declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;objc&lt;/s1&gt;&lt;/c0&gt;属性に対する引数はまた、その宣言に対するランタイム名を変更できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The argument value passed to this parameter specifies how much &lt;c8&gt;&lt;s9&gt;runningTotal&lt;/s9&gt;&lt;/c8&gt; should be incremented by each time the returned incrementer function is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このパラメータに渡された引き数の値は、返されたインクリメンタ関数（漸増器関数）が呼ばれるたびに、どのくらい&lt;c8&gt;&lt;s9&gt;runningTotal&lt;/s9&gt;&lt;/c8&gt;が増やされなければならないかについて指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The arguments to the initializer are passed like a function call when you create an instance of the class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザに対する引数は、あなたがクラスのインスタンスをつくるときに関数呼び出しのように渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The arithmetic addition operator is a &lt;e2&gt;binary operator&lt;/e2&gt; because it operates on two targets and is said to be &lt;e3&gt;infix&lt;/e3&gt; because it appears in between those two targets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>算術加算演算子は、それが２つの目標に作用するので&lt;e2&gt;二項演算子&lt;/e2&gt;です、そして、それがそれらの２つの目標の間に現れるので&lt;e3&gt;接中辞&lt;/e3&gt;と言われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The array &lt;c6&gt;&lt;s7&gt;[16,&lt;/s7&gt; &lt;s8&gt;58,&lt;/s8&gt; &lt;s9&gt;510]&lt;/s9&gt;&lt;/c6&gt; is used to create the new array &lt;c10&gt;&lt;s11&gt;["OneSix",&lt;/s11&gt; &lt;s12&gt;"FiveEight",&lt;/s12&gt; &lt;s13&gt;"FiveOneZero"]&lt;/s13&gt;&lt;/c10&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列&lt;c6&gt;&lt;s7&gt;[16,&lt;/s7&gt; &lt;s8&gt;58,&lt;/s8&gt; &lt;s9&gt;510]&lt;/s9&gt;&lt;/c6&gt;は、新しい配列&lt;c10&gt;&lt;s11&gt;["OneSix",&lt;/s11&gt; &lt;s12&gt;"FiveEight",&lt;/s12&gt; &lt;s13&gt;"FiveOneZero"]&lt;/s13&gt;&lt;/c10&gt;をつくるために使われます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The array is declared outside the scope of the function, which means the closures in the array can be executed after the function returns.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この配列は関数のスコープの外側で宣言されます、それは配列の中のクロージャが関数が戻った後で実行されることができるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The assignment is part of the optional chaining, which means none of the code on the right-hand side of the &lt;c0&gt;&lt;s1&gt;=&lt;/s1&gt;&lt;/c0&gt; operator is evaluated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この代入はオプショナル連鎖の一部です、それが意味するのは、&lt;c0&gt;&lt;s1&gt;=&lt;/s1&gt;&lt;/c0&gt;演算子の右手側で評価されるコードは何もないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The assignment operator (&lt;c0&gt;&lt;s1&gt;=&lt;/s1&gt;&lt;/c0&gt;) doesn’t return a value, to prevent it from being mistakenly used when the equal to operator (&lt;c2&gt;&lt;s3&gt;==&lt;/s3&gt;&lt;/c2&gt;) is intended.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代入演算子（&lt;c0&gt;&lt;s1&gt;=&lt;/s1&gt;&lt;/c0&gt;）は値を返しません、同等演算子（&lt;c2&gt;&lt;s3&gt;==&lt;/s3&gt;&lt;/c2&gt;）が意図される時にそれが誤って使われるのを防ぐためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The assignment operator does not return any value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代入演算子は、少しの値も返しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The audio channels described above are represented by instances of the &lt;c0&gt;&lt;s1&gt;AudioChannel&lt;/s1&gt;&lt;/c0&gt; structure:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上で記述される音声のチャンネルは、&lt;c0&gt;&lt;s1&gt;AudioChannel&lt;/s1&gt;&lt;/c0&gt;構造体のインスタンスによって表されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The author of a property wrapper type is responsible for determining the meaning of its projected value and defining the interface that the projected value exposes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティラッパー型の作者は、その予測値の意味の決定にそして予測値を露出するインターフェイスの定義に責任があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The availability condition above specifies that in iOS, the body of the &lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt; statement executes only in iOS 10 and later; in macOS, only in macOS 10.12 and later.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の有効性条件が指定するのは、iOS上では、&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt;の本文はiOS 10以降でのみ；macOS上では、macOS 10.12以降でのみ実行することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The availability condition takes a comma-separated list of platform names and versions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>有効性条件は、プラットホーム名とバージョンのコンマ区切りのリストを取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The backticks aren’t considered part of the identifier; &lt;c6&gt;&lt;s7&gt;`x`&lt;/s7&gt;&lt;/c6&gt; and &lt;c8&gt;&lt;s9&gt;x&lt;/s9&gt;&lt;/c8&gt; have the same meaning.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>バッククォートは、識別子の一部とみなされません；&lt;c6&gt;&lt;s7&gt;`x`&lt;/s7&gt;&lt;/c6&gt;と&lt;c8&gt;&lt;s9&gt;x&lt;/s9&gt;&lt;/c8&gt;は、同じ意味を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The barcode example in &lt;a0&gt;&lt;s1&gt;Associated Values&lt;/s1&gt;&lt;/a0&gt; shows how cases of an enumeration can declare that they store associated values of different types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;関連値&lt;/s1&gt;&lt;/a0&gt;におけるバーコード例は、それらが異なる型の関連値を格納することを、ある列挙のケース節たちがどのように宣言可能かを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The base class in the hierarchy is called &lt;c0&gt;&lt;s1&gt;Food&lt;/s1&gt;&lt;/c0&gt;, which is a simple class to encapsulate the name of a foodstuff.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この階層構造における基盤クラスは&lt;c0&gt;&lt;s1&gt;Food&lt;/s1&gt;&lt;/c0&gt;と呼ばれています、それは、食品の名前をカプセル化する単純なクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The basic characteristic of an ASCII art shape is a &lt;c0&gt;&lt;s1&gt;draw()&lt;/s1&gt;&lt;/c0&gt; function that returns the string representation of that shape, which you can use as the requirement for the &lt;c2&gt;&lt;s3&gt;Shape&lt;/s3&gt;&lt;/c2&gt; protocol:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるASCIIアート形状の基本的な特徴は、その形状の文字列表現を返す&lt;c0&gt;&lt;s1&gt;draw()&lt;/s1&gt;&lt;/c0&gt;関数です、それはあなたが要件として&lt;c2&gt;&lt;s3&gt;Shape&lt;/s3&gt;&lt;/c2&gt;プロトコルに対して使用できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The basic form imports the entire module; it consists of the &lt;c1&gt;&lt;s2&gt;import&lt;/s2&gt;&lt;/c1&gt; keyword followed by a module name:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>基本の形式は、そのモジュール全体をインポートします；それは、&lt;c1&gt;&lt;s2&gt;import&lt;/s2&gt;&lt;/c1&gt;キーワードとそれに続くモジュール名から成ります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The basic syntax for type constraints on a generic function is shown below (although the syntax is the same for generic types):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体関数に関する型制約のための基本の構文は、下で示されます（とはいえ構文は総称体型と同じものです）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The behavior of &lt;c7&gt;&lt;s8&gt;x&lt;/s8&gt; &lt;s9&gt;as!&lt;/s9&gt; &lt;s10&gt;T&lt;/s10&gt;&lt;/c7&gt; is the same as the behavior of &lt;c11&gt;&lt;s12&gt;(x&lt;/s12&gt; &lt;s13&gt;as?&lt;/s13&gt; &lt;s14&gt;T)!&lt;/s14&gt;&lt;/c11&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c7&gt;&lt;s8&gt;x&lt;/s8&gt; &lt;s9&gt;as!&lt;/s9&gt; &lt;s10&gt;T&lt;/s10&gt;&lt;/c7&gt;の挙動は、&lt;c11&gt;&lt;s12&gt;(x&lt;/s12&gt; &lt;s13&gt;as?&lt;/s13&gt; &lt;s14&gt;T)!&lt;/s14&gt;&lt;/c11&gt;の挙動と同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The behavior you see in your code is always as if a copy took place immediately.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがあなたのコードで見るこの挙動は、常にまるである１つのコピーが直ちに生じたかのようです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The bit-shifting behavior for unsigned integers is as follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>符号なし整数のためのビットシフト挙動は、次の通りです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The bitwise AND operator combines them to make the number &lt;c6&gt;&lt;s7&gt;00111100&lt;/s7&gt;&lt;/c6&gt;, which is equal to an unsigned decimal value of &lt;c8&gt;&lt;s9&gt;60&lt;/s9&gt;&lt;/c8&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット単位の論理積演算子は、それらを結合して、数&lt;c6&gt;&lt;s7&gt;00111100&lt;/s7&gt;&lt;/c6&gt;をつくります、それは、符号なしの10進数の&lt;c8&gt;&lt;s9&gt;60&lt;/s9&gt;&lt;/c8&gt;と等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The bitwise NOT operator is a prefix operator, and appears immediately before the value it operates on, without any white space:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット単位の論理否定演算子は、接頭辞演算子で、少しの空白なしで、それが作用する値の直前に現れまます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The bitwise NOT operator is then used to create a new constant called &lt;c0&gt;&lt;s1&gt;invertedBits&lt;/s1&gt;&lt;/c0&gt;, which is equal to &lt;c2&gt;&lt;s3&gt;initialBits&lt;/s3&gt;&lt;/c2&gt;, but with all of the bits inverted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット単位の論理否定演算子は、それから&lt;c0&gt;&lt;s1&gt;invertedBits&lt;/s1&gt;&lt;/c0&gt;と呼ばれる新しい定数をつくるために使われます、それは、&lt;c2&gt;&lt;s3&gt;initialBits&lt;/s3&gt;&lt;/c2&gt;と等しいです、しかし全てのビットは逆にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The bitwise OR operator combines them to make the number &lt;c6&gt;&lt;s7&gt;11111110&lt;/s7&gt;&lt;/c6&gt;, which equals an unsigned decimal of &lt;c8&gt;&lt;s9&gt;254&lt;/s9&gt;&lt;/c8&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット単位の論理和演算子は、それらを結合して、数&lt;c6&gt;&lt;s7&gt;11111110&lt;/s7&gt;&lt;/c6&gt;を作ります、それは、符号なしの10進数の&lt;c8&gt;&lt;s9&gt;254&lt;/s9&gt;&lt;/c8&gt;と等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The bitwise XOR operator sets both of these bits to &lt;c6&gt;&lt;s7&gt;1&lt;/s7&gt;&lt;/c6&gt; in its output value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビット単位の排他的論理和演算子は、これらのビットの両方ともその出力値において&lt;c6&gt;&lt;s7&gt;1&lt;/s7&gt;&lt;/c6&gt;に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The board has 25 squares, and the aim is to land on or beyond square 25.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この盤には25の正方形があります、そして目ざすのは正方形25の上に乗るまたは越える事です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The body of a class contains zero or more &lt;e0&gt;declarations&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスの本文は、０個以上の&lt;e0&gt;宣言&lt;/e0&gt;を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The body of a protocol contains zero or more &lt;e0&gt;protocol member declarations&lt;/e0&gt;, which describe the conformance requirements that any type adopting the protocol must fulfill.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルの本文は０以上の&lt;e0&gt;プロトコルメンバー宣言&lt;/e0&gt;を含みます、それは、プロトコルを採用しているすべての型が満たさなければならない準拠要件を記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The body of a structure contains zero or more &lt;e0&gt;declarations&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造の本文は、０以上の&lt;e0&gt;宣言&lt;/e0&gt;を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The body of an enumeration declared using either form contains zero or more values—called &lt;e2&gt;enumeration cases&lt;/e2&gt;—and any number of declarations, including computed properties, instance methods, type methods, initializers, type aliases, and even other enumeration, structure, and class declarations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どちらの形式を使って宣言される列挙宣言の本文でも、０以上の値 ― &lt;e2&gt;列挙ケース節&lt;/e2&gt;と呼ばれるもの ― および任意の数の宣言から成っていて、計算プロパティ、インスタンスメソッド、型メソッド、イニシャライザ、型エイリアス、そして他の列挙、構造体、およびクラス宣言さえも含められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The body of an extension declaration contains zero or more &lt;e0&gt;declarations&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張宣言の本文は、０個以上の&lt;e0&gt;宣言&lt;/e0&gt;を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The body of each case &lt;e0&gt;must&lt;/e0&gt; contain at least one executable statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれのケース節の本文は、少なくとも１つの実行可能な文を含んでいることが&lt;e0&gt;必要です&lt;/e0&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The body of the &lt;c0&gt;&lt;s1&gt;greet(person:)&lt;/s1&gt;&lt;/c0&gt; function starts by defining a new &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt; constant called &lt;c4&gt;&lt;s5&gt;greeting&lt;/s5&gt;&lt;/c4&gt; and setting it to a simple greeting message.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;greet(person:)&lt;/s1&gt;&lt;/c0&gt;関数の本文は、&lt;c4&gt;&lt;s5&gt;greeting&lt;/s5&gt;&lt;/c4&gt;と呼ばれる新しい&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;定数を定義してそれを単純な挨拶メッセージに設定することによって始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The body of the &lt;c0&gt;&lt;s1&gt;minMax(array:)&lt;/s1&gt;&lt;/c0&gt; function starts by setting two working variables called &lt;c2&gt;&lt;s3&gt;currentMin&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;currentMax&lt;/s5&gt;&lt;/c4&gt; to the value of the first integer in the array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;minMax(array:)&lt;/s1&gt;&lt;/c0&gt;の本文は、&lt;c2&gt;&lt;s3&gt;currentMin&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;currentMax&lt;/s5&gt;&lt;/c4&gt;と呼ばれる２つの作業用の変数を配列の最初の整数に設定することによって始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The body of the &lt;c0&gt;&lt;s1&gt;swapTwoValues(_:_:)&lt;/s1&gt;&lt;/c0&gt; function is identical to the body of the &lt;c2&gt;&lt;s3&gt;swapTwoInts(_:_:)&lt;/s3&gt;&lt;/c2&gt; function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;swapTwoValues(_:_:)&lt;/s1&gt;&lt;/c0&gt;関数の本文は、&lt;c2&gt;&lt;s3&gt;swapTwoInts(_:_:)&lt;/s3&gt;&lt;/c2&gt;関数の本文と同一です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The brackets tell Swift that &lt;c6&gt;&lt;s7&gt;T&lt;/s7&gt;&lt;/c6&gt; is a placeholder type name within the &lt;c8&gt;&lt;s9&gt;swapTwoValues(_:_:)&lt;/s9&gt;&lt;/c8&gt; function definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この括弧は、&lt;c6&gt;&lt;s7&gt;T&lt;/s7&gt;&lt;/c6&gt;が&lt;c8&gt;&lt;s9&gt;swapTwoValues(_:_:)&lt;/s9&gt;&lt;/c8&gt;関数定義内のプレースホルダ型名であるとスウィフトに教えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The call in the following example doesn’t compile because there isn’t an implementation of &lt;c2&gt;&lt;s3&gt;dynamicallyCall(withArguments:)&lt;/s3&gt;&lt;/c2&gt; that takes &lt;c4&gt;&lt;s5&gt;KeyValuePairs&lt;String,&lt;/s5&gt; &lt;s6&gt;String&gt;&lt;/s6&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例における呼び出しはコンパイルしません、なぜなら&lt;c2&gt;&lt;s3&gt;dynamicallyCall(withArguments:)&lt;/s3&gt;&lt;/c2&gt;の実装で&lt;c4&gt;&lt;s5&gt;KeyValuePairs&lt;String,&lt;/s5&gt; &lt;s6&gt;String&gt;&lt;/s6&gt;&lt;/c4&gt;をとるものがないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The call to &lt;c20&gt;&lt;s21&gt;increment(forCount:)&lt;/s21&gt;&lt;/c20&gt; happens only if &lt;c22&gt;&lt;s23&gt;increment(forCount:)&lt;/s23&gt;&lt;/c22&gt; exists—that is, if it isn’t &lt;c24&gt;&lt;s25&gt;nil&lt;/s25&gt;&lt;/c24&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c20&gt;&lt;s21&gt;increment(forCount:)&lt;/s21&gt;&lt;/c20&gt;への呼び出しは、&lt;c22&gt;&lt;s23&gt;increment(forCount:)&lt;/s23&gt;&lt;/c22&gt;が存在する場合にのみ起こります ― すなわち、それが&lt;c24&gt;&lt;s25&gt;nil&lt;/s25&gt;&lt;/c24&gt;でない場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The call to the &lt;c0&gt;&lt;s1&gt;digitNames&lt;/s1&gt;&lt;/c0&gt; dictionary’s subscript is followed by an exclamation point (&lt;c2&gt;&lt;s3&gt;!&lt;/s3&gt;&lt;/c2&gt;), because dictionary subscripts return an optional value to indicate that the dictionary lookup can fail if the key does not exist.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;digitNames&lt;/s1&gt;&lt;/c0&gt;辞書への呼び出しの添え字の後に感嘆符（&lt;c2&gt;&lt;s3&gt;!&lt;/s3&gt;&lt;/c2&gt;）が続きます、なぜなら、キーが存在しない場合は辞書検索が失敗し得ることを意味するために、辞書添え字がオプショナルの値を返すからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The call-as-function methods and the methods from the &lt;c0&gt;&lt;s1&gt;dynamicCallable&lt;/s1&gt;&lt;/c0&gt; attribute make different trade-offs between how much information you encode into the type system and how much dynamic behavior is possible at runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>call-as-functionメソッドと&lt;c0&gt;&lt;s1&gt;dynamicCallable&lt;/s1&gt;&lt;/c0&gt;属性からのメソッドは、どのくらいの情報をあなたが型システムにエンコードするかそしてどのくらい動的挙動が実行時に可能かの間で、異なる取り引きを行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The calling code can use any type that conforms to the &lt;c8&gt;&lt;s9&gt;Comparable&lt;/s9&gt;&lt;/c8&gt; protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>呼び出しているコードは、&lt;c8&gt;&lt;s9&gt;Comparable&lt;/s9&gt;&lt;/c8&gt;プロトコルに準拠するあらゆる型を使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The capabilities described above for computing and observing properties are also available to &lt;e0&gt;global variables&lt;/e0&gt; and &lt;e1&gt;local variables&lt;/e1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>計算するそして監視するプロパティに対して上で記述される可能なことは、また、&lt;e0&gt;グローバル変数&lt;/e0&gt;と&lt;e1&gt;ローカル変数&lt;/e1&gt;に対して利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The case values of an enumeration are actual values, not just another way of writing their raw values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある列挙に属するケース節の値は実際の値です、単にそれらの生の値を別のやり方で書くことではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The chapter’s example of &lt;a2&gt;&lt;s3&gt;Overriding Property Getters and Setters&lt;/s3&gt;&lt;/a2&gt; has been rewritten to show how to override a &lt;c4&gt;&lt;s5&gt;description&lt;/s5&gt;&lt;/c4&gt; property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この章の&lt;a2&gt;&lt;s3&gt;プロパティゲッターとセッターのオーバーライド&lt;/s3&gt;&lt;/a2&gt;の例は書き直されて、&lt;c4&gt;&lt;s5&gt;description&lt;/s5&gt;&lt;/c4&gt;プロパティをオーバーライドする方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The characters are visually similar, but don’t have the same linguistic meaning:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの文字は視覚的には同じ形です、しかし同じ言語的意味を持ちません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The class also defines a deinitializer, which prints a message to show when an &lt;c6&gt;&lt;s7&gt;HTMLElement&lt;/s7&gt;&lt;/c6&gt; instance is deallocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスもデイニシャライザを定義します、それは、&lt;c6&gt;&lt;s7&gt;HTMLElement&lt;/s7&gt;&lt;/c6&gt;インスタンスが割り当て解除される場合に示すメッセージを出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The class instance is not fully valid until the first phase ends.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第１段階が終わるまで、クラスインスタンスは充分に有効ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The class is assumed to take a nontrivial amount of time to initialize.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（このクラスは、瑣末でない量の時間が初期化にかかると仮定されます。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The closed range operator has an alternative form for ranges that continue as far as possible in one direction—for example, a range that includes all the elements of an array from index 2 to the end of the array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>完結範囲演算子は、一方向に可能な限り続く範囲 — 例えば、インデックス２から配列の最後までの配列のすべての要素を含む範囲、などに対する代替の形式を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The closed range operator is useful when iterating over a range in which you want all of the values to be used, such as with a &lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt; loop:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>完結範囲演算子は、あなたがその値の全てが使われることを望む、ある範囲全体に渡って繰り返すときに役に立ちます、例えば&lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt;ループで：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The closure can be used to create a string representation of any integer greater than zero.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このクロージャは、ゼロより大きいあらゆる整数の文字列表現を作るために使われることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The closure can then refer to and modify the values of those constants and variables from within its body, even if the original scope that defined the constants and variables no longer exists.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャはそれから、その本文内からそれらの定数と変数の値に言及することや修正することができます、たとえその定数と変数を定義した本来のスコープがもはや存在しないとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The closure expression also specifies a return type of &lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt;, to indicate the type that will be stored in the mapped output array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャ式はまた、&lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt;の戻り型を指定します、それによってマップされた出力配列の中に格納されることになる型を指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The closure expression builds a string called &lt;c0&gt;&lt;s1&gt;output&lt;/s1&gt;&lt;/c0&gt; each time it is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャ式は、それが呼ばれるたびに、&lt;c0&gt;&lt;s1&gt;output&lt;/s1&gt;&lt;/c0&gt;と呼ばれる文字列をつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The closure expression examples below illustrate these optimizations by refining a single example of the &lt;c1&gt;&lt;s2&gt;sorted(by:)&lt;/s2&gt;&lt;/c1&gt; method over several iterations, each of which expresses the same functionality in a more succinct way.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下のクロージャ式の例は、これらの最適化を１つの例の&lt;c1&gt;&lt;s2&gt;sorted(by:)&lt;/s2&gt;&lt;/c1&gt;メソッドの改良をいくどか繰り返していくことで解説します、そして、そのそれぞれは同じ機能性をより簡潔な方法で表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The closure expression examples below use the &lt;c0&gt;&lt;s1&gt;sorted(by:)&lt;/s1&gt;&lt;/c0&gt; method to sort an array of &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt; values in reverse alphabetical order.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下のクロージャ式の例は、&lt;c0&gt;&lt;s1&gt;sorted(by:)&lt;/s1&gt;&lt;/c0&gt;メソッドを使用して&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;値からなる配列を逆アルファベット順に分類します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The closure expressions passed to &lt;c0&gt;&lt;s1&gt;myFunction&lt;/s1&gt;&lt;/c0&gt; in code above are examples of this kind of immediate use.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のコードにおいて&lt;c0&gt;&lt;s1&gt;myFunction&lt;/s1&gt;&lt;/c0&gt;に渡されるクロージャ式は、この種の直接的な利用の例です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The closure in the example above calculates and sets the appropriate color for each square on the board in a temporary array called &lt;c4&gt;&lt;s5&gt;temporaryBoard&lt;/s5&gt;&lt;/c4&gt;, and returns this temporary array as the closure’s return value once its setup is complete.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例でのクロージャは&lt;c4&gt;&lt;s5&gt;temporaryBoard&lt;/s5&gt;&lt;/c4&gt;と呼ばれる一時的な配列の中の板上の各正方形に対して適切な色を計算して設定します、そしてひとたびその準備が完了されるならば、この一時的な配列をクロージャの戻り値として返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The closure is called once for each item in the array, and returns an alternative mapped value (possibly of some other type) for that item.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャは、配列の中の各項目に対して一度だけ呼ばれて、その項目のための代わりの対応付けされた（おそらく何か他の型の）値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code above calls the &lt;c0&gt;&lt;s1&gt;continue&lt;/s1&gt;&lt;/c0&gt; keyword whenever it matches a vowel or a space, causing the current iteration of the loop to end immediately and to jump straight to the start of the next iteration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のコードは、それが母音または空白と合致するたびに&lt;c0&gt;&lt;s1&gt;continue&lt;/s1&gt;&lt;/c0&gt;キーワードを呼んで、ループの現在の繰り返しを直ちに終わって、次の繰り返しのスタートへまっすぐポンと飛ぶようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code above creates a dictionary of mappings between the integer digits and English-language versions of their names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のコードは、整数桁とそれらの名前の英語版の間で対応付けをする辞書を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code above creates a new &lt;c0&gt;&lt;s1&gt;Counter&lt;/s1&gt;&lt;/c0&gt; instance; sets its data source to be a new &lt;c2&gt;&lt;s3&gt;ThreeSource&lt;/s3&gt;&lt;/c2&gt; instance; and calls the counter’s &lt;c4&gt;&lt;s5&gt;increment()&lt;/s5&gt;&lt;/c4&gt; method four times.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のコードは、新しい&lt;c0&gt;&lt;s1&gt;Counter&lt;/s1&gt;&lt;/c0&gt;インスタンスをつくり；それのデータ・ソースを新しい&lt;c2&gt;&lt;s3&gt;ThreeSource&lt;/s3&gt;&lt;/c2&gt;インスタンスであるように設定します；そして、counterの&lt;c4&gt;&lt;s5&gt;increment()&lt;/s5&gt;&lt;/c4&gt;メソッドを４回呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code above succeeds when &lt;c0&gt;&lt;s1&gt;john.residence&lt;/s1&gt;&lt;/c0&gt; has a non-&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt; value and will set &lt;c4&gt;&lt;s5&gt;roomCount&lt;/s5&gt;&lt;/c4&gt; to an &lt;c6&gt;&lt;s7&gt;Int&lt;/s7&gt;&lt;/c6&gt; value containing the appropriate number of rooms.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;john.residence&lt;/s1&gt;&lt;/c0&gt;が非&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;値を持って、&lt;c4&gt;&lt;s5&gt;roomCount&lt;/s5&gt;&lt;/c4&gt;を部屋の適当な数を含んでいる&lt;c6&gt;&lt;s7&gt;Int&lt;/s7&gt;&lt;/c6&gt;値に設定するとき、上のコードは成功します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code above uses the ternary conditional operator and forced unwrapping (&lt;c0&gt;&lt;s1&gt;a!&lt;/s1&gt;&lt;/c0&gt;) to access the value wrapped inside &lt;c2&gt;&lt;s3&gt;a&lt;/s3&gt;&lt;/c2&gt; when &lt;c4&gt;&lt;s5&gt;a&lt;/s5&gt;&lt;/c4&gt; is not &lt;c6&gt;&lt;s7&gt;nil&lt;/s7&gt;&lt;/c6&gt;, and to return &lt;c8&gt;&lt;s9&gt;b&lt;/s9&gt;&lt;/c8&gt; otherwise.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のコードは、三項条件演算子と強制アンラップ（&lt;c0&gt;&lt;s1&gt;a!&lt;/s1&gt;&lt;/c0&gt;）を使って、&lt;c4&gt;&lt;s5&gt;a&lt;/s5&gt;&lt;/c4&gt;が&lt;c6&gt;&lt;s7&gt;nil&lt;/s7&gt;&lt;/c6&gt;でないならば&lt;c2&gt;&lt;s3&gt;a&lt;/s3&gt;&lt;/c2&gt;内部にラップされた値にアクセスします、それ以外では&lt;c8&gt;&lt;s9&gt;b&lt;/s9&gt;&lt;/c8&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code below adds a &lt;c2&gt;&lt;s3&gt;projectedValue&lt;/s3&gt;&lt;/c2&gt; property to the &lt;c4&gt;&lt;s5&gt;SmallNumber&lt;/s5&gt;&lt;/c4&gt; structure to keep track of whether the property wrapper adjusted the new value for the property before storing that new value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下のコードは、&lt;c2&gt;&lt;s3&gt;projectedValue&lt;/s3&gt;&lt;/c2&gt;プロパティを&lt;c4&gt;&lt;s5&gt;SmallNumber&lt;/s5&gt;&lt;/c4&gt;構造体に加えることで、プロパティラッパーがプロパティに対する新しい値を、その新しい値を格納する前に調節したかどうかを追跡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code below shows four examples of these special characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下のコードは、これらの特殊文字の４つの例を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code below shows how a closure delays evaluation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下のコードは、どのようにクロージャが評価を遅らすかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code below shows that the same error appears for overlapping write accesses to the properties of a structure that’s stored in a global variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下のコードは、グローバル変数に格納される構造体に属するプロパティに対するオーバーラップする書き込みアクセスに、同じエラーが起こることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code below shows the &lt;c10&gt;&lt;s11&gt;ArithmeticExpression&lt;/s11&gt;&lt;/c10&gt; recursive enumeration being created for &lt;c12&gt;&lt;s13&gt;(5&lt;/s13&gt; &lt;s14&gt;+&lt;/s14&gt; &lt;s15&gt;4)&lt;/s15&gt; &lt;s16&gt;*&lt;/s16&gt; &lt;s17&gt;2&lt;/s17&gt;&lt;/c12&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下のコードは、&lt;c12&gt;&lt;s13&gt;(5&lt;/s13&gt; &lt;s14&gt;+&lt;/s14&gt; &lt;s15&gt;4)&lt;/s15&gt; &lt;s16&gt;*&lt;/s16&gt; &lt;s17&gt;2&lt;/s17&gt;&lt;/c12&gt;に対して作成されている再帰列挙&lt;c10&gt;&lt;s11&gt;ArithmeticExpression&lt;/s11&gt;&lt;/c10&gt;を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code in a closure has access to things like variables and functions that were available in the scope where the closure was created, even if the closure is in a different scope when it is executed—you saw an example of this already with nested functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるクロージャの中のコードは、そのクロージャが作成されたところのスコープ内で利用可能だった変数や関数といったものにアクセスをします、たとえそのクロージャが実行されるときに異なるスコープの中にあってもです ― あなたはこの例を入れ子にされた関数で既に見ました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code in the examples above sets the initial value for the wrapped property by giving &lt;c0&gt;&lt;s1&gt;number&lt;/s1&gt;&lt;/c0&gt; an initial value in the definition of &lt;c2&gt;&lt;s3&gt;TwelveOrLess&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例におけるコードは、ラップされたプロパティに初期値を設定することを、&lt;c0&gt;&lt;s1&gt;number&lt;/s1&gt;&lt;/c0&gt;を初期値に与えることによって、&lt;c2&gt;&lt;s3&gt;TwelveOrLess&lt;/s3&gt;&lt;/c2&gt;の定義の中で、行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code in the following example refers to the projected value of the wrapper around &lt;c2&gt;&lt;s3&gt;height&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;width&lt;/s5&gt;&lt;/c4&gt; as &lt;c6&gt;&lt;s7&gt;$height&lt;/s7&gt;&lt;/c6&gt; and &lt;c8&gt;&lt;s9&gt;$width&lt;/s9&gt;&lt;/c8&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の例におけるコードは、&lt;c2&gt;&lt;s3&gt;height&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;width&lt;/s5&gt;&lt;/c4&gt;のまわりのラッパーの予測値を、&lt;c6&gt;&lt;s7&gt;$height&lt;/s7&gt;&lt;/c6&gt;と&lt;c8&gt;&lt;s9&gt;$width&lt;/s9&gt;&lt;/c8&gt;として参照します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code inside &lt;c0&gt;&lt;s1&gt;makeTrapezoid()&lt;/s1&gt;&lt;/c0&gt; can return any type it needs to, as long as that type conforms to the &lt;c2&gt;&lt;s3&gt;Shape&lt;/s3&gt;&lt;/c2&gt; protocol, like the calling code does for a generic function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;makeTrapezoid()&lt;/s1&gt;&lt;/c0&gt;内部のコードは、それが必要とするどんな型でも返すことが、その型が&lt;c2&gt;&lt;s3&gt;Shape&lt;/s3&gt;&lt;/c2&gt;プロトコルに準拠する限りは可能です、呼び出しているコードが総称体関数に対してするように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code inside that initializer sets the initial wrapped value and the initial maximum value, using the default values of zero and 12.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのイニシャライザの内側のコードは、初期ラップ値と初期最大値を設定します、ゼロと12の省略時の値を使って。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code inside the function is written in a general way so it can handle whatever type the caller provides.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数の内側のコードは、ある一般化された方法で記述されます、それでそれは呼び出し側が提供するどんな型でも取り扱うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code inside the module could build up the same shape in a variety of ways, and other code outside the module that uses the shape shouldn’t have to account for the implementation details about the list of transformations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>モジュール内のコードは、同じ形状をさまざまな方法で作り上げることができました、そしてその形状を使うモジュール外のその他のコードは、ずらっとある変形それらについての実装詳細に関知する必要はないはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code is executed regardless of whether the function throws an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのコードは、関数がエラーをスローするかどうかに関係なく実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code snippets below define four model classes for use in several subsequent examples, including examples of multilevel optional chaining.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下のコード切れっぱしは、複数階層のオプショナル連鎖の例を含む以降のいくつかの例のために、４つのモデル・クラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code that calls &lt;c0&gt;&lt;s1&gt;max(_:_:)&lt;/s1&gt;&lt;/c0&gt; chooses the values for &lt;c2&gt;&lt;s3&gt;x&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;y&lt;/s5&gt;&lt;/c4&gt;, and the type of those values determines the concrete type of &lt;c6&gt;&lt;s7&gt;T&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;max(_:_:)&lt;/s1&gt;&lt;/c0&gt;を呼び出すコードは、&lt;c2&gt;&lt;s3&gt;x&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;y&lt;/s5&gt;&lt;/c4&gt;に対して値を選びます、そしてそれらの値の型は&lt;c6&gt;&lt;s7&gt;T&lt;/s7&gt;&lt;/c6&gt;の具象型を決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code that calls the function needs to be written in a general way, like the implementation of a generic function, so that it can work with any &lt;c4&gt;&lt;s5&gt;Shape&lt;/s5&gt;&lt;/c4&gt; value that’s returned by &lt;c6&gt;&lt;s7&gt;makeTrapezoid()&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数を呼び出すコードは、ある一般的な方法で書かれることを必要とします、総称体関数の実装のように、それでそれは、&lt;c6&gt;&lt;s7&gt;makeTrapezoid()&lt;/s7&gt;&lt;/c6&gt;によって返されるあらゆる&lt;c4&gt;&lt;s5&gt;Shape&lt;/s5&gt;&lt;/c4&gt;と仕事できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code within a default case is executed only if no other cases match the control expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他のいかなるケース節も制御式にマッチしない場合だけ、省略時のケース節内のコードは実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code you provide is run any time the value changes outside of an initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが提供したコードは、その値がイニシャライザの外側で変化する時はいつでも実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The colon in the declaration means “…of type…,” so the code above can be read as:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言でのコロンは「…の型の…」を意味します、それで上のコードは次のように読まれることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The column number in which it begins.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが開始するコラム番号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler also detects methods with &lt;c4&gt;&lt;s5&gt;override&lt;/s5&gt;&lt;/c4&gt; that don’t actually override any method in the superclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラはまた、実際にはスーパークラスにおけるメソッドを少しもオーバーライドしない&lt;c4&gt;&lt;s5&gt;override&lt;/s5&gt;&lt;/c4&gt;をもつメソッドも検出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler assumes that preconditions are always true, and it optimizes your code accordingly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラは、その前提条件が常にtrueであるとみなします、そしてそれはあなたのコードをそれを受けて最適化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler can prove that memory safety is preserved because the two stored properties don’t interact in any way.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラはメモリ安全が守られることを立証できます、なぜなら２つの格納プロパティはどんな方法でも相互作用しないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler displays the new name when emitting an error about the use of a renamed declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラは、ある改名された宣言の使用についてのエラーを発するときにその新しい名前を表示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler implicitly adds the &lt;c0&gt;&lt;s1&gt;objc&lt;/s1&gt;&lt;/c0&gt; attribute to subclasses of any class defined in Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラは、Objective-Cにおいて定義されたあらゆるクラスのサブクラスに暗黙的に&lt;c0&gt;&lt;s1&gt;objc&lt;/s1&gt;&lt;/c0&gt;属性を加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler is allowed to replace calls to an inlinable symbol with a copy of the symbol’s implementation at the call site.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラは、インライン可能シンボルへの呼び出しを、呼び出し場所でのそのシンボルの持つ実装のコピーで置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler is optimized for performance and the language is optimized for development, without compromising on either.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラはパフォーマンスのために最適化され言語は開発のために最適化されます、どちらについても妥協することなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler makes this possible using techniques like looking up information at runtime and adding a layer of indirection.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラは、これを、実行時に情報を検索することそして間接参照のレイヤーを加えることのような技術いくつかを使って可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler synthesizes an identifier for the projected value by prefixing the name of the wrapped property with a dollar sign (&lt;c3&gt;&lt;s4&gt;$&lt;/s4&gt;&lt;/c3&gt;)—for example, the projected value for &lt;c5&gt;&lt;s6&gt;someProperty&lt;/s6&gt;&lt;/c5&gt; is &lt;c7&gt;&lt;s8&gt;$someProperty&lt;/s8&gt;&lt;/c7&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラは、ある識別子を予測値に対して合成します、ラップされたプロパティの名前にドル記号（&lt;c3&gt;&lt;s4&gt;$&lt;/s4&gt;&lt;/c3&gt;）で接頭辞をつけることによって — 例えば、&lt;c5&gt;&lt;s6&gt;someProperty&lt;/s6&gt;&lt;/c5&gt;に対する見込値は&lt;c7&gt;&lt;s8&gt;$someProperty&lt;/s8&gt;&lt;/c7&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler synthesizes identifiers that begin with a dollar sign (&lt;c0&gt;&lt;s1&gt;$&lt;/s1&gt;&lt;/c0&gt;) for properties that have a property wrapper projection.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラは、ドル記号（&lt;c0&gt;&lt;s1&gt;$&lt;/s1&gt;&lt;/c0&gt;）で始まる識別子を、プロパティラッパー予測を持つプロパティに対して合成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler synthesizes storage for the instance of the wrapper type by prefixing the name of the wrapped property with an underscore (&lt;c5&gt;&lt;s6&gt;_&lt;/s6&gt;&lt;/c5&gt;)—for example, the wrapper for &lt;c7&gt;&lt;s8&gt;someProperty&lt;/s8&gt;&lt;/c7&gt; is stored as &lt;c9&gt;&lt;s10&gt;_someProperty&lt;/s10&gt;&lt;/c9&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラは、ラッパー型のインスタンスのためにストレージを合成します、ラップされたプロパティの名前にアンダースコア（&lt;c5&gt;&lt;s6&gt;_&lt;/s6&gt;&lt;/c5&gt;）で接頭辞をつけることによって — 例えば、&lt;c7&gt;&lt;s8&gt;someProperty&lt;/s8&gt;&lt;/c7&gt;に対するラッパーは、&lt;c9&gt;&lt;s10&gt;_someProperty&lt;/s10&gt;&lt;/c9&gt;として格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler uses availability information in the SDK to verify that all of the APIs used in your code are available on the deployment target specified by your project.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラは、SDKの中の有効性情報を使って、あなたのコードの中で使用されるAPIの全てがあなたのプロジェクトで指定される開発対象で有効であることを確かめます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compiler uses the information from the availability condition when it verifies that the APIs in that block of code are available.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラは、有効性条件からの情報を、それがそのブロックの中のAPIが利用可能であることを確かめる時に使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compound assignment operators don’t return a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複合代入演算子は、値を返しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The computed &lt;c6&gt;&lt;s7&gt;numberOfRooms&lt;/s7&gt;&lt;/c6&gt; property simply returns the value of the &lt;c8&gt;&lt;s9&gt;count&lt;/s9&gt;&lt;/c8&gt; property from the &lt;c10&gt;&lt;s11&gt;rooms&lt;/s11&gt;&lt;/c10&gt; array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>計算&lt;c6&gt;&lt;s7&gt;numberOfRooms&lt;/s7&gt;&lt;/c6&gt;プロパティは、単に&lt;c10&gt;&lt;s11&gt;rooms&lt;/s11&gt;&lt;/c10&gt;配列から&lt;c8&gt;&lt;s9&gt;count&lt;/s9&gt;&lt;/c8&gt;プロパティの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The computed type property examples above are for read-only computed type properties, but you can also define read-write computed type properties with the same syntax as for computed instance properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の計算型プロパティの例は、読み出し専用の計算型プロパティのためのものです、しかしあなたはまた、計算インスタンスプロパティについては同じ構文をつかって読み書き両用の計算型プロパティを定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The concept of a stack is used by the &lt;c0&gt;&lt;s1&gt;UINavigationController&lt;/s1&gt;&lt;/c0&gt; class to model the view controllers in its navigation hierarchy.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スタックの概念は、&lt;c0&gt;&lt;s1&gt;UINavigationController&lt;/s1&gt;&lt;/c0&gt;クラスで使用されて、そのナビゲーション階層においてビュー・コントローラをモデル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The concept of optionals doesn’t exist in C or Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルの概念は、CまたはObjective-Cの中に存在しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The condition can also be an optional binding declaration, as discussed in &lt;a5&gt;&lt;s6&gt;Optional Binding&lt;/s6&gt;&lt;/a5&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>条件はまた、&lt;a5&gt;&lt;s6&gt;オプショナル束縛&lt;/s6&gt;&lt;/a5&gt;で議論される、オプショナル束縛宣言であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The condition can also be an optional binding declaration, as discussed in &lt;a6&gt;&lt;s7&gt;Optional Binding&lt;/s7&gt;&lt;/a6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>条件はまた、&lt;a6&gt;&lt;s7&gt;オプショナル束縛&lt;/s7&gt;&lt;/a6&gt;で議論される、オプショナル束縛宣言であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The condition of a loop can be at the end instead, ensuring that the loop is run at least once.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ループの条件は終わりに置くことができます、その場合にはループが少なくとも一回は実行されることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The conditional form, &lt;c0&gt;&lt;s1&gt;as?&lt;/s1&gt;&lt;/c0&gt;, returns an optional value of the type you are trying to downcast to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>条件（仮定）形式&lt;c0&gt;&lt;s1&gt;as?&lt;/s1&gt;&lt;/c0&gt;は、あなたがダウンキャストしようとしている型のオプショナルの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The constraint on &lt;c14&gt;&lt;s15&gt;Item&lt;/s15&gt;&lt;/c14&gt; is a generic &lt;c16&gt;&lt;s17&gt;where&lt;/s17&gt;&lt;/c16&gt; clause, which is discussed in &lt;a18&gt;&lt;s19&gt;Associated Types with a Generic Where Clause&lt;/s19&gt;&lt;/a18&gt; below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c14&gt;&lt;s15&gt;Item&lt;/s15&gt;&lt;/c14&gt;での制約は総称体&lt;c16&gt;&lt;s17&gt;where&lt;/s17&gt;&lt;/c16&gt;です、それは下の&lt;a18&gt;&lt;s19&gt;where節を持つ関連型&lt;/s19&gt;&lt;/a18&gt;において議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The contents of a &lt;c0&gt;&lt;s1&gt;Dictionary&lt;/s1&gt;&lt;/c0&gt; are inherently unordered, and iterating over them does not guarantee the order in which they will be retrieved.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Dictionary&lt;/s1&gt;&lt;/c0&gt;の内容は本質的に順序付けされません、そしてそれらに繰り返すことはそれらが取り出される順番を保証しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The contents of a &lt;c8&gt;&lt;s9&gt;String&lt;/s9&gt;&lt;/c8&gt; can be accessed in various ways, including as a collection of &lt;c10&gt;&lt;s11&gt;Character&lt;/s11&gt;&lt;/c10&gt; values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある&lt;c8&gt;&lt;s9&gt;String&lt;/s9&gt;&lt;/c8&gt;の内容は、いくつかのやり方でアクセスされることができます、それには&lt;c10&gt;&lt;s11&gt;Character&lt;/s11&gt;&lt;/c10&gt;値からなるひとつのコレクションとしてを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The contents of this expression are also considered when performing type inference on the surrounding expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この式の内容はまた、型推論を実行する時に周囲の式上にあると見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The context and function name should make it clear that evaluation is being deferred.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文脈と関数名は、評価が猶予されていることを明確にしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The context in which a type conforms to a particular protocol is the minimum of the type’s access level and the protocol’s access level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型が特定のプロトコルに準拠するところの前後関係は、その型のアクセス水準とプロトコルのアクセス水準の最も低いものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The convenience initializer must call one of the two designated initializers, because it can only call another initializer from the same class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>便宜イニシャライザは、２つの指定イニシャライザのうちの１つを呼ぶに違いありません、なぜなら、それが同じクラスから別のイニシャライザを呼ぶことができるだけだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The corresponding argument must have no label in function or method calls.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対応する引数には、関数またはメソッドの呼び出しにおいてラベルがあってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The corresponding argument must use the given argument label in function or method calls.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>対応する引数は、この引数ラベルを関数またはメソッドの呼び出しにおいて使わなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The corresponding implementation for &lt;c0&gt;&lt;s1&gt;Vector2D&lt;/s1&gt;&lt;/c0&gt; instances performs this operation on both the &lt;c2&gt;&lt;s3&gt;x&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;y&lt;/s5&gt;&lt;/c4&gt; properties:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Vector2D&lt;/s1&gt;&lt;/c0&gt;インスタンスのための対応する実装は、&lt;c2&gt;&lt;s3&gt;x&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;y&lt;/s5&gt;&lt;/c4&gt;プロパティ両方の上でこの操作を実行します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The corresponding section in &lt;a6&gt;&lt;s7&gt;Strings and Characters&lt;/s7&gt;&lt;/a6&gt; has been removed, and various code examples have been updated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a6&gt;&lt;s7&gt;文字列と文字&lt;/s7&gt;&lt;/a6&gt;の中の関連する節は削除されました、そしてさまざまなコード例が更新されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The count of the characters returned by the &lt;c0&gt;&lt;s1&gt;count&lt;/s1&gt;&lt;/c0&gt; property isn’t always the same as the &lt;c2&gt;&lt;s3&gt;length&lt;/s3&gt;&lt;/c2&gt; property of an &lt;c4&gt;&lt;s5&gt;NSString&lt;/s5&gt;&lt;/c4&gt; that contains the same characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;count&lt;/s1&gt;&lt;/c0&gt;プロパティによって返される文字の総数は、同じ文字を含む&lt;c4&gt;&lt;s5&gt;NSString&lt;/s5&gt;&lt;/c4&gt;の&lt;c2&gt;&lt;s3&gt;length&lt;/s3&gt;&lt;/c2&gt;プロパティと常に同じではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The current &lt;c0&gt;&lt;s1&gt;while&lt;/s1&gt;&lt;/c0&gt; loop execution then ends, and the loop’s condition is checked to see if the loop should be executed again.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>現在の&lt;c0&gt;&lt;s1&gt;while&lt;/s1&gt;&lt;/c0&gt;ループ実行はそれから終了します、そしてループが再び実行されなければならないかどうか見るためにループの条件が調べられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The current center position of a &lt;c4&gt;&lt;s5&gt;Rect&lt;/s5&gt;&lt;/c4&gt; can always be determined from its &lt;c6&gt;&lt;s7&gt;origin&lt;/s7&gt;&lt;/c6&gt; and &lt;c8&gt;&lt;s9&gt;size&lt;/s9&gt;&lt;/c8&gt;, and so you don’t need to store the center point as an explicit &lt;c10&gt;&lt;s11&gt;Point&lt;/s11&gt;&lt;/c10&gt; value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;Rect&lt;/s5&gt;&lt;/c4&gt;の現在の中心位置は常にその&lt;c6&gt;&lt;s7&gt;origin&lt;/s7&gt;&lt;/c6&gt;と&lt;c8&gt;&lt;s9&gt;size&lt;/s9&gt;&lt;/c8&gt;から決定されることができます、なのであなたは中心点をわざわざ&lt;c10&gt;&lt;s11&gt;Point&lt;/s11&gt;&lt;/c10&gt;値として格納する必要ばありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The current login attempt counter is declared as a variable, because this value must be incremented after each failed login attempt.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>現在のログイン試行の計数は、この値が失敗したログインの試みそれぞれの後で増加する必要があるので、変数として宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The current loop execution then ends.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>現在のループ実行はそれで終わりです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The decimal fraction consists of a decimal point (&lt;c0&gt;&lt;s1&gt;.&lt;/s1&gt;&lt;/c0&gt;) followed by a sequence of decimal digits.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>小数部は、小数点（&lt;c0&gt;&lt;s1&gt;.&lt;/s1&gt;&lt;/c0&gt;）に続く一連の10進の桁から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The declaration for &lt;c0&gt;&lt;s1&gt;number&lt;/s1&gt;&lt;/c0&gt; in the example above marks the variable as &lt;c2&gt;&lt;s3&gt;private&lt;/s3&gt;&lt;/c2&gt;, which ensures &lt;c4&gt;&lt;s5&gt;number&lt;/s5&gt;&lt;/c4&gt; is used only in the implementation of &lt;c6&gt;&lt;s7&gt;TwelveOrLess&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;number&lt;/s1&gt;&lt;/c0&gt;に対する宣言は上の例において、変数を&lt;c2&gt;&lt;s3&gt;private&lt;/s3&gt;&lt;/c2&gt;として印します、それは&lt;c4&gt;&lt;s5&gt;number&lt;/s5&gt;&lt;/c4&gt;が&lt;c6&gt;&lt;s7&gt;TwelveOrLess&lt;/s7&gt;&lt;/c6&gt;の実装においてのみ使われることを保証します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The declaration has the &lt;c0&gt;&lt;s1&gt;IBAction&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;IBSegueAction&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;IBOutlet&lt;/s5&gt;&lt;/c4&gt;, &lt;c6&gt;&lt;s7&gt;IBDesignable&lt;/s7&gt;&lt;/c6&gt;, &lt;c8&gt;&lt;s9&gt;IBInspectable&lt;/s9&gt;&lt;/c8&gt;, &lt;c10&gt;&lt;s11&gt;NSManaged&lt;/s11&gt;&lt;/c10&gt;, or &lt;c12&gt;&lt;s13&gt;GKInspectable&lt;/s13&gt;&lt;/c12&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その宣言は、&lt;c0&gt;&lt;s1&gt;IBAction&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;IBSegueAction&lt;/s3&gt;&lt;/c2&gt;、&lt;c4&gt;&lt;s5&gt;IBOutlet&lt;/s5&gt;&lt;/c4&gt;、&lt;c6&gt;&lt;s7&gt;IBDesignable&lt;/s7&gt;&lt;/c6&gt;、&lt;c8&gt;&lt;s9&gt;IBInspectable&lt;/s9&gt;&lt;/c8&gt;、&lt;c10&gt;&lt;s11&gt;NSManaged&lt;/s11&gt;&lt;/c10&gt;、または&lt;c12&gt;&lt;s13&gt;GKInspectable&lt;/s13&gt;&lt;/c12&gt;を持つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The declaration is an override in a subclass, and the superclass’s declaration has the &lt;c0&gt;&lt;s1&gt;objc&lt;/s1&gt;&lt;/c0&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その宣言は、サブクラスの中のオーバーライドである、そしてそのサブクラスの宣言が&lt;c0&gt;&lt;s1&gt;objc&lt;/s1&gt;&lt;/c0&gt;属性を持つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The declaration must have the &lt;c0&gt;&lt;s1&gt;internal&lt;/s1&gt;&lt;/c0&gt; access level modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>宣言は、&lt;c0&gt;&lt;s1&gt;internal&lt;/s1&gt;&lt;/c0&gt;アクセス水準修飾子を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The declaration of &lt;c4&gt;&lt;s5&gt;SimpleClass&lt;/s5&gt;&lt;/c4&gt; doesn’t need any of its methods marked as mutating because methods on a class can always modify the class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;SimpleClass&lt;/s5&gt;&lt;/c4&gt;の宣言はそのメソッドのどれも変化させるとして印される必要はありません、なぜならあるクラスに属するメソッドは常にそのクラスを修正できるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The declaration of the &lt;c0&gt;&lt;s1&gt;dynamicallyCall(withArguments:)&lt;/s1&gt;&lt;/c0&gt; method must have a single parameter that conforms to the &lt;a2&gt;&lt;c3&gt;&lt;s4&gt;ExpressibleByArrayLiteral&lt;/s4&gt;&lt;/c3&gt;&lt;/a2&gt;&lt;s5&gt; [https://developer.apple.com/documentation/swift/expressiblebyarrayliteral]&lt;/s5&gt; protocol—like &lt;c6&gt;&lt;s7&gt;[Int]&lt;/s7&gt;&lt;/c6&gt; in the example above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;dynamicallyCall(withArguments:)&lt;/s1&gt;&lt;/c0&gt;メソッドの宣言は、&lt;a2&gt;&lt;c3&gt;&lt;s4&gt;ExpressibleByArrayLiteral&lt;/s4&gt;&lt;/c3&gt;&lt;/a2&gt;&lt;s5&gt; [https://developer.apple.com/documentation/swift/expressiblebyarrayliteral]&lt;/s5&gt;プロトコルに準拠する単一のパラメータを持たなければいけません — 上の例の&lt;c6&gt;&lt;s7&gt;[Int]&lt;/s7&gt;&lt;/c6&gt;のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The declaration of the &lt;c0&gt;&lt;s1&gt;dynamicallyCall(withKeywordArguments:)&lt;/s1&gt;&lt;/c0&gt; method must have a single parameter that conforms to the &lt;a2&gt;&lt;c3&gt;&lt;s4&gt;ExpressibleByDictionaryLiteral&lt;/s4&gt;&lt;/c3&gt;&lt;/a2&gt;&lt;s5&gt; [https://developer.apple.com/documentation/swift/expressiblebydictionaryliteral]&lt;/s5&gt; protocol, and the return type can be any type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;dynamicallyCall(withKeywordArguments:)&lt;/s1&gt;&lt;/c0&gt;メソッドの宣言は、ある単一のパラメータを持たなければなりません、それは&lt;a2&gt;&lt;c3&gt;&lt;s4&gt;ExpressibleByDictionaryLiteral&lt;/s4&gt;&lt;/c3&gt;&lt;/a2&gt;&lt;s5&gt; [https://developer.apple.com/documentation/swift/expressiblebydictionaryliteral]&lt;/s5&gt;プロトコルに準拠するものです、そして戻り型はどんな型でも構いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The declaration satisfies a requirement from a protocol that has the &lt;c0&gt;&lt;s1&gt;objc&lt;/s1&gt;&lt;/c0&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その宣言は、&lt;c0&gt;&lt;s1&gt;objc&lt;/s1&gt;&lt;/c0&gt;属性を持つあるプロトコルからの要件を満たす。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The declaration that the &lt;c2&gt;&lt;s3&gt;available&lt;/s3&gt;&lt;/c2&gt; attribute applies to is ignored if the attribute specifies a platform or language version that doesn’t match the current target.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;available&lt;/s3&gt;&lt;/c2&gt;属性を適用される宣言は、その属性が現在の対象と合致しないプラットホームまたは言語バージョンを指定するならば無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default access level of internal already matches this requirement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時のアクセス水準である内部は、既にこの要件に合致しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default inferred type of a string literal is &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期状態で推論されるリテラル文字列の型は、&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default initializer (when available) is always a designated initializer for a class, and can be used to create a new &lt;c4&gt;&lt;s5&gt;Vehicle&lt;/s5&gt;&lt;/c4&gt; instance with a &lt;c6&gt;&lt;s7&gt;numberOfWheels&lt;/s7&gt;&lt;/c6&gt; of &lt;c8&gt;&lt;s9&gt;0&lt;/s9&gt;&lt;/c8&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時のイニシャライザは（利用可能な場合は）、常にクラスのための指定イニシャライザです、そして&lt;c8&gt;&lt;s9&gt;0&lt;/s9&gt;&lt;/c8&gt;の&lt;c6&gt;&lt;s7&gt;numberOfWheels&lt;/s7&gt;&lt;/c6&gt;をもつ新しい&lt;c4&gt;&lt;s5&gt;Vehicle&lt;/s5&gt;&lt;/c4&gt;インスタンスを作成するために使用されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default initializer simply creates a new instance with all of its properties set to their default values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時のイニシャライザは、単に新しいインスタンスを、そのプロパティの全てをそれらの省略時の値に設定することで作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default memberwise initializer for a structure type is considered private if any of the structure’s stored properties are private.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体型のための省略時のメンバー関連イニシャライザは、その構造体の格納プロパティのいずれかが非公開ならば、非公開であるとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default types are &lt;c13&gt;&lt;s14&gt;Int&lt;/s14&gt;&lt;/c13&gt; for integer literals, &lt;c15&gt;&lt;s16&gt;Double&lt;/s16&gt;&lt;/c15&gt; for floating-point literals, &lt;c17&gt;&lt;s18&gt;String&lt;/s18&gt;&lt;/c17&gt; for string literals, and &lt;c19&gt;&lt;s20&gt;Bool&lt;/s20&gt;&lt;/c19&gt; for Boolean literals.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時の型は、整数リテラルのための&lt;c13&gt;&lt;s14&gt;Int&lt;/s14&gt;&lt;/c13&gt;、浮動小数点リテラルのための&lt;c15&gt;&lt;s16&gt;Double&lt;/s16&gt;&lt;/c15&gt;、文字列リテラルのための&lt;c17&gt;&lt;s18&gt;String&lt;/s18&gt;&lt;/c17&gt;、そしてブールのリテラルのための&lt;c19&gt;&lt;s20&gt;Bool&lt;/s20&gt;&lt;/c19&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default value also makes it easier for you to take advantage of default initializers and initializer inheritance, as described later in this chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時の値はまた、あなたが省略時のイニシャライザとイニシャライザ継承を活用することをより簡単にします、そのことはこの章の後で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The deferred statements may not contain any code that would transfer control out of the statements, such as a &lt;c4&gt;&lt;s5&gt;break&lt;/s5&gt;&lt;/c4&gt; or a &lt;c6&gt;&lt;s7&gt;return&lt;/s7&gt;&lt;/c6&gt; statement, or by throwing an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>延期される文は、制御をその文の外に、例えば&lt;c4&gt;&lt;s5&gt;break&lt;/s5&gt;&lt;/c4&gt;や&lt;c6&gt;&lt;s7&gt;return&lt;/s7&gt;&lt;/c6&gt;文、またはエラーをスローすることによって移すいかなるコードも含んではいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The definition describes what the function does, what it expects to receive, and what it returns when it is done.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定義は、関数が何をするか、それが何を受け取るのを予想するか、そしてそれが実行し終わったとき、それが何を返すかを記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The definition makes it easy for the function to be called unambiguously from elsewhere in your code:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定義は、関数があなたのコードのどこか他の場所から誤解の余地なく呼び出されることを簡単にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The definition of &lt;c0&gt;&lt;s1&gt;SmallNumber&lt;/s1&gt;&lt;/c0&gt; includes three initializers—&lt;c2&gt;&lt;s3&gt;init()&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;init(wrappedValue:)&lt;/s5&gt;&lt;/c4&gt;, and &lt;c6&gt;&lt;s7&gt;init(wrappedValue:maximum:)&lt;/s7&gt;&lt;/c6&gt;—which the examples below use to set the wrapped value and the maximum value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;SmallNumber&lt;/s1&gt;&lt;/c0&gt;の定義は３つのイニシャライザを含みます — &lt;c2&gt;&lt;s3&gt;init()&lt;/s3&gt;&lt;/c2&gt;、&lt;c4&gt;&lt;s5&gt;init(wrappedValue:)&lt;/s5&gt;&lt;/c4&gt;、そして&lt;c6&gt;&lt;s7&gt;init(wrappedValue:maximum:)&lt;/s7&gt;&lt;/c6&gt; — それらは、下の例がラップ値と最大値を設定するのに使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The definition of &lt;c8&gt;&lt;s9&gt;typealias&lt;/s9&gt; &lt;s10&gt;Item&lt;/s10&gt; &lt;s11&gt;=&lt;/s11&gt; &lt;s12&gt;Int&lt;/s12&gt;&lt;/c8&gt; turns the abstract type of &lt;c13&gt;&lt;s14&gt;Item&lt;/s14&gt;&lt;/c13&gt; into a concrete type of &lt;c15&gt;&lt;s16&gt;Int&lt;/s16&gt;&lt;/c15&gt; for this implementation of the &lt;c17&gt;&lt;s18&gt;Container&lt;/s18&gt;&lt;/c17&gt; protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定義&lt;c8&gt;&lt;s9&gt;typealias&lt;/s9&gt; &lt;s10&gt;Item&lt;/s10&gt; &lt;s11&gt;=&lt;/s11&gt; &lt;s12&gt;Int&lt;/s12&gt;&lt;/c8&gt;は、抽象型&lt;c13&gt;&lt;s14&gt;Item&lt;/s14&gt;&lt;/c13&gt;を具象型&lt;c15&gt;&lt;s16&gt;Int&lt;/s16&gt;&lt;/c15&gt;へと、&lt;c17&gt;&lt;s18&gt;Container&lt;/s18&gt;&lt;/c17&gt;プロトコルのこの実装のために転向します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The definition of this convenience initializer makes &lt;c11&gt;&lt;s12&gt;RecipeIngredient&lt;/s12&gt;&lt;/c11&gt; instances quicker and more convenient to create, and avoids code duplication when creating several single-quantity &lt;c13&gt;&lt;s14&gt;RecipeIngredient&lt;/s14&gt;&lt;/c13&gt; instances.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この便宜イニシャライザの定義は、&lt;c11&gt;&lt;s12&gt;RecipeIngredient&lt;/s12&gt;&lt;/c11&gt;インスタンスを素早くより便利に作成されるようにします、そして数量１の&lt;c13&gt;&lt;s14&gt;RecipeIngredient&lt;/s14&gt;&lt;/c13&gt;インスタンスをいくつか作成する時にコードの繰り返しを防止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The deinitializer does not take any parameters and is written without parentheses:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デイニシャライザは、まったくパラメータを取りません、したがって丸括弧なしで書かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The designated initializer hands off to a superclass initializer to perform the same task for its own stored properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定イニシャライザは、そのスーパークラスのイニシャライザに、それ自身の格納プロパティに対して同じ作業を実行するように任せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The designated initializer makes sure that all of the subclass’s properties have a value, as per safety check 1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定イニシャライザは、安全検査１のように、サブクラスのプロパティの全てが値を持つことを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The designated initializer of a class must initialize all of the class’s declared properties and it must do so before calling any of its superclass’s designated initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるクラスの指定イニシャライザは、そのクラスの指定するプロパティのすべてを初期化しなければ成りません、そしてそれは何であれそれのスーパークラスの指定イニシャライザを呼ぶ前にそうしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The dice is rolled at the start of each loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さいころは、各ループの始まりで振られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The difference between a read and write access is usually obvious: a write access changes the location in memory, but a read access doesn’t.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>読み出しと書き込みアクセスの間の違いは、通常は明白です：書き込みアクセスはメモリ中の位置を変更します、しかし読み出しアクセスはそうしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The difference between assertions and preconditions is in when they’re checked: Assertions are checked only in debug builds, but preconditions are checked in both debug and production builds.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>表明と前提条件の間の違いは、それらが調べられる時にあります：表明はデバッグビルドにおいてのみ調べられます、しかし前提条件はデバッグおよび製品（プロダクション）ビルドの両方において調べられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The difference between instantaneous access and long-term access is that it’s possible for other code to run after a long-term access starts but before it ends, which is called &lt;e1&gt;overlap&lt;/e1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>即時アクセスと長期アクセスの違いは、ある長期アクセスが開始した後しかしそれが終わる前に他のコードに実行が可能であることです、それは&lt;e1&gt;オーバーラップ&lt;/e1&gt;と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The difference between open and public access is described below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>開放と公開アクセスの間の違いは下で解説されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The difference between strings and substrings is that, as a performance optimization, a substring can reuse part of the memory that’s used to store the original string, or part of the memory that’s used to store another substring.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列と下位文字列の違いは、性能最適化として、下位文字列はオリジナルの文字列を格納するために使われるメモリについての、または別の下位文字列を格納するために使われるメモリの一部についての再利用ができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The duration of a memory access is either instantaneous or long-term.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メモリアクセスの期間は、即時か長期のどちらかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The elements of a tuple can be referred to either by name or by number.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるタプルの要素たちは、名前または番号で言及されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The elements of an array can be accessed through subscripting by specifying a valid index value in square brackets: &lt;c2&gt;&lt;s3&gt;someArray[0]&lt;/s3&gt;&lt;/c2&gt; refers to the element at index 0, &lt;c4&gt;&lt;s5&gt;"Alex"&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列の要素は、角括弧の中に有効なインデックス値を指定することによる添え字指定を通してアクセスされることができます：&lt;c2&gt;&lt;s3&gt;someArray[0]]&lt;/s3&gt;&lt;/c2&gt;は、インデックス0での要素、&lt;c4&gt;&lt;s5&gt;"Alex"&lt;/s5&gt;&lt;/c4&gt;に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The else clause of an &lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt; statement can contain another &lt;c2&gt;&lt;s3&gt;if&lt;/s3&gt;&lt;/c2&gt; statement to test more than one condition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt;文のelse節は、複数の条件をテストするために別の&lt;c2&gt;&lt;s3&gt;if&lt;/s3&gt;&lt;/c2&gt;文を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The end result is the same, but the default value ties the property’s initialization more closely to its declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最終的な結果は同じものです、しかし省略時の値は、プロパティの初期化をより密接にその宣言に結び付けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The end result of calling this alternative version of the method will be exactly the same as for calling the earlier version.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッドのこの代替版を呼ぶ最終結果は、以前の版を呼ぶことと正確に同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The end result was two completely separate instances that contained the same numeric values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最終的な結果は２つの完全に別々のインスタンスです、そしてそれらは同じ数値を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The entire definition of the &lt;c0&gt;&lt;s1&gt;greeting(for:)&lt;/s1&gt;&lt;/c0&gt; function is the greeting message that it returns, which means it can use this shorter form.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;greeting(for:)&lt;/s1&gt;&lt;/c0&gt;関数の全体の定義は、それが返す挨拶メッセージです、それは、それがこの省略形を使用できるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The entire expression &lt;c8&gt;&lt;s9&gt;c?.property.performAction()&lt;/s9&gt;&lt;/c8&gt; has a value of an optional type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>式&lt;c8&gt;&lt;s9&gt;c?.property.performAction()&lt;/s9&gt;&lt;/c8&gt;の全体がオプショナル型の値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The entries in the capture list are initialized when the closure is created.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キャプチャリストの中の登録項目は、クロージャが作成されるときに初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The enumeration below is a refinement of the earlier &lt;c0&gt;&lt;s1&gt;CompassPoint&lt;/s1&gt;&lt;/c0&gt; enumeration, with string raw values to represent each direction’s name:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の列挙は、前の&lt;c0&gt;&lt;s1&gt;CompassPoint&lt;/s1&gt;&lt;/c0&gt;列挙の改良版で、各方位の名前を表す文字列の生の値を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The enumeration below is a refinement of the earlier &lt;c0&gt;&lt;s1&gt;Planet&lt;/s1&gt;&lt;/c0&gt; enumeration, with integer raw values to represent each planet’s order from the sun:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の列挙は、以前の&lt;c0&gt;&lt;s1&gt;Planet&lt;/s1&gt;&lt;/c0&gt;列挙の改良で、太陽からの各惑星の順番を表す整数の生の値をもちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The enumeration cases &lt;c2&gt;&lt;s3&gt;north&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;south&lt;/s5&gt;&lt;/c4&gt;, &lt;c6&gt;&lt;s7&gt;east&lt;/s7&gt;&lt;/c6&gt;, and &lt;c8&gt;&lt;s9&gt;west&lt;/s9&gt;&lt;/c8&gt; therefore also have an access level of public:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この列挙のケース節&lt;c2&gt;&lt;s3&gt;north&lt;/s3&gt;&lt;/c2&gt;、&lt;c4&gt;&lt;s5&gt;south&lt;/s5&gt;&lt;/c4&gt;、&lt;c6&gt;&lt;s7&gt;east&lt;/s7&gt;&lt;/c6&gt;、そして&lt;c8&gt;&lt;s9&gt;west&lt;/s9&gt;&lt;/c8&gt;はしたがってまた公開のアクセス水準を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The enumeration type is pattern-matched against the enumeration case patterns in the case blocks of the &lt;c4&gt;&lt;s5&gt;switch&lt;/s5&gt;&lt;/c4&gt; statement, as described in &lt;a6&gt;&lt;s7&gt;Enumeration Case Pattern&lt;/s7&gt;&lt;/a6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙型は、&lt;c4&gt;&lt;s5&gt;switch&lt;/s5&gt;&lt;/c4&gt;文のケース節ブロックにおいて、列挙ケース節パターンに対してパターンのマッチされます、&lt;a6&gt;&lt;s7&gt;列挙ケース節パターン&lt;/s7&gt;&lt;/a6&gt;で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The enumeration’s &lt;c6&gt;&lt;s7&gt;toggle&lt;/s7&gt;&lt;/c6&gt; implementation is marked as &lt;c8&gt;&lt;s9&gt;mutating&lt;/s9&gt;&lt;/c8&gt;, to match the &lt;c10&gt;&lt;s11&gt;Togglable&lt;/s11&gt;&lt;/c10&gt; protocol’s requirements:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙の&lt;c6&gt;&lt;s7&gt;toggle&lt;/s7&gt;&lt;/c6&gt;実装は、&lt;c10&gt;&lt;s11&gt;Togglable&lt;/s11&gt;&lt;/c10&gt;プロトコルの要件に適合するように、&lt;c8&gt;&lt;s9&gt;mutating&lt;/s9&gt;&lt;/c8&gt;として印されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The error is then caught by the general &lt;c10&gt;&lt;s11&gt;catch&lt;/s11&gt;&lt;/c10&gt; clause.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーは、それから一般的な&lt;c10&gt;&lt;s11&gt;catch&lt;/s11&gt;&lt;/c10&gt;節によってキャッチされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The error on the last line of the example occurs for several reasons.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例の最後の行でのエラーは、いくつかの理由で発生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The error that’s thrown continues to propagate until it’s handled by a &lt;c2&gt;&lt;s3&gt;catch&lt;/s3&gt;&lt;/c2&gt; clause of a &lt;c4&gt;&lt;s5&gt;do&lt;/s5&gt;&lt;/c4&gt; statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スローされたエラーは、それが&lt;c4&gt;&lt;s5&gt;do&lt;/s5&gt;&lt;/c4&gt;文の&lt;c2&gt;&lt;s3&gt;catch&lt;/s3&gt;&lt;/c2&gt;節によって処理されるまで伝達を続けていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The escaped special characters &lt;c0&gt;&lt;s1&gt;\0&lt;/s1&gt;&lt;/c0&gt; (null character), &lt;c2&gt;&lt;s3&gt;\\&lt;/s3&gt;&lt;/c2&gt; (backslash), &lt;c4&gt;&lt;s5&gt;\t&lt;/s5&gt;&lt;/c4&gt; (horizontal tab), &lt;c6&gt;&lt;s7&gt;\n&lt;/s7&gt;&lt;/c6&gt; (line feed), &lt;c8&gt;&lt;s9&gt;\r&lt;/s9&gt;&lt;/c8&gt; (carriage return), &lt;c10&gt;&lt;s11&gt;\"&lt;/s11&gt;&lt;/c10&gt; (double quotation mark) and &lt;c12&gt;&lt;s13&gt;\'&lt;/s13&gt;&lt;/c12&gt; (single quotation mark)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エスケープされた特殊文字の&lt;c0&gt;&lt;s1&gt;\0&lt;/s1&gt;&lt;/c0&gt;（ヌル文字）、&lt;c2&gt;&lt;s3&gt;\\&lt;/s3&gt;&lt;/c2&gt;（バックスラッシュ）、&lt;c4&gt;&lt;s5&gt;\t&lt;/s5&gt;&lt;/c4&gt;（水平タブ）、&lt;c6&gt;&lt;s7&gt;\n&lt;/s7&gt;&lt;/c6&gt;（ラインフィード）、&lt;c8&gt;&lt;s9&gt;\r&lt;/s9&gt;&lt;/c8&gt;（キャリッジリターン）、&lt;c10&gt;&lt;s11&gt;\"&lt;/s11&gt;&lt;/c10&gt;（二重引用符）と&lt;c12&gt;&lt;s13&gt;\'&lt;/s13&gt;&lt;/c12&gt;（一重引用符）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exact meaning of “subscript” depends on the context in which it is used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「添え字」の正確な意味は、それが使われる前後関係に依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above also defines a new class called &lt;c0&gt;&lt;s1&gt;VideoMode&lt;/s1&gt;&lt;/c0&gt;, to describe a specific video mode for video display.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、また、ビデオ・ディスプレイのために特定のビデオ・モードを記述するために、&lt;c0&gt;&lt;s1&gt;VideoMode&lt;/s1&gt;&lt;/c0&gt;と呼ばれる新しいクラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above calculates the value of one number to the power of another (in this case, &lt;c0&gt;&lt;s1&gt;3&lt;/s1&gt;&lt;/c0&gt; to the power of &lt;c2&gt;&lt;s3&gt;10&lt;/s3&gt;&lt;/c2&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、ある数を他のもので乗算した値を計算します（この場合、&lt;c0&gt;&lt;s1&gt;3&lt;/s1&gt;&lt;/c0&gt;の&lt;c2&gt;&lt;s3&gt;10&lt;/s3&gt;&lt;/c2&gt;乗）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above checks whether the temperature is less than or equal to 32 degrees Fahrenheit (the freezing point of water).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、温度が華氏32度（水の氷点）以下かどうか確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above counts how many cases there are, and the example below uses a &lt;c8&gt;&lt;s9&gt;for&lt;/s9&gt;&lt;/c8&gt; loop to iterate over all the cases.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、どのくらい多くのケース節があるか数えます、そして下の例は、&lt;c8&gt;&lt;s9&gt;for&lt;/s9&gt;&lt;/c8&gt;ループを使って全てのケース節にわたって反復します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above creates a &lt;c0&gt;&lt;s1&gt;Stack&lt;/s1&gt;&lt;/c0&gt; instance to store &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt; values, and pushes three strings onto the stack.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、&lt;c0&gt;&lt;s1&gt;Stack&lt;/s1&gt;&lt;/c0&gt;インスタンスをつくって&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;値を格納します、そしてスタック上へ３つの文字列をプッシュします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above creates a new &lt;c0&gt;&lt;s1&gt;Matrix&lt;/s1&gt;&lt;/c0&gt; instance with two rows and two columns.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、２つの行と２つの列で新しい&lt;c0&gt;&lt;s1&gt;Matrix&lt;/s1&gt;&lt;/c0&gt;インスタンスをつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above creates a new &lt;c0&gt;&lt;s1&gt;Rect&lt;/s1&gt;&lt;/c0&gt; variable called &lt;c2&gt;&lt;s3&gt;square&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、&lt;c2&gt;&lt;s3&gt;square&lt;/s3&gt;&lt;/c2&gt;と呼ばれる新しい&lt;c0&gt;&lt;s1&gt;Rect&lt;/s1&gt;&lt;/c0&gt;変数をつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above defines a dictionary called &lt;c0&gt;&lt;s1&gt;testScores&lt;/s1&gt;&lt;/c0&gt;, which contains two key-value pairs that map a &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt; key to an array of &lt;c4&gt;&lt;s5&gt;Int&lt;/s5&gt;&lt;/c4&gt; values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は&lt;c0&gt;&lt;s1&gt;testScores&lt;/s1&gt;&lt;/c0&gt;と呼ばれる辞書型を定義します、それは、２つの「キーと値」対を含んでいて、それは&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;キーを&lt;c4&gt;&lt;s5&gt;Int&lt;/s5&gt;&lt;/c4&gt;値を持つ配列と関連づけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above defines a new prefix operator called &lt;c0&gt;&lt;s1&gt;+++&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、&lt;c0&gt;&lt;s1&gt;+++&lt;/s1&gt;&lt;/c0&gt;と呼ばれる新しい接頭辞演算子を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above defines a new structure called &lt;c0&gt;&lt;s1&gt;Resolution&lt;/s1&gt;&lt;/c0&gt;, to describe a pixel-based display resolution.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、ピクセルに基づくディスプレイ解像度を記述するために、&lt;c0&gt;&lt;s1&gt;Resolution&lt;/s1&gt;&lt;/c0&gt;と呼ばれる新しい構造体を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above defines a variable called &lt;c0&gt;&lt;s1&gt;numberOfLegs&lt;/s1&gt;&lt;/c0&gt; and initializes it with a dictionary literal containing three key-value pairs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、&lt;c0&gt;&lt;s1&gt;numberOfLegs&lt;/s1&gt;&lt;/c0&gt;と呼ばれる変数を定義して、３つの「キーと値」の対を含んでいる辞書リテラルでそれを初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above determines whether a positive or negative step is needed to move a variable called &lt;c0&gt;&lt;s1&gt;currentValue&lt;/s1&gt;&lt;/c0&gt; progressively closer to zero.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、&lt;c0&gt;&lt;s1&gt;currentValue&lt;/s1&gt;&lt;/c0&gt;と呼ばれる変数を次第にゼロにより近く動かすために正と負の一歩のどちらが必要とされるかを確定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above implements an &lt;c0&gt;&lt;s1&gt;==&lt;/s1&gt;&lt;/c0&gt; operator to check whether two &lt;c2&gt;&lt;s3&gt;Vector2D&lt;/s3&gt;&lt;/c2&gt; instances have equivalent values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、ある&lt;c0&gt;&lt;s1&gt;==&lt;/s1&gt;&lt;/c0&gt;演算子を実装して、２つの&lt;c2&gt;&lt;s3&gt;Vector2D&lt;/s3&gt;&lt;/c2&gt;インスタンスが同等な値を持つかどうかを調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above implements the unary minus operator (&lt;c0&gt;&lt;s1&gt;-a&lt;/s1&gt;&lt;/c0&gt;) for &lt;c2&gt;&lt;s3&gt;Vector2D&lt;/s3&gt;&lt;/c2&gt; instances.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、&lt;c2&gt;&lt;s3&gt;Vector2D&lt;/s3&gt;&lt;/c2&gt;インスタンスのための単項マイナス演算子（&lt;c0&gt;&lt;s1&gt;-a&lt;/s1&gt;&lt;/c0&gt;）を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above in &lt;a0&gt;&lt;s1&gt;Accessing Properties Through Optional Chaining&lt;/s1&gt;&lt;/a0&gt; attempts to set an &lt;c2&gt;&lt;s3&gt;address&lt;/s3&gt;&lt;/c2&gt; value for &lt;c4&gt;&lt;s5&gt;john.residence&lt;/s5&gt;&lt;/c4&gt;, even though the &lt;c6&gt;&lt;s7&gt;residence&lt;/s7&gt;&lt;/c6&gt; property is &lt;c8&gt;&lt;s9&gt;nil&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;オプショナル連鎖を通してプロパティにアクセスする&lt;/s1&gt;&lt;/a0&gt;での前の例は、ある&lt;c2&gt;&lt;s3&gt;address&lt;/s3&gt;&lt;/c2&gt;値を&lt;c4&gt;&lt;s5&gt;john.residence&lt;/s5&gt;&lt;/c4&gt;に対して設定することを試みます、たとえ&lt;c6&gt;&lt;s7&gt;residence&lt;/s7&gt;&lt;/c6&gt;プロパティが&lt;c8&gt;&lt;s9&gt;nil&lt;/s9&gt;&lt;/c8&gt;であるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above is shorthand for the code below:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、下のコードの短縮形です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above shows that calling &lt;c0&gt;&lt;s1&gt;alsoIncrementByTen&lt;/s1&gt;&lt;/c0&gt; is the same as calling &lt;c2&gt;&lt;s3&gt;incrementByTen&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、&lt;c0&gt;&lt;s1&gt;alsoIncrementByTen&lt;/s1&gt;&lt;/c0&gt;を呼び出すことは&lt;c2&gt;&lt;s3&gt;incrementByTen&lt;/s3&gt;&lt;/c2&gt;を呼び出す事と同じであるのを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above shows that the original values of &lt;c0&gt;&lt;s1&gt;someInt&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;anotherInt&lt;/s3&gt;&lt;/c2&gt; are modified by the &lt;c4&gt;&lt;s5&gt;swapTwoInts(_:_:)&lt;/s5&gt;&lt;/c4&gt; function, even though they were originally defined outside of the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、&lt;c0&gt;&lt;s1&gt;someInt&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;anotherInt&lt;/s3&gt;&lt;/c2&gt;の本来の値が、たとえそれらが元々は関数の外側で定義されたとしても、&lt;c4&gt;&lt;s5&gt;swapTwoInts(_:_:)&lt;/s5&gt;&lt;/c4&gt;関数によって修正されることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above shows what happens if it is called with an input value of &lt;c2&gt;&lt;s3&gt;"Anna"&lt;/s3&gt;&lt;/c2&gt;, and an input value of &lt;c4&gt;&lt;s5&gt;"Brian"&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、それが&lt;c2&gt;&lt;s3&gt;"Anna"&lt;/s3&gt;&lt;/c2&gt;の入力値、そして&lt;c4&gt;&lt;s5&gt;"Brian"&lt;/s5&gt;&lt;/c4&gt;の入力値で呼ばれるならば、何が起こるかについて示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above uses a very simple approach to dice rolling.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、さいころ振りに対する非常に単純なアプローチを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example above uses the default initializer for the &lt;c10&gt;&lt;s11&gt;ShoppingListItem&lt;/s11&gt;&lt;/c10&gt; class to create a new instance of the class with initializer syntax, written as &lt;c12&gt;&lt;s13&gt;ShoppingListItem()&lt;/s13&gt;&lt;/c12&gt;, and assigns this new instance to a variable called &lt;c14&gt;&lt;s15&gt;item&lt;/s15&gt;&lt;/c14&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、&lt;c10&gt;&lt;s11&gt;ShoppingListItem&lt;/s11&gt;&lt;/c10&gt;クラスのための省略時のイニシャライザを使って、このクラスの新しいインスタンスを作成します、&lt;c12&gt;&lt;s13&gt;ShoppingListItem()&lt;/s13&gt;&lt;/c12&gt;のように書かれる、イニシャライザ構文の所です、そしてこの新しいインスタンスを&lt;c14&gt;&lt;s15&gt;item&lt;/s15&gt;&lt;/c14&gt;と呼ばれる変数に代入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example also creates an &lt;c4&gt;&lt;s5&gt;Array&lt;/s5&gt;&lt;/c4&gt; instance initialized with an array literal containing the same three strings as the stack.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例はまた、このスタックと同じ３つの文字列を含む配列リテラルで初期化される&lt;c4&gt;&lt;s5&gt;Array&lt;/s5&gt;&lt;/c4&gt;インスタンスをつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example also defines a &lt;c0&gt;&lt;s1&gt;wishHappyBirthday(to:)&lt;/s1&gt;&lt;/c0&gt; function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例はまた、&lt;c0&gt;&lt;s1&gt;wishHappyBirthday(to:)&lt;/s1&gt;&lt;/c0&gt;関数を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example also defines two supporting structures called &lt;c2&gt;&lt;s3&gt;Size&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;Point&lt;/s5&gt;&lt;/c4&gt;, both of which provide default values of &lt;c6&gt;&lt;s7&gt;0.0&lt;/s7&gt;&lt;/c6&gt; for all of their properties:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例はまた、&lt;c2&gt;&lt;s3&gt;Size&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;Point&lt;/s5&gt;&lt;/c4&gt;と呼ばれる２つの支援の構造体を定義します、その両方はそれらのプロパティの全てに&lt;c6&gt;&lt;s7&gt;0.0&lt;/s7&gt;&lt;/c6&gt;の省略時の値を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below adds a new mutating method called &lt;c0&gt;&lt;s1&gt;square&lt;/s1&gt;&lt;/c0&gt; to Swift’s &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt; type, which squares the original value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、&lt;c0&gt;&lt;s1&gt;square&lt;/s1&gt;&lt;/c0&gt;と呼ばれる新しい変更メソッドをスウィフトの&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;型に加えます、それは、もとの値を二乗します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below calculates the &lt;e0&gt;arithmetic mean&lt;/e0&gt; (also known as the &lt;e1&gt;average&lt;/e1&gt;) for a list of numbers of any length:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、どんな長さの数のリストに対しても、&lt;e0&gt;算術平均&lt;/e0&gt;（また&lt;e1&gt;平均&lt;/e1&gt;としても知られるもの）を計算します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below calls the &lt;c0&gt;&lt;s1&gt;Address&lt;/s1&gt;&lt;/c0&gt; class’s &lt;c2&gt;&lt;s3&gt;buildingIdentifier()&lt;/s3&gt;&lt;/c2&gt; method through optional chaining.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、オプショナル連鎖を通して&lt;c0&gt;&lt;s1&gt;Address&lt;/s1&gt;&lt;/c0&gt;クラスの&lt;c2&gt;&lt;s3&gt;buildingIdentifier()&lt;/s3&gt;&lt;/c2&gt;メソッドを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below categorizes an (x, y) point on the following graph:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、続くグラフ上でポイント(x, y)を分類します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below creates a dictionary to store the names of international airports.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、国際空港の名前を格納するための辞書を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below creates a set called &lt;c0&gt;&lt;s1&gt;favoriteGenres&lt;/s1&gt;&lt;/c0&gt; to store &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt; values:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、&lt;c0&gt;&lt;s1&gt;favoriteGenres&lt;/s1&gt;&lt;/c0&gt;と呼ばれる集合を&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;値を格納するために作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below creates an array called &lt;c0&gt;&lt;s1&gt;shoppingList&lt;/s1&gt;&lt;/c0&gt; to store &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt; values:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;値を格納する&lt;c0&gt;&lt;s1&gt;shoppingList&lt;/s1&gt;&lt;/c0&gt;と呼ばれる配列をつくります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a &lt;c0&gt;&lt;s1&gt;Vector3D&lt;/s1&gt;&lt;/c0&gt; structure for a three-dimensional position vector &lt;c2&gt;&lt;s3&gt;(x,&lt;/s3&gt; &lt;s4&gt;y,&lt;/s4&gt; &lt;s5&gt;z)&lt;/s5&gt;&lt;/c2&gt;, similar to the &lt;c6&gt;&lt;s7&gt;Vector2D&lt;/s7&gt;&lt;/c6&gt; structure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、&lt;c0&gt;&lt;s1&gt;Vector3D&lt;/s1&gt;&lt;/c0&gt;構造体を３次元の位置ベクトル&lt;c2&gt;&lt;s3&gt;(x,&lt;/s3&gt; &lt;s4&gt;y,&lt;/s4&gt; &lt;s5&gt;z)&lt;/s5&gt;&lt;/c2&gt;に対して定義します、&lt;c6&gt;&lt;s7&gt;Vector2D&lt;/s7&gt;&lt;/c6&gt;構造体に似たものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a base class called &lt;c0&gt;&lt;s1&gt;Vehicle&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、&lt;c0&gt;&lt;s1&gt;Vehicle&lt;/s1&gt;&lt;/c0&gt;と呼ばれる基盤クラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a class called &lt;c0&gt;&lt;s1&gt;Document&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、&lt;c0&gt;&lt;s1&gt;Document&lt;/s1&gt;&lt;/c0&gt;と呼ばれるクラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a custom &lt;c0&gt;&lt;s1&gt;Rect&lt;/s1&gt;&lt;/c0&gt; structure to represent a geometric rectangle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、幾何学の長方形を表すためにあつらえの&lt;c0&gt;&lt;s1&gt;Rect&lt;/s1&gt;&lt;/c0&gt;構造体を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a function called &lt;c0&gt;&lt;s1&gt;minMax(array:)&lt;/s1&gt;&lt;/c0&gt;, which finds the smallest and largest numbers in an array of &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt; values:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は&lt;c0&gt;&lt;s1&gt;minMax(array:)&lt;/s1&gt;&lt;/c0&gt;と呼ばれる関数を定義します、それは、ある&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;値の配列の中で最小および最大の数を見つけます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a generic function called &lt;c0&gt;&lt;s1&gt;allItemsMatch&lt;/s1&gt;&lt;/c0&gt;, which checks to see if two &lt;c2&gt;&lt;s3&gt;Container&lt;/s3&gt;&lt;/c2&gt; instances contain the same items in the same order.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は&lt;c0&gt;&lt;s1&gt;allItemsMatch&lt;/s1&gt;&lt;/c0&gt;と呼ばれる総称体関数を定義します、それは、２つの&lt;c2&gt;&lt;s3&gt;Container&lt;/s3&gt;&lt;/c2&gt;インスタンスが同じ順序で同じ項目を含むかどうか見るために調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a global function called &lt;c0&gt;&lt;s1&gt;someFunction()&lt;/s1&gt;&lt;/c0&gt;, without providing a specific access-level modifier for the function itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、その関数自身に特定のアクセス水準修飾子を提供することなく、&lt;c0&gt;&lt;s1&gt;someFunction()&lt;/s1&gt;&lt;/c0&gt;と呼ばれるグローバル関数を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a new class called &lt;c4&gt;&lt;s5&gt;StepCounter&lt;/s5&gt;&lt;/c4&gt;, which tracks the total number of steps that a person takes while walking.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、&lt;c4&gt;&lt;s5&gt;StepCounter&lt;/s5&gt;&lt;/c4&gt;と呼ばれる新しいクラスを定義します、それは、ある人が歩いている間にとる総歩数を追跡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a new structure called &lt;c0&gt;&lt;s1&gt;Fahrenheit&lt;/s1&gt;&lt;/c0&gt; to store temperatures expressed in the Fahrenheit scale.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、&lt;c0&gt;&lt;s1&gt;Fahrenheit&lt;/s1&gt;&lt;/c0&gt;と呼ばれる新しい構造体を定義して、華氏尺度で表される温度を格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a protocol called &lt;c0&gt;&lt;s1&gt;Togglable&lt;/s1&gt;&lt;/c0&gt;, which defines a single instance method requirement called &lt;c2&gt;&lt;s3&gt;toggle&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、&lt;c0&gt;&lt;s1&gt;Togglable&lt;/s1&gt;&lt;/c0&gt;と呼ばれるプロトコルを定義します、それは、&lt;c2&gt;&lt;s3&gt;toggle&lt;/s3&gt;&lt;/c2&gt;と呼ばれる１つのインスタンスメソッド要件を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a structure called &lt;c0&gt;&lt;s1&gt;Animal&lt;/s1&gt;&lt;/c0&gt;, with a constant &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt; property called &lt;c4&gt;&lt;s5&gt;species&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、&lt;c0&gt;&lt;s1&gt;Animal&lt;/s1&gt;&lt;/c0&gt;と呼ばれるある構造体を、&lt;c4&gt;&lt;s5&gt;species&lt;/s5&gt;&lt;/c4&gt;と呼ばれる定数&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;プロパティを使って定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a structure called &lt;c0&gt;&lt;s1&gt;BlackjackCard&lt;/s1&gt;&lt;/c0&gt;, which models a playing card as used in the game of Blackjack.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下記の例は&lt;c0&gt;&lt;s1&gt;BlackjackCard&lt;/s1&gt;&lt;/c0&gt;と呼ばれる構造体を定義します、それは、「ブラックジャック」ゲームにおいて使われるときの遊戯カード、トランプカードをモデル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a structure called &lt;c0&gt;&lt;s1&gt;Chessboard&lt;/s1&gt;&lt;/c0&gt;, which models a board for the game of chess.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は&lt;c0&gt;&lt;s1&gt;Chessboard&lt;/s1&gt;&lt;/c0&gt;と呼ばれる構造体を定義します、それは、「チェス」ゲーム用の盤をモデル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a structure called &lt;c0&gt;&lt;s1&gt;FixedLengthRange&lt;/s1&gt;&lt;/c0&gt;, which describes a range of integers whose range length cannot be changed after it is created:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は&lt;c0&gt;&lt;s1&gt;FixedLengthRange&lt;/s1&gt;&lt;/c0&gt;と呼ばれる構造体を定義します、それは、それが作成された後に範囲長が変更されることが出来ない、整数からなるある範囲を記述します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a structure called &lt;c0&gt;&lt;s1&gt;LevelTracker&lt;/s1&gt;&lt;/c0&gt;, which tracks a player’s progress through the different levels or stages of a game.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は&lt;c0&gt;&lt;s1&gt;LevelTracker&lt;/s1&gt;&lt;/c0&gt;と呼ばれる構造体を定義します、それは、プレイヤーの進み具合をゲームの異なるレベルまたはステージを通して追跡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a structure called &lt;c0&gt;&lt;s1&gt;Size&lt;/s1&gt;&lt;/c0&gt; with two properties called &lt;c2&gt;&lt;s3&gt;width&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;height&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、&lt;c2&gt;&lt;s3&gt;width&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;height&lt;/s5&gt;&lt;/c4&gt;と呼ばれる２つのプロパティをもつ&lt;c0&gt;&lt;s1&gt;Size&lt;/s1&gt;&lt;/c0&gt;と呼ばれる構造体を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a structure called &lt;c0&gt;&lt;s1&gt;TrackedString&lt;/s1&gt;&lt;/c0&gt;, which keeps track of the number of times a string property is modified:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は&lt;c0&gt;&lt;s1&gt;TrackedString&lt;/s1&gt;&lt;/c0&gt;と呼ばれる構造体を定義します、それは、ある文字列プロパティが修正される回数を追跡します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines a subclass of &lt;c0&gt;&lt;s1&gt;Product&lt;/s1&gt;&lt;/c0&gt; called &lt;c2&gt;&lt;s3&gt;CartItem&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、&lt;c2&gt;&lt;s3&gt;CartItem&lt;/s3&gt;&lt;/c2&gt;と呼ばれる&lt;c0&gt;&lt;s1&gt;Product&lt;/s1&gt;&lt;/c0&gt;のサブクラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines an enumeration called &lt;c0&gt;&lt;s1&gt;OnOffSwitch&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、&lt;c0&gt;&lt;s1&gt;OnOffSwitch&lt;/s1&gt;&lt;/c0&gt;と呼ばれる列挙を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines an enumeration called &lt;c0&gt;&lt;s1&gt;TemperatureUnit&lt;/s1&gt;&lt;/c0&gt;, with three possible states (&lt;c2&gt;&lt;s3&gt;kelvin&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;celsius&lt;/s5&gt;&lt;/c4&gt;, and &lt;c6&gt;&lt;s7&gt;fahrenheit&lt;/s7&gt;&lt;/c6&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、３つの可能な状態（&lt;c2&gt;&lt;s3&gt;kelvin&lt;/s3&gt;&lt;/c2&gt;、&lt;c4&gt;&lt;s5&gt;celsius&lt;/s5&gt;&lt;/c4&gt;、そして&lt;c6&gt;&lt;s7&gt;fahrenheit&lt;/s7&gt;&lt;/c6&gt;）を持つ、&lt;c0&gt;&lt;s1&gt;TemperatureUnit&lt;/s1&gt;&lt;/c0&gt;と呼ばれる列挙を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines two classes, &lt;c0&gt;&lt;s1&gt;Country&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;City&lt;/s3&gt;&lt;/c2&gt;, each of which stores an instance of the other class as a property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は２つのクラス、&lt;c0&gt;&lt;s1&gt;Country&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;City&lt;/s3&gt;&lt;/c2&gt;を定義します、そして、そのそれぞれは他のクラスのインスタンスをプロパティとして格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines two protocols for use with dice-based board games:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、さいころに基づく様々なボードゲームで使うために、２つのプロトコルを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below defines two variables, &lt;c0&gt;&lt;s1&gt;movieCount&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;songCount&lt;/s3&gt;&lt;/c2&gt;, which count the number of &lt;c4&gt;&lt;s5&gt;Movie&lt;/s5&gt;&lt;/c4&gt; and &lt;c6&gt;&lt;s7&gt;Song&lt;/s7&gt;&lt;/c6&gt; instances in the &lt;c8&gt;&lt;s9&gt;library&lt;/s9&gt;&lt;/c8&gt; array:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は２つの変数、&lt;c0&gt;&lt;s1&gt;movieCount&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;songCountを&lt;/s3&gt;&lt;/c2&gt;定義します、それは、&lt;c4&gt;&lt;s5&gt;Movie&lt;/s5&gt;&lt;/c4&gt;と&lt;c6&gt;&lt;s7&gt;Song&lt;/s7&gt;&lt;/c6&gt;インスタンスの数を&lt;c8&gt;&lt;s9&gt;library&lt;/s9&gt;&lt;/c8&gt;配列において数えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below exposes the getter for the &lt;c8&gt;&lt;s9&gt;enabled&lt;/s9&gt;&lt;/c8&gt; property of the &lt;c10&gt;&lt;s11&gt;ExampleClass&lt;/s11&gt;&lt;/c10&gt; to Objective-C code as &lt;c12&gt;&lt;s13&gt;isEnabled&lt;/s13&gt;&lt;/c12&gt; rather than just as the name of the property itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、&lt;c10&gt;&lt;s11&gt;ExampleClass&lt;/s11&gt;&lt;/c10&gt;の&lt;c8&gt;&lt;s9&gt;enabled&lt;/s9&gt;&lt;/c8&gt;プロパティのためのゲッターをObjective-Cコードに、ただプロパティそれ自身の名前ではなく&lt;c12&gt;&lt;s13&gt;isEnabled&lt;/s13&gt;&lt;/c12&gt;として露出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below extends the &lt;c2&gt;&lt;s3&gt;Container&lt;/s3&gt;&lt;/c2&gt; protocol from the previous examples to add a &lt;c4&gt;&lt;s5&gt;startsWith(_:)&lt;/s5&gt;&lt;/c4&gt; method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、以前の例の&lt;c2&gt;&lt;s3&gt;Container&lt;/s3&gt;&lt;/c2&gt;プロトコルを拡張して、&lt;c4&gt;&lt;s5&gt;startsWith(_:)&lt;/s5&gt;&lt;/c4&gt;メソッドを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below extends the generic &lt;c2&gt;&lt;s3&gt;Stack&lt;/s3&gt;&lt;/c2&gt; structure from the previous examples to add an &lt;c4&gt;&lt;s5&gt;isTop(_:)&lt;/s5&gt;&lt;/c4&gt; method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、以前の例の総称体&lt;c2&gt;&lt;s3&gt;Stack&lt;/s3&gt;&lt;/c2&gt;構造体を拡張して、&lt;c4&gt;&lt;s5&gt;isTop(_:)&lt;/s5&gt;&lt;/c4&gt;メソッドを加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below implements an addition assignment operator method for &lt;c0&gt;&lt;s1&gt;Vector2D&lt;/s1&gt;&lt;/c0&gt; instances:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、&lt;c0&gt;&lt;s1&gt;Vector2D&lt;/s1&gt;&lt;/c0&gt;インスタンスのために追加代入演算子メソッドを実装します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below is identical to the &lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;Apartment&lt;/s3&gt;&lt;/c2&gt; example from above, with one important difference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、上記の&lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;Apartment&lt;/s3&gt;&lt;/c2&gt;例に同一ですが、１つの重要な違いがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below iterates over each &lt;c0&gt;&lt;s1&gt;MediaItem&lt;/s1&gt;&lt;/c0&gt; in &lt;c2&gt;&lt;s3&gt;library&lt;/s3&gt;&lt;/c2&gt;, and prints an appropriate description for each item.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、上に&lt;c2&gt;&lt;s3&gt;library&lt;/s3&gt;&lt;/c2&gt;の中の各々の&lt;c0&gt;&lt;s1&gt;MediaItem&lt;/s1&gt;&lt;/c0&gt;すべてに繰り返して、各項目の適切な説明を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below iterates over the items in the &lt;c10&gt;&lt;s11&gt;things&lt;/s11&gt;&lt;/c10&gt; array and queries the type of each item with a &lt;c12&gt;&lt;s13&gt;switch&lt;/s13&gt;&lt;/c12&gt; statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、&lt;c10&gt;&lt;s11&gt;things&lt;/s11&gt;&lt;/c10&gt;配列の中の項目のすべてに渡って繰り返して、&lt;c12&gt;&lt;s13&gt;switch&lt;/s13&gt;&lt;/c12&gt;文を使って各項目の型について問い合わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows a closure expression version of the &lt;c0&gt;&lt;s1&gt;backward(_:_:)&lt;/s1&gt;&lt;/c0&gt; function from above:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下記の例は、上の&lt;c0&gt;&lt;s1&gt;backward(_:_:)&lt;/s1&gt;&lt;/c0&gt;関数のクロージャ式版を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows a simplified version of the Swift standard library’s generic dictionary type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、スウィフト標準ライブラリの総称体辞書型の簡略版を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows a version of the &lt;c0&gt;&lt;s1&gt;TrackedString&lt;/s1&gt;&lt;/c0&gt; structure in which the structure is defined with an explicit access level of public.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、&lt;c0&gt;&lt;s1&gt;TrackedString&lt;/s1&gt;&lt;/c0&gt;構造体のある改作を示します、そこにおいてこの構造体は公開の明示的なアクセス水準を使って定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows an &lt;c6&gt;&lt;s7&gt;init?&lt;/s7&gt;&lt;/c6&gt; failable initializer that produces an optional instance of a structure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、ある構造体のオプショナルインスタンスを生成する、失敗できるイニシャライザ&lt;c6&gt;&lt;s7&gt;init?&lt;/s7&gt;&lt;/c6&gt;を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows how to implement the arithmetic addition operator (&lt;c0&gt;&lt;s1&gt;+&lt;/s1&gt;&lt;/c0&gt;) for a custom structure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、あつらえの構造体のために算術加算演算子（&lt;c0&gt;&lt;s1&gt;+&lt;/s1&gt;&lt;/c0&gt;）を実装する方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows how you can create a strong reference cycle when using a closure that references &lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、&lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;に参照をつけるクロージャを使うとき、あなたがどのように強い参照循環をつくることができるかについて示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows how you define and call a type subscript:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、どのようにあなたが型添え字を定義して呼び出すかを示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below shows the syntax for stored and computed type properties:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、格納型プロパティおよび計算型プロパティのための構文を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below takes an (x, y) point, expressed as a simple tuple of type &lt;c0&gt;&lt;s1&gt;(Int,&lt;/s1&gt; &lt;s2&gt;Int)&lt;/s2&gt;&lt;/c0&gt;, and categorizes it on the graph that follows the example.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、ポイント(x, y)、型&lt;c0&gt;&lt;s1&gt;(Int,&lt;/s1&gt; &lt;s2&gt;Int)&lt;/s2&gt;&lt;/c0&gt;の単純なタプルとして表されるもの、をとって、その例に続くグラフ上でそれを分類します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below takes an (x, y) point, expressed as a tuple of type &lt;c0&gt;&lt;s1&gt;(Int,&lt;/s1&gt; &lt;s2&gt;Int)&lt;/s2&gt;&lt;/c0&gt;, and categorizes it on the graph that follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下記の例は、ポイント(x, y)をとって、型&lt;c0&gt;&lt;s1&gt;(Int,&lt;/s1&gt; &lt;s2&gt;Int)&lt;/s2&gt;&lt;/c0&gt;のタプルとして表し、それをあとに続くグラフに分類します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below tries to access the &lt;c0&gt;&lt;s1&gt;street&lt;/s1&gt;&lt;/c0&gt; property of the &lt;c2&gt;&lt;s3&gt;address&lt;/s3&gt;&lt;/c2&gt; property of the &lt;c4&gt;&lt;s5&gt;residence&lt;/s5&gt;&lt;/c4&gt; property of &lt;c6&gt;&lt;s7&gt;john&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、&lt;c6&gt;&lt;s7&gt;john&lt;/s7&gt;&lt;/c6&gt;の&lt;c4&gt;&lt;s5&gt;residence&lt;/s5&gt;&lt;/c4&gt;プロパティの&lt;c2&gt;&lt;s3&gt;address&lt;/s3&gt;&lt;/c2&gt;プロパティの&lt;c0&gt;&lt;s1&gt;street&lt;/s1&gt;&lt;/c0&gt;プロパティにアクセスしようとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below tries to retrieve the name of the first room in the &lt;c0&gt;&lt;s1&gt;rooms&lt;/s1&gt;&lt;/c0&gt; array of the &lt;c2&gt;&lt;s3&gt;john.residence&lt;/s3&gt;&lt;/c2&gt; property using the subscript defined on the &lt;c4&gt;&lt;s5&gt;Residence&lt;/s5&gt;&lt;/c4&gt; class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、&lt;c4&gt;&lt;s5&gt;Residence&lt;/s5&gt;&lt;/c4&gt;クラス上で定義される添え字を使って、&lt;c2&gt;&lt;s3&gt;john.residence&lt;/s3&gt;&lt;/c2&gt;プロパティの&lt;c0&gt;&lt;s1&gt;rooms&lt;/s1&gt;&lt;/c0&gt;配列での最初の部屋の名前を取り出そうとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below uses &lt;c2&gt;&lt;s3&gt;fallthrough&lt;/s3&gt;&lt;/c2&gt; to create a textual description of a number.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、&lt;c2&gt;&lt;s3&gt;fallthrough&lt;/s3&gt;&lt;/c2&gt;をある数の文章での説明をつくるために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below uses a lazy stored property to avoid unnecessary initialization of a complex class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、ある複雑なクラスの必要でない初期化を避けるために遅延格納プロパティを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below uses the initializer to try to convert a &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; into an &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、このイニシャライザを使用して&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;を&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;に変えることを試みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example below uses the nil-coalescing operator to choose between a default color name and an optional user-defined color name:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、nil合体演算子を、省略時の色の名前とオプショナルの利用者定義の色の名前とで選択するために使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example can be read as:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、次のように解釈されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example creates an array called &lt;c2&gt;&lt;s3&gt;things&lt;/s3&gt;&lt;/c2&gt;, which can store values of type &lt;c4&gt;&lt;s5&gt;Any&lt;/s5&gt;&lt;/c4&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は&lt;c2&gt;&lt;s3&gt;things&lt;/s3&gt;&lt;/c2&gt;と呼ばれる配列をつくります、それは、&lt;c4&gt;&lt;s5&gt;Any&lt;/s5&gt;&lt;/c4&gt;型の値を格納することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example defines a &lt;c0&gt;&lt;s1&gt;Vector2D&lt;/s1&gt;&lt;/c0&gt; structure for a two-dimensional position vector &lt;c2&gt;&lt;s3&gt;(x,&lt;/s3&gt; &lt;s4&gt;y)&lt;/s4&gt;&lt;/c2&gt;, followed by a definition of an &lt;e5&gt;operator method&lt;/e5&gt; to add together instances of the &lt;c6&gt;&lt;s7&gt;Vector2D&lt;/s7&gt;&lt;/c6&gt; structure:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例は、２次元の位置ベクトル&lt;c2&gt;&lt;s3&gt;(x,&lt;/s3&gt; &lt;s4&gt;y)&lt;/s4&gt;&lt;/c2&gt;のための&lt;c0&gt;&lt;s1&gt;Vector2D&lt;/s1&gt;&lt;/c0&gt;構造体を定義します。そして、&lt;c6&gt;&lt;s7&gt;Vector2D&lt;/s7&gt;&lt;/c6&gt;構造体のインスタンスたちを１つに加えるための&lt;e5&gt;演算子メソッド&lt;/e5&gt;の定義が続きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example requires two supporting structures called &lt;c2&gt;&lt;s3&gt;Size&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;Point&lt;/s5&gt;&lt;/c4&gt;, both of which provide default values of &lt;c6&gt;&lt;s7&gt;0.0&lt;/s7&gt;&lt;/c6&gt; for all of their properties:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、&lt;c2&gt;&lt;s3&gt;Size&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;Point&lt;/s5&gt;&lt;/c4&gt;と呼ばれる２つの補助する構造体を必要とします、その両方はそれらのプロパティすべてに&lt;c6&gt;&lt;s7&gt;0.0&lt;/s7&gt;&lt;/c6&gt;の省略時の値を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example shown above demonstrates a custom implementation of a binary infix operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上で示される例は、二項接中辞演算子のあつらえの実装を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example shows how the &lt;c0&gt;&lt;s1&gt;==&lt;/s1&gt;&lt;/c0&gt; operator isn’t available—it depends on specific type information that isn’t preserved by using a protocol type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、どのように&lt;c0&gt;&lt;s1&gt;==&lt;/s1&gt;&lt;/c0&gt;演算子が利用可能でないか示します — それは具体的な型情報に依存します、それはプロトコル型を使うことでは保全されないものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example starts by trying to downcast the current &lt;c0&gt;&lt;s1&gt;item&lt;/s1&gt;&lt;/c0&gt; as a &lt;c2&gt;&lt;s3&gt;Movie&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例は、現在の&lt;c0&gt;&lt;s1&gt;item&lt;/s1&gt;&lt;/c0&gt;を&lt;c2&gt;&lt;s3&gt;Movie&lt;/s3&gt;&lt;/c2&gt;としてダウンキャストすることを試みることによって始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example then creates a new &lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt; instance called &lt;c2&gt;&lt;s3&gt;birthdayPerson&lt;/s3&gt;&lt;/c2&gt; and passes this new instance to the &lt;c4&gt;&lt;s5&gt;wishHappyBirthday(to:)&lt;/s5&gt;&lt;/c4&gt; function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、それから&lt;c2&gt;&lt;s3&gt;birthdayPerson&lt;/s3&gt;&lt;/c2&gt;と呼ばれる新しい&lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt;インスタンスをつくって、この新しいインスタンスを&lt;c4&gt;&lt;s5&gt;wishHappyBirthday(to:)&lt;/s5&gt;&lt;/c4&gt;関数に渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The example uses optional chaining to set the first item in the &lt;c6&gt;&lt;s7&gt;"Dave"&lt;/s7&gt;&lt;/c6&gt; array to &lt;c8&gt;&lt;s9&gt;91&lt;/s9&gt;&lt;/c8&gt;; to increment the first item in the &lt;c10&gt;&lt;s11&gt;"Bev"&lt;/s11&gt;&lt;/c10&gt; array by &lt;c12&gt;&lt;s13&gt;1&lt;/s13&gt;&lt;/c12&gt;; and to try to set the first item in an array for a key of &lt;c14&gt;&lt;s15&gt;"Brian"&lt;/s15&gt;&lt;/c14&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、オプショナル連鎖を使って&lt;c6&gt;&lt;s7&gt;"Dave"&lt;/s7&gt;&lt;/c6&gt;配列の最初の項目を&lt;c8&gt;&lt;s9&gt;91&lt;/s9&gt;&lt;/c8&gt;に設定します；それから&lt;c10&gt;&lt;s11&gt;"Bev"&lt;/s11&gt;&lt;/c10&gt;配列の最初の項目を&lt;c12&gt;&lt;s13&gt;1&lt;/s13&gt;&lt;/c12&gt;だけ増加します；そしてそれから&lt;c14&gt;&lt;s15&gt;"Brian"&lt;/s15&gt;&lt;/c14&gt;のキーに対応する配列の最初の項目を設定することを試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The examples above show how to use &lt;e0&gt;safe&lt;/e0&gt; unowned references.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例は、どのように&lt;e0&gt;safe&lt;/e0&gt;非所有参照を使うかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The examples below consider an array of strings representing the scene locations from the first two acts of Shakespeare’s &lt;e0&gt;Romeo and Juliet&lt;/e0&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の例は、シェークスピアの&lt;e0&gt;ロミオとジュリエット&lt;/e0&gt;の最初の２幕から、場面場所を表している文字列の配列を考えてみます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The examples for weak and unowned references above cover two of the more common scenarios in which it’s necessary to break a strong reference cycle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の弱いおよび非所有参照のための例は、強い参照循環を壊すために不可欠なよくある筋書きのうちの２つを扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The examples in the previous section show how the cases of an enumeration are a defined (and typed) value in their own right.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>前の節での例は、列挙のケース節がどのように自分だけで定義された（そして型付けされた）値であるかについて示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The examples that follow use two stored type properties as part of a structure that models an audio level meter for a number of audio channels.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あとに続く例は、いくつかのオーディオ・チャンネル用のオーディオ・レベルをモデル化する構造体の一部として、２つの格納型プロパティを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exclamation point effectively says, “I know that this optional definitely has a value; please use it.” This is known as &lt;e3&gt;forced unwrapping&lt;/e3&gt; of the optional’s value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>感嘆符は、実際上こう言っています、「私はこのオプショナルが間違いなくひとつの値を持つことを知っています；どうぞそれを使ってください」。これは、そのオプショナルの所有する値の&lt;e3&gt;強制アンラップ&lt;/e3&gt;として知られます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exponent consists of an upper- or lowercase &lt;c2&gt;&lt;s3&gt;e&lt;/s3&gt;&lt;/c2&gt; prefix followed by a sequence of decimal digits that indicates what power of 10 the value preceding the &lt;c4&gt;&lt;s5&gt;e&lt;/s5&gt;&lt;/c4&gt; is multiplied by.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指数は、大文字または小文字の接頭辞&lt;c2&gt;&lt;s3&gt;e&lt;/s3&gt;&lt;/c2&gt;、それに続けて&lt;c4&gt;&lt;s5&gt;e&lt;/s5&gt;&lt;/c4&gt;の前の値が10の何乗を掛けられるかを示す一連の10進の桁から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exponent consists of an upper- or lowercase &lt;c2&gt;&lt;s3&gt;p&lt;/s3&gt;&lt;/c2&gt; prefix followed by a sequence of decimal digits that indicates what power of 2 the value preceding the &lt;c4&gt;&lt;s5&gt;p&lt;/s5&gt;&lt;/c4&gt; is multiplied by.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指数は、大文字または小文字の&lt;c2&gt;&lt;s3&gt;p&lt;/s3&gt;&lt;/c2&gt;接頭辞、それに続けて&lt;c4&gt;&lt;s5&gt;p&lt;/s5&gt;&lt;/c4&gt;の前の値が２の何乗を掛けられるかを示す一連の10進の桁から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expression &lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt; &lt;s2&gt;+=&lt;/s2&gt; &lt;s3&gt;2&lt;/s3&gt;&lt;/c0&gt; is shorthand for &lt;c4&gt;&lt;s5&gt;a&lt;/s5&gt; &lt;s6&gt;=&lt;/s6&gt; &lt;s7&gt;a&lt;/s7&gt; &lt;s8&gt;+&lt;/s8&gt; &lt;s9&gt;2&lt;/s9&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>式&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt; &lt;s2&gt;+=&lt;/s2&gt; &lt;s3&gt;2&lt;/s3&gt;&lt;/c0&gt;は、&lt;c4&gt;&lt;s5&gt;a&lt;/s5&gt; &lt;s6&gt;=&lt;/s6&gt; &lt;s7&gt;a&lt;/s7&gt; &lt;s8&gt;+&lt;/s8&gt; &lt;s9&gt;2&lt;/s9&gt;&lt;/c4&gt;の簡略な表現です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expression &lt;c13&gt;&lt;s14&gt;a&lt;/s14&gt;&lt;/c13&gt; is always of an optional type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c13&gt;&lt;s14&gt;a&lt;/s14&gt;&lt;/c13&gt;の式は常にオプショナル型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expression &lt;c15&gt;&lt;s16&gt;b&lt;/s16&gt;&lt;/c15&gt; must match the type that is stored inside &lt;c17&gt;&lt;s18&gt;a&lt;/s18&gt;&lt;/c17&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c15&gt;&lt;s16&gt;b&lt;/s16&gt;&lt;/c15&gt;の式は&lt;c17&gt;&lt;s18&gt;a&lt;/s18&gt;&lt;/c17&gt;の中に格納される型に合致しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expression is evaluated when the closure is created, and the value is captured with the specified strength.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その式は、クロージャが作成される時に評価されます、そしてその値は、指定された強さでキャプチャされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expression represented by the expression pattern is compared with the value of an input expression using the Swift standard library &lt;c0&gt;&lt;s1&gt;~=&lt;/s1&gt;&lt;/c0&gt; operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>式パターンによって表される式は、入力された式の値とスウィフト標準ライブラリ&lt;c0&gt;&lt;s1&gt;~=&lt;/s1&gt;&lt;/c0&gt;演算子を使って比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expressions you write inside parentheses within an interpolated string can’t contain an unescaped backslash (&lt;c0&gt;&lt;s1&gt;\&lt;/s1&gt;&lt;/c0&gt;), a carriage return, or a line feed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>補間文字列においてあなたが丸括弧内に記述する式は、エスケープされないバックスラッシュ（&lt;c0&gt;&lt;s1&gt;\&lt;/s1&gt;&lt;/c0&gt;）、キャリッジリターン、またはラインフィードを含むことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fact that &lt;c2&gt;&lt;s3&gt;asHTML&lt;/s3&gt;&lt;/c2&gt; is a lazy property means that you can refer to &lt;c4&gt;&lt;s5&gt;self&lt;/s5&gt;&lt;/c4&gt; within the default closure, because the lazy property will not be accessed until after initialization has been completed and &lt;c6&gt;&lt;s7&gt;self&lt;/s7&gt;&lt;/c6&gt; is known to exist.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;asHTML&lt;/s3&gt;&lt;/c2&gt;が遅延プロパティだという事実は、あなたが省略時のクロージャ内で&lt;c4&gt;&lt;s5&gt;self&lt;/s5&gt;&lt;/c4&gt;に言及することができることを意味します、なぜなら、遅延プロパティは、初期化が完了されてしまって&lt;c6&gt;&lt;s7&gt;self&lt;/s7&gt;&lt;/c6&gt;が存在することを知られる後までアクセスされることはないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fact that it is queried through an optional chain means that the call to &lt;c4&gt;&lt;s5&gt;numberOfRooms&lt;/s5&gt;&lt;/c4&gt; will always return an &lt;c6&gt;&lt;s7&gt;Int?&lt;/s7&gt;&lt;/c6&gt; instead of an &lt;c8&gt;&lt;s9&gt;Int&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それがオプショナル連鎖によって問い合わせられるという事実は、&lt;c4&gt;&lt;s5&gt;numberOfRooms&lt;/s5&gt;&lt;/c4&gt;への呼び出しが常に&lt;c6&gt;&lt;s7&gt;Int?&lt;/s7&gt;&lt;/c6&gt;を返すことを意味します、&lt;c8&gt;&lt;s9&gt;Int&lt;/s9&gt;&lt;/c8&gt;ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fact that structures and enumerations can define methods in Swift is a major difference from C and Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体と列挙がスウィフトにおいてはメソッドを定義することができるという事実は、CやObjective-Cとの重大な違いです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The failable initializer for &lt;c0&gt;&lt;s1&gt;CartItem&lt;/s1&gt;&lt;/c0&gt; starts by validating that it has received a &lt;c2&gt;&lt;s3&gt;quantity&lt;/s3&gt;&lt;/c2&gt; value of &lt;c4&gt;&lt;s5&gt;1&lt;/s5&gt;&lt;/c4&gt; or more.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;CartItem&lt;/s1&gt;&lt;/c0&gt;のための失敗できるイニシャライザは、それが&lt;c4&gt;&lt;s5&gt;1&lt;/s5&gt;&lt;/c4&gt;以上の&lt;c2&gt;&lt;s3&gt;quantity&lt;/s3&gt;&lt;/c2&gt;値を受け取ったことを検証することによって始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fifth and sixth &lt;c0&gt;&lt;s1&gt;codeUnit&lt;/s1&gt;&lt;/c0&gt; values (&lt;c2&gt;&lt;s3&gt;55357&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;56374&lt;/s5&gt;&lt;/c4&gt;) are a UTF-16 surrogate pair representation of the &lt;c6&gt;&lt;s7&gt;DOG&lt;/s7&gt; &lt;s8&gt;FACE&lt;/s8&gt;&lt;/c6&gt; character.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>５番目と６番目の&lt;c0&gt;&lt;s1&gt;codeUnit&lt;/s1&gt;&lt;/c0&gt;値（&lt;c2&gt;&lt;s3&gt;55357&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;56374&lt;/s5&gt;&lt;/c4&gt;）は、&lt;c6&gt;&lt;s7&gt;DOG&lt;/s7&gt; &lt;s8&gt;FACE&lt;/s8&gt;&lt;/c6&gt;文字のUTF-16代用対叙述です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The figure below illustrates how two of these audio channels can be combined to model a stereo audio level meter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の図は、これらの音声のチャンネルのうちの２つがステレオ音声のレベル・メーターをモデル化するために結合されることができる方法を図示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The figure below shows a more complex class hierarchy for four classes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の図は、４つのクラスのためのより複雑なクラス階層を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The figure below shows the initializer chain for the &lt;c0&gt;&lt;s1&gt;Food&lt;/s1&gt;&lt;/c0&gt; class:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の図は、&lt;c0&gt;&lt;s1&gt;Food&lt;/s1&gt;&lt;/c0&gt;クラスのためのイニシャライザ連鎖を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The figure below shows the initializer chain for the &lt;c0&gt;&lt;s1&gt;RecipeIngredient&lt;/s1&gt;&lt;/c0&gt; class:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の図は、&lt;c0&gt;&lt;s1&gt;RecipeIngredient&lt;/s1&gt;&lt;/c0&gt;クラスのためのイニシャライザ連鎖を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The figure below shows the overall initializer chain for all three classes:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の図は、３つのクラス全てのために全体的なイニシャライザ連鎖を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The figure below shows these relationships:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の図は、それらの関係を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final &lt;c0&gt;&lt;s1&gt;else&lt;/s1&gt;&lt;/c0&gt; clause is optional, however, and can be excluded if the set of conditions does not need to be complete.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、最後の&lt;c0&gt;&lt;s1&gt;else&lt;/s1&gt;&lt;/c0&gt;節は任意です、そして条件の集合が完全である必要がないならば、除外されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final &lt;c2&gt;&lt;s3&gt;else&lt;/s3&gt;&lt;/c2&gt; clause remains, and it prints a response for any temperatures that are neither too warm nor too cold.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最後の&lt;c2&gt;&lt;s3&gt;else&lt;/s3&gt;&lt;/c2&gt;節は同じままです、そしてそれはあまり暖かくもなくあまり寒くもないすべての気温に対しての応答を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final case, &lt;c4&gt;&lt;s5&gt;case&lt;/s5&gt; &lt;s6&gt;let&lt;/s6&gt; &lt;s7&gt;(x,&lt;/s7&gt; &lt;s8&gt;y)&lt;/s8&gt;&lt;/c4&gt;, declares a tuple of two placeholder constants that can match any value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最後のケース節、&lt;c4&gt;&lt;s5&gt;case&lt;/s5&gt; &lt;s6&gt;let&lt;/s6&gt; &lt;s7&gt;(x,&lt;/s7&gt; &lt;s8&gt;y)&lt;/s8&gt;&lt;/c4&gt;は、どんな値にでも適合することができるプレースホルダ定数を２つもつタプルを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final class in this model is called &lt;c0&gt;&lt;s1&gt;Address&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このモデルの中の最後のクラスは、&lt;c0&gt;&lt;s1&gt;Address&lt;/s1&gt;&lt;/c0&gt;と呼ばれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final code snippet above shows that the deinitializers for the &lt;c0&gt;&lt;s1&gt;Customer&lt;/s1&gt;&lt;/c0&gt; instance and &lt;c2&gt;&lt;s3&gt;CreditCard&lt;/s3&gt;&lt;/c2&gt; instance both print their “deinitialized” messages after the &lt;c4&gt;&lt;s5&gt;john&lt;/s5&gt;&lt;/c4&gt; variable is set to &lt;c6&gt;&lt;s7&gt;nil&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の最後のコード断片は、&lt;c0&gt;&lt;s1&gt;Customer&lt;/s1&gt;&lt;/c0&gt;インスタンスと&lt;c2&gt;&lt;s3&gt;CreditCard&lt;/s3&gt;&lt;/c2&gt;インスタンスのためのデイニシャライザが両方ともそれらの「デイニシャライズされた」メッセージを、&lt;c4&gt;&lt;s5&gt;john&lt;/s5&gt;&lt;/c4&gt;変数が&lt;c6&gt;&lt;s7&gt;nil&lt;/s7&gt;&lt;/c6&gt;に設定された後に出力することを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final snippet creates a constant array called &lt;c0&gt;&lt;s1&gt;library&lt;/s1&gt;&lt;/c0&gt;, which contains two &lt;c2&gt;&lt;s3&gt;Movie&lt;/s3&gt;&lt;/c2&gt; instances and three &lt;c4&gt;&lt;s5&gt;Song&lt;/s5&gt;&lt;/c4&gt; instances.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最終的な断片は&lt;c0&gt;&lt;s1&gt;library&lt;/s1&gt;&lt;/c0&gt;と呼ばれる定数の配列をつくります、それは、２つの&lt;c2&gt;&lt;s3&gt;Movie&lt;/s3&gt;&lt;/c2&gt;インスタンスと３つの&lt;c4&gt;&lt;s5&gt;Song&lt;/s5&gt;&lt;/c4&gt;インスタンスを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first &lt;c0&gt;&lt;s1&gt;Rect&lt;/s1&gt;&lt;/c0&gt; initializer, &lt;c2&gt;&lt;s3&gt;init()&lt;/s3&gt;&lt;/c2&gt;, is functionally the same as the default initializer that the structure would have received if it did not have its own custom initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の&lt;c0&gt;&lt;s1&gt;Rect&lt;/s1&gt;&lt;/c0&gt;イニシャライザ、&lt;c2&gt;&lt;s3&gt;init()&lt;/s3&gt;&lt;/c2&gt;は、構造体が独自のあつらえのイニシャライザを持たない場合に受け取る省略時のイニシャライザと機能的に同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first and second requirements are defined in the function’s type parameter list, and the third and fourth requirements are defined in the function’s generic &lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt; clause.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初と２番目の要件は関数のもつ型パラメータリストにおいて定義されます、そして３番目と４番目の要件は関数のもつ総称体&lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt;節において定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first case, &lt;c8&gt;&lt;s9&gt;case&lt;/s9&gt; &lt;s10&gt;(let&lt;/s10&gt; &lt;s11&gt;x,&lt;/s11&gt; &lt;s12&gt;0)&lt;/s12&gt;&lt;/c8&gt;, matches any point with a &lt;c13&gt;&lt;s14&gt;y&lt;/s14&gt;&lt;/c13&gt; value of &lt;c15&gt;&lt;s16&gt;0&lt;/s16&gt;&lt;/c15&gt; and assigns the point’s &lt;c17&gt;&lt;s18&gt;x&lt;/s18&gt;&lt;/c17&gt; value to the temporary constant &lt;c19&gt;&lt;s20&gt;x&lt;/s20&gt;&lt;/c19&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初のケース節、&lt;c8&gt;&lt;s9&gt;case&lt;/s9&gt; &lt;s10&gt;(let&lt;/s10&gt; &lt;s11&gt;x,&lt;/s11&gt; &lt;s12&gt;0)&lt;/s12&gt;&lt;/c8&gt;は、&lt;c15&gt;&lt;s16&gt;0&lt;/s16&gt;&lt;/c15&gt;の&lt;c13&gt;&lt;s14&gt;y&lt;/s14&gt;&lt;/c13&gt;値をもつどんなポイントにでも適合して、そのポイントの&lt;c17&gt;&lt;s18&gt;x&lt;/s18&gt;&lt;/c17&gt;値を一時的な定数&lt;c19&gt;&lt;s20&gt;x&lt;/s20&gt;&lt;/c19&gt;に代入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first example’s use of the ternary conditional operator means that &lt;c0&gt;&lt;s1&gt;rowHeight&lt;/s1&gt;&lt;/c0&gt; can be set to the correct value on a single line of code, which is more concise than the code used in the second example.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の例の三項条件演算子の使用は、&lt;c0&gt;&lt;s1&gt;rowHeight&lt;/s1&gt;&lt;/c0&gt;がただ１行のコードで正しい値に設定されることができるのを意味します、それは２番目の例において使われるコードより簡潔です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first form allows code to be executed only when a condition is true and has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の形式は、条件が真である時にだけコードが実行されるようにし、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first form emits the &lt;e0&gt;error message&lt;/e0&gt; as a fatal error and terminates the compilation process.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の形式は、&lt;e0&gt;error message（エラーメッセージ）&lt;/e0&gt;を致命的エラーとして発して、コンパイル処理を終わらせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first form evaluates to the value of the &lt;e0&gt;expression&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の形式は、&lt;e0&gt;式&lt;/e0&gt;の値に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first form is used to access a member of the superclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の形式は、スーパークラスのメンバーにアクセスするために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first form of a line control statement changes the values of the &lt;c0&gt;&lt;s1&gt;#line&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;#file&lt;/s3&gt;&lt;/c2&gt; literal expressions, beginning with the line of code following the line control statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の形式の行制御文は、&lt;c0&gt;&lt;s1&gt;#line&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;#file&lt;/s3&gt;&lt;/c2&gt;リテラル式の値を変更して、行制御文の後に続くコードの行で始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first function, &lt;c0&gt;&lt;s1&gt;printAndCount(string:)&lt;/s1&gt;&lt;/c0&gt;, prints a string, and then returns its character count as an &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の関数、&lt;c0&gt;&lt;s1&gt;printAndCount(string:)&lt;/s1&gt;&lt;/c0&gt;は、ある文字列を出力して、それからその文字数を&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;として返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first initializer has a single initialization parameter with an argument label of &lt;c0&gt;&lt;s1&gt;fromFahrenheit&lt;/s1&gt;&lt;/c0&gt; and a parameter name of &lt;c2&gt;&lt;s3&gt;fahrenheit&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初のイニシャライザは、&lt;c0&gt;&lt;s1&gt;fromFahrenheit&lt;/s1&gt;&lt;/c0&gt;の引数ラベルと&lt;c2&gt;&lt;s3&gt;fahrenheit&lt;/s3&gt;&lt;/c2&gt;のパラメータ名を使うただ１つの初期化パラメータを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first is a type function called &lt;c4&gt;&lt;s5&gt;unlock(_:)&lt;/s5&gt;&lt;/c4&gt;, which updates the value of &lt;c6&gt;&lt;s7&gt;highestUnlockedLevel&lt;/s7&gt;&lt;/c6&gt; whenever a new level is unlocked.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第一は、&lt;c4&gt;&lt;s5&gt;unlock(_:)&lt;/s5&gt;&lt;/c4&gt;と呼ばれる型関数です、それは、新しいレベルが錠を開けられるときはいつでも、&lt;c6&gt;&lt;s7&gt;highestUnlockedLevel&lt;/s7&gt;&lt;/c6&gt;の値を更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first item in the array has an index of &lt;c0&gt;&lt;s1&gt;0&lt;/s1&gt;&lt;/c0&gt;, not &lt;c2&gt;&lt;s3&gt;1&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列での最初の項目が、&lt;c2&gt;&lt;s3&gt;1&lt;/s3&gt;&lt;/c2&gt;ではなく、&lt;c0&gt;&lt;s1&gt;0&lt;/s1&gt;&lt;/c0&gt;のインデックスを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first item in the array represents the top left square on the board and the last item in the array represents the bottom right square on the board.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列の最初の項目は盤上の一番左上の正方形を表わします、そして配列の最後の項目は盤上の一番右下の正方形を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first kind of pattern is used for destructuring values in simple variable, constant, and optional bindings.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の種類のパターンは、単純な変数、定数、およびオプショナル束縛での非構成の値に使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first letter of the case name is capitalized.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ケース節の最初の文字は大文字で書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first pair has a key of &lt;c2&gt;&lt;s3&gt;"YYZ"&lt;/s3&gt;&lt;/c2&gt; and a value of &lt;c4&gt;&lt;s5&gt;"Toronto&lt;/s5&gt; &lt;s6&gt;Pearson"&lt;/s6&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の組みは、&lt;c2&gt;&lt;s3&gt;"YYZ"&lt;/s3&gt;&lt;/c2&gt;のキーと&lt;c4&gt;&lt;s5&gt;"Toronto&lt;/s5&gt; &lt;s6&gt;Pearson"&lt;/s6&gt;&lt;/c4&gt;の値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first parameter is called &lt;c2&gt;&lt;s3&gt;mathFunction&lt;/s3&gt;&lt;/c2&gt;, and is of type &lt;c4&gt;&lt;s5&gt;(Int,&lt;/s5&gt; &lt;s6&gt;Int)&lt;/s6&gt; &lt;s7&gt;-&gt;&lt;/s7&gt; &lt;s8&gt;Int&lt;/s8&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初のパラメータは&lt;c2&gt;&lt;s3&gt;mathFunction&lt;/s3&gt;&lt;/c2&gt;と呼ばれていて、型&lt;c4&gt;&lt;s5&gt;(Int,&lt;/s5&gt; &lt;s6&gt;Int)&lt;/s6&gt; &lt;s7&gt;-&gt;&lt;/s7&gt; &lt;s8&gt;Int&lt;/s8&gt;&lt;/c4&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first situation is when you explicitly conform to the same protocol multiple times, but with different requirements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第一の状況は、あなたが明示的に同じプロトコルに対しての複数回の準拠を、しかし異なる要件を使って行う時です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first snippet defines a new base class called &lt;c0&gt;&lt;s1&gt;MediaItem&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の断片は、&lt;c0&gt;&lt;s1&gt;MediaItem&lt;/s1&gt;&lt;/c0&gt;と呼ばれる新しい基盤クラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first subclass, &lt;c2&gt;&lt;s3&gt;Movie&lt;/s3&gt;&lt;/c2&gt;, encapsulates additional information about a movie or film.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初のサブクラス&lt;c2&gt;&lt;s3&gt;Movie&lt;/s3&gt;&lt;/c2&gt;は、映画またはフィルムに関する追加の情報をカプセル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first two calls succeed, because the &lt;c16&gt;&lt;s17&gt;testScores&lt;/s17&gt;&lt;/c16&gt; dictionary contains keys for &lt;c18&gt;&lt;s19&gt;"Dave"&lt;/s19&gt;&lt;/c18&gt; and &lt;c20&gt;&lt;s21&gt;"Bev"&lt;/s21&gt;&lt;/c20&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の２つの呼び出しは成功します、なぜなら、&lt;c16&gt;&lt;s17&gt;testScores&lt;/s17&gt;&lt;/c16&gt;辞書は&lt;c18&gt;&lt;s19&gt;"Dave"&lt;/s19&gt;&lt;/c18&gt;と&lt;c20&gt;&lt;s21&gt;"Bev"&lt;/s21&gt;&lt;/c20&gt;のキーを含んでいるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first two properties, &lt;c4&gt;&lt;s5&gt;buildingName&lt;/s5&gt;&lt;/c4&gt; and &lt;c6&gt;&lt;s7&gt;buildingNumber&lt;/s7&gt;&lt;/c6&gt;, are alternative ways to identify a particular building as part of an address.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の２つのプロパティ、&lt;c4&gt;&lt;s5&gt;buildingName&lt;/s5&gt;&lt;/c4&gt;と&lt;c6&gt;&lt;s7&gt;buildingNumber&lt;/s7&gt;&lt;/c6&gt;は、アドレスの一部として特定の建物を同定するそれぞれ代替の方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first type parameter, &lt;c0&gt;&lt;s1&gt;T&lt;/s1&gt;&lt;/c0&gt;, has a type constraint that requires &lt;c2&gt;&lt;s3&gt;T&lt;/s3&gt;&lt;/c2&gt; to be a subclass of &lt;c4&gt;&lt;s5&gt;SomeClass&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の型パラメータ&lt;c0&gt;&lt;s1&gt;T&lt;/s1&gt;&lt;/c0&gt;は、&lt;c2&gt;&lt;s3&gt;T&lt;/s3&gt;&lt;/c2&gt;に&lt;c4&gt;&lt;s5&gt;SomeClass&lt;/s5&gt;&lt;/c4&gt;のサブクラスであることを要求する型制約を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first, &lt;c2&gt;&lt;s3&gt;resolution&lt;/s3&gt;&lt;/c2&gt;, is initialized with a new &lt;c4&gt;&lt;s5&gt;Resolution&lt;/s5&gt;&lt;/c4&gt; structure instance, which infers a property type of &lt;c6&gt;&lt;s7&gt;Resolution&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一番目、&lt;c2&gt;&lt;s3&gt;resolution&lt;/s3&gt;&lt;/c2&gt;は、新しい&lt;c4&gt;&lt;s5&gt;Resolution&lt;/s5&gt;&lt;/c4&gt;構造体インスタンスで初期化されます、そしてそれは、&lt;c6&gt;&lt;s7&gt;Resolution&lt;/s7&gt;&lt;/c6&gt;のプロパティ型を暗に意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first, &lt;c2&gt;&lt;s3&gt;thresholdLevel&lt;/s3&gt;&lt;/c2&gt;, defines the maximum threshold value an audio level can take.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その一番目、&lt;c2&gt;&lt;s3&gt;thresholdLevel&lt;/s3&gt;&lt;/c2&gt;は、音声レベルがとることができる最大の限界値を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fixity of the operator is specified by marking the operator declaration with the &lt;c0&gt;&lt;s1&gt;infix&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;prefix&lt;/s3&gt;&lt;/c2&gt;, or &lt;c4&gt;&lt;s5&gt;postfix&lt;/s5&gt;&lt;/c4&gt; declaration modifier before the &lt;c6&gt;&lt;s7&gt;operator&lt;/s7&gt;&lt;/c6&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子の定着性は、演算子定義を&lt;c6&gt;&lt;s7&gt;operator&lt;/s7&gt;&lt;/c6&gt;キーワードの前に&lt;c0&gt;&lt;s1&gt;infix&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;prefix&lt;/s3&gt;&lt;/c2&gt;、または&lt;c4&gt;&lt;s5&gt;postfix&lt;/s5&gt;&lt;/c4&gt;宣言修飾子を使って印することによって指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following &lt;c10&gt;&lt;s11&gt;if&lt;/s11&gt;&lt;/c10&gt; statements are equivalent:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の&lt;c10&gt;&lt;s11&gt;if&lt;/s11&gt;&lt;/c10&gt;文は同等です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following approaches are equivalent:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の各取り組みは同等です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following are examples of literals:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下はリテラルの例です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following characters are considered whitespace: space (U+0020), line feed (U+000A), carriage return (U+000D), horizontal tab (U+0009), vertical tab (U+000B), form feed (U+000C) and null (U+0000).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の文字は、空白とみなされます：空白（U+0020）、行送り（U+000A）、復帰（U+000D）、水平タブ（U+0009）、垂直タブ（U+000B）、改ページ（U+000C）およびヌル（U+0000）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following closure expressions are equivalent:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下のクロージャ式は、等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following code accesses different values and properties of a dictionary of arrays by using key-path expressions that combine these components.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下のコードは、いくつかの配列からなる辞書に属する異なる値およびプロパティに、それらの構成要素を組み合わせるキーパス式を使うことでアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following code uses &lt;c1&gt;&lt;s2&gt;\.someProperty&lt;/s2&gt;&lt;/c1&gt; instead of &lt;c3&gt;&lt;s4&gt;\SomeClass.someProperty&lt;/s4&gt;&lt;/c3&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下のコードは、&lt;c1&gt;&lt;s2&gt;\.someProperty&lt;/s2&gt;&lt;/c1&gt;を&lt;c3&gt;&lt;s4&gt;\SomeClass.someProperty&lt;/s4&gt;&lt;/c3&gt;の代わりに使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following code uses the variable &lt;c0&gt;&lt;s1&gt;index&lt;/s1&gt;&lt;/c0&gt; in both a key-path expression and in a closure to access the third element of the &lt;c2&gt;&lt;s3&gt;greetings&lt;/s3&gt;&lt;/c2&gt; array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下のコードは、変数&lt;c0&gt;&lt;s1&gt;index&lt;/s1&gt;&lt;/c0&gt;をキーパス式の中でそしてクロージャの中での両方で使うことで、&lt;c2&gt;&lt;s3&gt;greetings&lt;/s3&gt;&lt;/c2&gt;配列の３番目の要素にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example adds a new instance method called &lt;c0&gt;&lt;s1&gt;repetitions&lt;/s1&gt;&lt;/c0&gt; to the &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt; type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、&lt;c0&gt;&lt;s1&gt;repetitions&lt;/s1&gt;&lt;/c0&gt;と呼ばれる新しいインスタンスメソッドを&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;型に加えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example defines a &lt;c0&gt;&lt;s1&gt;Matrix&lt;/s1&gt;&lt;/c0&gt; structure, which represents a two-dimensional matrix of &lt;c2&gt;&lt;s3&gt;Double&lt;/s3&gt;&lt;/c2&gt; values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は&lt;c0&gt;&lt;s1&gt;Matrix&lt;/s1&gt;&lt;/c0&gt;構造体を定義します、それは&lt;c2&gt;&lt;s3&gt;Double&lt;/s3&gt;&lt;/c2&gt;値からなる２次元行列を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example defines a class called &lt;c0&gt;&lt;s1&gt;SurveyQuestion&lt;/s1&gt;&lt;/c0&gt;, with an optional &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt; property called &lt;c4&gt;&lt;s5&gt;response&lt;/s5&gt;&lt;/c4&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、&lt;c4&gt;&lt;s5&gt;response&lt;/s5&gt;&lt;/c4&gt;と呼ばれるオプショナルの&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;プロパティで、&lt;c0&gt;&lt;s1&gt;SurveyQuestion&lt;/s1&gt;&lt;/c0&gt;と呼ばれるクラスを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example defines a custom &lt;c0&gt;&lt;s1&gt;Rect&lt;/s1&gt;&lt;/c0&gt; structure to represent a geometric rectangle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、あつらえの&lt;c0&gt;&lt;s1&gt;Rect&lt;/s1&gt;&lt;/c0&gt;構造体を定義して、幾何学的な長方形を表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example defines a new class called &lt;c0&gt;&lt;s1&gt;AutomaticCar&lt;/s1&gt;&lt;/c0&gt;, which is a subclass of &lt;c2&gt;&lt;s3&gt;Car&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は&lt;c0&gt;&lt;s1&gt;AutomaticCar&lt;/s1&gt;&lt;/c0&gt;と呼ばれる新しいクラスを定義します、それは、&lt;c2&gt;&lt;s3&gt;Car&lt;/s3&gt;&lt;/c2&gt;のサブクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example defines a new class called &lt;c0&gt;&lt;s1&gt;Car&lt;/s1&gt;&lt;/c0&gt;, which is a subclass of &lt;c2&gt;&lt;s3&gt;Vehicle&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、&lt;c0&gt;&lt;s1&gt;Car&lt;/s1&gt;&lt;/c0&gt;と呼ばれる新しいクラスを定義します、それは、&lt;c2&gt;&lt;s3&gt;Vehicle&lt;/s3&gt;&lt;/c2&gt;のサブクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example defines a new custom infix operator called &lt;c0&gt;&lt;s1&gt;+-&lt;/s1&gt;&lt;/c0&gt;, which belongs to the precedence group &lt;c2&gt;&lt;s3&gt;AdditionPrecedence&lt;/s3&gt;&lt;/c2&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、&lt;c0&gt;&lt;s1&gt;+-&lt;/s1&gt;&lt;/c0&gt;と呼びれる新しいあつらえの接中辞演算子を定義します、それは優先順位グループ&lt;c2&gt;&lt;s3&gt;AdditionPrecedence&lt;/s3&gt;&lt;/c2&gt;に属します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example defines a new subclass of &lt;c0&gt;&lt;s1&gt;Vehicle&lt;/s1&gt;&lt;/c0&gt; called &lt;c2&gt;&lt;s3&gt;Train&lt;/s3&gt;&lt;/c2&gt;, which overrides the &lt;c4&gt;&lt;s5&gt;makeNoise()&lt;/s5&gt;&lt;/c4&gt; method that &lt;c6&gt;&lt;s7&gt;Train&lt;/s7&gt;&lt;/c6&gt; inherits from &lt;c8&gt;&lt;s9&gt;Vehicle&lt;/s9&gt;&lt;/c8&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、&lt;c2&gt;&lt;s3&gt;Train&lt;/s3&gt;&lt;/c2&gt;と呼ばれる&lt;c0&gt;&lt;s1&gt;Vehicle&lt;/s1&gt;&lt;/c0&gt;の新しいサブクラスを定義します、それは、&lt;c6&gt;&lt;s7&gt;Train&lt;/s7&gt;&lt;/c6&gt;が&lt;c8&gt;&lt;s9&gt;Vehicle&lt;/s9&gt;&lt;/c8&gt;から受け継ぐ&lt;c4&gt;&lt;s5&gt;makeNoise()&lt;/s5&gt;&lt;/c4&gt;メソッドをオーバーライドします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example defines a protocol with a single instance method requirement:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、１つのインスタンスメソッド要件で、プロトコルを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example defines a structure called &lt;c0&gt;&lt;s1&gt;Celsius&lt;/s1&gt;&lt;/c0&gt;, which stores temperatures expressed in degrees Celsius.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、&lt;c0&gt;&lt;s1&gt;Celsius&lt;/s1&gt;&lt;/c0&gt;と呼ばれる構造体を定義します、それは、摂氏度数で表される温度を格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example defines a structure called &lt;c0&gt;&lt;s1&gt;Color&lt;/s1&gt;&lt;/c0&gt;, with three constant properties called &lt;c2&gt;&lt;s3&gt;red&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;green&lt;/s5&gt;&lt;/c4&gt;, and &lt;c6&gt;&lt;s7&gt;blue&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は&lt;c0&gt;&lt;s1&gt;Color&lt;/s1&gt;&lt;/c0&gt;と呼ばれる構造体を定義します、それは&lt;c2&gt;&lt;s3&gt;red&lt;/s3&gt;&lt;/c2&gt;、&lt;c4&gt;&lt;s5&gt;green&lt;/s5&gt;&lt;/c4&gt;、そして&lt;c6&gt;&lt;s7&gt;blue&lt;/s7&gt;&lt;/c6&gt;と呼ばれる３つの定数プロパティを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example defines a subclass called &lt;c0&gt;&lt;s1&gt;Bicycle&lt;/s1&gt;&lt;/c0&gt;, with a superclass of &lt;c2&gt;&lt;s3&gt;Vehicle&lt;/s3&gt;&lt;/c2&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、&lt;c2&gt;&lt;s3&gt;Vehicle&lt;/s3&gt;&lt;/c2&gt;のスーパークラスを持つ、&lt;c0&gt;&lt;s1&gt;Bicycle&lt;/s1&gt;&lt;/c0&gt;と呼ばれるサブクラスを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example defines an integer-counting class called &lt;c0&gt;&lt;s1&gt;Counter&lt;/s1&gt;&lt;/c0&gt;, which uses an external data source to provide its increment amount.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は&lt;c0&gt;&lt;s1&gt;Counter&lt;/s1&gt;&lt;/c0&gt;と呼ばれる整数計数クラスを定義します、それは、その増加量を提供するために外部のデータ・ソースを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example defines two classes, &lt;c0&gt;&lt;s1&gt;Customer&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;CreditCard&lt;/s3&gt;&lt;/c2&gt;, which model a bank customer and a possible credit card for that customer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は２つのクラス、&lt;c0&gt;&lt;s1&gt;Customer&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;CreditCard&lt;/s3&gt;&lt;/c2&gt;を定義します、それは、銀行顧客とその顧客のために可能なクレジットカードをモデル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example explicitly declares the conditional conformance of &lt;c0&gt;&lt;s1&gt;Array&lt;/s1&gt;&lt;/c0&gt; to &lt;c2&gt;&lt;s3&gt;Loggable&lt;/s3&gt;&lt;/c2&gt; to avoid a conflict when declaring its conditional conformance to both &lt;c4&gt;&lt;s5&gt;TitledLoggable&lt;/s5&gt;&lt;/c4&gt; and the new &lt;c6&gt;&lt;s7&gt;MarkedLoggable&lt;/s7&gt;&lt;/c6&gt; protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、&lt;c2&gt;&lt;s3&gt;Loggable&lt;/s3&gt;&lt;/c2&gt;に対しての&lt;c0&gt;&lt;s1&gt;Array&lt;/s1&gt;&lt;/c0&gt;の条件準拠を明示的に宣言して、&lt;c4&gt;&lt;s5&gt;TitledLoggable&lt;/s5&gt;&lt;/c4&gt;と新しい&lt;c6&gt;&lt;s7&gt;MarkedLoggable&lt;/s7&gt;&lt;/c6&gt;プロトコルの両方に対してのそれの条件準拠を宣言する時に衝突を回避します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example extends the generic &lt;c0&gt;&lt;s1&gt;Stack&lt;/s1&gt;&lt;/c0&gt; type to add a read-only computed property called &lt;c2&gt;&lt;s3&gt;topItem&lt;/s3&gt;&lt;/c2&gt;, which returns the top item on the stack without popping it from the stack:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は総称体&lt;c0&gt;&lt;s1&gt;Stack&lt;/s1&gt;&lt;/c0&gt;型を拡張して、&lt;c2&gt;&lt;s3&gt;topItem&lt;/s3&gt;&lt;/c2&gt;と呼ばれる読み出し専用の計算プロパティを加えます、それは、スタックの一番上の項目をスタックからそれをポップすることなく返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example removes all vowels and spaces from a lowercase string to create a cryptic puzzle phrase:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、秘密の謎の語句をつくるために、小文字の文字列から全ての母音と空白を削除します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example replaces &lt;c0&gt;&lt;s1&gt;"Chocolate&lt;/s1&gt; &lt;s2&gt;Spread"&lt;/s2&gt;&lt;/c0&gt;, &lt;c3&gt;&lt;s4&gt;"Cheese"&lt;/s4&gt;&lt;/c3&gt;, and &lt;c5&gt;&lt;s6&gt;"Butter"&lt;/s6&gt;&lt;/c5&gt; with &lt;c7&gt;&lt;s8&gt;"Bananas"&lt;/s8&gt;&lt;/c7&gt; and &lt;c9&gt;&lt;s10&gt;"Apples"&lt;/s10&gt;&lt;/c9&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、&lt;c0&gt;&lt;s1&gt;"Chocolate&lt;/s1&gt; &lt;s2&gt;Spread"&lt;/s2&gt;&lt;/c0&gt;、&lt;c3&gt;&lt;s4&gt;"Cheese"&lt;/s4&gt;&lt;/c3&gt;、そして&lt;c5&gt;&lt;s6&gt;"Butter"&lt;/s6&gt;&lt;/c5&gt;を、&lt;c7&gt;&lt;s8&gt;"Bananas"&lt;/s8&gt;&lt;/c7&gt;および&lt;c9&gt;&lt;s10&gt;"Apples"&lt;/s10&gt;&lt;/c9&gt;と取り替えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example reports a compile-time error:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、コンパイル時エラーを報告します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example shows a string literal and a string delimited by extended delimiters that create equivalent string values:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、文字列リテラルそして同等の文字列値を作成する拡張区切り記号によって区切られる文字列を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example shows designated initializers, convenience initializers, and automatic initializer inheritance in action.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、指定イニシャライザ、便宜イニシャライザ、そして自動的なイニシャライザ継承の動作を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example shows the behavior of the example above without using optional chaining.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、オプショナル連鎖を使うことなく上の例の挙動を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example shows the difference in behavior between an optional string and an implicitly unwrapped optional string when accessing their wrapped value as an explicit &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、オプショナルの文字列と、暗黙的にアンラップされるオプショナルの文字列の間での、それらのラップされた値に明示的な&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;としてアクセスする場合での挙動の違いを示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example switches on a &lt;c0&gt;&lt;s1&gt;Character&lt;/s1&gt;&lt;/c0&gt; value and determines whether it represents a number symbol in one of four languages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、ある&lt;c0&gt;&lt;s1&gt;Character&lt;/s1&gt;&lt;/c0&gt;値に基づいて切り替えて、それが数字シンボルを４つの言語のうちの１つで表わすかどうかを明らかにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example switches over all three existing cases of the standard library’s &lt;a0&gt;&lt;c1&gt;&lt;s2&gt;Mirror.AncestorRepresentation&lt;/s2&gt;&lt;/c1&gt;&lt;/a0&gt;&lt;s3&gt; [https://developer.apple.com/documentation/swift/mirror/ancestorrepresentation]&lt;/s3&gt; enumeration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、標準ライブラリのもつ&lt;a0&gt;&lt;c1&gt;&lt;s2&gt;Mirror.AncestorRepresentation&lt;/s2&gt;&lt;/c1&gt;&lt;/a0&gt;&lt;s3&gt; [https://developer.apple.com/documentation/swift/mirror/ancestorrepresentation]&lt;/s3&gt;列挙の３つの既存のケース節すべてに対してスイッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example uses the &lt;c0&gt;&lt;s1&gt;break&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;continue&lt;/s3&gt;&lt;/c2&gt; statements with a labeled &lt;c4&gt;&lt;s5&gt;while&lt;/s5&gt;&lt;/c4&gt; loop for an adapted version of the &lt;e6&gt;Snakes and Ladders&lt;/e6&gt; game that you saw earlier in this chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の例は、&lt;c0&gt;&lt;s1&gt;break&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;continue&lt;/s3&gt;&lt;/c2&gt;文をラベルが付いた&lt;c4&gt;&lt;s5&gt;while&lt;/s5&gt;&lt;/c4&gt;ループと一緒に、あなたがこの章で以前に見た&lt;e6&gt;「ヘビとはしご」&lt;/e6&gt;ゲームの改作板のために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following extension makes &lt;c0&gt;&lt;s1&gt;Array&lt;/s1&gt;&lt;/c0&gt; instances conform to the &lt;c2&gt;&lt;s3&gt;TextRepresentable&lt;/s3&gt;&lt;/c2&gt; protocol whenever they store elements of a type that conforms to &lt;c4&gt;&lt;s5&gt;TextRepresentable&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の拡張は、&lt;c0&gt;&lt;s1&gt;Array&lt;/s1&gt;&lt;/c0&gt;インスタンスを&lt;c2&gt;&lt;s3&gt;TextRepresentable&lt;/s3&gt;&lt;/c2&gt;プロトコルに準拠させます、それが&lt;c4&gt;&lt;s5&gt;TextRepresentable&lt;/s5&gt;&lt;/c4&gt;に準拠する型の要素を格納する時は必ずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following form declares a computed variable or computed property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の形式は、計算変数または計算プロパティを宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following form declares a new infix operator:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の形式は、新しい接中辞演算子を宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following form declares a new postfix operator:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の形式は、新しい接尾辞演算子を宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following form declares a new prefix operator:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の形式は、新しい接頭辞演算子を宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following form declares a stored variable or stored variable property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の形式は、格納変数または格納変数プロパティを宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following form declares an enumeration type that contains enumeration cases of any type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の形式は、随意の型の列挙ケース節を含む列挙型を宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following form declares an enumeration type that contains enumeration cases of the same basic type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の形式は、同じ基本の型をもつ列挙ケース節たちを含む列挙型を宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following form declares initializers for structures, enumerations, and designated initializers of classes:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の形式は、構造体、列挙のイニシャライザ、そしてクラスの指定イニシャライザを宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following function calls are equivalent:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の関数呼び出しは、等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following keywords are reserved and can’t be used as identifiers, unless they’re escaped with backticks, as described above in &lt;a0&gt;&lt;s1&gt;Identifiers&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の&lt;a0&gt;&lt;s1&gt;識別子&lt;/s1&gt;&lt;/a0&gt;で記述されるように、以下のキーワードは予約済で、それらがバッククォートでエスケープされない限り、識別子として使われることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following requirements are placed on the function’s two type parameters:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の要件は、この関数の持つ２つの型パラメータ上に置かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following statement is not valid:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の文は、有効ではありません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following tokens are reserved as punctuation and can’t be used as custom operators: &lt;c0&gt;&lt;s1&gt;(&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;)&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;{&lt;/s5&gt;&lt;/c4&gt;, &lt;c6&gt;&lt;s7&gt;}&lt;/s7&gt;&lt;/c6&gt;, &lt;c8&gt;&lt;s9&gt;[&lt;/s9&gt;&lt;/c8&gt;, &lt;c10&gt;&lt;s11&gt;]&lt;/s11&gt;&lt;/c10&gt;, &lt;c12&gt;&lt;s13&gt;.&lt;/s13&gt;&lt;/c12&gt;, &lt;c14&gt;&lt;s15&gt;,&lt;/s15&gt;&lt;/c14&gt;, &lt;c16&gt;&lt;s17&gt;:&lt;/s17&gt;&lt;/c16&gt;, &lt;c18&gt;&lt;s19&gt;;&lt;/s19&gt;&lt;/c18&gt;, &lt;c20&gt;&lt;s21&gt;=&lt;/s21&gt;&lt;/c20&gt;, &lt;c22&gt;&lt;s23&gt;@&lt;/s23&gt;&lt;/c22&gt;, &lt;c24&gt;&lt;s25&gt;#&lt;/s25&gt;&lt;/c24&gt;, &lt;c26&gt;&lt;s27&gt;&amp;&lt;/s27&gt;&lt;/c26&gt; (as a prefix operator), &lt;c28&gt;&lt;s29&gt;-&gt;&lt;/s29&gt;&lt;/c28&gt;, &lt;c30&gt;&lt;s31&gt;`&lt;/s31&gt;&lt;/c30&gt;, &lt;c32&gt;&lt;s33&gt;?&lt;/s33&gt;&lt;/c32&gt;, and &lt;c34&gt;&lt;s35&gt;!&lt;/s35&gt;&lt;/c34&gt; (as a postfix operator).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下のトークンは、句読点として予約されます、そしてあつらえの演算子として使われることができません：&lt;c0&gt;&lt;s1&gt;(&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;)&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;{&lt;/s5&gt;&lt;/c4&gt;, &lt;c6&gt;&lt;s7&gt;}&lt;/s7&gt;&lt;/c6&gt;, &lt;c8&gt;&lt;s9&gt;[&lt;/s9&gt;&lt;/c8&gt;, &lt;c10&gt;&lt;s11&gt;]&lt;/s11&gt;&lt;/c10&gt;, &lt;c12&gt;&lt;s13&gt;.&lt;/s13&gt;&lt;/c12&gt;, &lt;c14&gt;&lt;s15&gt;,&lt;/s15&gt;&lt;/c14&gt;, &lt;c16&gt;&lt;s17&gt;:&lt;/s17&gt;&lt;/c16&gt;, &lt;c18&gt;&lt;s19&gt;;&lt;/s19&gt;&lt;/c18&gt;, &lt;c20&gt;&lt;s21&gt;=&lt;/s21&gt;&lt;/c20&gt;, &lt;c22&gt;&lt;s23&gt;@&lt;/s23&gt;&lt;/c22&gt;, &lt;c24&gt;&lt;s25&gt;#&lt;/s25&gt;&lt;/c24&gt;, &lt;c26&gt;&lt;s27&gt;&amp;&lt;/s27&gt;&lt;/c26&gt;（接頭辞演算子として）, &lt;c28&gt;&lt;s29&gt;-&gt;&lt;/s29&gt;&lt;/c28&gt;, &lt;c30&gt;&lt;s31&gt;`&lt;/s31&gt;&lt;/c30&gt;, &lt;c32&gt;&lt;s33&gt;?&lt;/s33&gt;&lt;/c32&gt;, そして&lt;c34&gt;&lt;s35&gt;!&lt;/s35&gt;&lt;/c34&gt;（接尾辞演算子として）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The forced form, &lt;c2&gt;&lt;s3&gt;as!&lt;/s3&gt;&lt;/c2&gt;, attempts the downcast and force-unwraps the result as a single compound action.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>強制形式&lt;c2&gt;&lt;s3&gt;as!&lt;/s3&gt;&lt;/c2&gt;は、一回の複合動作として、ダウンキャストとその結果の強制アンラップを試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The four function calls marked “Error” in the example above cause compiler errors.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例において「Error」と記される４つの関数呼び出しは、コンパイラエラーを引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fourth &lt;c0&gt;&lt;s1&gt;codeUnit&lt;/s1&gt;&lt;/c0&gt; value (&lt;c2&gt;&lt;s3&gt;8252&lt;/s3&gt;&lt;/c2&gt;) is a decimal equivalent of the hexadecimal value &lt;c4&gt;&lt;s5&gt;203C&lt;/s5&gt;&lt;/c4&gt;, which represents the Unicode scalar &lt;c6&gt;&lt;s7&gt;U+203C&lt;/s7&gt;&lt;/c6&gt; for the &lt;c8&gt;&lt;s9&gt;DOUBLE&lt;/s9&gt; &lt;s10&gt;EXCLAMATION&lt;/s10&gt; &lt;s11&gt;MARK&lt;/s11&gt;&lt;/c8&gt; character.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>４番目の&lt;c0&gt;&lt;s1&gt;codeUnit&lt;/s1&gt;&lt;/c0&gt;値（&lt;c2&gt;&lt;s3&gt;8252&lt;/s3&gt;&lt;/c2&gt;）は、16進数の値&lt;c4&gt;&lt;s5&gt;203C&lt;/s5&gt;&lt;/c4&gt;です、それは、&lt;c8&gt;&lt;s9&gt;DOUBLE&lt;/s9&gt; &lt;s10&gt;EXCLAMATION&lt;/s10&gt; &lt;s11&gt;MARK&lt;/s11&gt;&lt;/c8&gt;文字に対するユニコード・スカラー&lt;c6&gt;&lt;s7&gt;U+203C&lt;/s7&gt;&lt;/c6&gt;を表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The fourth &lt;c0&gt;&lt;s1&gt;codeUnit&lt;/s1&gt;&lt;/c0&gt; value (&lt;c2&gt;&lt;s3&gt;8252&lt;/s3&gt;&lt;/c2&gt;) is again a decimal equivalent of the hexadecimal value &lt;c4&gt;&lt;s5&gt;203C&lt;/s5&gt;&lt;/c4&gt;, which represents the Unicode scalar &lt;c6&gt;&lt;s7&gt;U+203C&lt;/s7&gt;&lt;/c6&gt; for the &lt;c8&gt;&lt;s9&gt;DOUBLE&lt;/s9&gt; &lt;s10&gt;EXCLAMATION&lt;/s10&gt; &lt;s11&gt;MARK&lt;/s11&gt;&lt;/c8&gt; character.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>４番目の&lt;c0&gt;&lt;s1&gt;codeUnit&lt;/s1&gt;&lt;/c0&gt;値（&lt;c2&gt;&lt;s3&gt;8252&lt;/s3&gt;&lt;/c2&gt;）は、ふたたび16進数値&lt;c4&gt;&lt;s5&gt;203C&lt;/s5&gt;&lt;/c4&gt;の10進の等価物です、それは、&lt;c8&gt;&lt;s9&gt;DOUBLE&lt;/s9&gt; &lt;s10&gt;EXCLAMATION&lt;/s10&gt; &lt;s11&gt;MARK&lt;/s11&gt;&lt;/c8&gt;文字に対するユニコード・スカラー&lt;c6&gt;&lt;s7&gt;U+203C&lt;/s7&gt;&lt;/c6&gt;を表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function call is understood to be a call to one of the specially named methods on that instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数呼び出しは、そのインスタンス上での特殊名メソッドの１つへの呼び出しであると理解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function definition still needs parentheses after the function’s name, even though it does not take any parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえそれが全くパラメータをとらないとしても、関数定義は依然として関数の名前の後に丸括弧を必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function in the example below is called &lt;c0&gt;&lt;s1&gt;greet(person:)&lt;/s1&gt;&lt;/c0&gt;, because that’s what it does—it takes a person’s name as input and returns a greeting for that person.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下記の例の関数は、それがすることから、&lt;c0&gt;&lt;s1&gt;greet(person:)&lt;/s1&gt;&lt;/c0&gt;と呼ばれます ― それは、入力としてある人の名前をとって、その人のために挨拶を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function it returns has no parameters, and returns an &lt;c7&gt;&lt;s8&gt;Int&lt;/s8&gt;&lt;/c7&gt; value each time it is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが返す関数は、パラメータを持たず、それが呼ばれるたびに&lt;c7&gt;&lt;s8&gt;Int&lt;/s8&gt;&lt;/c7&gt;値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function name is also followed by an empty pair of parentheses when the function is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その関数が呼ばれるとき、関数名の後にまた空の丸括弧の対が続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function performs this swap by storing the value of &lt;c10&gt;&lt;s11&gt;a&lt;/s11&gt;&lt;/c10&gt; in a temporary constant called &lt;c12&gt;&lt;s13&gt;temporaryA&lt;/s13&gt;&lt;/c12&gt;, assigning the value of &lt;c14&gt;&lt;s15&gt;b&lt;/s15&gt;&lt;/c14&gt; to &lt;c16&gt;&lt;s17&gt;a&lt;/s17&gt;&lt;/c16&gt;, and then assigning &lt;c18&gt;&lt;s19&gt;temporaryA&lt;/s19&gt;&lt;/c18&gt; to &lt;c20&gt;&lt;s21&gt;b&lt;/s21&gt;&lt;/c20&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数はこの交換を、&lt;c10&gt;&lt;s11&gt;a&lt;/s11&gt;&lt;/c10&gt;の値を&lt;c12&gt;&lt;s13&gt;temporaryA&lt;/s13&gt;&lt;/c12&gt;と呼ばれる一時的な定数の中に格納して、&lt;c14&gt;&lt;s15&gt;b&lt;/s15&gt;&lt;/c14&gt;の値を&lt;c16&gt;&lt;s17&gt;a&lt;/s17&gt;&lt;/c16&gt;に代入して、それから&lt;c18&gt;&lt;s19&gt;temporaryA&lt;/s19&gt;&lt;/c18&gt;を&lt;c20&gt;&lt;s21&gt;b&lt;/s21&gt;&lt;/c20&gt;に代入することによって実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function prints “Function was called” before returning a value, which lets you see whether the right-hand side of the &lt;c4&gt;&lt;s5&gt;=&lt;/s5&gt;&lt;/c4&gt; operator was evaluated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数は、値を返す前に「Function was called（関数は呼び出された）」を出力します、それはあなたに&lt;c4&gt;&lt;s5&gt;=&lt;/s5&gt;&lt;/c4&gt;演算子の右手側が評価されたかどうかを確かめさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function returns a Boolean value of &lt;c4&gt;&lt;s5&gt;true&lt;/s5&gt;&lt;/c4&gt; if all items match and a value of &lt;c6&gt;&lt;s7&gt;false&lt;/s7&gt;&lt;/c6&gt; if they don’t.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数は全ての項目が合致するならばブール値の&lt;c4&gt;&lt;s5&gt;true&lt;/s5&gt;&lt;/c4&gt;を、それらがそうしないならば&lt;c6&gt;&lt;s7&gt;false&lt;/s7&gt;&lt;/c6&gt;の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function returns a tailored greeting in each case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数は、それぞれの状況に合った挨拶を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function returns after it starts the operation, but the closure isn’t called until the operation is completed—the closure needs to escape, to be called later.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数は、それが演算を開始した後に戻ります、しかしクロージャはその演算が完了されるまで呼び出されません—このクロージャは脱出する、後で呼び出される、必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function then considers the value of &lt;c4&gt;&lt;s5&gt;integerToDescribe&lt;/s5&gt;&lt;/c4&gt; using a &lt;c6&gt;&lt;s7&gt;switch&lt;/s7&gt;&lt;/c6&gt; statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数は、それから&lt;c6&gt;&lt;s7&gt;switch&lt;/s7&gt;&lt;/c6&gt;文を使って&lt;c4&gt;&lt;s5&gt;integerToDescribe&lt;/s5&gt;&lt;/c4&gt;の値を考慮します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function then iterates over the remaining values in the array and checks each value to see if it is smaller or larger than the values of &lt;c6&gt;&lt;s7&gt;currentMin&lt;/s7&gt;&lt;/c6&gt; and &lt;c8&gt;&lt;s9&gt;currentMax&lt;/s9&gt;&lt;/c8&gt; respectively.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数はそれから、配列の残りの値すべてに渡って繰り返します、そして各値をそれが&lt;c6&gt;&lt;s7&gt;currentMin&lt;/s7&gt;&lt;/c6&gt;および&lt;c8&gt;&lt;s9&gt;currentMax&lt;/s9&gt;&lt;/c8&gt;の値より小さいかより大きいかそれぞれについて調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function value carries no context and uses the C calling convention.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数値は、コンテキストを持ち運びません、そしてC呼出規約を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function value is represented as a reference to the block object, which is an &lt;c2&gt;&lt;s3&gt;id&lt;/s3&gt;&lt;/c2&gt;-compatible Objective-C object that embeds its invocation function within the object.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数値はそのブロックオブジェクトへの参照として表現されます、それは&lt;c2&gt;&lt;s3&gt;id&lt;/s3&gt;&lt;/c2&gt;互換Objective-Cオブジェクトで、それの呼出関数がそのオブジェクト内部に埋め込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The functions in the following code both return a value of some type that conforms to the &lt;c0&gt;&lt;s1&gt;Shape&lt;/s1&gt;&lt;/c0&gt; protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下のコードでの関数は両方とも、&lt;c0&gt;&lt;s1&gt;Shape&lt;/s1&gt;&lt;/c0&gt;プロトコルに準拠する何らかの型の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The function’s return type is a tuple type composed from two of the custom classes defined above in &lt;a0&gt;&lt;s1&gt;Custom Types&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数の戻り型は、上の&lt;a0&gt;&lt;s1&gt;あつらえの型&lt;/s1&gt;&lt;/a0&gt;で定義されるあつらえのクラスのうちの２つから作られるタプル型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The game board is represented by an array of &lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt; values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ゲーム盤は、&lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt;値の配列によって表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The game board is the same as before.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ゲーム盤は、前と同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The generic &lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt; clause in the example above requires &lt;c2&gt;&lt;s3&gt;Item&lt;/s3&gt;&lt;/c2&gt; to conform to a protocol, but you can also write a generic &lt;c4&gt;&lt;s5&gt;where&lt;/s5&gt;&lt;/c4&gt; clauses that require &lt;c6&gt;&lt;s7&gt;Item&lt;/s7&gt;&lt;/c6&gt; to be a specific type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例の総称体&lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt;節は、&lt;c2&gt;&lt;s3&gt;Item&lt;/s3&gt;&lt;/c2&gt;に要求してあるプロトコルに準拠させます、しかしあなたはまた&lt;c6&gt;&lt;s7&gt;Item&lt;/s7&gt;&lt;/c6&gt;に特定の型であることを要求する総称体&lt;c4&gt;&lt;s5&gt;where&lt;/s5&gt;&lt;/c4&gt;節を書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The generic &lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt; clause on &lt;c2&gt;&lt;s3&gt;Iterator&lt;/s3&gt;&lt;/c2&gt; requires that the iterator must traverse over elements of the same item type as the container’s items, regardless of the iterator’s type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この総称体&lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt;節が&lt;c2&gt;&lt;s3&gt;Iterator&lt;/s3&gt;&lt;/c2&gt;上で要求するのは、そのイテレータがコンテナのもつ要素と同じ項目型の要素に対して見ていくことです、そのイテレータの持つ型に関係なく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The generic &lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt; clause requires that the iterator for the sequence must traverse over elements of type &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この総称体&lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt;節が要求するのは、このシーケンスのためのイテレータが型&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;の要素について見ていかなければなければならないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The generic parameter &lt;c0&gt;&lt;s1&gt;Indices&lt;/s1&gt;&lt;/c0&gt; in angle brackets has to be a type that conforms to the &lt;c2&gt;&lt;s3&gt;Sequence&lt;/s3&gt;&lt;/c2&gt; protocol from the standard library.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>山括弧の中の総称体パラメータ&lt;c0&gt;&lt;s1&gt;Indices&lt;/s1&gt;&lt;/c0&gt;は、それは標準ライブラリからの&lt;c2&gt;&lt;s3&gt;Sequence&lt;/s3&gt;&lt;/c2&gt;プロトコルに準拠する型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The generic version of the function uses a &lt;e0&gt;placeholder&lt;/e0&gt; type name (called &lt;c1&gt;&lt;s2&gt;T&lt;/s2&gt;&lt;/c1&gt;, in this case) instead of an &lt;e3&gt;actual&lt;/e3&gt; type name (such as &lt;c4&gt;&lt;s5&gt;Int&lt;/s5&gt;&lt;/c4&gt;, &lt;c6&gt;&lt;s7&gt;String&lt;/s7&gt;&lt;/c6&gt;, or &lt;c8&gt;&lt;s9&gt;Double&lt;/s9&gt;&lt;/c8&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数の総称体版は、&lt;e0&gt;プレースホルダ&lt;/e0&gt;型名（この場合、&lt;c1&gt;&lt;s2&gt;T&lt;/s2&gt;&lt;/c1&gt;と呼ばれるもの）を&lt;e3&gt;実際の&lt;/e3&gt;型名（例えば&lt;c4&gt;&lt;s5&gt;Int&lt;/s5&gt;&lt;/c4&gt;、&lt;c6&gt;&lt;s7&gt;String&lt;/s7&gt;&lt;/c6&gt;、または&lt;c8&gt;&lt;s9&gt;Double&lt;/s9&gt;&lt;/c8&gt;）の代わりに使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The getter and setter for &lt;c6&gt;&lt;s7&gt;height&lt;/s7&gt;&lt;/c6&gt; and &lt;c8&gt;&lt;s9&gt;width&lt;/s9&gt;&lt;/c8&gt; wrap access to the &lt;c10&gt;&lt;s11&gt;wrappedValue&lt;/s11&gt;&lt;/c10&gt; property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;height&lt;/s7&gt;&lt;/c6&gt;と&lt;c8&gt;&lt;s9&gt;width&lt;/s9&gt;&lt;/c8&gt;に対するゲッターとセッターは、&lt;c10&gt;&lt;s11&gt;wrappedValue&lt;/s11&gt;&lt;/c10&gt;プロパティへのアクセスをラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The getter and setter requirements can be satisfied by a conforming type in a variety of ways.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ゲッターとセッター要件は、準拠している型によっていろいろなやり方で満たされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The getter is used to read the value, and the setter is used to write the value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ゲッターが値を読むために使われます、そしてセッターが値を書くために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The given expression is evaluated when the function is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>与えられた式は、関数が呼び出される時に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The global and local variables you have encountered in previous chapters have all been &lt;e0&gt;stored variables&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが前の章において遭遇したグローバルおよびローカル変数は、すべて&lt;e0&gt;格納変数&lt;/e0&gt;でした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The grammar described here is intended to help you understand the language in more detail, rather than to allow you to directly implement a parser or compiler.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここで記述される文法は、あなたが更に詳細に言語を理解するのを手伝うつもりのもので、あなたに直ちにパーサーまたはコンパイラを実装させるようにするものではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The grammar production above is equivalent to the following two productions, where the alternatives are spelled out explicitly:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の文法導出は以下の２つの導出に等しいです、そこでは代替物がそれぞれ分けて書かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The half-open range operator also has a one-sided form that’s written with only its final value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>半開範囲演算子もまた、それの最後の値のみで記述される、片側形式を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The hexadecimal fraction consists of a decimal point followed by a sequence of hexadecimal digits.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>16進の小数部は、小数点に続く一連の16進の桁から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The hypothetical function above has two type parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の仮定の関数は、２つの型パラメータを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The identifier specifies the name to be exposed to Objective-C for the entity that the &lt;c2&gt;&lt;s3&gt;objc&lt;/s3&gt;&lt;/c2&gt; attribute applies to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この識別子は、Objective-Cへと暴露される名前を&lt;c2&gt;&lt;s3&gt;objc&lt;/s3&gt;&lt;/c2&gt;属性を適用される存在に対して指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The identity key path refers to a whole instance, so you can use it to access and change all of the data stored in a variable in a single step.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同一性キーパスはインスタンス全体を参照します、それであなたはそれを使って、ただ一段階で変数の中に格納されたデータの全てにアクセスおよび変更できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The illustration below depicts three sets—&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;b&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;c&lt;/s5&gt;&lt;/c4&gt;—with overlapping regions representing elements shared among sets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の図は３つの集合—&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;b&lt;/s3&gt;&lt;/c2&gt;、そして&lt;c4&gt;&lt;s5&gt;c&lt;/s5&gt;&lt;/c4&gt;—を集合間で共有される要素を表している重なり合う領域とともに描写します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The illustration below depicts two sets—&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;b&lt;/s3&gt;&lt;/c2&gt;—with the results of various set operations represented by the shaded regions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の図は、２つの集合—&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;b&lt;/s3&gt;&lt;/c2&gt;—を網掛けの領域で表される様々な集合演算の結果とともに描写します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The illustration below shows the push and pop behavior for a stack:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下のイラストは、あるスタックのプッシュおよびポップ挙動を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The illustration below shows the results of &lt;c0&gt;&lt;s1&gt;11111111&lt;/s1&gt; &lt;s2&gt;&lt;&lt;&lt;/s2&gt; &lt;s3&gt;1&lt;/s3&gt;&lt;/c0&gt; (which is &lt;c4&gt;&lt;s5&gt;11111111&lt;/s5&gt;&lt;/c4&gt; shifted to the left by &lt;c6&gt;&lt;s7&gt;1&lt;/s7&gt;&lt;/c6&gt; place), and &lt;c8&gt;&lt;s9&gt;11111111&lt;/s9&gt; &lt;s10&gt;&gt;&gt;&lt;/s10&gt; &lt;s11&gt;1&lt;/s11&gt;&lt;/c8&gt; (which is &lt;c12&gt;&lt;s13&gt;11111111&lt;/s13&gt;&lt;/c12&gt; shifted to the right by &lt;c14&gt;&lt;s15&gt;1&lt;/s15&gt;&lt;/c14&gt; place).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下のイラストは、&lt;c0&gt;&lt;s1&gt;11111111&lt;/s1&gt; &lt;s2&gt;&lt;&lt;&lt;/s2&gt; &lt;s3&gt;1&lt;/s3&gt;&lt;/c0&gt;（それは、&lt;c6&gt;&lt;s7&gt;1&lt;/s7&gt;&lt;/c6&gt;桁だけ左へシフトされる&lt;c4&gt;&lt;s5&gt;11111111&lt;/s5&gt;&lt;/c4&gt;です）、そして&lt;c8&gt;&lt;s9&gt;11111111&lt;/s9&gt; &lt;s10&gt;&gt;&gt;&lt;/s10&gt; &lt;s11&gt;1&lt;/s11&gt;&lt;/c8&gt;（それは、&lt;c14&gt;&lt;s15&gt;1&lt;/s15&gt;&lt;/c14&gt;桁だけ右へシフトされる&lt;c12&gt;&lt;s13&gt;11111111&lt;/s13&gt;&lt;/c12&gt;です）の結果を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The immediate issue is that the &lt;c0&gt;&lt;s1&gt;Shape&lt;/s1&gt;&lt;/c0&gt; doesn’t include an &lt;c2&gt;&lt;s3&gt;==&lt;/s3&gt;&lt;/c2&gt; operator as part of its protocol requirements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>当面の問題は、&lt;c0&gt;&lt;s1&gt;Shape&lt;/s1&gt;&lt;/c0&gt;がそれのプロトコル要件として&lt;c2&gt;&lt;s3&gt;==&lt;/s3&gt;&lt;/c2&gt;演算子を含まないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The implementation of &lt;c0&gt;&lt;s1&gt;gameDidStart(_:)&lt;/s1&gt;&lt;/c0&gt; shown above uses the &lt;c2&gt;&lt;s3&gt;game&lt;/s3&gt;&lt;/c2&gt; parameter to print some introductory information about the game that is about to be played.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上で示される&lt;c0&gt;&lt;s1&gt;gameDidStart(_:)&lt;/s1&gt;&lt;/c0&gt;の実装は、&lt;c2&gt;&lt;s3&gt;game&lt;/s3&gt;&lt;/c2&gt;パラメータを使って、プレイされようとしているゲームに関する若干の紹介の情報を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The implementation of &lt;c10&gt;&lt;s11&gt;max(_:_:)&lt;/s11&gt;&lt;/c10&gt; uses only functionality that all &lt;c12&gt;&lt;s13&gt;Comparable&lt;/s13&gt;&lt;/c12&gt; types share.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c10&gt;&lt;s11&gt;max(_:_:)&lt;/s11&gt;&lt;/c10&gt;の実装は、全ての&lt;c12&gt;&lt;s13&gt;Comparable&lt;/s13&gt;&lt;/c12&gt;型が共有する機能性だけを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The implementation of the &lt;c0&gt;&lt;s1&gt;vend(itemNamed:)&lt;/s1&gt;&lt;/c0&gt; method uses &lt;c2&gt;&lt;s3&gt;guard&lt;/s3&gt;&lt;/c2&gt; statements to exit the method early and throw appropriate errors if any of the requirements for purchasing a snack aren’t met.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;vend(itemNamed:)&lt;/s1&gt;&lt;/c0&gt;メソッドの実装は&lt;c2&gt;&lt;s3&gt;guard&lt;/s3&gt;&lt;/c2&gt;文を使って、購入スナックに必要な何かが満たされないならば早めにそのメソッドを終了して対応するエラーをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The imported module must be compiled with testing enabled.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インポートされたモジュールは、テストすることを可能にされてコンパイルされなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The individual cases of an enumeration automatically receive the same access level as the enumeration they belong to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある列挙の個々のケース節は、自動的にそれらが属している列挙と同じアクセス水準を与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The information about &lt;a2&gt;&lt;s3&gt;Accessing Properties Through Optional Chaining&lt;/s3&gt;&lt;/a2&gt; has been updated accordingly, and the examples of checking for method call success in &lt;a4&gt;&lt;s5&gt;Calling Methods Through Optional Chaining&lt;/s5&gt;&lt;/a4&gt; have been expanded to show how to check for property setting success.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a2&gt;&lt;s3&gt;オプショナル連鎖を通してプロパティにアクセスする&lt;/s3&gt;&lt;/a2&gt;についての情報はそれを受けて更新されました、そして&lt;a4&gt;&lt;s5&gt;オプショナル連鎖を通してメソッドを呼び出す&lt;/s5&gt;&lt;/a4&gt;の中のメソッド呼び出しがうまくいったかを確認する例は拡張されて、プロパティの設定がうまくいったかを確認する方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The inherited version of &lt;c8&gt;&lt;s9&gt;init()&lt;/s9&gt;&lt;/c8&gt; functions in exactly the same way as the &lt;c10&gt;&lt;s11&gt;Food&lt;/s11&gt;&lt;/c10&gt; version, except that it delegates to the &lt;c12&gt;&lt;s13&gt;RecipeIngredient&lt;/s13&gt;&lt;/c12&gt; version of &lt;c14&gt;&lt;s15&gt;init(name:&lt;/s15&gt; &lt;s16&gt;String)&lt;/s16&gt;&lt;/c14&gt; rather than the &lt;c17&gt;&lt;s18&gt;Food&lt;/s18&gt;&lt;/c17&gt; version.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c8&gt;&lt;s9&gt;init()&lt;/s9&gt;&lt;/c8&gt;の継承された改変板は、&lt;c10&gt;&lt;s11&gt;Food&lt;/s11&gt;&lt;/c10&gt;版と同じ正確に方法で機能しますが、それが&lt;c17&gt;&lt;s18&gt;Food&lt;/s18&gt;&lt;/c17&gt;板ではなく&lt;c12&gt;&lt;s13&gt;RecipeIngredient&lt;/s13&gt;&lt;/c12&gt;版の&lt;c14&gt;&lt;s15&gt;init(name:&lt;/s15&gt; &lt;s16&gt;String)&lt;/s16&gt;&lt;/c14&gt;に委任することを除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The init! Failable Initializer</seg>
      </tuv>
      <tuv lang="JA">
        <seg>init!失敗できるイニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initialization of &lt;c0&gt;&lt;s1&gt;airports&lt;/s1&gt;&lt;/c0&gt; could have been written in a shorter form instead:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;airports&lt;/s1&gt;&lt;/c0&gt;の初期化は、代わりにより短い形式で書かれることもできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initialization of &lt;c0&gt;&lt;s1&gt;shoppingList&lt;/s1&gt;&lt;/c0&gt; could have been written in a shorter form instead:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;shoppingList&lt;/s1&gt;&lt;/c0&gt;の初期化は、前の代わりにより短い形式に書かれることもできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initialization of &lt;c2&gt;&lt;s3&gt;favoriteGenres&lt;/s3&gt;&lt;/c2&gt; could have been written in a shorter form instead:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;favoriteGenres&lt;/s3&gt;&lt;/c2&gt;の初期化は、代わりに次のような短い形式で書かれることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initializer &lt;e0&gt;expression&lt;/e0&gt; can’t be present in a protocol declaration, but in all other contexts, the initializer &lt;e1&gt;expression&lt;/e1&gt; is optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザ&lt;e0&gt;式&lt;/e0&gt;はプロトコル宣言に含まれることはできません、しかし全ての他の文脈ではそうではありません、イニシャライザ&lt;e1&gt;式&lt;/e1&gt;は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initializer &lt;e0&gt;expression&lt;/e0&gt; is optional in the context of a class or structure declaration, but required elsewhere.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザ&lt;e0&gt;式&lt;/e0&gt;は、クラスまたは構造体宣言の文脈では任意です、しかしその他では必須です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initializer call &lt;c0&gt;&lt;s1&gt;Celsius(37.0)&lt;/s1&gt;&lt;/c0&gt; is clear in its intent without the need for an argument label.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザ呼び出し&lt;c0&gt;&lt;s1&gt;Celsius(37.0)&lt;/s1&gt;&lt;/c0&gt;は、引数ラベルを必要としなくともその意図は明快です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initializer can then fail if the provided parameters do not match an appropriate enumeration case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このイニシャライザは、提供されたパラメータが適切な列挙ケース節に適合しないならばその時に失敗できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initializer for &lt;c0&gt;&lt;s1&gt;City&lt;/s1&gt;&lt;/c0&gt; is called from within the initializer for &lt;c2&gt;&lt;s3&gt;Country&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;City&lt;/s1&gt;&lt;/c0&gt;のためのイニシャライザは、&lt;c2&gt;&lt;s3&gt;Country&lt;/s3&gt;&lt;/c2&gt;のためにイニシャライザの内部から呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initializer then calls the structure’s automatic memberwise initializer &lt;c4&gt;&lt;s5&gt;init(origin:size:)&lt;/s5&gt;&lt;/c4&gt;, which stores the new origin and size values in the appropriate properties:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザはそれから、構造体の自動的なメンバー関連イニシャライザ&lt;c4&gt;&lt;s5&gt;init(origin:size:)&lt;/s5&gt;&lt;/c4&gt;を呼びます、それは、新しい原点とサイズ値を適切なプロパティに保管します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initializer uses the wrapped value that’s specified here, and it uses the default maximum value of 12.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザは、ここで指定されるラップ値を使います、そしてそれは省略時の最大値限の12を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The instance of &lt;c0&gt;&lt;s1&gt;SmallNumber&lt;/s1&gt;&lt;/c0&gt; that wraps &lt;c2&gt;&lt;s3&gt;height&lt;/s3&gt;&lt;/c2&gt; is created by calling &lt;c4&gt;&lt;s5&gt;SmallNumber(wrappedValue:&lt;/s5&gt; &lt;s6&gt;1)&lt;/s6&gt;&lt;/c4&gt;, which uses the default maximum value of 12.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;height&lt;/s3&gt;&lt;/c2&gt;をラップする&lt;c0&gt;&lt;s1&gt;SmallNumber&lt;/s1&gt;&lt;/c0&gt;のインスタンスは、&lt;c4&gt;&lt;s5&gt;SmallNumber(wrappedValue:&lt;/s5&gt; &lt;s6&gt;1)&lt;/s6&gt;&lt;/c4&gt;を呼び出すことによって作成されます、それは省略時の最大値の12を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The instance of &lt;c0&gt;&lt;s1&gt;SmallNumber&lt;/s1&gt;&lt;/c0&gt; that wraps &lt;c2&gt;&lt;s3&gt;height&lt;/s3&gt;&lt;/c2&gt; is created by calling &lt;c4&gt;&lt;s5&gt;SmallNumber(wrappedValue:&lt;/s5&gt; &lt;s6&gt;2,&lt;/s6&gt; &lt;s7&gt;maximum:&lt;/s7&gt; &lt;s8&gt;5)&lt;/s8&gt;&lt;/c4&gt;, and the instance that wraps &lt;c9&gt;&lt;s10&gt;width&lt;/s10&gt;&lt;/c9&gt; is created by calling &lt;c11&gt;&lt;s12&gt;SmallNumber(wrappedValue:&lt;/s12&gt; &lt;s13&gt;3,&lt;/s13&gt; &lt;s14&gt;maximum:&lt;/s14&gt; &lt;s15&gt;4)&lt;/s15&gt;&lt;/c11&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;height&lt;/s3&gt;&lt;/c2&gt;をラップする&lt;c0&gt;&lt;s1&gt;SmallNumber&lt;/s1&gt;&lt;/c0&gt;インスタンスは、&lt;c4&gt;&lt;s5&gt;SmallNumber(wrappedValue:&lt;/s5&gt; &lt;s6&gt;2,&lt;/s6&gt; &lt;s7&gt;maximum:&lt;/s7&gt; &lt;s8&gt;5)&lt;/s8&gt;&lt;/c4&gt;を呼び出すことによって作成されます、&lt;c9&gt;&lt;s10&gt;width&lt;/s10&gt;&lt;/c9&gt;をラップするインスタンスは、&lt;c11&gt;&lt;s12&gt;SmallNumber(wrappedValue:&lt;/s12&gt; &lt;s13&gt;3,&lt;/s13&gt; &lt;s14&gt;maximum:&lt;/s14&gt; &lt;s15&gt;4)&lt;/s15&gt;&lt;/c11&gt;を呼び出すことによって作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The instance that wraps &lt;c7&gt;&lt;s8&gt;width&lt;/s8&gt;&lt;/c7&gt; is created by calling &lt;c9&gt;&lt;s10&gt;SmallNumber(wrappedValue:&lt;/s10&gt; &lt;s11&gt;2,&lt;/s11&gt; &lt;s12&gt;maximum:&lt;/s12&gt; &lt;s13&gt;9)&lt;/s13&gt;&lt;/c9&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c7&gt;&lt;s8&gt;width&lt;/s8&gt;&lt;/c7&gt;をラップするインスタンスは、&lt;c9&gt;&lt;s10&gt;SmallNumber(wrappedValue:&lt;/s10&gt; &lt;s11&gt;2,&lt;/s11&gt; &lt;s12&gt;maximum:&lt;/s12&gt; &lt;s13&gt;9)&lt;/s13&gt;&lt;/c9&gt;を呼び出すことによって作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The instances can then refer to each other without creating a strong reference cycle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インスタンスは、そのあと強い参照循環をつくることなくお互いに言及することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The instances of &lt;c0&gt;&lt;s1&gt;SmallNumber&lt;/s1&gt;&lt;/c0&gt; that wrap &lt;c2&gt;&lt;s3&gt;height&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;width&lt;/s5&gt;&lt;/c4&gt; are created by calling &lt;c6&gt;&lt;s7&gt;SmallNumber()&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;height&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;width&lt;/s5&gt;&lt;/c4&gt;をラップする&lt;c0&gt;&lt;s1&gt;SmallNumber&lt;/s1&gt;&lt;/c0&gt;のインスタンスは、&lt;c6&gt;&lt;s7&gt;SmallNumber()&lt;/s7&gt;&lt;/c6&gt;を呼び出すことによって作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The instances of &lt;c5&gt;&lt;s6&gt;SmallNumber&lt;/s6&gt;&lt;/c5&gt; that wrap &lt;c7&gt;&lt;s8&gt;height&lt;/s8&gt;&lt;/c7&gt; and &lt;c9&gt;&lt;s10&gt;width&lt;/s10&gt;&lt;/c9&gt; are created by calling &lt;c11&gt;&lt;s12&gt;SmallNumber(wrappedValue:&lt;/s12&gt; &lt;s13&gt;1)&lt;/s13&gt;&lt;/c11&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c7&gt;&lt;s8&gt;height&lt;/s8&gt;&lt;/c7&gt;と&lt;c9&gt;&lt;s10&gt;width&lt;/s10&gt;&lt;/c9&gt;をラップする&lt;c5&gt;&lt;s6&gt;SmallNumber&lt;/s6&gt;&lt;/c5&gt;のインスタンスは、&lt;c11&gt;&lt;s12&gt;SmallNumber(wrappedValue:&lt;/s12&gt; &lt;s13&gt;1)&lt;/s13&gt;&lt;/c11&gt;を呼び出すことによって作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The instance’s &lt;c0&gt;&lt;s1&gt;asHTML&lt;/s1&gt;&lt;/c0&gt; property holds a strong reference to its closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このインスタンスの&lt;c0&gt;&lt;s1&gt;asHTML&lt;/s1&gt;&lt;/c0&gt;プロパティは、それのクロージャに対する強い参照を保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The integers start at zero and count up by one for each item; if you enumerate over a whole array, these integers match the items’ indices.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その整数はゼロから始めて各項目に対して１ずつ数えていきます；あなたが配列全体をすべて列挙するならば、それらの整数はそれら項目のもつインデックスと一致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The interpolated expression can contain a string literal, but can’t contain an unescaped backslash, a carriage return, or a line feed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>差し込まれた式は、文字列リテラルを含むことができます、しかしエスケープされないバックスラッシュ、キャリッジリターン、またはラインフィードを含むことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The invocation function uses the C calling convention.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この呼出関数はC呼出規約を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The items in &lt;c0&gt;&lt;s1&gt;someContainer&lt;/s1&gt;&lt;/c0&gt; can be checked with the not equal operator (&lt;c2&gt;&lt;s3&gt;!=&lt;/s3&gt;&lt;/c2&gt;) to see if they’re different from each other.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;someContainer&lt;/s1&gt;&lt;/c0&gt;の中の項目は、それらがお互いと異なるかどうか見るために不等演算子（&lt;c2&gt;&lt;s3&gt;!=&lt;/s3&gt;&lt;/c2&gt;）を使って確認されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The items stored in &lt;c0&gt;&lt;s1&gt;library&lt;/s1&gt;&lt;/c0&gt; are still &lt;c2&gt;&lt;s3&gt;Movie&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;Song&lt;/s5&gt;&lt;/c4&gt; instances behind the scenes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;library&lt;/s1&gt;&lt;/c0&gt;に格納される項目は、依然として舞台裏では&lt;c2&gt;&lt;s3&gt;Movie&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;Song&lt;/s5&gt;&lt;/c4&gt;インスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key type of a dictionary must conform to the Swift standard library &lt;c0&gt;&lt;s1&gt;Hashable&lt;/s1&gt;&lt;/c0&gt; protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある辞書のキーの型は、スウィフト標準ライブラリ&lt;c0&gt;&lt;s1&gt;Hashable&lt;/s1&gt;&lt;/c0&gt;プロトコルに準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key-value pairs are written as a list, separated by commas, surrounded by a pair of square brackets:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「キーと値」の対はリストとして書かれます、それはコンマで区切られ、一対の角括弧に囲まれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The largest valid index in an array is &lt;c2&gt;&lt;s3&gt;count&lt;/s3&gt; &lt;s4&gt;-&lt;/s4&gt; &lt;s5&gt;1&lt;/s5&gt;&lt;/c2&gt; because arrays are indexed from zero—however, when &lt;c6&gt;&lt;s7&gt;count&lt;/s7&gt;&lt;/c6&gt; is &lt;c8&gt;&lt;s9&gt;0&lt;/s9&gt;&lt;/c8&gt; (meaning the array is empty), there are no valid indexes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある配列の中の最も大きい有効なインデックスは&lt;c2&gt;&lt;s3&gt;count&lt;/s3&gt; &lt;s4&gt;-&lt;/s4&gt; &lt;s5&gt;1&lt;/s5&gt;&lt;/c2&gt;です、なぜなら配列はゼロからインデックスをつけられるからです — しかしながら、&lt;c6&gt;&lt;s7&gt;count&lt;/s7&gt;&lt;/c6&gt;が&lt;c8&gt;&lt;s9&gt;0&lt;/s9&gt;&lt;/c8&gt;である時（配列がからであるのを意味しています）、有効なインデックスは全然ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The last &lt;c12&gt;&lt;s13&gt;defer&lt;/s13&gt;&lt;/c12&gt; statement in source code order executes first.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ソースコード順序での最後の&lt;c12&gt;&lt;s13&gt;defer&lt;/s13&gt;&lt;/c12&gt;文は最初に実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The last argument, &lt;c2&gt;&lt;s3&gt;*&lt;/s3&gt;&lt;/c2&gt;, is required and specifies that on any other platform, the body of the &lt;c4&gt;&lt;s5&gt;if&lt;/s5&gt;&lt;/c4&gt; executes on the minimum deployment target specified by your target.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最後の引数&lt;c2&gt;&lt;s3&gt;*&lt;/s3&gt;&lt;/c2&gt;は、必要で、あらゆる他のプラットホーム上を指定します、&lt;c4&gt;&lt;s5&gt;if&lt;/s5&gt;&lt;/c4&gt;の本文は、あなたの対象で指定される、最小の開発対象で実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The last expression in the array can be followed by an optional comma.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列の最後の式の後に、１つの任意のコンマが続くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The last expression in the dictionary can be followed by an optional comma.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書の最後の式の後に、１つの任意のコンマが続くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The last four &lt;c26&gt;&lt;s27&gt;codeUnit&lt;/s27&gt;&lt;/c26&gt; values (&lt;c28&gt;&lt;s29&gt;240&lt;/s29&gt;&lt;/c28&gt;, &lt;c30&gt;&lt;s31&gt;159&lt;/s31&gt;&lt;/c30&gt;, &lt;c32&gt;&lt;s33&gt;144&lt;/s33&gt;&lt;/c32&gt;, &lt;c34&gt;&lt;s35&gt;182&lt;/s35&gt;&lt;/c34&gt;) are a four-byte UTF-8 representation of the &lt;c36&gt;&lt;s37&gt;DOG&lt;/s37&gt; &lt;s38&gt;FACE&lt;/s38&gt;&lt;/c36&gt; character.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最後の４つの&lt;c26&gt;&lt;s27&gt;codeUnit&lt;/s27&gt;&lt;/c26&gt;値（&lt;c28&gt;&lt;s29&gt;240&lt;/s29&gt;&lt;/c28&gt;、&lt;c30&gt;&lt;s31&gt;159&lt;/s31&gt;&lt;/c30&gt;、&lt;c32&gt;&lt;s33&gt;144&lt;/s33&gt;&lt;/c32&gt;、&lt;c34&gt;&lt;s35&gt;182&lt;/s35&gt;&lt;/c34&gt;）は、&lt;c36&gt;&lt;s37&gt;DOG&lt;/s37&gt; &lt;s38&gt;FACE&lt;/s38&gt;&lt;/c36&gt;文字の４バイトUTF-８叙述です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The last part of the example above shows that &lt;c0&gt;&lt;s1&gt;Self&lt;/s1&gt;&lt;/c0&gt; refers to the runtime type &lt;c2&gt;&lt;s3&gt;Subclass&lt;/s3&gt;&lt;/c2&gt; of the value of &lt;c4&gt;&lt;s5&gt;z&lt;/s5&gt;&lt;/c4&gt;, not the compile-time type &lt;c6&gt;&lt;s7&gt;Superclass&lt;/s7&gt;&lt;/c6&gt; of the variable itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例の最後の部分は、&lt;c0&gt;&lt;s1&gt;Self&lt;/s1&gt;&lt;/c0&gt;が&lt;c4&gt;&lt;s5&gt;z&lt;/s5&gt;&lt;/c4&gt;の値のランタイム型&lt;c2&gt;&lt;s3&gt;Subclass&lt;/s3&gt;&lt;/c2&gt;を参照することを示します、変数それ自体のコンパイル時型&lt;c6&gt;&lt;s7&gt;Superclass&lt;/s7&gt;&lt;/c6&gt;ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The length of an &lt;c6&gt;&lt;s7&gt;NSString&lt;/s7&gt;&lt;/c6&gt; is based on the number of 16-bit code units within the string’s UTF-16 representation and not the number of Unicode extended grapheme clusters within the string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある&lt;c6&gt;&lt;s7&gt;NSString&lt;/s7&gt;&lt;/c6&gt;の長さは、その文字列のUTF-16表現内の16ビットコード単位の数に基づきます、その文字列内のユニコード拡張書記素クラスタの数ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The less specific return type information from &lt;c4&gt;&lt;s5&gt;protoFlip(_:)&lt;/s5&gt;&lt;/c4&gt; means that many operations that depend on type information aren’t available on the returned value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;protoFlip(_:)&lt;/s5&gt;&lt;/c4&gt;からの具体性のより少ない戻り型情報は、型情報に依存する多くの演算が、その返された値の上で利用可能でないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The letter &lt;c0&gt;&lt;s1&gt;é&lt;/s1&gt;&lt;/c0&gt; can be represented as the single Unicode scalar &lt;c2&gt;&lt;s3&gt;é&lt;/s3&gt;&lt;/c2&gt; (&lt;c4&gt;&lt;s5&gt;LATIN&lt;/s5&gt; &lt;s6&gt;SMALL&lt;/s6&gt; &lt;s7&gt;LETTER&lt;/s7&gt; &lt;s8&gt;E&lt;/s8&gt; &lt;s9&gt;WITH&lt;/s9&gt; &lt;s10&gt;ACUTE&lt;/s10&gt;&lt;/c4&gt;, or &lt;c11&gt;&lt;s12&gt;U+00E9&lt;/s12&gt;&lt;/c11&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字&lt;c0&gt;&lt;s1&gt;é&lt;/s1&gt;&lt;/c0&gt;は、単一のユニコード・スカラー&lt;c2&gt;&lt;s3&gt;é&lt;/s3&gt;&lt;/c2&gt;（&lt;c4&gt;&lt;s5&gt;LATIN&lt;/s5&gt; &lt;s6&gt;SMALL&lt;/s6&gt; &lt;s7&gt;LETTER&lt;/s7&gt; &lt;s8&gt;E&lt;/s8&gt; &lt;s9&gt;WITH&lt;/s9&gt; &lt;s10&gt;ACUTE&lt;/s10&gt;&lt;/c4&gt;、または&lt;c11&gt;&lt;s12&gt;U+00E9&lt;/s12&gt;&lt;/c11&gt;）として表わされることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The line break after the &lt;c0&gt;&lt;s1&gt;"""&lt;/s1&gt;&lt;/c0&gt; that begins the multiline string literal is not part of the string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数行文字列リテラルを開始する&lt;c0&gt;&lt;s1&gt;"""&lt;/s1&gt;&lt;/c0&gt;の後のラインブレークは、その文字列の一部ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The line break before the &lt;c2&gt;&lt;s3&gt;"""&lt;/s3&gt;&lt;/c2&gt; that ends the literal is also not part of the string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リテラルの終わりの&lt;c2&gt;&lt;s3&gt;"""&lt;/s3&gt;&lt;/c2&gt;の前のキャリッジリターンまたはラインフィードもまた、その文字列の一部ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The line number on which it appears.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが現れる行番号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The listing below does the same assignment, but it uses a function to create the address.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下でのコード出力は、同じ代入を行います、しかしそれはある関数を使ってアドレスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The literal value &lt;c0&gt;&lt;s1&gt;3&lt;/s1&gt;&lt;/c0&gt; can be added directly to the literal value &lt;c2&gt;&lt;s3&gt;0.14159&lt;/s3&gt;&lt;/c2&gt;, because number literals don’t have an explicit type in and of themselves.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リテラル値&lt;c0&gt;&lt;s1&gt;3&lt;/s1&gt;&lt;/c0&gt;は、直接にリテラル値&lt;c2&gt;&lt;s3&gt;0.14159&lt;/s3&gt;&lt;/c2&gt;に加えられることができます、なぜなら数リテラルがそれら自身において明確な型を持たないためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The literal value of &lt;c0&gt;&lt;s1&gt;3&lt;/s1&gt;&lt;/c0&gt; has no explicit type in and of itself, and so an appropriate output type of &lt;c2&gt;&lt;s3&gt;Double&lt;/s3&gt;&lt;/c2&gt; is inferred from the presence of a floating-point literal as part of the addition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リテラル値&lt;c0&gt;&lt;s1&gt;3&lt;/s1&gt;&lt;/c0&gt;は明確な型をそれ自体は持ちません、それで適切な出力の&lt;c2&gt;&lt;s3&gt;Double&lt;/s3&gt;&lt;/c2&gt;型は、加算部分の浮動小数点リテラルの存在から推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The location in memory refers to what is being accessed—for example, a variable, constant, or property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メモリ中の位置はアクセスされているのは何かを参照します — 例えば、変数、定数、またはプロパティ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The logical NOT operator is a prefix operator, and appears immediately before the value it operates on, without any white space.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>論理否定演算子は接頭辞演算子です、そして全く空白なしで、それが作用する値の直前に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The loop then ends, and control returns to the &lt;c2&gt;&lt;s3&gt;while&lt;/s3&gt;&lt;/c2&gt; condition to decide whether another turn is required.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ループはそれから終わります、そして制御はもう１つの回が必要かどうか決めるために&lt;c2&gt;&lt;s3&gt;while&lt;/s3&gt;&lt;/c2&gt;条件に戻ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The loop’s condition (&lt;c0&gt;&lt;s1&gt;while&lt;/s1&gt; &lt;s2&gt;square&lt;/s2&gt; &lt;s3&gt;&lt;&lt;/s3&gt; &lt;s4&gt;finalSquare&lt;/s4&gt;&lt;/c0&gt;) is the same as before, but this time it’s not evaluated until the &lt;e5&gt;end&lt;/e5&gt; of the first run through the loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ループの条件（&lt;c0&gt;&lt;s1&gt;while&lt;/s1&gt; &lt;s2&gt;square&lt;/s2&gt; &lt;s3&gt;&lt;&lt;/s3&gt; &lt;s4&gt;finalSquare&lt;/s4&gt;&lt;/c0&gt;）は前と同じものです、しかし今回それは最初のループ通り抜けの&lt;e5&gt;終わり&lt;/e5&gt;まで評価されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The main difference is that during phase 1, Objective-C assigns zero or null values (such as &lt;c0&gt;&lt;s1&gt;0&lt;/s1&gt;&lt;/c0&gt; or &lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;) to every property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>主な違いは、段階１の間に、Objective-Cがゼロまたは無効な値（例えば&lt;c0&gt;&lt;s1&gt;0&lt;/s1&gt;&lt;/c0&gt;または&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;）をあらゆるプロパティに代入するということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The main difference is that optional chaining fails gracefully when the optional is &lt;c6&gt;&lt;s7&gt;nil&lt;/s7&gt;&lt;/c6&gt;, whereas forced unwrapping triggers a runtime error when the optional is &lt;c8&gt;&lt;s9&gt;nil&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>大きな違いは、オプショナル連鎖はそのオプショナルが&lt;c6&gt;&lt;s7&gt;nil&lt;/s7&gt;&lt;/c6&gt;であるとき潔く失敗します、だけれども強制アンラップはそのオプショナルが&lt;c8&gt;&lt;s9&gt;nil&lt;/s9&gt;&lt;/c8&gt;であるとき実行時エラーの引き金となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The main exception to this rule occurs when a parameter name for an instance method has the same name as a property of that instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この規則に対する主な例外は、インスタンスメソッドのパラメータ名がそのインスタンスのプロパティと同じ名前を持つ時に起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The matches succeeds if the &lt;c2&gt;&lt;s3&gt;~=&lt;/s3&gt;&lt;/c2&gt; operator returns &lt;c4&gt;&lt;s5&gt;true&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;~=&lt;/s3&gt;&lt;/c2&gt;演算子が&lt;c4&gt;&lt;s5&gt;true&lt;/s5&gt;&lt;/c4&gt;を返すならば、マッチは成功します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The members of a module access the top-level declarations of that module.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>モジュールのメンバーは、そのモジュールのトップレベルの宣言にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The members of a named type are named as part of the type’s declaration or extension.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>名前付きの型に属するメンバーは、型の宣言または拡張の一部として命名されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The members of a tuple are implicitly named using integers in the order they appear, starting from zero.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプルのメンバーは、整数を使って、それらが現れる順序で、ゼロから始めて、暗黙のうちに名前をつけられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The memberwise initializer is a shorthand way to initialize the member properties of new structure instances.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メンバー関連イニシャライザは、新しい構造体インスタンスのメンバープロパティを初期化するための略記方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The memory for these stored properties is now initialized.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの格納プロパティに対するメモリは、今や初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The memory is not yet initialized.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのメモリは、まだ初期化されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The metatype of a class, structure, or enumeration type is the name of that type followed by &lt;c0&gt;&lt;s1&gt;.Type&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるクラス、構造体、または列挙型のメタタイプは、その型の名前に&lt;c0&gt;&lt;s1&gt;.Type&lt;/s1&gt;&lt;/c0&gt;が続くものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The metatype of a protocol type—not the concrete type that conforms to the protocol at runtime—is the name of that protocol followed by &lt;c2&gt;&lt;s3&gt;.Protocol&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロトコル型 ― 実行時にそのプロトコルに準拠する具象型ではない ― のメタタイプは、そのプロトコルの名前に&lt;c2&gt;&lt;s3&gt;.Protocol&lt;/s3&gt;&lt;/c2&gt;が続くものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method can also assign a completely new instance to its implicit &lt;c1&gt;&lt;s2&gt;self&lt;/s2&gt;&lt;/c1&gt; property, and this new instance will replace the existing one when the method ends.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメソッドはまた、完全に新しいインスタンスをその暗黙の&lt;c1&gt;&lt;s2&gt;self&lt;/s2&gt;&lt;/c1&gt;プロパティに代入することができます、そして、そのメソッドが終了するとき、この新しいインスタンスは既存のものを置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method can then mutate (that is, change) its properties from within the method, and any changes that it makes are written back to the original structure when the method ends.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメソッドはそれからそれのプロパティをメソッド内部から変化させること（すなわち変更）ができます、そして、そのメソッドが終了するとき、それが行ったどんな変更も本来の構造体へ書き込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The method returns a new &lt;c8&gt;&lt;s9&gt;Vector2D&lt;/s9&gt;&lt;/c8&gt; instance, whose &lt;c10&gt;&lt;s11&gt;x&lt;/s11&gt;&lt;/c10&gt; and &lt;c12&gt;&lt;s13&gt;y&lt;/s13&gt;&lt;/c12&gt; properties are initialized with the sum of the &lt;c14&gt;&lt;s15&gt;x&lt;/s15&gt;&lt;/c14&gt; and &lt;c16&gt;&lt;s17&gt;y&lt;/s17&gt;&lt;/c16&gt; properties from the two &lt;c18&gt;&lt;s19&gt;Vector2D&lt;/s19&gt;&lt;/c18&gt; instances that are added together.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッドは、新しい&lt;c8&gt;&lt;s9&gt;Vector2D&lt;/s9&gt;&lt;/c8&gt;インスタンスを返します、それは&lt;c10&gt;&lt;s11&gt;x&lt;/s11&gt;&lt;/c10&gt;と&lt;c12&gt;&lt;s13&gt;y&lt;/s13&gt;&lt;/c12&gt;プロパティが一緒に加えられる２つの&lt;c18&gt;&lt;s19&gt;Vector2D&lt;/s19&gt;&lt;/c18&gt;インスタンスからの&lt;c14&gt;&lt;s15&gt;x&lt;/s15&gt;&lt;/c14&gt;と&lt;c16&gt;&lt;s17&gt;y&lt;/s17&gt;&lt;/c16&gt;プロパティの合計で初期化されるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The middle line has more indentation than the closing quotation marks, so it starts with that extra four-space indentation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>真ん中の行は終了引用符よりもっと字下げされます、なのでそれは追加の４つの空白の字下げで始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The minimum value that a &lt;c0&gt;&lt;s1&gt;UInt8&lt;/s1&gt;&lt;/c0&gt; can hold is zero, or &lt;c2&gt;&lt;s3&gt;00000000&lt;/s3&gt;&lt;/c2&gt; in binary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;UInt8&lt;/s1&gt;&lt;/c0&gt;が持つことができる最小限の値は、０、または２進数では&lt;c2&gt;&lt;s3&gt;00000000&lt;/s3&gt;&lt;/c2&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The minimum value that an &lt;c0&gt;&lt;s1&gt;Int8&lt;/s1&gt;&lt;/c0&gt; can hold is &lt;c2&gt;&lt;s3&gt;-128&lt;/s3&gt;&lt;/c2&gt;, or &lt;c4&gt;&lt;s5&gt;10000000&lt;/s5&gt;&lt;/c4&gt; in binary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Int8&lt;/s1&gt;&lt;/c0&gt;が持つことができる最小限の数は、&lt;c2&gt;&lt;s3&gt;-128&lt;/s3&gt;&lt;/c2&gt;、または２進数での&lt;c4&gt;&lt;s5&gt;10000000&lt;/s5&gt;&lt;/c4&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The module’s public interface consists of operations like joining and flipping a shape, and those operations return another &lt;c4&gt;&lt;s5&gt;Shape&lt;/s5&gt;&lt;/c4&gt; value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>モジュールのもつパブリックインターフェイスは、形の結合および裏返しのような演算からなります、そしてそれらの演算は別の&lt;c4&gt;&lt;s5&gt;Shape&lt;/s5&gt;&lt;/c4&gt;値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The mutating method needs write access to &lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt; for the duration of the method, and the in-out parameter needs write access to &lt;c2&gt;&lt;s3&gt;teammate&lt;/s3&gt;&lt;/c2&gt; for the same duration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変更メソッドは、&lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;に対する書き込みアクセスをメソッドの期間中に必要とします、そしてin-outパラメータは&lt;c2&gt;&lt;s3&gt;teammate&lt;/s3&gt;&lt;/c2&gt;に対する書き込みアクセスを同じ期間に必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name of a call-as-function method is &lt;c0&gt;&lt;s1&gt;callAsFunction()&lt;/s1&gt;&lt;/c0&gt;, or another name that begins with &lt;c2&gt;&lt;s3&gt;callAsFunction(&lt;/s3&gt;&lt;/c2&gt; and adds labeled or unlabeled arguments—for example, &lt;c4&gt;&lt;s5&gt;callAsFunction(_:_:)&lt;/s5&gt;&lt;/c4&gt; and &lt;c6&gt;&lt;s7&gt;callAsFunction(something:)&lt;/s7&gt;&lt;/c6&gt; are also valid call-as-function method names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>call-as-functionメソッドの名前は&lt;c0&gt;&lt;s1&gt;callAsFunction()&lt;/s1&gt;&lt;/c0&gt;、または&lt;c2&gt;&lt;s3&gt;callAsFunction(&lt;/s3&gt;&lt;/c2&gt;で始まりそしてラベル付きまたはラベル無し引数を加える別の名前です — 例えば&lt;c4&gt;&lt;s5&gt;callAsFunction(_:_:)&lt;/s5&gt;&lt;/c4&gt;および&lt;c6&gt;&lt;s7&gt;callAsFunction(something:)&lt;/s7&gt;&lt;/c6&gt;は同様に有効なcall-as-functionメソッド名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name of a class</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるクラスの名前</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name of a protocol</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロトコルの名前</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name of each case must be unique.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各ケース節の名前は、固有でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name of the declaration in which it appears.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが現れる宣言の名前。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name of the file in which it appears.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それが現れるファイルの名前。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name of the projected value is the same as the wrapped value, except it begins with a dollar sign (&lt;c3&gt;&lt;s4&gt;$&lt;/s4&gt;&lt;/c3&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>予測値の名前は、ラップされた値と同じです、それがドル記号（&lt;c3&gt;&lt;s4&gt;$&lt;/s4&gt;&lt;/c3&gt;）で始まることを除いては。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The nature of the mapping and the type of the returned value is left up to the closure to specify.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>マッピング（対応付け）の性質と返される値の型は、指定するクロージャに委ねられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The nearest thing in Objective-C is the ability to return &lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt; from a method that would otherwise return an object, with &lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt; meaning “the absence of a valid object.” However, this only works for objects—it doesn’t work for structures, basic C types, or enumeration values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cにおいて最も近いものは、オブジェクトを返すメソッドからそうできない場合に&lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;を返す能力です、そのとき&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;は「有効なオブジェクトの欠如」を意味しています。しかし、それは単にオブジェクトのためだけに働きます ― それは構造体、基本的なC型、または列挙値のために働きません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The nested &lt;c4&gt;&lt;s5&gt;incrementer()&lt;/s5&gt;&lt;/c4&gt; function captures two values, &lt;c6&gt;&lt;s7&gt;runningTotal&lt;/s7&gt;&lt;/c6&gt; and &lt;c8&gt;&lt;s9&gt;amount&lt;/s9&gt;&lt;/c8&gt;, from its surrounding context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>入れ子にされた&lt;c4&gt;&lt;s5&gt;incrementer()&lt;/s5&gt;&lt;/c4&gt;関数は、それを取り囲む前後関係から２つの値、&lt;c6&gt;&lt;s7&gt;runningTotal&lt;/s7&gt;&lt;/c6&gt;と&lt;c8&gt;&lt;s9&gt;amount&lt;/s9&gt;&lt;/c8&gt;を捕獲します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The nested enumeration can now be used with any &lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt; value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>入れ子にされた列挙は今やあらゆる&lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt;値で使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The new &lt;c0&gt;&lt;s1&gt;Bicycle&lt;/s1&gt;&lt;/c0&gt; class automatically gains all of the characteristics of &lt;c2&gt;&lt;s3&gt;Vehicle&lt;/s3&gt;&lt;/c2&gt;, such as its &lt;c4&gt;&lt;s5&gt;currentSpeed&lt;/s5&gt;&lt;/c4&gt; and &lt;c6&gt;&lt;s7&gt;description&lt;/s7&gt;&lt;/c6&gt; properties and its &lt;c8&gt;&lt;s9&gt;makeNoise()&lt;/s9&gt;&lt;/c8&gt; method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この新しい&lt;c0&gt;&lt;s1&gt;Bicycle&lt;/s1&gt;&lt;/c0&gt;クラスは、自動的に&lt;c2&gt;&lt;s3&gt;Vehicle&lt;/s3&gt;&lt;/c2&gt;のすべての特徴を獲得します、例えばそれの&lt;c4&gt;&lt;s5&gt;currentSpeed&lt;/s5&gt;&lt;/c4&gt;および&lt;c6&gt;&lt;s7&gt;description&lt;/s7&gt;&lt;/c6&gt;プロパティやそれの&lt;c8&gt;&lt;s9&gt;makeNoise()&lt;/s9&gt;&lt;/c8&gt;メソッドなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The new array’s type is inferred from the type of the two arrays you add together:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい配列の型は、あなたが一緒に加える２つの配列の型から推論されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The new type can then be used wherever its access level permits.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その新しい型はそれから、そのアクセス水準が許すところどこででも使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The new value is passed to the &lt;c2&gt;&lt;s3&gt;willSet&lt;/s3&gt;&lt;/c2&gt; observer as a constant, and therefore it can’t be changed in the implementation of the &lt;c4&gt;&lt;s5&gt;willSet&lt;/s5&gt;&lt;/c4&gt; clause.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい値は、定数として&lt;c2&gt;&lt;s3&gt;willSet&lt;/s3&gt;&lt;/c2&gt;オブザーバーに渡されます、したがって、それ&lt;c4&gt;&lt;s5&gt;はwillSet&lt;/s5&gt;&lt;/c4&gt;節の実装の中で変更されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next code snippet defines three variables of type &lt;c0&gt;&lt;s1&gt;Person?&lt;/s1&gt;&lt;/c0&gt;, which are used to set up multiple references to a new &lt;c2&gt;&lt;s3&gt;Person&lt;/s3&gt;&lt;/c2&gt; instance in subsequent code snippets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次のコード断片は、型&lt;c0&gt;&lt;s1&gt;Person?&lt;/s1&gt;&lt;/c0&gt;の３つの変数を定義します、それは、以降のコード断片の中のある１つの新しい&lt;c2&gt;&lt;s3&gt;Person&lt;/s3&gt;&lt;/c2&gt;インスタンスへの複数の参照を準備するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next example creates a subclass of &lt;c0&gt;&lt;s1&gt;Bicycle&lt;/s1&gt;&lt;/c0&gt; for a two-seater bicycle known as a “tandem”:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の例は、「タンデム」として知られる２座席自転車のために、&lt;c0&gt;&lt;s1&gt;Bicycle&lt;/s1&gt;&lt;/c0&gt;のサブクラスを作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next example defines a subclass of &lt;c0&gt;&lt;s1&gt;Document&lt;/s1&gt;&lt;/c0&gt; called &lt;c2&gt;&lt;s3&gt;AutomaticallyNamedDocument&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の例は、&lt;c2&gt;&lt;s3&gt;AutomaticallyNamedDocument&lt;/s3&gt;&lt;/c2&gt;とよばれる&lt;c0&gt;&lt;s1&gt;Document&lt;/s1&gt;&lt;/c0&gt;のサブクラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next example defines a subclass of &lt;c0&gt;&lt;s1&gt;Vehicle&lt;/s1&gt;&lt;/c0&gt; called &lt;c2&gt;&lt;s3&gt;Bicycle&lt;/s3&gt;&lt;/c2&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の例は、&lt;c2&gt;&lt;s3&gt;Bicycle&lt;/s3&gt;&lt;/c2&gt;と呼ばれる&lt;c0&gt;&lt;s1&gt;Vehicle&lt;/s1&gt;&lt;/c0&gt;のサブクラスを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next example defines two simple functions called &lt;c0&gt;&lt;s1&gt;stepForward(_:)&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;stepBackward(_:)&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の例は、&lt;c0&gt;&lt;s1&gt;stepForward(_:)&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;stepBackward(_:)&lt;/s3&gt;&lt;/c2&gt;と呼ばれる２つの単純な関数を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next several code snippets demonstrate how optional chaining differs from forced unwrapping and enables you to check for success.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次のいくつかのコード切れっぱしは、どのようにオプショナル連鎖が強制アンラップと異なるか、そして成功をどのようにあなたが確認できるかを例示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next snippet defines two subclasses of &lt;c0&gt;&lt;s1&gt;MediaItem&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の断片は、&lt;c0&gt;&lt;s1&gt;MediaItem&lt;/s1&gt;&lt;/c0&gt;の２つのサブクラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next subscript index to the right refers to the element at that index in the array that’s nested one level in.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の右の添え字インデックスは、１段階内側の入れ子にされた配列の中のそのインデックスでの要素に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The next three decimal &lt;c14&gt;&lt;s15&gt;codeUnit&lt;/s15&gt;&lt;/c14&gt; values (&lt;c16&gt;&lt;s17&gt;226&lt;/s17&gt;&lt;/c16&gt;, &lt;c18&gt;&lt;s19&gt;128&lt;/s19&gt;&lt;/c18&gt;, &lt;c20&gt;&lt;s21&gt;188&lt;/s21&gt;&lt;/c20&gt;) are a three-byte UTF-8 representation of the &lt;c22&gt;&lt;s23&gt;DOUBLE&lt;/s23&gt; &lt;s24&gt;EXCLAMATION&lt;/s24&gt; &lt;s25&gt;MARK&lt;/s25&gt;&lt;/c22&gt; character.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の３つの10進の&lt;c14&gt;&lt;s15&gt;codeUnit&lt;/s15&gt;&lt;/c14&gt;値（&lt;c16&gt;&lt;s17&gt;226&lt;/s17&gt;&lt;/c16&gt;、&lt;c18&gt;&lt;s19&gt;128&lt;/s19&gt;&lt;/c18&gt;、&lt;c20&gt;&lt;s21&gt;188&lt;/s21&gt;&lt;/c20&gt;）は、&lt;c22&gt;&lt;s23&gt;DOUBLE&lt;/s23&gt; &lt;s24&gt;EXCLAMATION&lt;/s24&gt; &lt;s25&gt;MARK&lt;/s25&gt;&lt;/c22&gt;文字の３バイトUTF-8叙述です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The nil-coalescing operator is shorthand for the code below:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>nil合体演算子は、以下のコードに対する簡略形です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The nil-coalescing operator provides a more elegant way to encapsulate this conditional checking and unwrapping in a concise and readable form.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>nil合体演算子は、この条件検査およびアンラップを簡潔で判読しやすい形式にカプセル化するより洗練された方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The notation used to describe the formal grammar of the Swift programming language follows a few conventions:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトプログラミング言語の形式文法を記述するために使用される表記法は、２、３の規則に従います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The observers are not called when the variable or property is first initialized.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オブザーバーは、変数またはプロパティが最初に初期化されるときには呼ばれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only difference is the type of the values that they accept (&lt;c6&gt;&lt;s7&gt;Int&lt;/s7&gt;&lt;/c6&gt;, &lt;c8&gt;&lt;s9&gt;String&lt;/s9&gt;&lt;/c8&gt;, and &lt;c10&gt;&lt;s11&gt;Double&lt;/s11&gt;&lt;/c10&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>唯一の違いは、それらが受け入れる値の型（&lt;c6&gt;&lt;s7&gt;Int&lt;/s7&gt;&lt;/c6&gt;、&lt;c8&gt;&lt;s9&gt;String&lt;/s9&gt;&lt;/c8&gt;、そして&lt;c10&gt;&lt;s11&gt;Double&lt;/s11&gt;&lt;/c10&gt;）です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only exception is for required initializers (as defined in &lt;a0&gt;&lt;s1&gt;Required Initializers&lt;/s1&gt;&lt;/a0&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>唯一の例外は、必須イニシャライザに対してです（&lt;a0&gt;&lt;s1&gt;必須イニシャライザ&lt;/s1&gt;&lt;/a0&gt;で定義されるように）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only remaining strong reference to the &lt;c0&gt;&lt;s1&gt;Apartment&lt;/s1&gt;&lt;/c0&gt; instance is from the &lt;c2&gt;&lt;s3&gt;unit4A&lt;/s3&gt;&lt;/c2&gt; variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Apartment&lt;/s1&gt;&lt;/c0&gt;インスタンスへの唯一の残っている強い参照は、&lt;c2&gt;&lt;s3&gt;unit4A&lt;/s3&gt;&lt;/c2&gt;変数からです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator method is defined as a type method on &lt;c0&gt;&lt;s1&gt;Vector2D&lt;/s1&gt;&lt;/c0&gt;, with a method name that matches the operator to be overloaded (&lt;c2&gt;&lt;s3&gt;+&lt;/s3&gt;&lt;/c2&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この演算子メソッドは、&lt;c0&gt;&lt;s1&gt;Vector2D&lt;/s1&gt;&lt;/c0&gt;上で型メソッドとして定義され、オーバーロードされる演算子と一致するメソッド名を持ちます（&lt;c2&gt;&lt;s3&gt;+&lt;/s3&gt;&lt;/c2&gt;）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator returns a new number whose bits are set to &lt;c3&gt;&lt;s4&gt;1&lt;/s4&gt;&lt;/c3&gt; if the bits are equal to &lt;c5&gt;&lt;s6&gt;1&lt;/s6&gt;&lt;/c5&gt; in &lt;e7&gt;either&lt;/e7&gt; input number:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この演算子は、&lt;e7&gt;どちらかの&lt;/e7&gt;入力数においてビットが&lt;c5&gt;&lt;s6&gt;1&lt;/s6&gt;&lt;/c5&gt;と等しいならばビットが&lt;c3&gt;&lt;s4&gt;1&lt;/s4&gt;&lt;/c3&gt;に設定される、ある新しい数を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The operator returns a new number whose bits are set to &lt;c3&gt;&lt;s4&gt;1&lt;/s4&gt;&lt;/c3&gt; where the input bits are different and are set to &lt;c5&gt;&lt;s6&gt;0&lt;/s6&gt;&lt;/c5&gt; where the input bits are the same:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この演算子は、入力ビットたちが異なっている所で&lt;c3&gt;&lt;s4&gt;1&lt;/s4&gt;&lt;/c3&gt;に設定され、入力ビットたちが同じである所で&lt;c5&gt;&lt;s6&gt;0&lt;/s6&gt;&lt;/c5&gt;に設定される、ある新しい数を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optimized behavior is known as &lt;e0&gt;call by reference&lt;/e0&gt;; it satisfies all of the requirements of the copy-in copy-out model while removing the overhead of copying.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この最適化挙動は、&lt;e0&gt;参照呼び出し&lt;/e0&gt;として知られます；それはコピーイン・コピーアウトモデルの要件の全てを満足させる一方でコピーすることのオーバーヘッド（間接的経費）を取り除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optional &lt;c16&gt;&lt;s17&gt;Int&lt;/s17&gt;&lt;/c16&gt; is accessed through optional binding to unwrap the integer and assign the non-optional value to the &lt;c18&gt;&lt;s19&gt;roomCount&lt;/s19&gt;&lt;/c18&gt; variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルの&lt;c16&gt;&lt;s17&gt;Int&lt;/s17&gt;&lt;/c16&gt;は、オプショナル束縛を通してアクセスされることで、整数をアンラップして取り出して、その非オプショナル値を&lt;c18&gt;&lt;s19&gt;roomCount&lt;/s19&gt;&lt;/c18&gt;変数へ割り当てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optional &lt;e0&gt;version number&lt;/e0&gt; consists of one to three positive integers, separated by periods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>随意の&lt;e0&gt;バージョン番号&lt;/e0&gt;は、ビリオドで区切られた、１つから３つの正の整数から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optional chaining question mark always follows immediately after the part of the expression that is optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖の疑問符は、常にオプショナルである式部分の直後に続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optional chaining question mark in this subscript call is placed immediately after &lt;c0&gt;&lt;s1&gt;john.residence&lt;/s1&gt;&lt;/c0&gt;, before the subscript brackets, because &lt;c2&gt;&lt;s3&gt;john.residence&lt;/s3&gt;&lt;/c2&gt; is the optional value on which optional chaining is being attempted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この添え字呼び出しでのオプショナル連鎖の疑問符は、&lt;c0&gt;&lt;s1&gt;john.residence&lt;/s1&gt;&lt;/c0&gt;の直後、添え字の角括弧の前に置かれます、なぜなら、&lt;c2&gt;&lt;s3&gt;john.residence&lt;/s3&gt;&lt;/c2&gt;がオプショナル連鎖が試みられているオプショナルの値であるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optional lets you track whether there is currently a player in the game.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルは、プレーヤーが現在ゲーム中かどうかあなたに追跡させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optional pattern provides a convenient way to iterate over an array of optional values in a &lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt; statement, executing the body of the loop only for non-&lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt; elements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルパターンは、&lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt;文においてオプショナルの値がはいった配列の全体にわたって、ループの本文を非&lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;の要素のみに実行して、繰り返すための便利な方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The order in which modifiers are specified when defining &lt;a0&gt;&lt;s1&gt;Custom Operators&lt;/s1&gt;&lt;/a0&gt; has changed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;あつらえの演算子&lt;/s1&gt;&lt;/a0&gt;を定義する時に修飾子が指定される順番は変更されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The order of arguments in a function call must match the order of parameters in the function’s declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数呼び出しにおける引数の順序は、関数の宣言におけるパラメータの順番と一致しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The original array is not modified by the &lt;c4&gt;&lt;s5&gt;sorted(by:)&lt;/s5&gt;&lt;/c4&gt; method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>元の配列は、&lt;c4&gt;&lt;s5&gt;sorted(by:)&lt;/s5&gt;&lt;/c4&gt;メソッドによって修正されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other difference between a generic function and a nongeneric function is that the generic function’s name (&lt;c0&gt;&lt;s1&gt;swapTwoValues(_:_:)&lt;/s1&gt;&lt;/c0&gt;) is followed by the placeholder type name (&lt;c2&gt;&lt;s3&gt;T&lt;/s3&gt;&lt;/c2&gt;) inside angle brackets (&lt;c4&gt;&lt;s5&gt;&lt;T&gt;&lt;/s5&gt;&lt;/c4&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体関数と非総称体関数の間の他の違いは、総称体関数の名前（&lt;c0&gt;&lt;s1&gt;swapTwoValues(_:_:)&lt;/s1&gt;&lt;/c0&gt;）は、後ろにプレースホルダ型名（&lt;c2&gt;&lt;s3&gt;T&lt;/s3&gt;&lt;/c2&gt;）が山形括弧内部（&lt;c4&gt;&lt;s5&gt;&lt;T&gt;&lt;/s5&gt;&lt;/c4&gt;）で続くということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The other variation of the &lt;c0&gt;&lt;s1&gt;while&lt;/s1&gt;&lt;/c0&gt; loop, known as the &lt;c2&gt;&lt;s3&gt;repeat&lt;/s3&gt;&lt;/c2&gt;-&lt;c4&gt;&lt;s5&gt;while&lt;/s5&gt;&lt;/c4&gt; loop, performs a single pass through the loop block first, &lt;e6&gt;before&lt;/e6&gt; considering the loop’s condition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;while&lt;/s1&gt;&lt;/c0&gt;ループのもう一方の変種、&lt;c2&gt;&lt;s3&gt;repeat&lt;/s3&gt;&lt;/c2&gt;-&lt;c4&gt;&lt;s5&gt;while&lt;/s5&gt;&lt;/c4&gt;ループとして知られるものは、ループの条件を考慮する&lt;e6&gt;前&lt;/e6&gt;に、最初に一度だけループ・ブロックの通り抜けを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The output constant (&lt;c2&gt;&lt;s3&gt;twoThousandAndOne&lt;/s3&gt;&lt;/c2&gt;) is inferred to be of type &lt;c4&gt;&lt;s5&gt;UInt16&lt;/s5&gt;&lt;/c4&gt;, because it’s the sum of two &lt;c6&gt;&lt;s7&gt;UInt16&lt;/s7&gt;&lt;/c6&gt; values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>出力された定数（&lt;c2&gt;&lt;s3&gt;twoThousandAndOne&lt;/s3&gt;&lt;/c2&gt;）は、型&lt;c4&gt;&lt;s5&gt;UInt16&lt;/s5&gt;&lt;/c4&gt;であると推測されます、それが２つの&lt;c6&gt;&lt;s7&gt;UInt16値&lt;/s7&gt;&lt;/c6&gt;の合計であるので。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The output of the compound expression doesn’t change, but the overall intention is clearer to the reader.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複合式の出力は変わりません、しかし全体的な意図は読者にとってより明らかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The override of the &lt;c0&gt;&lt;s1&gt;description&lt;/s1&gt;&lt;/c0&gt; property starts by calling &lt;c2&gt;&lt;s3&gt;super.description&lt;/s3&gt;&lt;/c2&gt;, which returns the &lt;c4&gt;&lt;s5&gt;Vehicle&lt;/s5&gt;&lt;/c4&gt; class’s &lt;c6&gt;&lt;s7&gt;description&lt;/s7&gt;&lt;/c6&gt; property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;description&lt;/s1&gt;&lt;/c0&gt;プロパティのオーバーライドは、&lt;c2&gt;&lt;s3&gt;super.description&lt;/s3&gt;&lt;/c2&gt;を呼び出すことで始まります、それは&lt;c4&gt;&lt;s5&gt;Vehicle&lt;/s5&gt;&lt;/c4&gt;クラスの&lt;c6&gt;&lt;s7&gt;description&lt;/s7&gt;&lt;/c6&gt;プロパティを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The parameter name is used in the implementation of the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータ名は、関数の実装内において使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The parameter’s &lt;a6&gt;&lt;c7&gt;&lt;s8&gt;Key&lt;/s8&gt;&lt;/c7&gt;&lt;/a6&gt;&lt;s9&gt; [https://developer.apple.com/documentation/swift/expressiblebydictionaryliteral/2294108-key]&lt;/s9&gt; must be &lt;a10&gt;&lt;c11&gt;&lt;s12&gt;ExpressibleByStringLiteral&lt;/s12&gt;&lt;/c11&gt;&lt;/a10&gt;&lt;s13&gt; [https://developer.apple.com/documentation/swift/expressiblebystringliteral]&lt;/s13&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータの&lt;a6&gt;&lt;c7&gt;&lt;s8&gt;Key&lt;/s8&gt;&lt;/c7&gt;&lt;/a6&gt;&lt;s9&gt; [https://developer.apple.com/documentation/swift/expressiblebydictionaryliteral/2294108-key]&lt;/s9&gt;は、&lt;a10&gt;&lt;c11&gt;&lt;s12&gt;ExpressibleByStringLiteral&lt;/s12&gt;&lt;/c11&gt;&lt;/a10&gt;&lt;s13&gt; [https://developer.apple.com/documentation/swift/expressiblebystringliteral]&lt;/s13&gt;でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The parentheses around a tuple pattern that contains a single element have no effect.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ただ１つだけの要素を含むタプルパターンのまわりの丸括弧には、効果がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The parentheses make it clear that the first two values are considered as part of a separate possible state in the overall logic.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>丸括弧は、最初の２つの値が全体的な論理の中で１つの隔てられたあり得る状態の部分として考慮されることを明白にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The pattern matches values of that single element’s type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パターンは、そのただ１つの要素の型の値にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The patterns can be written over multiple lines if the list is long.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのパターンは、そのリストが長いならば、複数行にわたって書かれることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The phrase &lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt; &lt;s2&gt;!allowedEntry&lt;/s2&gt;&lt;/c0&gt; can be read as “if not allowed entry.” The subsequent line is only executed if “not allowed entry” is true; that is, if &lt;c3&gt;&lt;s4&gt;allowedEntry&lt;/s4&gt;&lt;/c3&gt; is &lt;c5&gt;&lt;s6&gt;false&lt;/s6&gt;&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>語句&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt; &lt;s2&gt;!allowedEntry&lt;/s2&gt;&lt;/c0&gt;は、「許されたエントリでないならば」と読まれることができます。続く行は「許されたエントリでない」が真である場合；すなわち、&lt;c3&gt;&lt;s4&gt;allowedEntry&lt;/s4&gt;&lt;/c3&gt;が&lt;c5&gt;&lt;s6&gt;false&lt;/s6&gt;&lt;/c5&gt;である場合に実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The phrase “of type &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;” means “can store any &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt; value.” Think of it as meaning “the type of thing” (or “the kind of thing”) that can be stored.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>フレーズ「型&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;の」は、「どんな&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;値でも格納することができる」ことを意味します。それを、格納されることができる「物の型」（または「物の種類」）の意味と思ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The placeholder type name doesn’t say anything about what &lt;c10&gt;&lt;s11&gt;T&lt;/s11&gt;&lt;/c10&gt; must be, but it &lt;e12&gt;does&lt;/e12&gt; say that both &lt;c13&gt;&lt;s14&gt;a&lt;/s14&gt;&lt;/c13&gt; and &lt;c15&gt;&lt;s16&gt;b&lt;/s16&gt;&lt;/c15&gt; must be of the same type &lt;c17&gt;&lt;s18&gt;T&lt;/s18&gt;&lt;/c17&gt;, whatever &lt;c19&gt;&lt;s20&gt;T&lt;/s20&gt;&lt;/c19&gt; represents.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プレースホルダ型名は&lt;c10&gt;&lt;s11&gt;T&lt;/s11&gt;&lt;/c10&gt;が何でなければならないかについて何も言いません、しかし、&lt;c13&gt;&lt;s14&gt;a&lt;/s14&gt;&lt;/c13&gt;と&lt;c15&gt;&lt;s16&gt;b&lt;/s16&gt;&lt;/c15&gt;の両方ともが同じ型&lt;c17&gt;&lt;s18&gt;T&lt;/s18&gt;&lt;/c17&gt;でなければならないと&lt;e12&gt;述べます&lt;/e12&gt;、&lt;c19&gt;&lt;s20&gt;T&lt;/s20&gt;&lt;/c19&gt;が表わすものが何であれ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The player has now left the game.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プレーヤーは、現在ゲームから離れました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The player moves forward by &lt;c0&gt;&lt;s1&gt;diceRoll&lt;/s1&gt;&lt;/c0&gt; squares, and the game logic checks for any snakes and ladders.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プレーヤーは&lt;c0&gt;&lt;s1&gt;diceRoll&lt;/s1&gt;&lt;/c0&gt;分の正方形を前進します、そして、ゲーム論理はあらゆるヘビとはしごについて調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The player’s purse now contains 2,100 coins, and the bank has only 7,900 coins left.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プレーヤーの財布は現在2,100個のコインを含みます、そして、胴元は7,900個のコインだけが残っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The player’s starting square is “square zero”, which is just off the bottom-left corner of the board.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プレーヤーの出発する正方形は「正方形ゼロ」です、それは、盤の左下の角からちょっと離れています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The point (0, 0) would match &lt;c3&gt;&lt;s4&gt;case&lt;/s4&gt; &lt;s5&gt;(0,&lt;/s5&gt; &lt;s6&gt;0)&lt;/s6&gt;&lt;/c3&gt; first, and so all other matching cases would be ignored.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>点(0, 0)は最初の&lt;c3&gt;&lt;s4&gt;case&lt;/s4&gt; &lt;s5&gt;(0,&lt;/s5&gt; &lt;s6&gt;0)&lt;/s6&gt;&lt;/c3&gt;に合います、それで他の適合するケース節すべては無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The postfix &lt;c0&gt;&lt;s1&gt;?&lt;/s1&gt;&lt;/c0&gt; operator makes an optional-chaining expression from an expression without changing the expression’s value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接尾辞&lt;c0&gt;&lt;s1&gt;?&lt;/s1&gt;&lt;/c0&gt;演算子は、オプショナル連鎖式をある式から、その式の値を変更することなく作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The precedence of an operator specifies how tightly the operator binds to its operands, in the absence of grouping parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある演算子の優先順位は、どのくらいきつくその演算子をそれの演算数に束縛するかを、グループ化の丸括弧がないところで指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The present section describes which characters can be used to define custom operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いま目の前の節は、どの文字があつらえの演算子を定義するために使われることができるかを記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The previous example shows how to retrieve the value of a property of optional type through optional chaining.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>前の例は、オプショナル連鎖を通してオプショナルの型のプロパティの値を取り出す方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The previous example uses &lt;a14&gt;&lt;c15&gt;&lt;s16&gt;KeyValuePairs&lt;/s16&gt;&lt;/c15&gt;&lt;/a14&gt;&lt;s17&gt; [https://developer.apple.com/documentation/swift/keyvaluepairs]&lt;/s17&gt; as the parameter type so that callers can include duplicate parameter labels—&lt;c18&gt;&lt;s19&gt;a&lt;/s19&gt;&lt;/c18&gt; and &lt;c20&gt;&lt;s21&gt;b&lt;/s21&gt;&lt;/c20&gt; appear multiple times in the call to &lt;c22&gt;&lt;s23&gt;repeat&lt;/s23&gt;&lt;/c22&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>前の例は、&lt;a14&gt;&lt;c15&gt;&lt;s16&gt;KeyValuePairs&lt;/s16&gt;&lt;/c15&gt;&lt;/a14&gt;&lt;s17&gt; [https://developer.apple.com/documentation/swift/keyvaluepairs]&lt;/s17&gt;をパラメータ型として使います、それで呼び出し側は重複するパラメータラベルを含むことができます — &lt;c18&gt;&lt;s19&gt;a&lt;/s19&gt;&lt;/c18&gt;と&lt;c20&gt;&lt;s21&gt;b&lt;/s21&gt;&lt;/c20&gt;は複数回&lt;c22&gt;&lt;s23&gt;repeat&lt;/s23&gt;&lt;/c22&gt;の呼び出しにおいて現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The primary use of implicitly unwrapped optionals in Swift is during class initialization, as described in &lt;a0&gt;&lt;s1&gt;Unowned References and Implicitly Unwrapped Optional Properties&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでの暗黙的にアンラップされるオプショナルの主要な利用法は、&lt;a0&gt;&lt;s1&gt;所有参照と暗黙的にアンラップされるオプショナルのプロパティ&lt;/s1&gt;&lt;/a0&gt;で記述されるように、クラス初期化の間にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The principle of finding the index of a value in an array isn’t useful only for strings, however.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、配列の中の値のインデックスを見つける原理は、文字列のためにだけ役立つわけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The problem lies with the equality check, “&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt; &lt;s2&gt;value&lt;/s2&gt; &lt;s3&gt;==&lt;/s3&gt; &lt;s4&gt;valueToFind&lt;/s4&gt;&lt;/c0&gt;”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>問題は、同等性検査&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt; &lt;s2&gt;value&lt;/s2&gt; &lt;s3&gt;==&lt;/s3&gt; &lt;s4&gt;valueToFind&lt;/s4&gt;&lt;/c0&gt;に横たわります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The process is repeated until &lt;c0&gt;&lt;s1&gt;number&lt;/s1&gt;&lt;/c0&gt; is equal to &lt;c2&gt;&lt;s3&gt;0&lt;/s3&gt;&lt;/c2&gt;, at which point the &lt;c4&gt;&lt;s5&gt;output&lt;/s5&gt;&lt;/c4&gt; string is returned by the closure, and is added to the output array by the &lt;c6&gt;&lt;s7&gt;map(_:)&lt;/s7&gt;&lt;/c6&gt; method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この処理は&lt;c0&gt;&lt;s1&gt;number&lt;/s1&gt;&lt;/c0&gt;が&lt;c2&gt;&lt;s3&gt;0&lt;/s3&gt;&lt;/c2&gt;に等しくなるまで繰り返されます、その時点で&lt;c4&gt;&lt;s5&gt;output&lt;/s5&gt;&lt;/c4&gt;文字列がクロージャによって返されて、そして&lt;c6&gt;&lt;s7&gt;map(_:)&lt;/s7&gt;&lt;/c6&gt;メソッドによって出力配列に加えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The process of defining your own implementations of the &lt;c0&gt;&lt;s1&gt;==&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;!=&lt;/s3&gt;&lt;/c2&gt; operators is described in &lt;a4&gt;&lt;s5&gt;Equivalence Operators&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;==&lt;/s1&gt;&lt;/c0&gt;および&lt;c2&gt;&lt;s3&gt;!=&lt;/s3&gt;&lt;/c2&gt;演算子のあなた独自の実装を定義する過程は、&lt;a4&gt;&lt;s5&gt;等価演算子&lt;/s5&gt;&lt;/a4&gt;で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The process of initializing a structure’s declared properties is described in &lt;a0&gt;&lt;s1&gt;Initialization&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある構造体の宣言されたプロパティを初期化する過程は、&lt;a0&gt;&lt;s1&gt;初期化&lt;/s1&gt;&lt;/a0&gt;で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The program begins executing a loop by calling the &lt;c7&gt;&lt;s8&gt;next()&lt;/s8&gt;&lt;/c7&gt; method on the iterator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プログラムは、そのイテレータ上で&lt;c7&gt;&lt;s8&gt;next()&lt;/s8&gt;&lt;/c7&gt;メソッドを呼ぶことによってループの実行を始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The program executes the &lt;e0&gt;statements&lt;/e0&gt;, and execution continues to step 2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プログラムが&lt;e0&gt;文&lt;/e0&gt;を実行します、そして実行はステップ２に続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The program executes the &lt;e0&gt;statements&lt;/e0&gt;, and execution returns to step 1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プログラムは&lt;e0&gt;文&lt;/e0&gt;を実行します、そして実行はステップ１に戻ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The projected value has the same access control level as the original wrapped property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>予測値は、元のラップされたプロパティと同じアクセス制御水準を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The properties of a frozen structure can’t have property observers, and expressions that provide the initial value for stored instance properties must follow the same restrictions as inlinable functions, as discussed in &lt;a2&gt;&lt;s3&gt;inlinable&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>凍結構造体のプロパティは、ブロパティオブザーバを持つことが出来ません、そして格納インスタンスプロパティに初期値を提供する式は、インライン可能関数と同じ制約に従わなければなりません、&lt;a2&gt;&lt;s3&gt;inlinable&lt;/s3&gt;&lt;/a2&gt;で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The property wrapper still provides all of the initial values, like the earlier example that used &lt;c8&gt;&lt;s9&gt;TwelveOrLess&lt;/s9&gt;&lt;/c8&gt; in &lt;c10&gt;&lt;s11&gt;SmallRectangle&lt;/s11&gt;&lt;/c10&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティラッパーは、依然として初期値のすべてを提供します、&lt;c10&gt;&lt;s11&gt;SmallRectangle&lt;/s11&gt;&lt;/c10&gt;での&lt;c8&gt;&lt;s9&gt;TwelveOrLess&lt;/s9&gt;&lt;/c8&gt;を使った前の例のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The protocol also specifies whether each property must be gettable or gettable &lt;e0&gt;and&lt;/e0&gt; settable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルはまた、各プロパティが取得可能または取得可能&lt;e0&gt;かつまた&lt;/e0&gt;設定可能でなければならないかどうか指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The protocol can then be &lt;e1&gt;adopted&lt;/e1&gt; by a class, structure, or enumeration to provide an actual implementation of those requirements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのプロトコルは、それから、クラス、構造体、または列挙によって&lt;e1&gt;採用される&lt;/e1&gt;ことで、それらの要件の実際の実装を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The protocol doesn’t define what &lt;c7&gt;&lt;s8&gt;Item&lt;/s8&gt;&lt;/c7&gt; is—that information is left for any conforming type to provide.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルは、&lt;c7&gt;&lt;s8&gt;Item&lt;/s8&gt;&lt;/c7&gt;が何であるかを定義しません ― その情報は、何であれそれに準拠する型が提供するようにそのままにされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The protocol doesn’t specify anything else about the nature of the conforming type—it only specifies that the type must be able to provide a full name for itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルは、その準拠型の性質について何ら指定しません ― それはただその型がそれ自身のフルネームを提供できなければならないことだけを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The protocol doesn’t specify whether the property should be a stored property or a computed property—it only specifies the required property name and type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは、そのプロパティが格納プロパティまたは計算プロパティでなければならないかどうかは指定しません ― それは、必要なプロパティ名と型を指定するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The protocol name is provided after the type name, separated by a colon, and an implementation of all requirements of the protocol is provided within the extension’s curly braces.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル名は、型名の後にコロンで区切られて提供されます、そして、プロトコルの全ての要件の実装は、拡張の波括弧内で提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The protocol only specifies the three bits of functionality that any type must provide in order to be considered a &lt;c0&gt;&lt;s1&gt;Container&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは、どんな型でも&lt;c0&gt;&lt;s1&gt;Container&lt;/s1&gt;&lt;/c0&gt;とみなされるためには提供しなければならない小さな３つの機能性を指定するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The protocol states that any &lt;c2&gt;&lt;s3&gt;FullyNamed&lt;/s3&gt;&lt;/c2&gt; type must have a gettable instance property called &lt;c4&gt;&lt;s5&gt;fullName&lt;/s5&gt;&lt;/c4&gt;, which is of type &lt;c6&gt;&lt;s7&gt;String&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルは、あらゆる&lt;c2&gt;&lt;s3&gt;FullyNamed&lt;/s3&gt;&lt;/c2&gt;型は&lt;c4&gt;&lt;s5&gt;fullName&lt;/s5&gt;&lt;/c4&gt;と呼ばれる、&lt;c6&gt;&lt;s7&gt;String&lt;/s7&gt;&lt;/c6&gt;型である、取得可能なインスタンスプロパティを持たなければならないことを述べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The question mark indicates that the value it contains is optional, meaning that it might contain &lt;e11&gt;some&lt;/e11&gt; &lt;c12&gt;&lt;s13&gt;Int&lt;/s13&gt;&lt;/c12&gt; value, or it might contain &lt;e14&gt;no value at all&lt;/e14&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>疑問符はそれが含む値がオプショナルであることを示します、そしてそれが&lt;e11&gt;何かの&lt;/e11&gt;&lt;c12&gt;&lt;s13&gt;Int&lt;/s13&gt;&lt;/c12&gt;値を含むかもしれない、あるいはそれが&lt;e14&gt;まったく値を含まない&lt;/e14&gt;かもしれないことを意味しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The range of numbers that can be stored in an integer constant or variable is different for each numeric type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>整数の定数または変数に格納されることができる数の範囲は、それぞれの数の型で異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The raw value for a particular enumeration case is always the same.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特定の列挙ケース節のための生の値は、常に同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The raw value initializer is a failable initializer, because not every raw value will return an enumeration case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>生の値のイニシャライザは、失敗できるイニシャライザです、なぜなら、すべての生の値が列挙ケース節を返すわけではないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The read access ends before the write access starts, so there isn’t a conflict.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>読み出しアクセスは書き込みアクセスが始まる前に終わります、それでそれらは衝突しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The read and write accesses refer to the same memory and they overlap, producing a conflict.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>読み出しと書き込みアクセスは同じメモリを参照してそれらはオーバーラッブして、衝突を生み出しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The red component is obtained by performing a bitwise AND between the numbers &lt;c0&gt;&lt;s1&gt;0xCC6699&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;0xFF0000&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>赤の構成要素は、数&lt;c0&gt;&lt;s1&gt;0xCC6699&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;0xFF0000&lt;/s3&gt;&lt;/c2&gt;との間のビット単位の論理積を実行することによって得られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reference is called a “strong” reference because it keeps a firm hold on that instance, and does not allow it to be deallocated for as long as that strong reference remains.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この参照が「強い」参照と呼ばれるのはそれがそのインスタンスに対する堅い支配力を保つからです、そしてその強い参照が残る限りは、そのインスタンスがメモリ割り当て解除されるのを許しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The relationship between &lt;c0&gt;&lt;s1&gt;Customer&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;CreditCard&lt;/s3&gt;&lt;/c2&gt; is slightly different from the relationship between &lt;c4&gt;&lt;s5&gt;Apartment&lt;/s5&gt;&lt;/c4&gt; and &lt;c6&gt;&lt;s7&gt;Person&lt;/s7&gt;&lt;/c6&gt; seen in the weak reference example above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Customer&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;CreditCard&lt;/s3&gt;&lt;/c2&gt;の関係は、上の弱い参照の例で見られる&lt;c4&gt;&lt;s5&gt;Apartment&lt;/s5&gt;&lt;/c4&gt;と&lt;c6&gt;&lt;s7&gt;Person&lt;/s7&gt;&lt;/c6&gt;の関係と少しばかり異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The remainder is treated the same way and may be split again.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>剰余は、同じ方法で扱われて、そして再び分割されるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The remainder operator (&lt;c0&gt;&lt;s1&gt;%&lt;/s1&gt;&lt;/c0&gt;) is also known as a &lt;e2&gt;modulo operator&lt;/e2&gt; in other languages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>剰余演算子（&lt;c0&gt;&lt;s1&gt;%&lt;/s1&gt;&lt;/c0&gt;）は、また、他の言語では&lt;e2&gt;モジュロ演算子&lt;/e2&gt;として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The remaining arguments can appear in any order and specify additional information about the declaration’s life cycle, including important milestones.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>残りの引数は、随意の順序で現れることができて、追加的な情報を宣言の寿命について、重要なマイルストーンを含めて指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The remaining bits (known as the &lt;e0&gt;value bits&lt;/e0&gt;) store the actual value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>残っているビット（&lt;e0&gt;値ビット&lt;/e0&gt;として知られるもの）は、実際の値を格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The requirement to always return a single type doesn’t prevent you from using generics in an opaque return type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>常に単一の型を返すという要件は、あなたが総称体を不透明戻り型において使う妨げになりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The response to a survey question cannot be known until it is asked, and so the &lt;c0&gt;&lt;s1&gt;response&lt;/s1&gt;&lt;/c0&gt; property is declared with a type of &lt;c2&gt;&lt;s3&gt;String?&lt;/s3&gt;&lt;/c2&gt;, or “optional &lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt;”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>意識調査への回答は、それが尋ねられるまでは知られることができません、なので&lt;c0&gt;&lt;s1&gt;response&lt;/s1&gt;&lt;/c0&gt;プロパティは&lt;c2&gt;&lt;s3&gt;String?&lt;/s3&gt;&lt;/c2&gt;の型、すなわち「オプショナルの&lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt;」を使って宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The restriction against overlapping access to properties of a structure isn’t always necessary to preserve memory safety.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体のプロパティに対するオーバーラップするアクセスを禁じる制限は、メモリ安全を守るために必ずしも必要ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result is a sequence of &lt;c12&gt;&lt;s13&gt;diceRoll&lt;/s13&gt;&lt;/c12&gt; values that is always &lt;c14&gt;&lt;s15&gt;1&lt;/s15&gt;&lt;/c14&gt;, &lt;c16&gt;&lt;s17&gt;2&lt;/s17&gt;&lt;/c16&gt;, &lt;c18&gt;&lt;s19&gt;3&lt;/s19&gt;&lt;/c18&gt;, &lt;c20&gt;&lt;s21&gt;4&lt;/s21&gt;&lt;/c20&gt;, &lt;c22&gt;&lt;s23&gt;5&lt;/s23&gt;&lt;/c22&gt;, &lt;c24&gt;&lt;s25&gt;6&lt;/s25&gt;&lt;/c24&gt;, &lt;c26&gt;&lt;s27&gt;1&lt;/s27&gt;&lt;/c26&gt;, &lt;c28&gt;&lt;s29&gt;2&lt;/s29&gt;&lt;/c28&gt; and so on.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果は一連の&lt;c12&gt;&lt;s13&gt;diceRoll&lt;/s13&gt;&lt;/c12&gt;値で、それは常に&lt;c14&gt;&lt;s15&gt;1&lt;/s15&gt;&lt;/c14&gt;、&lt;c16&gt;&lt;s17&gt;2&lt;/s17&gt;&lt;/c16&gt;、&lt;c18&gt;&lt;s19&gt;3&lt;/s19&gt;&lt;/c18&gt;、&lt;c20&gt;&lt;s21&gt;4&lt;/s21&gt;&lt;/c20&gt;、&lt;c22&gt;&lt;s23&gt;5&lt;/s23&gt;&lt;/c22&gt;、&lt;c24&gt;&lt;s25&gt;6&lt;/s25&gt;&lt;/c24&gt;、&lt;c26&gt;&lt;s27&gt;1&lt;/s27&gt;&lt;/c26&gt;、&lt;c28&gt;&lt;s29&gt;2&lt;/s29&gt;&lt;/c28&gt;など、となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result is a specialized version of that generic type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結果は、その総称体型の特殊化版です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result is exactly the same as if you place an exclamation point after a normal optional that doesn’t contain a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その結果は、あなたが値を含まない通常のオプショナルの後に感嘆符を置いた場合と正確に同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result of &lt;c18&gt;&lt;s19&gt;item&lt;/s19&gt; &lt;s20&gt;as?&lt;/s20&gt; &lt;s21&gt;Movie&lt;/s21&gt;&lt;/c18&gt; is of type &lt;c22&gt;&lt;s23&gt;Movie?&lt;/s23&gt;&lt;/c22&gt;, or “optional &lt;c24&gt;&lt;s25&gt;Movie&lt;/s25&gt;&lt;/c24&gt;”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c18&gt;&lt;s19&gt;item&lt;/s19&gt; &lt;s20&gt;as?&lt;/s20&gt; &lt;s21&gt;Movie&lt;/s21&gt;&lt;/c18&gt;の結果は、&lt;c22&gt;&lt;s23&gt;Movie?&lt;/s23&gt;&lt;/c22&gt;型、すなわち「オプショナルの&lt;c24&gt;&lt;s25&gt;Movie&lt;/s25&gt;&lt;/c24&gt;」です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result of flipping a triangle is a value of type &lt;c0&gt;&lt;s1&gt;Shape&lt;/s1&gt;&lt;/c0&gt;, and the &lt;c2&gt;&lt;s3&gt;protoFlip(_:)&lt;/s3&gt;&lt;/c2&gt; function takes an argument of some type that conforms to the &lt;c4&gt;&lt;s5&gt;Shape&lt;/s5&gt;&lt;/c4&gt; protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>三角形を裏返すことの結果は、型&lt;c0&gt;&lt;s1&gt;Shape&lt;/s1&gt;&lt;/c0&gt;の値です、そして&lt;c2&gt;&lt;s3&gt;protoFlip(_:)&lt;/s3&gt;&lt;/c2&gt;関数は&lt;c4&gt;&lt;s5&gt;Shape&lt;/s5&gt;&lt;/c4&gt;プロトコルに準拠する型の引数を取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result of the &lt;c0&gt;&lt;s1&gt;i&lt;/s1&gt; &lt;s2&gt;==&lt;/s2&gt; &lt;s3&gt;1&lt;/s3&gt;&lt;/c0&gt; comparison is of type &lt;c4&gt;&lt;s5&gt;Bool&lt;/s5&gt;&lt;/c4&gt;, and so this second example passes the type-check.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;i&lt;/s1&gt; &lt;s2&gt;==&lt;/s2&gt; &lt;s3&gt;1&lt;/s3&gt;&lt;/c0&gt;の比較の結果は型&lt;c4&gt;&lt;s5&gt;Bool&lt;/s5&gt;&lt;/c4&gt;です、それでこの第二の例は型チェックを通ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return type can be any type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>戻りの型は任意の型であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return type can include types that are part of the function’s generic type parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>戻り型は、関数のもつ総称体型パラメータの一部である型を定義含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return type of &lt;c0&gt;&lt;s1&gt;makeIncrementer&lt;/s1&gt;&lt;/c0&gt; is &lt;c2&gt;&lt;s3&gt;()&lt;/s3&gt; &lt;s4&gt;-&gt;&lt;/s4&gt; &lt;s5&gt;Int&lt;/s5&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;makeIncrementer&lt;/s1&gt;&lt;/c0&gt;の戻り型は、&lt;c2&gt;&lt;s3&gt;()&lt;/s3&gt; &lt;s4&gt;-&gt;&lt;/s4&gt; &lt;s5&gt;Int&lt;/s5&gt;&lt;/c2&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return value of &lt;c4&gt;&lt;s5&gt;john.residence?.address?.street&lt;/s5&gt;&lt;/c4&gt; is therefore also &lt;c6&gt;&lt;s7&gt;String?&lt;/s7&gt;&lt;/c6&gt;, even though two levels of optional chaining are applied in addition to the underlying optional type of the property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;john.residence?.address?.street&lt;/s5&gt;&lt;/c4&gt;の戻り値は、したがってまた、&lt;c6&gt;&lt;s7&gt;String?&lt;/s7&gt;&lt;/c6&gt;です、その下のプロパティのオプショナル型に加えて２つのオプショナル連鎖の階層が適用されるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return value of a function can be ignored when it is called:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数の戻り値は、それが呼ばれるとき無視されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The returned array value is stored in &lt;c6&gt;&lt;s7&gt;boardColors&lt;/s7&gt;&lt;/c6&gt; and can be queried with the &lt;c8&gt;&lt;s9&gt;squareIsBlackAt(row:column:)&lt;/s9&gt;&lt;/c8&gt; utility function:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>返された配列値は、&lt;c6&gt;&lt;s7&gt;boardColors&lt;/s7&gt;&lt;/c6&gt;に格納されて、便利な支援関数の&lt;c8&gt;&lt;s9&gt;squareIsBlackAt(row:column:)&lt;/s9&gt;&lt;/c8&gt;で問い合わされることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The revised version of the code returns an instance of &lt;c0&gt;&lt;s1&gt;Square&lt;/s1&gt;&lt;/c0&gt; or an instance of &lt;c2&gt;&lt;s3&gt;FlippedShape&lt;/s3&gt;&lt;/c2&gt;, depending on what shape is passed in.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この改訂版のコードは、&lt;c0&gt;&lt;s1&gt;Square&lt;/s1&gt;&lt;/c0&gt;のインスタンスまたは&lt;c2&gt;&lt;s3&gt;FlippedShape&lt;/s3&gt;&lt;/c2&gt;のインスタンスを返します、どの形状が渡されるかに依存して。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The role of &lt;c0&gt;&lt;s1&gt;printMathResult(_:_:_:)&lt;/s1&gt;&lt;/c0&gt; is to print the result of a call to a math function of an appropriate type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;printMathResult(_:_:_:)&lt;/s1&gt;&lt;/c0&gt;の役割は、適切な型の数学関数に対する呼び出しの結果を出力することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The row height should be 50 points taller than the content height if the row has a header, and 20 points taller if the row doesn’t have a header:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列の高さは、列にヘッダがあるならば内容の高さより50ポイント高く、列にヘッダがないならば20ポイント高くなければなりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rules for combining numeric constants and variables are different from the rules for numeric literals.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>数の定数や変数を結合することに対する規則は、数のリテラルに対する規則と異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rules for how initializer delegation works, and for what forms of delegation are allowed, are different for value types and class types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どのようにイニシャライザ委任が働くか、そしてどんな委任の形式が許されるかの規則は、値型とクラス型で異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rules of the game are as follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ゲームの規則は、次の通りです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rules only affect how you write the implementation of the class’s initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの規則は、あなたがクラスのイニシャライザの実装を書く方法に影響を及ぼすだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same behavior applies to enumerations:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じ挙動は、列挙にもあてはまります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same is not true for classes, which are &lt;e0&gt;reference types&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じことはクラスにはあてはまりません、それは&lt;e0&gt;参照型&lt;/e0&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same is true for method parameters, because methods are just functions that are associated with a type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じことはメソッドパラメータにもあてはまります、なぜならメソッドは、あるひとつの型に結び付けられた単なる関数だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same is true if you attempt to set a property through optional chaining.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じことは、あなたがプロパティをオプショナル連鎖を通して設定しようと試みる場合にも当てはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same method is applied when calculating the remainder for a negative value of &lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt;&lt;/c0&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じメソッドが、負の値の&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt;&lt;/c0&gt;のための余りを計算するとき適用されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same value can appear in an array multiple times at different positions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>同じ値は、ひとつの配列の中で複数回異なる位置で現れることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The scope of a labeled statement is the entire statement following the statement label.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ラベルをつけられた文のスコープは、文ラベルに続いている文全体です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The scope of each case can’t be empty.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれのケース節のスコープは、空であることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second &lt;c0&gt;&lt;s1&gt;Rect&lt;/s1&gt;&lt;/c0&gt; initializer, &lt;c2&gt;&lt;s3&gt;init(origin:size:)&lt;/s3&gt;&lt;/c2&gt;, is functionally the same as the memberwise initializer that the structure would have received if it did not have its own custom initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>二番目の&lt;c0&gt;&lt;s1&gt;Rect&lt;/s1&gt;&lt;/c0&gt;イニシャライザ、&lt;c2&gt;&lt;s3&gt;init(origin:size:)&lt;/s3&gt;&lt;/c2&gt;は、構造体が独自のあつらえのイニシャライザを持たない場合に受け取る省略時のメンバー関連イニシャライザと機能的に同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second and third parameters are called &lt;c9&gt;&lt;s10&gt;a&lt;/s10&gt;&lt;/c9&gt; and &lt;c11&gt;&lt;s12&gt;b&lt;/s12&gt;&lt;/c11&gt;, and are both of type &lt;c13&gt;&lt;s14&gt;Int&lt;/s14&gt;&lt;/c13&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２番目と３番目のパラメータは&lt;c9&gt;&lt;s10&gt;a&lt;/s10&gt;&lt;/c9&gt;と&lt;c11&gt;&lt;s12&gt;b&lt;/s12&gt;&lt;/c11&gt;と呼ばれます、そして両方とも&lt;c13&gt;&lt;s14&gt;Int&lt;/s14&gt;&lt;/c13&gt;型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second block is then closed, followed by the first block:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第二のブロックはそれから閉じられます、そして最初のブロックが続きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second class in the hierarchy is a subclass of &lt;c0&gt;&lt;s1&gt;Food&lt;/s1&gt;&lt;/c0&gt; called &lt;c2&gt;&lt;s3&gt;RecipeIngredient&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この階層構造における第二のクラスは、&lt;c2&gt;&lt;s3&gt;RecipeIngredient&lt;/s3&gt;&lt;/c2&gt;と呼ばれる&lt;c0&gt;&lt;s1&gt;Food&lt;/s1&gt;&lt;/c0&gt;のサブクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second form emits the &lt;e1&gt;warning message&lt;/e1&gt; as a nonfatal warning and allows compilation to proceed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２番目の形式は、&lt;e1&gt;warning message（警告メッセージ）&lt;/e1&gt;を致命的でない警告として発して、コンパイルの続行を許します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second form evaluates to the value of the &lt;e0&gt;type&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第二の形式は、&lt;e0&gt;型&lt;/e0&gt;の値に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second form is used to access the superclass’s subscript implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第２の形式は、スーパークラスの添え字実装にアクセスするために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second form of a line control statement, &lt;c0&gt;&lt;s1&gt;#sourceLocation()&lt;/s1&gt;&lt;/c0&gt;, resets the source code location back to the default line numbering and filename.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２番目の形式の行制御文、&lt;c0&gt;&lt;s1&gt;#sourceLocation()&lt;/s1&gt;&lt;/c0&gt;はソースコード位置を再設定して、初期状態の行番号振りとファイル名に戻します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second form of an &lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt; statement provides an additional &lt;e2&gt;else clause&lt;/e2&gt; (introduced by the &lt;c3&gt;&lt;s4&gt;else&lt;/s4&gt;&lt;/c3&gt; keyword) and is used for executing one part of code when the condition is true and another part of code when the same condition is false.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt;文の２番目の形式は、追加の&lt;e2&gt;else節&lt;/e2&gt;（代わりの節）を提供します（&lt;c3&gt;&lt;s4&gt;else&lt;/s4&gt;&lt;/c3&gt;キーワードで導入されます）、そして条件が真である場合はあるコード部分を、そして同じ条件が偽である場合は別のコード部分を実行するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second function, &lt;c4&gt;&lt;s5&gt;printWithoutCounting(string:)&lt;/s5&gt;&lt;/c4&gt;, calls the first function, but ignores its return value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第二の関数、&lt;c4&gt;&lt;s5&gt;printWithoutCounting(string:)&lt;/s5&gt;&lt;/c4&gt;は、最初の関数を呼びます、しかしその戻り値を無視します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second initializer has a single initialization parameter with an argument label of &lt;c4&gt;&lt;s5&gt;fromKelvin&lt;/s5&gt;&lt;/c4&gt; and a parameter name of &lt;c6&gt;&lt;s7&gt;kelvin&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第二のイニシャライザは、&lt;c4&gt;&lt;s5&gt;fromKelvin&lt;/s5&gt;&lt;/c4&gt;の引数ラベルと&lt;c6&gt;&lt;s7&gt;kelvin&lt;/s7&gt;&lt;/c6&gt;のパラメータ名を使うただ１つの初期化パラメータを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second is a convenience type function called &lt;c8&gt;&lt;s9&gt;isUnlocked(_:)&lt;/s9&gt;&lt;/c8&gt;, which returns &lt;c10&gt;&lt;s11&gt;true&lt;/s11&gt;&lt;/c10&gt; if a particular level number is already unlocked.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第二は、&lt;c8&gt;&lt;s9&gt;isUnlocked(_:)&lt;/s9&gt;&lt;/c8&gt;と呼ばれる便利な型関数です、それは、特定のレベル番号がすでに錠を開けられるならば、&lt;c10&gt;&lt;s11&gt;true&lt;/s11&gt;&lt;/c10&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second kind of pattern is used for full pattern matching, where the values you’re trying to match against may not be there at runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>2番目の種類のパターンは、完全なパターンマッチングのために使われます、そこにおいてあなたがマッチを試みている対象である値は実行時にそこにないかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second pair has a key of &lt;c7&gt;&lt;s8&gt;"DUB"&lt;/s8&gt;&lt;/c7&gt; and a value of &lt;c9&gt;&lt;s10&gt;"Dublin"&lt;/s10&gt;&lt;/c9&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２番目の組みは、&lt;c7&gt;&lt;s8&gt;"DUB"&lt;/s8&gt;&lt;/c7&gt;のキーと&lt;c9&gt;&lt;s10&gt;"Dublin"&lt;/s10&gt;&lt;/c9&gt;の値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second situation is when you implicitly inherit from the same protocol multiple times.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第二の状況は、あなたが暗黙的に同じプロトコルから複数回継承する時です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second subclass, &lt;c8&gt;&lt;s9&gt;Song&lt;/s9&gt;&lt;/c8&gt;, adds an &lt;c10&gt;&lt;s11&gt;artist&lt;/s11&gt;&lt;/c10&gt; property and initializer on top of the base class:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第二のサブクラス&lt;c8&gt;&lt;s9&gt;Song&lt;/s9&gt;&lt;/c8&gt;は、基盤クラスの上に&lt;c10&gt;&lt;s11&gt;artist&lt;/s11&gt;&lt;/c10&gt;プロパティとイニシャライザを加えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second type parameter, &lt;c6&gt;&lt;s7&gt;U&lt;/s7&gt;&lt;/c6&gt;, has a type constraint that requires &lt;c8&gt;&lt;s9&gt;U&lt;/s9&gt;&lt;/c8&gt; to conform to the protocol &lt;c10&gt;&lt;s11&gt;SomeProtocol&lt;/s11&gt;&lt;/c10&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２番目の型パラメータ&lt;c6&gt;&lt;s7&gt;U&lt;/s7&gt;&lt;/c6&gt;は、&lt;c8&gt;&lt;s9&gt;U&lt;/s9&gt;&lt;/c8&gt;にプロトコル&lt;c10&gt;&lt;s11&gt;SomeProtocol&lt;/s11&gt;&lt;/c10&gt;に準拠することを要求する型制約を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second type property is a variable stored property called &lt;c0&gt;&lt;s1&gt;maxInputLevelForAllChannels&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第二の型プロパティは、&lt;c0&gt;&lt;s1&gt;maxInputLevelForAllChannels&lt;/s1&gt;&lt;/c0&gt;と呼ばれる変数格納プロパティです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The self Property</seg>
      </tuv>
      <tuv lang="JA">
        <seg>selfプロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sequence being iterated over is a range of numbers from &lt;c0&gt;&lt;s1&gt;1&lt;/s1&gt;&lt;/c0&gt; to &lt;c2&gt;&lt;s3&gt;5&lt;/s3&gt;&lt;/c2&gt;, inclusive, as indicated by the use of the closed range operator (&lt;c4&gt;&lt;s5&gt;...&lt;/s5&gt;&lt;/c4&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それに対して繰り返しを行われている連続物（シーケンス）は、完結範囲演算子（&lt;c4&gt;&lt;s5&gt;...&lt;/s5&gt;&lt;/c4&gt;）の使用によって示されるように、&lt;c0&gt;&lt;s1&gt;1&lt;/s1&gt;&lt;/c0&gt;から&lt;c2&gt;&lt;s3&gt;5&lt;/s3&gt;&lt;/c2&gt;までを含める数からなる範囲です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sequence method is declared with the &lt;c8&gt;&lt;s9&gt;warn_unqualified_access&lt;/s9&gt;&lt;/c8&gt; attribute to help reduce confusion when attempting to use one or the other from within a &lt;c10&gt;&lt;s11&gt;Sequence&lt;/s11&gt;&lt;/c10&gt; extension.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シーケンスメソッドは、&lt;c8&gt;&lt;s9&gt;warn_unqualified_access&lt;/s9&gt;&lt;/c8&gt;属性で宣言されることで、ある&lt;c10&gt;&lt;s11&gt;Sequence&lt;/s11&gt;&lt;/c10&gt;拡張内部から一方または他方を使おうと試みる場合に混乱を減じる助けとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The server either responds with the requested information, or it responds with a description of what went wrong.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのサーバーは要請された情報で応答するか、またはそれは何がうまくいかなかったかの説明で応答するかのどちらかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The setter clause is optional, and when only a getter is needed, you can omit both clauses and simply return the requested value directly, as described in &lt;a0&gt;&lt;s1&gt;Read-Only Computed Properties&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セッター節は任意です、そして、ゲッターだけが必要なとき、あなたは両方の節を省略することができます、そして&lt;a0&gt;&lt;s1&gt;読み出し専用の計算プロパティ&lt;/s1&gt;&lt;/a0&gt;で記述されるように、単に直接に要請された値を返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The setter clause is optional, and when only a getter is needed, you can omit both clauses and simply return the requested value directly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セッター節は任意です、そしてゲッターだけが必要なとき、あなたは両方の節を省略して、単に直接要請された値を返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The setter ensures that new values are less than 12, and the getter returns the stored value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セッターは、新しい値が12より少ないことを保証します、そしてゲッターは格納された値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The shifting behavior is more complex for signed integers than for unsigned integers, because of the way signed integers are represented in binary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シフト挙動は、符号つき整数では符号なし整数よりももっと複雑です、なぜなら、符号つき整数が２進数において表される方法のためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The shorthand syntax for &lt;c0&gt;&lt;s1&gt;available&lt;/s1&gt;&lt;/c0&gt; attributes concisely expresses availability for multiple platforms.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;available&lt;/s1&gt;&lt;/c0&gt;属性のための略記構文は、複数のプラットホームに対する有効性を簡潔に表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sign bit is &lt;c0&gt;&lt;s1&gt;0&lt;/s1&gt;&lt;/c0&gt; (meaning “positive”), and the seven value bits are just the number &lt;c2&gt;&lt;s3&gt;4&lt;/s3&gt;&lt;/c2&gt;, written in binary notation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>符号ビットは&lt;c0&gt;&lt;s1&gt;0&lt;/s1&gt;&lt;/c0&gt;です（「正」を意味します）、そして７つの値ビットはちょうど、２進数表記法で書かれる数&lt;c2&gt;&lt;s3&gt;4&lt;/s3&gt;&lt;/c2&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sign of &lt;c0&gt;&lt;s1&gt;b&lt;/s1&gt;&lt;/c0&gt; is ignored for negative values of &lt;c2&gt;&lt;s3&gt;b&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;b&lt;/s1&gt;&lt;/c0&gt;の符号は、負の値の&lt;c2&gt;&lt;s3&gt;b&lt;/s3&gt;&lt;/c2&gt;のために無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sign of a numeric value can be toggled using a prefixed &lt;c0&gt;&lt;s1&gt;-&lt;/s1&gt;&lt;/c0&gt;, known as the &lt;e2&gt;unary minus operator&lt;/e2&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>数の値の符号は、&lt;e2&gt;単項マイナス演算子&lt;/e2&gt;として知られる、接頭辞&lt;c0&gt;&lt;s1&gt;-&lt;/s1&gt;&lt;/c0&gt;を使うことによって切り換えられることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The simplest entry in a parameter list has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パラメータ・リストの中の最も単純な項目は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The simplest form of initializer syntax uses the type name of the class or structure followed by empty parentheses, such as &lt;c0&gt;&lt;s1&gt;Resolution()&lt;/s1&gt;&lt;/c0&gt; or &lt;c2&gt;&lt;s3&gt;VideoMode()&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザ構文の最も単純な形式は、クラスまたは構造体の型名を使用して、それに空の丸括弧を続けます、例えば&lt;c0&gt;&lt;s1&gt;Resolution()&lt;/s1&gt;&lt;/c0&gt;または&lt;c2&gt;&lt;s3&gt;VideoMode()&lt;/s3&gt;&lt;/c2&gt;のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The single type parameter for &lt;c0&gt;&lt;s1&gt;findIndex(of:in:)&lt;/s1&gt;&lt;/c0&gt; is written as &lt;c2&gt;&lt;s3&gt;T:&lt;/s3&gt; &lt;s4&gt;Equatable&lt;/s4&gt;&lt;/c2&gt;, which means “any type &lt;c5&gt;&lt;s6&gt;T&lt;/s6&gt;&lt;/c5&gt; that conforms to the &lt;c7&gt;&lt;s8&gt;Equatable&lt;/s8&gt;&lt;/c7&gt; protocol.”</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;findIndex(of:in:)&lt;/s1&gt;&lt;/c0&gt;のただ１つの型パラメータは、&lt;c2&gt;&lt;s3&gt;T:&lt;/s3&gt; &lt;s4&gt;Equatable&lt;/s4&gt;&lt;/c2&gt;として書かれます、それは、「何らかの型&lt;c5&gt;&lt;s6&gt;T&lt;/s6&gt;&lt;/c5&gt;で&lt;c7&gt;&lt;s8&gt;Equatable&lt;/s8&gt;&lt;/c7&gt;プロトコルに準拠するもの」を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sorting closure needs to return &lt;c4&gt;&lt;s5&gt;true&lt;/s5&gt;&lt;/c4&gt; if the first value should appear &lt;e6&gt;before&lt;/e6&gt; the second value, and &lt;c7&gt;&lt;s8&gt;false&lt;/s8&gt;&lt;/c7&gt; otherwise.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このソートを行うクロージャは、最初の値が第２の値の&lt;e6&gt;前に&lt;/e6&gt;現れるべきならば&lt;c4&gt;&lt;s5&gt;true&lt;/s5&gt;&lt;/c4&gt;を、そうでないならば&lt;c7&gt;&lt;s8&gt;false&lt;/s8&gt;&lt;/c7&gt;を返す必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The specialized version of the generic &lt;c0&gt;&lt;s1&gt;Dictionary&lt;/s1&gt;&lt;/c0&gt; type, &lt;c2&gt;&lt;s3&gt;Dictionary&lt;String,&lt;/s3&gt; &lt;s4&gt;Int&gt;&lt;/s4&gt;&lt;/c2&gt; is formed by replacing the generic parameters &lt;c5&gt;&lt;s6&gt;Key:&lt;/s6&gt; &lt;s7&gt;Hashable&lt;/s7&gt;&lt;/c5&gt; and &lt;c8&gt;&lt;s9&gt;Value&lt;/s9&gt;&lt;/c8&gt; with the concrete type arguments &lt;c10&gt;&lt;s11&gt;String&lt;/s11&gt;&lt;/c10&gt; and &lt;c12&gt;&lt;s13&gt;Int&lt;/s13&gt;&lt;/c12&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体&lt;c0&gt;&lt;s1&gt;Dictionary&lt;/s1&gt;&lt;/c0&gt;型の特殊化版、&lt;c2&gt;&lt;s3&gt;Dictionary&lt;String,&lt;/s3&gt; &lt;s4&gt;Int&gt;&lt;/s4&gt;&lt;/c2&gt;は、総称体パラメータ&lt;c5&gt;&lt;s6&gt;Key:&lt;/s6&gt; &lt;s7&gt;Hashable&lt;/s7&gt;&lt;/c5&gt;および&lt;c8&gt;&lt;s9&gt;Value&lt;/s9&gt;&lt;/c8&gt;を具象型引数&lt;c10&gt;&lt;s11&gt;String&lt;/s11&gt;&lt;/c10&gt;および&lt;c12&gt;&lt;s13&gt;Int&lt;/s13&gt;&lt;/c12&gt;と置き換えて作り上げられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The specific implications of this guiding principle for different aspects of the language are covered in detail below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この言語の異なる面に対する、この原理指針の特定の影響は、詳細に下で扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The specific kinds of Swift code that use long-term accesses are discussed in the sections below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特定の種類のスウィフトコードでそれら長期アクセスを使うものは、下の節で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The stack now holds four values, with the most recent one at the top.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スタックは現在は４つの値を持ちます、最も最近のものは一番上にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The standard library provides pointer and buffer types that you can use if you need to interact with pointers directly—see &lt;a3&gt;Manual Memory Management&lt;/a3&gt;&lt;s4&gt; [https://developer.apple.com/documentation/swift/swift_standard_library/manual_memory_management]&lt;/s4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>標準ライブラリは、ポインタとバッファ型を提供します、それはあなたが直接にポインタと相互作用する必要があるならばあなたが使用できます — &lt;a3&gt;手動メモリ管理&lt;/a3&gt;&lt;s4&gt; [https://developer.apple.com/documentation/swift/swift_standard_library/manual_memory_management]&lt;/s4&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The start of the closure’s body is introduced by the &lt;c0&gt;&lt;s1&gt;in&lt;/s1&gt;&lt;/c0&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャのもつ本文の始まりは、&lt;c0&gt;&lt;s1&gt;in&lt;/s1&gt;&lt;/c0&gt;キーワードで紹介されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The statement &lt;c2&gt;&lt;s3&gt;if&lt;/s3&gt; &lt;s4&gt;let&lt;/s4&gt; &lt;s5&gt;somePlanet&lt;/s5&gt; &lt;s6&gt;=&lt;/s6&gt; &lt;s7&gt;Planet(rawValue:&lt;/s7&gt; &lt;s8&gt;11)&lt;/s8&gt;&lt;/c2&gt; creates an optional &lt;c9&gt;&lt;s10&gt;Planet&lt;/s10&gt;&lt;/c9&gt;, and sets &lt;c11&gt;&lt;s12&gt;somePlanet&lt;/s12&gt;&lt;/c11&gt; to the value of that optional &lt;c13&gt;&lt;s14&gt;Planet&lt;/s14&gt;&lt;/c13&gt; if it can be retrieved.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文&lt;c2&gt;&lt;s3&gt;if&lt;/s3&gt; &lt;s4&gt;let&lt;/s4&gt; &lt;s5&gt;somePlanet&lt;/s5&gt; &lt;s6&gt;=&lt;/s6&gt; &lt;s7&gt;Planet(rawValue:&lt;/s7&gt; &lt;s8&gt;11)&lt;/s8&gt;&lt;/c2&gt;は、オプショナルの&lt;c9&gt;&lt;s10&gt;Planet&lt;/s10&gt;&lt;/c9&gt;を作成して、それが取り出されることができるならば、&lt;c11&gt;&lt;s12&gt;somePlanet&lt;/s12&gt;&lt;/c11&gt;をそのオプショナルの&lt;c13&gt;&lt;s14&gt;Planet&lt;/s14&gt;&lt;/c13&gt;のもつ値に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The statements in the &lt;c0&gt;&lt;s1&gt;defer&lt;/s1&gt;&lt;/c0&gt; statement can’t transfer program control outside of the &lt;c2&gt;&lt;s3&gt;defer&lt;/s3&gt;&lt;/c2&gt; statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;defer&lt;/s1&gt;&lt;/c0&gt;文の中の文は、プログラムの制御を&lt;c2&gt;&lt;s3&gt;defer&lt;/s3&gt;&lt;/c2&gt;文の外側に移すことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The statements within the &lt;c0&gt;&lt;s1&gt;defer&lt;/s1&gt;&lt;/c0&gt; statement are executed no matter how program control is transferred.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;defer&lt;/s1&gt;&lt;/c0&gt;文内の文は、どのようにプログラム制御が移されようと関係なく実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The static method is a member of one of the types whose values the operator takes as an argument—for example, an operator that multiplies a &lt;c0&gt;&lt;s1&gt;Double&lt;/s1&gt;&lt;/c0&gt; by an &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt; is implemented as a static method on either the &lt;c4&gt;&lt;s5&gt;Double&lt;/s5&gt;&lt;/c4&gt; or &lt;c6&gt;&lt;s7&gt;Int&lt;/s7&gt;&lt;/c6&gt; structure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この静的メソッドは、その演算子が引数としてとる値の型のうちの１つに属するあるメンバーです、例えば&lt;c0&gt;&lt;s1&gt;Double&lt;/s1&gt;&lt;/c0&gt;に&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;を掛ける演算子は静的メソッドとして&lt;c4&gt;&lt;s5&gt;Double&lt;/s5&gt;&lt;/c4&gt;または&lt;c6&gt;&lt;s7&gt;Int&lt;/s7&gt;&lt;/c6&gt; 構造体のどちらかで実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The stored or computed nature of an inherited property is not known by a subclass—it only knows that the inherited property has a certain name and type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>継承されたプロパティの格納または計算の種別は、サブクラスには知られません ― それは、継承されたプロパティが特定の名前と型を持つということを知っているだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The string &lt;c6&gt;&lt;s7&gt;"123"&lt;/s7&gt;&lt;/c6&gt; can be converted into the numeric value &lt;c8&gt;&lt;s9&gt;123&lt;/s9&gt;&lt;/c8&gt;, but the string &lt;c10&gt;&lt;s11&gt;"hello,&lt;/s11&gt; &lt;s12&gt;world"&lt;/s12&gt;&lt;/c10&gt; doesn’t have an obvious numeric value to convert to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列&lt;c6&gt;&lt;s7&gt;"123"&lt;/s7&gt;&lt;/c6&gt;は数の値&lt;c8&gt;&lt;s9&gt;123&lt;/s9&gt;&lt;/c8&gt;に変えられることができます、しかし文字列&lt;c10&gt;&lt;s11&gt;"hello,&lt;/s11&gt; &lt;s12&gt;world"&lt;/s12&gt;&lt;/c10&gt;には変えるための明らかな数の値がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The string begins on the first line after the opening quotation marks (&lt;c0&gt;&lt;s1&gt;"""&lt;/s1&gt;&lt;/c0&gt;) and ends on the line before the closing quotation marks, which means that neither of the strings below start or end with a line break:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列は、開始引用符（&lt;c0&gt;&lt;s1&gt;"""&lt;/s1&gt;&lt;/c0&gt;）の後の最初の行で始まって終了引用符の前の行で終わります、それが意味するのは下の文字列のどちらも改行で始まったり終わったりしないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The string retrieved from the &lt;c0&gt;&lt;s1&gt;digitNames&lt;/s1&gt;&lt;/c0&gt; dictionary is added to the &lt;e2&gt;front&lt;/e2&gt; of &lt;c3&gt;&lt;s4&gt;output&lt;/s4&gt;&lt;/c3&gt;, effectively building a string version of the number in reverse.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;digitNames&lt;/s1&gt;&lt;/c0&gt;辞書から取り出される文字列は&lt;c3&gt;&lt;s4&gt;output&lt;/s4&gt;&lt;/c3&gt;の&lt;e2&gt;前方&lt;/e2&gt;に加えられて、うまい具合に数の文字列版を逆の順序で造ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The string-sorting closure from the &lt;a0&gt;&lt;s1&gt;Closure Expression Syntax&lt;/s1&gt;&lt;/a0&gt; section above can be written outside of the &lt;c2&gt;&lt;s3&gt;sorted(by:)&lt;/s3&gt;&lt;/c2&gt; method’s parentheses as a trailing closure:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の&lt;a0&gt;&lt;s1&gt;クロージャ式構文&lt;/s1&gt;&lt;/a0&gt;の節の文字列を分類するクロージャは、後付クロージャとして&lt;c2&gt;&lt;s3&gt;sorted(by:)&lt;/s3&gt;&lt;/c2&gt;関数の括弧の外側に書かれることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The strong reference cycle prevents the &lt;c2&gt;&lt;s3&gt;Person&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;Apartment&lt;/s5&gt;&lt;/c4&gt; instances from ever being deallocated, causing a memory leak in your app.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>強い参照循環は&lt;c2&gt;&lt;s3&gt;Person&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;Apartment&lt;/s5&gt;&lt;/c4&gt;インスタンスがともかく割り当て解除されるのを妨げます。そして、あなたのアプリのメモリリークを引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The strong references between the &lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt; instance and the &lt;c2&gt;&lt;s3&gt;Apartment&lt;/s3&gt;&lt;/c2&gt; instance remain and cannot be broken.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt;インスタンスと&lt;c2&gt;&lt;s3&gt;Apartment&lt;/s3&gt;&lt;/c2&gt;インスタンスの間の強い参照は、残っていて、壊されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The strong references from the two variables (&lt;c0&gt;&lt;s1&gt;john&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;unit4A&lt;/s3&gt;&lt;/c2&gt;) and the links between the two instances are created as before:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つの変数（&lt;c0&gt;&lt;s1&gt;john&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;unit4A&lt;/s3&gt;&lt;/c2&gt;）からの強い参照と２つのインスタンスの繋がりは、前の通り作成されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The structure also defines a stored integer property called &lt;c6&gt;&lt;s7&gt;numberOfEdits&lt;/s7&gt;&lt;/c6&gt;, which is used to track the number of times that &lt;c8&gt;&lt;s9&gt;value&lt;/s9&gt;&lt;/c8&gt; is modified.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この構造体はまた、&lt;c6&gt;&lt;s7&gt;numberOfEdits&lt;/s7&gt;&lt;/c6&gt;と呼ばれる格納整数プロパティを定義します、それは、&lt;c8&gt;&lt;s9&gt;value&lt;/s9&gt;&lt;/c8&gt;が修正される回数を追跡するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The structure defines a single initializer, &lt;c0&gt;&lt;s1&gt;init&lt;/s1&gt;&lt;/c0&gt;, with no parameters, which initializes the stored temperature with a value of &lt;c2&gt;&lt;s3&gt;32.0&lt;/s3&gt;&lt;/c2&gt; (the freezing point of water in degrees Fahrenheit).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この構造体は、パラメータのないただ１つのイニシャライザ、&lt;c0&gt;&lt;s1&gt;init&lt;/s1&gt;&lt;/c0&gt;を定義します、それは格納された温度を値&lt;c2&gt;&lt;s3&gt;32.0&lt;/s3&gt;&lt;/c2&gt;（華氏度数での水の氷点）で初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The structure is either not captured by any closures, or it’s captured only by nonescaping closures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その構造体はどんなクロージャによってもキャプチャされない、またはそれは非脱出クロージャによってのみキャプチャされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The structure is the value of a local variable, not a global variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その構造体はローカル変数の値である、グローバル変数ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The structure of the &lt;c6&gt;&lt;s7&gt;repeat&lt;/s7&gt;&lt;/c6&gt;-&lt;c8&gt;&lt;s9&gt;while&lt;/s9&gt;&lt;/c8&gt; loop is better suited to this game than the &lt;c10&gt;&lt;s11&gt;while&lt;/s11&gt;&lt;/c10&gt; loop in the previous example.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;repeat&lt;/s7&gt;&lt;/c6&gt;-&lt;c8&gt;&lt;s9&gt;while&lt;/s9&gt;&lt;/c8&gt;ループの構造は、前の例での&lt;c10&gt;&lt;s11&gt;while&lt;/s11&gt;&lt;/c10&gt;ループよりも更に良くこのゲームに適しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The structure’s members (including the &lt;c2&gt;&lt;s3&gt;numberOfEdits&lt;/s3&gt;&lt;/c2&gt; property) therefore have an internal access level by default.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体のメンバー（&lt;c2&gt;&lt;s3&gt;numberOfEdits&lt;/s3&gt;&lt;/c2&gt;プロパティを含む）は、したがって特に何もしなければ内部のアクセス水準を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The subclass in this figure has two designated initializers and one convenience initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この図の中のサブクラスは、２つの指定イニシャライザと１つの便宜イニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The subclass inherits characteristics from the existing class, which you can then refine.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブクラスは既存のクラスから特徴を受け継ぎます、あなたはそのとき改良することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The subclass object is not deallocated until all deinitializers in its inheritance chain have finished executing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブクラスオブジェクトは、その継承連鎖の中の全てのデイニシャライザが実行を終えるまで、割り当て解除されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The subclass’s implementation of that initializer must also be marked with the &lt;c0&gt;&lt;s1&gt;required&lt;/s1&gt;&lt;/c0&gt; modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このイニシャライザのサブクラスでの実装はまた、&lt;c0&gt;&lt;s1&gt;required&lt;/s1&gt;&lt;/c0&gt;修飾子で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The subclass’s implementation of that initializer must also be marked with the &lt;c2&gt;&lt;s3&gt;required&lt;/s3&gt;&lt;/c2&gt; declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのイニシャライザのサブクラスの実装もまた、&lt;c2&gt;&lt;s3&gt;required&lt;/s3&gt;&lt;/c2&gt;宣言修飾子で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The subscript can accept a parameter that’s either a key path or a member name; if you implement both subscripts, the subscript that takes key path argument is used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字は、あるパラメータを受け入れます、それはキーパスまたはメンバ名のどちらかです；あなたが両方の添え字を実装するならば、キーパス引数をとる添え字が使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The subscript on &lt;c16&gt;&lt;s17&gt;Container&lt;/s17&gt;&lt;/c16&gt; returns &lt;c18&gt;&lt;s19&gt;Item&lt;/s19&gt;&lt;/c18&gt;, which means that the type of &lt;c20&gt;&lt;s21&gt;twelve&lt;/s21&gt;&lt;/c20&gt; is also inferred to be &lt;c22&gt;&lt;s23&gt;Int&lt;/s23&gt;&lt;/c22&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c16&gt;&lt;s17&gt;Container&lt;/s17&gt;&lt;/c16&gt;上での添え字は、 &lt;c18&gt;&lt;s19&gt;Item&lt;/s19&gt;&lt;/c18&gt;を返します、それは&lt;c20&gt;&lt;s21&gt;twelve&lt;/s21&gt;&lt;/c20&gt;の型もまた&lt;c22&gt;&lt;s23&gt;Int&lt;/s23&gt;&lt;/c22&gt;に推論されることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The subscript returns an optional value of the dictionary’s value type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字は辞書のもつ値型のオプショナルの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The subscript takes a single parameter, &lt;c0&gt;&lt;s1&gt;indices&lt;/s1&gt;&lt;/c0&gt;, which is an instance of that &lt;c2&gt;&lt;s3&gt;Indices&lt;/s3&gt;&lt;/c2&gt; type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この添え字は、ただ１つだけのパラメータ、&lt;c0&gt;&lt;s1&gt;indices&lt;/s1&gt;&lt;/c0&gt;をとります、それは&lt;c2&gt;&lt;s3&gt;Indices&lt;/s3&gt;&lt;/c2&gt;型のインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The subscript’s return type can be any type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字のもつ戻り型は、どんな型でも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The superclass does not itself have a further superclass, and so rule 1 does not apply.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このスーパークラスにはそれ自身には更にスーパークラスをもちません、なので規則１は適用されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The superclass’s designated initializer makes sure that all of the superclass properties have a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラスの指定イニシャライザは、スーパークラスのプロパティの全てが値を持つことを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The superclass’s designated initializer now has an opportunity to customize the instance further (although it does not have to).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スーパークラスの指定イニシャライザは、現在、さらにインスタンスを好みに合わせて作り返る機会があります（しかしながら、それはそうしなければならない訳ではない）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The switch cycles between three different power states (&lt;c0&gt;&lt;s1&gt;off&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;low&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;high&lt;/s5&gt;&lt;/c4&gt;) every time its &lt;c6&gt;&lt;s7&gt;next()&lt;/s7&gt;&lt;/c6&gt; method is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この切替えは、３つの異なる出力状態（&lt;c0&gt;&lt;s1&gt;off&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;low&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;high&lt;/s5&gt;&lt;/c4&gt;）の間を、それの&lt;c6&gt;&lt;s7&gt;next()&lt;/s7&gt;&lt;/c6&gt;メソッドが呼ばれるたびに循環します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The syntax and standard library have been designed based on the guiding principle that the obvious way to write your code should also perform the best.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構文と標準ライブラリは、明確なやり方であなたのコードを書くことが常に最良を成すべきだという指針に基づいて設計されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The syntax for creating instances is very similar for both structures and classes:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インスタンスをつくるための構文は、構造体とクラスの両方で非常に類似しています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The syntax for protocol inheritance is similar to the syntax for class inheritance, but with the option to list multiple inherited protocols, separated by commas:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル継承のための構文は、クラス継承のための構文に似ています、しかし複数の継承されたプロトコルをコンマで区切って列記する選択肢を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The syntax for string creation and manipulation is lightweight and readable, with a string literal syntax that is similar to C. String concatenation is as simple as combining two strings with the &lt;c4&gt;&lt;s5&gt;+&lt;/s5&gt;&lt;/c4&gt; operator, and string mutability is managed by choosing between a constant or a variable, just like any other value in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列の作成と操作のための構文は、軽量で、読みやすく、Cに類似した文字列リテラル構文をもちます。文字列の連結は、２つの文字列を&lt;c4&gt;&lt;s5&gt;+&lt;/s5&gt;&lt;/c4&gt;演算子を使って繋ぎ合わせるくらい単純です、そして、文字列が変更可能かどうかは、スウィフトの他あらゆる値と同じように、定数または変数のどちらかを選ぶことによって管理されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The syntax used in the examples above marks the enumeration as conforming to the &lt;a0&gt;&lt;c1&gt;&lt;s2&gt;CaseIterable&lt;/s2&gt;&lt;/c1&gt;&lt;/a0&gt;&lt;s3&gt; [https://developer.apple.com/documentation/swift/caseiterable]&lt;/s3&gt; protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例において使われる構文は、列挙を&lt;a0&gt;&lt;c1&gt;&lt;s2&gt;CaseIterable&lt;/s2&gt;&lt;/c1&gt;&lt;/a0&gt;&lt;s3&gt; [https://developer.apple.com/documentation/swift/caseiterable]&lt;/s3&gt;プロトコルに準拠するように印します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The synthesized storage for the wrapper has an access control level of &lt;c11&gt;&lt;s12&gt;private&lt;/s12&gt;&lt;/c11&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ラッパーのために合成されたストレージは、&lt;c11&gt;&lt;s12&gt;private&lt;/s12&gt;&lt;/c11&gt;のアクセス制御水準を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The tenant property is optional because an apartment may not always have a tenant.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アパートには常に賃借人がいるわけではないので、tenant（テナント、賃借人）プロパティはオプショナルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ternary conditional operator is shorthand for the code below:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>三項条件演算子は、下のコードの短縮形です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ternary conditional operator provides an efficient shorthand for deciding which of two expressions to consider.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>三項条件演算子は、２つの式のどちらを考慮するべきか決定することについての効果的な短縮形を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third &lt;c0&gt;&lt;s1&gt;Rect&lt;/s1&gt;&lt;/c0&gt; initializer, &lt;c2&gt;&lt;s3&gt;init(center:size:)&lt;/s3&gt;&lt;/c2&gt;, is slightly more complex.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第３の&lt;c0&gt;&lt;s1&gt;Rect&lt;/s1&gt;&lt;/c0&gt;イニシャライザ、&lt;c2&gt;&lt;s3&gt;init(center:size:)&lt;/s3&gt;&lt;/c2&gt;は、わずかにより複雑です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third and final class in the hierarchy is a subclass of &lt;c0&gt;&lt;s1&gt;RecipeIngredient&lt;/s1&gt;&lt;/c0&gt; called &lt;c2&gt;&lt;s3&gt;ShoppingListItem&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この階層構造の中の３番目の最後のクラスは、&lt;c2&gt;&lt;s3&gt;ShoppingListItem&lt;/s3&gt;&lt;/c2&gt;と呼ばれる&lt;c0&gt;&lt;s1&gt;RecipeIngredient&lt;/s1&gt;&lt;/c0&gt;のサブクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third and fourth requirements combine to mean that the items in &lt;c0&gt;&lt;s1&gt;anotherContainer&lt;/s1&gt;&lt;/c0&gt; can &lt;e2&gt;also&lt;/e2&gt; be checked with the &lt;c3&gt;&lt;s4&gt;!=&lt;/s4&gt;&lt;/c3&gt; operator, because they’re exactly the same type as the items in &lt;c5&gt;&lt;s6&gt;someContainer&lt;/s6&gt;&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>３番目と４番目の要件は組み合わされて、&lt;c0&gt;&lt;s1&gt;anotherContainer&lt;/s1&gt;&lt;/c0&gt;の中の項目が&lt;c3&gt;&lt;s4&gt;!=&lt;/s4&gt;&lt;/c3&gt;演算子を使って確認されることが&lt;e2&gt;同様に&lt;/e2&gt;可能なことを意味します、なぜなら、それらは&lt;c5&gt;&lt;s6&gt;someContainer&lt;/s6&gt;&lt;/c5&gt;の中の項目と同じ正確に型であるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third call fails, because the &lt;c22&gt;&lt;s23&gt;testScores&lt;/s23&gt;&lt;/c22&gt; dictionary does not contain a key for &lt;c24&gt;&lt;s25&gt;"Brian"&lt;/s25&gt;&lt;/c24&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>３番目の呼び出しは失敗します、なぜなら、&lt;c22&gt;&lt;s23&gt;testScores&lt;/s23&gt;&lt;/c22&gt;辞書は&lt;c24&gt;&lt;s25&gt;"Brian"&lt;/s25&gt;&lt;/c24&gt;のキーを含んでいないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third form is used to access an initializer of the superclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第３の形式は、スーパークラスのイニシャライザにアクセスするために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The third property, &lt;c8&gt;&lt;s9&gt;street&lt;/s9&gt;&lt;/c8&gt;, is used to name the street for that address:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第３のプロパティ、&lt;c8&gt;&lt;s9&gt;street&lt;/s9&gt;&lt;/c8&gt;は、そのアドレスの通りのために使われます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The three &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; cases declare placeholder constants &lt;c2&gt;&lt;s3&gt;x&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;y&lt;/s5&gt;&lt;/c4&gt;, which temporarily take on one or both tuple values from &lt;c6&gt;&lt;s7&gt;anotherPoint&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>３つの&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;ケース節はプレースホルダ定数&lt;c2&gt;&lt;s3&gt;x&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;y&lt;/s5&gt;&lt;/c4&gt;を宣言します、それは、一時的に&lt;c6&gt;&lt;s7&gt;anotherPoint&lt;/s7&gt;&lt;/c6&gt;から１つまたは両方のタプル値を引き受けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The three &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; cases declare placeholder constants &lt;c2&gt;&lt;s3&gt;x&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;y&lt;/s5&gt;&lt;/c4&gt;, which temporarily take on the two tuple values from &lt;c6&gt;&lt;s7&gt;yetAnotherPoint&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>３つの&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;ケース節はプレースホルダ定数&lt;c2&gt;&lt;s3&gt;x&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;y&lt;/s5&gt;&lt;/c4&gt;とを宣言します、それは、一時的に２つタプル値を&lt;c6&gt;&lt;s7&gt;yetAnotherPoint&lt;/s7&gt;&lt;/c6&gt;から引き受けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The three code snippets below define a hierarchy of classes and an array containing instances of those classes, for use in an example of type casting.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下の３つのコードの断片は、型キャストの例で使うために、あるクラス階層とそれらのクラスのインスタンスを含んでいる配列を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The tokens &lt;c0&gt;&lt;s1&gt;=&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;-&gt;&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;//&lt;/s5&gt;&lt;/c4&gt;, &lt;c6&gt;&lt;s7&gt;/*&lt;/s7&gt;&lt;/c6&gt;, &lt;c8&gt;&lt;s9&gt;*/&lt;/s9&gt;&lt;/c8&gt;, &lt;c10&gt;&lt;s11&gt;.&lt;/s11&gt;&lt;/c10&gt;, the prefix operators &lt;c12&gt;&lt;s13&gt;&lt;&lt;/s13&gt;&lt;/c12&gt;, &lt;c14&gt;&lt;s15&gt;&amp;&lt;/s15&gt;&lt;/c14&gt;, and &lt;c16&gt;&lt;s17&gt;?&lt;/s17&gt;&lt;/c16&gt;, the infix operator &lt;c18&gt;&lt;s19&gt;?&lt;/s19&gt;&lt;/c18&gt;, and the postfix operators &lt;c20&gt;&lt;s21&gt;&gt;&lt;/s21&gt;&lt;/c20&gt;, &lt;c22&gt;&lt;s23&gt;!&lt;/s23&gt;&lt;/c22&gt;, and &lt;c24&gt;&lt;s25&gt;?&lt;/s25&gt;&lt;/c24&gt; are reserved.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>トークン&lt;c0&gt;&lt;s1&gt;=&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;-&gt;&lt;/s3&gt;&lt;/c2&gt;、&lt;c4&gt;&lt;s5&gt;//&lt;/s5&gt;&lt;/c4&gt;、&lt;c6&gt;&lt;s7&gt;/*&lt;/s7&gt;&lt;/c6&gt;、&lt;c8&gt;&lt;s9&gt;*/&lt;/s9&gt;&lt;/c8&gt;、&lt;c10&gt;&lt;s11&gt;.&lt;/s11&gt;&lt;/c10&gt;、接頭辞演算子&lt;c12&gt;&lt;s13&gt;&lt;&lt;/s13&gt;&lt;/c12&gt;、&lt;c14&gt;&lt;s15&gt;&amp;&lt;/s15&gt;&lt;/c14&gt;、および&lt;c16&gt;&lt;s17&gt;?&lt;/s17&gt;&lt;/c16&gt;、そして接中辞演算子&lt;c18&gt;&lt;s19&gt;?&lt;/s19&gt;&lt;/c18&gt;、そして接尾辞演算子&lt;c20&gt;&lt;s21&gt;&gt;&lt;/s21&gt;&lt;/c20&gt;、&lt;c22&gt;&lt;s23&gt;!&lt;/s23&gt;&lt;/c22&gt;、および&lt;c24&gt;&lt;s25&gt;?&lt;/s25&gt;&lt;/c24&gt;は予約されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The top item in the stack is popped.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スタックでの一番上の項目がポンと取り出され（ポップされ）ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The top-level code in a Swift source file consists of zero or more statements, declarations, and expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるスウィフトソースコードにおけるトップレベル・コードは、０個以上の文、宣言、そして式から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The trailing closure is understood as an argument to the function, added after the last parenthesized argument.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>後付クロージャは関数に対する引数として理解されます、そして、最後に括弧に入れた引数の後に加えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The two containers to be checked don’t have to be the same type of container (although they can be), but they do have to hold the same type of items.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>調べられる２つのコンテナは、同じ型のコンテナである必要はありません（とは言えそうでもよい）、しかしそれらは同じ型の項目を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The two write accesses refer to the same memory and they overlap, producing a conflict.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つの書き込みアクセスは同じメモリを参照してそれらはオーバーラッブして、衝突を生み出しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type &lt;c0&gt;&lt;s1&gt;Optional&lt;Wrapped&gt;&lt;/s1&gt;&lt;/c0&gt; is an enumeration with two cases, &lt;c2&gt;&lt;s3&gt;none&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;some(Wrapped)&lt;/s5&gt;&lt;/c4&gt;, which are used to represent values that may or may not be present.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型&lt;c0&gt;&lt;s1&gt;Optional&lt;Wrapped&gt;&lt;/s1&gt;&lt;/c0&gt;は、&lt;c2&gt;&lt;s3&gt;none&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;some(Wrapped)&lt;/s5&gt;&lt;/c4&gt;、２つのケース節をもつ列挙です、それは、存在しているかもしれないししていないかもしれない値を表わすために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type alias can provide concrete types for some or all of the generic parameters of the existing type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型エイリアスは、既存の型の総称体パラメータの一部またはすべてに具象型を提供できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type annotation (&lt;c0&gt;&lt;s1&gt;:&lt;/s1&gt;&lt;/c0&gt; &lt;e2&gt;type&lt;/e2&gt;) is optional in a constant declaration when the type of the &lt;e3&gt;constant name&lt;/e3&gt; can be inferred, as described in &lt;a4&gt;&lt;s5&gt;Type Inference&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e3&gt;定数名&lt;/e3&gt;の型が推論されることができるとき、&lt;a4&gt;&lt;s5&gt;型推論&lt;/s5&gt;&lt;/a4&gt;で記述されるように、型注釈（&lt;c0&gt;&lt;s1&gt;:&lt;/s1&gt;&lt;/c0&gt; &lt;e2&gt;type&lt;/e2&gt;）は定数宣言において任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type arguments are instead inferred from the type of the arguments passed to the function or initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型引数は、その代わりに関数またはイニシャライザに渡される引数の型から推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type check operator returns &lt;c3&gt;&lt;s4&gt;true&lt;/s4&gt;&lt;/c3&gt; if the instance is of that subclass type and &lt;c5&gt;&lt;s6&gt;false&lt;/s6&gt;&lt;/c5&gt; if it is not.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型確認演算子はそのインスタンスがそのサブクラス型ならば&lt;c3&gt;&lt;s4&gt;true&lt;/s4&gt;&lt;/c3&gt;を、それがそうでないならば&lt;c5&gt;&lt;s6&gt;false&lt;/s6&gt;&lt;/c5&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type method can be used as an infix operator between existing &lt;c0&gt;&lt;s1&gt;Vector2D&lt;/s1&gt;&lt;/c0&gt; instances:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この型メソッドは既存の&lt;c0&gt;&lt;s1&gt;Vector2D&lt;/s1&gt;&lt;/c0&gt;インスタンスの間で接中辞演算子として使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type must implement a &lt;c0&gt;&lt;s1&gt;subscript(dynamicMemberLookup:)&lt;/s1&gt;&lt;/c0&gt; subscript.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この型は、&lt;c0&gt;&lt;s1&gt;subscript(dynamicMemberLookup:)&lt;/s1&gt;&lt;/c0&gt;添え字を実装しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type must implement either a &lt;c0&gt;&lt;s1&gt;dynamicallyCall(withArguments:)&lt;/s1&gt;&lt;/c0&gt; method, a &lt;c2&gt;&lt;s3&gt;dynamicallyCall(withKeywordArguments:)&lt;/s3&gt;&lt;/c2&gt; method, or both.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その型は、&lt;c0&gt;&lt;s1&gt;dynamicallyCall(withArguments:)&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;dynamicallyCall(withKeywordArguments:)&lt;/s3&gt;&lt;/c2&gt;メソッドのどちらか、または両方を実装しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of &lt;c0&gt;&lt;s1&gt;directionToHead&lt;/s1&gt;&lt;/c0&gt; is already known, and so you can drop the type when setting its value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;directionToHead&lt;/s1&gt;&lt;/c0&gt;の型はすでに知られています、それでその値を設定するとき、あなたは型を省くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of &lt;c0&gt;&lt;s1&gt;directionToHead&lt;/s1&gt;&lt;/c0&gt; is inferred when it’s initialized with one of the possible values of &lt;c2&gt;&lt;s3&gt;CompassPoint&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;directionToHead&lt;/s1&gt;&lt;/c0&gt;の型は、それが&lt;c2&gt;&lt;s3&gt;CompassPoint&lt;/s3&gt;&lt;/c2&gt;の可能な値のうちの１つで初期化されるとき、推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of &lt;c0&gt;&lt;s1&gt;newValue&lt;/s1&gt;&lt;/c0&gt; is the same as the return value of the subscript.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;newValue&lt;/s1&gt;&lt;/c0&gt;の型は、添え字の戻り値と同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of &lt;c0&gt;&lt;s1&gt;twelve&lt;/s1&gt;&lt;/c0&gt; is inferred to be &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;, which illustrates the fact that type inference works with opaque types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;twelve&lt;/s1&gt;&lt;/c0&gt;の型は、&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;であると推論されます、それは型推論が不透明型を扱うという事実を例示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of a Swift array is written in full as &lt;c0&gt;&lt;s1&gt;Array&lt;Element&gt;&lt;/s1&gt;&lt;/c0&gt;, where &lt;c2&gt;&lt;s3&gt;Element&lt;/s3&gt;&lt;/c2&gt; is the type of values the array is allowed to store.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト配列の型は、完全には&lt;c0&gt;&lt;s1&gt;Array&lt;Element&gt;&lt;/s1&gt;&lt;/c0&gt;のように書かれます、そこにおいて&lt;c2&gt;&lt;s3&gt;Element&lt;/s3&gt;&lt;/c2&gt;はその配列が格納するのを許される値の型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of a Swift dictionary is written in full as &lt;c0&gt;&lt;s1&gt;Dictionary&lt;Key,&lt;/s1&gt; &lt;s2&gt;Value&gt;&lt;/s2&gt;&lt;/c0&gt;, where &lt;c3&gt;&lt;s4&gt;Key&lt;/s4&gt;&lt;/c3&gt; is the type of value that can be used as a dictionary key, and &lt;c5&gt;&lt;s6&gt;Value&lt;/s6&gt;&lt;/c5&gt; is the type of value that the dictionary stores for those keys.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの辞書型は、完全には&lt;c0&gt;&lt;s1&gt;Dictionary&lt;Key,&lt;/s1&gt; &lt;s2&gt;Value&gt;&lt;/s2&gt;&lt;/c0&gt;のように書かれます、ここで&lt;c3&gt;&lt;s4&gt;Key&lt;/s4&gt;&lt;/c3&gt;は辞書キーとして使われることができる値の型です、そして&lt;c5&gt;&lt;s6&gt;Value&lt;/s6&gt;&lt;/c5&gt;は辞書がそれらのキーに対してたくわえる値の型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of a Swift set is written as &lt;c0&gt;&lt;s1&gt;Set&lt;Element&gt;&lt;/s1&gt;&lt;/c0&gt;, where &lt;c2&gt;&lt;s3&gt;Element&lt;/s3&gt;&lt;/c2&gt; is the type that the set is allowed to store.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるスウィフト集合の型は、&lt;c0&gt;&lt;s1&gt;Set&lt;Element&gt;&lt;/s1&gt;&lt;/c0&gt;のように書かれます、そこにおいて&lt;c2&gt;&lt;s3&gt;Element&lt;/s3&gt;&lt;/c2&gt;はその集合が格納することを許される型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of both of these functions is &lt;c0&gt;&lt;s1&gt;(Int,&lt;/s1&gt; &lt;s2&gt;Int)&lt;/s2&gt; &lt;s3&gt;-&gt;&lt;/s3&gt; &lt;s4&gt;Int&lt;/s4&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの関数の型は両方とも、&lt;c0&gt;&lt;s1&gt;(Int,&lt;/s1&gt; &lt;s2&gt;Int)&lt;/s2&gt; &lt;s3&gt;-&gt;&lt;/s3&gt; &lt;s4&gt;Int&lt;/s4&gt;&lt;/c0&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of each parameter must be included—it can’t be inferred.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>各パラメータの型は、含められなければなりません ― それは、推論されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of the &lt;c0&gt;&lt;s1&gt;letters&lt;/s1&gt;&lt;/c0&gt; variable is inferred to be &lt;c2&gt;&lt;s3&gt;Set&lt;Character&gt;&lt;/s3&gt;&lt;/c2&gt;, from the type of the initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;letters&lt;/s1&gt;&lt;/c0&gt;変数の型は、そのイニシャライザの型から、&lt;c2&gt;&lt;s3&gt;Set&lt;Character&gt;&lt;/s3&gt;&lt;/c2&gt;と推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of the &lt;c2&gt;&lt;s3&gt;celebrator&lt;/s3&gt;&lt;/c2&gt; parameter is &lt;c4&gt;&lt;s5&gt;Named&lt;/s5&gt; &lt;s6&gt;&amp;&lt;/s6&gt; &lt;s7&gt;Aged&lt;/s7&gt;&lt;/c4&gt;, which means “any type that conforms to both the &lt;c8&gt;&lt;s9&gt;Named&lt;/s9&gt;&lt;/c8&gt; and &lt;c10&gt;&lt;s11&gt;Aged&lt;/s11&gt;&lt;/c10&gt; protocols.” It doesn’t matter which specific type is passed to the function, as long as it conforms to both of the required protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;celebrator&lt;/s3&gt;&lt;/c2&gt;パラメータの型は&lt;c4&gt;&lt;s5&gt;Named&lt;/s5&gt; &lt;s6&gt;&amp;&lt;/s6&gt; &lt;s7&gt;Aged&lt;/s7&gt;&lt;/c4&gt;です、それは「&lt;c8&gt;&lt;s9&gt;Named&lt;/s9&gt;&lt;/c8&gt;と&lt;c10&gt;&lt;s11&gt;Aged&lt;/s11&gt;&lt;/c10&gt;プロトコルの両方に準拠する何らかの型」を意味します。どのような具体的な型が関数へ渡されるかは問題ではありません、それが必須プロトコルの両方に準拠する限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of the &lt;c2&gt;&lt;s3&gt;numberOfLegs&lt;/s3&gt;&lt;/c2&gt; dictionary is inferred to be &lt;c4&gt;&lt;s5&gt;[String:&lt;/s5&gt; &lt;s6&gt;Int]&lt;/s6&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;numberOfLegs&lt;/s3&gt;&lt;/c2&gt;辞書の型は、&lt;c4&gt;&lt;s5&gt;[String:&lt;/s5&gt; &lt;s6&gt;Int]&lt;/s6&gt;&lt;/c4&gt;であると推測されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of the &lt;c6&gt;&lt;s7&gt;library&lt;/s7&gt;&lt;/c6&gt; array is inferred by initializing it with the contents of an array literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;library&lt;/s7&gt;&lt;/c6&gt;配列の型は、ある配列リテラルの内容でそれを初期化することから推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of the array is inferred to be &lt;c4&gt;&lt;s5&gt;[ShoppingListItem]&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列の型は、&lt;c4&gt;&lt;s5&gt;[ShoppingListItem]&lt;/s5&gt;&lt;/c4&gt;であると推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of the parameter to the setter is the same as the &lt;e3&gt;return type&lt;/e3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セッターに対するパラメータの型は、&lt;e3&gt;return type（戻り型）&lt;/e3&gt;と同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of the property must conform to the &lt;c3&gt;&lt;s4&gt;NSCopying&lt;/s4&gt;&lt;/c3&gt; protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティの型は、&lt;c3&gt;&lt;s4&gt;NSCopying&lt;/s4&gt;&lt;/c3&gt;プロトコルに準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of the variable or property must be an optional class type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この変数またはプロパティの型はまた、オプショナルクラス型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of these values is specified in the &lt;e3&gt;raw-value type&lt;/e3&gt; and must represent an integer, floating-point number, string, or single character.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの値の型は、&lt;e3&gt;生の値型&lt;/e3&gt;において指定されて、整数、浮動小数点数、文字列または単一の文字を表さなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of this function is &lt;c0&gt;&lt;s1&gt;()&lt;/s1&gt; &lt;s2&gt;-&gt;&lt;/s2&gt; &lt;s3&gt;Void&lt;/s3&gt;&lt;/c0&gt;, or “a function that has no parameters, and returns &lt;c4&gt;&lt;s5&gt;Void&lt;/s5&gt;&lt;/c4&gt;.”</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数の型は&lt;c0&gt;&lt;s1&gt;()&lt;/s1&gt; &lt;s2&gt;-&gt;&lt;/s2&gt; &lt;s3&gt;Void&lt;/s3&gt;&lt;/c0&gt;です、あるいは「パラメータを持たず、&lt;c4&gt;&lt;s5&gt;Void&lt;/s5&gt;&lt;/c4&gt;を返す関数」。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type of this property is &lt;c2&gt;&lt;s3&gt;String?&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロパティの型は、&lt;c2&gt;&lt;s3&gt;String?&lt;/s3&gt;&lt;/c2&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The types of &lt;c0&gt;&lt;s1&gt;orangesAreOrange&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;turnipsAreDelicious&lt;/s3&gt;&lt;/c2&gt; have been inferred as &lt;c4&gt;&lt;s5&gt;Bool&lt;/s5&gt;&lt;/c4&gt; from the fact that they were initialized with Boolean literal values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;orangesAreOrange&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;turnipsAreDelicious&lt;/s3&gt;&lt;/c2&gt;の型は、それらがブールのリテラル値で初期化されたという事実から、&lt;c4&gt;&lt;s5&gt;Bool&lt;/s5&gt;&lt;/c4&gt;として推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The types used for any raw values or associated values in an enumeration definition must have an access level at least as high as the enumeration’s access level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙定義の中のあらゆる生の値または関連値のために使われる型は、少なくとも列挙のアクセス水準と同じの高さのアクセス水準を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The unary minus operator (&lt;c0&gt;&lt;s1&gt;-&lt;/s1&gt;&lt;/c0&gt;) is prepended directly before the value it operates on, without any white space.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単項マイナス演算子（&lt;c0&gt;&lt;s1&gt;-&lt;/s1&gt;&lt;/c0&gt;）は、それが作用する値の前に、全く空白なしで、直接に先頭に追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The unary minus operator is a prefix operator, and so this method has to be qualified with the &lt;c4&gt;&lt;s5&gt;prefix&lt;/s5&gt;&lt;/c4&gt; modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この単項マイナス演算子は、接頭辞演算子です、なのでこのメソッドは&lt;c4&gt;&lt;s5&gt;prefix&lt;/s5&gt;&lt;/c4&gt;修飾子で修飾されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The underlying instance remains the same; it is simply treated and accessed as an instance of the type to which it has been cast.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>根底にあるインスタンスは、同じもののままです；それは単に、それがキャストされた型のインスタンスとして扱われ、アクセスされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The underscore character (&lt;c16&gt;&lt;s17&gt;_&lt;/s17&gt;&lt;/c16&gt;) used in place of a loop variable causes the individual values to be ignored and does not provide access to the current value during each iteration of the loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ループ変数の代わりに使われるアンダースコア文字（&lt;c16&gt;&lt;s17&gt;_&lt;/s17&gt;&lt;/c16&gt;）は、その個別の値を無視されるようにして、ループの各繰り返しのときにその現在の値へのアクセスを提供しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The unused expression is not evaluated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>使っていない式は、評価されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The unwrapped value of a forced-value expression can be modified, either by mutating the value itself, or by assigning to one of the value’s members.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>強制された値式のアンラップされた値は、値それ自体を変化させることによって、またはその値のメンバーの１つに代入することによってのどちらでも、修正されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The unwrapped value of an optional-chaining expression can be modified, either by mutating the value itself, or by assigning to one of the value’s members.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖のアンラップされた値は、その値自体を変化させることによって、またはその値のメンバーの１つに値に代入することによってのどちらでも修正されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The use of a two-phase initialization process makes initialization safe, while still giving complete flexibility to each class in a class hierarchy.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２段階初期化処理の使用は初期化を安全にします、その一方でさらに、クラス階層において各クラスに完全な柔軟性を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The use of argument labels can allow a function to be called in an expressive, sentence-like manner, while still providing a function body that is readable and clear in intent.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>引数ラベルの使用は、関数が、表現が豊かな、文章のようなやり方で呼び出されることを可能にします、その一方で、依然として読みやすくて意図が明白な関数本文を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The use of the &lt;c0&gt;&lt;s1&gt;required&lt;/s1&gt;&lt;/c0&gt; modifier ensures that you provide an explicit or inherited implementation of the initializer requirement on all subclasses of the conforming class, such that they also conform to the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;required&lt;/s1&gt;&lt;/c0&gt;修飾子の使用は、あなたがある明確なもしくは継承されたイニシャライザ要件の実装を準拠クラスの全てのサブクラス上で、それらもまたそのプロトコルに準拠するように、提供することを確かなものにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The use of trailing closure syntax in the example above neatly encapsulates the closure’s functionality immediately after the function that closure supports, without needing to wrap the entire closure within the &lt;c0&gt;&lt;s1&gt;map(_:)&lt;/s1&gt;&lt;/c0&gt; method’s outer parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例での後付クロージャ構文の使用は、クロージャの機能性をクロージャが手助けする関数の直後に手際よく要約していて、クロージャ全体を&lt;c0&gt;&lt;s1&gt;map(_:)&lt;/s1&gt;&lt;/c0&gt;メソッドの持つ外側の丸括弧の内部に包む必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of &lt;c0&gt;&lt;s1&gt;john.residence&lt;/s1&gt;&lt;/c0&gt; currently contains a valid &lt;c2&gt;&lt;s3&gt;Residence&lt;/s3&gt;&lt;/c2&gt; instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;john.residence&lt;/s1&gt;&lt;/c0&gt;の値は、現在は有効な&lt;c2&gt;&lt;s3&gt;Residence&lt;/s3&gt;&lt;/c2&gt;インスタンスを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of &lt;c0&gt;&lt;s1&gt;multiplier&lt;/s1&gt;&lt;/c0&gt; is also part of a larger expression later in the string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;multiplier&lt;/s1&gt;&lt;/c0&gt;の値は、また、文字列の後半のより大きな式の一部でもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of &lt;c0&gt;&lt;s1&gt;opaqueJoinedTriangles&lt;/s1&gt;&lt;/c0&gt; in this example is the same as &lt;c2&gt;&lt;s3&gt;joinedTriangles&lt;/s3&gt;&lt;/c2&gt; in the generics example in the &lt;a4&gt;&lt;s5&gt;The Problem That Opaque Types Solve&lt;/s5&gt;&lt;/a4&gt; section earlier in this chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例での&lt;c0&gt;&lt;s1&gt;opaqueJoinedTriangles&lt;/s1&gt;&lt;/c0&gt;の値は、この章の前の&lt;a4&gt;&lt;s5&gt;不透明型が解決する問題&lt;/s5&gt;&lt;/a4&gt;節の総称体の例での&lt;c2&gt;&lt;s3&gt;joinedTriangles&lt;/s3&gt;&lt;/c2&gt;と同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of &lt;c11&gt;&lt;s12&gt;a&lt;/s12&gt;&lt;/c11&gt; must not be greater than &lt;c13&gt;&lt;s14&gt;b&lt;/s14&gt;&lt;/c13&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c11&gt;&lt;s12&gt;a&lt;/s12&gt;&lt;/c11&gt;の値は&lt;c13&gt;&lt;s14&gt;b&lt;/s14&gt;&lt;/c13&gt;より大きくてはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of &lt;c4&gt;&lt;s5&gt;invertedBits&lt;/s5&gt;&lt;/c4&gt; is &lt;c6&gt;&lt;s7&gt;11110000&lt;/s7&gt;&lt;/c6&gt;, which is equal to an unsigned decimal value of &lt;c8&gt;&lt;s9&gt;240&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;invertedBits&lt;/s5&gt;&lt;/c4&gt;の値は&lt;c6&gt;&lt;s7&gt;11110000&lt;/s7&gt;&lt;/c6&gt;です、それは、符号なし10進の値の&lt;c8&gt;&lt;s9&gt;240&lt;/s9&gt;&lt;/c8&gt;と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of &lt;c6&gt;&lt;s7&gt;index&lt;/s7&gt;&lt;/c6&gt; is set to the first number in the range (&lt;c8&gt;&lt;s9&gt;1&lt;/s9&gt;&lt;/c8&gt;), and the statements inside the loop are executed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;index&lt;/s7&gt;&lt;/c6&gt;の値は、この範囲の最初の数（&lt;c8&gt;&lt;s9&gt;1&lt;/s9&gt;&lt;/c8&gt;）に設定されます、そしてループの内側の文が実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of a &lt;e8&gt;constant&lt;/e8&gt; can’t be changed once it’s set, whereas a &lt;e9&gt;variable&lt;/e9&gt; can be set to a different value in the future.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e8&gt;定数&lt;/e8&gt;の値は、一旦それが設定されるならば変わることができません、一方で&lt;e9&gt;変数&lt;/e9&gt;は将来異なる値に設定されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of a constant doesn’t need to be known at compile time, but you must assign it a value exactly once.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数の値はコンパイル時に知られている必要はありません、しかしあなたはそれに値を厳密に一度だけ代入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of a dictionary literal has type &lt;c0&gt;&lt;s1&gt;[Key:&lt;/s1&gt; &lt;s2&gt;Value]&lt;/s2&gt;&lt;/c0&gt;, where &lt;c3&gt;&lt;s4&gt;Key&lt;/s4&gt;&lt;/c3&gt; is the type of its key expressions and &lt;c5&gt;&lt;s6&gt;Value&lt;/s6&gt;&lt;/c5&gt; is the type of its value expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書リテラルの値は、型&lt;c0&gt;&lt;s1&gt;[Key:&lt;/s1&gt; &lt;s2&gt;Value]&lt;/s2&gt;&lt;/c0&gt;を持ちます、そこで、&lt;c3&gt;&lt;s4&gt;Key&lt;/s4&gt;&lt;/c3&gt;はそのキーの式の型です、そして、&lt;c5&gt;&lt;s6&gt;Value&lt;/s6&gt;&lt;/c5&gt;はその値の式の型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of a selector expression is an instance of the &lt;c2&gt;&lt;s3&gt;Selector&lt;/s3&gt;&lt;/c2&gt; type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セレクタ式の値は、&lt;c2&gt;&lt;s3&gt;Selector&lt;/s3&gt;&lt;/c2&gt;型のインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of an array literal has type &lt;c0&gt;&lt;s1&gt;[T]&lt;/s1&gt;&lt;/c0&gt;, where &lt;c2&gt;&lt;s3&gt;T&lt;/s3&gt;&lt;/c2&gt; is the type of the expressions inside it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列リテラルの値は型&lt;c0&gt;&lt;s1&gt;[T]&lt;/s1&gt;&lt;/c0&gt;を持ちます、そこで、&lt;c2&gt;&lt;s3&gt;T&lt;/s3&gt;&lt;/c2&gt;はそれの内部の式の型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of an expression can be inserted into a string literal by placing the expression in parentheses after a backslash (&lt;c0&gt;&lt;s1&gt;\&lt;/s1&gt;&lt;/c0&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>式の値は、バックスラッシュ（&lt;c0&gt;&lt;s1&gt;\&lt;/s1&gt;&lt;/c0&gt;）の後の丸括弧の中にその式を置くことによってリテラル文字列に差し込まれることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of any condition in a &lt;c0&gt;&lt;s1&gt;guard&lt;/s1&gt;&lt;/c0&gt; statement must be of type &lt;c2&gt;&lt;s3&gt;Bool&lt;/s3&gt;&lt;/c2&gt; or a type bridged to &lt;c4&gt;&lt;s5&gt;Bool&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;guard&lt;/s1&gt;&lt;/c0&gt;文の中のあらゆる条件の値は、&lt;c2&gt;&lt;s3&gt;Bool&lt;/s3&gt;&lt;/c2&gt;型または&lt;c4&gt;&lt;s5&gt;Bool&lt;/s5&gt;&lt;/c4&gt;にブリッジされる型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of any condition in an &lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt; statement must be of type &lt;c2&gt;&lt;s3&gt;Bool&lt;/s3&gt;&lt;/c2&gt; or a type bridged to &lt;c4&gt;&lt;s5&gt;Bool&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt;文の中のあらゆる条件の値は、&lt;c2&gt;&lt;s3&gt;Bool&lt;/s3&gt;&lt;/c2&gt;型または&lt;c4&gt;&lt;s5&gt;Bool&lt;/s5&gt;&lt;/c4&gt;にブリッジされる型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of the &lt;e0&gt;condition&lt;/e0&gt; must be of type &lt;c1&gt;&lt;s2&gt;Bool&lt;/s2&gt;&lt;/c1&gt; or a type bridged to &lt;c3&gt;&lt;s4&gt;Bool&lt;/s4&gt;&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;condition&lt;/e0&gt;の値は、&lt;c1&gt;&lt;s2&gt;Bool&lt;/s2&gt;&lt;/c1&gt;型または&lt;c3&gt;&lt;s4&gt;Bool&lt;/s4&gt;&lt;/c3&gt;にブリッジされる型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of the &lt;e0&gt;control expression&lt;/e0&gt; can even be matched to the value of a case in an enumeration and checked for inclusion in a specified range of values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;制御式&lt;/e0&gt;の値は、列挙でのケース節の値にさえマッチすることや、指定された範囲の値に包含されるかについて調べさえすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of the &lt;e0&gt;expression&lt;/e0&gt; is set to the value obtained by evaluating the &lt;e1&gt;value&lt;/e1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;式&lt;/e0&gt;の値は、&lt;e1&gt;値&lt;/e1&gt;を評価することによって得られる値に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of the &lt;e0&gt;expression&lt;/e0&gt; must have a type that conforms to the &lt;c1&gt;&lt;s2&gt;Error&lt;/s2&gt;&lt;/c1&gt; protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;expression（式）&lt;/e0&gt;の値は、&lt;c1&gt;&lt;s2&gt;Error&lt;/s2&gt;&lt;/c1&gt;プロトコルに準拠する型を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of these properties cannot be set, and so it is not appropriate to provide a &lt;c0&gt;&lt;s1&gt;willSet&lt;/s1&gt;&lt;/c0&gt; or &lt;c2&gt;&lt;s3&gt;didSet&lt;/s3&gt;&lt;/c2&gt; implementation as part of an override.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのプロパティの値は設定されることができません、なのでオーバーライドの一部として&lt;c0&gt;&lt;s1&gt;willSet&lt;/s1&gt;&lt;/c0&gt;または&lt;c2&gt;&lt;s3&gt;didSet&lt;/s3&gt;&lt;/c2&gt;の実装を提供することは適切ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value returned by a type’s &lt;c8&gt;&lt;s9&gt;hashValue&lt;/s9&gt;&lt;/c8&gt; property is not required to be the same across different executions of the same program, or in different programs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型の&lt;c8&gt;&lt;s9&gt;hashValue&lt;/s9&gt;&lt;/c8&gt;プロパティによって返される値は、同じプログラムの、または異なるプログラムでの、異なる実行にまたがって同じであることを要求されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value that remains within the bounds of the &lt;c14&gt;&lt;s15&gt;UInt8&lt;/s15&gt;&lt;/c14&gt; after the overflow addition is &lt;c16&gt;&lt;s17&gt;00000000&lt;/s17&gt;&lt;/c16&gt;, or zero.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オーバフロー加算の後で&lt;c14&gt;&lt;s15&gt;UInt8&lt;/s15&gt;&lt;/c14&gt;の領域内に残る値は、&lt;c16&gt;&lt;s17&gt;00000000&lt;/s17&gt;&lt;/c16&gt;、またはゼロです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value used in a subscript can be a named value or a literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字の中で使われる値は、名前付きの値またはあるリテラルであることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values defined in an enumeration (such as &lt;c0&gt;&lt;s1&gt;north&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;south&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;east&lt;/s5&gt;&lt;/c4&gt;, and &lt;c6&gt;&lt;s7&gt;west&lt;/s7&gt;&lt;/c6&gt;) are its &lt;e8&gt;enumeration cases&lt;/e8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙で定義される値（例えば&lt;c0&gt;&lt;s1&gt;north&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;south&lt;/s3&gt;&lt;/c2&gt;、&lt;c4&gt;&lt;s5&gt;east&lt;/s5&gt;&lt;/c4&gt;、そして&lt;c6&gt;&lt;s7&gt;west&lt;/s7&gt;&lt;/c6&gt;）は、それの&lt;e8&gt;列挙ケース節&lt;/e8&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values of &lt;c0&gt;&lt;s1&gt;finalSquare&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;board&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;square&lt;/s5&gt;&lt;/c4&gt;, and &lt;c6&gt;&lt;s7&gt;diceRoll&lt;/s7&gt;&lt;/c6&gt; are initialized in the same way as before:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;finalSquare&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;board&lt;/s3&gt;&lt;/c2&gt;、&lt;c4&gt;&lt;s5&gt;square&lt;/s5&gt;&lt;/c4&gt;、そして&lt;c6&gt;&lt;s7&gt;diceRoll&lt;/s7&gt;&lt;/c6&gt;の値は、前と同じように初期化されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values of &lt;c7&gt;&lt;s8&gt;finalSquare&lt;/s8&gt;&lt;/c7&gt;, &lt;c9&gt;&lt;s10&gt;board&lt;/s10&gt;&lt;/c9&gt;, &lt;c11&gt;&lt;s12&gt;square&lt;/s12&gt;&lt;/c11&gt;, and &lt;c13&gt;&lt;s14&gt;diceRoll&lt;/s14&gt;&lt;/c13&gt; are initialized in exactly the same way as with a &lt;c15&gt;&lt;s16&gt;while&lt;/s16&gt;&lt;/c15&gt; loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c7&gt;&lt;s8&gt;finalSquare&lt;/s8&gt;&lt;/c7&gt;、&lt;c9&gt;&lt;s10&gt;board&lt;/s10&gt;&lt;/c9&gt;、&lt;c11&gt;&lt;s12&gt;square&lt;/s12&gt;&lt;/c11&gt;、そして&lt;c13&gt;&lt;s14&gt;diceRoll&lt;/s14&gt;&lt;/c13&gt;の値は、正確に&lt;c15&gt;&lt;s16&gt;while&lt;/s16&gt;&lt;/c15&gt;ループと同じやり方で初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values of a dictionary can be accessed through subscripting by specifying the corresponding key in square brackets: &lt;c0&gt;&lt;s1&gt;someDictionary["Alex"]&lt;/s1&gt;&lt;/c0&gt; refers to the value associated with the key &lt;c2&gt;&lt;s3&gt;"Alex"&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書の値は、角括弧の中に対応するキーを指定することによる添え字指定を通してアクセスされることができます：&lt;c0&gt;&lt;s1&gt;someDictionary["Alex"]&lt;/s1&gt;&lt;/c0&gt;はキー&lt;c2&gt;&lt;s3&gt;"Alex"&lt;/s3&gt;&lt;/c2&gt;と結び付けられた値に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values of expressions your code can branch on are very flexible.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのコードが分岐することができる式の値は、非常に柔軟です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values of the conditions specified in a branch statement control how the program branches and, therefore, what block of code is executed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>分岐文において指定される条件の値は、プログラムがどのように分岐するか、したがって、コードのどのブロックが実行されるかについて制御します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values of these properties are of the appropriate-sized number type (such as &lt;c0&gt;&lt;s1&gt;UInt8&lt;/s1&gt;&lt;/c0&gt; in the example above) and can therefore be used in expressions alongside other values of the same type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのプロパティの値は、適切なサイズの数の型（例えば上の例での&lt;c0&gt;&lt;s1&gt;UInt8&lt;/s1&gt;&lt;/c0&gt;）であり、したがって、式の中で同じ型の他の値と並べて使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values passed to a variadic parameter are made available within the function’s body as an array of the appropriate type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>可変長パラメータに渡される値は、適切な型の配列として、関数の本文内で利用可能にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values that operators affect are &lt;e0&gt;operands&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子が影響を及ぼす値は、&lt;e0&gt;演算数&lt;/e0&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values within a tuple can be of any type and don’t have to be of the same type as each other.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプルの内部の値は、どんな型でもかまいません、そして互いに同じ型である必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The variable &lt;c0&gt;&lt;s1&gt;unsignedOverflow&lt;/s1&gt;&lt;/c0&gt; is initialized with the maximum value a &lt;c2&gt;&lt;s3&gt;UInt8&lt;/s3&gt;&lt;/c2&gt; can hold (&lt;c4&gt;&lt;s5&gt;255&lt;/s5&gt;&lt;/c4&gt;, or &lt;c6&gt;&lt;s7&gt;11111111&lt;/s7&gt;&lt;/c6&gt; in binary).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変数&lt;c0&gt;&lt;s1&gt;unsignedOverflow&lt;/s1&gt;&lt;/c0&gt;は、&lt;c2&gt;&lt;s3&gt;UInt8&lt;/s3&gt;&lt;/c2&gt;が持つことができる最大限の値で初期化されます（&lt;c4&gt;&lt;s5&gt;255&lt;/s5&gt;&lt;/c4&gt;、または２進数での&lt;c6&gt;&lt;s7&gt;11111111&lt;/s7&gt;&lt;/c6&gt;）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The various aspects of your code that can have access control applied to them (properties, types, functions, and so on) are referred to as “entities” in the sections below, for brevity.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらに適用可能なアクセス制御を持つあなたのコードのさまざまな面（プロパティ、型、関数、その他）は、簡潔さのために、下記の節において「実在」として言及されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The version for &lt;c6&gt;&lt;s7&gt;compiler()&lt;/s7&gt;&lt;/c6&gt; is the compiler version, regardless of the Swift version setting passed to the compiler.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;compiler()&lt;/s7&gt;&lt;/c6&gt;に対するバージョンはコンパイラバージョンです、コンパイラに渡されたSwiftバージョン設定に関係なく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The version for &lt;c8&gt;&lt;s9&gt;swift()&lt;/s9&gt;&lt;/c8&gt; is the language version currently being compiled.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c8&gt;&lt;s9&gt;swift()&lt;/s9&gt;&lt;/c8&gt;に対するバージョンは、現在コンパイルされている言語バージョンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The version number for the &lt;c0&gt;&lt;s1&gt;swift()&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;compiler()&lt;/s3&gt;&lt;/c2&gt; platform conditions consists of a major number, optional minor number, optional patch number, and so on, with a dot (&lt;c4&gt;&lt;s5&gt;.&lt;/s5&gt;&lt;/c4&gt;) separating each part of the version number.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;swift()&lt;/s1&gt;&lt;/c0&gt;および&lt;c2&gt;&lt;s3&gt;compiler()&lt;/s3&gt;&lt;/c2&gt;プラットホーム条件のためのバージョン番号は、メジャー番号、随意のマイナー番号、随意のパッチ番号、その他と、バージョン番号の各部を区切っているドット（&lt;c4&gt;&lt;s5&gt;.&lt;/s5&gt;&lt;/c4&gt;）から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The version of &lt;c2&gt;&lt;s3&gt;serve(customer:)&lt;/s3&gt;&lt;/c2&gt; below performs the same operation but, instead of taking an explicit closure, it takes an autoclosure by marking its parameter’s type with the &lt;c4&gt;&lt;s5&gt;@autoclosure&lt;/s5&gt;&lt;/c4&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下のバージョンの&lt;c2&gt;&lt;s3&gt;serve(customer:)&lt;/s3&gt;&lt;/c2&gt;は同じ演算を実行します、しかし明示的なクロージャを取るのではなく、それは自動クロージャを、それのパラメータの型を&lt;c4&gt;&lt;s5&gt;@autoclosure&lt;/s5&gt;&lt;/c4&gt;属性で記することによって取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The video mode is assigned a copy of the HD resolution of &lt;c4&gt;&lt;s5&gt;1920&lt;/s5&gt;&lt;/c4&gt; by &lt;c6&gt;&lt;s7&gt;1080&lt;/s7&gt;&lt;/c6&gt; from before.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ビデオ・モードは、以前にHD解像度&lt;c4&gt;&lt;s5&gt;1920&lt;/s5&gt;&lt;/c4&gt;×&lt;c6&gt;&lt;s7&gt;1080&lt;/s7&gt;&lt;/c6&gt;のコピーを代入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The whitespace around an operator is used to determine whether an operator is used as a prefix operator, a postfix operator, or a binary operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子のまわりの空白は、演算子が接頭辞演算子か、接尾辞演算子か、または二項演算子として使われるかを決定するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The whitespace before the closing quotation marks (&lt;c0&gt;&lt;s1&gt;"""&lt;/s1&gt;&lt;/c0&gt;) tells Swift what whitespace to ignore before all of the other lines.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>終了引用符（&lt;c0&gt;&lt;s1&gt;"""&lt;/s1&gt;&lt;/c0&gt;）の前の空白文字は、他の行すべての前でどの空白文字を無視するかスウィフトに教えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The wrapper is responsible for defining and managing any underlying storage needed by its wrapped value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ラッパーは、それのラップされた値によって必要とされるあらゆる基礎をなすストレージの定義と管理に責任を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The wrapper must define a &lt;c0&gt;&lt;s1&gt;wrappedValue&lt;/s1&gt;&lt;/c0&gt; instance property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ラッパーは、ある&lt;c0&gt;&lt;s1&gt;wrappedValue&lt;/s1&gt;&lt;/c0&gt;インスタンスプロパティを定義しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The wrapper prevents the value of those properties from being larger than 12, and it sets the projected value to &lt;c15&gt;&lt;s16&gt;true&lt;/s16&gt;&lt;/c15&gt;, to record the fact that it adjusted their values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ラッパーは、それらプロパティの値が12より大きくなることを防ぎます、そしてそれは予測値を&lt;c15&gt;&lt;s16&gt;true&lt;/s16&gt;&lt;/c15&gt;に設定します、それがそれらの値を調節したという事実を記録するために。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The write access for an in-out parameter starts after all of the non-in-out parameters have been evaluated and lasts for the entire duration of that function call.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるin-outパラメータに対する書き込みアクセスは、すべての非in-outパラメータが評価された後に始まって、その関数呼び出しの全期間持続します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The zeros in &lt;c4&gt;&lt;s5&gt;0xFF0000&lt;/s5&gt;&lt;/c4&gt; effectively “mask” the second and third bytes of &lt;c6&gt;&lt;s7&gt;0xCC6699&lt;/s7&gt;&lt;/c6&gt;, causing the &lt;c8&gt;&lt;s9&gt;6699&lt;/s9&gt;&lt;/c8&gt; to be ignored and leaving &lt;c10&gt;&lt;s11&gt;0xCC0000&lt;/s11&gt;&lt;/c10&gt; as the result.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;0xFF0000&lt;/s5&gt;&lt;/c4&gt;のゼロは、&lt;c6&gt;&lt;s7&gt;0xCC6699&lt;/s7&gt;&lt;/c6&gt;の２番目と３番目のバイトを効果的に「マスク」します（隠して消します）、そして&lt;c8&gt;&lt;s9&gt;6699&lt;/s9&gt;&lt;/c8&gt;が無視されるようになって、結果として&lt;c10&gt;&lt;s11&gt;0xCC0000&lt;/s11&gt;&lt;/c10&gt;が残ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Their durations overlap.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの期間が重なる（オーバーラップする）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Their primary role is to ensure that new instances of a type are correctly initialized before they are used for the first time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの主要な役割は、ある型の新しいインスタンスが、それらが初めて使われる前に正しく初期化されることを保証することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Their return value is of type &lt;c2&gt;&lt;s3&gt;Double&lt;/s3&gt;&lt;/c2&gt;, and can be used within mathematical calculations wherever a &lt;c4&gt;&lt;s5&gt;Double&lt;/s5&gt;&lt;/c4&gt; is accepted:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの戻り値は&lt;c2&gt;&lt;s3&gt;Double&lt;/s3&gt;&lt;/c2&gt;型です、そして数学計算内の&lt;c4&gt;&lt;s5&gt;Double&lt;/s5&gt;&lt;/c4&gt;が受け入れられるあらゆるところで使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Their syntax is similar to both instance method syntax and computed property syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの構文は、インスタンスメソッド構文と計算プロパティ構文に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Their type is inferred only at the point that they’re evaluated by the compiler.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの型は、それらがコンパイラによって評価される時点においてのみ、推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then, declare a new variable called &lt;c4&gt;&lt;s5&gt;currentLoginAttempt&lt;/s5&gt;&lt;/c4&gt;, and give it an initial value of &lt;c6&gt;&lt;s7&gt;0&lt;/s7&gt;&lt;/c6&gt;.”</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その後で、&lt;c4&gt;&lt;s5&gt;currentLoginAttempt&lt;/s5&gt;&lt;/c4&gt;と呼ばれる新しい変数を宣言して、それに&lt;c6&gt;&lt;s7&gt;0&lt;/s7&gt;&lt;/c6&gt;の初期値を与える。」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are &lt;e8&gt;two&lt;/e8&gt; levels of optional chaining in use here, to chain through the &lt;c9&gt;&lt;s10&gt;residence&lt;/s10&gt;&lt;/c9&gt; and &lt;c11&gt;&lt;s12&gt;address&lt;/s12&gt;&lt;/c11&gt; properties, both of which are of optional type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここで使用されるオプショナル連鎖の&lt;e8&gt;２つの&lt;/e8&gt;階層があります、そして&lt;c9&gt;&lt;s10&gt;residence&lt;/s10&gt;&lt;/c9&gt;と&lt;c11&gt;&lt;s12&gt;addressプ&lt;/s12&gt;&lt;/c11&gt;ロパティを通り抜けて繋げます、その両方ともオプショナル型です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are a number of ways this task can fail, including the file not existing at the specified path, the file not having read permissions, or the file not being encoded in a compatible format.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この作業が失敗するたくさんの道筋があります、そのファイルが指定したパスで存在しない、ファイルが読み出し権限を持っていない、またはファイルが互換性のある形式で符号化されていないことを含めて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are currently three values on the stack.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>現在は３つの値がこのスタックにはあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are four type-casting operators: the &lt;c0&gt;&lt;s1&gt;is&lt;/s1&gt;&lt;/c0&gt; operator, the &lt;c2&gt;&lt;s3&gt;as&lt;/s3&gt;&lt;/c2&gt; operator, the &lt;c4&gt;&lt;s5&gt;as?&lt;/s5&gt;&lt;/c4&gt; operator, and the &lt;c6&gt;&lt;s7&gt;as!&lt;/s7&gt;&lt;/c6&gt; operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>４つの型キャスト演算子、&lt;c0&gt;&lt;s1&gt;is&lt;/s1&gt;&lt;/c0&gt;演算子、&lt;c2&gt;&lt;s3&gt;as&lt;/s3&gt;&lt;/c2&gt;演算子、&lt;c4&gt;&lt;s5&gt;as?&lt;/s5&gt;&lt;/c4&gt;演算子、そして&lt;c6&gt;&lt;s7&gt;as!&lt;/s7&gt;&lt;/c6&gt;演算子があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are four ways to handle errors in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>４つの方法がエラーを取り扱うためにスウィフトにはあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are no further superclasses to initialize, and so no further delegation is needed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期化するための更なるスーパークラスはありません、なので、更なる委任は必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are now &lt;e0&gt;three&lt;/e0&gt; strong references to this single &lt;c1&gt;&lt;s2&gt;Person&lt;/s2&gt;&lt;/c1&gt; instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>現在この１つの&lt;c1&gt;&lt;s2&gt;Person&lt;/s2&gt;&lt;/c1&gt;インスタンスへの&lt;e0&gt;３つ&lt;/e0&gt;の強い参照があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are several special forms that allow closures to be written more concisely:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャをより簡潔に書かれるようにする特別ないくつかの形式があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are several types of control flow statements in Swift, including loop statements, branch statements, and control transfer statements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いくつかの種類の制御の流れ文が、スウィフトにあります、それはループ文、分岐文、そして制御移動文を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are several ways to handle errors.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いくつかの方法がエラーを取り扱うためにはあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are three basic forms of an operator declaration, one for each fixity.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子宣言の基本の書式は、各定着性に対して１つずつ、３つあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are three characteristics of memory access to consider in the context of conflicting access: whether the access is a read or a write, the duration of the access, and the location in memory being accessed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アクセス衝突の文脈において考慮すべき３つのメモリアクセスの特徴があります：アクセスが読み出しか書き込みか、アクセスの期間、そしてメモリの中のアクセスされる位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are three ways to create an instance of a previously declared structure:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以前に宣言された構造体のインスタンスを作成するには３つの方法があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two basic forms of an &lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt; statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt;文の２つの基本の書式があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two cases in which a type identifier doesn’t refer to a type with the same name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型識別子がある型に同じ名前で言及しない２つの場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two compound types: function types and tuple types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つの複合の型：関数型とタプル型があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two different things named &lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt;&lt;/c0&gt;, the variable in the surrounding scope and the constant in the closure’s scope, but only one variable named &lt;c2&gt;&lt;s3&gt;b&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt;&lt;/c0&gt;と名前をつけられる２つの異なるものがあります、囲んでいるスコープにおける変数とクロージャのスコープにおける定数、しかし&lt;c2&gt;&lt;s3&gt;b&lt;/s3&gt;&lt;/c2&gt;と名前をつけられる変数はただひとつのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two kinds of attributes in Swift—those that apply to declarations and those that apply to types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトには２種類の属性があります — 宣言に適用されるもの、そして型に適用されるもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two type-casting patterns, the &lt;c0&gt;&lt;s1&gt;is&lt;/s1&gt;&lt;/c0&gt; pattern and the &lt;c2&gt;&lt;s3&gt;as&lt;/s3&gt;&lt;/c2&gt; pattern.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つの型キャスト・パターン、&lt;c0&gt;&lt;s1&gt;is&lt;/s1&gt;&lt;/c0&gt;パターンと&lt;c2&gt;&lt;s3&gt;as&lt;/s3&gt;&lt;/c2&gt;パターンがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two ways to create an instance of a previously declared class:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以前に宣言されたクラスのインスタンスをつくるには２つの方法があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two ways to implement the &lt;c13&gt;&lt;s14&gt;==&lt;/s14&gt;&lt;/c13&gt; operator: You can implement it yourself, or for many types, you can ask Swift to synthesize an implementation for you.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c13&gt;&lt;s14&gt;==&lt;/s14&gt;&lt;/c13&gt;演算子を実装する２つの方法があります：あなたはそれをあなた自身で実装できます、または多くの型に対して、あなたはスウィフトにある実装をあなたかの代わりに実装するよう頼めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There can only ever be one &lt;c6&gt;&lt;s7&gt;Bank&lt;/s7&gt;&lt;/c6&gt; in the game, and so the &lt;c8&gt;&lt;s9&gt;Bank&lt;/s9&gt;&lt;/c8&gt; is implemented as a class with type properties and methods to store and manage its current state:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>１つの&lt;c6&gt;&lt;s7&gt;Bank&lt;/s7&gt;&lt;/c6&gt;だけがゲームにおいて存在することができます、なので&lt;c8&gt;&lt;s9&gt;Bank&lt;/s9&gt;&lt;/c8&gt;は型プロパティと型メソッドをもつクラスとして実装されて、その現在の状態を格納および管理します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is also a new &lt;c2&gt;&lt;s3&gt;@noescape&lt;/s3&gt;&lt;/c2&gt; parameter declaration attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>また新しい&lt;c2&gt;&lt;s3&gt;@noescape&lt;/s3&gt;&lt;/c2&gt;パラメーター宣言属性もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no requirement for classes to subclass any standard root class, so you can include or omit a superclass as needed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>何らかの標準となるルートクラスのサブクラスであることは、クラスにとって必要条件ではありません、そのためあなたは必要に応じてスーパークラスを含めたり省略したりすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is only one loop in the game, and therefore no ambiguity as to which loop the &lt;c5&gt;&lt;s6&gt;continue&lt;/s6&gt;&lt;/c5&gt; statement will affect.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このゲームにはただ１つのループしかありません、それゆえに&lt;c5&gt;&lt;s6&gt;continue&lt;/s6&gt;&lt;/c5&gt;文が影響を及ぼすループはどれかについての曖昧さもありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There must not be whitespace between the comparison operator and the version number.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>比較演算子とバージョン番号の間に空白があってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There will only ever be one copy of these properties, no matter how many instances of that type you create.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらのプロパティのコピーはただ１つだけ存在することになります、あなたが作るその型のインスタンスがいくらあろうとも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thereafter, the game instantiator has the option to set the property to a suitable delegate.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その後は、このゲームのイニシャライザは、このプロパティを適当な委任先に設定する選択肢を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, &lt;c7&gt;&lt;s8&gt;RecipeIngredient&lt;/s8&gt;&lt;/c7&gt; automatically inherits all of its superclass’s convenience initializers too.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>したがって、&lt;c7&gt;&lt;s8&gt;RecipeIngredient&lt;/s8&gt;&lt;/c7&gt;は自動的にそのスーパークラスの便宜イニシャライザの全てもまた継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, ARC automatically sets a weak reference to &lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt; when the instance that it refers to is deallocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>したがって、ARCは自動的に、弱い参照をそれが言及するインスタンスが割り当て解除されるとき&lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, it is sometimes useful to be explicit about which loop or conditional statement you want a &lt;c2&gt;&lt;s3&gt;break&lt;/s3&gt;&lt;/c2&gt; statement to terminate.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>したがって、あなたが&lt;c2&gt;&lt;s3&gt;break&lt;/s3&gt;&lt;/c2&gt;文に終了して欲しいループまたは条件文はどれかについて明白にすることは、しばしば役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, it’s safe to check for a snake or a ladder as the first action in the loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>したがって、ループでの最初の活動として、ヘビまたははしごについて調べるのは差し支えありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, the names and types of an initializer’s parameters play a particularly important role in identifying which initializer should be called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>したがって、イニシャライザのパラメータの名前と型は、どのイニシャライザが呼ばれなければならないか識別することにおいて特に重要な役割を演じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, the overall access level of the compound tuple type is private (the minimum access level of the tuple’s constituent types).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>したがって、この複合タプル型の全体としてのアクセス水準は非公開です（このタプルの構成要素の型の内の最小のアクセス水準）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, when you break the strong references held by the &lt;c8&gt;&lt;s9&gt;john&lt;/s9&gt;&lt;/c8&gt; and &lt;c10&gt;&lt;s11&gt;unit4A&lt;/s11&gt;&lt;/c10&gt; variables, the reference counts do not drop to zero, and the instances are not deallocated by ARC:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>したがって、あなたが&lt;c8&gt;&lt;s9&gt;john&lt;/s9&gt;&lt;/c8&gt;と&lt;c10&gt;&lt;s11&gt;unit4A&lt;/s11&gt;&lt;/c10&gt;変数によって保持される強い参照を壊すとき、参照総数はゼロに落ちません、なのでインスタンスはARCによって割り当て解除されません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, you can set it to an instance of &lt;e4&gt;any&lt;/e4&gt; type that adopts the &lt;c5&gt;&lt;s6&gt;RandomNumberGenerator&lt;/s6&gt;&lt;/c5&gt; protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>したがって、あなたはそれを&lt;c5&gt;&lt;s6&gt;RandomNumberGenerator&lt;/s6&gt;&lt;/c5&gt;プロトコルを採用する&lt;e4&gt;あらゆる&lt;/e4&gt;型のインスタンスに設定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, you can simply pass in the greater-than operator, and Swift will infer that you want to use its string-specific implementation:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>したがって、あなたはただ単に「大なり」演算子を渡すことができます、そしてスウィフトはあなたがその文字列特有の実装を使いたいのだと推測します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, you don’t need to specify a custom access level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>したがって、あなたはあつらえのアクセス水準を指定する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, you must write the &lt;c1&gt;&lt;s2&gt;override&lt;/s2&gt;&lt;/c1&gt; modifier before the subclass’s initializer definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>したがって、あなたは&lt;c1&gt;&lt;s2&gt;override&lt;/s2&gt;&lt;/c1&gt;修飾子をそのサブクラスのイニシャライザ定義の前に書かなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore, your subclass is not (strictly speaking) providing an override of the superclass initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それゆえに、あなたのサブクラスはスーパークラスのイニシャライザのオーバーライドを（厳密に言えば）提供していません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>したがって：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There’s a write access to &lt;c2&gt;&lt;s3&gt;oscar&lt;/s3&gt;&lt;/c2&gt; during the method call because &lt;c4&gt;&lt;s5&gt;oscar&lt;/s5&gt;&lt;/c4&gt; is the value of &lt;c6&gt;&lt;s7&gt;self&lt;/s7&gt;&lt;/c6&gt; in a mutating method, and there’s a write access to &lt;c8&gt;&lt;s9&gt;maria&lt;/s9&gt;&lt;/c8&gt; for the same duration because &lt;c10&gt;&lt;s11&gt;maria&lt;/s11&gt;&lt;/c10&gt; was passed as an in-out parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;oscar&lt;/s3&gt;&lt;/c2&gt;への書き込みアクセスがメソッド呼び出しの間にあります、なぜなら&lt;c4&gt;&lt;s5&gt;oscar&lt;/s5&gt;&lt;/c4&gt;は変更メソッドの中の&lt;c6&gt;&lt;s7&gt;self&lt;/s7&gt;&lt;/c6&gt;の値であるからです、そして&lt;c8&gt;&lt;s9&gt;maria&lt;/s9&gt;&lt;/c8&gt;への書き込みアクセスが同じ期間にあります、なぜなら&lt;c10&gt;&lt;s11&gt;maria&lt;/s11&gt;&lt;/c10&gt;がin-outパラメータとして渡されたからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There’s actually an even &lt;e0&gt;shorter&lt;/e0&gt; way to write the closure expression above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらに&lt;e0&gt;より短い&lt;/e0&gt;方法が上のクロージャ式を書くために実際にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There’s an even simpler way to include values in strings: Write the value in parentheses, and write a backslash (&lt;c0&gt;&lt;s1&gt;\&lt;/s1&gt;&lt;/c0&gt;) before the parentheses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いろいろな値を文字列の中に含めるさらに単純な方法があります：その値を丸括弧の中に書いてください、そして丸括弧の前にバックスラッシュ（&lt;c0&gt;&lt;s1&gt;\&lt;/s1&gt;&lt;/c0&gt;）を書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There’s no need to shift this to the right, as &lt;c6&gt;&lt;s7&gt;0x000099&lt;/s7&gt;&lt;/c6&gt; already equals &lt;c8&gt;&lt;s9&gt;0x99&lt;/s9&gt;&lt;/c8&gt;, which has a decimal value of &lt;c10&gt;&lt;s11&gt;153&lt;/s11&gt;&lt;/c10&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;0x000099&lt;/s7&gt;&lt;/c6&gt;がすでに&lt;c8&gt;&lt;s9&gt;0x99&lt;/s9&gt;&lt;/c8&gt;に等しいので、これを右へシフトする必要はありません、それは10進の値の&lt;c10&gt;&lt;s11&gt;153&lt;/s11&gt;&lt;/c10&gt;を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There’s nothing stopping you from having a tuple of type &lt;c0&gt;&lt;s1&gt;(Int,&lt;/s1&gt; &lt;s2&gt;Int,&lt;/s2&gt; &lt;s3&gt;Int)&lt;/s3&gt;&lt;/c0&gt;, or &lt;c4&gt;&lt;s5&gt;(String,&lt;/s5&gt; &lt;s6&gt;Bool)&lt;/s6&gt;&lt;/c4&gt;, or indeed any other permutation you require.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが&lt;c0&gt;&lt;s1&gt;(Int,&lt;/s1&gt; &lt;s2&gt;Int,&lt;/s2&gt; &lt;s3&gt;Int)&lt;/s3&gt;&lt;/c0&gt;の型のタプル、または&lt;c4&gt;&lt;s5&gt;(String,&lt;/s5&gt; &lt;s6&gt;Bool)&lt;/s6&gt;&lt;/c4&gt;、またはあなたが実際に必要とするあらゆる他の順列を持つのを止めるものは何もありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There’s one caveat to the rules above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>１つのただし書きが、上の規則にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These &lt;e0&gt;attribute arguments&lt;/e0&gt; are enclosed in parentheses, and their format is defined by the attribute they belong to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの&lt;e0&gt;属性引数&lt;/e0&gt;は丸括弧に囲まれます、そして、それらの形式はそれらが属している属性によって定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These &lt;e1&gt;declarations&lt;/e1&gt; can include both stored and computed properties, instance methods, type methods, initializers, a single deinitializer, subscripts, type aliases, and even other class, structure, and enumeration declarations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの&lt;e1&gt;宣言&lt;/e1&gt;は、格納または計算プロパティの双方、インスタンスメソッド、型メソッド、イニシャライザ、１つだけのデイニシャライザ、添え字、型エイリアス、そして他のクラス、構造体、および列挙宣言さえも含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These &lt;e1&gt;declarations&lt;/e1&gt; can include both stored and computed properties, type properties, instance methods, type methods, initializers, subscripts, type aliases, and even other structure, class, and enumeration declarations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの&lt;e1&gt;宣言&lt;/e1&gt;は、格納または計算プロパティの双方、型プロパティ、インスタンスメソッド、型メソッド、イニシャライザ、添え字、型エイリアス、そして他の構造体、クラス、および列挙宣言さえも含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These &lt;e1&gt;declarations&lt;/e1&gt; can include computed properties, computed type properties, instance methods, type methods, initializers, subscript declarations, and even class, structure, and enumeration declarations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの&lt;e1&gt;宣言&lt;/e1&gt;は、計算プロパティ、計算型プロパティ、インスタンスメソッド、型メソッド、イニシャライザ、添え字宣言、そしてクラス、構造体、そして列挙宣言さえも含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These access levels are relative to the source file in which an entity is defined, and also relative to the module that source file belongs to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのアクセス水準は、ある実在が定義されているソースファイルと関連しています、そのうえに、ソースファイルが属しているモジュールとも関連しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These actions are described in the following sections.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの行いは、以下の節で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are custom classes, structures, and enumerations that can work with &lt;e1&gt;any&lt;/e1&gt; type, in a similar way to &lt;c2&gt;&lt;s3&gt;Array&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;Dictionary&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらは、&lt;e1&gt;Array&lt;/e1&gt;と&lt;c2&gt;&lt;s3&gt;Dictionary&lt;/s3&gt;&lt;/c2&gt;に類似した方法で、&lt;c4&gt;&lt;s5&gt;あらゆる&lt;/s5&gt;&lt;/c4&gt;型で扱うことができる特注のクラス、構造体、そして列挙があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are followed by a check digit to verify that the code has been scanned correctly:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの後にコードが正しくスキャンされたことを確認するための１つの「チェック」桁が続きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are known as constants, and are much more powerful than constants in C. Constants are used throughout Swift to make code safer and clearer in intent when you work with values that don’t need to change.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらは定数として知られています、そしてCにおける定数よりずっと強力です。定数は、変わる必要がない値をあなたが扱う時、コードをより安全により明白にする意図でスウィフトを通して使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are known as designated initializers and convenience initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらは、指定イニシャライザと便宜イニシャライザとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are used as the two input values for the provided math function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらは提供された数学関数のための２つの入力値として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These arguments begin with one of the following platform or language names:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの引数は、以下のプラットホームまたは言語名の１つで始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These attributes are conceptually the same as their Objective-C counterparts.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの属性は、概念的にそれらのObjective-Cでの対応物と同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These changes are allowed on nonfrozen types, but they break ABI compatibility for frozen types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの変更は、非凍結型の上では許可されます、しかしそれらは凍結型に対するABI互換性を破壊します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These classes expand upon the &lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;Residence&lt;/s3&gt;&lt;/c2&gt; model from above by adding a &lt;c4&gt;&lt;s5&gt;Room&lt;/s5&gt;&lt;/c4&gt; and &lt;c6&gt;&lt;s7&gt;Address&lt;/s7&gt;&lt;/c6&gt; class, with associated properties, methods, and subscripts.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのクラスは、関連するプロパティ、メソッド、そして添え字とともに&lt;c4&gt;&lt;s5&gt;Room&lt;/s5&gt;&lt;/c4&gt;と&lt;c6&gt;&lt;s7&gt;Address&lt;/s7&gt;&lt;/c6&gt;クラスを加えることによって、上記の&lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;Residence&lt;/s3&gt;&lt;/c2&gt;モデルを拡張します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These computed properties express that a &lt;c0&gt;&lt;s1&gt;Double&lt;/s1&gt;&lt;/c0&gt; value should be considered as a certain unit of length.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの計算プロパティは、&lt;c0&gt;&lt;s1&gt;Double&lt;/s1&gt;&lt;/c0&gt;値が長さの特定の単位とみなされなければならないことを表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These constants (or variables) can then be referenced in a corresponding &lt;c4&gt;&lt;s5&gt;where&lt;/s5&gt;&lt;/c4&gt; clause and throughout the rest of the code within the scope of the case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの定数（または変数）は、それから対応する&lt;c4&gt;&lt;s5&gt;where&lt;/s5&gt;&lt;/c4&gt;節の中で、そしてそのケース節のスコープ内のその他のコードのいたるところで参照されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These constants are used as part of a &lt;c8&gt;&lt;s9&gt;where&lt;/s9&gt;&lt;/c8&gt; clause, to create a dynamic filter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの定数は、&lt;c8&gt;&lt;s9&gt;where&lt;/s9&gt;&lt;/c8&gt;節の一部として動的なフィルタを作成するために使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These function calls don’t violate the restriction because &lt;c4&gt;&lt;s5&gt;external&lt;/s5&gt;&lt;/c4&gt; isn’t one of the parameters of &lt;c6&gt;&lt;s7&gt;takesTwoFunctions(first:second:)&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの関数呼び出しは制約に違反しません、なぜなら&lt;c4&gt;&lt;s5&gt;external&lt;/s5&gt;&lt;/c4&gt;は&lt;c6&gt;&lt;s7&gt;takesTwoFunctions(first:second:)&lt;/s7&gt;&lt;/c6&gt;のパラメータの１つだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These functions and methods are known as &lt;e2&gt;rethrowing functions&lt;/e2&gt; and &lt;e3&gt;rethrowing methods&lt;/e3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの関数とメソッドは、&lt;e2&gt;再スロー関数&lt;/e2&gt;と&lt;e3&gt;再スローメソッド&lt;/e3&gt;として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These functions and methods are known as &lt;e2&gt;throwing functions&lt;/e2&gt; and &lt;e3&gt;throwing methods&lt;/e3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの関数とメソッドは&lt;e2&gt;スロー関数&lt;/e2&gt;および&lt;e3&gt;スローメソッド&lt;/e3&gt;として知られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These functions each take two &lt;c4&gt;&lt;s5&gt;Int&lt;/s5&gt;&lt;/c4&gt; values, and return an &lt;c6&gt;&lt;s7&gt;Int&lt;/s7&gt;&lt;/c6&gt; value, which is the result of performing an appropriate mathematical operation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの関数は、各々２つの&lt;c4&gt;&lt;s5&gt;Int&lt;/s5&gt;&lt;/c4&gt;値をとって、１つの&lt;c6&gt;&lt;s7&gt;Int&lt;/s7&gt;&lt;/c6&gt;値を返します、そしてそれは、適切な数値演算の実行の結果です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These include &lt;c0&gt;&lt;s1&gt;while&lt;/s1&gt;&lt;/c0&gt; loops to perform a task multiple times; &lt;c2&gt;&lt;s3&gt;if&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;guard&lt;/s5&gt;&lt;/c4&gt;, and &lt;c6&gt;&lt;s7&gt;switch&lt;/s7&gt;&lt;/c6&gt; statements to execute different branches of code based on certain conditions; and statements such as &lt;c8&gt;&lt;s9&gt;break&lt;/s9&gt;&lt;/c8&gt; and &lt;c10&gt;&lt;s11&gt;continue&lt;/s11&gt;&lt;/c10&gt; to transfer the flow of execution to another point in your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらは、ある作業を複数回実行する&lt;c0&gt;&lt;s1&gt;while&lt;/s1&gt;&lt;/c0&gt;ループ；特定の条件に基づいてコードの異なる分岐を実行する&lt;c2&gt;&lt;s3&gt;if&lt;/s3&gt;&lt;/c2&gt;、&lt;c4&gt;&lt;s5&gt;guard&lt;/s5&gt;&lt;/c4&gt;、および&lt;c6&gt;&lt;s7&gt;switch&lt;/s7&gt;&lt;/c6&gt;文；そして実行の流れをあなたのコードの別の地点に移す、&lt;c8&gt;&lt;s9&gt;break&lt;/s9&gt;&lt;/c8&gt;および&lt;c10&gt;&lt;s11&gt;continue&lt;/s11&gt;&lt;/c10&gt;のような文を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These include all of the bitwise and bit shifting operators you will be familiar with from C and Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらは、あなたがCとObjective-Cからお馴染みの、ビット単位およびビットシフト演算子の全てを含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These include enumeration case patterns, optional patterns, expression patterns, and type-casting patterns.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらは、列挙ケース節パターン、オプショナルパターン、式パターン、および型キャストパターンを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These include the UTF-8 encoding form (which encodes a string as 8-bit code units), the UTF-16 encoding form (which encodes a string as 16-bit code units), and the UTF-32 encoding form (which encodes a string as 32-bit code units).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらは、UTF-８符号化方式（それは、８ビット符号単位として文字列を符号化します）、UTF-16符号化方式（それは、16ビット符号単位として文字列を符号化します）、そしてUTF-32符号化方式（それは、32ビット符号単位として文字列を符号化します）を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These include wildcard patterns, identifier patterns, and any value binding or tuple patterns containing them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらはワイルドカード・パターン、識別子パターン、そしてそれらを含むあらゆる値束縛やタプルパターンを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These initialization options are represented by three custom initializers that are part of the &lt;c6&gt;&lt;s7&gt;Rect&lt;/s7&gt;&lt;/c6&gt; structure’s definition:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの初期化オプションは、&lt;c6&gt;&lt;s7&gt;Rect&lt;/s7&gt;&lt;/c6&gt;構造体の定義の一部である３つのあつらえのイニシャライザによって表されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These initializers can be used to create new &lt;c4&gt;&lt;s5&gt;Rect&lt;/s5&gt;&lt;/c4&gt; instances:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのイニシャライザが、新しい&lt;c4&gt;&lt;s5&gt;Rect&lt;/s5&gt;&lt;/c4&gt;例をつくるために使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These integers follow a naming convention similar to C, in that an 8-bit unsigned integer is of type &lt;c0&gt;&lt;s1&gt;UInt8&lt;/s1&gt;&lt;/c0&gt;, and a 32-bit signed integer is of type &lt;c2&gt;&lt;s3&gt;Int32&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの整数は、８ビットの符号なし整数が型&lt;c0&gt;&lt;s1&gt;UInt8&lt;/s1&gt;&lt;/c0&gt;である、そして32ビットの符号つき整数が型&lt;c2&gt;&lt;s3&gt;Int32&lt;/s3&gt;&lt;/c2&gt;であるという点で、Cに似ている命名規則に従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These keywords are described in the sections below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのキーワードは、以下の節で解説されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These kinds of closures or functions typically create a temporary value of the same type as the property, tailor that value to represent the desired initial state, and then return that temporary value to be used as the property’s default value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの種類のクロージャまたは関数は、概してプロパティと同じ型の一時的な値をつくって、望み通りの初期状態を表すようにその値を仕立てて、それからその一時的な値がプロパティの省略時の値として使われるように返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These kinds of loops are best used when the number of iterations is not known before the first iteration begins.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの種類のループが最も使われるのは、繰り返しの回数が最初の繰り返しが始まる前にはわからないときです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These kinds of methods are called &lt;e0&gt;type methods&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの種類のメソッドは、&lt;e0&gt;型メソッド&lt;/e0&gt;と呼ばれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These kinds of optionals are defined as &lt;e0&gt;implicitly unwrapped optionals&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの種類のオプショナルは、&lt;e0&gt;暗黙的にアンラップされるオプショナル&lt;/e0&gt;として定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These kinds of properties are called &lt;e0&gt;type properties&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの種類のプロパティは、&lt;e0&gt;型プロパティ&lt;/e0&gt;と呼ばれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These methods are marked as &lt;c10&gt;&lt;s11&gt;mutating&lt;/s11&gt;&lt;/c10&gt;, because they need to modify (or &lt;e12&gt;mutate&lt;/e12&gt;) the structure’s &lt;c13&gt;&lt;s14&gt;items&lt;/s14&gt;&lt;/c13&gt; array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのメソッドは&lt;c10&gt;&lt;s11&gt;mutating&lt;/s11&gt;&lt;/c10&gt;として印されます、なぜなら、それらが構造体の&lt;c13&gt;&lt;s14&gt;items&lt;/s14&gt;&lt;/c13&gt;配列を修正する（または&lt;e12&gt;変化させる&lt;/e12&gt;）必要があるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These methods are written as part of the protocol’s definition in exactly the same way as for normal instance and type methods, but without curly braces or a method body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのメソッドは、プロトコルの定義の一部として普通のインスタンスおよび型メソッドと正確に同じ方法で書かれます、しかし波括弧またはメソッド本文はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These names are valid identifiers within the scope of the closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの名前は、クロージャのスコープ内で有効な識別子です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These operators all begin with an ampersand (&lt;c1&gt;&lt;s2&gt;&amp;&lt;/s2&gt;&lt;/c1&gt;):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの演算子は、全てアンパサンド（&lt;c1&gt;&lt;s2&gt;&amp;&lt;/s2&gt;&lt;/c1&gt;）で始まります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These operators are now used only with &lt;c10&gt;&lt;s11&gt;String&lt;/s11&gt;&lt;/c10&gt; values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの演算子は今では&lt;c10&gt;&lt;s11&gt;String&lt;/s11&gt;&lt;/c10&gt;値でのみ使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These operators can be used and adopted in your code like any of the predefined operators, and you can even extend existing types to support the custom operators you define.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの演算子は、あらかじめ定義された演算子のどれとも同じように、使用されることができ、あなたのコードにおいて取り入れられることができます、そして、あなたはあなたが定義するカスタム演算子をサポートするように既存の型を拡張することさえ可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These operators can contain additional dots.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの演算子は、さらなるドットを含むことが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These operators have the same associativity and precedence as the logical operators that are used to combine ordinary Boolean expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの演算子は、普通のブール式を組み合わせるのに使われる論理演算子と同じ結合性と優先順位を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These optimizations include:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの最適化は、以下を含みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These options are described later in this chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの選択肢は、この章の後刻に記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These overrides ensure that an &lt;c8&gt;&lt;s9&gt;AutomaticallyNamedDocument&lt;/s9&gt;&lt;/c8&gt; instance has an initial &lt;c10&gt;&lt;s11&gt;name&lt;/s11&gt;&lt;/c10&gt; value of &lt;c12&gt;&lt;s13&gt;"[Untitled]"&lt;/s13&gt;&lt;/c12&gt; if the instance is initialized without a name, or if an empty string is passed to the &lt;c14&gt;&lt;s15&gt;init(name:)&lt;/s15&gt;&lt;/c14&gt; initializer:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのオーバーライドは、&lt;c8&gt;&lt;s9&gt;AutomaticallyNamedDocument&lt;/s9&gt;&lt;/c8&gt;インスタンスが、そのインスタンスが名前なしで初期化されるならば、または空の文字列が&lt;c14&gt;&lt;s15&gt;init(name:)&lt;/s15&gt;&lt;/c14&gt;イニシャライザに渡されるならば、初期&lt;c10&gt;&lt;s11&gt;name&lt;/s11&gt;&lt;/c10&gt;値の&lt;c12&gt;&lt;s13&gt;"[Untitled]"&lt;/s13&gt;&lt;/c12&gt;を持つことを確実にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These pairings are written within a pair of square braces, separated by commas.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの組合せは、一対の角括弧内に書かれて、コンマで区切られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These properties are read-only computed properties, and so they are expressed without the &lt;c0&gt;&lt;s1&gt;get&lt;/s1&gt;&lt;/c0&gt; keyword, for brevity.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのプロパティは、読み出し専用の計算プロパティです、それでそれらは簡潔さのために、&lt;c0&gt;&lt;s1&gt;get&lt;/s1&gt;&lt;/c0&gt;キーワードなしで表わされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These properties store a value between &lt;c8&gt;&lt;s9&gt;0.0&lt;/s9&gt;&lt;/c8&gt; and &lt;c10&gt;&lt;s11&gt;1.0&lt;/s11&gt;&lt;/c10&gt; to indicate the amount of red, green, and blue in the color.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのプロパティは、&lt;c8&gt;&lt;s9&gt;0.0&lt;/s9&gt;&lt;/c8&gt;と&lt;c10&gt;&lt;s11&gt;1.0&lt;/s11&gt;&lt;/c10&gt;の間の値を格納して、その色における赤、緑、および青の量を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These requirements define two different ways for data sources to provide an appropriate increment amount for a &lt;c6&gt;&lt;s7&gt;Counter&lt;/s7&gt;&lt;/c6&gt; instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの要件は、データ・ソースのために&lt;c6&gt;&lt;s7&gt;Counter&lt;/s7&gt;&lt;/c6&gt;インスタンスに適切な増加量を用意する２つの異なる方法を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These requirements don’t have to be implemented by types that conform to the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの要件は、そのプロトコルに準拠する型によって実装される必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These requirements enable the &lt;c0&gt;&lt;s1&gt;allItemsMatch(_:_:)&lt;/s1&gt;&lt;/c0&gt; function to compare the two containers, even if they’re of a different container type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの要件は、&lt;c0&gt;&lt;s1&gt;allItemsMatch(_:_:)&lt;/s1&gt;&lt;/c0&gt;関数に２つのコンテナを比較するのを可能にします、たとえそれらが異なるコンテナ型であるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These requirements mean:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの要件が意味するのは：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These responsibilities are described in &lt;a2&gt;&lt;s3&gt;Class Inheritance and Initialization&lt;/s3&gt;&lt;/a2&gt; below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの責任は、下記の&lt;a2&gt;&lt;s3&gt;クラス継承と初期化&lt;/s3&gt;&lt;/a2&gt;で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These rules apply even if your subclass adds further convenience initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの規則は、たとえあなたのサブクラスが更なる便宜イニシャライザを加えるとしてもあてはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These rules are illustrated in the figure below:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの規則は、下の図で説明されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These rules don’t affect how users of your classes &lt;e0&gt;create&lt;/e0&gt; instances of each class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの規則は、あなたのクラスのユーザーが各クラスのインスタンスを&lt;e0&gt;作成する&lt;/e0&gt;方法に影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These situations are discussed in the sections below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの状況は、以下の節で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These statements are indicated by the &lt;c7&gt;&lt;s8&gt;else&lt;/s8&gt;&lt;/c7&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの文は、&lt;c7&gt;&lt;s8&gt;else&lt;/s8&gt;&lt;/c7&gt;キーワードによって指し示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These three capabilities match the requirements of the &lt;c8&gt;&lt;s9&gt;Container&lt;/s9&gt;&lt;/c8&gt; protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの３つの能力は、&lt;c8&gt;&lt;s9&gt;Container&lt;/s9&gt;&lt;/c8&gt;プロトコルの要件に合致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These three methods have been incorporated into the game logic within the &lt;c2&gt;&lt;s3&gt;play()&lt;/s3&gt;&lt;/c2&gt; method above, and are called when a new game starts, a new turn begins, or the game ends.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの３つのメソッドは、上の&lt;c2&gt;&lt;s3&gt;play()&lt;/s3&gt;&lt;/c2&gt;メソッド内のゲーム論理に組み込まれています、そして、新しいゲームが始まるとき、新しいターンを開始するとき、あるいはこのゲームが終わるとき、呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These tokens can’t be overloaded, nor can they be used as custom operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのトークンは、オーバーロードされることができませんし、それらはあつらえの演算子として使われることもできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These two classes each store an instance of the other class as a property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの２つのクラスは、それぞれ他のクラスのインスタンスをプロパティとして格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These two operators provide a simple and expressive way to check the type of a value or cast a value to a different type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの２つの演算子は、値の型を調べたり、値を異なる型にキャストする（配役する、投げ込む）ための単純で表現豊かな方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These two properties are inferred to be of type &lt;c6&gt;&lt;s7&gt;Int&lt;/s7&gt;&lt;/c6&gt; by setting them to an initial integer value of &lt;c8&gt;&lt;s9&gt;0&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの２つのプロパティは、それらを最初の整数値&lt;c8&gt;&lt;s9&gt;0&lt;/s9&gt;&lt;/c8&gt;に設定することによって型&lt;c6&gt;&lt;s7&gt;Int&lt;/s7&gt;&lt;/c6&gt;であると推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These two statements call the subscript’s setter to set a value of &lt;c0&gt;&lt;s1&gt;1.5&lt;/s1&gt;&lt;/c0&gt; in the top right position of the matrix (where &lt;c2&gt;&lt;s3&gt;row&lt;/s3&gt;&lt;/c2&gt; is &lt;c4&gt;&lt;s5&gt;0&lt;/s5&gt;&lt;/c4&gt; and &lt;c6&gt;&lt;s7&gt;column&lt;/s7&gt;&lt;/c6&gt; is &lt;c8&gt;&lt;s9&gt;1&lt;/s9&gt;&lt;/c8&gt;), and &lt;c10&gt;&lt;s11&gt;3.2&lt;/s11&gt;&lt;/c10&gt; in the bottom left position (where &lt;c12&gt;&lt;s13&gt;row&lt;/s13&gt;&lt;/c12&gt; is &lt;c14&gt;&lt;s15&gt;1&lt;/s15&gt;&lt;/c14&gt; and &lt;c16&gt;&lt;s17&gt;column&lt;/s17&gt;&lt;/c16&gt; is &lt;c18&gt;&lt;s19&gt;0&lt;/s19&gt;&lt;/c18&gt;):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの２つの文は、添え字のセッターを呼び出して、この行列の右上位置（&lt;c2&gt;&lt;s3&gt;row&lt;/s3&gt;&lt;/c2&gt;が&lt;c4&gt;&lt;s5&gt;0&lt;/s5&gt;&lt;/c4&gt;で&lt;c6&gt;&lt;s7&gt;column&lt;/s7&gt;&lt;/c6&gt;が&lt;c8&gt;&lt;s9&gt;1&lt;/s9&gt;&lt;/c8&gt;のところ）に&lt;c0&gt;&lt;s1&gt;1.5&lt;/s1&gt;&lt;/c0&gt;の値を、そして左下位置（&lt;c12&gt;&lt;s13&gt;row&lt;/s13&gt;&lt;/c12&gt;が&lt;c14&gt;&lt;s15&gt;1&lt;/s15&gt;&lt;/c14&gt;で&lt;c16&gt;&lt;s17&gt;column&lt;/s17&gt;&lt;/c16&gt;が&lt;c18&gt;&lt;s19&gt;0&lt;/s19&gt;&lt;/c18&gt;のところ）に&lt;c10&gt;&lt;s11&gt;3.2&lt;/s11&gt;&lt;/c10&gt;を設定します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These type parameters act as placeholders that are replaced by actual concrete type arguments when an instance of a generic type is created or a generic function or initializer is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの型パラメータは、総称体型のインスタンスがつくられる、あるいは、総称体の関数やイニシャライザが呼ばれるとき、実際の具象型引数と取り替えられるプレースホルダの働きをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These types are not the same as &lt;c27&gt;&lt;s28&gt;()&lt;/s28&gt; &lt;s29&gt;-&gt;&lt;/s29&gt; &lt;s30&gt;()&lt;/s30&gt;&lt;/c27&gt;—a function that takes no arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの型は、&lt;c27&gt;&lt;s28&gt;()&lt;/s28&gt; &lt;s29&gt;-&gt;&lt;/s29&gt; &lt;s30&gt;()&lt;/s30&gt;&lt;/c27&gt; — 引数を取らない関数、と同じではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These types are specified in the &lt;e2&gt;associated value types&lt;/e2&gt; tuple, immediately following the name of the case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの型は、ケース節の名前の直後に、それら&lt;e2&gt;関連値型&lt;/e2&gt;のタプルを使って指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These valid tokens form the lowest-level building blocks of the language and are used to describe the rest of the language in subsequent chapters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの公式のトークンは、言語の最も基本的な建物ブロックを形成して、以降の章において言語の残りの部分を記述するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These values are a high-surrogate value of &lt;c9&gt;&lt;s10&gt;U+D83D&lt;/s10&gt;&lt;/c9&gt; (decimal value &lt;c11&gt;&lt;s12&gt;55357&lt;/s12&gt;&lt;/c11&gt;) and a low-surrogate value of &lt;c13&gt;&lt;s14&gt;U+DC36&lt;/s14&gt;&lt;/c13&gt; (decimal value &lt;c15&gt;&lt;s16&gt;56374&lt;/s16&gt;&lt;/c15&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの値は、前半代用値の&lt;c9&gt;&lt;s10&gt;U+D83D&lt;/s10&gt;&lt;/c9&gt;（10進の値&lt;c11&gt;&lt;s12&gt;55357&lt;/s12&gt;&lt;/c11&gt;）と後半代用値の&lt;c13&gt;&lt;s14&gt;U+DC36&lt;/s14&gt;&lt;/c13&gt;（10進の値&lt;c15&gt;&lt;s16&gt;56374&lt;/s16&gt;&lt;/c15&gt;）です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These values are labeled &lt;c4&gt;&lt;s5&gt;min&lt;/s5&gt;&lt;/c4&gt; and &lt;c6&gt;&lt;s7&gt;max&lt;/s7&gt;&lt;/c6&gt; so that they can be accessed by name when querying the function’s return value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの値は、&lt;c4&gt;&lt;s5&gt;min&lt;/s5&gt;&lt;/c4&gt;および&lt;c6&gt;&lt;s7&gt;max&lt;/s7&gt;&lt;/c6&gt;とラベルをつけられます、なのでそれらはこの関数の戻り値について問い合わせるときに名前によってアクセスされることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These values are represented as optionals.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このような値は、オプショナルであるとして表現されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These variations on function syntax are discussed below in &lt;a2&gt;&lt;s3&gt;Function Argument Labels and Parameter Names&lt;/s3&gt;&lt;/a2&gt; and &lt;a4&gt;&lt;s5&gt;Default Parameter Values&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数構文上のこれらの差異は、&lt;a2&gt;&lt;s3&gt;関数の引数ラベルとパラメータ名&lt;/s3&gt;&lt;/a2&gt;と&lt;a4&gt;&lt;s5&gt;省略時のパラメータ値&lt;/s5&gt;&lt;/a4&gt;の下で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They access the same location in memory.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらがメモリ中の同じ位置にアクセスする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They adopt many features traditionally supported only by classes, such as computed properties to provide additional information about the enumeration’s current value, and instance methods to provide functionality related to the values the enumeration represents.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらはクラスによってのみ伝統的に支えられる多くの特徴を採用します、例えば列挙の現在の値に関する追加の情報を提供する計算プロパティ、そして、列挙が表す値に関連した機能性を提供するインスタンスメソッドなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are &lt;e1&gt;prefix&lt;/e1&gt; if they precede their target (such as &lt;c2&gt;&lt;s3&gt;-a&lt;/s3&gt;&lt;/c2&gt;) and &lt;e4&gt;postfix&lt;/e4&gt; operators if they follow their target (such as &lt;c5&gt;&lt;s6&gt;b!&lt;/s6&gt;&lt;/c5&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらは、それがその目標に先行するならば&lt;e1&gt;接頭辞&lt;/e1&gt;（例えば&lt;c2&gt;&lt;s3&gt;-a&lt;/s3&gt;&lt;/c2&gt;）、それがその目標の後に続くならば&lt;e4&gt;接尾辞&lt;/e4&gt;演算子です（例えば&lt;c5&gt;&lt;s6&gt;b!&lt;/s6&gt;&lt;/c5&gt;）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are guaranteed to be initialized only once, even when accessed by multiple threads simultaneously, and they do not need to be marked with the &lt;c0&gt;&lt;s1&gt;lazy&lt;/s1&gt;&lt;/c0&gt; modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらは、ただ１度だけ初期化されることを保証されます、複数のスレッドによって同時にアクセスされる場合でさえもです、そしてそれらは&lt;c0&gt;&lt;s1&gt;lazy&lt;/s1&gt;&lt;/c0&gt;修飾子で印されることを必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are not called while a class is setting its own properties, before the superclass initializer has been called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらは、スーパークラスイニシャライザが呼び出され終わる前、あるクラスがそれ自身のプロパティを設定している間には呼び出されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are often used in low-level programming, such as graphics programming and device driver creation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらが、低階層のプログラミング、例えばグラフィックス・プログラミングやデバイスドライバー作成において、しばしば使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are stored by subtracting their absolute value from &lt;c0&gt;&lt;s1&gt;2&lt;/s1&gt;&lt;/c0&gt; to the power of &lt;c2&gt;&lt;s3&gt;n&lt;/s3&gt;&lt;/c2&gt;, where &lt;c4&gt;&lt;s5&gt;n&lt;/s5&gt;&lt;/c4&gt; is the number of value bits.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらは、&lt;c0&gt;&lt;s1&gt;2&lt;/s1&gt;&lt;/c0&gt;の&lt;c2&gt;&lt;s3&gt;n&lt;/s3&gt;&lt;/c2&gt;乗からそれらの絶対値を減ずることによって格納されます、そこで、&lt;c4&gt;&lt;s5&gt;n&lt;/s5&gt;&lt;/c4&gt;は値ビットの数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They can be used as expressions on their own, and they can be combined with other tokens to make prefix expressions, binary expressions, and postfix expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらはそれら自身で式として使われることができます、そしてそれらは接頭辞式、二項式、そして接尾辞式を作るために別のトークンと組み合わされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They can’t be added together directly, because they’re not of the same type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらは直接にひとつに加算されることができません、それらが同じ型でないためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They can’t be adopted by structures or enumerations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは構造体や列挙によって採用されることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They continue to be a &lt;c0&gt;&lt;s1&gt;Circle&lt;/s1&gt;&lt;/c0&gt;, a &lt;c2&gt;&lt;s3&gt;Country&lt;/s3&gt;&lt;/c2&gt; and an &lt;c4&gt;&lt;s5&gt;Animal&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらは、&lt;c0&gt;&lt;s1&gt;Circle&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;Country&lt;/s3&gt;&lt;/c2&gt;、そして&lt;c4&gt;&lt;s5&gt;Animal&lt;/s5&gt;&lt;/c4&gt;であり続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They could prefer one mark every &lt;c0&gt;&lt;s1&gt;5&lt;/s1&gt;&lt;/c0&gt; minutes instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>彼らは、代わりに&lt;c0&gt;&lt;s1&gt;5&lt;/s1&gt;&lt;/c0&gt;分毎に１つの印を選ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They have the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらは以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They must always explicitly declare their adoption of the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらは、常に明示的にそのプロトコルについてそれらが採用することを宣言しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They must always have a number (or hexadecimal number) on both sides of the decimal point.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらは、常に小数点の両側で数（または16進の数）を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They must have a set value before first use.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは最初に使用される前に値を設定される必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They support the functionality of those instances, either by providing ways to access and modify instance properties, or by providing functionality related to the instance’s purpose.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは、そういったもののインスタンスの機能性を、インスタンスプロパティにアクセスしたり修正したりする方法を提供することで、またはインスタンスの目的と関連がある機能性を提供することでのどちらかで支えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They themselves don’t describe a specific resolution or video mode.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらはそれら自体で、特定の解像度またはビデオ・モードを記述しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They’re both optional, after all.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>結局、それらは両方ともオプショナルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They’re not suited to the creation of complex data structures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらは、複雑なデータ構造物の作成には適していません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Think of it as meaning “they associate with the expression to their left,” or “they associate with the expression to their right.”</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それは「それらは、式をそれらの左と結びつける」あるいは「それらは、式をそれらの右と結びつける」を意味すると考えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Think of this as adding implicit parentheses around these parts of the expression, starting from their left:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これを、これらの式部分のまわりに、暗黙の括弧をそれらの左から開始して加えることと考えてみてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; statement does not have a &lt;c2&gt;&lt;s3&gt;default&lt;/s3&gt;&lt;/c2&gt; case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;文には&lt;c2&gt;&lt;s3&gt;default&lt;/s3&gt;&lt;/c2&gt;ケース節がない点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This &lt;c2&gt;&lt;s3&gt;Player&lt;/s3&gt;&lt;/c2&gt; instance is stored in an optional &lt;c4&gt;&lt;s5&gt;Player&lt;/s5&gt;&lt;/c4&gt; variable called &lt;c6&gt;&lt;s7&gt;playerOne&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この&lt;c2&gt;&lt;s3&gt;Player&lt;/s3&gt;&lt;/c2&gt;インスタンスは、&lt;c6&gt;&lt;s7&gt;playerOne&lt;/s7&gt;&lt;/c6&gt;と呼ばれるオプショナルの&lt;c4&gt;&lt;s5&gt;Player&lt;/s5&gt;&lt;/c4&gt;変数に格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This &lt;c4&gt;&lt;s5&gt;default&lt;/s5&gt;&lt;/c4&gt; case does not need to perform any action, and so it is written with a single &lt;c6&gt;&lt;s7&gt;break&lt;/s7&gt;&lt;/c6&gt; statement as its body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この&lt;c4&gt;&lt;s5&gt;default&lt;/s5&gt;&lt;/c4&gt;ケース節はいかなる動作も実行する必要がありません、なのでそれはその本文として&lt;c6&gt;&lt;s7&gt;break&lt;/s7&gt;&lt;/c6&gt;文ひとつだけを書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This action ensures that signed integers have the same sign after they are shifted to the right, and is known as an &lt;e0&gt;arithmetic shift&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この動作は、符号つき整数が、それが右へシフトされた後に同じサインを持つことを確実にします、そして&lt;e0&gt;算術シフト&lt;/e0&gt;として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This additional information is called an &lt;e2&gt;associated value&lt;/e2&gt;, and it varies each time you use that case as a value in your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この追加的情報は、&lt;e2&gt;関連値&lt;/e2&gt;と呼ばれます、そしてそれは、あなたがそのケース節をある値としてあなたのコードにおいて使うたびに変化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This aids code consistency and interoperability.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、コードの整合性と相互運用性を支援します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows you to define behavior on protocols themselves, rather than in each type’s individual conformance or in a global function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはあなたに、それぞれの型の個々の準拠においてまたはグローバル関数においてではなく、プロトコルそれ自体に振る舞いを定義することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This also means that if you assign a closure to two different constants or variables, both of those constants or variables refer to the same closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはまた、あなたがクロージャを２つの異なる定数または変数に代入するならば、それらの定数または変数の両方とも同じクロージャに言及することを意味するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This approach assumes that the method’s caller knows there’s a special value to test against and remembers to check for it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このアプローチは、メソッドの呼び出し側が試験するべき特別な値があるのを知っていて、それについて調べるのを忘れないでいると仮定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This approach avoids accidental fallthrough from one case to another and makes for safer code that is clearer in its intent.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この取り組み方は、１つのケース節から他のものへの思いがけない抜け落ちを防止してより安全なコード、その意図するところがより明白であること、に寄与します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This approach avoids confusion about how the value is accessed in different contexts and simplifies the property’s declaration into a single, definitive statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この取り組み方は、値が異なる文脈においてアクセスされる方法についての混乱を避け、プロパティの宣言をただ１つの、決定的な文に単純化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This approach is different from string mutation in Objective-C and Cocoa, where you choose between two classes (&lt;c0&gt;&lt;s1&gt;NSString&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;NSMutableString&lt;/s3&gt;&lt;/c2&gt;) to indicate whether a string can be mutated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この取り組みは、Objective-Cとココアでの文字列変化と異なります、そこでは、あなたは文字列が変化することができるかどうか示すために、２つのクラス（&lt;c0&gt;&lt;s1&gt;NSString&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;NSMutableString&lt;/s3&gt;&lt;/c2&gt;）のどちらかを選びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This approach is known as a &lt;e0&gt;logical shift&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このやり方は、&lt;e0&gt;論理シフト&lt;/e0&gt;として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This approach to defining a &lt;c0&gt;&lt;s1&gt;JoinedShape&lt;T:&lt;/s1&gt; &lt;s2&gt;Shape,&lt;/s2&gt; &lt;s3&gt;U:&lt;/s3&gt; &lt;s4&gt;Shape&gt;&lt;/s4&gt;&lt;/c0&gt; structure that joins two shapes together vertically, like the code below shows, results in types like &lt;c5&gt;&lt;s6&gt;JoinedShape&lt;FlippedShape&lt;Triangle&gt;,&lt;/s6&gt; &lt;s7&gt;Triangle&gt;&lt;/s7&gt;&lt;/c5&gt; from joining a flipped triangle with another triangle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つの形状を一緒に垂直につなぐ&lt;c0&gt;&lt;s1&gt;JoinedShape&lt;T:&lt;/s1&gt; &lt;s2&gt;Shape,&lt;/s2&gt; &lt;s3&gt;U:&lt;/s3&gt; &lt;s4&gt;Shape&gt;&lt;/s4&gt;&lt;/c0&gt;構造体を定義するこの取り組みは、下のコードが示すように、裏返した三角を別の三角とつなぐことから&lt;c5&gt;&lt;s6&gt;JoinedShape&lt;FlippedShape&lt;Triangle&gt;,&lt;/s6&gt; &lt;s7&gt;Triangle&gt;&lt;/s7&gt;&lt;/c5&gt;のような型という結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This argument can’t be used when specifying Swift version availability.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この引数は、スウィフトバージョン利用可能性を指定する時に使われることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This assumption is demonstrated by the use of &lt;c4&gt;&lt;s5&gt;count&lt;/s5&gt;&lt;/c4&gt; (rather than &lt;c6&gt;&lt;s7&gt;self.count&lt;/s7&gt;&lt;/c6&gt;) inside the three instance methods for &lt;c8&gt;&lt;s9&gt;Counter&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この仮定は、&lt;c8&gt;&lt;s9&gt;Counter&lt;/s9&gt;&lt;/c8&gt;のための３つのインスタンスメソッド内部での（&lt;c6&gt;&lt;s7&gt;self.count&lt;/s7&gt;&lt;/c6&gt;ではなく）&lt;c4&gt;&lt;s5&gt;count&lt;/s5&gt;&lt;/c4&gt;の使用によって示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This attribute can’t be applied to declarations that are nested inside functions or to &lt;c0&gt;&lt;s1&gt;fileprivate&lt;/s1&gt;&lt;/c0&gt; or &lt;c2&gt;&lt;s3&gt;private&lt;/s3&gt;&lt;/c2&gt; declarations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性は、関数の内部に入れ子にされる宣言に、または&lt;c0&gt;&lt;s1&gt;fileprivate&lt;/s1&gt;&lt;/c0&gt;や&lt;c2&gt;&lt;s3&gt;private&lt;/s3&gt;&lt;/c2&gt;宣言に適用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This attribute causes the property’s setter to be synthesized with a &lt;e0&gt;copy&lt;/e0&gt; of the property’s value—returned by the &lt;c1&gt;&lt;s2&gt;copyWithZone(_:)&lt;/s2&gt;&lt;/c1&gt; method—instead of the value of the property itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性は、プロパティのセッターがそのプロパティの値の&lt;e0&gt;コピー&lt;/e0&gt; ― &lt;c1&gt;&lt;s2&gt;copyWithZone(_:)&lt;/s2&gt;&lt;/c1&gt;メソッドによって返されるもの ― を使って合成されるようにします、プロパティそれ自体の値ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This attribute is allowed only when compiling in library evolution mode.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性は、ライブラリ進化モードでコンパイルしている場合にのみ許可されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This attribute is inferred for any class that inherits from &lt;c0&gt;&lt;s1&gt;NSManagedObject&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性は、&lt;c0&gt;&lt;s1&gt;NSManagedObject&lt;/s1&gt;&lt;/c0&gt;から継承されるあらゆるクラスに対して伴われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This avoids implicitly conforming to the parent protocol twice with different requirements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、その親プロトコルに対する異なる要件での二重の暗黙的準拠を回避します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This base class declares a stored property called &lt;c2&gt;&lt;s3&gt;numberOfWheels&lt;/s3&gt;&lt;/c2&gt;, with a default &lt;c4&gt;&lt;s5&gt;Int&lt;/s5&gt;&lt;/c4&gt; value of &lt;c6&gt;&lt;s7&gt;0&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この基盤クラスは&lt;c2&gt;&lt;s3&gt;numberOfWheels&lt;/s3&gt;&lt;/c2&gt;と呼ばれる格納プロパティを、省略時の値として&lt;c4&gt;&lt;s5&gt;Int&lt;/s5&gt;&lt;/c4&gt;値&lt;c6&gt;&lt;s7&gt;0&lt;/s7&gt;&lt;/c6&gt;を使って、宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This base class defines a stored property called &lt;c2&gt;&lt;s3&gt;currentSpeed&lt;/s3&gt;&lt;/c2&gt;, with a default value of &lt;c4&gt;&lt;s5&gt;0.0&lt;/s5&gt;&lt;/c4&gt; (inferring a property type of &lt;c6&gt;&lt;s7&gt;Double&lt;/s7&gt;&lt;/c6&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この基盤クラスは、&lt;c2&gt;&lt;s3&gt;currentSpeed&lt;/s3&gt;&lt;/c2&gt;と呼ばれる格納プロパティを定義します、それは&lt;c4&gt;&lt;s5&gt;0.0&lt;/s5&gt;&lt;/c4&gt;の省略時の値を持ちます（&lt;c6&gt;&lt;s7&gt;Double&lt;/s7&gt;&lt;/c6&gt;の型のプロパティと推論されます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior can be used to match and ignore one or more cases in a &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この挙動は、&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;文の１つ以上のケース節を適合してから無視することのために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior gives extra safety when you work with numbers that are too large or too small.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この挙動は、あまりに大きいかあまりに小さい数をあなたが扱うとき、追加の安全を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior is communicated by a getter and setter in the same way as for computed properties:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この挙動は、計算プロパティに関してと同様に、ゲッターとセッターによって伝えられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior is different from other types, where a public type definition implies an access level of internal for the type’s members.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この挙動は他の型とは異なります、そこにおいて、公開型定義は、その型のメンバーに対して内部アクセス水準を暗黙的に意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior is due to structures being &lt;e0&gt;value types&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この挙動は、この構造体が&lt;e0&gt;値型&lt;/e0&gt;であるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior is known as &lt;e0&gt;copy-in copy-out&lt;/e0&gt; or &lt;e1&gt;call by value result&lt;/e1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この挙動は、&lt;e0&gt;コピーイン・コピーアウト&lt;/e0&gt;または&lt;e1&gt;結果値による呼び出し&lt;/e1&gt;として知られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior is known as &lt;e2&gt;value binding&lt;/e2&gt;, because the values are bound to temporary constants or variables within the case’s body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この挙動は&lt;e2&gt;値束縛&lt;/e2&gt;として知られています、なぜなら値がそのケース節の本文内の一時的な定数または変数に束縛（バインド）されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior is referred to as &lt;e0&gt;longest match&lt;/e0&gt; or &lt;e1&gt;maximal munch&lt;/e1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この挙動は、&lt;e0&gt;最長マッチ&lt;/e0&gt;または&lt;e1&gt;欲張り捕獲&lt;/e1&gt;と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior is summarized in the following rules:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この挙動は、以下の規則において要約されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior means you can use extensions in the same way to organize your code, whether or not your types have private entities.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この挙動は、あなたの型が非公開な実在を持つかどうかにかかわらず、あなたが拡張を同じ方法で使ってあなたのコードを編成できるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior prevents the reference from becoming part of a strong reference cycle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この挙動は、参照が強い参照循環の一部になるのを妨げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This behavior removes the need for the array bounds check seen in the &lt;c25&gt;&lt;s26&gt;while&lt;/s26&gt;&lt;/c25&gt; loop version of the game described earlier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この挙動は、前に記述された&lt;c25&gt;&lt;s26&gt;while&lt;/s26&gt;&lt;/c25&gt;ループ版のゲームで見られた配列の境界検査の必要を取り除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This book describes Swift 5.2, the default version of Swift that’s included in Xcode 11.4.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この本はSwift 5.2、Xcode 11.4に含まれるスウィフトの初期状態のバージョン、を記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This calculation yields the final answer of &lt;c0&gt;&lt;s1&gt;17&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この計算は、最終的な答えの&lt;c0&gt;&lt;s1&gt;17&lt;/s1&gt;&lt;/c0&gt;を生みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This call to the &lt;c0&gt;&lt;s1&gt;insert(_:at:)&lt;/s1&gt;&lt;/c0&gt; method inserts a new item with a value of &lt;c2&gt;&lt;s3&gt;"Maple&lt;/s3&gt; &lt;s4&gt;Syrup"&lt;/s4&gt;&lt;/c2&gt; at the very beginning of the shopping list, indicated by an index of &lt;c5&gt;&lt;s6&gt;0&lt;/s6&gt;&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;insert(_:at:)&lt;/s1&gt;&lt;/c0&gt;メソッドへのこの呼び出しは、&lt;c2&gt;&lt;s3&gt;"Maple&lt;/s3&gt; &lt;s4&gt;Syrup"&lt;/s4&gt;&lt;/c2&gt;の値をもつ新しい項目を、&lt;c5&gt;&lt;s6&gt;0&lt;/s6&gt;&lt;/c5&gt;のインデックスによって指し示される、買い物リストのまさしくその開始位置で差し入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be read as:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、次のように解釈されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can happen if two class instances hold a strong reference to each other, such that each instance keeps the other alive.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つのクラスインスタンスが強い参照にお互いを守らせるならば、これは起こることができます、各インスタンスが他を生かしておくようなものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This capture might occur because the closure’s body accesses a property of the instance, such as &lt;c0&gt;&lt;s1&gt;self.someProperty&lt;/s1&gt;&lt;/c0&gt;, or because the closure calls a method on the instance, such as &lt;c2&gt;&lt;s3&gt;self.someMethod()&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この捕獲は、例えば&lt;c0&gt;&lt;s1&gt;self.someProperty&lt;/s1&gt;&lt;/c0&gt;のようにクロージャの本文がインスタンスのプロパティにアクセスするために、または例えば&lt;c2&gt;&lt;s3&gt;self.someMethod()&lt;/s3&gt;&lt;/c2&gt;のようにクロージャがインスタンスのメソッドを呼ぶために起こるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This chapter describes parameters and arguments for generic types, functions, and initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この章は、総称体の型、関数、そしてイニシャライザに対するパラメータと引数を記載します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This chapter describes the common operators in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この章は、スウィフトの通常の演算子を記載します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This chapter describes those situations and shows how you enable ARC to manage all of your app’s memory.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この章は、それらの状況を記載して、あなたがどのようにARCにあなたのアプリのメモリの全てを管理させるかについて示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This chapter discusses the types defined in the Swift language itself and describes the type inference behavior of Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この章は、スウィフト言語それ自身によって定義される型を議論して、スウィフトの型推論挙動を記載します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This chapter now focuses more on the addition of new functionality in a subclass, and the modification of existing functionality with overrides.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この章は、今やサブクラスにおける追加された新しい機能性、そしてオーバーライドを使った既存の機能性の変更にもっと焦点を当てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This character can be represented as a single code unit in UTF-16.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この文字は、UTF-16において単一の符号単位で表わされることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This check ensures that your overriding definition is correct.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この調査は、あなたのオーバーライドの定義が正しいことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This class has four variable stored properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このクラスは、４つの変数の格納プロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This class has three optional properties of type &lt;c2&gt;&lt;s3&gt;String?&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このクラスは、型&lt;c2&gt;&lt;s3&gt;String?&lt;/s3&gt;&lt;/c2&gt;の３つのオプショナルのプロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This class implements a pseudorandom number generator algorithm known as a &lt;e2&gt;linear congruential generator&lt;/e2&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このクラスは、&lt;e2&gt;線形合同法生成器&lt;/e2&gt;として知られている擬似乱数生成器アルゴリズムを実装します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This class implements the &lt;c0&gt;&lt;s1&gt;fullName&lt;/s1&gt;&lt;/c0&gt; property requirement as a computed read-only property for a starship.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このクラスは、&lt;c0&gt;&lt;s1&gt;fullName&lt;/s1&gt;&lt;/c0&gt;プロパティ要件をある宇宙船のための読み出し専用の計算プロパティとして実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This class might be used with input data from a pedometer or other step counter to keep track of a person’s exercise during their daily routine.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このクラスは、万歩計または他の歩数計からの入力データとともに、ある個人の日課の運動の経過を追うために使われるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This class models a document that can be initialized with a &lt;c2&gt;&lt;s3&gt;name&lt;/s3&gt;&lt;/c2&gt; property that is either a nonempty string value or &lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;, but cannot be an empty string:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このクラスはある書類をモデル化します、それは空でない文字列か&lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;のどちらかである&lt;c2&gt;&lt;s3&gt;name&lt;/s3&gt;&lt;/c2&gt;プロパティで初期化されることができます、しかし空の文字列であることはできません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This class provides basic functionality for any kind of item that appears in a digital media library.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このクラスは、基本の機能性をデジタル・メディア図書館に現れるあらゆる種類の項目のために用意します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This code can be read as:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このコードは、次のように解釈されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This code uses optional chaining in a key path to access a property of an optional string:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このコードは、オプショナル連鎖をキーパスの中で使うことで、あるオプショナル文字列に属するプロパティにアクセスします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This code uses the key path expression &lt;c1&gt;&lt;s2&gt;\OuterStructure.outer.someValue&lt;/s2&gt;&lt;/c1&gt; to access the &lt;c3&gt;&lt;s4&gt;someValue&lt;/s4&gt;&lt;/c3&gt; property of the &lt;c5&gt;&lt;s6&gt;OuterStructure&lt;/s6&gt;&lt;/c5&gt; type’s &lt;c7&gt;&lt;s8&gt;outer&lt;/s8&gt;&lt;/c7&gt; property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このコードは、キーパス式&lt;c1&gt;&lt;s2&gt;\OuterStructure.outer.someValue&lt;/s2&gt;&lt;/c1&gt;を使って、&lt;c3&gt;&lt;s4&gt;someValue&lt;/s4&gt;&lt;/c3&gt;プロパティにアクセスします、そのプロパティは&lt;c5&gt;&lt;s6&gt;OuterStructure&lt;/s6&gt;&lt;/c5&gt;型の持つ&lt;c7&gt;&lt;s8&gt;outer&lt;/s8&gt;&lt;/c7&gt;プロパティに属しています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This color is then decomposed into its red (&lt;c8&gt;&lt;s9&gt;CC&lt;/s9&gt;&lt;/c8&gt;), green (&lt;c10&gt;&lt;s11&gt;66&lt;/s11&gt;&lt;/c10&gt;), and blue (&lt;c12&gt;&lt;s13&gt;99&lt;/s13&gt;&lt;/c12&gt;) components by the bitwise AND operator (&lt;c14&gt;&lt;s15&gt;&amp;&lt;/s15&gt;&lt;/c14&gt;) and the bitwise right shift operator (&lt;c16&gt;&lt;s17&gt;&gt;&gt;&lt;/s17&gt;&lt;/c16&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この色はそれから、ビット単位の論理積演算子（&lt;c14&gt;&lt;s15&gt;&amp;&lt;/s15&gt;&lt;/c14&gt;）とビット単位の右シフト演算子（&lt;c16&gt;&lt;s17&gt;&gt;&gt;&lt;/s17&gt;&lt;/c16&gt;）によって、それの赤（&lt;c8&gt;&lt;s9&gt;CC&lt;/s9&gt;&lt;/c8&gt;）、緑（&lt;c10&gt;&lt;s11&gt;66&lt;/s11&gt;&lt;/c10&gt;）、そして青（&lt;c12&gt;&lt;s13&gt;99&lt;/s13&gt;&lt;/c12&gt;）の構成要素に分解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This combination results in a compile-time error that the declaration has been renamed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この連携は、宣言が改名されてしまっているというコンパイル時エラーという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This computed property considers the rank of the card and initializes a new &lt;c6&gt;&lt;s7&gt;Values&lt;/s7&gt;&lt;/c6&gt; instance with appropriate values based on its rank.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この計算プロパティは、カードの等級を考慮して、その等級に基づいた適切な値で新しい&lt;c6&gt;&lt;s7&gt;Values&lt;/s7&gt;&lt;/c6&gt;インスタンスを初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This condition tests whether it’s possible to import the module, but doesn’t actually import it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この条件は、そのモジュールがインポート可能であるかどうかをテストします、しかし実際にそれをインポートはしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This confirms that initialization has taken place.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、初期化が起こったことを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This constraint ensures that each element of the sequence is equatable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この制約はシーケンスの各要素が同等比較可能であることを保証します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This constraint prevents a situation in which additional essential setup provided in a more complex initializer is accidentally circumvented by someone using one of the automatic initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この制約は、あるより複雑なイニシャライザにおいて提供される追加の重要な準備が、自動的なイニシャライザのうちの１つを使う何かによって図らずも回避される状況を防ぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This continues up the class inheritance chain until the top of the chain is reached.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、クラス継承連鎖を上って、その連鎖の最上部に着くまで続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This convenience initializer assumes a quantity of &lt;c7&gt;&lt;s8&gt;1&lt;/s8&gt;&lt;/c7&gt; for any &lt;c9&gt;&lt;s10&gt;RecipeIngredient&lt;/s10&gt;&lt;/c9&gt; instance that is created without an explicit quantity.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この便宜イニシャライザは、はっきりした量なしで作成されるあらゆる&lt;c9&gt;&lt;s10&gt;RecipeIngredient&lt;/s10&gt;&lt;/c9&gt;インスタンスに対して数量&lt;c7&gt;&lt;s8&gt;1&lt;/s8&gt;&lt;/c7&gt;を仮定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This convenience initializer cannot yet modify any properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この便宜イニシャライザは、まだどのプロパティも修正することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This convenience initializer simply delegates across to the class’s designated initializer, passing in a &lt;c15&gt;&lt;s16&gt;quantity&lt;/s16&gt;&lt;/c15&gt; value of &lt;c17&gt;&lt;s18&gt;1&lt;/s18&gt;&lt;/c17&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この便宜イニシャライザはそのクラスの指定イニシャライザに、単純に&lt;c15&gt;&lt;s16&gt;quantity&lt;/s16&gt;&lt;/c15&gt;に値&lt;c17&gt;&lt;s18&gt;1&lt;/s18&gt;&lt;/c17&gt;を渡して横に委任します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This creates a new instance of the class or structure, with any properties initialized to their default values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、クラスまたは構造体の新しいインスタンスをつくり、どんなプロパティでもそれらの省略時の値に初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This data source is defined by the &lt;c2&gt;&lt;s3&gt;CounterDataSource&lt;/s3&gt;&lt;/c2&gt; protocol, which has two optional requirements:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このデータ・ソースは&lt;c2&gt;&lt;s3&gt;CounterDataSource&lt;/s3&gt;&lt;/c2&gt;プロトコルによって定義されます、それは、２つのオプショナルの要件を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This default case is indicated by the &lt;c5&gt;&lt;s6&gt;default&lt;/s6&gt;&lt;/c5&gt; keyword, and must always appear last.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>defaultケース節は、キーワード&lt;c5&gt;&lt;s6&gt;default&lt;/s6&gt;&lt;/c5&gt;によって示されて、常に最後に現れなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This definition doesn’t provide any actual &lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt; or &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt; values—it just defines the &lt;e4&gt;type&lt;/e4&gt; of associated values that &lt;c5&gt;&lt;s6&gt;Barcode&lt;/s6&gt;&lt;/c5&gt; constants and variables can store when they are equal to &lt;c7&gt;&lt;s8&gt;Barcode.upc&lt;/s8&gt;&lt;/c7&gt; or &lt;c9&gt;&lt;s10&gt;Barcode.qrCode&lt;/s10&gt;&lt;/c9&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この定義は、何ら実際の&lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt;または&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;値を提供しません ― それは、ただ単に関連値の&lt;e4&gt;型&lt;/e4&gt;を定義します、それは、&lt;c5&gt;&lt;s6&gt;Barcode&lt;/s6&gt;&lt;/c5&gt;定数と変数が&lt;c7&gt;&lt;s8&gt;Barcode.upc&lt;/s8&gt;&lt;/c7&gt;もしくは&lt;c9&gt;&lt;s10&gt;Barcode.qrCode&lt;/s10&gt;&lt;/c9&gt;に等しいときに格納できる型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This definition indicates that a getter-setter block can consist of a getter clause followed by an optional setter clause, enclosed in braces, &lt;e0&gt;or&lt;/e0&gt; a setter clause followed by a getter clause, enclosed in braces.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この定義は、１つのゲッターセッター・ブロックが、１つのゲッター節とそれに続く任意の１つのセッター節、それを波括弧でくくったもの、&lt;e0&gt;または&lt;/e0&gt;、１つのゲッター節に１つのセッター節を続けて波括弧でくくったものから成ることができることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This definition of multiple subscripts is known as &lt;e0&gt;subscript overloading&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この複数の添え字の定義は、&lt;e0&gt;添え字オーバーロード&lt;/e0&gt;として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This design pattern is implemented by defining a protocol that encapsulates the delegated responsibilities, such that a conforming type (known as a delegate) is guaranteed to provide the functionality that has been delegated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このデザイン・パターンは、委任された責務をカプセル化するプロトコルを定義することによって実装されます、例えば、委任プロトコルに拠準する型が（代表、委任先として知られるものが）その委任されている機能性を提供する責任を負わされるといったこと。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This designated initializer matches a designated initializer from the superclass of &lt;c4&gt;&lt;s5&gt;Bicycle&lt;/s5&gt;&lt;/c4&gt;, and so the &lt;c6&gt;&lt;s7&gt;Bicycle&lt;/s7&gt;&lt;/c6&gt; version of this initializer is marked with the &lt;c8&gt;&lt;s9&gt;override&lt;/s9&gt;&lt;/c8&gt; modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この指定イニシャライザは&lt;c4&gt;&lt;s5&gt;Bicycle&lt;/s5&gt;&lt;/c4&gt;のスーパークラスでのある指定イニシャライザと一致します、なのでこのイニシャライザの&lt;c6&gt;&lt;s7&gt;Bicycle&lt;/s7&gt;&lt;/c6&gt;改変板は&lt;c8&gt;&lt;s9&gt;override&lt;/s9&gt;&lt;/c8&gt;修飾子で印されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This dictionary literal contains two &lt;c0&gt;&lt;s1&gt;String:&lt;/s1&gt; &lt;s2&gt;String&lt;/s2&gt;&lt;/c0&gt; pairs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この辞書リテラルは、&lt;c0&gt;&lt;s1&gt;String:&lt;/s1&gt; &lt;s2&gt;String&lt;/s2&gt;&lt;/c0&gt;の組みを２つ含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This distinction is not visible when the captured variable’s type has reference semantics.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この相違は、キャプチャされた変数の型が参照意味論を持つ場合には見られません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This does not, however, cause the observer to be called again.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、しかし、このオブザーバーが再び呼び出されるようにしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This empty protocol indicates that a type can be used for error handling.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この空のプロトコルは、ある型がエラー処理のために使われることができるのを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables &lt;c10&gt;&lt;s11&gt;TrackedString&lt;/s11&gt;&lt;/c10&gt; to modify the &lt;c12&gt;&lt;s13&gt;numberOfEdits&lt;/s13&gt;&lt;/c12&gt; property internally, but to present the property as a read-only property when it’s used outside the structure’s definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これが&lt;c10&gt;&lt;s11&gt;TrackedString&lt;/s11&gt;&lt;/c10&gt;に可能にするのは、&lt;c12&gt;&lt;s13&gt;numberOfEdits&lt;/s13&gt;&lt;/c12&gt;プロパティを内部のように修正すること、しかしそのプロパティをそれが構造体の定義の外側で使われる時は読み出し専用プロパティとして提供することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables &lt;c2&gt;&lt;s3&gt;printMathResult(_:_:_:)&lt;/s3&gt;&lt;/c2&gt; to hand off some of its functionality to the caller of the function in a type-safe way.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、&lt;c2&gt;&lt;s3&gt;printMathResult(_:_:_:)&lt;/s3&gt;&lt;/c2&gt;にその機能性の一部をその関数の呼び出し手に、ある型安全な方法で、手渡すことを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables both properties to be accessed directly (without optional unwrapping) once initialization is complete, while still avoiding a reference cycle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、一旦初期化が終了しているならば、両方のプロパティが直接にアクセスされるのを（オプショナルをアンラップすることなく）可能にします、その一方で、依然として参照循環を避けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables structures and enumerations to adopt the protocol and satisfy that method requirement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、構造体と列挙に、そのプロトコルを採用してメソッド要件を満たすのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables you to be notified when the value of an inherited property changes, regardless of how that property was originally implemented.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはあなたに、そのプロパティが元々どのように実装されるかに関係なく、継承されたプロパティの値が変わるとき通知されることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables you to catch and fix errors as early as possible in the development process.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたに開発過程においてエラーをできるだけ早く捕えて修復するのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables you to check for a successful downcast.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたに成功したダウンキャストについて調べるのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables you to check for their existence within the closure’s body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはあなたに、クロージャの本文内でそれらの存在について調べることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables you to check whether or not an update took place.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはあなたに、更新が起こったかどうか、確認することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables you to create protocols that can only be adopted within a certain access context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたに特定のアクセス文脈内で採用されることだけができるプロトコルを作成するのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables you to define a subclass for which initialization cannot fail, even though initialization of the superclass is allowed to fail.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはあなたに、それに対しての初期化が失敗することが出来ないサブクラスを定義することを可能にします、たとえスーパークラスの初期化が失敗することが許されるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables you to drill down into subproperties within complex models of interrelated types, and to check whether it is possible to access properties, methods, and subscripts on those subproperties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはあなたに、相互に関係づけられた型である複雑なモデルの内部の下位情報に掘り下げていくこと、そしてそれらの下位情報上でプロパティ、メソッド、そして添え字にアクセスすることが可能であるかどうか確認することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables you to extend other types to accept your own custom types as initializer parameters, or to provide additional initialization options that were not included as part of the type’s original implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたに別の型を拡張してあなた独自のあつらえの型をイニシャライザパラメータとして受け入れるようにすること、またはその型の最初の実装の一部として含まれなかった追加の初期化選択肢を提供することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables you to leave some aspects of a function’s implementation for the function’s caller to provide when the function is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはあなたに、ある関数の実装のいくつかの側面をその関数の呼び出し側のために、その関数が呼ばれるとき提供する目的で、取っておくことを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables you to see whether instances of &lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;Apartment&lt;/s3&gt;&lt;/c2&gt; are being deallocated as expected.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたに期待されるように&lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;Apartment&lt;/s3&gt;&lt;/c2&gt;のインスタンスが割り当て解除されているかどうか知ることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enables you to use an &lt;c4&gt;&lt;s5&gt;if&lt;/s5&gt;&lt;/c4&gt; statement to check whether it was possible to call the &lt;c6&gt;&lt;s7&gt;printNumberOfRooms()&lt;/s7&gt;&lt;/c6&gt; method, even though the method does not itself define a return value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはあなたに&lt;c4&gt;&lt;s5&gt;if&lt;/s5&gt;&lt;/c4&gt;文を&lt;c6&gt;&lt;s7&gt;printNumberOfRooms()&lt;/s7&gt;&lt;/c6&gt;メソッドを呼び出すことが可能か調べるために使うことを可能にします、たとえそのメソッドがそれ自身では戻り値を定義しないとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This encoding for negative numbers is known as a &lt;e0&gt;two’s complement&lt;/e0&gt; representation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この負数のための符号化は、&lt;e0&gt;２の補数&lt;/e0&gt;表現として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This ensures that a &lt;c9&gt;&lt;s10&gt;CreditCard&lt;/s10&gt;&lt;/c9&gt; instance always has a &lt;c11&gt;&lt;s12&gt;customer&lt;/s12&gt;&lt;/c11&gt; instance associated with it when the &lt;c13&gt;&lt;s14&gt;CreditCard&lt;/s14&gt;&lt;/c13&gt; instance is created.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、&lt;c9&gt;&lt;s10&gt;CreditCard&lt;/s10&gt;&lt;/c9&gt;インスタンスがつくられるとき、&lt;c13&gt;&lt;s14&gt;CreditCard&lt;/s14&gt;&lt;/c13&gt;インスタンスが常にそれと結びつけられる&lt;c11&gt;&lt;s12&gt;Customer&lt;/s12&gt;&lt;/c11&gt;インスタンスを持つことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This ensures that all of the protocol’s requirements will be visible on any type that adopts the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、プロトコルを採用するあらゆる型上で、プロトコルのもつ要件の全てが見えることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This ensures that class instances do not take up space in memory when they are no longer needed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、クラスインスタンスが、それらがもはや必要でない時に、メモリ上で場所を取らないことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This ensures that the &lt;c10&gt;&lt;s11&gt;numberOfWheels&lt;/s11&gt;&lt;/c10&gt; inherited property is initialized by &lt;c12&gt;&lt;s13&gt;Vehicle&lt;/s13&gt;&lt;/c12&gt; before &lt;c14&gt;&lt;s15&gt;Bicycle&lt;/s15&gt;&lt;/c14&gt; has the opportunity to modify the property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは継承されたプロパティ&lt;c10&gt;&lt;s11&gt;numberOfWheels&lt;/s11&gt;&lt;/c10&gt;が、&lt;c14&gt;&lt;s15&gt;Bicycle&lt;/s15&gt;&lt;/c14&gt;がそのプロパティを変更する機会を得る前に、&lt;c12&gt;&lt;s13&gt;Vehicle&lt;/s13&gt;&lt;/c12&gt;によってイニシャライズされることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This ensures that the indices in the sequence are the same type as the indices used for a container.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、このシーケンスのインデックスがコンテナに対して使われるインデックスと同じ型であるのを保証することになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This ensures that, no matter which part of the compound case matched, the code in the body of the case can always access a value for the bindings and that the value always has the same type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、たとえ複合ケース節のどの部分がマッチしたとしても、ケース節の本文のコードが常に束縛のための値にアクセスできること、そしてその値が常に同じ型を持つことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enumeration can store three kinds of arithmetic expressions: a plain number, the addition of two expressions, and the multiplication of two expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この列挙は、３種類の算術式：普通の数字、２つの式の加算、そして２つの式の乗算を格納することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enumeration toggles between two states, indicated by the enumeration cases &lt;c2&gt;&lt;s3&gt;on&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;off&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この列挙は、列挙のケース節&lt;c2&gt;&lt;s3&gt;on&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;off&lt;/s5&gt;&lt;/c4&gt;で示される、２つの状態の間で切替えをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This enumeration, called &lt;c2&gt;&lt;s3&gt;Kind&lt;/s3&gt;&lt;/c2&gt;, expresses the kind of number that a particular integer represents.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この列挙は、&lt;c2&gt;&lt;s3&gt;Kind&lt;/s3&gt;&lt;/c2&gt;と呼ばれ、特定の整数を表わす数の種類を表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This exactly matches the method type needed by the &lt;c9&gt;&lt;s10&gt;sorted(by:)&lt;/s10&gt;&lt;/c9&gt; method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、&lt;c9&gt;&lt;s10&gt;sorted(by:)&lt;/s10&gt;&lt;/c9&gt;メソッドによって必要とされるメソッド型に正確に適合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example adds a new nested enumeration to &lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、新しい入れ子にされた列挙を&lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt;に加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example adds an &lt;c0&gt;&lt;s1&gt;average()&lt;/s1&gt;&lt;/c0&gt; method to containers whose &lt;c2&gt;&lt;s3&gt;Item&lt;/s3&gt;&lt;/c2&gt; type is &lt;c4&gt;&lt;s5&gt;Double&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、&lt;c0&gt;&lt;s1&gt;average()&lt;/s1&gt;&lt;/c0&gt;メソッドを、&lt;c2&gt;&lt;s3&gt;Item&lt;/s3&gt;&lt;/c2&gt;型が&lt;c4&gt;&lt;s5&gt;Double&lt;/s5&gt;&lt;/c4&gt;であるコンテナに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example adds an integer subscript to Swift’s built-in &lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt; type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、整数添え字をスウィフトの組み込みの&lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt;型に加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example adds five computed instance properties to Swift’s built-in &lt;c0&gt;&lt;s1&gt;Double&lt;/s1&gt;&lt;/c0&gt; type, to provide basic support for working with distance units:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、５つの計算インスタンスプロパティをスウィフトの組み込みの&lt;c0&gt;&lt;s1&gt;Double&lt;/s1&gt;&lt;/c0&gt;型に加えて、距離単位を扱うための基本的な支持を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example adds together the vectors &lt;c0&gt;&lt;s1&gt;(3.0,&lt;/s1&gt; &lt;s2&gt;1.0)&lt;/s2&gt;&lt;/c0&gt; and &lt;c3&gt;&lt;s4&gt;(2.0,&lt;/s4&gt; &lt;s5&gt;4.0)&lt;/s5&gt;&lt;/c3&gt; to make the vector &lt;c6&gt;&lt;s7&gt;(5.0,&lt;/s7&gt; &lt;s8&gt;5.0)&lt;/s8&gt;&lt;/c6&gt;, as illustrated below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、下で図示されるように、ベクトル&lt;c0&gt;&lt;s1&gt;(3.0,&lt;/s1&gt; &lt;s2&gt;1.0)&lt;/s2&gt;&lt;/c0&gt;と&lt;c3&gt;&lt;s4&gt;(2.0,&lt;/s4&gt; &lt;s5&gt;4.0)&lt;/s5&gt;&lt;/c3&gt;を加えて一緒にして、ベクトル&lt;c6&gt;&lt;s7&gt;(5.0,&lt;/s7&gt; &lt;s8&gt;5.0)&lt;/s8&gt;&lt;/c6&gt;を作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example also adds a new computed instance property to &lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt;, called &lt;c2&gt;&lt;s3&gt;kind&lt;/s3&gt;&lt;/c2&gt;, which returns the appropriate &lt;c4&gt;&lt;s5&gt;Kind&lt;/s5&gt;&lt;/c4&gt; enumeration case for that integer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例はまた、新しい計算インスタンスプロパティを&lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt;に加えます、それは、&lt;c2&gt;&lt;s3&gt;kind&lt;/s3&gt;&lt;/c2&gt;と呼ばれ、その整数に対する適切な&lt;c4&gt;&lt;s5&gt;Kind&lt;/s5&gt;&lt;/c4&gt;列挙ケース節を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example also demonstrates a challenge you may encounter when fixing conflicting access to memory: There are sometimes multiple ways to fix the conflict that produce different answers, and it’s not always obvious which answer is correct.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例はまた、メモリアクセスの衝突を直す場合にあなたが直面するある困難を実演します；時として複数の方法が衝突を修正するために存在してそれらは異なる答えを生み出します、そしてどの答えが正しいか必ずしも明確ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example also shows how reference types can be harder to reason about.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例はまた、どれくらい参照型について思考するのが困難になりうるかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example checks &lt;c0&gt;&lt;s1&gt;numberSymbol&lt;/s1&gt;&lt;/c0&gt; to determine whether it is a Latin, Arabic, Chinese, or Thai symbol for the numbers &lt;c2&gt;&lt;s3&gt;1&lt;/s3&gt;&lt;/c2&gt; to &lt;c4&gt;&lt;s5&gt;4&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、&lt;c0&gt;&lt;s1&gt;numberSymbol&lt;/s1&gt;&lt;/c0&gt;を、それが&lt;c2&gt;&lt;s3&gt;1&lt;/s3&gt;&lt;/c2&gt;から&lt;c4&gt;&lt;s5&gt;4&lt;/s5&gt;&lt;/c4&gt;のラテン、アラビア語、中国語、またはタイ語であるかどうか明らかにするために調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example considers two &lt;c0&gt;&lt;s1&gt;Bool&lt;/s1&gt;&lt;/c0&gt; values and only allows access if both values are &lt;c2&gt;&lt;s3&gt;true&lt;/s3&gt;&lt;/c2&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、２つの&lt;c0&gt;&lt;s1&gt;Bool&lt;/s1&gt;&lt;/c0&gt;値を考慮して、両方の値が&lt;c2&gt;&lt;s3&gt;true&lt;/s3&gt;&lt;/c2&gt;の場合にのみアクセスを許します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example creates a new variable called &lt;c0&gt;&lt;s1&gt;productBarcode&lt;/s1&gt;&lt;/c0&gt; and assigns it a value of &lt;c2&gt;&lt;s3&gt;Barcode.upc&lt;/s3&gt;&lt;/c2&gt; with an associated tuple value of &lt;c4&gt;&lt;s5&gt;(8,&lt;/s5&gt; &lt;s6&gt;85909,&lt;/s6&gt; &lt;s7&gt;51226,&lt;/s7&gt; &lt;s8&gt;3)&lt;/s8&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、&lt;c0&gt;&lt;s1&gt;productBarcode&lt;/s1&gt;&lt;/c0&gt;と呼ばれる新しい変数をつくって、それにあるひとつの&lt;c2&gt;&lt;s3&gt;Barcode.upc&lt;/s3&gt;&lt;/c2&gt;の値を関連したタプル値&lt;c4&gt;&lt;s5&gt;(8,&lt;/s5&gt; &lt;s6&gt;85909,&lt;/s6&gt; &lt;s7&gt;51226,&lt;/s7&gt; &lt;s8&gt;3)&lt;/s8&gt;&lt;/c4&gt;とともに代入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example creates an array of &lt;c2&gt;&lt;s3&gt;TextRepresentable&lt;/s3&gt;&lt;/c2&gt; things:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、&lt;c2&gt;&lt;s3&gt;TextRepresentable&lt;/s3&gt;&lt;/c2&gt;なものの配列をつくります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example creates an empty dictionary of type &lt;c0&gt;&lt;s1&gt;[Int:&lt;/s1&gt; &lt;s2&gt;String]&lt;/s2&gt;&lt;/c0&gt; to store human-readable names of integer values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、型&lt;c0&gt;&lt;s1&gt;[Int:&lt;/s1&gt; &lt;s2&gt;String]&lt;/s2&gt;&lt;/c0&gt;の空の辞書を、整数値の人間の読み込み可能な名前を格納するために作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example declares a constant called &lt;c0&gt;&lt;s1&gt;hd&lt;/s1&gt;&lt;/c0&gt; and sets it to a &lt;c2&gt;&lt;s3&gt;Resolution&lt;/s3&gt;&lt;/c2&gt; instance initialized with the width and height of full HD video (1920 pixels wide by 1080 pixels high).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、&lt;c0&gt;&lt;s1&gt;hd&lt;/s1&gt;&lt;/c0&gt;と呼ばれる定数を宣言して、それをフルHDビデオの幅と高さ（1920ピクセル幅の広さで1080ピクセルの高さ）で初期化される&lt;c2&gt;&lt;s3&gt;Resolution&lt;/s3&gt;&lt;/c2&gt;インスタンスに対して設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example declares a new &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; variable called &lt;c2&gt;&lt;s3&gt;description&lt;/s3&gt;&lt;/c2&gt; and assigns it an initial value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、&lt;c2&gt;&lt;s3&gt;description&lt;/s3&gt;&lt;/c2&gt;と呼ばれる新しい&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;変数を宣言して、それに最初の値を代入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example declares a new constant called &lt;c0&gt;&lt;s1&gt;tenEighty&lt;/s1&gt;&lt;/c0&gt; and sets it to refer to a new instance of the &lt;c2&gt;&lt;s3&gt;VideoMode&lt;/s3&gt;&lt;/c2&gt; class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、&lt;c0&gt;&lt;s1&gt;tenEighty&lt;/s1&gt;&lt;/c0&gt;と呼ばれる新しい定数を宣言して、それを&lt;c2&gt;&lt;s3&gt;VideoMode&lt;/s3&gt;&lt;/c2&gt;クラスの新しいインスタンスに言及するように設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example defines a class called &lt;c0&gt;&lt;s1&gt;ShoppingListItem&lt;/s1&gt;&lt;/c0&gt;, which encapsulates the name, quantity, and purchase state of an item in a shopping list:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は&lt;c0&gt;&lt;s1&gt;ShoppingListItem&lt;/s1&gt;&lt;/c0&gt;と呼ばれるクラスを定義します、それは、ある購入品目リストにおける名前、量、そしてある項目の購入状態といったものをカプセル化します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example defines a class called &lt;c2&gt;&lt;s3&gt;HTMLElement&lt;/s3&gt;&lt;/c2&gt;, which provides a simple model for an individual element within an HTML document:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は&lt;c2&gt;&lt;s3&gt;HTMLElement&lt;/s3&gt;&lt;/c2&gt;と呼ばれるクラスを定義します、それは、HTML文書内個々の要素に対する単純なモデルを用意します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example defines a function called &lt;c0&gt;&lt;s1&gt;printMathResult(_:_:_:)&lt;/s1&gt;&lt;/c0&gt;, which has three parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は&lt;c0&gt;&lt;s1&gt;printMathResult(_:_:_:)&lt;/s1&gt;&lt;/c0&gt;と呼ばれる関数を定義します、それは３つのパラメータを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example defines a hierarchy of three classes called &lt;c0&gt;&lt;s1&gt;Food&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;RecipeIngredient&lt;/s3&gt;&lt;/c2&gt;, and &lt;c4&gt;&lt;s5&gt;ShoppingListItem&lt;/s5&gt;&lt;/c4&gt;, and demonstrates how their initializers interact.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、&lt;c0&gt;&lt;s1&gt;Food&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;RecipeIngredient&lt;/s3&gt;&lt;/c2&gt;、そして&lt;c4&gt;&lt;s5&gt;ShoppingListItem&lt;/s5&gt;&lt;/c4&gt;と呼ばれる３つのクラスの階層を定義して、それらのイニシャライザが相互に作用する方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example defines a new class called &lt;c0&gt;&lt;s1&gt;Dice&lt;/s1&gt;&lt;/c0&gt;, which represents an &lt;e2&gt;n&lt;/e2&gt;-sided dice for use in a board game.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は&lt;c0&gt;&lt;s1&gt;Dice&lt;/s1&gt;&lt;/c0&gt;と呼ばれる新しいクラスを定義します、それは、ボードゲームで使うのために&lt;e2&gt;n&lt;/e2&gt;面のさいころを表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example defines a new protocol, &lt;c0&gt;&lt;s1&gt;PrettyTextRepresentable&lt;/s1&gt;&lt;/c0&gt;, which inherits from &lt;c2&gt;&lt;s3&gt;TextRepresentable&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、ある新しいプロトコル、&lt;c0&gt;&lt;s1&gt;PrettyTextRepresentable&lt;/s1&gt;&lt;/c0&gt;を定義します、それは、&lt;c2&gt;&lt;s3&gt;TextRepresentable&lt;/s3&gt;&lt;/c2&gt;から継承を受けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example defines a new structure called &lt;c0&gt;&lt;s1&gt;Cuboid&lt;/s1&gt;&lt;/c0&gt;, which represents a 3D rectangular box with &lt;c2&gt;&lt;s3&gt;width&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;height&lt;/s5&gt;&lt;/c4&gt;, and &lt;c6&gt;&lt;s7&gt;depth&lt;/s7&gt;&lt;/c6&gt; properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は&lt;c0&gt;&lt;s1&gt;Cuboid&lt;/s1&gt;&lt;/c0&gt;と呼ばれる新しい構造体を定義します、それは、&lt;c2&gt;&lt;s3&gt;width&lt;/s3&gt;&lt;/c2&gt;、&lt;c4&gt;&lt;s5&gt;height&lt;/s5&gt;&lt;/c4&gt;、そして&lt;c6&gt;&lt;s7&gt;depth&lt;/s7&gt;&lt;/c6&gt;プロパティで3D矩形の箱を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example defines a protocol called &lt;c0&gt;&lt;s1&gt;HasArea&lt;/s1&gt;&lt;/c0&gt;, with a single property requirement of a gettable &lt;c2&gt;&lt;s3&gt;Double&lt;/s3&gt;&lt;/c2&gt; property called &lt;c4&gt;&lt;s5&gt;area&lt;/s5&gt;&lt;/c4&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、&lt;c4&gt;&lt;s5&gt;area&lt;/s5&gt;&lt;/c4&gt;と呼ばれる取得可能な&lt;c2&gt;&lt;s3&gt;Double&lt;/s3&gt;&lt;/c2&gt;プロパティである１つだけのプロパティ要件をもつ、&lt;c0&gt;&lt;s1&gt;HasArea&lt;/s1&gt;&lt;/c0&gt;と呼ばれるプロトコルを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example defines a structure called &lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt;, which represents a specific named person.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、&lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt;と呼ばれる構造体を定義します、それは、特定の名前の人物を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example defines an enumeration for a three-state switch.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、３つの状態を切り替えるために、ある列挙を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example defines another subclass of &lt;c0&gt;&lt;s1&gt;Vehicle&lt;/s1&gt;&lt;/c0&gt;, called &lt;c2&gt;&lt;s3&gt;Hoverboard&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、もう１つ&lt;c0&gt;&lt;s1&gt;Vehicle&lt;/s1&gt;&lt;/c0&gt;のサブクラスを定義します、それは&lt;c2&gt;&lt;s3&gt;Hoverboard&lt;/s3&gt;&lt;/c2&gt;と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example defines three structures for working with geometric shapes:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、幾何学形を扱うために３つの構造体を定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example defines two classes called &lt;c0&gt;&lt;s1&gt;DataImporter&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;DataManager&lt;/s3&gt;&lt;/c2&gt;, neither of which is shown in full:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、&lt;c0&gt;&lt;s1&gt;DataImporter&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;DataManager&lt;/s3&gt;&lt;/c2&gt;と呼ばれる２つのクラスを定義します、そのどちらも全部は示されません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example defines two classes called &lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;Apartment&lt;/s3&gt;&lt;/c2&gt;, which model a block of apartments and its residents:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は&lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;Apartment&lt;/s3&gt;&lt;/c2&gt;と呼ばれる２つのクラスを定義します、それは、アパートの１区画とその居住者をモデル化します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example defines two new types, &lt;c0&gt;&lt;s1&gt;Bank&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;Player&lt;/s3&gt;&lt;/c2&gt;, for a simple game.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、２つの新しい型&lt;c0&gt;&lt;s1&gt;Bank&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;Player&lt;/s3&gt;&lt;/c2&gt;を、単純なゲームのために定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example defines two simple mathematical functions called &lt;c0&gt;&lt;s1&gt;addTwoInts&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;multiplyTwoInts&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、&lt;c0&gt;&lt;s1&gt;addTwoInts&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;multiplyTwoInts&lt;/s3&gt;&lt;/c2&gt;と呼ばれる２つの単純な数学的な関数を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example highlights the way that an opaque return type is like the reverse of a generic type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、不透明型が総称体型のまるで逆であるやり方に光を当てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example identifies Uranus from its raw value of &lt;c0&gt;&lt;s1&gt;7&lt;/s1&gt;&lt;/c0&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、その生の値の&lt;c0&gt;&lt;s1&gt;7&lt;/s1&gt;&lt;/c0&gt;からUranus（天王星）を特定します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example initializes a &lt;c6&gt;&lt;s7&gt;UInt8&lt;/s7&gt;&lt;/c6&gt; integer with the binary value &lt;c8&gt;&lt;s9&gt;00001111&lt;/s9&gt;&lt;/c8&gt;, which has its first four bits set to &lt;c10&gt;&lt;s11&gt;0&lt;/s11&gt;&lt;/c10&gt;, and its second four bits set to &lt;c12&gt;&lt;s13&gt;1&lt;/s13&gt;&lt;/c12&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、&lt;c6&gt;&lt;s7&gt;UInt8&lt;/s7&gt;&lt;/c6&gt;整数を２進数の値&lt;c8&gt;&lt;s9&gt;00001111&lt;/s9&gt;&lt;/c8&gt;で初期化します、それは、その最初の４つのビットを&lt;c10&gt;&lt;s11&gt;0&lt;/s11&gt;&lt;/c10&gt;に設定して、次の４つのビットを&lt;c12&gt;&lt;s13&gt;1&lt;/s13&gt;&lt;/c12&gt;に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example is sorting an array of &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; values, and so the sorting closure needs to be a function of type &lt;c2&gt;&lt;s3&gt;(String,&lt;/s3&gt; &lt;s4&gt;String)&lt;/s4&gt; &lt;s5&gt;-&gt;&lt;/s5&gt; &lt;s6&gt;Bool&lt;/s6&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;値の配列を分類しています、なのでソート・クロージャは型&lt;c2&gt;&lt;s3&gt;(String,&lt;/s3&gt; &lt;s4&gt;String)&lt;/s4&gt; &lt;s5&gt;-&gt;&lt;/s5&gt; &lt;s6&gt;Bool&lt;/s6&gt;&lt;/c2&gt;の関数である必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example iterates through all items in the &lt;c0&gt;&lt;s1&gt;library&lt;/s1&gt;&lt;/c0&gt; array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、&lt;c0&gt;&lt;s1&gt;library&lt;/s1&gt;&lt;/c0&gt;配列の中の全ての項目の端が端まで繰り返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example plays a simple game of &lt;e0&gt;Snakes and Ladders&lt;/e0&gt; (also known as &lt;e1&gt;Chutes and Ladders&lt;/e1&gt;):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、単純なゲームの&lt;e0&gt;「ヘビとはしご」&lt;/e0&gt;（また、&lt;e1&gt;「荷すべらしとはしご」&lt;/e1&gt;として知られます）で遊びます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example prints the first few entries in a five-times table:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、九九の５の段の表の最初のいくつかの項を出力します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example provides a type annotation for a variable called &lt;c0&gt;&lt;s1&gt;welcomeMessage&lt;/s1&gt;&lt;/c0&gt;, to indicate that the variable can store &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt; values:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、&lt;c0&gt;&lt;s1&gt;welcomeMessage&lt;/s1&gt;&lt;/c0&gt;と呼ばれる変数に対して、その変数は&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;値を格納できることを示すために型注釈を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example sets a constant called &lt;c0&gt;&lt;s1&gt;incrementByTen&lt;/s1&gt;&lt;/c0&gt; to refer to an incrementer function that adds &lt;c2&gt;&lt;s3&gt;10&lt;/s3&gt;&lt;/c2&gt; to its &lt;c4&gt;&lt;s5&gt;runningTotal&lt;/s5&gt;&lt;/c4&gt; variable each time it is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、&lt;c0&gt;&lt;s1&gt;incrementByTen&lt;/s1&gt;&lt;/c0&gt;と呼ばれる定数を、それが呼ばれるたびに&lt;c2&gt;&lt;s3&gt;10&lt;/s3&gt;&lt;/c2&gt;をその&lt;c4&gt;&lt;s5&gt;runningTotal&lt;/s5&gt;&lt;/c4&gt;変数に加えるあるインクリメンタ関数に言及するように設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example starts with a simple class called &lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt;, which defines a stored constant property called &lt;c2&gt;&lt;s3&gt;name&lt;/s3&gt;&lt;/c2&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、&lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt;と呼ばれる単純なクラスから始めます、それは、&lt;c2&gt;&lt;s3&gt;name&lt;/s3&gt;&lt;/c2&gt;と呼ばれる格納定数プロパティを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example uses a &lt;c0&gt;&lt;s1&gt;UInt32&lt;/s1&gt;&lt;/c0&gt; constant called &lt;c2&gt;&lt;s3&gt;pink&lt;/s3&gt;&lt;/c2&gt; to store a Cascading Style Sheets color value for the color pink.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、ピンク色のカスケーディング・スタイル・シートの色値を保存するために、&lt;c2&gt;&lt;s3&gt;pink&lt;/s3&gt;&lt;/c2&gt;と呼ばれる&lt;c0&gt;&lt;s1&gt;UInt32&lt;/s1&gt;&lt;/c0&gt;定数を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example uses a &lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt; loop to iterate over the items in an array:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、&lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt;ループを使って、ある配列の中の項目すべてにわたって繰り返していきます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example uses a &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; statement to consider a single lowercase character called &lt;c2&gt;&lt;s3&gt;someCharacter&lt;/s3&gt;&lt;/c2&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;文を１つの小文字の文字、&lt;c2&gt;&lt;s3&gt;someCharacter&lt;/s3&gt;&lt;/c2&gt;と呼ばれるものについて考察するために使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example uses a subscript in a key path to access the second element of an array:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、キーパス式において添え字を使って、配列の２番目の要素にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example uses multiple &lt;c0&gt;&lt;s1&gt;&amp;&amp;&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;||&lt;/s3&gt;&lt;/c2&gt; operators to create a longer compound expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、より長く複雑な式をつくるために複数の&lt;c0&gt;&lt;s1&gt;&amp;&amp;&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;||&lt;/s3&gt;&lt;/c2&gt;演算子を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example uses number intervals to provide a natural-language count for numbers of any size:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、自然言語の数え方をどんな大きさの数にも用意するために、数の区間を使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example uses optional binding to try to access a planet with a raw value of &lt;c0&gt;&lt;s1&gt;11&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例は、&lt;c0&gt;&lt;s1&gt;11&lt;/s1&gt;&lt;/c0&gt;の生の値で惑星にアクセスすることを試みるためにオプショナル束縛を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This example’s &lt;c0&gt;&lt;s1&gt;willSet&lt;/s1&gt;&lt;/c0&gt; observer uses a custom parameter name of &lt;c2&gt;&lt;s3&gt;newTotalSteps&lt;/s3&gt;&lt;/c2&gt; for the upcoming new value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例の&lt;c0&gt;&lt;s1&gt;willSet&lt;/s1&gt;&lt;/c0&gt;オブザーバーは、来るべき新しい値のためにあつらえのパラメータ名&lt;c2&gt;&lt;s3&gt;newTotalSteps&lt;/s3&gt;&lt;/c2&gt;を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This exception ensures that an older compiler doesn’t attempt to parse syntax introduced in a newer version of Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例外は、古いコンパイラがより新しいバージョンのスウィフトで導入される構文の解析を試みないことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This expression calculates the value of &lt;c2&gt;&lt;s3&gt;Double(multiplier)&lt;/s3&gt; &lt;s4&gt;*&lt;/s4&gt; &lt;s5&gt;2.5&lt;/s5&gt;&lt;/c2&gt; and inserts the result (&lt;c6&gt;&lt;s7&gt;7.5&lt;/s7&gt;&lt;/c6&gt;) into the string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この式は、&lt;c2&gt;&lt;s3&gt;Double(multiplier)&lt;/s3&gt; &lt;s4&gt;*&lt;/s4&gt; &lt;s5&gt;2.5&lt;/s5&gt;&lt;/c2&gt;の値を計算して、結果（&lt;c6&gt;&lt;s7&gt;7.5&lt;/s7&gt;&lt;/c6&gt;）を文字列に差し込みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This extension adopts the new protocol in exactly the same way as if &lt;c0&gt;&lt;s1&gt;Dice&lt;/s1&gt;&lt;/c0&gt; had provided it in its original implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この拡張は、まるで&lt;c0&gt;&lt;s1&gt;Dice&lt;/s1&gt;&lt;/c0&gt;がその最初の実装においてそれを提供したかのように、正確に同じふうに新しいプロトコルを採用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This extension states that it adopts the &lt;c0&gt;&lt;s1&gt;PrettyTextRepresentable&lt;/s1&gt;&lt;/c0&gt; protocol and provides an implementation of the &lt;c2&gt;&lt;s3&gt;prettyTextualDescription&lt;/s3&gt;&lt;/c2&gt; property for the &lt;c4&gt;&lt;s5&gt;SnakesAndLadders&lt;/s5&gt;&lt;/c4&gt; type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この拡張が述べるのは、それが&lt;c0&gt;&lt;s1&gt;PrettyTextRepresentable&lt;/s1&gt;&lt;/c0&gt;プロトコルを採用して&lt;c2&gt;&lt;s3&gt;prettyTextualDescription&lt;/s3&gt;&lt;/c2&gt;プロパティの実装を&lt;c4&gt;&lt;s5&gt;SnakesAndLadders&lt;/s5&gt;&lt;/c4&gt;型に提供することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This extension to the &lt;c0&gt;&lt;s1&gt;Container&lt;/s1&gt;&lt;/c0&gt; protocol adds a subscript that takes a sequence of indices and returns an array containing the items at each given index.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この&lt;c0&gt;&lt;s1&gt;Container&lt;/s1&gt;&lt;/c0&gt;プロトコルに対する拡張は、ある添え字を追加します、それはインデックスのシーケンスをとって、与えられたインデックスそれぞれでの項目を含んでいる配列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This failure might be triggered by invalid initialization parameter values, the absence of a required external resource, or some other condition that prevents initialization from succeeding.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この失敗は、無効な初期化パラメータ、必須の外部リソースの欠如、または初期化がうまくいくのを妨げる何か他の状況によって引き起こされるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This feature enables you to hide the implementation details of your code, and to specify a preferred interface through which that code can be accessed and used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この特徴によってあなたは、あなたのコードの実施詳細を隠すこと、そしてそれを通してそのコードがアクセスされ使用されることができる好ましいインタフェースを指定することが可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This feature is represented by a structure called &lt;c0&gt;&lt;s1&gt;Values&lt;/s1&gt;&lt;/c0&gt;, which is nested within the &lt;c2&gt;&lt;s3&gt;Rank&lt;/s3&gt;&lt;/c2&gt; enumeration:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この特徴は&lt;c0&gt;&lt;s1&gt;Values&lt;/s1&gt;&lt;/c0&gt;と呼ばれる構造体で表されます、それは、&lt;c2&gt;&lt;s3&gt;Rank&lt;/s3&gt;&lt;/c2&gt;列挙の内部で入れ子にされます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This feature prevents the assignment operator (&lt;c0&gt;&lt;s1&gt;=&lt;/s1&gt;&lt;/c0&gt;) from being used by accident when the equal to operator (&lt;c2&gt;&lt;s3&gt;==&lt;/s3&gt;&lt;/c2&gt;) is actually intended.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この特徴は、実際には同等演算子（&lt;c2&gt;&lt;s3&gt;==&lt;/s3&gt;&lt;/c2&gt;）が意図されるときに、偶然に代入演算子（&lt;c0&gt;&lt;s1&gt;=&lt;/s1&gt;&lt;/c0&gt;）が使われるのを防止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This form of the operator will always return an optional value, and the value will be &lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt; if the downcast was not possible.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子のこの形式は、常にオプショナルの値を返します、そしてダウンキャストが可能でなかったならばその値は&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This form of the operator will trigger a runtime error if you try to downcast to an incorrect class type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子のこの形式は、あなたが適切でないクラス型へのダウンキャストをためすならば、実行時エラーを引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function doesn’t compile as written above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数は、上記のように書かれるとしてもコンパイルしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function evaluates a plain number by simply returning the associated value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数は、普通の数字を単に関連値を返すことによって評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function makes use of in-out parameters to swap the values of &lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;b&lt;/s3&gt;&lt;/c2&gt;, as described in &lt;a4&gt;&lt;s5&gt;In-Out Parameters&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数は、値&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;b&lt;/s3&gt;&lt;/c2&gt;を交換するためにin-outパラメータの利用を行います、&lt;a4&gt;&lt;s5&gt;In-Outパラメータ&lt;/s5&gt;&lt;/a4&gt;で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function simply adds &lt;c14&gt;&lt;s15&gt;amount&lt;/s15&gt;&lt;/c14&gt; to &lt;c16&gt;&lt;s17&gt;runningTotal&lt;/s17&gt;&lt;/c16&gt;, and returns the result.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数は、単に&lt;c14&gt;&lt;s15&gt;amount&lt;/s15&gt;&lt;/c14&gt;を&lt;c16&gt;&lt;s17&gt;runningTotal&lt;/s17&gt;&lt;/c16&gt;に加えて、結果を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function takes a person’s name and whether they have already been greeted as input, and returns an appropriate greeting for that person:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数は、人物の名前と彼らがすでに挨拶されたかどうかを入力として取って、ふさわしい挨拶をその人物に対して返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function takes two arguments called &lt;c0&gt;&lt;s1&gt;someContainer&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;anotherContainer&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数は、&lt;c0&gt;&lt;s1&gt;someContainer&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;anotherContainer&lt;/s3&gt;&lt;/c2&gt;と呼ばれる２つの引数をとります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function, &lt;c0&gt;&lt;s1&gt;printIntegerKinds(_:)&lt;/s1&gt;&lt;/c0&gt;, takes an input array of &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt; values and iterates over those values in turn.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数、&lt;c0&gt;&lt;s1&gt;printIntegerKinds(_:)&lt;/s1&gt;&lt;/c0&gt;は、&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;値の配列の入力を取り、それらの値に最初から終わりまで順番に繰り返していきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This functionality is provided by the &lt;c2&gt;&lt;s3&gt;DataImporter&lt;/s3&gt;&lt;/c2&gt; class, which is assumed to take a nontrivial amount of time to initialize.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この機能性は&lt;c2&gt;&lt;s3&gt;DataImporter&lt;/s3&gt;&lt;/c2&gt;クラスによって提供されます、それは、初期化するために瑣末でない量の時間がかかると仮定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This future type can be referred to as &lt;c2&gt;&lt;s3&gt;Element&lt;/s3&gt;&lt;/c2&gt; anywhere within the structure’s definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この将来の型は、構造体の定義の範囲内のどこででも「&lt;c2&gt;&lt;s3&gt;Element&lt;/s3&gt;&lt;/c2&gt;」として参照されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This future warning informs you that the library author added a new case to the enumeration that doesn’t have a corresponding switch case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この未来警告は、対応するスイッチケース節を持たない列挙にライブラリ作者がある新しいケース節を加えたことをあなたに告知します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This generic subscript is constrained as follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この総称体添え字は、以下のように制約されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This gives a reverse alphabetical sort, with &lt;c20&gt;&lt;s21&gt;"Barry"&lt;/s21&gt;&lt;/c20&gt; being placed before &lt;c22&gt;&lt;s23&gt;"Alex"&lt;/s23&gt;&lt;/c22&gt;, and so on.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、&lt;c20&gt;&lt;s21&gt;"Barry"&lt;/s21&gt;&lt;/c20&gt;が&lt;c22&gt;&lt;s23&gt;"Alex"&lt;/s23&gt;&lt;/c22&gt;の前に置かれるなどの、逆アルファベット順の分類を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This greeting is then passed back out of the function using the &lt;c6&gt;&lt;s7&gt;return&lt;/s7&gt;&lt;/c6&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この挨拶は、それから&lt;c6&gt;&lt;s7&gt;return&lt;/s7&gt;&lt;/c6&gt;キーワードを使用して逆に関数の外に渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This helps you remember that it’s possible to capture &lt;c10&gt;&lt;s11&gt;self&lt;/s11&gt;&lt;/c10&gt; by accident.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、偶然に&lt;c10&gt;&lt;s11&gt;self&lt;/s11&gt;&lt;/c10&gt;を捕らえることは可能であるのをあなたが忘れないことを手助けします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This illustrates that the overall call to the &lt;c0&gt;&lt;s1&gt;sorted(by:)&lt;/s1&gt;&lt;/c0&gt; method has remained the same.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、&lt;c0&gt;&lt;s1&gt;sorted(by:)&lt;/s1&gt;&lt;/c0&gt;メソッドへの呼び出し全体が、同じもののままだったことを図解します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This implementation of &lt;c0&gt;&lt;s1&gt;HTMLElement&lt;/s1&gt;&lt;/c0&gt; is identical to the previous implementation, apart from the addition of a capture list within the &lt;c2&gt;&lt;s3&gt;asHTML&lt;/s3&gt;&lt;/c2&gt; closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;HTMLElement&lt;/s1&gt;&lt;/c0&gt;のこの実装は、&lt;c2&gt;&lt;s3&gt;asHTML&lt;/s3&gt;&lt;/c2&gt;クロージャ内の捕獲リストの追加は別として、前の実装と同一です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This implementation uses two triangles and a square, but the function could be rewritten to draw a trapezoid in a variety of other ways without changing its return type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この実装は、２つの三角形とある四角形を使います、しかし関数は、台形をさまざまな他の方法で描画するよう書き直されることがそれの戻り型を変更することなしにできました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes &lt;c10&gt;&lt;s11&gt;String&lt;/s11&gt;&lt;/c10&gt;, as shown here, as well as collection types such as &lt;c12&gt;&lt;s13&gt;Array&lt;/s13&gt;&lt;/c12&gt;, &lt;c14&gt;&lt;s15&gt;Dictionary&lt;/s15&gt;&lt;/c14&gt;, and &lt;c16&gt;&lt;s17&gt;Set&lt;/s17&gt;&lt;/c16&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、ここで示すように&lt;c10&gt;&lt;s11&gt;String&lt;/s11&gt;&lt;/c10&gt;を、それだけでなく&lt;c12&gt;&lt;s13&gt;Array&lt;/s13&gt;&lt;/c12&gt;、&lt;c14&gt;&lt;s15&gt;Dictionary&lt;/s15&gt;&lt;/c14&gt;、そして&lt;c16&gt;&lt;s17&gt;Set&lt;/s17&gt;&lt;/c16&gt;といったコレクション型も含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes &lt;c12&gt;&lt;s13&gt;String&lt;/s13&gt;&lt;/c12&gt;, as shown here, as well as collection types such as &lt;c14&gt;&lt;s15&gt;Array&lt;/s15&gt;&lt;/c14&gt;, &lt;c16&gt;&lt;s17&gt;Dictionary&lt;/s17&gt;&lt;/c16&gt;, and &lt;c18&gt;&lt;s19&gt;Set&lt;/s19&gt;&lt;/c18&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、ここで示すように&lt;c12&gt;&lt;s13&gt;String&lt;/s13&gt;&lt;/c12&gt;を、それだけでなく&lt;c14&gt;&lt;s15&gt;Array&lt;/s15&gt;&lt;/c14&gt;、&lt;c16&gt;&lt;s17&gt;Dictionary&lt;/s17&gt;&lt;/c16&gt;、そして&lt;c18&gt;&lt;s19&gt;Set&lt;/s19&gt;&lt;/c18&gt;といったコレクション型も含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes a protocol with an associated type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、関連型を使うプロトコルを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes the ability to extend types for which you do not have access to the original source code (known as &lt;e1&gt;retroactive modeling&lt;/e1&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたが元々のソース・コードにアクセスをしないで型を拡張する能力を含みます（&lt;e1&gt;遡及モデリング&lt;/e1&gt;として知られます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This initializer can be used to create a new &lt;c4&gt;&lt;s5&gt;Food&lt;/s5&gt;&lt;/c4&gt; instance with a specific name:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このイニシャライザが、ある特定の名前を使って新しい&lt;c4&gt;&lt;s5&gt;Food&lt;/s5&gt;&lt;/c4&gt;インスタンスをつくるために使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This initializer checks if the &lt;c10&gt;&lt;s11&gt;species&lt;/s11&gt;&lt;/c10&gt; value passed to the initializer is an empty string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このイニシャライザは、イニシャライザに渡される&lt;c10&gt;&lt;s11&gt;species&lt;/s11&gt;&lt;/c10&gt;値が空の文字列かどうか検査します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This initializer has a parameter called &lt;c2&gt;&lt;s3&gt;generator&lt;/s3&gt;&lt;/c2&gt;, which is also of type &lt;c4&gt;&lt;s5&gt;RandomNumberGenerator&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このイニシャライザは、&lt;c2&gt;&lt;s3&gt;generator&lt;/s3&gt;&lt;/c2&gt;と呼ばれるパラメータを持ちます、それもまた、型&lt;c4&gt;&lt;s5&gt;RandomNumberGenerator&lt;/s5&gt;&lt;/c4&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This initializer has an empty body, represented by an empty pair of curly braces &lt;c4&gt;&lt;s5&gt;{}&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このイニシャライザは、一対の空の波括弧&lt;c4&gt;&lt;s5&gt;{}&lt;/s5&gt;&lt;/c4&gt;によって表される空の本文を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This initializer is described in more detail in &lt;a16&gt;&lt;s17&gt;Creating an Array with a Default Value&lt;/s17&gt;&lt;/a16&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このイニシャライザは、更に詳細に&lt;a16&gt;&lt;s17&gt;配列を１つの初期値で作成する&lt;/s17&gt;&lt;/a16&gt;で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This initializer is therefore inherited by &lt;c6&gt;&lt;s7&gt;RecipeIngredient&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このイニシャライザは、したがって、&lt;c6&gt;&lt;s7&gt;RecipeIngredient&lt;/s7&gt;&lt;/c6&gt;によって継承されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This initializer simply assigns the &lt;c4&gt;&lt;s5&gt;origin&lt;/s5&gt;&lt;/c4&gt; and &lt;c6&gt;&lt;s7&gt;size&lt;/s7&gt;&lt;/c6&gt; argument values to the appropriate stored properties:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このイニシャライザは、単に引数値&lt;c4&gt;&lt;s5&gt;origin&lt;/s5&gt;&lt;/c4&gt;と&lt;c6&gt;&lt;s7&gt;size&lt;/s7&gt;&lt;/c6&gt;を適切な格納プロパティに代入します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This initializer starts by assigning the passed &lt;c9&gt;&lt;s10&gt;quantity&lt;/s10&gt;&lt;/c9&gt; argument to the &lt;c11&gt;&lt;s12&gt;quantity&lt;/s12&gt;&lt;/c11&gt; property, which is the only new property introduced by &lt;c13&gt;&lt;s14&gt;RecipeIngredient&lt;/s14&gt;&lt;/c13&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このイニシャライザは、渡された&lt;c9&gt;&lt;s10&gt;quantity&lt;/s10&gt;&lt;/c9&gt;引数を&lt;c11&gt;&lt;s12&gt;quantity&lt;/s12&gt;&lt;/c11&gt;プロパティに代入することによって始めます、それは、&lt;c13&gt;&lt;s14&gt;RecipeIngredient&lt;/s14&gt;&lt;/c13&gt;によって導入される唯一の新しいプロパティです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a constant value of &lt;c4&gt;&lt;s5&gt;10&lt;/s5&gt;&lt;/c4&gt; for all &lt;c6&gt;&lt;s7&gt;AudioChannel&lt;/s7&gt;&lt;/c6&gt; instances.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、定数値で、全ての&lt;c6&gt;&lt;s7&gt;AudioChannel&lt;/s7&gt;&lt;/c6&gt;インスタンスのために&lt;c4&gt;&lt;s5&gt;10&lt;/s5&gt;&lt;/c4&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a stored property with &lt;c6&gt;&lt;s7&gt;willSet&lt;/s7&gt;&lt;/c6&gt; and &lt;c8&gt;&lt;s9&gt;didSet&lt;/s9&gt;&lt;/c8&gt; observers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、&lt;c6&gt;&lt;s7&gt;willSet&lt;/s7&gt;&lt;/c6&gt;と&lt;c8&gt;&lt;s9&gt;didSet&lt;/s9&gt;&lt;/c8&gt;オブザーバーを持つ格納プロパティです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is also a comment</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（これもコメントです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is because functions and closures are &lt;e6&gt;reference types&lt;/e6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、関数とクロージャが&lt;e6&gt;参照型&lt;/e6&gt;であるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is because of the copy-in copy-out memory model for in-out parameters: The value is always written back to the property at the end of the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、in-outパラメータのための「コピーイン、コピーアウト」メモリーモデルが理由です：値は常に、その関数の終わりでプロパティへと書き込まれて戻されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is because the type itself does not have an initializer that can assign a value to a stored type property at initialization time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、型それ自身には初期化時に値を格納型プロパティに代入することができるイニシャライザがないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is equivalent to a decimal value of &lt;c14&gt;&lt;s15&gt;15&lt;/s15&gt;&lt;/c14&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、10進の値の&lt;c14&gt;&lt;s15&gt;15&lt;/s15&gt;&lt;/c14&gt;に等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is indicated by passing a value of &lt;c2&gt;&lt;s3&gt;3&lt;/s3&gt;&lt;/c2&gt; to the structure’s &lt;c4&gt;&lt;s5&gt;initializer&lt;/s5&gt;&lt;/c4&gt; as the value to use for the instance’s &lt;c6&gt;&lt;s7&gt;multiplier&lt;/s7&gt;&lt;/c6&gt; parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、値&lt;c2&gt;&lt;s3&gt;3&lt;/s3&gt;&lt;/c2&gt;をこの構造体の&lt;c4&gt;&lt;s5&gt;initializer&lt;/s5&gt;&lt;/c4&gt;にインスタンスの&lt;c6&gt;&lt;s7&gt;multiplier&lt;/s7&gt;&lt;/c6&gt;パラメータのために使う値として渡すことによって示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is indicated by setting the optional &lt;c0&gt;&lt;s1&gt;playerOne&lt;/s1&gt;&lt;/c0&gt; variable to &lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;, meaning “no &lt;c4&gt;&lt;s5&gt;Player&lt;/s5&gt;&lt;/c4&gt; instance.” At the point that this happens, the &lt;c6&gt;&lt;s7&gt;playerOne&lt;/s7&gt;&lt;/c6&gt; variable’s reference to the &lt;c8&gt;&lt;s9&gt;Player&lt;/s9&gt;&lt;/c8&gt; instance is broken.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはオプショナルの&lt;c0&gt;&lt;s1&gt;playerOne&lt;/s1&gt;&lt;/c0&gt;変数に、「&lt;c4&gt;&lt;s5&gt;Player&lt;/s5&gt;&lt;/c4&gt;インスタンスがない」ことを意味する、&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;を設定することによって示されます。これが起こる時点で、&lt;c6&gt;&lt;s7&gt;playerOne&lt;/s7&gt;&lt;/c6&gt;変数のもつ&lt;c8&gt;&lt;s9&gt;Player&lt;/s9&gt;&lt;/c8&gt;インスタンスへの参照は壊れています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is known as &lt;e0&gt;closing over&lt;/e0&gt; those constants and variables.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、そのような定数や変数を&lt;e0&gt;すっかりクローズする（閉じ込める）&lt;/e0&gt;こととして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is known as &lt;e0&gt;overloading&lt;/e0&gt; the existing operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>既存の演算子の&lt;e0&gt;オーバーロード&lt;/e0&gt;としてこれは知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is known as &lt;e0&gt;overriding&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、&lt;e0&gt;オーバーライド&lt;/e0&gt;として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is known as &lt;e6&gt;short-circuit evaluation&lt;/e6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは&lt;e6&gt;短絡評価&lt;/e6&gt;として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is known as &lt;e9&gt;short-circuit evaluation&lt;/e9&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは&lt;e9&gt;短絡評価&lt;/e9&gt;として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is known as a &lt;e1&gt;strong reference cycle&lt;/e1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、&lt;e1&gt;強い参照循環&lt;/e1&gt;として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is necessary in order for it to be able to access the &lt;c10&gt;&lt;s11&gt;director&lt;/s11&gt;&lt;/c10&gt; or &lt;c12&gt;&lt;s13&gt;artist&lt;/s13&gt;&lt;/c12&gt; property of a &lt;c14&gt;&lt;s15&gt;Movie&lt;/s15&gt;&lt;/c14&gt; or &lt;c16&gt;&lt;s17&gt;Song&lt;/s17&gt;&lt;/c16&gt; for use in the description.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、それがその説明で使う目的で&lt;c14&gt;&lt;s15&gt;Movie&lt;/s15&gt;&lt;/c14&gt;または&lt;c16&gt;&lt;s17&gt;Song&lt;/s17&gt;&lt;/c16&gt;のもつ&lt;c10&gt;&lt;s11&gt;director&lt;/s11&gt;&lt;/c10&gt;または&lt;c12&gt;&lt;s13&gt;artist&lt;/s13&gt;&lt;/c12&gt;プロパティにアクセス可能になるために必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is often done by assigning a &lt;e0&gt;literal value&lt;/e0&gt; (or &lt;e1&gt;literal&lt;/e1&gt;) to the constant or variable at the point that you declare it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、&lt;e0&gt;リテラル値&lt;/e0&gt;（または&lt;e1&gt;リテラル&lt;/e1&gt;）を定数または変数に、あなたがそれを宣言する時点で代入することによって、しばしば行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is particularly true when you work with functions or methods that take functions as one or more of their arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>１つ以上のそれの引数として関数をとる関数またはメソッドをあなたが扱うとき、これは特に当てはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is represented by the player’s &lt;c2&gt;&lt;s3&gt;coinsInPurse&lt;/s3&gt;&lt;/c2&gt; property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、プレーヤーの&lt;c2&gt;&lt;s3&gt;coinsInPurse&lt;/s3&gt;&lt;/c2&gt;プロパティによって表されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is simply an empty tuple, which is written as &lt;c5&gt;&lt;s6&gt;()&lt;/s6&gt;&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは単に空のタプルです、それは&lt;c5&gt;&lt;s6&gt;()&lt;/s6&gt;&lt;/c5&gt;のように書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the end of the first multiline comment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（最初の複数行コメントの終わり。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the same as &lt;c7&gt;&lt;s8&gt;0xCC&lt;/s8&gt;&lt;/c7&gt;, which has a decimal value of &lt;c9&gt;&lt;s10&gt;204&lt;/s10&gt;&lt;/c9&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは&lt;c7&gt;&lt;s8&gt;0xCC&lt;/s8&gt;&lt;/c7&gt;と同じものです、それは、10進の値の&lt;c9&gt;&lt;s10&gt;204&lt;/s10&gt;&lt;/c9&gt;を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the second, nested multiline comment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（第二の入れ子の複数行コメント。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the standard calling convention for function values in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、スウィフトにおける関数値のための標準的な呼出規約です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the start of the first multiline comment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（最初の複数行コメントの始まり。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is true even for constant stored properties, as described in &lt;a2&gt;&lt;s3&gt;Assigning Constant Properties During Initialization&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a2&gt;&lt;s3&gt;初期化の間に定数プロパティを割り当てる&lt;/s3&gt;&lt;/a2&gt;で記述されるように、これは定数格納プロパティにさえあてはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is true even if the new value is the same as the current value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、たとえ新しい値が現在の値と同じものであるとしても当てはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is true even if you are overriding an automatically provided default initializer, as described in &lt;a3&gt;&lt;s4&gt;Default Initializers&lt;/s4&gt;&lt;/a3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、&lt;a3&gt;&lt;s4&gt;省略時のイニシャライザ&lt;/s4&gt;&lt;/a3&gt;で記述されるように、あなたが自動的に提供される省略時のイニシャライザをオーバーライドしている場合にさえもあてはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is true even though &lt;c5&gt;&lt;s6&gt;increment(forCount:)&lt;/s6&gt;&lt;/c5&gt; is defined as returning a non-optional &lt;c7&gt;&lt;s8&gt;Int&lt;/s8&gt;&lt;/c7&gt; value in the definition of &lt;c9&gt;&lt;s10&gt;CounterDataSource&lt;/s10&gt;&lt;/c9&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえ&lt;c5&gt;&lt;s6&gt;increment(forCount:)&lt;/s6&gt;&lt;/c5&gt;が&lt;c9&gt;&lt;s10&gt;CounterDataSource&lt;/s10&gt;&lt;/c9&gt;の定義の中で非オプショナルの&lt;c7&gt;&lt;s8&gt;Int&lt;/s8&gt;&lt;/c7&gt;値を返すように定義されるとしても、これは当てはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is true even though type method requirements are prefixed with the &lt;c2&gt;&lt;s3&gt;class&lt;/s3&gt;&lt;/c2&gt; or &lt;c4&gt;&lt;s5&gt;static&lt;/s5&gt;&lt;/c4&gt; keyword when implemented by a class:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえ型メソッド要件がクラスによって実装されるとき&lt;c2&gt;&lt;s3&gt;class&lt;/s3&gt;&lt;/c2&gt;または&lt;c4&gt;&lt;s5&gt;static&lt;/s5&gt;&lt;/c4&gt;キーワードを前に置かれるとしても、これは当てはまります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is very similar to placing an exclamation point (&lt;c4&gt;&lt;s5&gt;!&lt;/s5&gt;&lt;/c4&gt;) after an optional value to force the unwrapping of its value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、その値を強制アンラップするためにオプショナルの値の後に感嘆符（&lt;c4&gt;&lt;s5&gt;!&lt;/s5&gt;&lt;/c4&gt;）を置くことに非常に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is why &lt;c26&gt;&lt;s27&gt;increment(forCount:)&lt;/s27&gt;&lt;/c26&gt; is also written with a question mark after its name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これが、&lt;c26&gt;&lt;s27&gt;increment(forCount:)&lt;/s27&gt;&lt;/c26&gt;もまたその名前の後に疑問符を書かれる理由です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is why the &lt;c4&gt;&lt;s5&gt;m&lt;/s5&gt;&lt;/c4&gt; computed property returns &lt;c6&gt;&lt;s7&gt;self&lt;/s7&gt;&lt;/c6&gt;—the expression &lt;c8&gt;&lt;s9&gt;1.m&lt;/s9&gt;&lt;/c8&gt; is considered to calculate a &lt;c10&gt;&lt;s11&gt;Double&lt;/s11&gt;&lt;/c10&gt; value of &lt;c12&gt;&lt;s13&gt;1.0&lt;/s13&gt;&lt;/c12&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これが&lt;c4&gt;&lt;s5&gt;m&lt;/s5&gt;&lt;/c4&gt;計算プロパティが&lt;c6&gt;&lt;s7&gt;self&lt;/s7&gt;&lt;/c6&gt;を返す理由です ― 式&lt;c8&gt;&lt;s9&gt;1.m&lt;/s9&gt;&lt;/c8&gt;は、&lt;c12&gt;&lt;s13&gt;1.0&lt;/s13&gt;&lt;/c12&gt;の&lt;c10&gt;&lt;s11&gt;Double&lt;/s11&gt;&lt;/c10&gt;値を計算するものと考えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This keeps track of the maximum input value that has been received by &lt;e2&gt;any&lt;/e2&gt; &lt;c3&gt;&lt;s4&gt;AudioChannel&lt;/s4&gt;&lt;/c3&gt; instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、&lt;e2&gt;あらゆる&lt;/e2&gt;&lt;c3&gt;&lt;s4&gt;AudioChannel&lt;/s4&gt;&lt;/c3&gt;インスタンスによって受け取られた最大入力値の情報を得続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This key-value type matches the type of the &lt;c3&gt;&lt;s4&gt;airports&lt;/s4&gt;&lt;/c3&gt; variable declaration (a dictionary with only &lt;c5&gt;&lt;s6&gt;String&lt;/s6&gt;&lt;/c5&gt; keys, and only &lt;c7&gt;&lt;s8&gt;String&lt;/s8&gt;&lt;/c7&gt; values), and so the assignment of the dictionary literal is permitted as a way to initialize the &lt;c9&gt;&lt;s10&gt;airports&lt;/s10&gt;&lt;/c9&gt; dictionary with two initial items.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この「キーと値」型は、&lt;c3&gt;&lt;s4&gt;airports&lt;/s4&gt;&lt;/c3&gt;変数の宣言の型（&lt;c5&gt;&lt;s6&gt;String&lt;/s6&gt;&lt;/c5&gt;のキーのみ、そして&lt;c7&gt;&lt;s8&gt;String&lt;/s8&gt;&lt;/c7&gt;の値のみをもつ辞書）に合致します、なのでこの辞書リテラルを代入することは、２つの最初の項目で&lt;c9&gt;&lt;s10&gt;airports&lt;/s10&gt;&lt;/c9&gt;辞書を初期化する方法として許されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This keyword indicates that the definition of the closure’s parameters and return type has finished, and the body of the closure is about to begin.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このキーワードはクロージャのパラメータと戻り型の定義が終わったことを示します、そして、クロージャの本文はまさに開始しようとしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This kind of function call expression has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この種類の関数呼び出し式は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This kind of function is known as a &lt;e0&gt;nested function&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この種類の関数は、&lt;e0&gt;入れ子にされた関数&lt;/e0&gt;として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This kind of range is called a &lt;e0&gt;one-sided range&lt;/e0&gt; because the operator has a value on only one side.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この種類の範囲は、&lt;e0&gt;片側範囲&lt;/e0&gt;と呼ばれます、なぜならこの演算子は一方の側でのみ値を持つからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This kind of subscript is called a &lt;e0&gt;type subscript&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この種の添え字は、&lt;e0&gt;型添え字&lt;/e0&gt;と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This lets you call the throwing function inside a &lt;c4&gt;&lt;s5&gt;do&lt;/s5&gt;&lt;/c4&gt;-&lt;c6&gt;&lt;s7&gt;catch&lt;/s7&gt;&lt;/c6&gt; statement and handle errors in the &lt;c8&gt;&lt;s9&gt;catch&lt;/s9&gt;&lt;/c8&gt; clause by throwing a different error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたにスロー関数を&lt;c4&gt;&lt;s5&gt;do&lt;/s5&gt;&lt;/c4&gt;-&lt;c6&gt;&lt;s7&gt;catch&lt;/s7&gt;&lt;/c6&gt;文の内部で呼び出させ、その&lt;c8&gt;&lt;s9&gt;catch&lt;/s9&gt;&lt;/c8&gt;節において異なるエラーをスローすることによって、エラーを取り扱わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This list is transformed into a tree by applying operator precedence.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このリストは、演算子優先順位を適用することによって、ツリー（木構造）に変えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes for highly readable code when working with explicitly typed enumeration values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、明示的に型指定された列挙値を扱う場合に、非常に可読性の高いコードにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes it easy to create custom string values for display, storage, and printing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、表示、保存、そして出力するために個々の注文に応じた文字列値をつくることを簡単にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes the &lt;c10&gt;&lt;s11&gt;switch&lt;/s11&gt;&lt;/c10&gt; statement safer and easier to use than the one in C and avoids executing more than one &lt;c12&gt;&lt;s13&gt;switch&lt;/s13&gt;&lt;/c12&gt; case by mistake.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、&lt;c10&gt;&lt;s11&gt;switch&lt;/s11&gt;&lt;/c10&gt;文をCのものよりも安全で使いやすくして、誤って複数の&lt;c12&gt;&lt;s13&gt;switch&lt;/s13&gt;&lt;/c12&gt;ケース節を実行することを防ぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This matches the single requirement of the &lt;c6&gt;&lt;s7&gt;FullyNamed&lt;/s7&gt;&lt;/c6&gt; protocol, and means that &lt;c8&gt;&lt;s9&gt;Person&lt;/s9&gt;&lt;/c8&gt; has correctly conformed to the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、&lt;c6&gt;&lt;s7&gt;FullyNamed&lt;/s7&gt;&lt;/c6&gt;プロトコルの唯一の要件に適合します、したがってその&lt;c8&gt;&lt;s9&gt;Person&lt;/s9&gt;&lt;/c8&gt;が正しくそのプロトコルに従ったことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This matches the type of the &lt;c2&gt;&lt;s3&gt;shoppingList&lt;/s3&gt;&lt;/c2&gt; variable’s declaration (an array that can only contain &lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt; values), and so the assignment of the array literal is permitted as a way to initialize &lt;c6&gt;&lt;s7&gt;shoppingList&lt;/s7&gt;&lt;/c6&gt; with two initial items.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは&lt;c2&gt;&lt;s3&gt;shoppingList&lt;/s3&gt;&lt;/c2&gt;変数の宣言（&lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt;値を含むことだけができる配列）の型に合致します、それでこの配列リテラルの代入は、２つの最初の項目で&lt;c6&gt;&lt;s7&gt;shoppingList&lt;/s7&gt;&lt;/c6&gt;を初期化するためのやり方として認められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means code like &lt;c10&gt;&lt;s11&gt;protoFlip(protoFlip(smallTriange))&lt;/s11&gt;&lt;/c10&gt; that applies multiple transformations is invalid because the flipped shape isn’t a valid argument to &lt;c12&gt;&lt;s13&gt;protoFlip(_:)&lt;/s13&gt;&lt;/c12&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、複数の変換を適用する&lt;c10&gt;&lt;s11&gt;protoFlip(protoFlip(smallTriange))&lt;/s11&gt;&lt;/c10&gt;のようなコードが無効であることを意味します、なぜなら裏返された形状は&lt;c12&gt;&lt;s13&gt;protoFlip(_:)&lt;/s13&gt;&lt;/c12&gt;への有効な引数ではないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means it is possible to have precedence groups with undefined relative precedence.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これが意味するのは、未定義の関係優先順位による優先順位グループを持つことは可能だということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that &lt;c0&gt;&lt;s1&gt;4.75&lt;/s1&gt;&lt;/c0&gt; becomes &lt;c2&gt;&lt;s3&gt;4&lt;/s3&gt;&lt;/c2&gt;, and &lt;c4&gt;&lt;s5&gt;-3.9&lt;/s5&gt;&lt;/c4&gt; becomes &lt;c6&gt;&lt;s7&gt;-3&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、&lt;c0&gt;&lt;s1&gt;4.75&lt;/s1&gt;&lt;/c0&gt;が&lt;c2&gt;&lt;s3&gt;4&lt;/s3&gt;&lt;/c2&gt;に、そして&lt;c4&gt;&lt;s5&gt;-3.9&lt;/s5&gt;&lt;/c4&gt;が&lt;c6&gt;&lt;s7&gt;-3&lt;/s7&gt;&lt;/c6&gt;になることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that &lt;c2&gt;&lt;s3&gt;SomeInternalClass&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;someInternalConstant&lt;/s5&gt;&lt;/c4&gt; can be written without an explicit access-level modifier, and will still have an access level of internal:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、&lt;c2&gt;&lt;s3&gt;SomeInternalClass&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;someInternalConstant&lt;/s5&gt;&lt;/c4&gt;が明示的なアクセス水準修飾子なしで書かれることができ、それでもまだ内部のアクセス水準を持つことを意味します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that &lt;c4&gt;&lt;s5&gt;a&lt;/s5&gt; &lt;s6&gt;%&lt;/s6&gt; &lt;s7&gt;b&lt;/s7&gt;&lt;/c4&gt; and &lt;c8&gt;&lt;s9&gt;a&lt;/s9&gt; &lt;s10&gt;%&lt;/s10&gt; &lt;s11&gt;-b&lt;/s11&gt;&lt;/c8&gt; always give the same answer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、&lt;c4&gt;&lt;s5&gt;a&lt;/s5&gt; &lt;s6&gt;%&lt;/s6&gt; &lt;s7&gt;b&lt;/s7&gt;&lt;/c4&gt;と&lt;c8&gt;&lt;s9&gt;a&lt;/s9&gt; &lt;s10&gt;%&lt;/s10&gt; &lt;s11&gt;-b&lt;/s11&gt;&lt;/c8&gt;が常に同じ答えを与えることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that a &lt;c2&gt;&lt;s3&gt;defer&lt;/s3&gt;&lt;/c2&gt; statement can be used, for example, to perform manual resource management such as closing file descriptors, and to perform actions that need to happen even if an error is thrown.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは&lt;c2&gt;&lt;s3&gt;defer&lt;/s3&gt;&lt;/c2&gt;文が、例えば、ファイル記述子を閉じることなどの手動リソース管理を実行するために、そしてたとえエラーがスローされるとしても起こることが必要な動作を実行するために使われることができるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that a change to the value of &lt;c8&gt;&lt;s9&gt;a&lt;/s9&gt;&lt;/c8&gt; in the outer scope does not affect the value of &lt;c10&gt;&lt;s11&gt;a&lt;/s11&gt;&lt;/c10&gt; in the inner scope, nor does a change to &lt;c12&gt;&lt;s13&gt;a&lt;/s13&gt;&lt;/c12&gt; inside the closure affect the value of &lt;c14&gt;&lt;s15&gt;a&lt;/s15&gt;&lt;/c14&gt; outside the closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これが意味するのは、外側のスコープの&lt;c8&gt;&lt;s9&gt;a&lt;/s9&gt;&lt;/c8&gt;の値に対する変更は内側のスコープの&lt;c10&gt;&lt;s11&gt;a&lt;/s11&gt;&lt;/c10&gt;の値に影響を及ぼさない、そしてまたクロージャ内部の&lt;c12&gt;&lt;s13&gt;a&lt;/s13&gt;&lt;/c12&gt;に対する変更はクロージャ外部の&lt;c14&gt;&lt;s15&gt;a&lt;/s15&gt;&lt;/c14&gt;に影響を及ぼさないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that a function can return another function as its value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、ある関数が別の関数をその値として返すことができるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that all of the information needed to infer an omitted type or part of a type in an expression must be accessible from type-checking the expression or one of its subexpressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、ある式における省略される型や型の一部分を推論するために必要とされる情報のすべては、型を調べているその式またはそれの下位式の１つからアクセス可能でなければならないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that any structure and enumeration instances you create—and any value types they have as properties—are always copied when they are passed around in your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたがつくるあらゆる構造体や列挙のインスタンス ― そして、それらがプロパティとして持つあらゆる値型 ― は、あなたのコードの中であちこち渡される時に常にコピーされることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that classes have additional responsibilities for ensuring that all stored properties they inherit are assigned a suitable value during initialization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、クラスが、それが継承する全ての格納プロパティが初期化の間に適切な値を代入されることを確実にすることに対する追加の責任を持つことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that code that would otherwise run immediately after the call is never executed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これが意味するのは、そうでなければ呼び出しの直後に動作するコードは、決して実行されないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that different characters—and different representations of the same character—can require different amounts of memory to store.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは異なる文字—さらに同じ文字の異なる表現—が、格納するために異なる量のメモリを必要とすることがあるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that in the example above, &lt;c0&gt;&lt;s1&gt;array3D[0]&lt;/s1&gt;&lt;/c0&gt; refers to &lt;c2&gt;&lt;s3&gt;[[1,&lt;/s3&gt; &lt;s4&gt;2],&lt;/s4&gt; &lt;s5&gt;[3,&lt;/s5&gt; &lt;s6&gt;4]]&lt;/s6&gt;&lt;/c2&gt;, &lt;c7&gt;&lt;s8&gt;array3D[0][1]&lt;/s8&gt;&lt;/c7&gt; refers to &lt;c9&gt;&lt;s10&gt;[3,&lt;/s10&gt; &lt;s11&gt;4]&lt;/s11&gt;&lt;/c9&gt;, and &lt;c12&gt;&lt;s13&gt;array3D[0][1][1]&lt;/s13&gt;&lt;/c12&gt; refers to the value 4.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、上の例で、&lt;c0&gt;&lt;s1&gt;array3D[0]&lt;/s1&gt;&lt;/c0&gt;は&lt;c2&gt;&lt;s3&gt;[[1,&lt;/s3&gt; &lt;s4&gt;2],&lt;/s4&gt; &lt;s5&gt;[3,&lt;/s5&gt; &lt;s6&gt;4]]&lt;/s6&gt;&lt;/c2&gt;に言及し、&lt;c7&gt;&lt;s8&gt;array3D[0][1]&lt;/s8&gt;&lt;/c7&gt;は&lt;c9&gt;&lt;s10&gt;[3,&lt;/s10&gt; &lt;s11&gt;4]&lt;/s11&gt;&lt;/c9&gt;に言及し、そして&lt;c12&gt;&lt;s13&gt;array3D[0][1][1]&lt;/s13&gt;&lt;/c12&gt;は値４に言及することを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that it returns a &lt;e6&gt;function&lt;/e6&gt;, rather than a simple value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、それが&lt;e6&gt;関数&lt;/e6&gt;を返すことを意味します、単純なひとつの値ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that the &lt;c10&gt;&lt;s11&gt;Country&lt;/s11&gt;&lt;/c10&gt; initializer can start to reference and pass around the implicit &lt;c12&gt;&lt;s13&gt;self&lt;/s13&gt;&lt;/c12&gt; property as soon as the &lt;c14&gt;&lt;s15&gt;name&lt;/s15&gt;&lt;/c14&gt; property is set.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは&lt;c10&gt;&lt;s11&gt;Country&lt;/s11&gt;&lt;/c10&gt;イニシャライザが、&lt;c14&gt;&lt;s15&gt;name&lt;/s15&gt;&lt;/c14&gt;プロパティが設定されるとすぐに、暗黙の&lt;c12&gt;&lt;s13&gt;self&lt;/s13&gt;&lt;/c12&gt;プロパティに基づいて参照したり渡したりを可能であるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that the &lt;c6&gt;&lt;s7&gt;capitalCity&lt;/s7&gt;&lt;/c6&gt; property has a default value of &lt;c8&gt;&lt;s9&gt;nil&lt;/s9&gt;&lt;/c8&gt;, like any other optional, but can be accessed without the need to unwrap its value as described in &lt;a10&gt;&lt;s11&gt;Implicitly Unwrapped Optionals&lt;/s11&gt;&lt;/a10&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、&lt;c6&gt;&lt;s7&gt;capitalCity&lt;/s7&gt;&lt;/c6&gt;プロパティが、オプショナルの他のものの様に、&lt;c8&gt;&lt;s9&gt;nil&lt;/s9&gt;&lt;/c8&gt;の省略時の値を持つが、アンラップする必要なしでその値にアクセスされることができることを意味します、&lt;a10&gt;&lt;s11&gt;暗黙的にアンラップされるオプショナル&lt;/s11&gt;&lt;/a10&gt;で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that the &lt;c7&gt;&lt;s8&gt;(String,&lt;/s8&gt; &lt;s9&gt;String)&lt;/s9&gt;&lt;/c7&gt; and &lt;c10&gt;&lt;s11&gt;Bool&lt;/s11&gt;&lt;/c10&gt; types do not need to be written as part of the closure expression’s definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、&lt;c7&gt;&lt;s8&gt;(String,&lt;/s8&gt; &lt;s9&gt;String)&lt;/s9&gt;&lt;/c7&gt;および&lt;c10&gt;&lt;s11&gt;Bool&lt;/s11&gt;&lt;/c10&gt;型が、クロージャ式の定義の一部として書かれる必要がないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that the letter &lt;c12&gt;&lt;s13&gt;"B"&lt;/s13&gt;&lt;/c12&gt; is “greater than” the letter &lt;c14&gt;&lt;s15&gt;"A"&lt;/s15&gt;&lt;/c14&gt;, and the string &lt;c16&gt;&lt;s17&gt;"Tom"&lt;/s17&gt;&lt;/c16&gt; is greater than the string &lt;c18&gt;&lt;s19&gt;"Tim"&lt;/s19&gt;&lt;/c18&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは文字&lt;c12&gt;&lt;s13&gt;"B"&lt;/s13&gt;&lt;/c12&gt;は文字&lt;c14&gt;&lt;s15&gt;"A"&lt;/s15&gt;&lt;/c14&gt;「より大きい」こと、そして文字列&lt;c16&gt;&lt;s17&gt;"Tom"&lt;/s17&gt;&lt;/c16&gt;は文字列&lt;c18&gt;&lt;s19&gt;"Tim"&lt;/s19&gt;&lt;/c18&gt;よりも大きいことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that the value is allowed to outlive the lifetime of the call.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、その値が呼び出しのライフタイムより長生きするのを許されることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that they return a value of &lt;c4&gt;&lt;s5&gt;()&lt;/s5&gt;&lt;/c4&gt;, or an empty tuple.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、それらが値&lt;c4&gt;&lt;s5&gt;()&lt;/s5&gt;&lt;/c4&gt;、または空のタプルを返すことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that when you break the strong reference held by the &lt;c9&gt;&lt;s10&gt;john&lt;/s10&gt;&lt;/c9&gt; variable by setting it to &lt;c11&gt;&lt;s12&gt;nil&lt;/s12&gt;&lt;/c11&gt;, there are no more strong references to the &lt;c13&gt;&lt;s14&gt;Person&lt;/s14&gt;&lt;/c13&gt; instance:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたが&lt;c9&gt;&lt;s10&gt;john&lt;/s10&gt;&lt;/c9&gt;変数によって保持される強い参照を、それを&lt;c11&gt;&lt;s12&gt;nil&lt;/s12&gt;&lt;/c11&gt;に設定することによって壊すとき、&lt;c13&gt;&lt;s14&gt;Person&lt;/s14&gt;&lt;/c13&gt;インスタンスへの強い参照がもうそれ以上ないことを意味します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that you can change (or &lt;e1&gt;mutate&lt;/e1&gt;) the collection after it’s created by adding, removing, or changing items in the collection.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたがコレクションを変更する（または&lt;e1&gt;変化させる&lt;/e1&gt;）ことが、それが作成された後にそのコレクション中の項目を追加、削除、または変更することによって可能なのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that you can extend &lt;c10&gt;&lt;s11&gt;Array&lt;/s11&gt;&lt;/c10&gt; to conform to the &lt;c12&gt;&lt;s13&gt;Container&lt;/s13&gt;&lt;/c12&gt; protocol simply by declaring that &lt;c14&gt;&lt;s15&gt;Array&lt;/s15&gt;&lt;/c14&gt; adopts the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたが&lt;c10&gt;&lt;s11&gt;Array&lt;/s11&gt;&lt;/c10&gt;を拡張して&lt;c12&gt;&lt;s13&gt;Container&lt;/s13&gt;&lt;/c12&gt;プロトコルに準拠することが、&lt;c14&gt;&lt;s15&gt;Array&lt;/s15&gt;&lt;/c14&gt;がそのプロトコルを採用すると宣言することによって可能であることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that you can use &lt;c2&gt;&lt;s3&gt;self&lt;/s3&gt;&lt;/c2&gt; to disambiguate between type properties and type method parameters, just as you do for instance properties and instance method parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはあなたが型プロパティと型メソッドパラメータの間で曖昧さをなくすために&lt;c2&gt;&lt;s3&gt;self&lt;/s3&gt;&lt;/c2&gt;を使うことができることを意味します、ちょうどあなたがインスタンスプロパティとインスタンスメソッドパラメータでするように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that you cannot access any other property values from within your closure, even if those properties have default values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、たとえそれらのプロパティには省略時の値があるとしても、あなたがあなたのクロージャ内から他のどのプロパティ値にもアクセスすることができないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that you cannot insert a value of the wrong type into a collection by mistake.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたが間違った型の値を誤ってあるコレクションの中に入れることが不可能なことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that you can’t accidentally access methods or properties that the class implements in addition to its protocol conformance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、クラスがそれのプロトコル準拠にさらに加えて実装するメソッドやプロパティにあなたが偶然にアクセスすることができないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means that you can’t change the value of a parameter by mistake.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたが誤ってパラメータの値を変えることができないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means there are two write accesses to &lt;c10&gt;&lt;s11&gt;playerInformation&lt;/s11&gt;&lt;/c10&gt; with durations that overlap, causing a conflict.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、２つの書き込みアクセスが&lt;c10&gt;&lt;s11&gt;playerInformation&lt;/s11&gt;&lt;/c10&gt;に対してオーバーラップする期間に存在して、衝突を起こしていることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means you always get great performance when working with strings as value types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、値型として文字列を扱うとき、あなたは常に非常に大きいパフォーマンスを得ることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means you can use as many assertions as you want during your development process, without impacting performance in production.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これが意味するのは、あなたは多くの表明をあなたが望むだけあなたの開発過程の間に使用できる、製品での性能に影響を与えることなしに、ということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means you can use constants to name a value that you determine once but use in many places.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたが一度だけ決定するが多くの場所で使用する値に対して名前をつけるために定数を利用できるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means, if you have a large project that’s divided into multiple frameworks, you can migrate your code from Swift 4 to Swift 5.2 one framework at a time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたが複数のフレームワークへと分割される巨大なプロジェクトを持つならば、あなたはあなたのコードをSwift 4からSwift 5.2へと１度に１フレームワークずつ移行できるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This means, if you import Foundation, you can access those &lt;c8&gt;&lt;s9&gt;NSString&lt;/s9&gt;&lt;/c8&gt; methods on &lt;c10&gt;&lt;s11&gt;String&lt;/s11&gt;&lt;/c10&gt; without casting.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これが意味するのは、あなたがFoundationをインポートするならば、あなたはそれら&lt;c8&gt;&lt;s9&gt;NSString&lt;/s9&gt;&lt;/c8&gt;メソッドに&lt;c10&gt;&lt;s11&gt;String&lt;/s11&gt;&lt;/c10&gt;上でキャストなしでアクセスできるという事です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This memory holds information about the type of the instance, together with the values of any stored properties associated with that instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメモリは、インスタンスの型に関する情報を、そのインスタンスと結びつけられるあらゆる格納プロパティの値と共に持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method calls the generator’s &lt;c4&gt;&lt;s5&gt;random()&lt;/s5&gt;&lt;/c4&gt; method to create a new random number between &lt;c6&gt;&lt;s7&gt;0.0&lt;/s7&gt;&lt;/c6&gt; and &lt;c8&gt;&lt;s9&gt;1.0&lt;/s9&gt;&lt;/c8&gt;, and uses this random number to create a dice roll value within the correct range.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメソッドは、&lt;c6&gt;&lt;s7&gt;0.0&lt;/s7&gt;&lt;/c6&gt;と&lt;c8&gt;&lt;s9&gt;1.0&lt;/s9&gt;&lt;/c8&gt;の間で新しい乱数をつくるgeneratorの&lt;c4&gt;&lt;s5&gt;random()&lt;/s5&gt;&lt;/c4&gt;メソッドを呼んで、この乱数を正しい範囲内でさいころを振った値をつくるために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method checks the properties of the address and returns &lt;c6&gt;&lt;s7&gt;buildingName&lt;/s7&gt;&lt;/c6&gt; if it has a value, or &lt;c8&gt;&lt;s9&gt;buildingNumber&lt;/s9&gt;&lt;/c8&gt; concatenated with &lt;c10&gt;&lt;s11&gt;street&lt;/s11&gt;&lt;/c10&gt; if both have values, or &lt;c12&gt;&lt;s13&gt;nil&lt;/s13&gt;&lt;/c12&gt; otherwise.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメソッドは、アドレスのプロパティを調べて、それが値を持つならば&lt;c6&gt;&lt;s7&gt;buildingName&lt;/s7&gt;&lt;/c6&gt;を、または両方とも値を持つならば&lt;c8&gt;&lt;s9&gt;buildingNumber&lt;/s9&gt;&lt;/c8&gt;に繋げて&lt;c10&gt;&lt;s11&gt;street&lt;/s11&gt;&lt;/c10&gt;を、またはそれ以外では&lt;c12&gt;&lt;s13&gt;nil&lt;/s13&gt;&lt;/c12&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method does not actually do anything for a base &lt;c4&gt;&lt;s5&gt;Vehicle&lt;/s5&gt;&lt;/c4&gt; instance, but will be customized by subclasses of &lt;c6&gt;&lt;s7&gt;Vehicle&lt;/s7&gt;&lt;/c6&gt; later on:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメソッドは実際に何かを基盤&lt;c4&gt;&lt;s5&gt;Vehicle&lt;/s5&gt;&lt;/c4&gt;インスタンスのために行うわけではありません、しかし後で&lt;c6&gt;&lt;s7&gt;Vehicle&lt;/s7&gt;&lt;/c6&gt;のサブクラスによって目的に合わせて作り変えられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method does not specify a return type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメソッドは、戻り型を指定しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method removes the item at the specified index and returns the removed item (although you can ignore the returned value if you do not need it):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメソッドは、指定されたインデックスでの項目を取り除いて、取り除かれた項目を返します（けれども、あなたがそれを必要としないならば、返された値を無視することができます）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method removes the key-value pair if it exists and returns the removed value, or returns &lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt; if no value existed:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメソッドは、それが存在するならば「キーと値」の対を削除して、削除された値を返します、または値が存在しないならば&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method returns a value of type &lt;c4&gt;&lt;s5&gt;String?&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメソッドは、型&lt;c4&gt;&lt;s5&gt;String?&lt;/s5&gt;&lt;/c4&gt;の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method unlocks the next level for all players and updates the player’s progress to move them to the next level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメソッドは、全てのプレーヤーたちのために次のレベルの錠をあけて、プレーヤーの進捗をかれらを次のレベルへ移動するために更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This might be a description of itself, or a text version of its current state:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、それ自身の説明、またはテキスト版のそれの現在の状態であるかもしれません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This might be because a &lt;c4&gt;&lt;s5&gt;DataImporter&lt;/s5&gt;&lt;/c4&gt; instance needs to open a file and read its contents into memory when the &lt;c6&gt;&lt;s7&gt;DataImporter&lt;/s7&gt;&lt;/c6&gt; instance is initialized.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、&lt;c4&gt;&lt;s5&gt;DataImporter&lt;/s5&gt;&lt;/c4&gt;インスタンスが初期化されるとき、&lt;c6&gt;&lt;s7&gt;DataImporter&lt;/s7&gt;&lt;/c6&gt;インスタンスがファイルを開いてメモリーにその内容を読む必要があるからでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This modification tracking is implemented with a &lt;c10&gt;&lt;s11&gt;didSet&lt;/s11&gt;&lt;/c10&gt; property observer on the &lt;c12&gt;&lt;s13&gt;value&lt;/s13&gt;&lt;/c12&gt; property, which increments &lt;c14&gt;&lt;s15&gt;numberOfEdits&lt;/s15&gt;&lt;/c14&gt; every time the &lt;c16&gt;&lt;s17&gt;value&lt;/s17&gt;&lt;/c16&gt; property is set to a new value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この修正追跡は、&lt;c10&gt;&lt;s11&gt;didSet&lt;/s11&gt;&lt;/c10&gt;プロパティオブザーバーとして&lt;c12&gt;&lt;s13&gt;value&lt;/s13&gt;&lt;/c12&gt;プロパティ上で実行されます、それは、&lt;c14&gt;&lt;s15&gt;numberOfEdits&lt;/s15&gt;&lt;/c14&gt;を&lt;c16&gt;&lt;s17&gt;value&lt;/s17&gt;&lt;/c16&gt;プロパティが新しい値に設定されるたびに増加させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This new &lt;c0&gt;&lt;s1&gt;isTop(_:)&lt;/s1&gt;&lt;/c0&gt; method first checks that the stack isn’t empty, and then compares the given item against the stack’s topmost item.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この新しい&lt;c0&gt;&lt;s1&gt;isTop(_:)&lt;/s1&gt;&lt;/c0&gt;メソッドは、まずスタックが空でないことを確認します、それから与えられた項目をスタックの持つ最も上の項目と比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This new &lt;c2&gt;&lt;s3&gt;startsWith(_:)&lt;/s3&gt;&lt;/c2&gt; method can be used with any type that conforms to the &lt;c4&gt;&lt;s5&gt;Container&lt;/s5&gt;&lt;/c4&gt; protocol, including the stacks and arrays used above, as long as the container’s items are equatable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この新しい&lt;c2&gt;&lt;s3&gt;startsWith(_:)&lt;/s3&gt;&lt;/c2&gt;メソッドは&lt;c4&gt;&lt;s5&gt;Container&lt;/s5&gt;&lt;/c4&gt;プロトコルに準拠するあらゆる型で使われることができます、上で使われるスタックと配列を含めて、コンテナの持つ項目が同等評価可能である限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This new default can still be overridden within the extension for individual type members.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この新しい省略時設定はさらに、個々の型メンバーのために拡張内でオーバーライドされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This new initializer starts by calculating an appropriate origin point based on the provided &lt;c0&gt;&lt;s1&gt;center&lt;/s1&gt;&lt;/c0&gt; point and &lt;c2&gt;&lt;s3&gt;size&lt;/s3&gt;&lt;/c2&gt; value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この新しいイニシャライザは、提供された&lt;c0&gt;&lt;s1&gt;center&lt;/s1&gt;&lt;/c0&gt;点と&lt;c2&gt;&lt;s3&gt;size&lt;/s3&gt;&lt;/c2&gt;値に基づいて適切な起源点を計算することによって始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This next code snippet defines an optional &lt;c0&gt;&lt;s1&gt;Customer&lt;/s1&gt;&lt;/c0&gt; variable called &lt;c2&gt;&lt;s3&gt;john&lt;/s3&gt;&lt;/c2&gt;, which will be used to store a reference to a specific customer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次のコード断片は、&lt;c2&gt;&lt;s3&gt;john&lt;/s3&gt;&lt;/c2&gt;と呼ばれる、オプショナルの&lt;c0&gt;&lt;s1&gt;Customer&lt;/s1&gt;&lt;/c0&gt;変数を定義します。それは、特定の顧客への参照を格納するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This next code snippet defines two variables of optional type called &lt;c0&gt;&lt;s1&gt;john&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;unit4A&lt;/s3&gt;&lt;/c2&gt;, which will be set to a specific &lt;c4&gt;&lt;s5&gt;Apartment&lt;/s5&gt;&lt;/c4&gt; and &lt;c6&gt;&lt;s7&gt;Person&lt;/s7&gt;&lt;/c6&gt; instance below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この次のコード断片は&lt;c0&gt;&lt;s1&gt;john&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;unit4A&lt;/s3&gt;&lt;/c2&gt;と呼ばれるオプショナルの型の２つの変数を定義します、それは、特定の&lt;c4&gt;&lt;s5&gt;Apartment&lt;/s5&gt;&lt;/c4&gt;と&lt;c6&gt;&lt;s7&gt;Person&lt;/s7&gt;&lt;/c6&gt;インスタンスに以降で設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This next example shows a class called &lt;c0&gt;&lt;s1&gt;DiceGameTracker&lt;/s1&gt;&lt;/c0&gt;, which adopts the &lt;c2&gt;&lt;s3&gt;DiceGameDelegate&lt;/s3&gt;&lt;/c2&gt; protocol:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この次の例は&lt;c0&gt;&lt;s1&gt;DiceGameTracker&lt;/s1&gt;&lt;/c0&gt;と呼ばれるクラスを示します、それは、&lt;c2&gt;&lt;s3&gt;DiceGameDelegate&lt;/s3&gt;&lt;/c2&gt;プロトコルを採用します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This number is then shifted 16 places to the right (&lt;c0&gt;&lt;s1&gt;&gt;&gt;&lt;/s1&gt; &lt;s2&gt;16&lt;/s2&gt;&lt;/c0&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この数は、それから右に16桁シフトされます（&lt;c0&gt;&lt;s1&gt;&gt;&gt;&lt;/s1&gt; &lt;s2&gt;16&lt;/s2&gt;&lt;/c0&gt;）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This observer performs two checks:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このオブザーバーは、２つのチェックをします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This operator adds together the &lt;c0&gt;&lt;s1&gt;x&lt;/s1&gt;&lt;/c0&gt; values of two vectors, and subtracts the &lt;c2&gt;&lt;s3&gt;y&lt;/s3&gt;&lt;/c2&gt; value of the second vector from the first.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この演算子は、２つのベクトルの&lt;c0&gt;&lt;s1&gt;x&lt;/s1&gt;&lt;/c0&gt;値を一緒に加えて、第二のベクトルの&lt;c2&gt;&lt;s3&gt;y&lt;/s3&gt;&lt;/c2&gt;値を最初のものから減じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This operator does not have an existing meaning in Swift, and so it is given its own custom meaning below in the specific context of working with &lt;c2&gt;&lt;s3&gt;Vector2D&lt;/s3&gt;&lt;/c2&gt; instances.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この演算子は、スウィフトにおいて既存の意味を持ちません、なので、それは&lt;c2&gt;&lt;s3&gt;Vector2D&lt;/s3&gt;&lt;/c2&gt;インスタンスを扱う特定の文脈の下で、独自のあつらえの意味を与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This opt-in approach prevents hidden conversion errors and helps make type conversion intentions explicit in your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このオプトインの（個々に決めていく）取り組み方は、隠された変換エラーを防いで、あなたのコードにおいて型変換の意図を明確にするのを助けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This optional binding is written “&lt;c6&gt;&lt;s7&gt;if&lt;/s7&gt; &lt;s8&gt;let&lt;/s8&gt; &lt;s9&gt;movie&lt;/s9&gt; &lt;s10&gt;=&lt;/s10&gt; &lt;s11&gt;item&lt;/s11&gt; &lt;s12&gt;as?&lt;/s12&gt; &lt;s13&gt;Movie&lt;/s13&gt;&lt;/c6&gt;”, which can be read as:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このオプショナル束縛は「&lt;c6&gt;&lt;s7&gt;if&lt;/s7&gt; &lt;s8&gt;let&lt;/s8&gt; &lt;s9&gt;movie&lt;/s9&gt; &lt;s10&gt;=&lt;/s10&gt; &lt;s11&gt;item&lt;/s11&gt; &lt;s12&gt;as?&lt;/s12&gt; &lt;s13&gt;Movie&lt;/s13&gt;&lt;/c6&gt;」のように書かれます、それは、次のように解釈されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This optional value contains the old value for that key if one existed before the update, or &lt;c8&gt;&lt;s9&gt;nil&lt;/s9&gt;&lt;/c8&gt; if no value existed:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このオプショナルの値は、それが更新の前に存在するならばそのキーに対する古い値を、値が存在しないならば&lt;c8&gt;&lt;s9&gt;nil&lt;/s9&gt;&lt;/c8&gt;を含みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This output value is then shifted eight places to the right, giving a value of &lt;c6&gt;&lt;s7&gt;0x66&lt;/s7&gt;&lt;/c6&gt;, which has a decimal value of &lt;c8&gt;&lt;s9&gt;102&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この出力値は、それから８桁右にシフトされて、&lt;c6&gt;&lt;s7&gt;0x66&lt;/s7&gt;&lt;/c6&gt;の値を与えます、それは10進の値の&lt;c8&gt;&lt;s9&gt;102&lt;/s9&gt;&lt;/c8&gt;を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This part of the book describes the formal grammar of the Swift programming language.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>本のこの部分は、スウィフトプログラミング言語の形式文法を記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This performance optimization means you don’t have to pay the performance cost of copying memory until you modify either the string or substring.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この性能最適化が意味するのは、あなたがメモリをコピーする性能経費を、あなたが文字列か下位文字列のどちらかを修正するまでは払う必要がないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This placeholder is replaced with the actual value of &lt;c4&gt;&lt;s5&gt;multiplier&lt;/s5&gt;&lt;/c4&gt; when the string interpolation is evaluated to create an actual string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプレースホルダーは、文字列補間が実際の文字列を作成するために評価されるとき、&lt;c4&gt;&lt;s5&gt;multiplier&lt;/s5&gt;&lt;/c4&gt;の実際の値と取り替えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This procedure is known as &lt;e6&gt;switching&lt;/e6&gt; on the value that is being considered.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この手順は、考察されている値での&lt;e6&gt;切り替え（スイッチング）&lt;/e6&gt;として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This process continues until the end of the range is reached.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この過程は、範囲の終わりに達するまで続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This process involves setting an initial value for each stored property on that instance and performing any other setup or initialization that is required before the new instance is ready for use.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この過程は、そのインスタンスの格納プロパティそれぞれに初期値を設定すること、および新しいインスタンスの使用準備が整う前に必要とされる他のあらゆる設定や初期化を行うことを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This process is described in &lt;a0&gt;&lt;s1&gt;Resolving Strong Reference Cycles Between Class Instances&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この過程は、&lt;a0&gt;&lt;s1&gt;クラスインスタンス間の強い参照循環の解消&lt;/s1&gt;&lt;/a0&gt;で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This process is described in &lt;a5&gt;&lt;s6&gt;Modifying Value Types from Within Instance Methods&lt;/s6&gt;&lt;/a5&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この過程は、&lt;a5&gt;&lt;s6&gt;値型をインスタンスメソッド内から修正する&lt;/s6&gt;&lt;/a5&gt;で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This process is described in &lt;a6&gt;&lt;s7&gt;Working with Characters&lt;/s7&gt;&lt;/a6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このやり方は&lt;a6&gt;&lt;s7&gt;文字を扱う&lt;/s7&gt;&lt;/a6&gt;で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This process satisfies safety check 1 from &lt;a20&gt;&lt;s21&gt;Two-Phase Initialization&lt;/s21&gt;&lt;/a20&gt; above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この過程は、上記の&lt;a20&gt;&lt;s21&gt;２段階初期化&lt;/s21&gt;&lt;/a20&gt;の安全点検１を満たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This process transforms it into the tree (2 + (3 * 5)).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この処理は、それをツリー(2 + (3 * 5))に変えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This process, known as &lt;e0&gt;initializer delegation&lt;/e0&gt;, avoids duplicating code across multiple initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この処理、&lt;e0&gt;イニシャライザ委任&lt;/e0&gt;として知られるものは、複数のイニシャライザにまたがってコードを繰り返し複製することを避けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This property is of type &lt;c4&gt;&lt;s5&gt;String.UTF16View&lt;/s5&gt;&lt;/c4&gt;, which is a collection of unsigned 16-bit (&lt;c6&gt;&lt;s7&gt;UInt16&lt;/s7&gt;&lt;/c6&gt;) values, one for each 16-bit code unit in the string’s UTF-16 representation:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロパティは型&lt;c4&gt;&lt;s5&gt;String.UTF16View&lt;/s5&gt;&lt;/c4&gt;です、そしてそれは、符号なし16ビット（&lt;c6&gt;&lt;s7&gt;UInt16&lt;/s7&gt;&lt;/c6&gt;）の値の集まりで、そのひとつがその文字列のUTF-16叙述における各16ビット符号単位です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This property is of type &lt;c4&gt;&lt;s5&gt;String.UTF8View&lt;/s5&gt;&lt;/c4&gt;, which is a collection of unsigned 8-bit (&lt;c6&gt;&lt;s7&gt;UInt8&lt;/s7&gt;&lt;/c6&gt;) values, one for each byte in the string’s UTF-8 representation:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロパティは型&lt;c4&gt;&lt;s5&gt;String.UTF8View&lt;/s5&gt;&lt;/c4&gt;です、そしてそれは、符号なし８ビット（&lt;c6&gt;&lt;s7&gt;UInt8&lt;/s7&gt;&lt;/c6&gt;）の値の集まりで、それぞれがその文字列のUTF-８叙述における各バイトです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This property is of type &lt;c4&gt;&lt;s5&gt;UnicodeScalarView&lt;/s5&gt;&lt;/c4&gt;, which is a collection of values of type &lt;c6&gt;&lt;s7&gt;UnicodeScalar&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロパティは型&lt;c4&gt;&lt;s5&gt;UnicodeScalarView&lt;/s5&gt;&lt;/c4&gt;です、そしてそれは、&lt;c6&gt;&lt;s7&gt;UnicodeScalar&lt;/s7&gt;&lt;/c6&gt;型の値の集まりです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This property references a closure that combines &lt;c4&gt;&lt;s5&gt;name&lt;/s5&gt;&lt;/c4&gt; and &lt;c6&gt;&lt;s7&gt;text&lt;/s7&gt;&lt;/c6&gt; into an HTML string fragment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロパティは、&lt;c4&gt;&lt;s5&gt;name&lt;/s5&gt;&lt;/c4&gt;と&lt;c6&gt;&lt;s7&gt;text&lt;/s7&gt;&lt;/c6&gt;をHTML文字列断片に結合するクロージャに参照をつけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This protocol doesn’t specify how the items in the container should be stored or what type they’re allowed to be.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルは、コンテナの中の項目が格納されなければならない方法やそれらが許される型が何であるかを指定しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This protocol, &lt;c0&gt;&lt;s1&gt;RandomNumberGenerator&lt;/s1&gt;&lt;/c0&gt;, requires any conforming type to have an instance method called &lt;c2&gt;&lt;s3&gt;random&lt;/s3&gt;&lt;/c2&gt;, which returns a &lt;c4&gt;&lt;s5&gt;Double&lt;/s5&gt;&lt;/c4&gt; value whenever it’s called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコル、&lt;c0&gt;&lt;s1&gt;RandomNumberGenerator&lt;/s1&gt;&lt;/c0&gt;は、あらゆる準拠型に&lt;c2&gt;&lt;s3&gt;random&lt;/s3&gt;&lt;/c2&gt;と呼ばれるインスタンスメソッドを持つことを要求します、それは、それが呼ばれた時はいつでもある&lt;c4&gt;&lt;s5&gt;Double&lt;/s5&gt;&lt;/c4&gt;値を返すものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This provides a syntactically convenient way to defer the evaluation of an expression without needing to write an explicit closure when you call the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、あなたがその関数を呼び出す時に明示的なクロージャを書く必要なしに、ある式の評価を延期する統語的に便利な方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This provision ensures that the &lt;c16&gt;&lt;s17&gt;switch&lt;/s17&gt;&lt;/c16&gt; statement is exhaustive.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この条項は、&lt;c16&gt;&lt;s17&gt;switch&lt;/s17&gt;&lt;/c16&gt;文が網羅的であることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This public-facing interface is the application programming interface (or API) for the framework.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この公開向けインタフェースは、フレームワークのためのアプリケーション・プログラミング・インタフェース（またはAPI）です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This pushes its binary representation just over the size that a &lt;c12&gt;&lt;s13&gt;UInt8&lt;/s13&gt;&lt;/c12&gt; can hold, causing it to overflow beyond its bounds, as shown in the diagram below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、そのバイナリの表現をちょうど&lt;c12&gt;&lt;s13&gt;UInt8&lt;/s13&gt;&lt;/c12&gt;が持つことができる大きさ以上に押し広げて、それを、下の図で示すように、その境界を越えてあふれさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This relationship has the potential to create a strong reference cycle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関係は、強い参照循環をつくる可能性を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This requests the sixth entry in the three-times-table, which returns a value of &lt;c4&gt;&lt;s5&gt;18&lt;/s5&gt;&lt;/c4&gt;, or &lt;c6&gt;&lt;s7&gt;3&lt;/s7&gt;&lt;/c6&gt; times &lt;c8&gt;&lt;s9&gt;6&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは九九の３の段において６番目の部分を要請します、それは値&lt;c4&gt;&lt;s5&gt;18&lt;/s5&gt;&lt;/c4&gt;、つまり&lt;c6&gt;&lt;s7&gt;3&lt;/s7&gt;&lt;/c6&gt;掛ける&lt;c8&gt;&lt;s9&gt;6&lt;/s9&gt;&lt;/c8&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This requirement ensures that the public-facing API for a type is something you opt in to publishing, and avoids presenting the internal workings of a type as public API by mistake.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この要件は、ある型のための公開向けAPIがあなたが公開するように選ぶ何かであることを確実にして、ある型の内部の働きを誤って公開のAPIとして公表することを避けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This requirement is enforced by a type constraint on the key type for &lt;c0&gt;&lt;s1&gt;Dictionary&lt;/s1&gt;&lt;/c0&gt;, which specifies that the key type must conform to the &lt;c2&gt;&lt;s3&gt;Hashable&lt;/s3&gt;&lt;/c2&gt; protocol, a special protocol defined in the Swift standard library.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この要件は、&lt;c0&gt;&lt;s1&gt;Dictionary&lt;/s1&gt;&lt;/c0&gt;のためのキー型に関する型制約によって強制されます、それは、キー型がスウィフト標準ライブラリで定義される特別なプロトコル、&lt;c2&gt;&lt;s3&gt;Hashable&lt;/s3&gt;&lt;/c2&gt;プロトコルに準拠しなければならないことを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This requirement is expressed through a combination of type constraints and a generic &lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt; clause:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この要件は、型制約と総称体&lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt;節の組合せによって表されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This restriction helps Swift perform more of its checks for conflicting access to memory at compile time instead of at runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この規制は、スウィフトが実行時ではなくコンパイル時にメモリへのアクセスの衝突についてより多くのそれの検査を実行する助けとなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This restriction is demonstrated in the example below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この制限は、下の例において実演されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This restriction protects the implementation details of the &lt;c3&gt;&lt;s4&gt;TrackedString&lt;/s4&gt;&lt;/c3&gt; edit-tracking functionality, while still providing convenient access to an aspect of that functionality.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この制限は、&lt;c3&gt;&lt;s4&gt;TrackedString&lt;/s4&gt;&lt;/c3&gt;編集追跡機能性の実装詳細を保護します、その一方でその機能性の一面への便利なアクセスを依然として提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This rule also applies to type aliases for associated types used to satisfy protocol conformances.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この規則はまた、プロトコル準拠を満たすために使われる関連型のための型エイリアスにも適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This rule applies to stored properties as well as computed properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この規則は、格納プロパティに、それだけでなく計算プロパティにも適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This rule pertains even though type property requirements can be prefixed with the &lt;c2&gt;&lt;s3&gt;class&lt;/s3&gt;&lt;/c2&gt; or &lt;c4&gt;&lt;s5&gt;static&lt;/s5&gt;&lt;/c4&gt; keyword when implemented by a class:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえ型プロパティ要件がクラスによって実装されるとき&lt;c2&gt;&lt;s3&gt;class&lt;/s3&gt;&lt;/c2&gt;または&lt;c4&gt;&lt;s5&gt;static&lt;/s5&gt;&lt;/c4&gt;キーワードを前に置かれるとしても、この規則は当てはまります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This satisfies rules 2 and 3 from above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、上記の規則２と３を満たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This scenario is best resolved with a weak reference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この筋書きは、弱い参照で最もよく解消されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This scenario is best resolved with an unowned reference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この筋書きは、非所有参照で最もよく解消されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This section shows you how to set up such a relationship.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この節は、あなたにそのような関係を設定する方法を教えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This section shows you how to write a generic collection type called &lt;c0&gt;&lt;s1&gt;Stack&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この節は、あなたに&lt;c0&gt;&lt;s1&gt;Stack&lt;/s1&gt;&lt;/c0&gt;と呼ばれる総称体コレクション型を書く方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This simplified syntax lets you omit an optional pattern.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この簡略化された構文は、あなたにあるオプショナルパターンを省略させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This sort of operator usually takes arguments of type &lt;c6&gt;&lt;s7&gt;Self&lt;/s7&gt;&lt;/c6&gt;, matching whatever concrete type adopts the protocol, but adding a &lt;c8&gt;&lt;s9&gt;Self&lt;/s9&gt;&lt;/c8&gt; requirement to the protocol doesn’t allow for the type erasure that happens when you use the protocol as a type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この種の演算子は通常は、どんな具象型がそのプロトコルを採用しても合う、型&lt;c6&gt;&lt;s7&gt;Self&lt;/s7&gt;&lt;/c6&gt;の引数を取ります、しかし&lt;c8&gt;&lt;s9&gt;Self&lt;/s9&gt;&lt;/c8&gt;要件をプロトコルに加えることは型消去を想定しません、それはあなたがプロトコルをひとつの型として使う場合に予期せず起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This square is represented by the blue square in the diagram below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この正方形は、下の図において青い正方形で表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This statement consists of the &lt;c2&gt;&lt;s3&gt;defer&lt;/s3&gt;&lt;/c2&gt; keyword and the statements to be executed later.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この文は、&lt;c2&gt;&lt;s3&gt;defer&lt;/s3&gt;&lt;/c2&gt;キーワードと後で実行される文から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This statement lets you do any necessary cleanup that should be performed regardless of &lt;e2&gt;how&lt;/e2&gt; execution leaves the current block of code—whether it leaves because an error was thrown or because of a statement such as &lt;c3&gt;&lt;s4&gt;return&lt;/s4&gt;&lt;/c3&gt; or &lt;c5&gt;&lt;s6&gt;break&lt;/s6&gt;&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この文は、あなたに何らかの不可欠なクリーンアップを行わせます、それは&lt;e2&gt;どうやって&lt;/e2&gt;実行が現在のコードブロックから離れるか ― それがエラーがスローされたためにまたは&lt;c3&gt;&lt;s4&gt;return&lt;/s4&gt;&lt;/c3&gt;または&lt;c5&gt;&lt;s6&gt;break&lt;/s6&gt;&lt;/c5&gt;のような文を理由に離れるかどうかに関係なく実行されるべきものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This strong reference cycle occurs because closures, like classes, are &lt;e0&gt;reference types&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この強い参照循環は、クロージャが、クラスの様に&lt;e0&gt;参照型&lt;/e0&gt;であるために起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This structure also has a read-only computed property called &lt;c8&gt;&lt;s9&gt;volume&lt;/s9&gt;&lt;/c8&gt;, which calculates and returns the current volume of the cuboid.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この構造体はまた、&lt;c8&gt;&lt;s9&gt;volume&lt;/s9&gt;&lt;/c8&gt;と呼ばれる読み出し専用の計算プロパティを持ちます、それは、現在の立方体の体積を計算して、返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This structure encapsulates the fact that most cards have one value, but the Ace card has two values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この構造体は、大部分のカードが１つの値を持つという事実をカプセル化します、しかし「エース」カードは２つの値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This structure has two stored properties called &lt;c2&gt;&lt;s3&gt;width&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;height&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この構造体は、２つの格納プロパティ、&lt;c2&gt;&lt;s3&gt;width&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;height&lt;/s5&gt;&lt;/c4&gt;と呼ばれるものを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This structure uses an &lt;c0&gt;&lt;s1&gt;Array&lt;/s1&gt;&lt;/c0&gt; property called &lt;c2&gt;&lt;s3&gt;items&lt;/s3&gt;&lt;/c2&gt; to store the values in the stack.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この構造体は、&lt;c2&gt;&lt;s3&gt;items&lt;/s3&gt;&lt;/c2&gt;と呼ばれる&lt;c0&gt;&lt;s1&gt;Array&lt;/s1&gt;&lt;/c0&gt;プロパティを使って値をスタックに格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This subscript &lt;c2&gt;&lt;s3&gt;[n]&lt;/s3&gt;&lt;/c2&gt; returns the decimal digit &lt;c4&gt;&lt;s5&gt;n&lt;/s5&gt;&lt;/c4&gt; places in from the right of the number:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この添え字&lt;c2&gt;&lt;s3&gt;[n]&lt;/s3&gt;&lt;/c2&gt;は、右の数からの10進桁&lt;c4&gt;&lt;s5&gt;n&lt;/s5&gt;&lt;/c4&gt;位置を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This subscript setting attempt also fails, because &lt;c0&gt;&lt;s1&gt;residence&lt;/s1&gt;&lt;/c0&gt; is currently &lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この添え字設定の試みはまた失敗します、なぜなら&lt;c0&gt;&lt;s1&gt;residence&lt;/s1&gt;&lt;/c0&gt;が現在&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This syntactic convenience lets you omit braces around a function’s parameter by writing a normal expression instead of an explicit closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この統語上の便宜は、明示的なクロージャの代わりに通常の関数を書くことによって、あなたに関数のパラメータのまわりの波括弧を省略させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This syntax is the most general way to use a property wrapper.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この構文は、プロバティラッパーを使う最も一般的な方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This tag contains the optional &lt;c2&gt;&lt;s3&gt;text&lt;/s3&gt;&lt;/c2&gt; value if it exists, or no text content if &lt;c4&gt;&lt;s5&gt;text&lt;/s5&gt;&lt;/c4&gt; does not exist.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このタグは、それが存在するならばオプショナルの&lt;c2&gt;&lt;s3&gt;text&lt;/s3&gt;&lt;/c2&gt;値を、あるいは&lt;c4&gt;&lt;s5&gt;text&lt;/s5&gt;&lt;/c4&gt;が存在しないならば、無いテキスト内容を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This tells Swift to execute the closure immediately.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、スウィフトにこのクロージャを直ちに実行するように言います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This tells Swift to “chain” on the optional &lt;c0&gt;&lt;s1&gt;residence&lt;/s1&gt;&lt;/c0&gt; property and to retrieve the value of &lt;c2&gt;&lt;s3&gt;numberOfRooms&lt;/s3&gt;&lt;/c2&gt; if &lt;c4&gt;&lt;s5&gt;residence&lt;/s5&gt;&lt;/c4&gt; exists.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはスウィフトに、オプショナルの&lt;c0&gt;&lt;s1&gt;residence&lt;/s1&gt;&lt;/c0&gt;プロパティの上に「繋げて」、そして&lt;c4&gt;&lt;s5&gt;residence&lt;/s5&gt;&lt;/c4&gt;が存在するならば&lt;c2&gt;&lt;s3&gt;numberOfRooms&lt;/s3&gt;&lt;/c2&gt;の値を取り出すように言います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This time around, the &lt;c4&gt;&lt;s5&gt;Apartment&lt;/s5&gt;&lt;/c4&gt; type’s &lt;c6&gt;&lt;s7&gt;tenant&lt;/s7&gt;&lt;/c6&gt; property is declared as a weak reference:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>今度は、&lt;c4&gt;&lt;s5&gt;Apartment&lt;/s5&gt;&lt;/c4&gt;型の&lt;c6&gt;&lt;s7&gt;tenant&lt;/s7&gt;&lt;/c6&gt;プロパティは、弱い参照として宣言されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This time around, the game has an extra rule:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このたびは、このゲームは特別な規則を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This time, however, the associated values are extracted as part of the switch statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>今度は、しかし、関連値がスイッチ文の一部として抽出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This time, the &lt;c2&gt;&lt;s3&gt;Residence&lt;/s3&gt;&lt;/c2&gt; class defines a variable property called &lt;c4&gt;&lt;s5&gt;rooms&lt;/s5&gt;&lt;/c4&gt;, which is initialized with an empty array of type &lt;c6&gt;&lt;s7&gt;[Room]&lt;/s7&gt;&lt;/c6&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>今度は、&lt;c2&gt;&lt;s3&gt;Residence&lt;/s3&gt;&lt;/c2&gt;クラスは&lt;c4&gt;&lt;s5&gt;rooms&lt;/s5&gt;&lt;/c4&gt;と呼ばれる変数プロパティを定義します、それは、型&lt;c6&gt;&lt;s7&gt;[Room]&lt;/s7&gt;&lt;/c6&gt;の空の配列で初期化されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This time, the capture of &lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt; by the closure is an unowned reference, and does not keep a strong hold on the &lt;c2&gt;&lt;s3&gt;HTMLElement&lt;/s3&gt;&lt;/c2&gt; instance it has captured.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>今度は、クロージャによる&lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;の捕獲は非所有参照であって、それが捕獲している&lt;c2&gt;&lt;s3&gt;HTMLElement&lt;/s3&gt;&lt;/c2&gt;インスタンスに対する強い支配力を保ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This time, the sign bit is &lt;c0&gt;&lt;s1&gt;1&lt;/s1&gt;&lt;/c0&gt; (meaning “negative”), and the seven value bits have a binary value of &lt;c2&gt;&lt;s3&gt;124&lt;/s3&gt;&lt;/c2&gt; (which is &lt;c4&gt;&lt;s5&gt;128&lt;/s5&gt; &lt;s6&gt;-&lt;/s6&gt; &lt;s7&gt;4&lt;/s7&gt;&lt;/c4&gt;):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>今度は、符号ビットは&lt;c0&gt;&lt;s1&gt;1&lt;/s1&gt;&lt;/c0&gt;です（「負」を意味します）、そして、７つの値ビットは２進数の値の&lt;c2&gt;&lt;s3&gt;124&lt;/s3&gt;&lt;/c2&gt;を持ちます（それは、&lt;c4&gt;&lt;s5&gt;128&lt;/s5&gt; &lt;s6&gt;-&lt;/s6&gt; &lt;s7&gt;4&lt;/s7&gt;&lt;/c4&gt;です）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This time, the type parameter &lt;c0&gt;&lt;s1&gt;Element&lt;/s1&gt;&lt;/c0&gt; is used as the type of the &lt;c2&gt;&lt;s3&gt;append(_:)&lt;/s3&gt;&lt;/c2&gt; method’s &lt;c4&gt;&lt;s5&gt;item&lt;/s5&gt;&lt;/c4&gt; parameter and the return type of the subscript.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>今度は、型パラメータ&lt;c0&gt;&lt;s1&gt;Element&lt;/s1&gt;&lt;/c0&gt;が、&lt;c2&gt;&lt;s3&gt;append(_:)&lt;/s3&gt;&lt;/c2&gt;メソッドの&lt;c4&gt;&lt;s5&gt;item&lt;/s5&gt;&lt;/c4&gt;パラメータの型および添え字の戻り型として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This tour gives you enough information to start writing code in Swift by showing you how to accomplish a variety of programming tasks.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このツアーはあなたにスウィフトでコードを書き始めるのに十分な情報を、どうやって様々なプログラミング作業を達成するかをあなたに示すことによって提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This type parameter is written within a pair of angle brackets (&lt;c6&gt;&lt;s7&gt;&lt;Element&gt;&lt;/s7&gt;&lt;/c6&gt;) immediately after the structure’s name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この型パラメータは、構造体の名前の直後に一対の山形括弧の内部で（&lt;c6&gt;&lt;s7&gt;&lt;Element&gt;&lt;/s7&gt;&lt;/c6&gt;）書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This value is stored in a type property called &lt;c2&gt;&lt;s3&gt;highestUnlockedLevel&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この値は、&lt;c2&gt;&lt;s3&gt;highestUnlockedLevel&lt;/s3&gt;&lt;/c2&gt;と呼ばれる型プロパティに格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This variable has an initial value of nil, by virtue of being optional:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルであるおかげで、この変数はnilの初期値を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This variable is initialized with a value of &lt;c4&gt;&lt;s5&gt;0&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この変数は、値&lt;c4&gt;&lt;s5&gt;0&lt;/s5&gt;&lt;/c4&gt;で初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This version is adapted to use a &lt;c3&gt;&lt;s4&gt;Dice&lt;/s4&gt;&lt;/c3&gt; instance for its dice-rolls; to adopt the &lt;c5&gt;&lt;s6&gt;DiceGame&lt;/s6&gt;&lt;/c5&gt; protocol; and to notify a &lt;c7&gt;&lt;s8&gt;DiceGameDelegate&lt;/s8&gt;&lt;/c7&gt; about its progress:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この版は改変され、それにより、それのさいころ振りに&lt;c3&gt;&lt;s4&gt;Dice&lt;/s4&gt;&lt;/c3&gt;インスタンスを使用します；&lt;c5&gt;&lt;s6&gt;DiceGame&lt;/s6&gt;&lt;/c5&gt;プロトコルを採用します；そして、その進歩について&lt;c7&gt;&lt;s8&gt;DiceGameDelegate&lt;/s8&gt;&lt;/c7&gt;に通知します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This version of &lt;c0&gt;&lt;s1&gt;Residence&lt;/s1&gt;&lt;/c0&gt; also provides a method called &lt;c2&gt;&lt;s3&gt;printNumberOfRooms&lt;/s3&gt;&lt;/c2&gt;, which simply prints the number of rooms in the residence.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Residence&lt;/s1&gt;&lt;/c0&gt;のこの版も&lt;c2&gt;&lt;s3&gt;printNumberOfRooms&lt;/s3&gt;&lt;/c2&gt;と呼ばれるメソッドを提供します、それは、単にその住居の部屋数を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This version of &lt;c0&gt;&lt;s1&gt;protoFlip(_:)&lt;/s1&gt;&lt;/c0&gt; has the same body as &lt;c2&gt;&lt;s3&gt;flip(_:)&lt;/s3&gt;&lt;/c2&gt;, and it always returns a value of the same type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このバージョンの&lt;c0&gt;&lt;s1&gt;protoFlip(_:)&lt;/s1&gt;&lt;/c0&gt;は、&lt;c2&gt;&lt;s3&gt;flip(_:)&lt;/s3&gt;&lt;/c2&gt;と同じ本文を持ちます、そしてそれは常に同じ型の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This version of the &lt;c0&gt;&lt;s1&gt;Shape&lt;/s1&gt;&lt;/c0&gt; class is missing something important: an initializer to set up the class when an instance is created.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Shape&lt;/s1&gt;&lt;/c0&gt;クラスのこの版は、重要なあるもの：インスタンスが作られるときにクラスを設定準備するイニシャライザ（初期化子）、が欠けています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This version of the game is wrapped up as a class called &lt;c0&gt;&lt;s1&gt;SnakesAndLadders&lt;/s1&gt;&lt;/c0&gt;, which adopts the &lt;c2&gt;&lt;s3&gt;DiceGame&lt;/s3&gt;&lt;/c2&gt; protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ゲームのこの改作は、&lt;c0&gt;&lt;s1&gt;SnakesAndLadders&lt;/s1&gt;&lt;/c0&gt;と呼ばれるクラスで包まれます、それは、&lt;c2&gt;&lt;s3&gt;DiceGame&lt;/s3&gt;&lt;/c2&gt;プロトコルを採用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This version of the game uses a &lt;c0&gt;&lt;s1&gt;while&lt;/s1&gt;&lt;/c0&gt; loop and a &lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt; statement to implement the game’s logic.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ゲームのこの改変板は、このゲームの論理を実装するために&lt;c0&gt;&lt;s1&gt;while&lt;/s1&gt;&lt;/c0&gt;ループと&lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt;文を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This version of the mutating &lt;c0&gt;&lt;s1&gt;moveBy(x:y:)&lt;/s1&gt;&lt;/c0&gt; method creates a new structure whose &lt;c2&gt;&lt;s3&gt;x&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;y&lt;/s5&gt;&lt;/c4&gt; values are set to the target location.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変更&lt;c0&gt;&lt;s1&gt;moveBy(x:y:)&lt;/s1&gt;&lt;/c0&gt;メソッドのこの改作は、それの持つ&lt;c2&gt;&lt;s3&gt;x&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;y&lt;/s5&gt;&lt;/c4&gt;の値が目標場所に設定される、新しい構造体を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This violates the requirement to return values of only one type and makes &lt;c6&gt;&lt;s7&gt;invalidFlip(_:)&lt;/s7&gt;&lt;/c6&gt; invalid code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは、ただ１つの型だけの値を返すという要件に違反します、そして&lt;c6&gt;&lt;s7&gt;invalidFlip(_:)&lt;/s7&gt;&lt;/c6&gt;を無効なコードにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This wouldn’t be the case if you had written the initializer as part of the value type’s original implementation, as described in &lt;a0&gt;&lt;s1&gt;Initializer Delegation for Value Types&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;値型のためのイニシャライザ委任&lt;/s1&gt;&lt;/a0&gt;で記述されるように、あなたがイニシャライザをその値型の最初の実装の一部として書いたならば、それはこの場合にはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those roles are reversed for a function with an opaque return type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの役割は、不透明戻り型をもつある関数に対しては逆にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Those two values are compared, and the result of that comparison determines the overall result of the tuple comparison.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのような２つの値が比較されます、するとその比較の結果がタプル比較の結果全体を決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Throw Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>throw文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Throwing Functions and Methods</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スローを行う関数とメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Throwing an error lets you indicate that something unexpected happened and the normal flow of execution can’t continue.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーのスローがあなたに示すのは、何か予期せぬことが起こった、そして通常の実行の流れは続けることができないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Throwing and rethrowing functions are described in &lt;a4&gt;&lt;s5&gt;Throwing Functions and Methods&lt;/s5&gt;&lt;/a4&gt; and &lt;a6&gt;&lt;s7&gt;Rethrowing Functions and Methods&lt;/s7&gt;&lt;/a6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スローおよび再スロー関数は、&lt;a4&gt;&lt;s5&gt;スロー関数とメソッド&lt;/s5&gt;&lt;/a4&gt;と&lt;a6&gt;&lt;s7&gt;再スロー関数とメソッド&lt;/s7&gt;&lt;/a6&gt;において記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Throwing and rethrowing functions can transfer program control to an appropriate &lt;c5&gt;&lt;s6&gt;catch&lt;/s6&gt;&lt;/c5&gt; block, even when they are nonreturning.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スローおよび再スロー関数は、制御を適切な&lt;c5&gt;&lt;s6&gt;catch&lt;/s6&gt;&lt;/c5&gt;ブロックに移すことができます、それらが非復帰である場合でさえも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Throwing initializers can propagate errors in the same way as throwing functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スローするイニシャライザは、スローする関数と同じ方法でエラーを伝達できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Throwing, catching, and propagating errors is covered in greater detail in &lt;a0&gt;&lt;s1&gt;Error Handling&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーのスロー、キャッチ、そして伝達は、詳細に&lt;a0&gt;&lt;s1&gt;エラー処理&lt;/s1&gt;&lt;/a0&gt;において扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To access a value using a key path, pass the key path to the &lt;c0&gt;&lt;s1&gt;subscript(keyPath:)&lt;/s1&gt;&lt;/c0&gt; subscript, which is available on all types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キーパスを使ってある値にアクセスするには、そのキーパスを&lt;c0&gt;&lt;s1&gt;subscript(keyPath:)&lt;/s1&gt;&lt;/c0&gt;添え字に渡してください、それは全ての型で利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To access an index farther away from the given index, you can use the &lt;c6&gt;&lt;s7&gt;index(_:offsetBy:)&lt;/s7&gt;&lt;/c6&gt; method instead of calling one of these methods multiple times.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>与えられたインデックスからもっと遠く離れたインデックスにアクセスするには、あなたはこれらのメソッドのうちの１つを複数回呼び出すことの代わりに&lt;c6&gt;&lt;s7&gt;index(_:offsetBy:)&lt;/s7&gt;&lt;/c6&gt;メソッドを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To accomplish this, Swift enables you to define &lt;e0&gt;nested types&lt;/e0&gt;, whereby you nest supporting enumerations, classes, and structures within the definition of the type they support.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これを達成するために、スウィフトはあなたに&lt;e0&gt;入れ子にされた型&lt;/e0&gt;を定義するのを可能にします、それによってあなたは、補助の列挙、クラス、そして構造体をそれらが支援をする型の定義の範囲内で入れ子にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To accomplish this, you define one input parameter—a &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt; value called &lt;c4&gt;&lt;s5&gt;person&lt;/s5&gt;&lt;/c4&gt;—and a return type of &lt;c6&gt;&lt;s7&gt;String&lt;/s7&gt;&lt;/c6&gt;, which will contain a greeting for that person:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これを達成するために、あなたは１つの入力パラメータ ― &lt;c4&gt;&lt;s5&gt;person&lt;/s5&gt;&lt;/c4&gt;と呼ばれる&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;値 ― そしてその人のための挨拶を含むことになる、&lt;c6&gt;&lt;s7&gt;String&lt;/s7&gt;&lt;/c6&gt;の戻り型を定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To achieve these aims, you can mark a loop statement or conditional statement with a &lt;e0&gt;statement label&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの狙いを達成するために、あなたはループ文または条件文に&lt;e0&gt;文ラベル&lt;/e0&gt;で印をつけることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To achieve this, an extra rule is used when signed integers are shifted to the right: When you shift signed integers to the right, apply the same rules as for unsigned integers, but fill any empty bits on the left with the &lt;e0&gt;sign bit&lt;/e0&gt;, rather than with a zero.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これを達成するために、符号つき整数が右へシフトされるとき、特別な規則が使われます：あなたが符号つき整数を右にシフトする時は、符号なし整数と同じ規則を適用してください、しかし、その左のあらゆる空のビットを、ゼロではなく&lt;e0&gt;符号ビット&lt;/e0&gt;で満たしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To achieve this, the &lt;c0&gt;&lt;s1&gt;Container&lt;/s1&gt;&lt;/c0&gt; protocol declares an associated type called &lt;c2&gt;&lt;s3&gt;Item&lt;/s3&gt;&lt;/c2&gt;, written as &lt;c4&gt;&lt;s5&gt;associatedtype&lt;/s5&gt; &lt;s6&gt;Item&lt;/s6&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これを達成するために、&lt;c0&gt;&lt;s1&gt;Container&lt;/s1&gt;&lt;/c0&gt;プロトコルは&lt;c2&gt;&lt;s3&gt;Item&lt;/s3&gt;&lt;/c2&gt;と呼ばれる関連型を宣言します、それは&lt;c4&gt;&lt;s5&gt;associatedtype&lt;/s5&gt; &lt;s6&gt;Item&lt;/s6&gt;&lt;/c4&gt;のように書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To achieve this, the array’s size, and an initial cell value of &lt;c14&gt;&lt;s15&gt;0.0&lt;/s15&gt;&lt;/c14&gt;, are passed to an array initializer that creates and initializes a new array of the correct size.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これを達成するために、この配列の大きさ、そして&lt;c14&gt;&lt;s15&gt;0.0&lt;/s15&gt;&lt;/c14&gt;の初期セル値は、正しいサイズの新しい配列をつくって初期化する配列イニシャライザに渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To add protocol conformance, you write the protocol names the same way as you write them for a class or structure:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル準拠を加えるには、あなたはそれらプロトコル名を、あなたがそれらをクラスや構造体に対して書くのと同じ方法で記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To align the values and statements, the unary plus operator (&lt;c10&gt;&lt;s11&gt;+i&lt;/s11&gt;&lt;/c10&gt;) is explicitly used with the unary minus operator (&lt;c12&gt;&lt;s13&gt;-i&lt;/s13&gt;&lt;/c12&gt;) and numbers lower than &lt;c14&gt;&lt;s15&gt;10&lt;/s15&gt;&lt;/c14&gt; are padded with zeros.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値と文を整列するために、単項プラス演算子（&lt;c10&gt;&lt;s11&gt;+i&lt;/s11&gt;&lt;/c10&gt;）が明示的に単項マイナス演算子（&lt;c12&gt;&lt;s13&gt;-i&lt;/s13&gt;&lt;/c12&gt;)とともに使われます、そして&lt;c14&gt;&lt;s15&gt;10&lt;/s15&gt;&lt;/c14&gt;より低い数はゼロを詰められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To assist with these assertions, &lt;c6&gt;&lt;s7&gt;Matrix&lt;/s7&gt;&lt;/c6&gt; includes a convenience method called &lt;c8&gt;&lt;s9&gt;indexIsValid(row:column:)&lt;/s9&gt;&lt;/c8&gt;, which checks whether the requested &lt;c10&gt;&lt;s11&gt;row&lt;/s11&gt;&lt;/c10&gt; and &lt;c12&gt;&lt;s13&gt;column&lt;/s13&gt;&lt;/c12&gt; are inside the bounds of the matrix:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの表明を手伝うために、&lt;c6&gt;&lt;s7&gt;Matrix&lt;/s7&gt;&lt;/c6&gt;は&lt;c8&gt;&lt;s9&gt;indexIsValid(row:column:)&lt;/s9&gt;&lt;/c8&gt;と呼ばれるある便利なメソッドを含みます、それは要請された&lt;c10&gt;&lt;s11&gt;row&lt;/s11&gt;&lt;/c10&gt;と&lt;c12&gt;&lt;s13&gt;column&lt;/s13&gt;&lt;/c12&gt;が行列の境界の内側にあるかどうか確認します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To calculate &lt;c0&gt;&lt;s1&gt;9&lt;/s1&gt; &lt;s2&gt;%&lt;/s2&gt; &lt;s3&gt;4&lt;/s3&gt;&lt;/c0&gt;, you first work out how many &lt;c4&gt;&lt;s5&gt;4&lt;/s5&gt;&lt;/c4&gt;s will fit inside &lt;c6&gt;&lt;s7&gt;9&lt;/s7&gt;&lt;/c6&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;9&lt;/s1&gt; &lt;s2&gt;%&lt;/s2&gt; &lt;s3&gt;4&lt;/s3&gt;&lt;/c0&gt;を計算するために、あなたは最初にどれくらい多くの&lt;c4&gt;&lt;s5&gt;4&lt;/s5&gt;&lt;/c4&gt;が&lt;c6&gt;&lt;s7&gt;9&lt;/s7&gt;&lt;/c6&gt;の中に収まるかを考え出します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To check the values of enumeration cases, use a &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; statement, as shown in &lt;a2&gt;&lt;s3&gt;Matching Enumeration Values with a Switch Statement&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙ケース節の値を調べるために、&lt;a2&gt;&lt;s3&gt;列挙値をスイッチ文で照合する&lt;/s3&gt;&lt;/a2&gt;で示されるように、&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;文を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To check whether a set contains a particular item, use the &lt;c0&gt;&lt;s1&gt;contains(_:)&lt;/s1&gt;&lt;/c0&gt; method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある集合が特定の項目を含むかどうか調べるために、&lt;c0&gt;&lt;s1&gt;contains(_:)&lt;/s1&gt;&lt;/c0&gt;メソッドを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To check whether a string has a particular string prefix or suffix, call the string’s &lt;c0&gt;&lt;s1&gt;hasPrefix(_:)&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;hasSuffix(_:)&lt;/s3&gt;&lt;/c2&gt; methods, both of which take a single argument of type &lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt; and return a Boolean value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある文字列が特定の文字列接頭辞または接尾辞を持つかどうか調べるために、文字列の&lt;c0&gt;&lt;s1&gt;hasPrefix(_:)&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;hasSuffix(_:)&lt;/s3&gt;&lt;/c2&gt;メソッドを呼んでください、それらの両方ともただ１つの&lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt;型の引数をとって、ブールの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To compare tuples with seven or more elements, you must implement the comparison operators yourself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>７つまたはそれより多い要素のタプルを比較するには、あなたは比較演算子をあなた自身で実装しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To conform to this version of &lt;c0&gt;&lt;s1&gt;Container&lt;/s1&gt;&lt;/c0&gt;, the container’s &lt;c2&gt;&lt;s3&gt;Item&lt;/s3&gt;&lt;/c2&gt; type has to conform to the &lt;c4&gt;&lt;s5&gt;Equatable&lt;/s5&gt;&lt;/c4&gt; protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このバージョンの&lt;c0&gt;&lt;s1&gt;Container&lt;/s1&gt;&lt;/c0&gt;に準拠するには、コンテナのもつ&lt;c2&gt;&lt;s3&gt;Item&lt;/s3&gt;&lt;/c2&gt;型は&lt;c4&gt;&lt;s5&gt;Equatable&lt;/s5&gt;&lt;/c4&gt;プロトコルに準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To convert one specific number type to another, you initialize a new number of the desired type with the existing value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>１つの特定の数の型を他のものに変換するために、あなたは望む型の新しい数を既存の値で初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To cope with initialization conditions that can fail, define one or more failable initializers as part of a class, structure, or enumeration definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>失敗の可能性がある初期化状況にうまく対処するために、１つ以上の失敗可能なイニシャライザをクラス、構造体、または列挙定義の一部として定義してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To cope with this requirement, you declare the &lt;c0&gt;&lt;s1&gt;capitalCity&lt;/s1&gt;&lt;/c0&gt; property of &lt;c2&gt;&lt;s3&gt;Country&lt;/s3&gt;&lt;/c2&gt; as an implicitly unwrapped optional property, indicated by the exclamation point at the end of its type annotation (&lt;c4&gt;&lt;s5&gt;City!&lt;/s5&gt;&lt;/c4&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この必要条件に対処するために、あなたは&lt;c2&gt;&lt;s3&gt;Country&lt;/s3&gt;&lt;/c2&gt;の&lt;c0&gt;&lt;s1&gt;capitalCity&lt;/s1&gt;&lt;/c0&gt;プロパティを、暗黙的にアンラップされるオプショナルのプロパティとして、その型注釈の終わりに感嘆符で示して宣言します（&lt;c4&gt;&lt;s5&gt;City!&lt;/s5&gt;&lt;/c4&gt;）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To cope with this scenario, the code checks that &lt;c2&gt;&lt;s3&gt;square&lt;/s3&gt;&lt;/c2&gt; is less than the &lt;c4&gt;&lt;s5&gt;board&lt;/s5&gt;&lt;/c4&gt; array’s &lt;c6&gt;&lt;s7&gt;count&lt;/s7&gt;&lt;/c6&gt; property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この事態に対処するために、コードは、&lt;c2&gt;&lt;s3&gt;square&lt;/s3&gt;&lt;/c2&gt;が&lt;c4&gt;&lt;s5&gt;board&lt;/s5&gt;&lt;/c4&gt;配列の&lt;c6&gt;&lt;s7&gt;count&lt;/s7&gt;&lt;/c6&gt;プロパティより少ないことを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To cope with this, the example above uses optional binding to check whether the optional &lt;c4&gt;&lt;s5&gt;Movie&lt;/s5&gt;&lt;/c4&gt; actually contains a value (that is, to find out whether the downcast succeeded.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これに対処するために、上の例は、オプショナル束縛を使って、オプショナルの&lt;c4&gt;&lt;s5&gt;Movie&lt;/s5&gt;&lt;/c4&gt;が実際に値を含むかどうか調べます（すなわち、ダウンキャストが成功したかどうか探り出します）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To create a property called &lt;c0&gt;&lt;s1&gt;items&lt;/s1&gt;&lt;/c0&gt;, which is initialized with an empty array of values of type &lt;c2&gt;&lt;s3&gt;Element&lt;/s3&gt;&lt;/c2&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;items&lt;/s1&gt;&lt;/c0&gt;と呼ばれるプロパティをつくる所で、それは、型&lt;c2&gt;&lt;s3&gt;Element&lt;/s3&gt;&lt;/c2&gt;の値が入る空の配列で初期化されます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To create an empty &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; value as the starting point for building a longer string, either assign an empty string literal to a variable, or initialize a new &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt; instance with initializer syntax:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より長い文字列をつくるための出発点として空の&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;値を作成するために、変数に空のリテラル文字列を代入するか、イニシャライザ構文で新しい&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;インスタンスを初期化してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To create an empty array or dictionary, use the initializer syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>空の配列または辞書を作成するために、初期化構文を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To declare a class or static method requirement in a protocol declaration, mark the method declaration with the &lt;c0&gt;&lt;s1&gt;static&lt;/s1&gt;&lt;/c0&gt; declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスまたは静的メソッド要件をあるプロトコル宣言において宣言するために、そのメソッド宣言を&lt;c0&gt;&lt;s1&gt;static&lt;/s1&gt;&lt;/c0&gt;宣言修飾子で印してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To declare a constant type property, mark the declaration with the &lt;c0&gt;&lt;s1&gt;static&lt;/s1&gt;&lt;/c0&gt; declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数型プロパティを宣言するために、宣言に&lt;c0&gt;&lt;s1&gt;static&lt;/s1&gt;&lt;/c0&gt;宣言修飾子で印をつけてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To declare a failable initializer that produces an implicitly unwrapped optional instance, append an exclamation point instead (&lt;c4&gt;&lt;s5&gt;init!&lt;/s5&gt;&lt;/c4&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗黙的にアンラップされるオプショナルインスタンスを生成する失敗できるイニシャライザを宣言するために、代わりに感嘆符を加えてください（&lt;c4&gt;&lt;s5&gt;init!&lt;/s5&gt;&lt;/c4&gt;）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To declare a failable initializer that produces an optional instance, append a question mark to the &lt;c0&gt;&lt;s1&gt;init&lt;/s1&gt;&lt;/c0&gt; keyword in the initializer declaration (&lt;c2&gt;&lt;s3&gt;init?&lt;/s3&gt;&lt;/c2&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルインスタンスを生成する失敗できるイニシャライザを宣言するために、イニシャライザ宣言において疑問符を&lt;c0&gt;&lt;s1&gt;init&lt;/s1&gt;&lt;/c0&gt;キーワードに加えてください（&lt;c2&gt;&lt;s3&gt;init?&lt;/s3&gt;&lt;/c2&gt;）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To declare a static subscript requirement in a protocol declaration, mark the subscript declaration with the &lt;c0&gt;&lt;s1&gt;static&lt;/s1&gt;&lt;/c0&gt; declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>静的添え字要件をプロトコル宣言において宣言するには、その添え字宣言を&lt;c0&gt;&lt;s1&gt;static&lt;/s1&gt;&lt;/c0&gt;宣言修飾子で印してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To declare a subscript that’s exposed by the type, rather than by instances of the type, mark the subscript declaration with the &lt;c0&gt;&lt;s1&gt;static&lt;/s1&gt;&lt;/c0&gt; declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型によって、その型のインスタンスによってではなく、露出される添え字を宣言するには、添え字宣言を&lt;c0&gt;&lt;s1&gt;static&lt;/s1&gt;&lt;/c0&gt;宣言修飾子で印してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To declare a type property requirement in a protocol declaration, mark the property declaration with the &lt;c0&gt;&lt;s1&gt;static&lt;/s1&gt;&lt;/c0&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型プロパティ要件をプロトコル宣言の中で宣言するには、そのプロパティ宣言を&lt;c0&gt;&lt;s1&gt;static&lt;/s1&gt;&lt;/c0&gt;キーワードで印してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To declare a type variable property, mark the declaration with the &lt;c0&gt;&lt;s1&gt;static&lt;/s1&gt;&lt;/c0&gt; declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型変数プロパティを宣言するために、宣言に&lt;c0&gt;&lt;s1&gt;static&lt;/s1&gt;&lt;/c0&gt;宣言修飾子で印をつけてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To declare convenience initializers for a class, mark the initializer declaration with the &lt;c0&gt;&lt;s1&gt;convenience&lt;/s1&gt;&lt;/c0&gt; declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるクラスの便宜イニシャライザを宣言するために、そのイニシャライザ宣言を&lt;c0&gt;&lt;s1&gt;convenience&lt;/s1&gt;&lt;/c0&gt;宣言修飾子を使って印してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To define a property wrapper, you make a structure, enumeration, or class that defines a &lt;c0&gt;&lt;s1&gt;wrappedValue&lt;/s1&gt;&lt;/c0&gt; property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティラッパーを定義するには、あなたはある&lt;c0&gt;&lt;s1&gt;wrappedValue&lt;/s1&gt;&lt;/c0&gt;プロパティを定義する構造体、列挙、またはクラスを作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To define these requirements, the &lt;c0&gt;&lt;s1&gt;Container&lt;/s1&gt;&lt;/c0&gt; protocol needs a way to refer to the type of the elements that a container will hold, without knowing what that type is for a specific container.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの要件を定義するために、&lt;c0&gt;&lt;s1&gt;Container&lt;/s1&gt;&lt;/c0&gt;プロトコルは、あるコンテナが保持することになる要素の型を参照する方法を必要とします、その型がどんなコンテナのためのものか知ることなしにです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To determine the answer for &lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt; &lt;s2&gt;%&lt;/s2&gt; &lt;s3&gt;b&lt;/s3&gt;&lt;/c0&gt;, the &lt;c4&gt;&lt;s5&gt;%&lt;/s5&gt;&lt;/c4&gt; operator calculates the following equation and returns &lt;c6&gt;&lt;s7&gt;remainder&lt;/s7&gt;&lt;/c6&gt; as its output:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt; &lt;s2&gt;%&lt;/s2&gt; &lt;s3&gt;b&lt;/s3&gt;&lt;/c0&gt;に対する答えを決定するために、&lt;c4&gt;&lt;s5&gt;%&lt;/s5&gt;&lt;/c4&gt;演算子は以下の等式を計算します、そしてその出力として&lt;c6&gt;&lt;s7&gt;余り&lt;/s7&gt;&lt;/c6&gt;を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To discover the specific type of a constant or variable that is known only to be of type &lt;c0&gt;&lt;s1&gt;Any&lt;/s1&gt;&lt;/c0&gt; or &lt;c2&gt;&lt;s3&gt;AnyObject&lt;/s3&gt;&lt;/c2&gt;, you can use an &lt;c4&gt;&lt;s5&gt;is&lt;/s5&gt;&lt;/c4&gt; or &lt;c6&gt;&lt;s7&gt;as&lt;/s7&gt;&lt;/c6&gt; pattern in a &lt;c8&gt;&lt;s9&gt;switch&lt;/s9&gt;&lt;/c8&gt; statement’s cases.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型&lt;c0&gt;&lt;s1&gt;Any&lt;/s1&gt;&lt;/c0&gt;または&lt;c2&gt;&lt;s3&gt;AnyObject&lt;/s3&gt;&lt;/c2&gt;のものであることだけが知られている定数や変数の具体的な型を見つけるために、あなたは&lt;c4&gt;&lt;s5&gt;is&lt;/s5&gt;&lt;/c4&gt;または&lt;c6&gt;&lt;s7&gt;as&lt;/s7&gt;&lt;/c6&gt;パターンを&lt;c8&gt;&lt;s9&gt;switch&lt;/s9&gt;&lt;/c8&gt;文のケース節の中で使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To distinguish between methods or initializers whose names differ only by the names of their arguments, include the argument names in parentheses, with each argument name followed by a colon (&lt;c0&gt;&lt;s1&gt;:&lt;/s1&gt;&lt;/c0&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>名前がそれらの引数の名前でだけ異なるものであるメソッド間またはイニシャライザ間で識別を行うために、丸括弧の中に引数名を、各引数名にコロン（&lt;c0&gt;&lt;s1&gt;:&lt;/s1&gt;&lt;/c0&gt;）を続けることで含めて下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To distinguish between overloaded methods, use a type annotation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オーバーロードされたメソッド間で識別を行うには、型注釈を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To do that, you need to create an instance of the structure or class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それをするために、あなたは構造体またはクラスのインスタンスをつくる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To do this, it needs to access each item as a true &lt;c4&gt;&lt;s5&gt;Movie&lt;/s5&gt;&lt;/c4&gt; or &lt;c6&gt;&lt;s7&gt;Song&lt;/s7&gt;&lt;/c6&gt;, and not just as a &lt;c8&gt;&lt;s9&gt;MediaItem&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これをするために、それは、ただ&lt;c8&gt;&lt;s9&gt;MediaItem&lt;/s9&gt;&lt;/c8&gt;としてではなく、本当の&lt;c4&gt;&lt;s5&gt;Movie&lt;/s5&gt;&lt;/c4&gt;または&lt;c6&gt;&lt;s7&gt;Song&lt;/s7&gt;&lt;/c6&gt;として各項目にアクセスする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To do this, you make parts of your code &lt;e0&gt;conditional&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これをするために、あなたは、あなたのコードの一部を&lt;e0&gt;条件つき&lt;/e0&gt;にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To enable indirection for a particular enumeration case, mark it with the &lt;c0&gt;&lt;s1&gt;indirect&lt;/s1&gt;&lt;/c0&gt; declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある特定の列挙ケース節に対して間接参照を可能にするには、それを&lt;c0&gt;&lt;s1&gt;indirect&lt;/s1&gt;&lt;/c0&gt;宣言修飾子で印してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To enable indirection for all the cases of an enumeration that have an associated value, mark the entire enumeration with the &lt;c0&gt;&lt;s1&gt;indirect&lt;/s1&gt;&lt;/c0&gt; modifier—this is convenient when the enumeration contains many cases that would each need to be marked with the &lt;c2&gt;&lt;s3&gt;indirect&lt;/s3&gt;&lt;/c2&gt; modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある列挙の中のすべてのケース節、それらは関連値を持っている、に対して間接参照を可能にするには、その列挙全体を&lt;c0&gt;&lt;s1&gt;indirect&lt;/s1&gt;&lt;/c0&gt;修飾子で印してください—これはその列挙がそのそれぞれが&lt;c2&gt;&lt;s3&gt;indirect&lt;/s3&gt;&lt;/c2&gt;修飾子で印される必要がある多くのケース節を含んでいる時に適します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To enable it in Xcode, set the “Build Libraries for Distribution” build setting (&lt;c2&gt;&lt;s3&gt;BUILD_LIBRARY_FOR_DISTRIBUTION&lt;/s3&gt;&lt;/c2&gt;) to Yes, as described in &lt;a4&gt;Xcode Help&lt;/a4&gt;&lt;s5&gt; [https://help.apple.com/xcode/mac/current/#/dev04b3a04ba]&lt;/s5&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それをXcodeで可能にするには、“Build Libraries for Distribution” ビルド設定（&lt;c2&gt;&lt;s3&gt;BUILD_LIBRARY_FOR_DISTRIBUTION&lt;/s3&gt;&lt;/c2&gt;）を Yes に設定してください、&lt;a4&gt;Xcode Help&lt;/a4&gt;&lt;s5&gt; [https://help.apple.com/xcode/mac/current/#/dev04b3a04ba]&lt;/s5&gt;で記述されるとおりに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To enable library evolution mode on the command line, pass the &lt;c0&gt;&lt;s1&gt;-enable-library-evolution&lt;/s1&gt;&lt;/c0&gt; option to the Swift compiler.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ライブラリ進化モードをコマンドライン上で可能にするには、&lt;c0&gt;&lt;s1&gt;-enable-library-evolution&lt;/s1&gt;&lt;/c0&gt;オプションをスウィフトコンパイラに渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To enable this, Swift provides two identity operators:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これを可能にするために、スウィフトは２つの同一性演算子を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To ensure conversion between numeric types maintains the value exactly, use the &lt;c0&gt;&lt;s1&gt;init(exactly:)&lt;/s1&gt;&lt;/c0&gt; initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>数値型の間の変換がその値を正確に維持するのを保証するために、&lt;c0&gt;&lt;s1&gt;init(exactly:)&lt;/s1&gt;&lt;/c0&gt;イニシャライザを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To ensure that an error is handled, use a &lt;c0&gt;&lt;s1&gt;catch&lt;/s1&gt;&lt;/c0&gt; clause with a pattern that matches all errors, such as a wildcard pattern (&lt;c2&gt;&lt;s3&gt;_&lt;/s3&gt;&lt;/c2&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーが処理されることが保証されるように、あるひとつの&lt;c0&gt;&lt;s1&gt;catch&lt;/s1&gt;&lt;/c0&gt;節をどんなエラーにもマッチするパターンとともに使ってください、例えばワイルドカードパターン（&lt;c2&gt;&lt;s3&gt;_&lt;/s3&gt;&lt;/c2&gt;）など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To evaluate the value of a subscript expression, the subscript getter for the &lt;e0&gt;expression&lt;/e0&gt;’s type is called with the &lt;e1&gt;index expressions&lt;/e1&gt; passed as the subscript parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字式の値を評価するために、この&lt;e0&gt;式&lt;/e0&gt;のもつ型のための添え字ゲッターが、添え字パラメータとして渡される&lt;e1&gt;インデックス式&lt;/e1&gt;を使って呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To explicitly fall through at the end of a particular &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; case, use the &lt;c2&gt;&lt;s3&gt;fallthrough&lt;/s3&gt;&lt;/c2&gt; keyword, as described in &lt;a4&gt;&lt;s5&gt;Fallthrough&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある特定の&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;ケース節の終わりで明示的に抜け落ちるには、&lt;a4&gt;&lt;s5&gt;フォールスルー&lt;/s5&gt;&lt;/a4&gt;で記述されるように、&lt;c2&gt;&lt;s3&gt;fallthrough&lt;/s3&gt;&lt;/c2&gt;キーワードを使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To express this fact, you write a type constraint of &lt;c4&gt;&lt;s5&gt;Equatable&lt;/s5&gt;&lt;/c4&gt; as part of the type parameter’s definition when you define the function:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この事実を表すために、あなたは&lt;c4&gt;&lt;s5&gt;Equatable&lt;/s5&gt;&lt;/c4&gt;の型制約を型パラメータの定義の一部として、あなたが関数を定義する時に書きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To find out the number of items in a set, check its read-only &lt;c0&gt;&lt;s1&gt;count&lt;/s1&gt;&lt;/c0&gt; property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>集合の中の項目数を知るために、それの読み出し専用の&lt;c0&gt;&lt;s1&gt;count&lt;/s1&gt;&lt;/c0&gt;プロパティを調べてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To find out the number of items in an array, check its read-only &lt;c0&gt;&lt;s1&gt;count&lt;/s1&gt;&lt;/c0&gt; property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある配列の中の項目の数を知るために、その読み出し専用の&lt;c0&gt;&lt;s1&gt;count&lt;/s1&gt;&lt;/c0&gt;プロパティを調べてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To handle an empty array safely, write the &lt;c0&gt;&lt;s1&gt;minMax(array:)&lt;/s1&gt;&lt;/c0&gt; function with an optional tuple return type and return a value of &lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt; when the array is empty:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>空の配列を安全に取り扱うために、&lt;c0&gt;&lt;s1&gt;minMax(array:)&lt;/s1&gt;&lt;/c0&gt;関数をオプショナルタプルの戻り型を使って書いて、配列が空の時に&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;の値を返してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To help manage the &lt;c0&gt;&lt;s1&gt;currentLevel&lt;/s1&gt;&lt;/c0&gt; property, &lt;c2&gt;&lt;s3&gt;LevelTracker&lt;/s3&gt;&lt;/c2&gt; defines an instance method called &lt;c4&gt;&lt;s5&gt;advance(to:)&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;currentLevel&lt;/s1&gt;&lt;/c0&gt;プロパティを管理するのを手伝うために、&lt;c2&gt;&lt;s3&gt;LevelTracker&lt;/s3&gt;&lt;/c2&gt;は&lt;c4&gt;&lt;s5&gt;advance(to:)&lt;/s5&gt;&lt;/c4&gt;と呼ばれるインスタンスメソッドを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To identify these places in your code, write the &lt;c0&gt;&lt;s1&gt;try&lt;/s1&gt;&lt;/c0&gt; keyword—or the &lt;c2&gt;&lt;s3&gt;try?&lt;/s3&gt;&lt;/c2&gt; or &lt;c4&gt;&lt;s5&gt;try!&lt;/s5&gt;&lt;/c4&gt; variation—before a piece of code that calls a function, method, or initializer that can throw an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの場所をあなたのコードの中で識別するには、&lt;c0&gt;&lt;s1&gt;try&lt;/s1&gt;&lt;/c0&gt;キーワードを ― またはその変種&lt;c2&gt;&lt;s3&gt;try?&lt;/s3&gt;&lt;/c2&gt;または&lt;c4&gt;&lt;s5&gt;try!&lt;/s5&gt;&lt;/c4&gt;を ― エラーをスローできる関数、メソッド、またはイニシャライザを呼び出すコードの前の場所に書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To illustrate this behavior, the following example defines two protocols and a generic type that conditionally conforms to both protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この挙動を図解するために、以下の例は２つのプロトコルおよび両方のプロトコルに条件付きで準拠する１つの総称体型を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To implement the &lt;c12&gt;&lt;s13&gt;+++&lt;/s13&gt;&lt;/c12&gt; operator, you add a type method called &lt;c14&gt;&lt;s15&gt;+++&lt;/s15&gt;&lt;/c14&gt; to &lt;c16&gt;&lt;s17&gt;Vector2D&lt;/s17&gt;&lt;/c16&gt; as follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c12&gt;&lt;s13&gt;+++&lt;/s13&gt;&lt;/c12&gt;演算子を実装するには、あなたは&lt;c14&gt;&lt;s15&gt;+++&lt;/s15&gt;&lt;/c14&gt;と呼ばれる型メソッドを次のように&lt;c16&gt;&lt;s17&gt;Vector2D&lt;/s17&gt;&lt;/c16&gt;に加えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To include the text &lt;c2&gt;&lt;s3&gt;"""&lt;/s3&gt;&lt;/c2&gt; in a multiline string, escape at least one of the quotation marks.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>テキスト&lt;c2&gt;&lt;s3&gt;"""&lt;/s3&gt;&lt;/c2&gt;を複数行文字列の中に含めるには、少なくとも１つの引用符記号の１つをエスケープしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To indicate that a function, method, or initializer can throw an error, you write the &lt;c0&gt;&lt;s1&gt;throws&lt;/s1&gt;&lt;/c0&gt; keyword in the function’s declaration after its parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーをスローすることのできる関数、メソッド、またはイニシャライザを指し示すために、あなたは&lt;c0&gt;&lt;s1&gt;throws&lt;/s1&gt;&lt;/c0&gt;キーワードを関数の定義においてそれのパラメータの後に書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To indicate that a subclass has a superclass, write the subclass name before the superclass name, separated by a colon:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるサブクラスがあるスーパークラスを持つことを表わすには、サブクラスの名前をスーパークラスの名前の前に、コロンで区切って書きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To insert a single character into a string at a specified index, use the &lt;c0&gt;&lt;s1&gt;insert(_:at:)&lt;/s1&gt;&lt;/c0&gt; method, and to insert the contents of another string at a specified index, use the &lt;c2&gt;&lt;s3&gt;insert(contentsOf:at:)&lt;/s3&gt;&lt;/c2&gt; method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある単一の文字をある文字列中へ特定のインデックスで差し込むには、&lt;c0&gt;&lt;s1&gt;insert(_:at:)&lt;/s1&gt;&lt;/c0&gt;メソッドを使ってください、そして別の文字列の内容を特定のインデックスで差し込むには、&lt;c2&gt;&lt;s3&gt;insert(contentsOf:at:)&lt;/s3&gt;&lt;/c2&gt;メソッドを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To insert an item into the array at a specified index, call the array’s &lt;c0&gt;&lt;s1&gt;insert(_:at:)&lt;/s1&gt;&lt;/c0&gt; method:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある項目を配列の中へ指定されたインデックスで差し入れるために、配列の&lt;c0&gt;&lt;s1&gt;insert(_:at:)&lt;/s1&gt;&lt;/c0&gt;メソッドを呼んでください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To iterate over the keys or values of a dictionary in a specific order, use the &lt;c2&gt;&lt;s3&gt;sorted()&lt;/s3&gt;&lt;/c2&gt; method on its &lt;c4&gt;&lt;s5&gt;keys&lt;/s5&gt;&lt;/c4&gt; or &lt;c6&gt;&lt;s7&gt;values&lt;/s7&gt;&lt;/c6&gt; property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>辞書のキーまたは値に特定の順序で繰り返していくために、&lt;c2&gt;&lt;s3&gt;sorted()&lt;/s3&gt;&lt;/c2&gt;メソッドを&lt;c4&gt;&lt;s5&gt;keys&lt;/s5&gt;&lt;/c4&gt;または&lt;c6&gt;&lt;s7&gt;values&lt;/s7&gt;&lt;/c6&gt;プロパティ上で使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To iterate over the values of a set in a specific order, use the &lt;c2&gt;&lt;s3&gt;sorted()&lt;/s3&gt;&lt;/c2&gt; method, which returns the set’s elements as an array sorted using the &lt;c4&gt;&lt;s5&gt;&lt;&lt;/s5&gt;&lt;/c4&gt; operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>集合の中の値に特定の順番で繰り返すには、&lt;c2&gt;&lt;s3&gt;sorted()&lt;/s3&gt;&lt;/c2&gt;メソッドを使ってください、それは集合の要素を&lt;c4&gt;&lt;s5&gt;&lt;&lt;/s5&gt;&lt;/c4&gt;演算子を使って格納される配列として返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To learn how functions can return other functions, see &lt;a9&gt;&lt;s10&gt;Function Types as Return Types&lt;/s10&gt;&lt;/a9&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数が他の関数を返すことができる方法を学ぶために、&lt;a9&gt;&lt;s10&gt;戻り型としての関数型&lt;/s10&gt;&lt;/a9&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To learn how to define new, custom operators, see &lt;a0&gt;&lt;s1&gt;Custom Operators&lt;/s1&gt;&lt;/a0&gt; and &lt;a2&gt;&lt;s3&gt;Operator Declaration&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい、あつらえの演算子を定義する方法を学ぶために、&lt;a0&gt;&lt;s1&gt;あつらえの演算子&lt;/s1&gt;&lt;/a0&gt;と&lt;a2&gt;&lt;s3&gt;演算子宣言&lt;/s3&gt;&lt;/a2&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To learn how to overload existing operators, see &lt;a4&gt;&lt;s5&gt;Operator Methods&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>既存の演算子にオーバーロードする方法を学ぶために、&lt;a4&gt;&lt;s5&gt;演算子メソッド&lt;/s5&gt;&lt;/a4&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To make a &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; with a single case that matches both &lt;c2&gt;&lt;s3&gt;"a"&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;"A"&lt;/s5&gt;&lt;/c4&gt;, combine the two values into a compound case, separating the values with commas.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ただ１つだけのケース節を持つある&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;が&lt;c2&gt;&lt;s3&gt;"a"&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;"A"&lt;/s5&gt;&lt;/c4&gt;の両方にマッチするようにするには、２つの値をひとつの複合ケース節へと、コンマで値を隔てて結合してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To make a multiline string literal that begins or ends with a line feed, write a blank line as its first or last line.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ラインフィードで始まるまたは終わる複数行文字列リテラルを作るには、空の行をそれの最初または最後の行に書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To make a multiline string literal that begins or ends with a line feed, write a blank line as the first or last line.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ラインフィードで始まるまたは終わる複数行文字列リテラルを作るには、空の行を最初または最後の行として記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To make it more useful, you need to refine it to describe more specific kinds of vehicles.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それをより役に立つようにするために、あなたはそれを改良してより具体的な乗物の種類を記述する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To make sure that instances don’t disappear while they are still needed, ARC tracks how many properties, constants, and variables are currently referring to each class instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それがまだ必要な間にインスタンスが消えないことを確実にするために、ARCは、どれくらいのプロパティ、定数、および変数が目下のところ各クラスインスタンスに言及しているかを追跡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To make the body of this function shorter, you can combine the message creation and the return statement into one line:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数の本文をより短くするために、あなたはメッセージ作成と返しの文を１行に結合することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To make this possible, whenever you assign a class instance to a property, constant, or variable, that property, constant, or variable makes a &lt;e0&gt;strong reference&lt;/e0&gt; to the instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これを可能にするために、あなたがクラスインスタンスをプロパティ、定数、または変数に代入するときはいつでも、そのプロパティ、定数、または変数はそのインスタンスへの&lt;e0&gt;強い参照&lt;/e0&gt;を作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To model this restriction, the failable initializer triggers an initialization failure if an empty string is found.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この制約条件をモデル化するために、失敗できるイニシャライザは空の文字列が見つけられるならば初期化失敗を引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To nest a type within another type, write its definition within the outer braces of the type it supports.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型を別の型の内部で入れ子にするために、その定義をそれが支援する型の外側の波括弧の範囲内で書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To opt in to overflow behavior, use Swift’s second set of arithmetic operators that overflow by default, such as the overflow addition operator (&lt;c0&gt;&lt;s1&gt;&amp;+&lt;/s1&gt;&lt;/c0&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オーバフロー挙動を選ぶために、初期状態でオーバフローするスウィフトの算術演算子の第二集合を使ってください、例えばオーバフロー加算演算子（&lt;c0&gt;&lt;s1&gt;&amp;+&lt;/s1&gt;&lt;/c0&gt;）など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To override a characteristic that would otherwise be inherited, you prefix your overriding definition with the &lt;c0&gt;&lt;s1&gt;override&lt;/s1&gt;&lt;/c0&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうしなければ継承される特徴をオーバーライドするために、あなたは、あなたのオーバーライド定義の前に&lt;c0&gt;&lt;s1&gt;override&lt;/s1&gt;&lt;/c0&gt;キーワードを置きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To prevent strong reference cycles, delegates are declared as weak references.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>強い参照循環を防ぐために、委任先は弱い参照として宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To print a value without a line break after it, pass an empty string as the terminator—for example, &lt;c8&gt;&lt;s9&gt;print(someValue,&lt;/s9&gt; &lt;s10&gt;terminator:&lt;/s10&gt; &lt;s11&gt;"")&lt;/s11&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある値をそれの後に改行なしで出力するには、空の文字列を終端子（ターミネータ）として渡してください ― 例えば、&lt;c8&gt;&lt;s9&gt;print(someValue,&lt;/s9&gt; &lt;s10&gt;terminator:&lt;/s10&gt; &lt;s11&gt;"")&lt;/s11&gt;&lt;/c8&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To project a value from a property wrapper, define a &lt;c1&gt;&lt;s2&gt;projectedValue&lt;/s2&gt;&lt;/c1&gt; instance property on the wrapper type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある値をプロパティラッパーから見積もるには、&lt;c1&gt;&lt;s2&gt;projectedValue&lt;/s2&gt;&lt;/c1&gt;インスタンスプロパティをそのラッパー型上で定義してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To put it another way:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>言い換えれば：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To receive a synthesized implementation of &lt;c0&gt;&lt;s1&gt;==&lt;/s1&gt;&lt;/c0&gt;, declare &lt;c2&gt;&lt;s3&gt;Equatable&lt;/s3&gt;&lt;/c2&gt; conformance in the file that contains the original declaration, without implementing an &lt;c4&gt;&lt;s5&gt;==&lt;/s5&gt;&lt;/c4&gt; operator yourself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;==&lt;/s1&gt;&lt;/c0&gt;の合成された実装を受け取るには、&lt;c2&gt;&lt;s3&gt;Equatable&lt;/s3&gt;&lt;/c2&gt;準拠の宣言を元の宣言を含むファイルにおいて行ってください、&lt;c4&gt;&lt;s5&gt;==&lt;/s5&gt;&lt;/c4&gt;演算子をあなた自身で実装することなしに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To reference the case of an enumeration type, use dot (&lt;c0&gt;&lt;s1&gt;.&lt;/s1&gt;&lt;/c0&gt;) syntax, as in &lt;c2&gt;&lt;s3&gt;EnumerationType.enumerationCase&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙型のケース節に言及するために、&lt;c2&gt;&lt;s3&gt;EnumerationType.enumerationCase&lt;/s3&gt;&lt;/c2&gt;のように、ドット（&lt;c0&gt;&lt;s1&gt;.&lt;/s1&gt;&lt;/c0&gt;）構文を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To reflect the fact that optional chaining can be called on a &lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt; value, the result of an optional chaining call is always an optional value, even if the property, method, or subscript you are querying returns a non-optional value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖は&lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;値上で呼ばれることができるという事実を反映するために、オプショナル連鎖呼び出しの結果は、たとえあなたが問い合わせているプロパティ、メソッド、または添え字が非オプショナルの値を返すとしても、常にオプショナルの値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To remove a single character from a string at a specified index, use the &lt;c0&gt;&lt;s1&gt;remove(at:)&lt;/s1&gt;&lt;/c0&gt; method, and to remove a substring at a specified range, use the &lt;c2&gt;&lt;s3&gt;removeSubrange(_:)&lt;/s3&gt;&lt;/c2&gt; method:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある単一の文字をある文字列から特定のインデックスで削除するには、&lt;c0&gt;&lt;s1&gt;remove(at:)&lt;/s1&gt;&lt;/c0&gt;メソッドを使ってください、そして部分文字列を特定の範囲で削除するには、&lt;c2&gt;&lt;s3&gt;removeSubrange(_:)&lt;/s3&gt;&lt;/c2&gt;メソッドを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To represent this fact, &lt;c0&gt;&lt;s1&gt;ShoppingListItem&lt;/s1&gt;&lt;/c0&gt; introduces a Boolean property called &lt;c2&gt;&lt;s3&gt;purchased&lt;/s3&gt;&lt;/c2&gt;, with a default value of &lt;c4&gt;&lt;s5&gt;false&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この事実を表すために、&lt;c0&gt;&lt;s1&gt;ShoppingListItem&lt;/s1&gt;&lt;/c0&gt;は、&lt;c4&gt;&lt;s5&gt;false&lt;/s5&gt;&lt;/c4&gt;の省略時の値で、&lt;c2&gt;&lt;s3&gt;purchased&lt;/s3&gt;&lt;/c2&gt;と呼ばれるブールのプロパティを導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To represent this game board, the &lt;c0&gt;&lt;s1&gt;Chessboard&lt;/s1&gt;&lt;/c0&gt; structure has a single property called &lt;c2&gt;&lt;s3&gt;boardColors&lt;/s3&gt;&lt;/c2&gt;, which is an array of 64 &lt;c4&gt;&lt;s5&gt;Bool&lt;/s5&gt;&lt;/c4&gt; values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このゲーム板を表すために、&lt;c0&gt;&lt;s1&gt;Chessboard&lt;/s1&gt;&lt;/c0&gt;構造体は&lt;c2&gt;&lt;s3&gt;boardColors&lt;/s3&gt;&lt;/c2&gt;と呼ばれる１つのプロパティだけを持ちます、それは64個の&lt;c4&gt;&lt;s5&gt;Bool&lt;/s5&gt;&lt;/c4&gt;値の配列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To represent this, &lt;c0&gt;&lt;s1&gt;board[03]&lt;/s1&gt;&lt;/c0&gt; is equal to &lt;c2&gt;&lt;s3&gt;+08&lt;/s3&gt;&lt;/c2&gt;, which is equivalent to an integer value of &lt;c4&gt;&lt;s5&gt;8&lt;/s5&gt;&lt;/c4&gt; (the difference between &lt;c6&gt;&lt;s7&gt;3&lt;/s7&gt;&lt;/c6&gt; and &lt;c8&gt;&lt;s9&gt;11&lt;/s9&gt;&lt;/c8&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これを表すために、&lt;c0&gt;&lt;s1&gt;board[03]&lt;/s1&gt;&lt;/c0&gt;は&lt;c2&gt;&lt;s3&gt;+08&lt;/s3&gt;&lt;/c2&gt;と等しいです、そしてそれは、整数値の&lt;c4&gt;&lt;s5&gt;８&lt;/s5&gt;&lt;/c4&gt;（&lt;c6&gt;&lt;s7&gt;3&lt;/s7&gt;&lt;/c6&gt;と&lt;c8&gt;&lt;s9&gt;11&lt;/s9&gt;&lt;/c8&gt;の差）に等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To represent this, the &lt;c13&gt;&lt;s14&gt;Customer&lt;/s14&gt;&lt;/c13&gt; class has an optional &lt;c15&gt;&lt;s16&gt;card&lt;/s16&gt;&lt;/c15&gt; property, but the &lt;c17&gt;&lt;s18&gt;CreditCard&lt;/s18&gt;&lt;/c17&gt; class has an unowned (and non-optional) &lt;c19&gt;&lt;s20&gt;customer&lt;/s20&gt;&lt;/c19&gt; property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これを表すために、&lt;c13&gt;&lt;s14&gt;Customer&lt;/s14&gt;&lt;/c13&gt;クラスはオプショナルの&lt;c15&gt;&lt;s16&gt;card&lt;/s16&gt;&lt;/c15&gt;プロパティを持ちます、しかし、&lt;c17&gt;&lt;s18&gt;CreditCard&lt;/s18&gt;&lt;/c17&gt;クラスは非所有（そして非オプショナル）の&lt;c19&gt;&lt;s20&gt;customer&lt;/s20&gt;&lt;/c19&gt;プロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To represent this, the &lt;c4&gt;&lt;s5&gt;Country&lt;/s5&gt;&lt;/c4&gt; class has a &lt;c6&gt;&lt;s7&gt;capitalCity&lt;/s7&gt;&lt;/c6&gt; property, and the &lt;c8&gt;&lt;s9&gt;City&lt;/s9&gt;&lt;/c8&gt; class has a &lt;c10&gt;&lt;s11&gt;country&lt;/s11&gt;&lt;/c10&gt; property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これを表すために、&lt;c4&gt;&lt;s5&gt;Country&lt;/s5&gt;&lt;/c4&gt;クラスは&lt;c6&gt;&lt;s7&gt;capitalCity&lt;/s7&gt;&lt;/c6&gt;プロパティを持ちます、そして、&lt;c8&gt;&lt;s9&gt;City&lt;/s9&gt;&lt;/c8&gt;クラスは&lt;c10&gt;&lt;s11&gt;country&lt;/s11&gt;&lt;/c10&gt;プロパティを持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To require that subclasses implement a superclass’s initializer, mark the superclass’s initializer with the &lt;c0&gt;&lt;s1&gt;required&lt;/s1&gt;&lt;/c0&gt; declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるスーパークラスの持つイニシャライザをそのサブクラスたちが実装することを要求するために、そのスーパークラスのイニシャライザを&lt;c0&gt;&lt;s1&gt;required&lt;/s1&gt;&lt;/c0&gt;宣言修飾子で印してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To restrict the adoption of a protocol to class types only, include the &lt;c0&gt;&lt;s1&gt;AnyObject&lt;/s1&gt;&lt;/c0&gt; protocol in the &lt;e2&gt;inherited protocols&lt;/e2&gt; list after the colon.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロトコルの採用をクラス型のみに制約するには、&lt;c0&gt;&lt;s1&gt;AnyObject&lt;/s1&gt;&lt;/c0&gt;プロトコルを&lt;e2&gt;継承されたプロトコル&lt;/e2&gt;のリストの中にコロンの後で加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To retrieve a count of the &lt;c0&gt;&lt;s1&gt;Character&lt;/s1&gt;&lt;/c0&gt; values in a string, use the &lt;c2&gt;&lt;s3&gt;count&lt;/s3&gt;&lt;/c2&gt; property of the string:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある文字列の中の&lt;c0&gt;&lt;s1&gt;Character&lt;/s1&gt;&lt;/c0&gt;値の総数を取り出すために、その文字列の&lt;c2&gt;&lt;s3&gt;count&lt;/s3&gt;&lt;/c2&gt;プロパティを使ってください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To see an example of how to create and implement a new operator, see &lt;a12&gt;&lt;s13&gt;Custom Operators&lt;/s13&gt;&lt;/a12&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい演算子の作成と実装の方法の例を見るには、&lt;a12&gt;&lt;s13&gt;あつらえの演算子&lt;/s13&gt;&lt;/a12&gt;を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To see an example of how to use a &lt;c0&gt;&lt;s1&gt;do&lt;/s1&gt;&lt;/c0&gt; statement with several &lt;c2&gt;&lt;s3&gt;catch&lt;/s3&gt;&lt;/c2&gt; clauses, see &lt;a4&gt;&lt;s5&gt;Handling Errors&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;do&lt;/s1&gt;&lt;/c0&gt;文を複数の&lt;c2&gt;&lt;s3&gt;catch&lt;/s3&gt;&lt;/c2&gt;節とともに使う方法の例を見るために、&lt;a4&gt;&lt;s5&gt;エラーを処理する&lt;/s5&gt;&lt;/a4&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To see examples of initializers in various type declarations, see &lt;a0&gt;&lt;s1&gt;Initialization&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いろいろな型宣言におけるイニシャライザの例を見るために、&lt;a0&gt;&lt;s1&gt;初期化&lt;/s1&gt;&lt;/a0&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To set its value, the subscript setter is called in the same way.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その値を設定するために、添え字セッターが同様に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To set up the interdependency between the two classes, the initializer for &lt;c0&gt;&lt;s1&gt;City&lt;/s1&gt;&lt;/c0&gt; takes a &lt;c2&gt;&lt;s3&gt;Country&lt;/s3&gt;&lt;/c2&gt; instance, and stores this instance in its &lt;c4&gt;&lt;s5&gt;country&lt;/s5&gt;&lt;/c4&gt; property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つのクラスの間で相互依存を設定するために、&lt;c0&gt;&lt;s1&gt;City&lt;/s1&gt;&lt;/c0&gt;のためのイニシャライザは、&lt;c2&gt;&lt;s3&gt;Country&lt;/s3&gt;&lt;/c2&gt;インスタンスをとって、このインスタンスをそれの&lt;c4&gt;&lt;s5&gt;country&lt;/s5&gt;&lt;/c4&gt;プロパティに保管します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To simplify the relationships between designated and convenience initializers, Swift applies the following three rules for delegation calls between initializers:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>指定と便宜イニシャライザの間の関係を単純化するために、スウィフトは以下の３つの規則をイニシャライザ間の委任呼び出しに対して適用します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To specify an in-out parameter, prefix the parameter type with the &lt;c0&gt;&lt;s1&gt;inout&lt;/s1&gt;&lt;/c0&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>in-outパラメータを指定するために、&lt;c0&gt;&lt;s1&gt;inout&lt;/s1&gt;&lt;/c0&gt;キーワードをそのパラメータ型の前に置いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To specify that the &lt;c0&gt;&lt;s1&gt;push(_:)&lt;/s1&gt;&lt;/c0&gt; method has a single parameter called &lt;c2&gt;&lt;s3&gt;item&lt;/s3&gt;&lt;/c2&gt;, which must be of type &lt;c4&gt;&lt;s5&gt;Element&lt;/s5&gt;&lt;/c4&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;push(_:)&lt;/s1&gt;&lt;/c0&gt;メソッドが１つのパラメータ、&lt;c2&gt;&lt;s3&gt;item&lt;/s3&gt;&lt;/c2&gt;と呼ばれるものを持つことを指定する所で、それは、型&lt;c4&gt;&lt;s5&gt;Element&lt;/s5&gt;&lt;/c4&gt;でなければなりません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To specify that the value returned by the &lt;c0&gt;&lt;s1&gt;pop()&lt;/s1&gt;&lt;/c0&gt; method will be a value of type &lt;c2&gt;&lt;s3&gt;Element&lt;/s3&gt;&lt;/c2&gt;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;pop()&lt;/s1&gt;&lt;/c0&gt;メソッドによって返される値が型&lt;c2&gt;&lt;s3&gt;Element&lt;/s3&gt;&lt;/c2&gt;の値であることを示す所で</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To support recursion, the compiler must insert a layer of indirection.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>再帰をサポートするために、コンパイラは間接参照の階層を差し入れる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To support setting an initial value or other customization, the property wrapper needs to add an initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期値の設定または他のカスタマイゼーションをサポートするには、プロパティラッパーはイニシャライザの追加を必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To use a function, you “call” that function with its name and pass it input values (known as &lt;e1&gt;arguments&lt;/e1&gt;) that match the types of the function’s parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある関数を使うためには、あなたはその関数をそれの名前を使って「呼び出し」、それにその関数のパラメータの型に適合する入力値（&lt;e1&gt;引数&lt;/e1&gt;として知られます）を渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To use a nested type outside of its definition context, prefix its name with the name of the type it is nested within:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>入れ子にされた型をその定義の文脈外で使うために、その名前にそれが入れ子にされている型の名前で接頭辞を付けてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To use a reserved word as an identifier, put a backtick (&lt;c0&gt;&lt;s1&gt;`&lt;/s1&gt;&lt;/c0&gt;) before and after it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>識別子として予約語を使用するために、それの前後にバッククォート（&lt;c0&gt;&lt;s1&gt;`&lt;/s1&gt;&lt;/c0&gt;）を置いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To use it in the ternary conditional (&lt;c6&gt;&lt;s7&gt;?&lt;/s7&gt;&lt;/c6&gt; &lt;c8&gt;&lt;s9&gt;:&lt;/s9&gt;&lt;/c8&gt;) operator, it must have whitespace around both sides.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それを三項条件（&lt;c6&gt;&lt;s7&gt;?&lt;/s7&gt;&lt;/c6&gt; &lt;c8&gt;&lt;s9&gt;:&lt;/s9&gt;&lt;/c8&gt;）において使うためには、それは両側に空白を持ってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To use optional chaining, use a question mark in place of the exclamation point:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナル連鎖を使用するために、感嘆符の代わりに疑問符を使ってください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To use string interpolation inside a string that uses extended delimiters, match the number of number signs after the backslash to the number of number signs at the beginning and end of the string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列補間を拡張区切り記号を使う文字列内部で使うには、バックスラッシュの後のシャープ記号の数をその文字列の始まりと終わりでのシャープ記号の数と合わせてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To use the &lt;c4&gt;&lt;s5&gt;?&lt;/s5&gt;&lt;/c4&gt; as the optional-chaining operator, it must not have whitespace on the left.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;?&lt;/s5&gt;&lt;/c4&gt;をオプショナル連鎖演算子として使うには、それは左側に空白を持ってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To win, you must land &lt;e0&gt;exactly&lt;/e0&gt; on square 25.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>勝つために、あなたは&lt;e0&gt;ぴったり&lt;/e0&gt;正方形25に到着しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To work out the exact evaluation order to use, you also need to consider their associativity.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>使用する的確な評価順序を解き明かすには、あなたはまたそれらの結合性を考慮する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Top-Level Code</seg>
      </tuv>
      <tuv lang="JA">
        <seg>トップレベル・コード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tradition suggests that the first program in a new language should print the words “Hello, world!” on the screen.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>伝統は、新しい言語において最初のプログラムが画面上に語句「Hello, world!」を出力しなければならないことを示唆します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Trailing Closures</seg>
      </tuv>
      <tuv lang="JA">
        <seg>後付クロージャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Trailing closure syntax</seg>
      </tuv>
      <tuv lang="JA">
        <seg>後付クロージャ構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Trailing closures are most useful when the closure is sufficiently long that it is not possible to write it inline on a single line.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャがそれをただ１つの行の行内に書くことが可能でないほど長いとき、後付クロージャは最も役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Try Operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>try演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Try removing the conversion to &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; from the last line.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最後の行から&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;への転換を取り除いてみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Try removing the default case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>何れにも当てはまらない場合の部分（default: の部分）を取り除いてみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Trying to change the value of a function parameter from within the body of that function results in a compile-time error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その関数の本文内部から関数パラメータの値を変えようとすることは、コンパイル時エラーに終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Trying to set an &lt;c6&gt;&lt;s7&gt;Int16&lt;/s7&gt;&lt;/c6&gt; constant or variable to a number outside of this range causes an error:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;Int16&lt;/s7&gt;&lt;/c6&gt;定数または変数をこの範囲の外側の数に設定する試みは、エラーを引き起こします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Trying to store 24 actually stores a value of 12 instead, because 24 is too large for the property setter’s rule.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>24を格納する試みは、実際には12の値を代わりに格納します、なぜなら24はプロパティのセッターのもつ規則には大きすぎるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Trying to use &lt;c0&gt;&lt;s1&gt;!&lt;/s1&gt;&lt;/c0&gt; to access a nonexistent optional value triggers a runtime error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>存在しないオプショナルの値にアクセスするために&lt;c0&gt;&lt;s1&gt;!&lt;/s1&gt;&lt;/c0&gt;を使うことを試みることは、実行時エラーの引き金となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuple Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプル式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuple Pattern</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプルパターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuple Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプル型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuple Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプル型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuple patterns match values of corresponding tuple types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプルパターンは、対応するタプル型の値にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuple types don’t have a standalone definition in the way that classes, structures, enumerations, and functions do.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプル型には、クラス、構造体、列挙、そして関数が行う方法での、独立した定義がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuples</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuples are compared from left to right, one value at a time, until the comparison finds two values that aren’t equal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプルは、左から右へと、一度に１つの値を、比較が等しくない２つの値を見つけるまで、比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuples are particularly useful as the return values of functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプルは、特に関数の戻り値として便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuples are useful for simple groups of related values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプルは、関連した値の単純なグループに対して便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuples can also be used as parameter types and return types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプルもまた、パラメータ型および戻り型として使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuples can be compared with a given operator only if the operator can be applied to each value in the respective tuples.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプルは、与えられた演算子で比較されることが、その演算子がそれぞれのタプルの中の値それぞれに適用可能である場合にのみ可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tuples enable you to create and pass around groupings of values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプルは、あなたに値のグループをつくってあちこち渡すことを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Two &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; values (or two &lt;c2&gt;&lt;s3&gt;Character&lt;/s3&gt;&lt;/c2&gt; values) are considered equal if their extended grapheme clusters are &lt;e4&gt;canonically equivalent&lt;/e4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つの&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;値（または２つの&lt;c2&gt;&lt;s3&gt;Character&lt;/s3&gt;&lt;/c2&gt;）は、それらの拡張書記素クラスタたちが&lt;e4&gt;正準等価&lt;/e4&gt;ならば、等しいとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Two extension declarations attempt to add conditional conformance to the &lt;c0&gt;&lt;s1&gt;Serializable&lt;/s1&gt;&lt;/c0&gt; protocol, one for for arrays with &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt; elements, and one for arrays with &lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt; elements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つの拡張宣言は、&lt;c0&gt;&lt;s1&gt;Serializable&lt;/s1&gt;&lt;/c0&gt;プロトコルへの条件準拠を加えることを試みます、&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;要素を持つ配列のために１つ、そして&lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt;要素を持つ配列のために１つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Two flipped shapes returned by this function might have completely different types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この関数によって返される２つの裏返された形状が、完全に異なる型を持つかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Two-Phase Initialization</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２段階初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Two-phase initialization prevents property values from being accessed before they are initialized, and prevents property values from being set to a different value by another initializer unexpectedly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２段階初期化は、プロパティ値が初期化される前にアクセスされるのを妨げます、それによってプロパティ値が思いもよらず別のイニシャライザによって異なる値に設定されるのを防ぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Alias Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型エイリアス宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Aliases</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型エイリアス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Annotation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型注釈</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Annotations</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さまざまな型注釈</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Attributes</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Casting</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型キャスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Casting for Any and AnyObject</seg>
      </tuv>
      <tuv lang="JA">
        <seg>AnyおよびAnyObjectに対する型キャスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Constraint Syntax</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型制約構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Constraints</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型制約</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Constraints in Action</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型制約の動作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Identifier</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型識別子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Inference</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型推論</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Inheritance Clause</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型継承節</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Methods</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Parameters</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型パラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Property Syntax</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型プロパティ構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Safety and Type Inference</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型安全と型推論</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Subscript Declarations</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型添え字宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Subscripts</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型添え字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type Variable Properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型変数プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type alias declarations are declared using the &lt;c1&gt;&lt;s2&gt;typealias&lt;/s2&gt;&lt;/c1&gt; keyword and have the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型エイリアス宣言は、キーワード&lt;c1&gt;&lt;s2&gt;typealias&lt;/s2&gt;&lt;/c1&gt;を使って宣言されます、そして以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type aliases are useful when you want to refer to an existing type by a name that is contextually more appropriate, such as when working with data of a specific size from an external source:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型エイリアスは、あなたがより文脈上適切な名前で既存の型に言及したいとき役に立ちます、たとえば外部ソースからの特定の大きさのデータを扱う時など：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type aliases do not create new types; they simply allow a name to refer to an existing type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型エイリアスは、新しい型を作成しません；それらは、単にある名前が既存の型に言及できるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type annotations begin with a colon (&lt;c1&gt;&lt;s2&gt;:&lt;/s2&gt;&lt;/c1&gt;) and end with a type, as the following examples show:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型注釈は、以下の例が示すように、コロン（&lt;c1&gt;&lt;s2&gt;:&lt;/s2&gt;&lt;/c1&gt;）で始まりひとつの型で終わります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type annotations can contain an optional list of type attributes before the type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型注釈は、型の前に任意の型属性のリストを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type casting enables you to check and interpret the type of a class instance at runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型キャストは、あなたにクラスインスタンスの型を実行時に調べて解釈することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type casting in Swift is implemented with the &lt;c0&gt;&lt;s1&gt;is&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;as&lt;/s3&gt;&lt;/c2&gt; operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでの型キャストは、&lt;c0&gt;&lt;s1&gt;is&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;as&lt;/s3&gt;&lt;/c2&gt;演算子を使って実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type casts that can fail at runtime now use the &lt;c0&gt;&lt;s1&gt;as?&lt;/s1&gt;&lt;/c0&gt; or &lt;c2&gt;&lt;s3&gt;as!&lt;/s3&gt;&lt;/c2&gt; operator, and type casts that are guaranteed not to fail use the &lt;c4&gt;&lt;s5&gt;as&lt;/s5&gt;&lt;/c4&gt; operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実行時に失敗できる型キャストは、今では&lt;c0&gt;&lt;s1&gt;as?&lt;/s1&gt;&lt;/c0&gt;または&lt;c2&gt;&lt;s3&gt;as!&lt;/s3&gt;&lt;/c2&gt;演算子を使います、そして失敗しないことを保証される型キャストは&lt;c4&gt;&lt;s5&gt;as&lt;/s5&gt;&lt;/c4&gt;演算子を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type constraints specify that a type parameter must inherit from a specific class, or conform to a particular protocol or protocol composition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型制約は、型パラメータが特定のクラスから継承しなければならない、もしくはある特定のプロトコルまたはプロトコル合成に準拠しなければならないことを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type constraints, as described in &lt;a0&gt;&lt;s1&gt;Type Constraints&lt;/s1&gt;&lt;/a0&gt;, enable you to define requirements on the type parameters associated with a generic function, subscript, or type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型制約は、「&lt;a0&gt;&lt;s1&gt;型制約&lt;/s1&gt;&lt;/a0&gt;」で記述されるように、総称体の関数、添え字、または型と関連した型パラメータに要件を定義することをあなたに可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type inference enables a compiler to deduce the type of a particular expression automatically when it compiles your code, simply by examining the values you provide.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型推論は、コンパイラに自動的に特定の式の型を演繹することを、それがあなたのコードをコンパイルする時に、単純にあなたが提供する値を調べることによって、可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type inference helps make Swift code more concise and readable when it initializes constants or variables with other values whose type is already known.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型推論は、スウィフトのコードを、それが定数または変数を型がすでに知られている他の値で初期化するとき、より簡潔で読みやすくするのを助けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type inference in Swift operates at the level of a single expression or statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトの型推論は、単一の式や文の水準で働きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type inference is particularly useful when you declare a constant or variable with an initial value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが最初の値で定数または変数を宣言するとき、型推論は特に役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type methods and properties now use the &lt;c0&gt;&lt;s1&gt;static&lt;/s1&gt;&lt;/c0&gt; keyword as a declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッドとプロパティは今では&lt;c0&gt;&lt;s1&gt;static&lt;/s1&gt;&lt;/c0&gt;キーワードを宣言修飾子として使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type methods are called with dot syntax, like instance methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型メソッドは、インスタンスメソッドの様に、ドット構文で呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type methods are similar to class methods in Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型メソッドは、Objective-Cにおけるクラスメソッドに似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type parameters specify and name a placeholder type, and are written immediately after the function’s name, between a pair of matching angle brackets (such as &lt;c5&gt;&lt;s6&gt;&lt;T&gt;&lt;/s6&gt;&lt;/c5&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型パラメータは、プレースホルダ型を指定して命名します、そして関数の名前の直後に一対の山形括弧の間で書かれます（例えば&lt;c5&gt;&lt;s6&gt;&lt;T&gt;&lt;/s6&gt;&lt;/c5&gt;）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type properties are discussed in &lt;a4&gt;&lt;s5&gt;Type Properties&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型プロパティは、&lt;a4&gt;&lt;s5&gt;型プロパティ&lt;/s5&gt;&lt;/a4&gt;で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type properties are discussed in &lt;a6&gt;&lt;s7&gt;Type Properties&lt;/s7&gt;&lt;/a6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型プロパティは、&lt;a6&gt;&lt;s7&gt;型プロパティ&lt;/s7&gt;&lt;/a6&gt;で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type properties are queried and set with dot syntax, just like instance properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型プロパティは、インスタンスプロパティのように、ドット構文で問い合わせられ設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type properties are useful for defining values that are universal to &lt;e0&gt;all&lt;/e0&gt; instances of a particular type, such as a constant property that all instances can use (like a static constant in C), or a variable property that stores a value that is global to all instances of that type (like a static variable in C).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型プロパティは、特定の型の&lt;e0&gt;全ての&lt;/e0&gt;インスタンスに共通なさまざまな値を定義することに役立ちます、例えば、全てのインスタンスが使うことができる定数プロパティ（Cでの静的定数のように）、またはその型の全てのインスタンスにグローバルである値を格納する変数プロパティ（Cでの静的変数のように）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type safety helps you catch and fix errors as early as possible in the development process.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型安全は、あなたが開発プロセスにおいて可能な限り早期にエラーを捕まえて修復するのを助けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type-Casting Operators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型キャスト演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type-Casting Patterns</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型キャスト・パターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Type-checking helps you avoid errors when you’re working with different types of values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型をチェックすることは、あなたが異なる種類の値を扱っているとき、あなたがエラーを避ける手助けをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Types can be nested to as many levels as are required.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型は、必要とされるだけ多くの階層に入れ子にされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Types declared with the &lt;c0&gt;&lt;s1&gt;dynamicMemberLookup&lt;/s1&gt;&lt;/c0&gt; attribute include members that are looked up at runtime, as described in &lt;a2&gt;&lt;s3&gt;Attributes&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;dynamicMemberLookup&lt;/s1&gt;&lt;/c0&gt;属性とともに宣言される型は、実行時に捜されるメンバーを含みます、&lt;a2&gt;&lt;s3&gt;属性&lt;/s3&gt;&lt;/a2&gt;で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Types don’t automatically adopt a protocol just by satisfying its requirements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>型は、単にその要件を満たすことだけによっては自動的にあるプロトコルを採用しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Types like structures, tuples, and enumerations are made up of individual constituent values, such as the properties of a structure or the elements of a tuple.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体、タプル、そして列挙のようないくつかの型は、例えば構造体のプロパティやタプルの要素などのような個々の構成要素から作り上げられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Types that conform to the &lt;c2&gt;&lt;s3&gt;Hashable&lt;/s3&gt;&lt;/c2&gt; protocol must provide a gettable &lt;c4&gt;&lt;s5&gt;Int&lt;/s5&gt;&lt;/c4&gt; property called &lt;c6&gt;&lt;s7&gt;hashValue&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;Hashable&lt;/s3&gt;&lt;/c2&gt;プロトコルに適合する型は、取得可能な&lt;c4&gt;&lt;s5&gt;Int&lt;/s5&gt;&lt;/c4&gt;プロパティ、&lt;c6&gt;&lt;s7&gt;hashValue&lt;/s7&gt;&lt;/c6&gt;と呼ばれるものを提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically you don’t need to perform manual cleanup when your instances are deallocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>概して、あなたのインスタンスが割り当て解除されるとき、あなたが手動で掃除をする必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typically, you use the &lt;c4&gt;&lt;s5&gt;if&lt;/s5&gt;&lt;/c4&gt; statement to evaluate simple conditions with only a few possible outcomes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一般的に、あなたは&lt;c4&gt;&lt;s5&gt;if&lt;/s5&gt;&lt;/c4&gt;文をほんの２、３の起こりうる結果だけを持つ単純な状況を評価するために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>U+0000, U+0009, U+000B, U+000C, or U+0020</seg>
      </tuv>
      <tuv lang="JA">
        <seg>U+0000, U+0009, U+000B, U+000C, または U+0020</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>U+000D followed by U+000A</seg>
      </tuv>
      <tuv lang="JA">
        <seg>U+000D に続けて U+000A</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>U+00A8, U+00AA, U+00AD, U+00AF, U+00B2–U+00B5, or U+00B7–U+00BA</seg>
      </tuv>
      <tuv lang="JA">
        <seg>U+00A8, U+00AA, U+00AD, U+00AF, U+00B2–U+00B5, または U+00B7–U+00BA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>U+00BC–U+00BE, U+00C0–U+00D6, U+00D8–U+00F6, or U+00F8–U+00FF</seg>
      </tuv>
      <tuv lang="JA">
        <seg>U+00BC–U+00BE, U+00C0–U+00D6, U+00D8–U+00F6, または U+00F8–U+00FF</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>U+0100–U+02FF, U+0370–U+167F, U+1681–U+180D, or U+180F–U+1DBF</seg>
      </tuv>
      <tuv lang="JA">
        <seg>U+0100–U+02FF, U+0370–U+167F, U+1681–U+180D, または U+180F–U+1DBF</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>U+0300–U+036F, U+1DC0–U+1DFF, U+20D0–U+20FF, or U+FE20–U+FE2F</seg>
      </tuv>
      <tuv lang="JA">
        <seg>U+0300–U+036F, U+1DC0–U+1DFF, U+20D0–U+20FF, または U+FE20–U+FE2F</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>U+10000–U+1FFFD, U+20000–U+2FFFD, U+30000–U+3FFFD, or U+40000–U+4FFFD</seg>
      </tuv>
      <tuv lang="JA">
        <seg>U+10000–U+1FFFD, U+20000–U+2FFFD, U+30000–U+3FFFD, または U+40000–U+4FFFD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>U+200B–U+200D, U+202A–U+202E, U+203F–U+2040, U+2054, or U+2060–U+206F</seg>
      </tuv>
      <tuv lang="JA">
        <seg>U+200B–U+200D, U+202A–U+202E, U+203F–U+2040, U+2054, または U+2060–U+206F</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>U+2070–U+20CF, U+2100–U+218F, U+2460–U+24FF, or U+2776–U+2793</seg>
      </tuv>
      <tuv lang="JA">
        <seg>U+2070–U+20CF, U+2100–U+218F, U+2460–U+24FF, または U+2776–U+2793</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>U+3004–U+3007, U+3021–U+302F, U+3031–U+303F, or U+3040–U+D7FF</seg>
      </tuv>
      <tuv lang="JA">
        <seg>U+3004–U+3007, U+3021–U+302F, U+3031–U+303F, または U+3040–U+D7FF</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>U+50000–U+5FFFD, U+60000–U+6FFFD, U+70000–U+7FFFD, or U+80000–U+8FFFD</seg>
      </tuv>
      <tuv lang="JA">
        <seg>U+50000–U+5FFFD, U+60000–U+6FFFD, U+70000–U+7FFFD, または U+80000–U+8FFFD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>U+90000–U+9FFFD, U+A0000–U+AFFFD, U+B0000–U+BFFFD, or U+C0000–U+CFFFD</seg>
      </tuv>
      <tuv lang="JA">
        <seg>U+90000–U+9FFFD, U+A0000–U+AFFFD, U+B0000–U+BFFFD, または U+C0000–U+CFFFD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>U+D0000–U+DFFFD or U+E0000–U+EFFFD</seg>
      </tuv>
      <tuv lang="JA">
        <seg>U+D0000–U+DFFFD または U+E0000–U+EFFFD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>U+F900–U+FD3D, U+FD40–U+FDCF, U+FDF0–U+FE1F, or U+FE30–U+FE44</seg>
      </tuv>
      <tuv lang="JA">
        <seg>U+F900–U+FD3D, U+FD40–U+FDCF, U+FDF0–U+FE1F, または U+FE30–U+FE44</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>UInt</seg>
      </tuv>
      <tuv lang="JA">
        <seg>符号なし整数（Unsigned Integer）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>UTF-16 Representation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>UTF-16表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>UTF-8 Representation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>UTF-8表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unary &lt;e3&gt;prefix&lt;/e3&gt; operators appear immediately before their target (such as &lt;c4&gt;&lt;s5&gt;!b&lt;/s5&gt;&lt;/c4&gt;), and unary &lt;e6&gt;postfix&lt;/e6&gt; operators appear immediately after their target (such as &lt;c7&gt;&lt;s8&gt;c!&lt;/s8&gt;&lt;/c7&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単項&lt;e3&gt;接頭辞&lt;/e3&gt;演算子はそれらの目標の直前に現れます（例えば&lt;c4&gt;&lt;s5&gt;!b&lt;/s5&gt;&lt;/c4&gt;のように）、そして単項&lt;e6&gt;接尾辞&lt;/e6&gt;演算子はそれらの目標の直後に現れます（例えば&lt;c7&gt;&lt;s8&gt;c!&lt;/s8&gt;&lt;/c7&gt;のように）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unary Minus Operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単項マイナス演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unary Plus Operator</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単項プラス演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unary operators operate on a single target.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単項演算子は、１つの目標に作用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Underscores (&lt;c0&gt;&lt;s1&gt;_&lt;/s1&gt;&lt;/c0&gt;) are allowed between digits for readability, but they’re ignored and therefore don’t affect the value of the literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アンダースコア（&lt;c0&gt;&lt;s1&gt;_&lt;/s1&gt;&lt;/c0&gt;）は、可読性のために桁の間で認められます、しかしそれらは無視されて、それゆえにリテラルの値に影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Understanding Conflicting Access to Memory</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メモリへのアクセスの衝突を理解する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, linking these two instances creates a strong reference cycle between them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>残念なことに、これらの２つのインスタンスを結ぶことは、それらの間で強い参照循環をつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unfortunately, the &lt;c0&gt;&lt;s1&gt;HTMLElement&lt;/s1&gt;&lt;/c0&gt; class, as written above, creates a strong reference cycle between an &lt;c2&gt;&lt;s3&gt;HTMLElement&lt;/s3&gt;&lt;/c2&gt; instance and the closure used for its default &lt;c4&gt;&lt;s5&gt;asHTML&lt;/s5&gt;&lt;/c4&gt; value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>残念なことに、この&lt;c0&gt;&lt;s1&gt;HTMLElement&lt;/s1&gt;&lt;/c0&gt;クラスは、上で書かれるように、&lt;c2&gt;&lt;s3&gt;HTMLElement&lt;/s3&gt;&lt;/c2&gt;インスタンスとその省略時の&lt;c4&gt;&lt;s5&gt;asHTML&lt;/s5&gt;&lt;/c4&gt;値のために使われるクロージャとの間に強い参照循環をつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unicode</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユニコード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unicode Representations of Strings</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列のユニコード表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unicode Scalar Representation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユニコード・スカラー表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unicode scalar (&lt;c0&gt;&lt;s1&gt;\u{&lt;/s1&gt;&lt;/c0&gt;&lt;e2&gt;n&lt;/e2&gt;&lt;c3&gt;&lt;s4&gt;}&lt;/s4&gt;&lt;/c3&gt;), where &lt;e5&gt;n&lt;/e5&gt; is a hexadecimal number that has one to eight digits</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユニコード・スカラー（&lt;c0&gt;&lt;s1&gt;\u{&lt;/s1&gt;&lt;/c0&gt;&lt;e2&gt;n&lt;/e2&gt;&lt;c3&gt;&lt;s4&gt;}&lt;/s4&gt;&lt;/c3&gt;）、ここで&lt;e5&gt;n&lt;/e5&gt;は16進数で１から８桁を持ちます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unicode scalars for regional indicator symbols can be combined in pairs to make a single &lt;c0&gt;&lt;s1&gt;Character&lt;/s1&gt;&lt;/c0&gt; value, such as this combination of &lt;c2&gt;&lt;s3&gt;REGIONAL&lt;/s3&gt; &lt;s4&gt;INDICATOR&lt;/s4&gt; &lt;s5&gt;SYMBOL&lt;/s5&gt; &lt;s6&gt;LETTER&lt;/s6&gt; &lt;s7&gt;U&lt;/s7&gt;&lt;/c2&gt; (&lt;c8&gt;&lt;s9&gt;U+1F1FA&lt;/s9&gt;&lt;/c8&gt;) and &lt;c10&gt;&lt;s11&gt;REGIONAL&lt;/s11&gt; &lt;s12&gt;INDICATOR&lt;/s12&gt; &lt;s13&gt;SYMBOL&lt;/s13&gt; &lt;s14&gt;LETTER&lt;/s14&gt; &lt;s15&gt;S&lt;/s15&gt;&lt;/c10&gt; (&lt;c16&gt;&lt;s17&gt;U+1F1F8&lt;/s17&gt;&lt;/c16&gt;):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>地域標識記号のためのユニコード・スカラーは、単一の&lt;c0&gt;&lt;s1&gt;Character&lt;/s1&gt;&lt;/c0&gt;値を作るために２つ一組で組み合わされることが出来ます、例えば&lt;c2&gt;&lt;s3&gt;REGIONAL&lt;/s3&gt; &lt;s4&gt;INDICATOR&lt;/s4&gt; &lt;s5&gt;SYMBOL&lt;/s5&gt; &lt;s6&gt;LETTER&lt;/s6&gt; &lt;s7&gt;U&lt;/s7&gt;&lt;/c2&gt;（&lt;c8&gt;&lt;s9&gt;U+1F1FA&lt;/s9&gt;&lt;/c8&gt;）と&lt;c10&gt;&lt;s11&gt;REGIONAL&lt;/s11&gt; &lt;s12&gt;INDICATOR&lt;/s12&gt; &lt;s13&gt;SYMBOL&lt;/s13&gt; &lt;s14&gt;LETTER&lt;/s14&gt; &lt;s15&gt;S&lt;/s15&gt;&lt;/c10&gt;（&lt;c16&gt;&lt;s17&gt;U+1F1F8&lt;/s17&gt;&lt;/c16&gt;）の組み合わせのように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless otherwise specified, the default access level is internal, as described in &lt;a0&gt;&lt;s1&gt;Default Access Levels&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に明記しない限り、&lt;a0&gt;&lt;s1&gt;省略時のアクセス水準&lt;/s1&gt;&lt;/a0&gt;で記述されるように、省略時のアクセス水準は内部です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless otherwise specified, the default inferred type of a floating-point literal is the Swift standard library type &lt;c0&gt;&lt;s1&gt;Double&lt;/s1&gt;&lt;/c0&gt;, which represents a 64-bit floating-point number.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に明記しない限り、初期状態で推論されるリテラル浮動小数点の型は、スウィフト標準ライブラリ型&lt;c0&gt;&lt;s1&gt;Double&lt;/s1&gt;&lt;/c0&gt;です、それは、64ビットの浮動小数点数を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless otherwise specified, the default inferred type of an integer literal is the Swift standard library type &lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に明記しない限り、初期状態で推論されるリテラル整数の型は、スウィフト標準ライブラリ型&lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless the value of &lt;c0&gt;&lt;s1&gt;integerToDescribe&lt;/s1&gt;&lt;/c0&gt; is in the list of known prime numbers, it is not matched by the first &lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt; case at all.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;integerToDescribe&lt;/s1&gt;&lt;/c0&gt;の値が知っている素数のリストの中にある場合を除いて、それは最初の&lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt;ケース節に適合することはまったくありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unless you need to work with a specific size of integer, always use &lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt; for integer values in your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが整数の特定のサイズを扱う必要がない限り、常に、あなたのコードの整数値のために&lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt;を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike &lt;c2&gt;&lt;s3&gt;public&lt;/s3&gt;&lt;/c2&gt;, the compiler doesn’t allow declarations marked with &lt;c4&gt;&lt;s5&gt;usableFromInline&lt;/s5&gt;&lt;/c4&gt; to be referenced by name in code outside the module, even though the declaration’s symbol is exported.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;public&lt;/s3&gt;&lt;/c2&gt;とは違い、コンパイラは&lt;c4&gt;&lt;s5&gt;usableFromInline&lt;/s5&gt;&lt;/c4&gt;で印される宣言に名前によってモジュール外部のコードにおいて参照されるのを許しません、宣言のシンボルがエクスポートされるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike &lt;c4&gt;&lt;s5&gt;flip(_:)&lt;/s5&gt;&lt;/c4&gt;, the value that &lt;c6&gt;&lt;s7&gt;protoFlip(_:)&lt;/s7&gt;&lt;/c6&gt; returns isn’t required to always have the same type—it just has to conform to the &lt;c8&gt;&lt;s9&gt;Shape&lt;/s9&gt;&lt;/c8&gt; protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;flip(_:)&lt;/s5&gt;&lt;/c4&gt;とは違い、&lt;c6&gt;&lt;s7&gt;protoFlip(_:)&lt;/s7&gt;&lt;/c6&gt;が返す値は、常に同じ型を持つように要求されません — それは単に&lt;c8&gt;&lt;s9&gt;Shape&lt;/s9&gt;&lt;/c8&gt;プロトコルに準拠しなければならないだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike Boolean conditions, you can’t combine availability conditions using logical operators such as &lt;c0&gt;&lt;s1&gt;&amp;&amp;&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;||&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ブール条件と違って、あなたは論理演算子例えば&lt;c0&gt;&lt;s1&gt;&amp;&amp;&lt;/s1&gt;&lt;/c0&gt;や&lt;c2&gt;&lt;s3&gt;||&lt;/s3&gt;&lt;/c2&gt;などを使って有効性条件を連結することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike C, Swift allows multiple &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; cases to consider the same value or values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Cと違って、スウィフトは複数の&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;ケース節に、同じ値または複数の値について考慮させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike Objective-C initializers, Swift initializers do not return a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cのイニシャライザと違って、スウィフトのイニシャライザは値を返しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike a &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; statement in C, this &lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt; statement does not match both &lt;c4&gt;&lt;s5&gt;"a"&lt;/s5&gt;&lt;/c4&gt; and &lt;c6&gt;&lt;s7&gt;"A"&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Cでの&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;文と違って、この&lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt;文は&lt;c4&gt;&lt;s5&gt;"a"&lt;/s5&gt;&lt;/c4&gt;と&lt;c6&gt;&lt;s7&gt;"A"&lt;/s7&gt;&lt;/c6&gt;の両方に合うものを見つけるわけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike a default initializer, the structure receives a memberwise initializer even if it has stored properties that don’t have default values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時のイニシャライザと違って、構造体はメンバー関連イニシャライザを受け取ります、たとえそれが省略時の値を持たない格納プロパティを持つとしても。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike a single-line string literal, a multiline string literal can contain unescaped double quotation marks (&lt;c0&gt;&lt;s1&gt;"&lt;/s1&gt;&lt;/c0&gt;), carriage returns, and line feeds.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>単一行の文字列リテラルと違い、複数行の文字列リテラルはエスケープされていない二重引用符（&lt;c0&gt;&lt;s1&gt;"&lt;/s1&gt;&lt;/c0&gt;）、キャリッジリターン、そしてラインフィードを含むことが出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike a subscript, however, the &lt;c4&gt;&lt;s5&gt;updateValue(_:forKey:)&lt;/s5&gt;&lt;/c4&gt; method returns the &lt;e6&gt;old&lt;/e6&gt; value after performing an update.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、添え字とは違い、&lt;c4&gt;&lt;s5&gt;updateValue(_:forKey:)&lt;/s5&gt;&lt;/c4&gt;メソッドは更新を実行した後に&lt;e6&gt;古い&lt;/e6&gt;値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike a variable, the value of a constant can’t be changed after it’s set.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変数とは異なり、それが設定された後で定数の値は変更できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike a weak reference, however, an unowned reference is used when the other instance has the same lifetime or a longer lifetime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、弱い参照とは違い、非所有参照は他のインスタンスが同じ生涯またはより長い生涯を持つ場合に使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike an &lt;c8&gt;&lt;s9&gt;if&lt;/s9&gt;&lt;/c8&gt; statement, a &lt;c10&gt;&lt;s11&gt;guard&lt;/s11&gt;&lt;/c10&gt; statement always has an &lt;c12&gt;&lt;s13&gt;else&lt;/s13&gt;&lt;/c12&gt; clause—the code inside the &lt;c14&gt;&lt;s15&gt;else&lt;/s15&gt;&lt;/c14&gt; clause is executed if the condition is not true.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c8&gt;&lt;s9&gt;if&lt;/s9&gt;&lt;/c8&gt;文と違って、&lt;c10&gt;&lt;s11&gt;guard&lt;/s11&gt;&lt;/c10&gt;文は常に&lt;c12&gt;&lt;s13&gt;else&lt;/s13&gt;&lt;/c12&gt;節を持ちます—&lt;c14&gt;&lt;s15&gt;else&lt;/s15&gt;&lt;/c14&gt;節の内部のコードはその条件が真でないならば実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike arithmetic operators in C, arithmetic operators in Swift do not overflow by default.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Cでの算術演算子と違って、スウィフトの算術演算子は、初期状態ではオーバフローしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike arrays, sets do not have an equivalent shorthand form.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列とは違い、集合は相当する短縮形を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike classes and structures, enumeration types do not have an implicitly provided default initializer; all initializers must be declared explicitly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスや構造体と違って、列挙型には、暗黙のうちに提供される省略時のイニシャライザがありません；全てのイニシャライザは、明確に宣言されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike exception handling in many languages—including Objective-C—error handling in Swift does not involve unwinding the call stack, a process that can be computationally expensive.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>多くの言語 ― Objective-Cを含めて ― での例外処理と違い、スウィフトにおけるエラー処理はコールスタック、計算的に高くつく可能性がある処理、の巻き戻し（アンワインド）を必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike instance methods, subscripts can be read-write or read-only.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インスタンスメソッドと違って、添え字は読み書き用であるか読み出し専用であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike items in an array, items in a dictionary do not have a specified order.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列の中の項目と違って、辞書の中の項目には、指定された順番がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike lazy stored properties, global constants and variables do not need to be marked with the &lt;c2&gt;&lt;s3&gt;lazy&lt;/s3&gt;&lt;/c2&gt; modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>遅延格納プロパティと違って、グローバルな定数と変数は&lt;c2&gt;&lt;s3&gt;lazy&lt;/s3&gt;&lt;/c2&gt;修飾子で印付けされる必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike many other languages, Swift doesn’t require you to write a semicolon (&lt;c0&gt;&lt;s1&gt;;&lt;/s1&gt;&lt;/c0&gt;) after each statement in your code, although you can do so if you wish.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>多くの他の言語とは異なり、スウィフトはあなたにあなたのコードにおいて各文の後にセミコロン（&lt;c0&gt;&lt;s1&gt;;&lt;/s1&gt;&lt;/c0&gt;）を書くことを要求しません、けれどもあなたが望むならば、あなたはそうできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike multiline comments in C, multiline comments in Swift can be nested inside other multiline comments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Cでの複数行コメントと違って、スウィフトの複数行コメントは他の複数行コメント内部に入れ子にされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike other programming languages, Swift doesn’t require you to create separate interface and implementation files for custom structures and classes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他のプログラミング言語と違って、スウィフトはあなたにあつらえの構造体およびクラスのために別々のインタフェースおよび実装ファイルを作成することを要求しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike returning a value whose type is a protocol type, opaque types preserve type identity—the compiler has access to the type information, but clients of the module don’t.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それの型があるプロトコル型である値を返すのとは違い、不透明型は型同一性を保全します — コンパイラは型情報にアクセスします、しかしモジュールのクライアントはしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike stored instance properties, you must always give stored type properties a default value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>格納インスタンスプロパティと違って、あなたは格納型プロパティに省略時の値を常に与えなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike stored named values and stored variable properties, the value of a computed named value or a computed property is not stored in memory.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>格納される名前を付けられた値および格納変数プロパティと違って、計算される名前を付けられた値または計算プロパティの値は、メモリに格納されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike structures and enumerations, classes have two kinds of initializers: designated initializers and convenience initializers, as described in &lt;a0&gt;&lt;s1&gt;Initialization&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体や列挙と違って、クラスは２種類のイニシャライザを持ちます：指定イニシャライザと便宜イニシャライザ、&lt;a0&gt;&lt;s1&gt;初期化&lt;/s1&gt;&lt;/a0&gt;で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike structures, class instances don’t receive a default memberwise initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体と違って、クラスインスタンスは、自動生成のメンバー関連イニシャライザを授けられません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike subclasses in Objective-C, Swift subclasses do not inherit their superclass initializers by default.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Objective-Cでのサブクラスとは異なり、スウィフトのサブクラスは、特に何もしなくてもそれらのスーパークラスのイニシャライザを継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike that example, &lt;c12&gt;&lt;s13&gt;SmallNumber&lt;/s13&gt;&lt;/c12&gt; also supports writing those initial values as part of declaring the property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その例とは違い、&lt;c12&gt;&lt;s13&gt;SmallNumber&lt;/s13&gt;&lt;/c12&gt;は、それら初期値を書き込むこともプロパティの宣言の一部としてサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike the arithmetic operators in C and Objective-C, the Swift arithmetic operators don’t allow values to overflow by default.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>CとObjective-Cの算術演算子と違って、スウィフトの算術演算子は、値がオーバフローするのを初期状態では許しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike the assignment operator in C and Objective-C, the assignment operator in Swift does not itself return a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>CとObjective-Cの代入演算子と違って、スウィフトの代入演算子は、それ自身で値を返しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike the cases in the first form, each case has an underlying value, called a &lt;e2&gt;raw value&lt;/e2&gt;, of the same basic type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の形式でのケース節と違って、それぞれのケース節は、同じ基本の型の、もととなる値、&lt;e2&gt;生の値&lt;/e2&gt;と呼ばれるものを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike the condition of an &lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt; statement, the &lt;e2&gt;compilation condition&lt;/e2&gt; is evaluated at compile time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt;文の条件とは違い、&lt;e2&gt;compilation condition（コンパイル条件）&lt;/e2&gt;はコンパイル時に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike the error conditions discussed in &lt;a0&gt;&lt;s1&gt;Error Handling&lt;/s1&gt;&lt;/a0&gt; above, assertions and preconditions aren’t used for recoverable or expected errors.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の&lt;a0&gt;&lt;s1&gt;エラー処理&lt;/s1&gt;&lt;/a0&gt;で議論されるエラー条件とは違い、表明と前提条件は回復できるまたは予想されたエラーに対して使われません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike value types, &lt;e0&gt;reference types&lt;/e0&gt; are &lt;e1&gt;not&lt;/e1&gt; copied when they are assigned to a variable or constant, or when they are passed to a function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値型とは異なり、&lt;e0&gt;参照型&lt;/e0&gt;は、それが変数や定数に代入される時に、あるいはそれが関数に渡される時に、コピーされ&lt;e1&gt;ません&lt;/e1&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unowned References</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非所有参照</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unowned References and Implicitly Unwrapped Optional Properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非所有参照と暗黙的にアンラップされるオプショナルのプロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Upcasting lets you use an expression as an instance of its type’s supertype, without using an intermediate variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アップキャストは、あなたにある式をそれのスーパータイプのインスタンスとして使用させます、中間生成物の変数の使用なしに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated &lt;a0&gt;&lt;s1&gt;Closures Are Reference Types&lt;/s1&gt;&lt;/a0&gt; to clarify the capturing rules for variables.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;クロージャは参照型です&lt;/s1&gt;&lt;/a0&gt;を新しくして、変数に対するキャプチャ規則を明瞭にしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated &lt;a0&gt;&lt;s1&gt;Defining a Capture List&lt;/s1&gt;&lt;/a0&gt; to clarify the syntax for weak and unowned references in closure capture lists.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;捕獲リストの定義&lt;/s1&gt;&lt;/a0&gt;を新しくして、クロージャ捕獲リスト内の弱いおよび非所有参照に対する構文を明瞭にしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated &lt;a0&gt;&lt;s1&gt;Operators&lt;/s1&gt;&lt;/a0&gt; to explicitly mention examples of supported characters for custom operators, such as those in the Mathematical Operators, Miscellaneous Symbols, and Dingbats Unicode blocks.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;演算子&lt;/s1&gt;&lt;/a0&gt;を更新して、あつらえの演算子のためにサポートされる文字の例にはっきりと言及するようにしました、例えばMathematical Operators、Miscellaneous Symbols、そしてDingbatsユニコードブロックにおけるそれら。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated &lt;a0&gt;&lt;s1&gt;Protocol Declaration&lt;/s1&gt;&lt;/a0&gt; to clarify protocol declaration scope and members.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;プロトコル宣言&lt;/s1&gt;&lt;/a0&gt;を新しくして、プロトコル宣言スコープおよびメンバーを明瞭にしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated &lt;a0&gt;&lt;s1&gt;Range Operators&lt;/s1&gt;&lt;/a0&gt; to note that a half-open range with the same start and end index will be empty.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;範囲演算子&lt;/s1&gt;&lt;/a0&gt;を新しくして、同じ開始および終止インデックスを持つ半開範囲が空になることを記しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated &lt;a0&gt;&lt;s1&gt;Value Overflow&lt;/s1&gt;&lt;/a0&gt; to clarify the overflow behavior of signed and unsigned integers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;値オーバフロー&lt;/s1&gt;&lt;/a0&gt;を新しくして、符号つき及び符号なし整数のオーバフロー挙動を明瞭にしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated a note in the &lt;a0&gt;&lt;s1&gt;Property Observers&lt;/s1&gt;&lt;/a0&gt; section to clarify the behavior of &lt;c2&gt;&lt;s3&gt;willSet&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;didSet&lt;/s5&gt;&lt;/c4&gt; observers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節&lt;a0&gt;&lt;s1&gt;プロパティオブザーバー&lt;/s1&gt;&lt;/a0&gt;を&lt;c2&gt;&lt;s3&gt;willSet&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;didSetオ&lt;/s5&gt;&lt;/c4&gt;ブザーバーの挙動を理解しやすくするために更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated a note in the &lt;a0&gt;&lt;s1&gt;Type Properties&lt;/s1&gt;&lt;/a0&gt; section to mention that stored type properties are lazily initialized.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;型プロパティ&lt;/s1&gt;&lt;/a0&gt;節の注を更新して、格納型プロパティが遅延して初期化されることに言及した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated and expanded the &lt;a0&gt;&lt;s1&gt;Comparing Strings&lt;/s1&gt;&lt;/a0&gt; section to reflect and demonstrate that string and character comparison and prefix / suffix comparison are now based on Unicode canonical equivalence of extended grapheme clusters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節&lt;a0&gt;&lt;s1&gt;文字列を比較する&lt;/s1&gt;&lt;/a0&gt;を更新および拡張して、文字列および文字比較と接頭辞／接尾辞比較が今では拡張書記クラスタのユニコード正準等価に基づかれることを反映し例示しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated attribute arguments to use a colon in the &lt;a0&gt;&lt;s1&gt;Attributes&lt;/s1&gt;&lt;/a0&gt; chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>属性引数をコロンを使うように章&lt;a0&gt;&lt;s1&gt;属性&lt;/s1&gt;&lt;/a0&gt;において更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated discussion throughout to use macOS instead of OS X, &lt;c0&gt;&lt;s1&gt;Error&lt;/s1&gt;&lt;/c0&gt; instead of &lt;c2&gt;&lt;s3&gt;ErrorProtocol&lt;/s3&gt;&lt;/c2&gt;, and protocol names such as &lt;c4&gt;&lt;s5&gt;ExpressibleByStringLiteral&lt;/s5&gt;&lt;/c4&gt; instead of &lt;c6&gt;&lt;s7&gt;StringLiteralConvertible&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>解説を隅から隅まで更新してmacOSをOS Xの代わりに、&lt;c0&gt;&lt;s1&gt;Error&lt;/s1&gt;&lt;/c0&gt;を&lt;c2&gt;&lt;s3&gt;ErrorProtocol&lt;/s3&gt;&lt;/c2&gt;の代わりに、&lt;c4&gt;&lt;s5&gt;ExpressibleByStringLiteral&lt;/s5&gt;&lt;/c4&gt;のようなプロトコル名を&lt;c6&gt;&lt;s7&gt;StringLiteralConvertible&lt;/s7&gt;&lt;/c6&gt;の代わりに使うようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated figures in the &lt;a0&gt;&lt;s1&gt;Weak References&lt;/s1&gt;&lt;/a0&gt; section to show the deallocation process more clearly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;弱い参照&lt;/s1&gt;&lt;/a0&gt;節の図を更新して、デアロケーション過程をより明瞭に見せるようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated for Swift 1.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Swift 1.1にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated for Swift 1.2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Swift 1.2にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated for Swift 2.0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Swift 2.0にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated for Swift 2.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Swift 2.1にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated for Swift 2.2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Swift 2.2にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated for Swift 3.0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Swift 3.0にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated for Swift 3.0.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Swift 3.0.1にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated for Swift 3.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Swift 3.1にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated for Swift 4.0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Swift 4.0にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated for Swift 4.0.3.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Swift 4.0.3にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated for Swift 4.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Swift 4.1にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated for Swift 4.2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Swift 4.2にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated for Swift 5.0.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Swift 5.0にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated for Swift 5.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Swift 5.1にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated for Swift 5.2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Swift 5.2にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated information about initializers that return &lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt; before the instance is fully initialized in the &lt;a2&gt;&lt;s3&gt;Failable Initializers&lt;/s3&gt;&lt;/a2&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インスタンスが完全に初期化される前に&lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;を返すイニシャライザについての情報を&lt;a2&gt;&lt;s3&gt;失敗できるイニシャライザ&lt;/s3&gt;&lt;/a2&gt;節において更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the &lt;a0&gt;&lt;s1&gt;Accessing Properties Through Optional Chaining&lt;/s1&gt;&lt;/a0&gt; section to clarify how assignment through optional chaining behaves.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;オプショナル連鎖を通してプロパティにアクセスする&lt;/s1&gt;&lt;/a0&gt;節を更新して、オプショナル連鎖を通した割り当てがどのように振る舞うかを明確にした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the &lt;a0&gt;&lt;s1&gt;Accessing and Modifying a Dictionary&lt;/s1&gt;&lt;/a0&gt; section to note that &lt;c2&gt;&lt;s3&gt;Dictionary&lt;/s3&gt;&lt;/c2&gt; now has a Boolean &lt;c4&gt;&lt;s5&gt;isEmpty&lt;/s5&gt;&lt;/c4&gt; property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;辞書へのアクセスと修正&lt;/s1&gt;&lt;/a0&gt;の節を更新して&lt;c2&gt;&lt;s3&gt;Dictionary&lt;/s3&gt;&lt;/c2&gt;が今やブールの&lt;c4&gt;&lt;s5&gt;isEmpty&lt;/s5&gt;&lt;/c4&gt;プロパティを持つことを記しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the &lt;a0&gt;&lt;s1&gt;Accessing and Modifying an Array&lt;/s1&gt;&lt;/a0&gt; section to note that you can no longer append a single item to an array with the &lt;c2&gt;&lt;s3&gt;+=&lt;/s3&gt;&lt;/c2&gt; operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節&lt;a0&gt;&lt;s1&gt;配列へのアクセスと変更&lt;/s1&gt;&lt;/a0&gt;を更新して、あなたがもはや単一の項目を&lt;c2&gt;&lt;s3&gt;+=&lt;/s3&gt;&lt;/c2&gt;演算子を使って配列に加えることが出来ないことを注記しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the &lt;a0&gt;&lt;s1&gt;Attributes&lt;/s1&gt;&lt;/a0&gt; chapter to note that the &lt;c2&gt;&lt;s3&gt;@IBAction&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;@IBOutlet&lt;/s5&gt;&lt;/c4&gt;, and &lt;c6&gt;&lt;s7&gt;@NSManaged&lt;/s7&gt;&lt;/c6&gt; attributes imply the &lt;c8&gt;&lt;s9&gt;@objc&lt;/s9&gt;&lt;/c8&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;属性&lt;/s1&gt;&lt;/a0&gt;の章を更新して、&lt;c2&gt;&lt;s3&gt;@IBAction&lt;/s3&gt;&lt;/c2&gt;、&lt;c4&gt;&lt;s5&gt;@IBOutlet&lt;/s5&gt;&lt;/c4&gt;、そして&lt;c6&gt;&lt;s7&gt;@NSManaged&lt;/s7&gt;&lt;/c6&gt;属性が&lt;c8&gt;&lt;s9&gt;@objc&lt;/s9&gt;&lt;/c8&gt;属性を暗示することを注記した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the &lt;a0&gt;&lt;s1&gt;Break Statement&lt;/s1&gt;&lt;/a0&gt; section with information about labeled break statements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節&lt;a0&gt;&lt;s1&gt;ブレーク文&lt;/s1&gt;&lt;/a0&gt;をラベルをつけられたブレーク文についての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the &lt;a0&gt;&lt;s1&gt;Capturing Values&lt;/s1&gt;&lt;/a0&gt; section to clarify how variables and constants are captured in closures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;値を捕獲する&lt;/s1&gt;&lt;/a0&gt;節を更新してどのように変数と定数がクロージャにキャプチャされるかをわかりやすくした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the &lt;a0&gt;&lt;s1&gt;Concatenating Strings and Characters&lt;/s1&gt;&lt;/a0&gt; section to reflect the fact that &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;Character&lt;/s5&gt;&lt;/c4&gt; values can no longer be combined with the addition operator (&lt;c6&gt;&lt;s7&gt;+&lt;/s7&gt;&lt;/c6&gt;) or addition assignment operator (&lt;c8&gt;&lt;s9&gt;+=&lt;/s9&gt;&lt;/c8&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;文字列と文字の連結&lt;/s1&gt;&lt;/a0&gt;節を&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;Character&lt;/s5&gt;&lt;/c4&gt;値はもはや加算演算子（&lt;c6&gt;&lt;s7&gt;+&lt;/s7&gt;&lt;/c6&gt;）または加算代入演算子（&lt;c8&gt;&lt;s9&gt;+=&lt;/s9&gt;&lt;/c8&gt;）を使って結合されることができないという事実を反映するために更新しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the &lt;a0&gt;&lt;s1&gt;Declaration Attributes&lt;/s1&gt;&lt;/a0&gt; and &lt;a2&gt;&lt;s3&gt;Conditional Compilation Block&lt;/s3&gt;&lt;/a2&gt; sections with information about tvOS.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;宣言属性&lt;/s1&gt;&lt;/a0&gt;と&lt;a2&gt;&lt;s3&gt;条件コンパイルブロック&lt;/s3&gt;&lt;/a2&gt;節をtvOSについての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the &lt;a0&gt;&lt;s1&gt;Declaration Attributes&lt;/s1&gt;&lt;/a0&gt; section to describe when you can apply the &lt;c2&gt;&lt;s3&gt;@objc&lt;/s3&gt;&lt;/c2&gt; attribute to classes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;宣言属性&lt;/s1&gt;&lt;/a0&gt;節を更新してあなたが&lt;c2&gt;&lt;s3&gt;@objc&lt;/s3&gt;&lt;/c2&gt;属性をクラスへ適用できる場合を記述した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the &lt;a0&gt;&lt;s1&gt;Declaration Attributes&lt;/s1&gt;&lt;/a0&gt; section with information about the &lt;c2&gt;&lt;s3&gt;@available&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;@warn_unused_result&lt;/s5&gt;&lt;/c4&gt; attributes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節&lt;a0&gt;&lt;s1&gt;宣言属性&lt;/s1&gt;&lt;/a0&gt;を&lt;c2&gt;&lt;s3&gt;@available&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;@warn_unused_result&lt;/s5&gt;&lt;/c4&gt;属性についての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the &lt;a0&gt;&lt;s1&gt;Enumeration Case Pattern&lt;/s1&gt;&lt;/a0&gt; section, now that an enumeration case pattern can match an optional value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;列挙ケース節パターン&lt;/s1&gt;&lt;/a0&gt;の節を更新しました、今では列挙ケース節パターンはオプショナル値にマッチできるので。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the &lt;a0&gt;&lt;s1&gt;Expressions&lt;/s1&gt;&lt;/a0&gt; chapter to separate the discussion of parenthesized expressions and tuple expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;式&lt;/s1&gt;&lt;/a0&gt;の章を更新して、括弧で囲まれた式とタプル式の解説を分離した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the &lt;a0&gt;&lt;s1&gt;Implicitly Unwrapped Optionals&lt;/s1&gt;&lt;/a0&gt; section to make it clearer that an implicitly unwrapped optional value can be used as either an optional or non-optional value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;暗黙的にアンラップされるオプショナル&lt;/s1&gt;&lt;/a0&gt;の節を更新した、暗黙的にアンラップされるオプショナル値がオプショナルまたは非オプショナル値のどちらとして使用できることをより明確にするため。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the &lt;a0&gt;&lt;s1&gt;Initializer Inheritance and Overriding&lt;/s1&gt;&lt;/a0&gt; section to note that overrides of a designated initializer must now be marked with the &lt;c2&gt;&lt;s3&gt;override&lt;/s3&gt;&lt;/c2&gt; modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節&lt;a0&gt;&lt;s1&gt;イニシャライザの継承とオーバーライド&lt;/s1&gt;&lt;/a0&gt;を更新して、指定イニシャライザのオーバーライドは今や&lt;c2&gt;&lt;s3&gt;override&lt;/s3&gt;&lt;/c2&gt;修飾子で印付けされなければならないことを注記しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the &lt;a0&gt;&lt;s1&gt;Key-Path Expression&lt;/s1&gt;&lt;/a0&gt; section, now that key paths support subscript components.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;キーパス式&lt;/s1&gt;&lt;/a0&gt;の節を更新した、今ではキーパスは添え字を構成要素としてサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the &lt;a0&gt;&lt;s1&gt;Memberwise Initializers for Structure Types&lt;/s1&gt;&lt;/a0&gt; section, now that memberwise initializers support omitting parameters for properties that have a default value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;構造体型のためのメンバー関連イニシャライザ&lt;/s1&gt;&lt;/a0&gt;の節を更新しました、今ではメンバー関連イニシャライザは、省略時の値を持つプロパティに対してパラメータを省略することをサポートするので。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the &lt;a0&gt;&lt;s1&gt;Operators&lt;/s1&gt;&lt;/a0&gt; section with discussion of custom operators that contain a dot.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;演算子&lt;/s1&gt;&lt;/a0&gt;節をドットを含むカスタム演算子の議論で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the &lt;a0&gt;&lt;s1&gt;Repeat-While&lt;/s1&gt;&lt;/a0&gt; section with information about the &lt;c2&gt;&lt;s3&gt;repeat&lt;/s3&gt;&lt;/c2&gt;-&lt;c4&gt;&lt;s5&gt;while&lt;/s5&gt;&lt;/c4&gt; loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節&lt;a0&gt;&lt;s1&gt;この間繰り返す&lt;/s1&gt;&lt;/a0&gt;を&lt;c2&gt;&lt;s3&gt;repeat&lt;/s3&gt;&lt;/c2&gt;-&lt;c4&gt;&lt;s5&gt;while&lt;/s5&gt;&lt;/c4&gt;ループについての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the &lt;a0&gt;&lt;s1&gt;Representing and Throwing Errors&lt;/s1&gt;&lt;/a0&gt; section, now that all types can conform to the &lt;c2&gt;&lt;s3&gt;ErrorType&lt;/s3&gt;&lt;/c2&gt; protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;エラーの表現とスロー&lt;/s1&gt;&lt;/a0&gt;節を更新した、現在ではすべての型が&lt;c2&gt;&lt;s3&gt;ErrorType&lt;/s3&gt;&lt;/c2&gt;プロトコルに準拠できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the &lt;a0&gt;&lt;s1&gt;Required Initializers&lt;/s1&gt;&lt;/a0&gt; section to note that the &lt;c2&gt;&lt;s3&gt;required&lt;/s3&gt;&lt;/c2&gt; modifier is now written before every subclass implementation of a required initializer, and that the requirements for required initializers can now be satisfied by automatically inherited initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節&lt;a0&gt;&lt;s1&gt;必須イニシャライザ&lt;/s1&gt;&lt;/a0&gt;を更新して、&lt;c2&gt;&lt;s3&gt;required&lt;/s3&gt;&lt;/c2&gt;修飾子が今やすべてのサブクラス実装の必須イニシャライザの前に書かれること、そして必須イニシャライザのための必要条件は今や自動的に継承されるイニシャライザで満たされることが出来るのを注記しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the &lt;a0&gt;&lt;s1&gt;Self Type&lt;/s1&gt;&lt;/a0&gt; section, now that &lt;c2&gt;&lt;s3&gt;Self&lt;/s3&gt;&lt;/c2&gt; can be used to refer to the type introduced by the current class, structure, or enumeration declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;Self型&lt;/s1&gt;&lt;/a0&gt;の節を加えました、今では&lt;c2&gt;&lt;s3&gt;Self&lt;/s3&gt;&lt;/c2&gt;は現在のクラス、構造体、または列挙宣言によって導入される型を参照するために使われることができるので。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the &lt;a0&gt;&lt;s1&gt;Self Type&lt;/s1&gt;&lt;/a0&gt; section, now that the &lt;c2&gt;&lt;s3&gt;Self&lt;/s3&gt;&lt;/c2&gt; can be used in more contexts.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;Self型&lt;/s1&gt;&lt;/a0&gt;の節を更新した、今では&lt;c2&gt;&lt;s3&gt;Self&lt;/s3&gt;&lt;/c2&gt;はより多くの文脈で使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the &lt;a0&gt;&lt;s1&gt;Special Characters in String Literals&lt;/s1&gt;&lt;/a0&gt; section with a more precise definition of Unicode scalars.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節&lt;a0&gt;&lt;s1&gt;文字列リテラル内の特別な文字&lt;/s1&gt;&lt;/a0&gt;をユニコードスカラーのより精密な定義づけで更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the &lt;a0&gt;&lt;s1&gt;String Interpolation&lt;/s1&gt;&lt;/a0&gt; and &lt;a2&gt;&lt;s3&gt;String Literals&lt;/s3&gt;&lt;/a2&gt; sections now that string interpolations can contain string literals.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;文字列補間&lt;/s1&gt;&lt;/a0&gt;と&lt;a2&gt;&lt;s3&gt;文字列リテラル&lt;/s3&gt;&lt;/a2&gt;節を更新した、今では文字列補間は文字列リテラルを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the &lt;a0&gt;&lt;s1&gt;String Literals&lt;/s1&gt;&lt;/a0&gt; section to note that Unicode scalars inside string literals are now written as &lt;c2&gt;&lt;s3&gt;\u{n}&lt;/s3&gt;&lt;/c2&gt;, where &lt;c4&gt;&lt;s5&gt;n&lt;/s5&gt;&lt;/c4&gt; is a hexadecimal number between 0 and 10FFFF, the range of Unicode’s codespace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;文字列リテラル&lt;/s1&gt;&lt;/a0&gt;の節を更新して文字列内部のユニコード・スカラーが今や&lt;c2&gt;&lt;s3&gt;\u{n}&lt;/s3&gt;&lt;/c2&gt;のように書かれることを記しました、ここで&lt;c4&gt;&lt;s5&gt;n&lt;/s5&gt;&lt;/c4&gt;は０から10FFFまでの16進数、ユニコードの符号空間です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the &lt;a0&gt;&lt;s1&gt;Strings and Characters&lt;/s1&gt;&lt;/a0&gt; chapter to reflect the fact that Swift’s &lt;c2&gt;&lt;s3&gt;Character&lt;/s3&gt;&lt;/c2&gt; type now represents a single Unicode extended grapheme cluster.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;文字列と文字&lt;/s1&gt;&lt;/a0&gt;の章を、スウィフトの&lt;c2&gt;&lt;s3&gt;Character&lt;/s3&gt;&lt;/c2&gt;型が今や単一のユニコード拡張書記素クラスタを表わすという事実を反映するために更新しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the &lt;a0&gt;&lt;s1&gt;Strings and Characters&lt;/s1&gt;&lt;/a0&gt; chapter, now that &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt; no longer conforms to the &lt;c4&gt;&lt;s5&gt;CollectionType&lt;/s5&gt;&lt;/c4&gt; protocol from the Swift standard library.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節&lt;a0&gt;&lt;s1&gt;文字列と文字&lt;/s1&gt;&lt;/a0&gt;を更新した、現在では&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;はもはやスウィフト標準ライブラリ由来の&lt;c4&gt;&lt;s5&gt;CollectionType&lt;/s5&gt;&lt;/c4&gt;プロトコルに準拠しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the &lt;a0&gt;&lt;s1&gt;Subscript Options&lt;/s1&gt;&lt;/a0&gt; section, now that subscripts support parameters with default values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;添え字オプション&lt;/s1&gt;&lt;/a0&gt;の節を更新した、今では添え字は省略時の値をもつパラメータをサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the &lt;a0&gt;&lt;s1&gt;Type Annotations&lt;/s1&gt;&lt;/a0&gt; section to note that multiple related variables can be defined on a single line with one type annotation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;型注釈&lt;/s1&gt;&lt;/a0&gt;の節を更新して複数の関連する変数が１行だけで１つの型注釈で定義されることが出来ることを記しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the &lt;a0&gt;&lt;s1&gt;Type Attributes&lt;/s1&gt;&lt;/a0&gt; section with information about the &lt;c2&gt;&lt;s3&gt;@convention&lt;/s3&gt;&lt;/c2&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節&lt;a0&gt;&lt;s1&gt;型属性&lt;/s1&gt;&lt;/a0&gt;を&lt;c2&gt;&lt;s3&gt;@convention&lt;/s3&gt;&lt;/c2&gt;属性についての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the &lt;a0&gt;&lt;s1&gt;Type Properties&lt;/s1&gt;&lt;/a0&gt; section with information about stored and computed type properties for classes, structures, and enumerations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>節&lt;a0&gt;&lt;s1&gt;型プロパティ&lt;/s1&gt;&lt;/a0&gt;をクラス、構造体、そして列挙のための格納および計算型プロパティについての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the &lt;a0&gt;&lt;s1&gt;Variadic Parameters&lt;/s1&gt;&lt;/a0&gt; section, now that variadic parameters can be declared in any position in a function’s parameter list.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;可変長パラメータ&lt;/s1&gt;&lt;/a0&gt;節を更新した、現在では可変長パラメータは関数のパラメータリストの中のあらゆる位置で宣言されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the &lt;a2&gt;&lt;s3&gt;Operators&lt;/s3&gt;&lt;/a2&gt; reference to describe the revised rules.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>改められた規則を記述するために&lt;a2&gt;&lt;s3&gt;演算子&lt;/s3&gt;&lt;/a2&gt;リファレンスを更新しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the definition of Unicode scalars in string literals.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列リテラルの中のユニコードスカラーの定義を新しくしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion about default parameters in the &lt;a0&gt;&lt;s1&gt;Default Parameter Values&lt;/s1&gt;&lt;/a0&gt; section, now that they can’t be reordered in function calls.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>省略時のパラメータについての議論を&lt;a0&gt;&lt;s1&gt;省略時のパラメータ値&lt;/s1&gt;&lt;/a0&gt;の節で更新した、今ではそれらは関数呼び出しにおいて再配列されることが出来ないので。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion in &lt;a0&gt;&lt;s1&gt;Functions that Never Return&lt;/s1&gt;&lt;/a0&gt; to use the new &lt;c2&gt;&lt;s3&gt;Never&lt;/s3&gt;&lt;/c2&gt; type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;決して返らない関数&lt;/s1&gt;&lt;/a0&gt;での議論を更新して新しい&lt;c2&gt;&lt;s3&gt;Never&lt;/s3&gt;&lt;/c2&gt;型を使うようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion in the &lt;a0&gt;&lt;s1&gt;Escaping Closures&lt;/s1&gt;&lt;/a0&gt; section, now that closures are nonescaping by default.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;クロージャを脱出する&lt;/s1&gt;&lt;/a0&gt;の節において議論を更新した、今ではクロージャは初期状態で非脱出です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion in the &lt;a0&gt;&lt;s1&gt;Function Type&lt;/s1&gt;&lt;/a0&gt; section to note that argument labels are not allowed when writing a function type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;関数型&lt;/s1&gt;&lt;/a0&gt;節での議論を更新して、属性ラベルは関数型を書いている時に許可されないことを注記した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion in the &lt;a0&gt;&lt;s1&gt;Function Type&lt;/s1&gt;&lt;/a0&gt; section, now that Swift distinguishes between functions that take multiple parameters and functions that take a single parameter of a tuple type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;関数型&lt;/s1&gt;&lt;/a0&gt;の節での議論を更新した、今ではスウィフトは複数のパラメータを取る関数とただ１つのタプル型のパラメータを取る関数の間の区別をするので。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion in the &lt;a0&gt;&lt;s1&gt;Generic Where Clauses&lt;/s1&gt;&lt;/a0&gt; section of the &lt;a2&gt;&lt;s3&gt;Generics&lt;/s3&gt;&lt;/a2&gt; chapter and in the &lt;a4&gt;&lt;s5&gt;Generic Parameters and Arguments&lt;/s5&gt;&lt;/a4&gt; chapter, now that generic &lt;c6&gt;&lt;s7&gt;where&lt;/s7&gt;&lt;/c6&gt; clauses are written at the end of a declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;総称体where節&lt;/s1&gt;&lt;/a0&gt;の節で&lt;a2&gt;&lt;s3&gt;総称体&lt;/s3&gt;&lt;/a2&gt;の章において、そして&lt;a4&gt;&lt;s5&gt;総称体パラメータと引数&lt;/s5&gt;&lt;/a4&gt;の章においてその議論を更新した、今では総称体&lt;c6&gt;&lt;s7&gt;where&lt;/s7&gt;&lt;/c6&gt;節は宣言の最後に書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion in the &lt;a0&gt;&lt;s1&gt;In-Out Parameters&lt;/s1&gt;&lt;/a0&gt; section to note that only nonescaping closures can capture in-out parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;in-outパラメータ&lt;/s1&gt;&lt;/a0&gt;の節において解説を更新して、非脱出クロージャのみがin-outパラメータをキャプチャできることを注記した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion in the &lt;a0&gt;&lt;s1&gt;Optional Binding&lt;/s1&gt;&lt;/a0&gt; section of the &lt;a2&gt;&lt;s3&gt;The Basics&lt;/s3&gt;&lt;/a2&gt; chapter and the &lt;a4&gt;&lt;s5&gt;While Statement&lt;/s5&gt;&lt;/a4&gt; section of the &lt;a6&gt;&lt;s7&gt;Statements&lt;/s7&gt;&lt;/a6&gt; chapter, now that &lt;c8&gt;&lt;s9&gt;if&lt;/s9&gt;&lt;/c8&gt;, &lt;c10&gt;&lt;s11&gt;while&lt;/s11&gt;&lt;/c10&gt;, and &lt;c12&gt;&lt;s13&gt;guard&lt;/s13&gt;&lt;/c12&gt; statements use a comma-separated list of conditions without &lt;c14&gt;&lt;s15&gt;where&lt;/s15&gt;&lt;/c14&gt; clauses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;オプショナルを束縛する&lt;/s1&gt;&lt;/a0&gt;の節を&lt;a2&gt;&lt;s3&gt;基本&lt;/s3&gt;&lt;/a2&gt;の章で、そして&lt;a4&gt;&lt;s5&gt;while文&lt;/s5&gt;&lt;/a4&gt;の節を&lt;a6&gt;&lt;s7&gt;文&lt;/s7&gt;&lt;/a6&gt;の章でその議論を更新した、今では&lt;c8&gt;&lt;s9&gt;if&lt;/s9&gt;&lt;/c8&gt;、&lt;c10&gt;&lt;s11&gt;while&lt;/s11&gt;&lt;/c10&gt;、そして&lt;c12&gt;&lt;s13&gt;guard&lt;/s13&gt;&lt;/c12&gt;文はコンマで区切られた条件リストを&lt;c14&gt;&lt;s15&gt;where&lt;/s15&gt;&lt;/c14&gt;節なしで使うからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion in the &lt;a0&gt;&lt;s1&gt;Protocol Composition&lt;/s1&gt;&lt;/a0&gt; section of the &lt;a2&gt;&lt;s3&gt;Protocols&lt;/s3&gt;&lt;/a2&gt; chapter, and in the &lt;a4&gt;&lt;s5&gt;Protocol Composition Type&lt;/s5&gt;&lt;/a4&gt; section of the &lt;a6&gt;&lt;s7&gt;Types&lt;/s7&gt;&lt;/a6&gt; chapter, now that protocol composition types can contain a superclass requirement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>議論を&lt;a0&gt;&lt;s1&gt;プロトコル合成&lt;/s1&gt;&lt;/a0&gt;の節で&lt;a2&gt;&lt;s3&gt;プロトコル&lt;/s3&gt;&lt;/a2&gt;の章において、そして&lt;a4&gt;&lt;s5&gt;プロトコル合成型&lt;/s5&gt;&lt;/a4&gt;の節で&lt;a6&gt;&lt;s7&gt;型&lt;/s7&gt;&lt;/a6&gt;の章において更新した、今ではプロトコル合成型はスーパークラス要件を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion in the Dynamic Type Expression section to use the new &lt;c0&gt;&lt;s1&gt;type(of:)&lt;/s1&gt;&lt;/c0&gt; syntax for dynamic type expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「動的型式」の節において議論を更新して、 新しい&lt;c0&gt;&lt;s1&gt;type(of:)&lt;/s1&gt;&lt;/c0&gt;構文を動的型式に使うようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion of &lt;c0&gt;&lt;s1&gt;inout&lt;/s1&gt;&lt;/c0&gt; in the &lt;a2&gt;&lt;s3&gt;Function Declaration&lt;/s3&gt;&lt;/a2&gt; section to note that it appears in front of a parameter’s type instead of in front of a parameter’s name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;inout&lt;/s1&gt;&lt;/c0&gt;の議論を&lt;a2&gt;&lt;s3&gt;関数宣言&lt;/s3&gt;&lt;/a2&gt;の節において更新して、それが現れるのはパラメータの持つ型の前で、パラメータの名前の前でないことを注記した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion of Swift language version numbers in the &lt;a0&gt;&lt;s1&gt;Conditional Compilation Block&lt;/s1&gt;&lt;/a0&gt; section, now that an optional patch number is allowed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフト言語バージョン番号の議論を&lt;a0&gt;&lt;s1&gt;条件比較ブロック&lt;/s1&gt;&lt;/a0&gt;の節において更新した、今では随意のパッチ番号が許可されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion of associated types to use the &lt;c0&gt;&lt;s1&gt;associatedtype&lt;/s1&gt;&lt;/c0&gt; keyword in the &lt;a2&gt;&lt;s3&gt;Associated Types&lt;/s3&gt;&lt;/a2&gt; and &lt;a4&gt;&lt;s5&gt;Protocol Associated Type Declaration&lt;/s5&gt;&lt;/a4&gt; sections.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連型の議論を&lt;c0&gt;&lt;s1&gt;associatedtype&lt;/s1&gt;&lt;/c0&gt;キーワードを使うように&lt;a2&gt;&lt;s3&gt;関連型&lt;/s3&gt;&lt;/a2&gt;と&lt;a4&gt;&lt;s5&gt;プロトコル関連型宣言&lt;/s5&gt;&lt;/a4&gt;の節で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion of function types in the &lt;a0&gt;&lt;s1&gt;Function Type&lt;/s1&gt;&lt;/a0&gt; section now that function argument labels are no longer part of a function’s type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数型の解説を節&lt;a0&gt;&lt;s1&gt;関数型&lt;/s1&gt;&lt;/a0&gt;において更新した、今では関数引数ラベルはもはや関数の型の一部ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion of function types in the &lt;a0&gt;&lt;s1&gt;Function Type&lt;/s1&gt;&lt;/a0&gt; section to note that parentheses around the parameter types are required.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数型の解説を節&lt;a0&gt;&lt;s1&gt;関数型&lt;/s1&gt;&lt;/a0&gt;において更新して、パラメータ型の周りの丸括弧は必要とされることを注記した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion of functions in the &lt;a0&gt;&lt;s1&gt;Functions&lt;/s1&gt;&lt;/a0&gt; chapter and the &lt;a2&gt;&lt;s3&gt;Function Declaration&lt;/s3&gt;&lt;/a2&gt; section to note that all parameters get an argument label by default.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数の解説を&lt;a0&gt;&lt;s1&gt;関数&lt;/s1&gt;&lt;/a0&gt;の章と&lt;a2&gt;&lt;s3&gt;関数宣言&lt;/s3&gt;&lt;/a2&gt;の節において更新して、すべてのパラメータが引数ラベルを初期状態で受け取ることを注記した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion of line control statements to use the &lt;c0&gt;&lt;s1&gt;#sourceLocation(file:line:)&lt;/s1&gt;&lt;/c0&gt; syntax in the &lt;a2&gt;&lt;s3&gt;Line Control Statement&lt;/s3&gt;&lt;/a2&gt; section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>行制御文の解説を&lt;c0&gt;&lt;s1&gt;#sourceLocation(file:line:)&lt;/s1&gt;&lt;/c0&gt;構文を使うように&lt;a2&gt;&lt;s3&gt;行制御文&lt;/s3&gt;&lt;/a2&gt;の節において更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion of operators in the &lt;a0&gt;&lt;s1&gt;Advanced Operators&lt;/s1&gt;&lt;/a0&gt; chapter, now that you implement them as type methods instead of as global functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>演算子の議論を&lt;a0&gt;&lt;s1&gt;先進の演算子&lt;/s1&gt;&lt;/a0&gt;の章において更新した、今ではあなたはそれらをグローバル関数としてではなく型メソッドとして実装するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion of optional protocol requirements in the &lt;a0&gt;&lt;s1&gt;Optional Protocol Requirements&lt;/s1&gt;&lt;/a0&gt; section to clarify that they are used only in code that interoperates with Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルプロトコル要件の解説を節&lt;a0&gt;&lt;s1&gt;オプショナルのプロトコル要件&lt;/s1&gt;&lt;/a0&gt;において更新して、それらがObjective-Cと相互運用するコードにおいてのみ使用されることを明確にした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion of protocol composition types in the &lt;a0&gt;&lt;s1&gt;Protocol Composition&lt;/s1&gt;&lt;/a0&gt; section of the &lt;a2&gt;&lt;s3&gt;Protocols&lt;/s3&gt;&lt;/a2&gt; chapter and in the &lt;a4&gt;&lt;s5&gt;Protocol Composition Type&lt;/s5&gt;&lt;/a4&gt; section of the &lt;a6&gt;&lt;s7&gt;Types&lt;/s7&gt;&lt;/a6&gt; chapter to use the new &lt;c8&gt;&lt;s9&gt;Protocol1&lt;/s9&gt; &lt;s10&gt;&amp;&lt;/s10&gt; &lt;s11&gt;Protocol2&lt;/s11&gt;&lt;/c8&gt; syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル合成型の議論を&lt;a0&gt;&lt;s1&gt;プロトコル合成&lt;/s1&gt;&lt;/a0&gt;の節で&lt;a2&gt;&lt;s3&gt;プロトコル&lt;/s3&gt;&lt;/a2&gt;の章において、そして&lt;a4&gt;&lt;s5&gt;プロトコル合成型&lt;/s5&gt;&lt;/a4&gt;の節で&lt;a6&gt;&lt;s7&gt;型&lt;/s7&gt;&lt;/a6&gt;の章において更新して、新しい&lt;c8&gt;&lt;s9&gt;Protocol1&lt;/s9&gt; &lt;s10&gt;&amp;&lt;/s10&gt; &lt;s11&gt;Protocol2&lt;/s11&gt;&lt;/c8&gt;構文を使うようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion of protocol extensions in &lt;a0&gt;&lt;s1&gt;Extension Declaration&lt;/s1&gt;&lt;/a0&gt; now that &lt;c2&gt;&lt;s3&gt;final&lt;/s3&gt;&lt;/c2&gt; isn’t allowed in them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル拡張の議論を&lt;a0&gt;&lt;s1&gt;拡張宣言&lt;/s1&gt;&lt;/a0&gt;において更新した、今では&lt;c2&gt;&lt;s3&gt;final&lt;/s3&gt;&lt;/c2&gt;はそれらにおいて許可されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion of the &lt;c0&gt;&lt;s1&gt;@NSManaged&lt;/s1&gt;&lt;/c0&gt; attribute in the &lt;a2&gt;&lt;s3&gt;Declaration Attributes&lt;/s3&gt;&lt;/a2&gt; section, now that the attribute can be applied to certain instance methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;@NSManaged&lt;/s1&gt;&lt;/c0&gt;属性の議論を&lt;a2&gt;&lt;s3&gt;宣言属性&lt;/s3&gt;&lt;/a2&gt;節において更新した、現在ではこの属性は特定のインスタンスメソッドに適用されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion of the &lt;c0&gt;&lt;s1&gt;@noescape&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;@autoclosure&lt;/s3&gt;&lt;/c2&gt; attributes in the &lt;a4&gt;&lt;s5&gt;Escaping Closures&lt;/s5&gt;&lt;/a4&gt; and &lt;a6&gt;&lt;s7&gt;Autoclosures&lt;/s7&gt;&lt;/a6&gt; sections and the &lt;a8&gt;&lt;s9&gt;Attributes&lt;/s9&gt;&lt;/a8&gt; chapter now that they are type attributes, rather than declaration attributes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;@noescape&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;@autoclosure&lt;/s3&gt;&lt;/c2&gt;属性の議論を&lt;a4&gt;&lt;s5&gt;脱出クロージャ&lt;/s5&gt;&lt;/a4&gt;と&lt;a6&gt;&lt;s7&gt;自動クロージャ&lt;/s7&gt;&lt;/a6&gt;の節および&lt;a8&gt;&lt;s9&gt;属性&lt;/s9&gt;&lt;/a8&gt;の章で更新した、今ではそれらは型属性です、宣言属性ではなくて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion of the &lt;c0&gt;&lt;s1&gt;@objc&lt;/s1&gt;&lt;/c0&gt; attribute in the &lt;a2&gt;&lt;s3&gt;Declaration Attributes&lt;/s3&gt;&lt;/a2&gt; section to note that enumerations and enumeration cases can use this attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;@objc&lt;/s1&gt;&lt;/c0&gt;属性についての議論を&lt;a2&gt;&lt;s3&gt;宣言属性&lt;/s3&gt;&lt;/a2&gt;において更新して、列挙と列挙ケースがこの属性を使用できることを注記した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion of the &lt;c0&gt;&lt;s1&gt;objc&lt;/s1&gt;&lt;/c0&gt; attribute in &lt;a2&gt;&lt;s3&gt;Declaration Attributes&lt;/s3&gt;&lt;/a2&gt;, now that this attribute is inferred in fewer places.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;objc&lt;/s1&gt;&lt;/c0&gt;属性の議論を&lt;a2&gt;&lt;s3&gt;宣言属性&lt;/s3&gt;&lt;/a2&gt;において更新した、現在この属性はいくつかの場所で推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the discussion of weak and unowned references in the &lt;a0&gt;&lt;s1&gt;Automatic Reference Counting&lt;/s1&gt;&lt;/a0&gt; chapter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>弱いそして非所有参照の議論を&lt;a0&gt;&lt;s1&gt;自動参照カウント&lt;/s1&gt;&lt;/a0&gt;の章において更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the entire book to refer to &lt;c0&gt;&lt;s1&gt;..&lt;&lt;/s1&gt;&lt;/c0&gt; as the &lt;a2&gt;&lt;s3&gt;Half-Open Range Operator&lt;/s3&gt;&lt;/a2&gt; (rather than the “half-closed range operator”).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;..&lt;&lt;/s1&gt;&lt;/c0&gt;を&lt;a2&gt;&lt;s3&gt;半開範囲演算子&lt;/s3&gt;&lt;/a2&gt;と言うように本全体を更新しました（「半完結範囲演算子」ではなしに）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the example in &lt;a2&gt;&lt;s3&gt;Type Casting for Any and AnyObject&lt;/s3&gt;&lt;/a2&gt; to show how to check for and cast to a function type within a &lt;c4&gt;&lt;s5&gt;switch&lt;/s5&gt;&lt;/c4&gt; statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a2&gt;&lt;s3&gt;AnyおよびAnyObjectに対する型キャスト&lt;/s3&gt;&lt;/a2&gt;での例を更新して、&lt;c4&gt;&lt;s5&gt;switch&lt;/s5&gt;&lt;/c4&gt;文内のある関数型について調べてキャストする方法を示しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the information about &lt;a0&gt;&lt;s1&gt;Memberwise Initializers for Structure Types&lt;/s1&gt;&lt;/a0&gt; to clarify that the memberwise structure initializer is made available even if a structure’s stored properties do not have default values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;構造体型のためのメンバー関連イニシャライザ&lt;/s1&gt;&lt;/a0&gt;についての情報が更新されて、メンバー関連の構造体初期化子が、ある構造体の持つ格納プロパティが省略時の値を持たなくてさえも、利用可能にされることをわかりやすくされました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the information about &lt;a2&gt;&lt;s3&gt;Mutability of Collections&lt;/s3&gt;&lt;/a2&gt; and &lt;a4&gt;&lt;s5&gt;Arrays&lt;/s5&gt;&lt;/a4&gt; to reflect the new approach.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい取り組み方を反映するために、&lt;a2&gt;&lt;s3&gt;コレクションの可変性&lt;/s3&gt;&lt;/a2&gt;および&lt;a4&gt;&lt;s5&gt;配列&lt;/s5&gt;&lt;/a4&gt;についての情報が更新されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated the rules for constant and constant property declaration and initialization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数と定数プロパティの宣言と初期化についての規則を新しくしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updated to &lt;c0&gt;&lt;s1&gt;..&lt;&lt;/s1&gt;&lt;/c0&gt; rather than &lt;c2&gt;&lt;s3&gt;..&lt;/s3&gt;&lt;/c2&gt; for the &lt;a4&gt;&lt;s5&gt;Half-Open Range Operator&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a4&gt;&lt;s5&gt;半開範囲演算子&lt;/s5&gt;&lt;/a4&gt;に対して&lt;c2&gt;&lt;s3&gt;..&lt;/s3&gt;&lt;/c2&gt;ではなく&lt;c0&gt;&lt;s1&gt;..&lt;&lt;/s1&gt;&lt;/c0&gt;に更新しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updating the budget is a two-step process: First you add the items’ names and prices, and then you change the total amount to reflect the items currently on the list.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>予算案の更新は２段階の処理です：最初にあなたはその項目の名前と値段を加えます、それからあなたは総支出額を変更してそれら項目の現在をリスト上に反映します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Upper- or lowercase letter A through Z</seg>
      </tuv>
      <tuv lang="JA">
        <seg>大文字または小文字のAからZ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use &lt;c0&gt;&lt;s1&gt;..&lt;&lt;/s1&gt;&lt;/c0&gt; to make a range that omits its upper value, and use &lt;c2&gt;&lt;s3&gt;...&lt;/s3&gt;&lt;/c2&gt; to make a range that includes both values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;..&lt;&lt;/s1&gt;&lt;/c0&gt;をその上側の値を除く範囲を作るために使ってください、そして&lt;c2&gt;&lt;s3&gt;...&lt;/s3&gt;&lt;/c2&gt;を両方の値を含む範囲を作るために使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use &lt;c0&gt;&lt;s1&gt;Any&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;AnyObject&lt;/s3&gt;&lt;/c2&gt; only when you explicitly need the behavior and capabilities they provide.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが明白にそれらが提供する挙動と能力を必要とする時にだけ、&lt;c0&gt;&lt;s1&gt;Any&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;AnyObject&lt;/s3&gt;&lt;/c2&gt;を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use &lt;c0&gt;&lt;s1&gt;UInt&lt;/s1&gt;&lt;/c0&gt; only when you specifically need an unsigned integer type with the same size as the platform’s native word size.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが特にプラットホーム固有のワードサイズと同じ大きさで符号なし整数型を必要とする時にだけ&lt;c0&gt;&lt;s1&gt;UInt&lt;/s1&gt;&lt;/c0&gt;を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use &lt;c0&gt;&lt;s1&gt;\()&lt;/s1&gt;&lt;/c0&gt; to include a floating-point calculation in a string and to include someone’s name in a greeting.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;\()&lt;/s1&gt;&lt;/c0&gt;を、浮動小数点計算を文字列に含めるために、そして誰かの名前をある挨拶に含めるために使ってみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use &lt;c0&gt;&lt;s1&gt;class&lt;/s1&gt;&lt;/c0&gt; followed by the class’s name to create a class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるクラスを作成するために&lt;c0&gt;&lt;s1&gt;class&lt;/s1&gt;&lt;/c0&gt;を使ってその後にそのクラスの名前を続けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use &lt;c0&gt;&lt;s1&gt;defer&lt;/s1&gt;&lt;/c0&gt; to write a block of code that is executed after all other code in the function, just before the function returns.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;defer&lt;/s1&gt;&lt;/c0&gt;を使って関数の中の全ての他のコードの後で、その関数が返る直前に実行されるひとかたまりのコードを書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use &lt;c0&gt;&lt;s1&gt;deinit&lt;/s1&gt;&lt;/c0&gt; to create a deinitializer if you need to perform some cleanup before the object is deallocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オブジェクトが割り当て解除される前にあなたがいくらかの掃除をする必要があるならば、デイニシャライザをつくるために、&lt;c0&gt;&lt;s1&gt;deinit&lt;/s1&gt;&lt;/c0&gt;を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use &lt;c0&gt;&lt;s1&gt;enum&lt;/s1&gt;&lt;/c0&gt; to create an enumeration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙をつくるために、&lt;c0&gt;&lt;s1&gt;enum&lt;/s1&gt;&lt;/c0&gt;を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use &lt;c0&gt;&lt;s1&gt;extension&lt;/s1&gt;&lt;/c0&gt; to add functionality to an existing type, such as new methods and computed properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>機能性、例えば新しいメソッドや計算プロパティなどを、既存の型に加えるために、&lt;c0&gt;&lt;s1&gt;extension&lt;/s1&gt;&lt;/c0&gt;を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use &lt;c0&gt;&lt;s1&gt;fileprivate(set)&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;private(set)&lt;/s3&gt;&lt;/c2&gt;, and &lt;c4&gt;&lt;s5&gt;internal(set)&lt;/s5&gt;&lt;/c4&gt; to change the access level of this synthesized setter in exactly the same way as for an explicit setter in a computed property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;fileprivate(set)&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;private(set)&lt;/s3&gt;&lt;/c2&gt;、そして&lt;c4&gt;&lt;s5&gt;internal(set)&lt;/s5&gt;&lt;/c4&gt;を使って、計算プロパティにおける明示的なセッターと正確に同じ方法で、この総合されたセッターのアクセス水準を変更してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use &lt;c0&gt;&lt;s1&gt;func&lt;/s1&gt;&lt;/c0&gt; to declare a function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;func&lt;/s1&gt;&lt;/c0&gt;を使うことで、あるひとつの関数を宣言してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use &lt;c0&gt;&lt;s1&gt;iOS&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;macOS&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;watchOS&lt;/s5&gt;&lt;/c4&gt;, and &lt;c6&gt;&lt;s7&gt;tvOS&lt;/s7&gt;&lt;/c6&gt; for the platform names, and include the corresponding version numbers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プラットホーム名として&lt;c0&gt;&lt;s1&gt;iOS&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;macOS&lt;/s3&gt;&lt;/c2&gt;、&lt;c4&gt;&lt;s5&gt;watchOS&lt;/s5&gt;&lt;/c4&gt;、そして&lt;c6&gt;&lt;s7&gt;tvOS&lt;/s7&gt;&lt;/c6&gt;を、付随するバージョン番号を含めて使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use &lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt; to make conditionals, and use &lt;c4&gt;&lt;s5&gt;for&lt;/s5&gt;&lt;/c4&gt;-&lt;c6&gt;&lt;s7&gt;in&lt;/s7&gt;&lt;/c6&gt;, &lt;c8&gt;&lt;s9&gt;while&lt;/s9&gt;&lt;/c8&gt;, and &lt;c10&gt;&lt;s11&gt;repeat&lt;/s11&gt;&lt;/c10&gt;-&lt;c12&gt;&lt;s13&gt;while&lt;/s13&gt;&lt;/c12&gt; to make loops.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>条件文を作るために&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt;を使ってください、そしてループを作るために&lt;c4&gt;&lt;s5&gt;for&lt;/s5&gt;&lt;/c4&gt;-&lt;c6&gt;&lt;s7&gt;in&lt;/s7&gt;&lt;/c6&gt;、&lt;c8&gt;&lt;s9&gt;while&lt;/s9&gt;&lt;/c8&gt;、そして&lt;c10&gt;&lt;s11&gt;repeat&lt;/s11&gt;&lt;/c10&gt;-&lt;c12&gt;&lt;s13&gt;while&lt;/s13&gt;&lt;/c12&gt;を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use &lt;c0&gt;&lt;s1&gt;let&lt;/s1&gt;&lt;/c0&gt; to make a constant and &lt;c2&gt;&lt;s3&gt;var&lt;/s3&gt;&lt;/c2&gt; to make a variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;let&lt;/s1&gt;&lt;/c0&gt;を使って定数を作り&lt;c2&gt;&lt;s3&gt;var&lt;/s3&gt;&lt;/c2&gt;を使って変数を作ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use &lt;c0&gt;&lt;s1&gt;protocol&lt;/s1&gt;&lt;/c0&gt; to declare a protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロトコルを宣言するために、&lt;c0&gt;&lt;s1&gt;protocol&lt;/s1&gt;&lt;/c0&gt;を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use &lt;c0&gt;&lt;s1&gt;struct&lt;/s1&gt;&lt;/c0&gt; to create a structure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>構造体を作成するために、&lt;c0&gt;&lt;s1&gt;struct&lt;/s1&gt;&lt;/c0&gt;を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use &lt;c0&gt;&lt;s1&gt;throw&lt;/s1&gt;&lt;/c0&gt; to throw an error and &lt;c2&gt;&lt;s3&gt;throws&lt;/s3&gt;&lt;/c2&gt; to mark a function that can throw an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるエラーをスローする（投げかける）ために&lt;c0&gt;&lt;s1&gt;throw&lt;/s1&gt;&lt;/c0&gt;を、そしてエラーをスローできる関数に印をつけるために&lt;c2&gt;&lt;s3&gt;throws&lt;/s3&gt;&lt;/c2&gt;を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use &lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt; right before the body to specify a list of requirements—for example, to require the type to implement a protocol, to require two types to be the same, or to require a class to have a particular superclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>本文のまさに前に、必要なことのリストを指定するために&lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt;を使ってください ― 例えば、型があるプロトコルを実装することを要求するために、２つの型が同じものであることを要求するために、またはあるクラスがある特定のスーパークラスを持つことを要求するために。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use &lt;c0&gt;&lt;s1&gt;while&lt;/s1&gt;&lt;/c0&gt; to repeat a block of code until a condition changes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;while&lt;/s1&gt;&lt;/c0&gt;を使って、コードのひとかたまり（ブロック）を、ある条件が変化するまで繰り返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use &lt;c2&gt;&lt;s3&gt;-&gt;&lt;/s3&gt;&lt;/c2&gt; to separate the parameter names and types from the function’s return type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;-&gt;&lt;/s3&gt;&lt;/c2&gt;を使って、パラメーター名とその関数の返す型とを隔ててください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use &lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt; to separate the arguments and return type from the body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt;を使って、引数および返す型を本文から切り離してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use &lt;c2&gt;&lt;s3&gt;init&lt;/s3&gt;&lt;/c2&gt; to create one.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そうしたものをつくるために、&lt;c2&gt;&lt;s3&gt;init&lt;/s3&gt;&lt;/c2&gt;を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use a class-only protocol when the behavior defined by that protocol’s requirements assumes or requires that a conforming type has reference semantics rather than value semantics.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラス専用プロトコルを、そのプロトコルの要件によって定義される挙動が想定されるまたは必要とされる時、準拠する型が値意味論ではなく参照意味論を持つ時に、使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use a line control statement to change the source code location used by Swift for diagnostic and debugging purposes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>行制御文を使ってスウィフトによって使われるソースコード位置を診断上のそしてデバッグの目的で変更してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use a new key of the appropriate type as the subscript index, and assign a new value of the appropriate type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字インデックスとして適切な型の新しいキーを使ってください、そして適切な型の新しい値を割り当ててください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use a precondition whenever a condition has the potential to be false, but must &lt;e0&gt;definitely&lt;/e0&gt; be true for your code to continue execution.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある条件が偽である可能性をもつ、しかし&lt;e0&gt;definitely&lt;/e0&gt;があなたのコードの実行の継続のためにtrueでなければならない時はいつでも前提条件を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use a single &lt;c6&gt;&lt;s7&gt;break&lt;/s7&gt;&lt;/c6&gt; statement if you don’t intend to execute any code in the body of a matched case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがマッチされたケース節の本文において何らコードを実行するつもりでないならば、ただ１つ&lt;c6&gt;&lt;s7&gt;break&lt;/s7&gt;&lt;/c6&gt;文を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use a string literal as an initial value for a constant or variable:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列リテラルを定数または変数の初期値として使ってください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use a tuple to make a compound value—for example, to return multiple values from a function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある混成の値を作るために、タプル（一組にしたもの）を使ってください ― 例えば、関数から複数の値を返すために。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use a weak reference when the other instance has a shorter lifetime—that is, when the other instance can be deallocated first.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>弱い参照を他のインスタンスがより短い生涯を持つ場合に使ってください — すなわち、他のインスタンスが最初にでアロケートされることが可能である時。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use a wildcard pattern when you don’t care about the values being matched against.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがマッチされている値を気にかけない場合に、ワイルドカード・パターンを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use an initializer expression to construct an instance of a type from that type’s metatype value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イニシャライザ式を使って、ある型のインスタンスをその型のメタタイプ値から組み立ててください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use an unowned reference only when you are sure that the reference &lt;e0&gt;always&lt;/e0&gt; refers to an instance that has not been deallocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非所有参照を、その参照が&lt;e0&gt;常に&lt;/e0&gt;デアロケートされていないインスタンスに言及するとあなたが確信する時にだけ使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use comments to include nonexecutable text in your code, as a note or reminder to yourself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなた自身への注意事項または覚え書きとして、実行可能でないテキストをあなたのコードに含めるために、コメントを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use dot syntax to access the properties and methods of the instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのインスタンスのプロパティおよびメソッドにアクセスするためにドット構文を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use file-private access to hide the implementation details of a specific piece of functionality when those details are used within an entire file.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それら詳細があるファイル全体の内部で使われる時に、機能性のある特定部分のそれら実装詳細を隠すために、ファイル外非公開アクセスを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use optional chaining to conditionally perform an operation on an implicitly unwrapped optional expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある暗黙的にアンラップされるオプショナルの式に関して演算を条件付きで実行するために、オプショナル連鎖を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use other integer types only when they’re specifically needed for the task at hand, because of explicitly sized data from an external source, or for performance, memory usage, or other necessary optimization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>外部ソース由来の明確に大きさを設定されたデータのために、またはパフォーマンス、メモリ使用、または他の必要な最適化のためになど、目下の作業に特に必要とされる時にだけ、他の整数を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use private access to hide the implementation details of a specific piece of functionality when those details are used only within a single declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それら詳細がある単一の宣言内部でのみ使われる時に、機能性のある特定部分のそれら実装詳細を隠すために、非公開アクセスを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use statement labels with &lt;c7&gt;&lt;s8&gt;break&lt;/s8&gt;&lt;/c7&gt; and &lt;c9&gt;&lt;s10&gt;continue&lt;/s10&gt;&lt;/c9&gt; statements to be explicit about how you want to change control flow in a loop statement or a &lt;c11&gt;&lt;s12&gt;switch&lt;/s12&gt;&lt;/c11&gt; statement, as discussed in &lt;a13&gt;&lt;s14&gt;Break Statement&lt;/s14&gt;&lt;/a13&gt; and &lt;a15&gt;&lt;s16&gt;Continue Statement&lt;/s16&gt;&lt;/a15&gt; below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c7&gt;&lt;s8&gt;break&lt;/s8&gt;&lt;/c7&gt;と&lt;c9&gt;&lt;s10&gt;continue&lt;/s10&gt;&lt;/c9&gt;文で文ラベルを使って、あなたがループ文または&lt;c11&gt;&lt;s12&gt;switch&lt;/s12&gt;&lt;/c11&gt;文においてどのように制御の流れを変えたいかについて明示してください、下記の&lt;a13&gt;&lt;s14&gt;ブレーク文&lt;/s14&gt;&lt;/a13&gt;と&lt;a15&gt;&lt;s16&gt;継続文&lt;/s16&gt;&lt;/a15&gt;で議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the &lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt; type for all general-purpose integer constants and variables in your code, even if they’re known to be nonnegative.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt;型を全ての一般的な目的のための整数の定数と変数に対してあなたのコードにおいて使ってください、たとえそれらが負数でないことが知られているとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the &lt;c0&gt;&lt;s1&gt;indices&lt;/s1&gt;&lt;/c0&gt; property to access all of the indices of individual characters in a string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;indices&lt;/s1&gt;&lt;/c0&gt;プロパティを使って、ある文字列中の個々の文字のインデックスの全てにアクセスしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the &lt;c0&gt;&lt;s1&gt;init?(rawValue:)&lt;/s1&gt;&lt;/c0&gt; initializer to make an instance of an enumeration from a raw value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;init?(rawValue:)&lt;/s1&gt;&lt;/c0&gt;イニシャライザを使用して、生の値から列挙のインスタンスを作ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the &lt;c0&gt;&lt;s1&gt;intersection(_:)&lt;/s1&gt;&lt;/c0&gt; method to create a new set with only the values common to both sets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;intersection(_:)&lt;/s1&gt;&lt;/c0&gt;メソッドを使って両方の集合に共通した値だけを持つ新しい集合を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the &lt;c0&gt;&lt;s1&gt;isDisjoint(with:)&lt;/s1&gt;&lt;/c0&gt; method to determine whether two sets have no values in common.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;isDisjoint(with:)&lt;/s1&gt;&lt;/c0&gt;メソッドを使って２つの集合が共通の値を全く持たないかどうか判定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the &lt;c0&gt;&lt;s1&gt;isStrictSubset(of:)&lt;/s1&gt;&lt;/c0&gt; or &lt;c2&gt;&lt;s3&gt;isStrictSuperset(of:)&lt;/s3&gt;&lt;/c2&gt; methods to determine whether a set is a subset or superset, but not equal to, a specified set.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;isStrictSubset(of:)&lt;/s1&gt;&lt;/c0&gt;または&lt;c2&gt;&lt;s3&gt;isStrictSuperset(of:)&lt;/s3&gt;&lt;/c2&gt;メソッドを使ってある集合がある指定した集合の下位集合または上位集合、しかし等しくはない、かどうか決定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the &lt;c0&gt;&lt;s1&gt;isSubset(of:)&lt;/s1&gt;&lt;/c0&gt; method to determine whether all of the values of a set are contained in the specified set.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;isSubset(of:)&lt;/s1&gt;&lt;/c0&gt;メソッドを使ってある集合のすべての値が指定した集合の値の中に含まれるかどうか決定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the &lt;c0&gt;&lt;s1&gt;isSuperset(of:)&lt;/s1&gt;&lt;/c0&gt; method to determine whether a set contains all of the values in a specified set.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;isSuperset(of:)&lt;/s1&gt;&lt;/c0&gt;メソッドを使ってある集合がある指定した集合の値のすべてを含むかどうか決定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the &lt;c0&gt;&lt;s1&gt;startIndex&lt;/s1&gt;&lt;/c0&gt; property to access the position of the first &lt;c2&gt;&lt;s3&gt;Character&lt;/s3&gt;&lt;/c2&gt; of a &lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある&lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt;の最初の&lt;c2&gt;&lt;s3&gt;Character&lt;/s3&gt;&lt;/c2&gt;の位置にアクセスするために&lt;c0&gt;&lt;s1&gt;startIndex&lt;/s1&gt;&lt;/c0&gt;プロパティを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the &lt;c0&gt;&lt;s1&gt;subtracting(_:)&lt;/s1&gt;&lt;/c0&gt; method to create a new set with values not in the specified set.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;subtracting(_:)&lt;/s1&gt;&lt;/c0&gt;メソッドを使って指定した集合にない値を持つ新しい集合を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the &lt;c0&gt;&lt;s1&gt;symmetricDifference(_:)&lt;/s1&gt;&lt;/c0&gt; method to create a new set with values in either set, but not both.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;symmetricDifference(_:)&lt;/s1&gt;&lt;/c0&gt;メソッドを使ってどちらかの集合にある、しかし両方にではない値を持つ新しい集合を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the &lt;c0&gt;&lt;s1&gt;union(_:)&lt;/s1&gt;&lt;/c0&gt; method to create a new set with all of the values in both sets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;union(_:)&lt;/s1&gt;&lt;/c0&gt;メソッドを使って両方の集合のすべての値を持つ新しい集合を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the &lt;c12&gt;&lt;s13&gt;String&lt;/s13&gt;&lt;/c12&gt; type’s &lt;c14&gt;&lt;s15&gt;append(_:)&lt;/s15&gt;&lt;/c14&gt; method to append a single &lt;c16&gt;&lt;s17&gt;Character&lt;/s17&gt;&lt;/c16&gt; value onto the end of a string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c12&gt;&lt;s13&gt;String&lt;/s13&gt;&lt;/c12&gt;型の&lt;c14&gt;&lt;s15&gt;append(_:)&lt;/s15&gt;&lt;/c14&gt;メソッドを単一の&lt;c16&gt;&lt;s17&gt;Character&lt;/s17&gt;&lt;/c16&gt;値を文字列の終わりに加えるために使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the &lt;c2&gt;&lt;s3&gt;stride(from:to:by:)&lt;/s3&gt;&lt;/c2&gt; function to skip the unwanted marks.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c2&gt;&lt;s3&gt;stride(from:to:by:)&lt;/s3&gt;&lt;/c2&gt;関数を使って、不必要な印を飛ばしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the &lt;c4&gt;&lt;s5&gt;rawValue&lt;/s5&gt;&lt;/c4&gt; property to access the raw value of an enumeration case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;rawValue&lt;/s5&gt;&lt;/c4&gt;プロパティを使用して、列挙ケース節の生の値にアクセスしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the &lt;e0&gt;type check operator&lt;/e0&gt; (&lt;c1&gt;&lt;s2&gt;is&lt;/s2&gt;&lt;/c1&gt;) to check whether an instance is of a certain subclass type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;e0&gt;型確認演算子&lt;/e0&gt;（&lt;c1&gt;&lt;s2&gt;is&lt;/s2&gt;&lt;/c1&gt;）を使用して、あるインスタンスが特定のサブクラス型であるかどうか調べてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the Boolean &lt;c0&gt;&lt;s1&gt;isEmpty&lt;/s1&gt;&lt;/c0&gt; property as a shortcut for checking whether the &lt;c2&gt;&lt;s3&gt;count&lt;/s3&gt;&lt;/c2&gt; property is equal to &lt;c4&gt;&lt;s5&gt;0&lt;/s5&gt;&lt;/c4&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ブールの&lt;c0&gt;&lt;s1&gt;isEmpty&lt;/s1&gt;&lt;/c0&gt;プロパティを&lt;c2&gt;&lt;s3&gt;count&lt;/s3&gt;&lt;/c2&gt;プロパティが&lt;c4&gt;&lt;s5&gt;0&lt;/s5&gt;&lt;/c4&gt;と等しいかどうかを調べる近道として使ってください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the classes defined above to create a new &lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt; instance, and try to access its &lt;c2&gt;&lt;s3&gt;numberOfRooms&lt;/s3&gt;&lt;/c2&gt; property as before:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上のクラス定義を使って、新しい&lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt;インスタンスをつくって、前のようにその&lt;c2&gt;&lt;s3&gt;numberOfRooms&lt;/s3&gt;&lt;/c2&gt;プロパティにアクセスすることを試みてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the conditional form of the type cast operator (&lt;c0&gt;&lt;s1&gt;as?&lt;/s1&gt;&lt;/c0&gt;) when you are not sure if the downcast will succeed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがダウンキャストが成功するかどうかよくわからない場合には、条件形式の型キャスト演算子（&lt;c0&gt;&lt;s1&gt;as?&lt;/s1&gt;&lt;/c0&gt;）を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the forced form of the type cast operator (&lt;c0&gt;&lt;s1&gt;as!&lt;/s1&gt;&lt;/c0&gt;) only when you are sure that the downcast will always succeed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがダウンキャストが常に成功すると確信する場合には、強制形式の型キャスト演算子（&lt;c0&gt;&lt;s1&gt;as!&lt;/s1&gt;&lt;/c0&gt;）を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the half-open range operator (&lt;c4&gt;&lt;s5&gt;..&lt;&lt;/s5&gt;&lt;/c4&gt;) to include the lower bound but not the upper bound.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>半開範囲演算子（&lt;c4&gt;&lt;s5&gt;..&lt;&lt;/s5&gt;&lt;/c4&gt;）を使って、下方の境界を含めて、しかし上方の境界を含めないようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the ternary conditional operator with care, however.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし、注意して三項条件演算子を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the “is equal” operator (&lt;c0&gt;&lt;s1&gt;==&lt;/s1&gt;&lt;/c0&gt;) to determine whether two sets contain all of the same values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「同等」演算子（&lt;c0&gt;&lt;s1&gt;==&lt;/s1&gt;&lt;/c0&gt;）を使って２つの集合がすべて同じ値を含むかどうか決定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use these operators to check whether two constants or variables refer to the same single instance:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つの定数または変数が同じ１つのインスタンスに言及するかどうか調べるためにこれらの演算子を使用してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use this approach if you need to add a potential failure state to an existing initialization process that does not otherwise fail.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが、起こりうる失敗状況を、その場合にも失敗しない既存の初期化プロセスに加える必要がある場合に、このやり方を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use this attribute to help discourage ambiguity between functions with the same name that are accessible from the same scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性を使って、関数とその同じスコープからアクセス可能な同じ名前との間の曖昧さを防止するのに役立ててください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use this form of an access-level modifier when you want to specify an access level for the setter of a variable or subscript that’s less than or equal to the access level of the variable or subscript itself, as discussed in &lt;a4&gt;&lt;s5&gt;Getters and Setters&lt;/s5&gt;&lt;/a4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アクセス水準修飾子のこの形式は、あなたが変数または添え字のセッターにその変数または添え字それ自身のアクセス水準よりもより少ないか等しいアクセス水準を指定することを望むときに使ってください、&lt;a4&gt;&lt;s5&gt;ゲッターとセッター&lt;/s5&gt;&lt;/a4&gt;で議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use this form to access a type as a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値として型にアクセスするために、この形式を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use three double quotation marks (&lt;c0&gt;&lt;s1&gt;"""&lt;/s1&gt;&lt;/c0&gt;) for strings that take up multiple lines.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数行にわたる文字列のために３つの二重引用符（&lt;c0&gt;&lt;s1&gt;"""&lt;/s1&gt;&lt;/c0&gt;）を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use variables only for storing values that need to be able to change.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変更できる必要がある値を保存するためにだけ、変数を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using &lt;c0&gt;&lt;s1&gt;try?&lt;/s1&gt;&lt;/c0&gt; lets you write concise error handling code when you want to handle all errors in the same way.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;try?&lt;/s1&gt;&lt;/c0&gt;を使うことで、あなたに簡潔なエラー処理コードを書くことを可能にするのは、あなたがすべてのエラーを同じやり方で取り扱いたい時です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using ARC in Swift is very similar to the approach described in &lt;a0&gt;Transitioning to ARC Release Notes&lt;/a0&gt;&lt;s1&gt; [https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html]&lt;/s1&gt; for using ARC with Objective-C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトでのARCの使用は、Objective-CでARCを使うための&lt;a0&gt;Transitioning to ARC Release Notes&lt;/a0&gt;&lt;s1&gt; [https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html]&lt;/s1&gt;で記述される取り組みに非常に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using Function Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数型を使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using a &lt;c0&gt;&lt;s1&gt;guard&lt;/s1&gt;&lt;/c0&gt; statement for requirements improves the readability of your code, compared to doing the same check with an &lt;c2&gt;&lt;s3&gt;if&lt;/s3&gt;&lt;/c2&gt; statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;guard&lt;/s1&gt;&lt;/c0&gt;文を必要条件に対して使うことは、あなたのコードの可読性を同じ検査確認を&lt;c2&gt;&lt;s3&gt;if&lt;/s3&gt;&lt;/c2&gt;文を使って実行するのと比べて向上します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using a Protocol in Its Associated Type’s Constraints</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロトコルをそれの関連型のもつ制約において使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using a generic &lt;c12&gt;&lt;s13&gt;where&lt;/s13&gt;&lt;/c12&gt; clause lets you add a new requirement to the extension, so that the extension adds the &lt;c14&gt;&lt;s15&gt;isTop(_:)&lt;/s15&gt;&lt;/c14&gt; method only when the items in the stack are equatable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体&lt;c12&gt;&lt;s13&gt;where&lt;/s13&gt;&lt;/c12&gt;節を使うことは、あなたに新しい要件をその拡張に追加させます、それで拡張は&lt;c14&gt;&lt;s15&gt;isTop(_:)&lt;/s15&gt;&lt;/c14&gt;メソッドをスタックの中の項目が同等評価可能なものである時のみ加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using a protocol as a type is sometimes called an &lt;e0&gt;existential type&lt;/e0&gt;, which comes from the phrase “there exists a type &lt;e1&gt;T&lt;/e1&gt; such that &lt;e2&gt;T&lt;/e2&gt; conforms to the protocol”.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルを型として使うことは、ときどき&lt;e0&gt;存在型&lt;/e0&gt;と呼ばれます、それは語句 “そこに型&lt;e1&gt;T&lt;/e1&gt;が存在する、そのような&lt;e2&gt;T&lt;/e2&gt;はそのプロトコルに準拠する” から来ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using a protocol type as the return type for a function gives you the flexibility to return any type that conforms to the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル型を戻り型として関数に使うことは、あなたに、そのプロトコルに準拠するどんな型でも返す柔軟性を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using assertions and preconditions isn’t a substitute for designing your code in such a way that invalid conditions are unlikely to arise.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>表明と前提条件を使用することは、無効な条件が思いもよらず起こるようなあなたのコードの設計に対する代役ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using explicitly sized types in these situations helps to catch any accidental value overflows and implicitly documents the nature of the data being used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの状況において明示的に大きさを設定された型を使うことは、偶発的な何らかの値のオーバフローを捕えることや、使われているデータの性質を暗黙的に記録することの手助けになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using optionals is similar to using &lt;c3&gt;&lt;s4&gt;nil&lt;/s4&gt;&lt;/c3&gt; with pointers in Objective-C, but they work for any type, not just classes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルの使用は、Objective-Cのポインターで&lt;c3&gt;&lt;s4&gt;nil&lt;/s4&gt;&lt;/c3&gt;を使うことに似ています、しかしそれは、ただクラスだけでなく、どんな型のためにでも働きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using the &lt;c0&gt;&lt;s1&gt;!&lt;/s1&gt;&lt;/c0&gt; operator to unwrap an optional that has a value of &lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt; results in a runtime error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;!&lt;/s1&gt;&lt;/c0&gt;演算子を使って&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;の値を持つあるオプショナルをアンラップすることは、実行時エラーの結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using the &lt;c8&gt;&lt;s9&gt;gameLoop&lt;/s9&gt;&lt;/c8&gt; label makes it clear which control statement should be terminated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c8&gt;&lt;s9&gt;gameLoop&lt;/s9&gt;&lt;/c8&gt;ラベルを使用することは、どの制御文が終了されなければならないかを明確にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using the default integer type in everyday situations means that integer constants and variables are immediately interoperable in your code and will match the inferred type for integer literal values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>日々の状況において初期状態として整数型を使うことは、整数の定数と変数があなたのコードにおいて直接に情報交換が可能で、いろいろな整数のリテラル値に対して推論される型と調和することを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using the opaque type &lt;c0&gt;&lt;s1&gt;some&lt;/s1&gt; &lt;s2&gt;Container&lt;/s2&gt;&lt;/c0&gt; as a return type expresses the desired API contract—the function returns a container, but declines to specify the container’s type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>不透明型&lt;c0&gt;&lt;s1&gt;some&lt;/s1&gt; &lt;s2&gt;Container&lt;/s2&gt;&lt;/c0&gt;を戻り型として使うことは、望まれるAPI契約を表現します — 関数はあるコンテナ（容れ物）を返します、しかしコンテナのもつ型を指定することを辞退します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using this attribute is equivalent to calling the &lt;c0&gt;&lt;s1&gt;NSApplicationMain(_:_:)&lt;/s1&gt;&lt;/c0&gt; function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性を使用することは、&lt;c0&gt;&lt;s1&gt;NSApplicationMain(_:_:)&lt;/s1&gt;&lt;/c0&gt;関数を呼ぶことに相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using this attribute is equivalent to calling the &lt;c0&gt;&lt;s1&gt;UIApplicationMain&lt;/s1&gt;&lt;/c0&gt; function and passing this class’s name as the name of the delegate class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この属性を使用することは、&lt;c0&gt;&lt;s1&gt;UIApplicationMain&lt;/s1&gt;&lt;/c0&gt;関数を呼んで、このクラスの名前を委任先クラスの名前として渡すことに相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Valid arguments</seg>
      </tuv>
      <tuv lang="JA">
        <seg>有効な引数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Value</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Value Bindings</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値束縛</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Value Overflow</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値オーバフロー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Value types (structures and enumerations) do not support inheritance, and so their initializer delegation process is relatively simple, because they can only delegate to another initializer that they provide themselves.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値型（構造体と列挙）は、継承をサポートしません、なので、それらのイニシャライザ委任プロセスは比較的単純です、なぜなら、それらがそれら自身で提供する別のイニシャライザに委任できるだけだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Value types are described in &lt;a10&gt;&lt;s11&gt;Structures and Enumerations Are Value Types&lt;/s11&gt;&lt;/a10&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値型は&lt;a10&gt;&lt;s11&gt;「構造体と列挙は値型です」&lt;/s11&gt;&lt;/a10&gt;で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Value-Binding Pattern</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値束縛パターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Value-binding patterns that bind a matched value to the name of a constant begin with the &lt;c1&gt;&lt;s2&gt;let&lt;/s2&gt;&lt;/c1&gt; keyword; those that bind to the name of variable begin with the &lt;c3&gt;&lt;s4&gt;var&lt;/s4&gt;&lt;/c3&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>マッチした値を定数の名前に束縛する値束縛パターンは、&lt;c1&gt;&lt;s2&gt;let&lt;/s2&gt;&lt;/c1&gt;キーワードで始まります；変数の名前と縛りつけるものは、&lt;c3&gt;&lt;s4&gt;var&lt;/s4&gt;&lt;/c3&gt;キーワードで始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Values are captured in key paths using value semantics.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>様々な値は、キーパスの中に値意味論を使ってキャプチャされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Values are never implicitly converted to another type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>なんらかの値が暗黙のうちに別の型に変換されることは決してありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Values in &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; cases can be checked for their inclusion in an interval.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;ケース節における値は、ある区間におけるそれの包含について調べられることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Values in the matrix can be set by passing row and column values into the subscript, separated by a comma:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>行列の中の値は、コンマで区切った行と列の値を添え字に渡すことによって設定されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variable Declaration</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変数の宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variable declarations have several forms that declare different kinds of named, mutable values, including stored and computed variables and properties, stored variable and property observers, and static variable properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変数宣言はいくつかの形式を持ちます、それらは、格納および計算の変数およびプロパティ、格納である変数およびプロパティのオブザーバー、そして静的変数プロパティを含む、異なる種類の名前をつけられた可変の値を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variables and constants declared in the scope of a &lt;c4&gt;&lt;s5&gt;do&lt;/s5&gt;&lt;/c4&gt; statement can be accessed only within that scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;do&lt;/s5&gt;&lt;/c4&gt;文のスコープ内で宣言される変数と定数は、そのスコープ内でのみアクセスされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variables are always initialized before use.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変数は、常に使用前に初期化される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variadic Parameters</seg>
      </tuv>
      <tuv lang="JA">
        <seg>可変長パラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variadic parameters are allowed, subject to the same rules as for normal methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>可変長パラメータは、許され、普通のメソッドと同じ規則の支配下にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Variadic parameters can be used if you name the variadic parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが可変長パラメータに名前をつけるならば、可変長パラメータが使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Version Compatibility</seg>
      </tuv>
      <tuv lang="JA">
        <seg>バージョン互換性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can’t wait to see what you create with it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>私達は、あなたがそれで何をつくるか知るのが待ち切れません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Weak References</seg>
      </tuv>
      <tuv lang="JA">
        <seg>弱い参照</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Weak and Unowned References</seg>
      </tuv>
      <tuv lang="JA">
        <seg>弱いおよび非所有参照</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Weak and unowned references enable one instance in a reference cycle to refer to the other instance &lt;e0&gt;without&lt;/e0&gt; keeping a strong hold on it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>弱いおよび非所有参照は、ある参照循環の中の１つのインスタンスに、他のインスタンスに言及することをそれに対する強い支配力を持つこと&lt;e0&gt;なく&lt;/e0&gt;可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Weak references are always of an optional type, and automatically become &lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt; when the instance they reference is deallocated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>弱い参照は常にオプショナルの型です、そしてそれが参照をつけるインスタンスが割り当て解除されるとき、自動的に&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Welcome to Swift</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトにようこそ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What about the second and third blocks?</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２番目と３番目のブロックはどうですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What changes do you need to make to &lt;c2&gt;&lt;s3&gt;SimpleClass&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;SimpleStructure&lt;/s5&gt;&lt;/c4&gt; so that they still conform to the protocol?</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どんな変更をあなたは&lt;c2&gt;&lt;s3&gt;SimpleClass&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;SimpleStructure&lt;/s5&gt;&lt;/c4&gt;にする必要があるでしょうか、それらが依然としてそのプロトコルに準拠するためには？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What error do you get?</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、どんなエラーを得ますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What greeting do you get?</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、どんな挨拶を得ますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What kind of error do you need to throw so that the error is handled by the first &lt;c2&gt;&lt;s3&gt;catch&lt;/s3&gt;&lt;/c2&gt; block?</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーが最初の&lt;c2&gt;&lt;s3&gt;catch&lt;/s3&gt;&lt;/c2&gt;ブロックによって取り扱われるためには、どんな種類のエラーをあなたはスローする必要があるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When &lt;c0&gt;&lt;s1&gt;cinema&lt;/s1&gt;&lt;/c0&gt; was given the current value of &lt;c2&gt;&lt;s3&gt;hd&lt;/s3&gt;&lt;/c2&gt;, the &lt;e4&gt;values&lt;/e4&gt; stored in &lt;c5&gt;&lt;s6&gt;hd&lt;/s6&gt;&lt;/c5&gt; were copied into the new &lt;c7&gt;&lt;s8&gt;cinema&lt;/s8&gt;&lt;/c7&gt; instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;cinema&lt;/s1&gt;&lt;/c0&gt;が&lt;c2&gt;&lt;s3&gt;hd&lt;/s3&gt;&lt;/c2&gt;の現在の値を与えられたとき、&lt;c5&gt;&lt;s6&gt;hd&lt;/s6&gt;&lt;/c5&gt;に格納される&lt;e4&gt;値&lt;/e4&gt;は新しい&lt;c7&gt;&lt;s8&gt;cinema&lt;/s8&gt;&lt;/c7&gt;インスタンスにコピーされました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When &lt;c0&gt;&lt;s1&gt;log()&lt;/s1&gt;&lt;/c0&gt; is called on the instance that’s passed to &lt;c2&gt;&lt;s3&gt;doSomething(_:)&lt;/s3&gt;&lt;/c2&gt;, the customized title is omitted from the logged string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;log()&lt;/s1&gt;&lt;/c0&gt;が&lt;c2&gt;&lt;s3&gt;doSomething(_:)&lt;/s3&gt;&lt;/c2&gt;に渡されるインスタンス上で呼び出される時、カスタマイズされたタイトルはログ文字列から省かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When &lt;c0&gt;&lt;s1&gt;printMathResult(_:_:_:)&lt;/s1&gt;&lt;/c0&gt; is called, it is passed the &lt;c2&gt;&lt;s3&gt;addTwoInts(_:_:)&lt;/s3&gt;&lt;/c2&gt; function, and the integer values &lt;c4&gt;&lt;s5&gt;3&lt;/s5&gt;&lt;/c4&gt; and &lt;c6&gt;&lt;s7&gt;5&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;printMathResult(_:_:_:)&lt;/s1&gt;&lt;/c0&gt;が呼ばれるとき、それは、&lt;c2&gt;&lt;s3&gt;addTwoInts(_:_:)&lt;/s3&gt;&lt;/c2&gt;関数、そして整数値&lt;c4&gt;&lt;s5&gt;3&lt;/s5&gt;&lt;/c4&gt;と&lt;c6&gt;&lt;s7&gt;5&lt;/s7&gt;&lt;/c6&gt;を渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When &lt;c0&gt;&lt;s1&gt;rememberedDirection&lt;/s1&gt;&lt;/c0&gt; is assigned the value of &lt;c2&gt;&lt;s3&gt;currentDirection&lt;/s3&gt;&lt;/c2&gt;, it’s actually set to a copy of that value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;rememberedDirection&lt;/s1&gt;&lt;/c0&gt;が&lt;c2&gt;&lt;s3&gt;currentDirection&lt;/s3&gt;&lt;/c2&gt;の値を代入されるとき、それは実際にはその値のコピーに設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When &lt;c4&gt;&lt;s5&gt;index&lt;/s5&gt;&lt;/c4&gt; is modified, the key-path expression still references the third element, while the closure uses the new index.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c4&gt;&lt;s5&gt;index&lt;/s5&gt;&lt;/c4&gt;が修正される時、キーパス式は依然として３番目の要素に参照を付けます、一方でクロージャは新しいインデックスを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When &lt;c6&gt;&lt;s7&gt;residence&lt;/s7&gt;&lt;/c6&gt; is &lt;c8&gt;&lt;s9&gt;nil&lt;/s9&gt;&lt;/c8&gt;, as in the example above, this optional &lt;c10&gt;&lt;s11&gt;Int&lt;/s11&gt;&lt;/c10&gt; will also be &lt;c12&gt;&lt;s13&gt;nil&lt;/s13&gt;&lt;/c12&gt;, to reflect the fact that it was not possible to access &lt;c14&gt;&lt;s15&gt;numberOfRooms&lt;/s15&gt;&lt;/c14&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;residence&lt;/s7&gt;&lt;/c6&gt;が&lt;c8&gt;&lt;s9&gt;nil&lt;/s9&gt;&lt;/c8&gt;のとき、上の例の場合のように、このオプショナルの&lt;c10&gt;&lt;s11&gt;Int&lt;/s11&gt;&lt;/c10&gt;はまた&lt;c12&gt;&lt;s13&gt;nil&lt;/s13&gt;&lt;/c12&gt;になり、&lt;c14&gt;&lt;s15&gt;numberOfRooms&lt;/s15&gt;&lt;/c14&gt;にアクセスすることは可能でなかったという事実を反映します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a &lt;c0&gt;&lt;s1&gt;break&lt;/s1&gt;&lt;/c0&gt; statement is followed by the name of a statement label, it ends program execution of the loop, &lt;c2&gt;&lt;s3&gt;if&lt;/s3&gt;&lt;/c2&gt; statement, or &lt;c4&gt;&lt;s5&gt;switch&lt;/s5&gt;&lt;/c4&gt; statement named by that label.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;break&lt;/s1&gt;&lt;/c0&gt;文に文ラベルの名前が続くとき、それはそのラベルによって指定されるループ、&lt;c2&gt;&lt;s3&gt;if&lt;/s3&gt;&lt;/c2&gt;文、または&lt;c4&gt;&lt;s5&gt;switch&lt;/s5&gt;&lt;/c4&gt;文のプログラム実行を終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a &lt;c0&gt;&lt;s1&gt;break&lt;/s1&gt;&lt;/c0&gt; statement is not followed by the name of a statement label, it ends program execution of the &lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt; statement or the innermost enclosing loop statement in which it occurs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;break&lt;/s1&gt;&lt;/c0&gt;文に文ラベルの名前が続かないとき、それは&lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt;文またはそれが現れているところの最も内側のそれを囲んでいるループ文のプログラム実行を終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a &lt;c0&gt;&lt;s1&gt;continue&lt;/s1&gt;&lt;/c0&gt; statement is followed by the name of a statement label, it ends program execution of the current iteration of the loop statement named by that label.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;continue&lt;/s1&gt;&lt;/c0&gt;文に文ラベルの名前が続くとき、それは、そのラベルによって指名されるループ文の現在の繰り返しのプログラム実行を終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a &lt;c0&gt;&lt;s1&gt;continue&lt;/s1&gt;&lt;/c0&gt; statement is not followed by the name of a statement label, it ends program execution of the current iteration of the innermost enclosing loop statement in which it occurs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;continue&lt;/s1&gt;&lt;/c0&gt;文に文ラベルの名前が続かないとき、それは、それが現れるところの一番内側のそれを囲んでいるループ文の現在の繰り返しのプログラム実行を終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a &lt;c0&gt;&lt;s1&gt;return&lt;/s1&gt;&lt;/c0&gt; statement is followed by an expression, the value of the expression is returned to the calling function or method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;return&lt;/s1&gt;&lt;/c0&gt;文の後に式が続くとき、式の値は関数またはメソッドを呼んでいるところに返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a &lt;c0&gt;&lt;s1&gt;return&lt;/s1&gt;&lt;/c0&gt; statement is not followed by an expression, it can be used only to return from a function or method that does not return a value (that is, when the return type of the function or method is &lt;c2&gt;&lt;s3&gt;Void&lt;/s3&gt;&lt;/c2&gt; or &lt;c4&gt;&lt;s5&gt;()&lt;/s5&gt;&lt;/c4&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;return&lt;/s1&gt;&lt;/c0&gt;文の後に式が続かないとき、それは値を返さない関数またはメソッド（すなわち、戻り型が&lt;c2&gt;&lt;s3&gt;Void&lt;/s3&gt;&lt;/c2&gt;または&lt;c4&gt;&lt;s5&gt;()&lt;/s5&gt;&lt;/c4&gt;である関数またはメソッド）から返るためにだけ使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a Unicode string is written to a text file or some other storage, the Unicode scalars in that string are encoded in one of several Unicode-defined &lt;e0&gt;encoding forms&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるUnicode文字列がテキスト・ファイルまたは何か他の記憶装置に書かれるとき、その文字列内のユニコード・スカラーはいくつかのUnicode定義の&lt;e0&gt;符号化方式&lt;/e0&gt;のうちの１つで符号化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a channel’s audio level is &lt;c0&gt;&lt;s1&gt;0&lt;/s1&gt;&lt;/c0&gt;, none of the lights for that channel are lit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>チャンネルの音声のレベルが&lt;c0&gt;&lt;s1&gt;0&lt;/s1&gt;&lt;/c0&gt;であるとき、そのチャンネルのための光のどれも点灯されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a class implements an initializer to satisfy a protocol’s initializer requirement, the initializer must be marked with the &lt;c0&gt;&lt;s1&gt;required&lt;/s1&gt;&lt;/c0&gt; declaration modifier if the class is not already marked with the &lt;c2&gt;&lt;s3&gt;final&lt;/s3&gt;&lt;/c2&gt; declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるクラスがプロトコルのイニシャライザ要件を満たすためにイニシャライザを実装するとき、そのイニシャライザは&lt;c0&gt;&lt;s1&gt;required&lt;/s1&gt;&lt;/c0&gt;宣言修飾子を使って印される必要が、そのクラスが既に&lt;c2&gt;&lt;s3&gt;final&lt;/s3&gt;&lt;/c2&gt;宣言修飾子を使って印されていないならば、あります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a closure is the only argument to a function, you can omit the parentheses entirely.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ひとつのクロージャが関数の唯一の引数である時、あなたは丸括弧をすっかり省くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a closure’s type is already known, such as the callback for a delegate, you can omit the type of its parameters, its return type, or both.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クロージャの型がすでに知られているとき、例えば委任先のためのコールバックなどでは、あなたはそのパラメータの型、その戻り型、あるいは両方を省略することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a concrete type conditionally conforms to a protocol, that type implicitly conforms to any parent protocols with the same requirements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>具象型があるプロトコルに条件準拠するとき、その型は同じ要件を持つあらゆる親プロトコルに暗黙的に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a constant declaration occurs in the context of a class or structure declaration, it is considered a &lt;e0&gt;constant property&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数宣言がクラスまたは構造体宣言の文脈において起こるとき、それは&lt;e0&gt;定数プロパティ&lt;/e0&gt;とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a constant declaration occurs in the context of a function or method, it can be initialized later, as long as it is guaranteed to have a value set before the first time its value is read.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数宣言が関数またはメソッドの文脈において現れるとき、それは後で初期化されることができます、それがある値をその値が読み出される最初の時の前に設定されてしまっているよう保証する限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a constant is declared at global scope, it must be initialized with a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数がグローバルなスコープで宣言されるとき、それはひとつの値で初期化されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a declaration is obsoleted, it’s removed from the specified platform or language and can no longer be used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある宣言が廃止された場合は、それは指定されたプラットホームまたは言語から取り除かれます、そしてもはや使用されることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a function encounters an error condition, it &lt;e0&gt;throws&lt;/e0&gt; an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある関数がエラー状態に遭遇するとき、それはあるエラーを&lt;e0&gt;スローします&lt;/e0&gt;（投げます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a function throws an error, it changes the flow of your program, so it’s important that you can quickly identify places in your code that can throw errors.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある関数がエラーをスローするとき、それはあなたのプログラムの流れを変えます、そのため重要なのは、あなたがすばやくあなたのコードの中のエラーをスローできる場所を識別することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a library’s authors mark an enumeration as nonfrozen, they reserve the right to add new enumeration cases, and any code that interacts with that enumeration &lt;e1&gt;must&lt;/e1&gt; be able to handle those future cases without being recompiled.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるライブラリの作者たちがある列挙を非凍結として印する時、彼らは新しい列挙ケース節を加える権利を有します、そしてその列挙と相互作用する何らかのコードは、それらの未来ケース節を再コンパイルされることなしに取り扱いできる&lt;e1&gt;必要があります&lt;/e1&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a member has the same name as a keyword, references to that member don’t need to be escaped with backticks, except when there’s ambiguity between referring to the member and using the keyword—for example, &lt;c8&gt;&lt;s9&gt;self&lt;/s9&gt;&lt;/c8&gt;, &lt;c10&gt;&lt;s11&gt;Type&lt;/s11&gt;&lt;/c10&gt;, and &lt;c12&gt;&lt;s13&gt;Protocol&lt;/s13&gt;&lt;/c12&gt; have special meaning in an explicit member expression, so they must be escaped with backticks in that context.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるメンバがあるキーワードと同じ名前を持つ時、そのメンバへの参照はバッククォートでエスケープされる必要はありません、そのメンバへの参照とキーワードの使用の間に曖昧さがある場合を除いては—例えば、&lt;c8&gt;&lt;s9&gt;self&lt;/s9&gt;&lt;/c8&gt;、&lt;c10&gt;&lt;s11&gt;Type&lt;/s11&gt;&lt;/c10&gt;、そして&lt;c12&gt;&lt;s13&gt;Protocol&lt;/s13&gt;&lt;/c12&gt;は、特別な意味をある明示的なメンバ式の中で持ちます、それでそれらはバッククォートでエスケープされることがその文脈においては必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a protocol composition type contains type aliases, it’s possible for the same protocol to appear more than once in the definitions—duplicates are ignored.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロトコル合成型が型エイリアスを含む場合、同じプロトコルが複数回定義の中に現れることが可能です — 重複は無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a protocol type inherits from other protocols, the set of requirements from those other protocols are aggregated together, and any type that inherits from the current protocol must conform to all of those requirements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル型が他のプロトコルから継承するとき、それらの他のプロトコルからの要件ひとそろいは一緒にまとめられます、そして、現在のプロトコルから継承するどんな型でもそれらの要件の全てに準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a protocol type inherits from other protocols, the set of requirements from those other protocols are aggregated, and any type that inherits from the current protocol must conform to all those requirements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるプロトコル型が他のプロトコルから継承するとき、それらの他のプロトコルからの要件一式は、ひとまとめにされます、そして現在のプロトコルから継承するどんな型でも、それらの要件の全てに従わなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a single else clause is present, an &lt;c5&gt;&lt;s6&gt;if&lt;/s6&gt;&lt;/c5&gt; statement has the following form:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ただ１つだけのelse節が含まれている時は、&lt;c5&gt;&lt;s6&gt;if&lt;/s6&gt;&lt;/c5&gt;文は以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a tuple pattern is used as the pattern in a &lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt; statement or in a variable or constant declaration, it can contain only wildcard patterns, identifier patterns, optional patterns, or other tuple patterns that contain those.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タプルパターンが&lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt;文においてまたは変数や定数宣言においてパターンとして使われるとき、それはワイルドカード・パターン、識別子パターン、オプショナルパターン、またはそれらを含む他のタプルパターンだけを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a type alias is declared with generic parameters, the constraints on those parameters must match exactly the constraints on the existing type’s generic parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型エイリアスが総称体パラメータで宣言されるとき、それらのパラメータ上の制約は厳密に既存の型の持つ総称体パラメータ上の制約に一致しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a variable declaration of this form is declared at global scope or the local scope of a function, it is referred to as a &lt;e0&gt;computed variable&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この形式の変数の宣言がグローバルなスコープまたは関数のローカルなスコープで宣言されるとき、それは&lt;e0&gt;計算変数&lt;/e0&gt;と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a variable declaration of this form is declared at global scope or the local scope of a function, it is referred to as a &lt;e0&gt;stored variable&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この形式の変数の宣言がグローバルなスコープまたは関数のローカルなスコープで宣言されるとき、それは&lt;e0&gt;格納変数&lt;/e0&gt;と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a variable declaration of this form is declared at global scope or the local scope of a function, the observers are referred to as &lt;e0&gt;stored variable observers&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この形式の変数の宣言がグローバルなスコープまたは関数のローカルスコープで宣言されるとき、オブザーバーは&lt;e0&gt;格納変数オブザーバー&lt;/e0&gt;と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When accessing the elements in a multidimensional array, the left-most subscript index refers to the element at that index in the outermost array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>多次元配列の要素にアクセスするとき、最も左の添え字インデックスは、最も外側の配列の中のそのインデックスでの要素に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When alternative productions are too long to read easily, they are broken into multiple grammar production rules on new lines.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>代替の導出が簡単に読むにはあまりに長いとき、それらが新しい行で複数部分の文法導出規則へとばらされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an element of a tuple type has a name, that name is part of the type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるタプル型の要素が名前を持つ場合、その名前は型の一部です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an error is thrown, some surrounding piece of code must be responsible for handling the error—for example, by correcting the problem, trying an alternative approach, or informing the user of the failure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるエラーがスローされるとき、なかには周囲のコード部分がエラーを処理することに対して責任を持たなければならないこともあります ― 例えば、問題を訂正すること、代わりの取り組みを試みること、または失敗をユーザに知らせることによって。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an instance of a value type is marked as a constant, so are all of its properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値型のインスタンスが定数として印される時は、そのプロパティの全てがそうです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When considered in isolation, the nested &lt;c0&gt;&lt;s1&gt;incrementer()&lt;/s1&gt;&lt;/c0&gt; function might seem unusual:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>切り離して考えたとき、入れ子にされた&lt;c0&gt;&lt;s1&gt;incrementer()&lt;/s1&gt;&lt;/c0&gt;関数は普通でないものに見えるかもしれません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When creating a selector for a property’s getter, the &lt;e0&gt;property name&lt;/e0&gt; can be a reference to a variable or constant property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロパティのゲッターのためのセレクタを作成するとき、&lt;e0&gt;property name&lt;/e0&gt;は変数または定数プロパティへの参照であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When defining a class, the name of the superclass must appear first in the list of type identifiers, followed by any number of protocols the class must conform to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クラスを定義するとき、スーパークラスの名前は型識別子のリストにおいて最初に現れなければなりません、そしてそのクラスが準拠しなければならないいくらかのプロトコルが続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When defining a protocol, it’s sometimes useful to declare one or more associated types as part of the protocol’s definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルを定義するとき、時々役に立つのは、プロトコルの定義の一部として１つ以上の関連型を宣言することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When it is declared in the context of a class or structure declaration, it is referred to as a &lt;e1&gt;stored variable property&lt;/e1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それがクラスまたは構造体宣言の文脈において宣言されるとき、それは&lt;e1&gt;格納変数プロパティ&lt;/e1&gt;と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When it is declared in the context of a class or structure declaration, the observers are referred to as &lt;e1&gt;property observers&lt;/e1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それがクラスまたは構造体宣言の文脈において宣言されるとき、オブザーバーは&lt;e1&gt;プロパティオブザーバー&lt;/e1&gt;と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When it is declared in the context of a class, structure, or extension declaration, it is referred to as a &lt;e1&gt;computed property&lt;/e1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それがクラス、構造体、または拡張宣言の文脈において宣言されるとき、それは&lt;e1&gt;計算プロパティ&lt;/e1&gt;と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When it isn’t appropriate to provide a &lt;c0&gt;&lt;s1&gt;case&lt;/s1&gt;&lt;/c0&gt; for every enumeration case, you can provide a &lt;c2&gt;&lt;s3&gt;default&lt;/s3&gt;&lt;/c2&gt; case to cover any cases that aren’t addressed explicitly:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべての列挙ケース節に&lt;c0&gt;&lt;s1&gt;case&lt;/s1&gt;&lt;/c0&gt;を提供することが妥当でないとき、あなたは明確に指定されないあらゆる場合を扱うために&lt;c2&gt;&lt;s3&gt;default&lt;/s3&gt;&lt;/c2&gt;ケース節を提供することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When one class inherits from another, the inheriting class is known as a &lt;e1&gt;subclass&lt;/e1&gt;, and the class it inherits from is known as its &lt;e2&gt;superclass&lt;/e2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるクラスが他のものから継承するとき、継承を受けているクラスは&lt;e1&gt;サブクラス&lt;/e1&gt;として知られています、そして、そこからそれが譲り受ける原点のクラスは、それの&lt;e2&gt;スーパークラス&lt;/e2&gt;として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When set to &lt;c1&gt;&lt;s2&gt;true&lt;/s2&gt;&lt;/c1&gt;, an operator in the corresponding precedence group uses the same grouping rules during optional chaining as the assignment operators from the standard library.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c1&gt;&lt;s2&gt;true&lt;/s2&gt;&lt;/c1&gt;に設定する場合、対応する優先順位グループの演算子は標準ライブラリ由来のassignment（割り当て）演算子と同じグループ化規則をオプショナル連鎖の間に使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When specifying the type annotation for a literal value, the annotation’s type must be a type that can be instantiated from that literal value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるリテラル値に型注釈を指定するとき、その注釈の型は、そのリテラル値からインスタンス化されることができる型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When strings are used for raw values, the implicit value for each case is the text of that case’s name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列が生の値のために使われる時、各ケース節のための暗黙的な値は、そのケース節の名前のテキストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When switching over a nonfrozen enumeration value, you always need to include a default case, even if every case of the enumeration already has a corresponding switch case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>非凍結列挙値に対してスイッチしている時、あなたは常にdefaultケース節を含む必要があります、たとえ列挙のあらゆるケース節が既に対応するスイッチケース節を持つとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When that case is matched by the &lt;c6&gt;&lt;s7&gt;switch&lt;/s7&gt;&lt;/c6&gt; statement, the &lt;c8&gt;&lt;s9&gt;break&lt;/s9&gt;&lt;/c8&gt; statement inside the case ends the &lt;c10&gt;&lt;s11&gt;switch&lt;/s11&gt;&lt;/c10&gt; statement’s execution immediately.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのケース節が&lt;c6&gt;&lt;s7&gt;switch&lt;/s7&gt;&lt;/c6&gt;文によってマッチされるとき、ケース節の内側の&lt;c8&gt;&lt;s9&gt;break&lt;/s9&gt;&lt;/c8&gt;文は直ちに&lt;c10&gt;&lt;s11&gt;switch&lt;/s11&gt;&lt;/c10&gt;文の実行を終えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the &lt;c20&gt;&lt;s21&gt;log()&lt;/s21&gt;&lt;/c20&gt; method is called on &lt;c22&gt;&lt;s23&gt;oneAndTwo&lt;/s23&gt;&lt;/c22&gt; directly, the specialized version containing the title string is used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c20&gt;&lt;s21&gt;log()&lt;/s21&gt;&lt;/c20&gt;メソッドが&lt;c22&gt;&lt;s23&gt;oneAndTwo&lt;/s23&gt;&lt;/c22&gt;において直接に呼び出される時、タイトル文字列を含んでいる特殊化版が使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the audio level is &lt;c2&gt;&lt;s3&gt;10&lt;/s3&gt;&lt;/c2&gt;, all of the lights for that channel are lit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>音声のレベルが&lt;c2&gt;&lt;s3&gt;10&lt;/s3&gt;&lt;/c2&gt;であるとき、そのチャンネルのための光の全ては点灯されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the compiler isn’t in library evolution mode, all structures and enumerations are implicitly frozen, and this attribute is ignored.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コンパイラがライブラリ進化モードではない場合、全ての構造体と列挙は暗黙的に凍結されます、そしてこの属性は無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the enumeration type can be inferred from context, you can omit it (the dot is still required), as described in &lt;a4&gt;&lt;s5&gt;Enumeration Syntax&lt;/s5&gt;&lt;/a4&gt; and &lt;a6&gt;&lt;s7&gt;Implicit Member Expression&lt;/s7&gt;&lt;/a6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>列挙型が前後関係から推論されることができるとき、&lt;a4&gt;&lt;s5&gt;列挙構文&lt;/s5&gt;&lt;/a4&gt;と&lt;a6&gt;&lt;s7&gt;暗黙のメンバー式&lt;/s7&gt;&lt;/a6&gt;で記述されるように、あなたはそれを省略することができます（ドットは依然必要です）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the expression on the left-hand side of a binary operator is marked with &lt;c0&gt;&lt;s1&gt;try&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;try?&lt;/s3&gt;&lt;/c2&gt;, or &lt;c4&gt;&lt;s5&gt;try!&lt;/s5&gt;&lt;/c4&gt;, that operator applies to the whole binary expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある二項演算子の左手側での式が&lt;c0&gt;&lt;s1&gt;try&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;try?&lt;/s3&gt;&lt;/c2&gt;、または&lt;c4&gt;&lt;s5&gt;try!&lt;/s5&gt;&lt;/c4&gt;で印される場合、その演算子は二項式全体に適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the function is called, the value of the argument is copied.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数が呼ばれる時、その引数の値はコピー（複製）をつくられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the function returns, the copy’s value is assigned to the original argument.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数が戻る時、コピーの値はそのオリジナルの（元の）引数に代入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the match succeeds, the value &lt;c0&gt;&lt;s1&gt;42&lt;/s1&gt;&lt;/c0&gt; is bound (assigned) to the constant name &lt;c2&gt;&lt;s3&gt;someValue&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>マッチが成功するとき、値&lt;c0&gt;&lt;s1&gt;42&lt;/s1&gt;&lt;/c0&gt;は、定数の名前の&lt;c2&gt;&lt;s3&gt;someValue&lt;/s3&gt;&lt;/c2&gt;に縛りつけられます（代入されます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the pattern on the left-hand side of a variable or constant declaration is an identifier pattern, the identifier pattern is implicitly a subpattern of a value-binding pattern.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>変数や定数宣言の左側のパターンが識別子パターンであるとき、その識別子パターンは暗黙のうちに値束縛パターンの下位パターンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the second function is called, the message is still printed by the first function, but the returned value is not used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>第二の関数が呼ばれるとき、メッセージは最初の関数によって依然として出力されます、しかし返された値は使われません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When this detailed form is used, only the imported symbol (and not the module that declares it) is made available in the current scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この詳細な書式が使われるとき、インポートされたシンボルだけが（そしてそれを宣言するモジュールでなく）、現在のスコープにおいて利用可能にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When this simply isn’t feasible (for example, when the control expression’s type is &lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt;), you can include a default case to satisfy the requirement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これが単に実行可能でないとき（たとえば、制御式のもつ型が&lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt;であるとき）、あなたはこの必要条件を満たすために省略時のケース節を含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When two operators compete with each other for their operands, such as in the expression &lt;c4&gt;&lt;s5&gt;2&lt;/s5&gt; &lt;s6&gt;+&lt;/s6&gt; &lt;s7&gt;3&lt;/s7&gt; &lt;s8&gt;*&lt;/s8&gt; &lt;s9&gt;5&lt;/s9&gt;&lt;/c4&gt;, the operator with the higher relative precedence binds more tightly to its operands.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>２つの演算子がそれらの演算数に対して互いと比較される時、例えば式&lt;c4&gt;&lt;s5&gt;2&lt;/s5&gt; &lt;s6&gt;+&lt;/s6&gt; &lt;s7&gt;3&lt;/s7&gt; &lt;s8&gt;*&lt;/s8&gt; &lt;s9&gt;5&lt;/s9&gt;&lt;/c4&gt;などで、より高い関係優先順位を持つ演算子はよりきつくそれの演算数に束縛されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When used as the default value of a function or method parameter, the special literal’s value is determined when the default value expression is evaluated at the call site.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数およびメソッドのパラメータの省略時の値として使われる時、特殊リテラルの値は、省略時値式が呼び出し現場で評価される場合は決定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When used inside a &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; statement, &lt;c2&gt;&lt;s3&gt;break&lt;/s3&gt;&lt;/c2&gt; causes the &lt;c4&gt;&lt;s5&gt;switch&lt;/s5&gt;&lt;/c4&gt; statement to end its execution immediately and to transfer control to the code after the &lt;c6&gt;&lt;s7&gt;switch&lt;/s7&gt;&lt;/c6&gt; statement’s closing brace (&lt;c8&gt;&lt;s9&gt;}&lt;/s9&gt;&lt;/c8&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;文の中に使われるとき、&lt;c2&gt;&lt;s3&gt;break&lt;/s3&gt;&lt;/c2&gt;によって&lt;c4&gt;&lt;s5&gt;switch&lt;/s5&gt;&lt;/c4&gt;文が直ちにその実行を終えて、&lt;c6&gt;&lt;s7&gt;switch&lt;/s7&gt;&lt;/c6&gt;文の閉じ波括弧（&lt;c8&gt;&lt;s9&gt;}&lt;/s9&gt;&lt;/c8&gt;）の後のコードへ制御を移します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When used inside a loop statement, &lt;c0&gt;&lt;s1&gt;break&lt;/s1&gt;&lt;/c0&gt; ends the loop’s execution immediately and transfers control to the code after the loop’s closing brace (&lt;c2&gt;&lt;s3&gt;}&lt;/s3&gt;&lt;/c2&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ループ文の内側で使われるとき、&lt;c0&gt;&lt;s1&gt;break&lt;/s1&gt;&lt;/c0&gt;は直ちにループの実行を終えて、ループの閉じ波括弧（&lt;c2&gt;&lt;s3&gt;}&lt;/s3&gt;&lt;/c2&gt;）の後のコードへ制御を移します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When working with optional values, you can write &lt;c0&gt;&lt;s1&gt;?&lt;/s1&gt;&lt;/c0&gt; before operations like methods, properties, and subscripting.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルの値を扱うとき、あなたはメソッド、プロパティ、そして添え字指定のような演算の前に&lt;c0&gt;&lt;s1&gt;?&lt;/s1&gt;&lt;/c0&gt;を書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you access a projected value from code that’s part of the type, like a property getter or an instance method, you can omit &lt;c0&gt;&lt;s1&gt;self.&lt;/s1&gt;&lt;/c0&gt; before the property name, just like accessing other properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある予測値に、プロパティゲッターやインスタンスメソッドのようなその型の一部であるコードからアクセスする場合、あなたは&lt;c0&gt;&lt;s1&gt;self.&lt;/s1&gt;&lt;/c0&gt;をプロパティ名の前で省略できます、ちょうど他のプロパティにアクセスするように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you access a subscript on an optional value through optional chaining, you place the question mark &lt;e0&gt;before&lt;/e0&gt; the subscript’s brackets, not after.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがオプショナル連鎖を通してオプショナルの値の上で添え字にアクセスするとき、あなたは添え字の角括弧の&lt;e0&gt;前に&lt;/e0&gt;疑問符を置きます、後ろではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you apply a wrapper to a property and you don’t specify an initial value, Swift uses the &lt;c0&gt;&lt;s1&gt;init()&lt;/s1&gt;&lt;/c0&gt; initializer to set up the wrapper.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがラッパーをプロパティに適用するそしてあなたが初期値を指定しないならば、スウィフトは&lt;c0&gt;&lt;s1&gt;init()&lt;/s1&gt;&lt;/c0&gt;イニシャライザを使ってラッパーを準備します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you apply a wrapper to a property, the compiler synthesizes code that provides storage for the wrapper and code that provides access to the property through the wrapper.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがあるラッパーをプロパティに適用する場合、コンパイラは、そのラッパーに対するストレージを提供するコードそしてそのラッパーに通してプロパティへのアクセスを提供するコードを合成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you apply this attribute to a type, you create a custom attribute with the same name as the type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがこの属性をある型に適用する場合、あなたはあるあつらえの属性をその型と同じ名前で作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you assign a closure to a property, you are assigning a &lt;e1&gt;reference&lt;/e1&gt; to that closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがクロージャをプロパティに代入するとき、あなたは&lt;e1&gt;参照&lt;/e1&gt;をそのクロージャに代入しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you assign a default value to a stored property, or set its initial value within an initializer, the value of that property is set directly, without calling any property observers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある格納プロパティに省略時の値を代入する、またはその初期値をイニシャライザの内部で設定するとき、そのプロパティの値は、どんなプロパティオブザーバーも呼び出すことなく、直接に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you call a function that can throw an error, you prepend the &lt;c2&gt;&lt;s3&gt;try&lt;/s3&gt;&lt;/c2&gt; keyword to the expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがエラーをスローできる関数を呼ぶとき、あなたは&lt;c2&gt;&lt;s3&gt;try&lt;/s3&gt;&lt;/c2&gt;キーワードをその式の前に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you call a memberwise initializer, you can omit values for any properties that have default values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがメンバー関連イニシャライザを呼び出す場合、あなたは省略時の値を持つあらゆるプロパティに対して値を省略できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you call an overloaded generic function or initializer, the compiler uses these constraints to resolve which overloaded function or initializer to invoke.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがオーバーロードされた総称体関数またはイニシャライザを呼ぶとき、コンパイラはこれらの制約を使って、呼び出すことになるオーバーロードされた関数またはイニシャライザはどれか決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you declare a call-as-function method, you specify the number of arguments, and each argument’s type and label.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがcall-as-functionメソッドを宣言する場合、あなたは引数の数、そして各引数のもつ型およびラベルを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you declare a function that takes a closure as one of its parameters, you can write &lt;c1&gt;&lt;s2&gt;@escaping&lt;/s2&gt;&lt;/c1&gt; before the parameter’s type to indicate that the closure is allowed to escape.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある関数、それのパラメータの１つとしてクロージャをとるものを宣言する時、あなたは&lt;c1&gt;&lt;s2&gt;@escaping&lt;/s2&gt;&lt;/c1&gt;をパラメータの型の前に書くことによって、そのクロージャが脱出を許可されるのを指し示すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you declare a generic type, function, subscript, or initializer, you specify the type parameters that the generic type, function, or initializer can work with.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある総称体型、添え字、関数、またはイニシャライザを宣言するとき、あなたはその総称体型、関数、またはイニシャライザが扱うことができる型パラメータを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you define a function, you can optionally define one or more named, typed values that the function takes as input, known as &lt;e0&gt;parameters&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある関数を定義するとき、あなたは随意にその関数が入力としてとる、１つ以上の名前をつけられ型付けされた値、&lt;e0&gt;パラメータ&lt;/e0&gt;として知られるものを定義できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you define a protocol extension, you can specify constraints that conforming types must satisfy before the methods and properties of the extension are available.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがプロトコル拡張を定義するとき、あなたは準拠している型がその拡張のメソッドやプロパティが利用可能になる前に満たさなければならない制約を指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you define your own custom structures and classes, it’s your responsibility to decide what qualifies as two instances being equal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが独自のあつらえのクラスと構造体を定義するとき、２つのインスタンスが等しくなる基準は何かを決めるのはあなたの責任です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you define your own structures, classes, and enumerations, it can be useful to provide your own implementations of the standard Swift operators for these custom types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがあなた自身の構造体、クラス、そして列挙を定義するとき、標準のスウィフト演算子のあなた自身の実施をそれらあつらえの型のために提供することは役に立つことがありえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you develop a framework, mark the public-facing interface to that framework as open or public so that it can be viewed and accessed by other modules, such as an app that imports the framework.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがフレームワークを開発する場合、そのフレームワークを開放または公開するために公開向けインタフェースとして印してください、それで、他のモジュール、例えばそのフレームワークをインポートするアプリによってそれが見られてアクセスされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you do so, you must mark the overridden subscript declaration with the &lt;c2&gt;&lt;s3&gt;override&lt;/s3&gt;&lt;/c2&gt; declaration modifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがそうするとき、あなたはオーバーライドされる添え字宣言を&lt;c2&gt;&lt;s3&gt;override&lt;/s3&gt;&lt;/c2&gt;宣言修飾子で印しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you don’t, Swift automatically assigns the values for you.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがそうしない時は、スウィフトはあなたの代わりに自動的に値を割り当てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you extend a generic type, you don’t provide a type parameter list as part of the extension’s definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある総称体型を拡張する時、あなたは型パラメーターリストを拡張の定義の一部として提供しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you get a substring from a string—for example, using a subscript or a method like &lt;c0&gt;&lt;s1&gt;prefix(_:)&lt;/s1&gt;&lt;/c0&gt;—the result is an instance of &lt;a2&gt;&lt;c3&gt;&lt;s4&gt;Substring&lt;/s4&gt;&lt;/c3&gt;&lt;/a2&gt;&lt;s5&gt; [https://developer.apple.com/documentation/swift/substring]&lt;/s5&gt;, not another string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある文字列から下位文字列を得る場合 — 例えば、添え字または&lt;c0&gt;&lt;s1&gt;prefix(_:)&lt;/s1&gt;&lt;/c0&gt;のようなメソッドを使って — その結果は&lt;a2&gt;&lt;c3&gt;&lt;s4&gt;Substring&lt;/s4&gt;&lt;/c3&gt;&lt;/a2&gt;&lt;s5&gt; [https://developer.apple.com/documentation/swift/substring]&lt;/s5&gt;のインスタンスとなります、別の文字列ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you include property wrapper arguments, you can also specify an initial value using assignment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがプロパティラッパー引数を含める場合、あなたはまた代入を使って初期値を指定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you make a copy of &lt;c0&gt;&lt;s1&gt;stepSize&lt;/s1&gt;&lt;/c0&gt; before calling &lt;c2&gt;&lt;s3&gt;increment(_:)&lt;/s3&gt;&lt;/c2&gt;, it’s clear that the value of &lt;c4&gt;&lt;s5&gt;copyOfStepSize&lt;/s5&gt;&lt;/c4&gt; is incremented by the current step size.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが&lt;c0&gt;&lt;s1&gt;stepSize&lt;/s1&gt;&lt;/c0&gt;のコピーを&lt;c2&gt;&lt;s3&gt;increment(_:)&lt;/s3&gt;&lt;/c2&gt;を呼び出す前に作る場合、それは&lt;c4&gt;&lt;s5&gt;copyOfStepSize&lt;/s5&gt;&lt;/c4&gt;の値が現在の段階量だけ漸増されることを明確にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you mark a member declaration with the &lt;c0&gt;&lt;s1&gt;dynamic&lt;/s1&gt;&lt;/c0&gt; modifier, access to that member is always dynamically dispatched using the Objective-C runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがメンバー宣言を&lt;c0&gt;&lt;s1&gt;dynamic&lt;/s1&gt;&lt;/c0&gt;修飾子で印する時は、そのメンバーへのアクセスは、常に動的にObjective-Cランタイムを使用してディスパッチされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you provide a method, property, or subscript override for a subclass, it is sometimes useful to use the existing superclass implementation as part of your override.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがサブクラスのためにメソッド、プロパティ、または添え字のオーバーライドを提供する時、既存のスーパークラスの実装をあなたのオーバーライドの一部として使うことは時々役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you specify an initial value for the property, Swift uses the &lt;c0&gt;&lt;s1&gt;init(wrappedValue:)&lt;/s1&gt;&lt;/c0&gt; initializer to set up the wrapper.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが初期値をプロパティに対して指定する場合、スウィフトは&lt;c0&gt;&lt;s1&gt;init(wrappedValue:)&lt;/s1&gt;&lt;/c0&gt;イニシャライザを使ってラッパーを準備します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you use Xcode 11.4 to build Swift 4 and Swift 4.2 code, most Swift 5.2 functionality is available.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがXcode 11.4を使ってSwift 4とSwift 4.2コードをビルドする場合、ほとんどのSwift 5.2機能性が利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you use a key-path string expression within a class, you can refer to a property of that class by writing just the property name, without the class name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがキーパス文字列式をあるクラス内で使う時、あなたはそのクラスのプロパティを参照することが、クラス名なしで単にそのプロパティ名を書くことによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you use a method or property in an optional requirement, its type automatically becomes an optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがオプショナルの要件の中のメソッドやプロパティを使うとき、それの型は自動的にオプショナルになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you use a property wrapper, you write the management code once when you define the wrapper, and then reuse that management code by applying it to multiple properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがプロパティラッパーを使う場合、あなたは管理コードを一度だけあなたがラッパーを定義する時に書きます、そしてそれからその管理コードを、それを複数のプロパティに適用することによって再利用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you use an implicitly unwrapped optional value, Swift first tries to use it as an ordinary optional value; if it can’t be used as an optional, Swift force-unwraps the value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある暗黙的にアンラップされるオプショナル値を使う場合、Swiftはまずそれを普通のオプショナル値として使おうと試みます；それがオプショナルとして使用できないならば、Swiftは値を強制アンラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you use subscript syntax, the index you specify needs to be valid.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが添え字構文を使う時、あなたが指定するインデックスは有効である必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you use the trailing closure syntax, you don’t write the argument label for the closure as part of the function call.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが後付クロージャ構文を使うとき、あなたは引数ラベルをそのクロージャに対して関数呼び出しの一部として書きません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you work with values whose type is a protocol type, methods outside the protocol definition are not available.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その型があるプロトコル型である値をあなたが扱うとき、そのプロトコル定義の外部のメソッドは利用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you write &lt;c0&gt;&lt;s1&gt;=&lt;/s1&gt; &lt;s2&gt;1&lt;/s2&gt;&lt;/c0&gt; on a property with a wrapper, that’s translated into a call to the &lt;c3&gt;&lt;s4&gt;init(wrappedValue:)&lt;/s4&gt;&lt;/c3&gt; initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが&lt;c0&gt;&lt;s1&gt;=&lt;/s1&gt; &lt;s2&gt;1&lt;/s2&gt;&lt;/c0&gt;をラッパーをもつプロパティ上で記述する場合、それは&lt;c3&gt;&lt;s4&gt;init(wrappedValue:)&lt;/s4&gt;&lt;/c3&gt;イニシャライザへの呼び出しに変換されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you write a simple single-target app, the code in your app is typically self-contained within the app and doesn’t need to be made available outside of the app’s module.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが単純な単一ターゲットアプリを書いている場合、あなたのアプリのコードは概してそのアプリの内部に自身で持っていて、そしてそのアプリのモジュールの外側で利用可能にされることは必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you write a subclass initializer that matches a superclass &lt;e0&gt;designated&lt;/e0&gt; initializer, you are effectively providing an override of that designated initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがスーパークラスの&lt;e0&gt;指定&lt;/e0&gt;イニシャライザと一致するあるサブクラス・イニシャライザを書く時、あなたは事実上その指定イニシャライザのオーバーライドを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you write an app with a unit test target, the code in your app needs to be made available to that module in order to be tested.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがユニットテストターゲットを使ってアプリを書く場合、あなたのアプリのコードはテストされるためにそのモジュールに対して利用可能にされる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you write arguments in parentheses after the custom attribute, Swift uses the initializer that accepts those arguments to set up the wrapper.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが引数を丸括弧の中であつらえの属性の後に書く場合、スウィフトはそれらの引数を受け入れるイニシャライザを使ってそのラッパーを準備します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you write or extend a type to conform to a protocol, you must ensure that the type’s implementation of each protocol requirement has at least the same access level as the type’s conformance to that protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがある型をプロトコルに準拠するように書く、または拡張する時は、あなたはその型のもつ各プロトコル要件の実装が少なくともそのプロトコルに対するその型の準拠と同じアクセス水準を持つことを確かにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you write the name of a generic superclass class after the colon, you must include the full name of that generic class, including its generic parameter clause.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがコロンの後に総称体スーパークラスの名前を書く時、あなたはその総称体クラスの名前全体を、それの総称体パラメーター節を含めて書く必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When your source code includes a line break inside of a multiline string literal, that line break also appears in the string’s value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのソースコードがある複数行文字列リテラルの内部に改行を含む場合、その改行はまたその文字列の持つ値の中に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you’re ready to store the result for a longer time, you convert the substring to an instance of &lt;c6&gt;&lt;s7&gt;String&lt;/s7&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが結果を長期間にわたって格納しようとする場合、あなたは下位文字列を&lt;c6&gt;&lt;s7&gt;String&lt;/s7&gt;&lt;/c6&gt;のインスタンスへと変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you’re working with enumerations that store integer or string raw values, you don’t have to explicitly assign a raw value for each case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが整数や文字列の生の値を格納する列挙を使って作業している時、あなたは各ケース節に生の値を明示的に割り当てる必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever a new &lt;c0&gt;&lt;s1&gt;Chessboard&lt;/s1&gt;&lt;/c0&gt; instance is created, the closure is executed, and the default value of &lt;c2&gt;&lt;s3&gt;boardColors&lt;/s3&gt;&lt;/c2&gt; is calculated and returned.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい&lt;c0&gt;&lt;s1&gt;Chessboard&lt;/s1&gt;&lt;/c0&gt;インスタンスがつくられるときはいつでも、このクロージャは実行されます、そして&lt;c2&gt;&lt;s3&gt;boardColors&lt;/s3&gt;&lt;/c2&gt;の省略時の値が計算されて、返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever a new instance of the type that the property belongs to is initialized, the closure or function is called, and its return value is assigned as the property’s default value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのプロパティが属している型の新しいインスタンスが初期化されるときはいつでも、そのクロージャまたは関数が呼ばれます、そしてその戻り値はプロパティの省略時の値として代入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever an object in the array conforms to the &lt;c0&gt;&lt;s1&gt;HasArea&lt;/s1&gt;&lt;/c0&gt; protocol, the optional value returned by the &lt;c2&gt;&lt;s3&gt;as?&lt;/s3&gt;&lt;/c2&gt; operator is unwrapped with optional binding into a constant called &lt;c4&gt;&lt;s5&gt;objectWithArea&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>配列のオブジェクトが&lt;c0&gt;&lt;s1&gt;HasArea&lt;/s1&gt;&lt;/c0&gt;プロトコルに準拠するときはいつでも、&lt;c2&gt;&lt;s3&gt;as?&lt;/s3&gt;&lt;/c2&gt;演算子によって返されるオプショナルの値は、オプショナル束縛によって&lt;c4&gt;&lt;s5&gt;objectWithArea&lt;/s5&gt;&lt;/c4&gt;と呼ばれる定数へとアンラップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever this return value equals &lt;c8&gt;&lt;s9&gt;7&lt;/s9&gt;&lt;/c8&gt;, the dice roll has become too large and is reset to a value of &lt;c10&gt;&lt;s11&gt;1&lt;/s11&gt;&lt;/c10&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この戻り値が&lt;c8&gt;&lt;s9&gt;7&lt;/s9&gt;&lt;/c8&gt;に等しいときはいつでも、そのさいころの目は大きくなり過ぎているので、値&lt;c10&gt;&lt;s11&gt;1&lt;/s11&gt;&lt;/c10&gt;へ設定し直されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever you assign a function or a closure to a constant or a variable, you are actually setting that constant or variable to be a &lt;e0&gt;reference&lt;/e0&gt; to the function or closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが関数やクロージャを定数または変数に代入するときはいつでも、あなたは実際はその定数または変数が関数やクロージャへの&lt;e0&gt;参照&lt;/e0&gt;であると設定しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever you define a new structure or class, you define a new Swift type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが新しいクラスまたは構造体を定義するときはいつでも、あなたはある新しいスウィフト型を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever you set the &lt;c0&gt;&lt;s1&gt;currentSpeed&lt;/s1&gt;&lt;/c0&gt; property of an &lt;c2&gt;&lt;s3&gt;AutomaticCar&lt;/s3&gt;&lt;/c2&gt; instance, the property’s &lt;c4&gt;&lt;s5&gt;didSet&lt;/s5&gt;&lt;/c4&gt; observer sets the instance’s &lt;c6&gt;&lt;s7&gt;gear&lt;/s7&gt;&lt;/c6&gt; property to an appropriate choice of gear for the new speed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが&lt;c2&gt;&lt;s3&gt;AutomaticCar&lt;/s3&gt;&lt;/c2&gt;インスタンスの&lt;c0&gt;&lt;s1&gt;currentSpeed&lt;/s1&gt;&lt;/c0&gt;プロパティを設定したときはいつでも、そのプロパティの&lt;c4&gt;&lt;s5&gt;didSet&lt;/s5&gt;&lt;/c4&gt;オブザーバーは、そのインスタンスの&lt;c6&gt;&lt;s7&gt;gear&lt;/s7&gt;&lt;/c6&gt;プロパティを新しい速度のために適切な選択に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Where this is appropriate, you access the superclass version of a method, property, or subscript by using the &lt;c0&gt;&lt;s1&gt;super&lt;/s1&gt;&lt;/c0&gt; prefix:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これがふさわしい所で、あなたは&lt;c0&gt;&lt;s1&gt;super&lt;/s1&gt;&lt;/c0&gt;接頭辞を使用することによってスーパークラス版のメソッド、プロパティ、または添え字にアクセスします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Where you believe this is the case, you can try to &lt;e0&gt;downcast&lt;/e0&gt; to the subclass type with a &lt;e1&gt;type cast operator&lt;/e1&gt; (&lt;c2&gt;&lt;s3&gt;as?&lt;/s3&gt;&lt;/c2&gt; or &lt;c4&gt;&lt;s5&gt;as!&lt;/s5&gt;&lt;/c4&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがこの場合であると思う所で、あなたはサブクラス型への&lt;e0&gt;ダウンキャスト&lt;/e0&gt;を試みることが&lt;e1&gt;型キャスト演算子&lt;/e1&gt;（&lt;c2&gt;&lt;s3&gt;as?&lt;/s3&gt;&lt;/c2&gt;または&lt;c4&gt;&lt;s5&gt;as!&lt;/s5&gt;&lt;/c4&gt;）を使ってできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Wherever you use &lt;c4&gt;&lt;s5&gt;tenEighty&lt;/s5&gt;&lt;/c4&gt;, you also have to think about the code that uses &lt;c6&gt;&lt;s7&gt;alsoTenEighty&lt;/s7&gt;&lt;/c6&gt;, and vice versa.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが&lt;c4&gt;&lt;s5&gt;tenEighty&lt;/s5&gt;&lt;/c4&gt;を使うどこであれ、あなたはまた&lt;c6&gt;&lt;s7&gt;alsoTenEighty&lt;/s7&gt;&lt;/c6&gt;を使うコードについて頭を働かせなければなりません、そして逆もまた同様に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初に評価</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While Loops</seg>
      </tuv>
      <tuv lang="JA">
        <seg>whileループ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While Statement</seg>
      </tuv>
      <tuv lang="JA">
        <seg>while文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While it is most common for a subscript to take a single parameter, you can also define a subscript with multiple parameters if it is appropriate for your type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>添え字がただ１つのパラメータをとることが最も普通であるけれども、あなたはまた、それがあなたの型に適切ならば、複数のパラメータをもつ添え字を定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While you’re adding items to the budget, it’s in a temporary, invalid state because the total amount hasn’t been updated to reflect the newly added items.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが項目を予算案に加えている間、それは一時的な、無効な状態にあります、なぜなら総支出額は新しく追加された項目を反映するよう更新されていないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whitespace and Comments</seg>
      </tuv>
      <tuv lang="JA">
        <seg>空白とコメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whitespace has two uses: to separate tokens in the source file and to help determine whether an operator is a prefix or postfix (see &lt;a0&gt;&lt;s1&gt;Operators&lt;/s1&gt;&lt;/a0&gt;), but is otherwise ignored.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>空白には、２つの用途があります：ソース・ファイルの中のトークンを切り離すため、そして、演算子が接頭辞か接尾辞であるかについて決定することを手伝います（&lt;a0&gt;&lt;s1&gt;演算子&lt;/s1&gt;&lt;/a0&gt;を見てください）、それ以外では無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Wildcard Expression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ワイルドカード式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Wildcard Pattern</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ワイルドカード・パターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With a conditional statement, you can use a statement label with the &lt;c1&gt;&lt;s2&gt;break&lt;/s2&gt;&lt;/c1&gt; statement to end the execution of the labeled statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>条件文では、あなたは文ラベルを&lt;c1&gt;&lt;s2&gt;break&lt;/s2&gt;&lt;/c1&gt;文とともに使うことで、ラベルをつけられた文の実行を終えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With a few exceptions, a function of any calling convention can be used when a function any other calling convention is needed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>2、3の例外がありますが、何らかの呼出規約の関数は、何らかの他の呼出規約の関数が必要とされる場合に使用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With a loop statement, you can use a statement label with the &lt;c3&gt;&lt;s4&gt;break&lt;/s4&gt;&lt;/c3&gt; or &lt;c5&gt;&lt;s6&gt;continue&lt;/s6&gt;&lt;/c5&gt; statement to end or continue the execution of the labeled statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ループ文では、あなたは文ラベルを&lt;c3&gt;&lt;s4&gt;break&lt;/s4&gt;&lt;/c3&gt;または&lt;c5&gt;&lt;s6&gt;continue&lt;/s6&gt;&lt;/c5&gt;文とともに使うことで、ラベルをつけられた文の実行を終えたり継続したりすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With an optional tuple type, the entire tuple is optional, not just each individual value within the tuple.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルタプル型では、タプル全体がオプショナルです、単にタプルの内部の個々の値それぞれではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With the exception of the implicit unwrapping behavior, the following two declarations are equivalent:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗黙的にアンラップされる挙動を除けば、以下の２つの宣言は等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With those settings, the following code prints all three messages:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの設定で、以下のコードは３つのメッセージすべてを出力します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within a function, don’t access a value that was passed as an in-out argument, even if the original value is available in the current scope.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関数内部で、in-out引数として渡された値にアクセスしないでください、たとえその元の値が現在のスコープにおいて利用可能であるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within the body of a type method, the implicit &lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt; property refers to the type itself, rather than an instance of that type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある型メソッドの本文内で、暗黙の&lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;プロパティはその型自身に言及します、その型のインスタンスではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within the method, both &lt;c4&gt;&lt;s5&gt;self&lt;/s5&gt;&lt;/c4&gt; and &lt;c6&gt;&lt;s7&gt;teammate&lt;/s7&gt;&lt;/c6&gt; refer to the same location in memory—as shown in the figure below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メソッド内部で、&lt;c4&gt;&lt;s5&gt;self&lt;/s5&gt;&lt;/c4&gt;および&lt;c6&gt;&lt;s7&gt;teammate&lt;/s7&gt;&lt;/c6&gt;の両方がメモリ中の同じ位置を参照します — 下の図で示すように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without the &lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt; prefix, Swift would assume that both uses of &lt;c2&gt;&lt;s3&gt;x&lt;/s3&gt;&lt;/c2&gt; referred to the method parameter called &lt;c4&gt;&lt;s5&gt;x&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;接頭辞なしでは、スウィフトは両方の&lt;c2&gt;&lt;s3&gt;x&lt;/s3&gt;&lt;/c2&gt;の使用が&lt;c4&gt;&lt;s5&gt;x&lt;/s5&gt;&lt;/c4&gt;と呼ばれるメソッドパラメータに言及したものと仮定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without the extension to explicitly declare conditional conformance to &lt;c0&gt;&lt;s1&gt;Loggable&lt;/s1&gt;&lt;/c0&gt;, the other &lt;c2&gt;&lt;s3&gt;Array&lt;/s3&gt;&lt;/c2&gt; extensions would implicitly create these declarations, resulting in an error:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張が&lt;c0&gt;&lt;s1&gt;Loggable&lt;/s1&gt;&lt;/c0&gt;への条件準拠を明示的に宣言することなしには、他の&lt;c2&gt;&lt;s3&gt;Array&lt;/s3&gt;&lt;/c2&gt;拡張は、結果としてエラーになるこれら宣言を暗黙的に作成するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without this conversion in place, the addition would not be allowed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>適切なこの変換なしでは、この加算は許されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without this requirement, &lt;c7&gt;&lt;s8&gt;Dictionary&lt;/s8&gt;&lt;/c7&gt; could not tell whether it should insert or replace a value for a particular key, nor would it be able to find a value for a given key that is already in the dictionary.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この要件なしでは、&lt;c7&gt;&lt;s8&gt;Dictionary&lt;/s8&gt;&lt;/c7&gt;はそれが特定のキーのために値を差し込んだり取り替えたりするべきかどうか伝えることができませんし、それはすでに辞書の中にある指定されたキーに対する値を見つけることもできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without this type alias, the &lt;c0&gt;&lt;s1&gt;sum&lt;/s1&gt;&lt;/c0&gt; function would have to refer to the associated type as &lt;c2&gt;&lt;s3&gt;T.Iterator.Element&lt;/s3&gt;&lt;/c2&gt; instead of &lt;c4&gt;&lt;s5&gt;T.Element&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この型エイリアスな時では、&lt;c0&gt;&lt;s1&gt;sum&lt;/s1&gt;&lt;/c0&gt;関数は関連値を&lt;c2&gt;&lt;s3&gt;T.Iterator.Element&lt;/s3&gt;&lt;/c2&gt;のように参照しなければならないでしょう、&lt;c4&gt;&lt;s5&gt;T.Element&lt;/s5&gt;&lt;/c4&gt;ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Working back down from the top of the chain, each designated initializer in the chain has the option to customize the instance further.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>連鎖の最上部から逆に階層を下って、連鎖の中の各指定イニシャライザは、さらにインスタンスを好みに合わせて作り変える選択肢を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Working with Characters</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字を扱う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Wrap the name in parentheses and escape it with a backslash before the opening parenthesis:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>丸括弧にその名前を包んで、始めの括弧の前のバックスラッシュでそれをエスケープします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Wrapper types like &lt;c0&gt;&lt;s1&gt;JoinedShape&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;FlippedShape&lt;/s3&gt;&lt;/c2&gt; don’t matter to the module’s users, and they shouldn’t be visible.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;JoinedShape&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;FlippedShape&lt;/s3&gt;&lt;/c2&gt;のようなラッパー型は、モジュールのユーザにとって重要ではありません、そしてそれらは可視でないべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Write a custom argument label before the parameter name, or write &lt;c0&gt;&lt;s1&gt;_&lt;/s1&gt;&lt;/c0&gt; to use no argument label.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あつらえの引数ラベルはパラメータ名の前に書いてください、または引数ラベルなしで使うためには&lt;c0&gt;&lt;s1&gt;_&lt;/s1&gt;&lt;/c0&gt;を書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Write a function that compares two &lt;c0&gt;&lt;s1&gt;Rank&lt;/s1&gt;&lt;/c0&gt; values by comparing their raw values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの生の値を比較することによって２つの&lt;c0&gt;&lt;s1&gt;Rank&lt;/s1&gt;&lt;/c0&gt;の値を比較する関数を記述してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Write a function that returns an array containing a full deck of cards, with one card of each combination of rank and suit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ランク（順位）とスート（記号）の各組合せのカード１枚を持つ、カードの完全なデック（一組）を含んでいる配列を返す関数を書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Write a name inside angle brackets to make a generic function or type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>総称体である関数や型を作るためには、その名前を山形括弧の中に書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Write a question mark (&lt;c6&gt;&lt;s7&gt;?&lt;/s7&gt;&lt;/c6&gt;) after the type of a value to mark the value as optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある値がオプショナルであると印するために、その値の型の後に疑問符（&lt;c6&gt;&lt;s7&gt;?&lt;/s7&gt;&lt;/c6&gt;）を書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Write a type annotation by placing a colon after the constant or variable name, followed by a space, followed by the name of the type to use.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定数か変数の名前のあとにコロンを置いて、１つの空白に続き、使用する型の名前を続けることによって型注釈を書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Write an extension for the &lt;c0&gt;&lt;s1&gt;Double&lt;/s1&gt;&lt;/c0&gt; type that adds an &lt;c2&gt;&lt;s3&gt;absoluteValue&lt;/s3&gt;&lt;/c2&gt; property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;Double&lt;/s1&gt;&lt;/c0&gt;型のために拡張をひとつ書いてください、それは&lt;c2&gt;&lt;s3&gt;absoluteValue&lt;/s3&gt;&lt;/c2&gt;プロパティを加えるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Write an optional binding for an &lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt; statement as follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オプショナルの束縛を&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt;文のために次のように書いてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Write an underscore (&lt;c2&gt;&lt;s3&gt;_&lt;/s3&gt;&lt;/c2&gt;) for an argument with no name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>名前のない引数に対しては１つのアンダースコア（&lt;c2&gt;&lt;s3&gt;_&lt;/s3&gt;&lt;/c2&gt;）を書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Write the &lt;c0&gt;&lt;s1&gt;required&lt;/s1&gt;&lt;/c0&gt; modifier before the definition of a class initializer to indicate that every subclass of the class must implement that initializer:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;required&lt;/s1&gt;&lt;/c0&gt;修飾子をクラス・イニシャライザの定義の前に書いて、そのクラスの全てのサブクラスがそのイニシャライザを実装しなければならないことを示してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Write these constraints after the name of the protocol you’re adopting by writing a generic &lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt; clause.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの制約を、あなたが総称体&lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt;節を書くことによって採用しているプロトコルの名前の後に書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Write variadic parameters by inserting three period characters (&lt;c1&gt;&lt;s2&gt;...&lt;/s2&gt;&lt;/c1&gt;) after the parameter’s type name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのパラメータの型名の後に３つのピリオド文字（&lt;c1&gt;&lt;s2&gt;...&lt;/s2&gt;&lt;/c1&gt;）を書き入れることによって、可変長パラメータを書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Write your code using the model given by copy-in copy-out, without depending on the call-by-reference optimization, so that it behaves correctly with or without the optimization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのコードをコピーイン・コピーアウトによって与えられるモデルを使って書いてください、参照呼び出し最適化に依存することなしに、そうすることでそれは最適化があってもなくても正しく振舞います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Writing &lt;c0&gt;&lt;s1&gt;&lt;T:&lt;/s1&gt; &lt;s2&gt;Equatable&gt;&lt;/s2&gt;&lt;/c0&gt; is the same as writing &lt;c3&gt;&lt;s4&gt;&lt;T&gt;&lt;/s4&gt; &lt;s5&gt;...&lt;/s5&gt; &lt;s6&gt;where&lt;/s6&gt; &lt;s7&gt;T:&lt;/s7&gt; &lt;s8&gt;Equatable&lt;/s8&gt;&lt;/c3&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;&lt;T:&lt;/s1&gt; &lt;s2&gt;Equatable&gt;&lt;/s2&gt;&lt;/c0&gt;と書くことは、&lt;c3&gt;&lt;s4&gt;&lt;T&gt;&lt;/s4&gt; &lt;s5&gt;...&lt;/s5&gt; &lt;s6&gt;where&lt;/s6&gt; &lt;s7&gt;T:&lt;/s7&gt; &lt;s8&gt;Equatable&lt;/s8&gt;&lt;/c3&gt;と書くことと同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Writing &lt;c0&gt;&lt;s1&gt;someStructure.$someNumber&lt;/s1&gt;&lt;/c0&gt; accesses the wrapper’s projected value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c0&gt;&lt;s1&gt;someStructure.$someNumber&lt;/s1&gt;&lt;/c0&gt;を書くことは、ラッパーのもつ予測値にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Writing &lt;c6&gt;&lt;s7&gt;Self.someStaticMember&lt;/s7&gt;&lt;/c6&gt; to access a member of the current type is the same as writing &lt;c8&gt;&lt;s9&gt;type(of:&lt;/s9&gt; &lt;s10&gt;self).someStaticMember&lt;/s10&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c6&gt;&lt;s7&gt;Self.someStaticMember&lt;/s7&gt;&lt;/c6&gt;を書いて現在の型のあるメンバーにアクセスすることは、&lt;c8&gt;&lt;s9&gt;type(of:&lt;/s9&gt; &lt;s10&gt;self).someStaticMember&lt;/s10&gt;&lt;/c8&gt;を書くことと同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Writing &lt;c7&gt;&lt;s8&gt;makeTrapezoid()&lt;/s8&gt;&lt;/c7&gt; this way lets it express the fundamental aspect of its public interface—the value it returns is a shape—without making the specific types that the shape is made from a part of its public interface.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;c7&gt;&lt;s8&gt;makeTrapezoid()&lt;/s8&gt;&lt;/c7&gt;をこの方法で書くことは、それにそれのパブリックインターフェイスの基本となる面 — それが返す値はある形状である — を表現させます、特定の型を作ることなしにです、それはその形状がそれのパブリックインターフェイスの一部に由来して作られることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Writing Swift code in a playground lets you experiment with code and see the results immediately, without the overhead of building and running an app.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>スウィフトコードをあるプレイグラウンドの中で書くことで、あなたはコードで実験しその結果を直ちに確かめます、アプリをビルドして実行する手間なしにです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You &lt;e0&gt;can&lt;/e0&gt; iterate over a one-sided range that omits its final value; however, because the range continues indefinitely, make sure you add an explicit end condition for the loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、それの最後の値を省いた片側範囲に対して反復処理&lt;e0&gt;できます&lt;/e0&gt;；しかしながら、範囲があいまいに続いていることから、確実にあなたが明示的な終了条件をそのループに対して加えるようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You access and modify a dictionary through its methods and properties, or by using subscript syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、辞書へのアクセスおよび修正をそれのメソッドとプロパティを通して、または添え字構文を使うことで行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You access and modify a set through its methods and properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは集合へのアクセス及び変更をそれのメソッドとプロパティを通して行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You access and modify a string through its methods and properties, or by using subscript syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは文字列へのアクセスと修正を、それのメソッドとプロパティを通して、または添え字構文を使うことによって行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You access and modify an array through its methods and properties, or by using subscript syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、そのメソッドとプロパティを通して、または添え字構文を使うことによって、配列にアクセスして修正します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You access the indices before and after a given index using the &lt;c0&gt;&lt;s1&gt;index(before:)&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;index(after:)&lt;/s3&gt;&lt;/c2&gt; methods of &lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ある与えられたインデックスの前後のインデックスに&lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt;の&lt;c0&gt;&lt;s1&gt;index(before:)&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;index(after:)&lt;/s3&gt;&lt;/c2&gt;メソッドを使ってアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You access the raw value of an enumeration case with its &lt;c0&gt;&lt;s1&gt;rawValue&lt;/s1&gt;&lt;/c0&gt; property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある列挙ケース節の生の値にそれの&lt;c0&gt;&lt;s1&gt;rawValue&lt;/s1&gt;&lt;/c0&gt;プロパティでアクセスしてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You add conditional conformance to a protocol by including &lt;e0&gt;requirements&lt;/e0&gt; in an extension declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あるプロトコルに対する条件準拠を加えることを、&lt;e0&gt;要件&lt;/e0&gt;を拡張宣言に含めることによって行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You also cannot use the implicit &lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt; property, or call any of the instance’s methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、暗黙の&lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;プロパティを使うことや、そのインスタンスのメソッドの何も呼ぶことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You also can’t use it as constraint in a generic return type because there isn’t enough information outside the function body to infer what the generic type needs to be.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまたそれを制約として総称体戻り型において使用できません、なぜならどうあることをその総称体型が必要とするか推論するのに十分な情報が関数本文の外側にないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You also don’t need to write semicolons at the end of every statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、すべての文の終わりにセミコロンを書く必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You also saw how to use weak and unowned references to break these strong reference cycles.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、これらの強い参照循環を壊すために弱いおよび非所有参照を使う方法を見ました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You also use an initializer expression to delegate to the initializer of a superclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、スーパークラスのイニシャライザに委任するために、イニシャライザ式を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You always write the &lt;c0&gt;&lt;s1&gt;override&lt;/s1&gt;&lt;/c0&gt; modifier when overriding a superclass designated initializer, even if your subclass’s implementation of the initializer is a convenience initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはスーパークラスの指定イニシャライザをオーバーライドする時に常に&lt;c0&gt;&lt;s1&gt;override&lt;/s1&gt;&lt;/c0&gt;修飾子を書きます、そのイニシャライザのあなたのサブクラスでの実装が便宜イニシャライザであるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You apply a wrapper to a property by writing the wrapper’s name before the property as an attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ラッパーのもつ名前をそのプロパティの前に属性として書くことによって、ラッパーをプロパティに適用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You apply it to a parameter’s type in a method or function declaration, for a parameter whose type is a function type that takes no arguments and that returns a value of the type of the expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、それをメソッドまたは関数宣言においてあるパラメータの持つ型に適用します、それの型もつが関数型であるパラメータに対して、それは引数を取らずそしてそれは式の型のひとつの値を返すものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You apply the &lt;c0&gt;&lt;s1&gt;IBOutlet&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;IBInspectable&lt;/s3&gt;&lt;/c2&gt; attributes to property declarations of a class.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;IBOutlet&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;IBInspectable&lt;/s3&gt;&lt;/c2&gt;属性をクラスのプロパティ宣言に適用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You apply the &lt;c4&gt;&lt;s5&gt;IBAction&lt;/s5&gt;&lt;/c4&gt; and &lt;c6&gt;&lt;s7&gt;IBSegueAction&lt;/s7&gt;&lt;/c6&gt; attribute to method declarations of a class and the &lt;c8&gt;&lt;s9&gt;IBDesignable&lt;/s9&gt;&lt;/c8&gt; attribute to class declarations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c4&gt;&lt;s5&gt;IBAction&lt;/s5&gt;&lt;/c4&gt;と&lt;c6&gt;&lt;s7&gt;IBSegueAction&lt;/s7&gt;&lt;/c6&gt;属性をクラスのメソッド宣言に、そして&lt;c8&gt;&lt;s9&gt;IBDesignable&lt;/s9&gt;&lt;/c8&gt;属性をクラス宣言に適用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You are free to implement subscripts in the most appropriate way for your particular class or structure’s functionality.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あなたの特定のクラスまたは構造体の機能性に最も適切な方法で、添え字を実装して結構です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You are not allowed to call a deinitializer yourself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、デイニシャライザをあなた自身で呼び出すことは許されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You assign a lower access level by writing &lt;c1&gt;&lt;s2&gt;fileprivate(set)&lt;/s2&gt;&lt;/c1&gt;, &lt;c3&gt;&lt;s4&gt;private(set)&lt;/s4&gt;&lt;/c3&gt;, or &lt;c5&gt;&lt;s6&gt;internal(set)&lt;/s6&gt;&lt;/c5&gt; before the &lt;c7&gt;&lt;s8&gt;var&lt;/s8&gt;&lt;/c7&gt; or &lt;c9&gt;&lt;s10&gt;subscript&lt;/s10&gt;&lt;/c9&gt; introducer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、より低いアクセス水準を割り当てることを、&lt;c1&gt;&lt;s2&gt;fileprivate(set)&lt;/s2&gt;&lt;/c1&gt;、&lt;c3&gt;&lt;s4&gt;private(set)&lt;/s4&gt;&lt;/c3&gt;、または&lt;c5&gt;&lt;s6&gt;internal(set)&lt;/s6&gt;&lt;/c5&gt;を&lt;c7&gt;&lt;s8&gt;var&lt;/s8&gt;&lt;/c7&gt;または&lt;c9&gt;&lt;s10&gt;subscript&lt;/s10&gt;&lt;/c9&gt;導入子の前に書くことによって行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You call an &lt;c0&gt;&lt;s1&gt;init?&lt;/s1&gt;&lt;/c0&gt; failable initializer in the same way that you call a nonfailable initializer, except that you must deal with the optionality of the result.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは失敗できるイニシャライザ&lt;c0&gt;&lt;s1&gt;init?&lt;/s1&gt;&lt;/c0&gt;を、オプショナルの結果を処理する必要があることを除き、失敗できないイニシャライザを呼び出すのと同じ方法で呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You call instance methods with the same dot syntax as properties:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、インスタンスメソッドをプロパティと同じドット構文を使って呼び出します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You call the &lt;c0&gt;&lt;s1&gt;greet(person:)&lt;/s1&gt;&lt;/c0&gt; function by passing it a &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt; value after the &lt;c4&gt;&lt;s5&gt;person&lt;/s5&gt;&lt;/c4&gt; argument label, such as &lt;c6&gt;&lt;s7&gt;greet(person:&lt;/s7&gt; &lt;s8&gt;"Anna")&lt;/s8&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;greet(person:)&lt;/s1&gt;&lt;/c0&gt;関数をそれに&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;値を&lt;c4&gt;&lt;s5&gt;person&lt;/s5&gt;&lt;/c4&gt;引数ラベルの後で渡すことによって、例えば&lt;c6&gt;&lt;s7&gt;greet(person:&lt;/s7&gt; &lt;s8&gt;"Anna")&lt;/s8&gt;&lt;/c6&gt;のように呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You call the &lt;c0&gt;&lt;s1&gt;greet(person:alreadyGreeted:)&lt;/s1&gt;&lt;/c0&gt; function by passing it both a &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt; argument value labeled &lt;c4&gt;&lt;s5&gt;person&lt;/s5&gt;&lt;/c4&gt; and a &lt;c6&gt;&lt;s7&gt;Bool&lt;/s7&gt;&lt;/c6&gt; argument value labeled &lt;c8&gt;&lt;s9&gt;alreadyGreeted&lt;/s9&gt;&lt;/c8&gt; in parentheses, separated by commas.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは&lt;c0&gt;&lt;s1&gt;greet(person:alreadyGreeted:)&lt;/s1&gt;&lt;/c0&gt;関数をそれに&lt;c4&gt;&lt;s5&gt;person&lt;/s5&gt;&lt;/c4&gt;でラベルした&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;引数値と&lt;c8&gt;&lt;s9&gt;alreadyGreeted&lt;/s9&gt;&lt;/c8&gt;でラベルした&lt;c6&gt;&lt;s7&gt;Bool&lt;/s7&gt;&lt;/c6&gt;引き数値を両方とも丸括弧内に、コンマで区切って渡すことで呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You call the &lt;c2&gt;&lt;s3&gt;UINavigationController&lt;/s3&gt;&lt;/c2&gt; class &lt;c4&gt;&lt;s5&gt;pushViewController(_:animated:)&lt;/s5&gt;&lt;/c4&gt; method to add (or push) a view controller on to the navigation stack, and its &lt;c6&gt;&lt;s7&gt;popViewControllerAnimated(_:)&lt;/s7&gt;&lt;/c6&gt; method to remove (or pop) a view controller from the navigation stack.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは&lt;c2&gt;&lt;s3&gt;UINavigationController&lt;/s3&gt;&lt;/c2&gt;クラスの&lt;c4&gt;&lt;s5&gt;pushViewController(_:animated:)&lt;/s5&gt;&lt;/c4&gt;メソッドをナビゲーション・スタックにビュー・コントローラを加える（またはプッシュする）ために、そしてそれの&lt;c6&gt;&lt;s7&gt;popViewControllerAnimated(_:)&lt;/s7&gt;&lt;/c6&gt;メソッドをナビゲーション・スタックからビュー・コントローラを取り除くために呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can &lt;e0&gt;decompose&lt;/e0&gt; a tuple’s contents into separate constants or variables, which you then access as usual:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはタプルの内容を個々の定数または変数に&lt;e0&gt;分解&lt;/e0&gt;することができます。そして、あなたはそれから通常通りそれにアクセスします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can access a UTF-16 representation of a &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; by iterating over its &lt;c2&gt;&lt;s3&gt;utf16&lt;/s3&gt;&lt;/c2&gt; property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ある&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;のUTF-16叙述に、それの&lt;c2&gt;&lt;s3&gt;utf16&lt;/s3&gt;&lt;/c2&gt;プロパティのすべてに渡って繰り返していくことによってアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can access a UTF-8 representation of a &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; by iterating over its &lt;c2&gt;&lt;s3&gt;utf8&lt;/s3&gt;&lt;/c2&gt; property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ある&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;のUTF-８叙述に、それの&lt;c2&gt;&lt;s3&gt;utf8&lt;/s3&gt;&lt;/c2&gt;プロパティのすべてに渡って繰り返していくことによってアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can access a Unicode scalar representation of a &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; value by iterating over its &lt;c2&gt;&lt;s3&gt;unicodeScalars&lt;/s3&gt;&lt;/c2&gt; property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ある&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;のUnicodeスカラー叙述に、それの&lt;c2&gt;&lt;s3&gt;unicodeScalars&lt;/s3&gt;&lt;/c2&gt;プロパティのすべてに渡って繰り返していくことによってアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can access the individual &lt;c0&gt;&lt;s1&gt;Character&lt;/s1&gt;&lt;/c0&gt; values for a &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt; by iterating over the string with a &lt;c4&gt;&lt;s5&gt;for&lt;/s5&gt;&lt;/c4&gt;-&lt;c6&gt;&lt;s7&gt;in&lt;/s7&gt;&lt;/c6&gt; loop:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ある&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;の個々の&lt;c0&gt;&lt;s1&gt;Character&lt;/s1&gt;&lt;/c0&gt;値に&lt;c4&gt;&lt;s5&gt;for&lt;/s5&gt;&lt;/c4&gt;-&lt;c6&gt;&lt;s7&gt;in&lt;/s7&gt;&lt;/c6&gt;ループでその文字列の初めから終わりまで反復することによってアクセスできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can access the minimum and maximum values of each integer type with its &lt;c0&gt;&lt;s1&gt;min&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;max&lt;/s3&gt;&lt;/c2&gt; properties:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、その&lt;c0&gt;&lt;s1&gt;min&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;max&lt;/s3&gt;&lt;/c2&gt;プロパティで各整数型の最小と最大の値を得ることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can access the properties of an instance using &lt;e0&gt;dot syntax&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;e0&gt;ドット構文&lt;/e0&gt;を使ってインスタンスのプロパティにアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can add a new item into a set by calling the set’s &lt;c0&gt;&lt;s1&gt;insert(_:)&lt;/s1&gt;&lt;/c0&gt; method:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは新しい項目を集合に加えることが集合の&lt;c0&gt;&lt;s1&gt;insert(_:)&lt;/s1&gt;&lt;/c0&gt;メソッドを呼ぶことによって行えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can add a new item to a dictionary with subscript syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、添え字構文を使って辞書に新しい項目を付け加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can add a new item to the end of an array by calling the array’s &lt;c0&gt;&lt;s1&gt;append(_:)&lt;/s1&gt;&lt;/c0&gt; method:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、配列の&lt;c0&gt;&lt;s1&gt;append(_:)&lt;/s1&gt;&lt;/c0&gt;メソッドを呼ぶことによって配列の終わりに新しい項目を加えることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can add any number of additional branches using &lt;c2&gt;&lt;s3&gt;#elseif&lt;/s3&gt;&lt;/c2&gt; clauses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、任意の数の追加の分岐を加えることが&lt;c2&gt;&lt;s3&gt;#elseif&lt;/s3&gt;&lt;/c2&gt;を使って行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can add property observers to any stored properties you define, except for lazy stored properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、プロパティオブザーバーをあなたが定義するどんな格納プロパティにでも加えることができます、しかし遅延格納プロパティは除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can add property observers to any stored property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、プロパティオブザーバーをどんな格納プロパティにでも加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can add protocol conformance to a previously declared type by adopting the protocol in an extension declaration of that type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、プロトコル準拠を以前に宣言された型に加えることが、その型の拡張宣言においてそのプロトコルを採用することによってできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can add type constraints to an associated type in a protocol to require that conforming types satisfy those constraints.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、型制約を関連型へとプロトコルの中で加えることで、準拠する型がそれら制約を満たすことを要求できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also add a final additional branch using an &lt;c4&gt;&lt;s5&gt;#else&lt;/s5&gt;&lt;/c4&gt; clause.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、最後の追加の分岐を&lt;c4&gt;&lt;s5&gt;#else&lt;/s5&gt;&lt;/c4&gt;節を使って加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also add new characteristics to the subclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、新しい特徴をサブクラスに加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also add property observers to any inherited property (whether stored or computed) by overriding the property within a subclass, as described in &lt;a0&gt;&lt;s1&gt;Overriding Property Observers&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、プロパティオブザーバーをあらゆる継承されたプロパティ（格納されるか、計算されるかに関係なく）にでも加えることが、サブクラスの内部でプロパティをオーバーライドすることによって、&lt;a0&gt;&lt;s1&gt;プロパティオブザーバーのオーバーライド&lt;/s1&gt;&lt;/a0&gt;で記述されるように、可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also add property observers to any inherited property (whether stored or computed) by overriding the property within a subclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、プロパティオブザーバーを、どんな継承されたプロパティにでも（格納されるか、計算されるかに関係なく）、サブクラス内でそのプロパティをオーバーライドすることによって加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also aggregate the conformance requirements of multiple protocols using protocol composition types, as described in &lt;a0&gt;&lt;s1&gt;Protocol Composition Type&lt;/s1&gt;&lt;/a0&gt; and &lt;a2&gt;&lt;s3&gt;Protocol Composition&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、&lt;a0&gt;&lt;s1&gt;プロトコル合成型&lt;/s1&gt;&lt;/a0&gt;と&lt;a2&gt;&lt;s3&gt;プロトコル合成&lt;/s3&gt;&lt;/a2&gt;で記述されるように、複数のプロトコルの準拠要件をひとまとめにすることがプロトコル合成（コンポジション）型を使って可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also append a &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; value to an existing &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt; variable with the addition assignment operator (&lt;c4&gt;&lt;s5&gt;+=&lt;/s5&gt;&lt;/c4&gt;):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、ある&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;値を既存の&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;変数に加算代入演算子（&lt;c4&gt;&lt;s5&gt;+=&lt;/s5&gt;&lt;/c4&gt;）を使って追加することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also attempt to set a property’s value through optional chaining:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまたプロパティの値をオプショナル連鎖を通して設定することを試みることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also bind an arbitrary expression to a named value in a capture list.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、ある任意の式を、キャプチャリストの中の名前をつけられた値と結び付けることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also call the &lt;a0&gt;&lt;c1&gt;&lt;s2&gt;preconditionFailure(_:file:line:)&lt;/s2&gt;&lt;/c1&gt;&lt;/a0&gt;&lt;s3&gt; [https://developer.apple.com/documentation/swift/1539374-preconditionfailure]&lt;/s3&gt; function to indicate that a failure has occurred—for example, if the default case of a switch was taken, but all valid input data should have been handled by one of the switch’s other cases.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、&lt;a0&gt;&lt;c1&gt;&lt;s2&gt;preconditionFailure(_:file:line:)&lt;/s2&gt;&lt;/c1&gt;&lt;/a0&gt;&lt;s3&gt; [https://developer.apple.com/documentation/swift/1539374-preconditionfailure]&lt;/s3&gt;関数を呼び出して失敗がすでに起こっていることを示すことができます — 例えば、あるスイッチ文の省略時のケース節が取られた、しかし全ての有効な入力データがそのスイッチ文の他のケース節の１つによって取り扱われてしまっている場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also check whether a one-sided range contains a particular value, as shown in the code below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、以下のコードで示すように、片側範囲が特定の値を含むかどうか調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also combine opaque return types with generics.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、不透明戻り型を総称体と結合できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also declare a stored variable or property with &lt;c0&gt;&lt;s1&gt;willSet&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;didSet&lt;/s3&gt;&lt;/c2&gt; observers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、&lt;c0&gt;&lt;s1&gt;willSet&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;didSet&lt;/s3&gt;&lt;/c2&gt;オブザーバーをもつ格納変数やプロパティを宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also declare properties in the context of a protocol declaration, as described in &lt;a0&gt;&lt;s1&gt;Protocol Property Declaration&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;プロトコルプロパティ宣言&lt;/s1&gt;&lt;/a0&gt;で記述されるように、あなたはまた、プロトコル宣言の文脈において、プロパティを宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also declare subscripts in the context of a protocol declaration, as described in &lt;a0&gt;&lt;s1&gt;Protocol Subscript Declaration&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;プロトコル添え字宣言&lt;/s1&gt;&lt;/a0&gt;で記述されるように、あなたはまた、プロトコル宣言の文脈において添え字を宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also define a convenience initializer to create an instance of that class for a specific use case or input value type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、ある便宜イニシャライザを定義して、そのクラスのインスタンスを特定の使用状況のために作成したり、値型を入力することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also define custom operators that begin with a dot (&lt;c0&gt;&lt;s1&gt;.&lt;/s1&gt;&lt;/c0&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、１つのドット（&lt;c0&gt;&lt;s1&gt;.&lt;/s1&gt;&lt;/c0&gt;）で始まるあつらえの演算子を定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also define functions inside the bodies of other functions, known as &lt;e1&gt;nested functions&lt;/e1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、他の関数の本体の内側に関数を、&lt;e1&gt;入れ子にされた関数&lt;/e1&gt;として知られるものを、定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also define methods that are called on the type itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、型それ自体の上で呼ばれるメソッドを定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also define properties that belong to the type itself, not to any one instance of that type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、その型のどれかひとつのインスタンスにではなく、型それ自体に属しているいくらかのプロパティを定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also define subscripts that are called on the type itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、型それ自身の上で呼び出される添え字を定義できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also delegate from &lt;c8&gt;&lt;s9&gt;init&lt;/s9&gt;&lt;/c8&gt; to &lt;c10&gt;&lt;s11&gt;init!&lt;/s11&gt;&lt;/c10&gt;, although doing so will trigger an assertion if the &lt;c12&gt;&lt;s13&gt;init!&lt;/s13&gt;&lt;/c12&gt; initializer causes initialization to fail.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、&lt;c8&gt;&lt;s9&gt;init&lt;/s9&gt;&lt;/c8&gt;から&lt;c10&gt;&lt;s11&gt;init!&lt;/s11&gt;&lt;/c10&gt;へ委任することができます、もっともそうすることは、&lt;c12&gt;&lt;s13&gt;init!&lt;/s13&gt;&lt;/c12&gt;イニシャライザが初期化失敗の原因となるならば、ある表明を引き起こすことになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also extend a generic type to conditionally add functionality, as described in &lt;a2&gt;&lt;s3&gt;Extensions with a Generic Where Clause&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた総称体型を拡張することで条件付きの機能性を追加することができます、&lt;a2&gt;&lt;s3&gt;総称体where節を持つ拡張&lt;/s3&gt;&lt;/a2&gt;で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also initialize a dictionary with a &lt;e0&gt;dictionary literal&lt;/e0&gt;, which has a similar syntax to the array literal seen earlier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、&lt;e0&gt;辞書リテラル&lt;/e0&gt;で辞書を初期化することができます、それは以前に見た配列リテラルに似ている構文を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also initialize a set with an array literal, as a shorthand way to write one or more values as a set collection.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、１つ以上の値を集合コレクションとして書くための省略法として、集合を配列リテラルを使って初期化することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also initialize an array with an &lt;e0&gt;array literal&lt;/e0&gt;, which is a shorthand way to write one or more values as an array collection.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた&lt;e0&gt;配列リテラル&lt;/e0&gt;を使って配列を初期化することができます、それは１つ以上の値を配列コレクションとして書くための短縮形の方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also iterate over a dictionary to access its key-value pairs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、辞書の端から端まで繰り返して、その「キーと値」の対にアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also make the generic &lt;c0&gt;&lt;s1&gt;Stack&lt;/s1&gt;&lt;/c0&gt; type conform to the &lt;c2&gt;&lt;s3&gt;Container&lt;/s3&gt;&lt;/c2&gt; protocol:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、総称体&lt;c0&gt;&lt;s1&gt;Stack&lt;/s1&gt;&lt;/c0&gt;型を&lt;c2&gt;&lt;s3&gt;Container&lt;/s3&gt;&lt;/c2&gt;プロトコルに準拠させることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also modify the inherited &lt;c0&gt;&lt;s1&gt;currentSpeed&lt;/s1&gt;&lt;/c0&gt; property of a &lt;c2&gt;&lt;s3&gt;Bicycle&lt;/s3&gt;&lt;/c2&gt; instance, and query the instance’s inherited &lt;c4&gt;&lt;s5&gt;description&lt;/s5&gt;&lt;/c4&gt; property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、ある&lt;c2&gt;&lt;s3&gt;Bicycle&lt;/s3&gt;&lt;/c2&gt;インスタンスの継承された&lt;c0&gt;&lt;s1&gt;currentSpeed&lt;/s1&gt;&lt;/c0&gt;プロパティを変更することが出来ます、そしてそのインスタンスの持つ継承された&lt;c4&gt;&lt;s5&gt;description&lt;/s5&gt;&lt;/c4&gt;プロパティについて問い合わせることが出来ます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also name the elements of a tuple type and use those names to refer to the values of the individual elements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、タプル型の要素に名をつけることができて、それらの名前を個々の要素の値に言及するために使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also optionally define a type of value that the function will pass back as output when it is done, known as its &lt;e1&gt;return type&lt;/e1&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、随意にその関数が実行を終えたとき出力として逆に渡す値の型、その&lt;e1&gt;戻り型&lt;/e1&gt;として知られるものを定義できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also override a subscript declaration inherited from a superclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、スーパークラスから継承した添え字宣言をオーバーライドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also provide arguments to the attribute when you apply it to a property, and those arguments are passed to the property wrapper’s initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた引数いくつかを、属性に対して提供することが、それをあなたがプロパティに適用する時に行えます、そしてそれら引数は、プロパティラッパーのもつイニシャライザに渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also replace a type parameter with a type argument that is itself a specialized version of a generic type (provided it satisfies the appropriate constraints and requirements).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、型パラメータを、それ自身が総称体型の特殊化版である型引数と置き換えることができます（それが適切な制約と要件を満たすという条件で）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also retrieve an iterable collection of a dictionary’s keys or values by accessing its &lt;c0&gt;&lt;s1&gt;keys&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;values&lt;/s3&gt;&lt;/c2&gt; properties:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、その&lt;c0&gt;&lt;s1&gt;keys&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;values&lt;/s3&gt;&lt;/c2&gt;プロパティにアクセスすることによって、ある辞書のキーまたは値からなる、for-in文で繰り返し可能なコレクション（集まり）を取り出すことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also set and modify the initial value for a stored property during initialization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、初期化のときに格納プロパティに対して最初の値を設定および修正することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also specify the requirement that two types be identical, using the &lt;c0&gt;&lt;s1&gt;==&lt;/s1&gt;&lt;/c0&gt; operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、&lt;c0&gt;&lt;s1&gt;==&lt;/s1&gt;&lt;/c0&gt;演算子を使用して、２つの型が同一であるという要件を指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also subclass any open class that’s defined in a different module.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、異なるモジュールにおいて定義されるどんな開放クラスにでもサブクラスを作れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use &lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt; loops with numeric ranges.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたまた、&lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt;ループを数値範囲とともに使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use a declaration to extend the behavior of an existing named type and to import symbols into your program that are declared elsewhere.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、ある宣言を使うことで、既存の名前付きの型の振るまいを拡張することや、どこか他で宣言されるシンボルをあなたのプログラムへインポートすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use a generic &lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt; clause as part of an extension.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたまた、総称体&lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt;節を拡張の一部として使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use a property wrapper to reuse code in the getter and setter of multiple properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまたプロパティラッパーを使用して、複数のプロパティのゲッターとセッターでコードを再利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use a raw value to find a corresponding case, if there is one, by calling the enumeration’s failable initializer, as in &lt;c11&gt;&lt;s12&gt;ExampleEnum(rawValue:&lt;/s12&gt; &lt;s13&gt;5)&lt;/s13&gt;&lt;/c11&gt;, which returns an optional case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた生の値を使用して対応するケース節を見つけることが、もしそれが１つあるならば、列挙の持つ失敗できるイニシャライザを呼ぶことによって可能です、例えば&lt;c11&gt;&lt;s12&gt;ExampleEnum(rawValue:&lt;/s12&gt; &lt;s13&gt;5)&lt;/s13&gt;&lt;/c11&gt;のように、それはオプショナルのケース節を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use an asterisk (&lt;c0&gt;&lt;s1&gt;*&lt;/s1&gt;&lt;/c0&gt;) to indicate the availability of the declaration on all of the platform names listed above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、アスタリスク（&lt;c0&gt;&lt;s1&gt;*&lt;/s1&gt;&lt;/c0&gt;）を使って上でリストされるプラットホーム名の全てでその宣言の有効性を指し示すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use an implicitly unwrapped optional with optional binding, to check and unwrap its value in a single statement:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、暗黙的にアンラップされるオプショナルをオプショナル束縛とともに使うことができます、１つの文でその値を確認してアンラップするためには：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use dot syntax to assign a new value to a variable property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、新しい値を変数プロパティに代入するためにドット構文を使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use optional chaining and optional binding to conditionally perform an operation on an optional expression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまたオプショナル連鎖とオプショナル束縛を使って、あるオプショナルの式に関して演算を条件付きで実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use optional chaining to call a method that returns a value of optional type, and to chain on that method’s return value if needed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまたオプショナル連鎖を使って、オプショナルの型の値を返すメソッドを呼び出すこと、そして必要ならば、そのメソッドの戻り値の上で連鎖することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use strings or floating-point numbers as the raw type of an enumeration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、列挙の生の型として、文字列または浮動小数点数を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use strings to insert constants, variables, literals, and expressions into longer strings, in a process known as string interpolation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた文字列を、文字列補間として知られているやり方で、定数、変数、リテラル、および式をより長い文字列に差し入れるために使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use subscript syntax to change a range of values at once, even if the replacement set of values has a different length than the range you are replacing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、添え字構文を使って、ある範囲の値を一度に変えることができます、たとえ代替の値一式があなたが置き換えている範囲と異なる長さを持つとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use subscript syntax to change the value associated with a particular key:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、添え字構文を特定のキーと結びつけられる値を変えるために使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use subscript syntax to retrieve a value from the dictionary for a particular key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、添え字構文を特定のキーに対する値を辞書から取り出すために使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also use type casting to check whether a type conforms to a protocol, as described in &lt;a0&gt;&lt;s1&gt;Checking for Protocol Conformance&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、&lt;a0&gt;&lt;s1&gt;プロトコル準拠の確認&lt;/s1&gt;&lt;/a0&gt;で記述されるように、その型があるプロトコルに準拠しているどうか調べるために型キャストを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also write &lt;c0&gt;&lt;s1&gt;indirect&lt;/s1&gt;&lt;/c0&gt; before the beginning of the enumeration to enable indirection for all of the enumeration’s cases that have an associated value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、列挙の始まりの前に&lt;c0&gt;&lt;s1&gt;indirect&lt;/s1&gt;&lt;/c0&gt;を書くことで、列挙の持つケース節で関連値を持つもの全てに対して間接参照を可能にできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also write the type of a dictionary in shorthand form as &lt;c0&gt;&lt;s1&gt;[Key:&lt;/s1&gt; &lt;s2&gt;Value]&lt;/s2&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、辞書の型を&lt;c0&gt;&lt;s1&gt;[Key:&lt;/s1&gt; &lt;s2&gt;Value]&lt;/s2&gt;&lt;/c0&gt;のような省略形で書くこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also write the type of an array in shorthand form as &lt;c4&gt;&lt;s5&gt;[Element]&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、また、短縮形形式で配列の型を&lt;c4&gt;&lt;s5&gt;[Element]&lt;/s5&gt;&lt;/c4&gt;のように書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can append a &lt;c0&gt;&lt;s1&gt;Character&lt;/s1&gt;&lt;/c0&gt; value to a &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt; variable with the &lt;c4&gt;&lt;s5&gt;String&lt;/s5&gt;&lt;/c4&gt; type’s &lt;c6&gt;&lt;s7&gt;append()&lt;/s7&gt;&lt;/c6&gt; method:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;Character&lt;/s1&gt;&lt;/c0&gt;値を&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;変数にその&lt;c4&gt;&lt;s5&gt;String型&lt;/s5&gt;&lt;/c4&gt;のもつ&lt;c6&gt;&lt;s7&gt;append()&lt;/s7&gt;&lt;/c6&gt;メソッドを使って追加することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can apply a declaration attribute to declarations only.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、宣言属性を宣言だけに適用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can apply multiple &lt;c0&gt;&lt;s1&gt;available&lt;/s1&gt;&lt;/c0&gt; attributes on a single declaration to specify the declaration’s availability on different platforms and different versions of Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、複数の&lt;c0&gt;&lt;s1&gt;available&lt;/s1&gt;&lt;/c0&gt;属性を単一の宣言上に適用することで、その宣言の利用可能性を異なるプラットホームおよび異なるバージョンのスウィフトに関して指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can apply switch case attributes to switch cases only.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、スイッチケース節属性をスイッチケース節のみに適用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can apply the &lt;c0&gt;&lt;s1&gt;@unknown&lt;/s1&gt;&lt;/c0&gt; attribute to the default case, which indicates that the default case should match only enumeration cases that are added in the future.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは&lt;c0&gt;&lt;s1&gt;@unknown&lt;/s1&gt;&lt;/c0&gt;属性をdefaultケース節に適用できます、それはそのdefaultケース節が、将来に加えられる列挙ケース節だけに合致すべきであることを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can apply the &lt;c0&gt;&lt;s1&gt;available&lt;/s1&gt;&lt;/c0&gt; attribute with the &lt;c2&gt;&lt;s3&gt;renamed&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;unavailable&lt;/s5&gt;&lt;/c4&gt; arguments to a type alias declaration, as shown below, to indicate that the name of a declaration changed between releases of a framework or library.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;available&lt;/s1&gt;&lt;/c0&gt;属性を&lt;c2&gt;&lt;s3&gt;renamed&lt;/s3&gt;&lt;/c2&gt;および&lt;c4&gt;&lt;s5&gt;unavailable&lt;/s5&gt;&lt;/c4&gt;属性とともに型エイリアス宣言に対して使うことで、下で示されるように、ある宣言の名前がフレームワークまたはライブラリのリリースの間に変わったことを指し示せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can apply the &lt;c0&gt;&lt;s1&gt;optional&lt;/s1&gt;&lt;/c0&gt; modifier only to protocols that are marked with the &lt;c2&gt;&lt;s3&gt;objc&lt;/s3&gt;&lt;/c2&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは&lt;c0&gt;&lt;s1&gt;optional&lt;/s1&gt;&lt;/c0&gt;修飾子を&lt;c2&gt;&lt;s3&gt;objc&lt;/s3&gt;&lt;/c2&gt;属性で印されるプロトコルだけに適用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can apply type attributes to types only.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、型属性を型だけに適用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can assign a &lt;c0&gt;&lt;s1&gt;Residence&lt;/s1&gt;&lt;/c0&gt; instance to &lt;c2&gt;&lt;s3&gt;john.residence&lt;/s3&gt;&lt;/c2&gt;, so that it no longer has a &lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt; value:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは&lt;c2&gt;&lt;s3&gt;john.residence&lt;/s3&gt;&lt;/c2&gt;に&lt;c0&gt;&lt;s1&gt;Residence&lt;/s1&gt;&lt;/c0&gt;インスタンスを代入することができます、それによってそれはもはや&lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;値を持ちません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can assign a value to a constant property at any point during initialization, as long as it is set to a definite value by the time initialization finishes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、それが初期化終了時にある明確な値に設定されさえするならば、ある値を初期化の間のどの時点ででも定数プロパティに割り当てることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can assign specific access levels to individual types (classes, structures, and enumerations), as well as to properties, methods, initializers, and subscripts belonging to those types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは特定のアクセス水準を個々の型（クラス、構造体、および列挙）、それだけでなくそれらの型に属しているプロパティ、メソッド、イニシャライザ、そして添え字に、個別に割り当てることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can assign the same product a different type of barcode:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、同じ商品を異なる型のバーゴードに割り当てることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can be confident that the string you are passed won’t be modified unless you modify it yourself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あなたが渡される文字列があなたが自身でそれを修正しない限り修正されないことを確信することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can call &lt;c2&gt;&lt;s3&gt;self.init&lt;/s3&gt;&lt;/c2&gt; only from within an initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c2&gt;&lt;s3&gt;self.init&lt;/s3&gt;&lt;/c2&gt;をイニシャライザ内からだけ呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can call an instance of a dynamically callable type as if it’s a function that takes any number of arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは動的callable型のインスタンスを、まるでそれがいくらかの数の引数を取る関数であるかのように呼び出せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can call such functions with either a &lt;c10&gt;&lt;s11&gt;String&lt;/s11&gt;&lt;/c10&gt; or &lt;c12&gt;&lt;s13&gt;Substring&lt;/s13&gt;&lt;/c12&gt; value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、そのような関数を&lt;c10&gt;&lt;s11&gt;String&lt;/s11&gt;&lt;/c10&gt;または&lt;c12&gt;&lt;s13&gt;Substring&lt;/s13&gt;&lt;/c12&gt;値で呼出せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can call the &lt;c0&gt;&lt;s1&gt;greet(person:)&lt;/s1&gt;&lt;/c0&gt; function multiple times with different input values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、異なる入力値を使って&lt;c0&gt;&lt;s1&gt;greet(person:)&lt;/s1&gt;&lt;/c0&gt;関数を複数回呼び出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can call the &lt;c0&gt;&lt;s1&gt;swapTwoInts(_:_:)&lt;/s1&gt;&lt;/c0&gt; function with two variables of type &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt; to swap their values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;swapTwoInts(_:_:)&lt;/s1&gt;&lt;/c0&gt;関数を、それらの値を交換する２つの&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;型の変数で呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can call the &lt;c14&gt;&lt;s15&gt;type(of:)&lt;/s15&gt;&lt;/c14&gt; function with an instance of a type to access that instance’s dynamic, runtime type as a value, as the following example shows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ある型のインスタンスを使って&lt;c14&gt;&lt;s15&gt;type(of:)&lt;/s15&gt;&lt;/c14&gt;関数を呼び出して、そのインスタンスの持つ動的な、実行時の型にひとつの値としてアクセスできます、以下の例で示すように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can call this function to swap the values in two &lt;c10&gt;&lt;s11&gt;Int&lt;/s11&gt;&lt;/c10&gt; variables:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、２つの&lt;c10&gt;&lt;s11&gt;Int&lt;/s11&gt;&lt;/c10&gt;変数の値を交換するためにこの関数を呼ぶことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can chain multiple &lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt; statements together to consider additional clauses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、複数の&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt;文を一緒につないで追加の条項を考慮することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can change the value of an existing variable to another value of a compatible type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、既存の変数の値を、別の互換性を持つ型の値に変えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can check for the existence of a value in the weak reference, just like any other optional value, and you will never end up with a reference to an invalid instance that no longer exists.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他のあらゆるオプショナルの値と同じように、あなたは弱い参照の中の値の存在について調べることができます、そして、あなたは既に存在しない無効なインスタンスへの参照に至ることは決してありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can check that an index is valid before using it by comparing it to the array’s &lt;c0&gt;&lt;s1&gt;count&lt;/s1&gt;&lt;/c0&gt; property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはあるインデックスが有効なことを、それを配列の&lt;c0&gt;&lt;s1&gt;count&lt;/s1&gt;&lt;/c0&gt;プロパティと比較することによって、それを使う前に確認することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can check the different barcode types using a switch statement, similar to the example in &lt;a0&gt;&lt;s1&gt;Matching Enumeration Values with a Switch Statement&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、異なるバーコード型それらを、&lt;a0&gt;&lt;s1&gt;列挙値をスイッチ文で照合する&lt;/s1&gt;&lt;/a0&gt;での例に似たあるスイッチ文を使って調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can check whether an implicitly unwrapped optional is &lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt; the same way you check a normal optional:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、暗黙的にアンラップされるオプショナルが&lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;であるかどうかを確認することが、あなたが通常のオプショナルを調べるのと同じ方法で可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can combine compilation conditions using the logical operators &lt;c0&gt;&lt;s1&gt;&amp;&amp;&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;||&lt;/s3&gt;&lt;/c2&gt;, and &lt;c4&gt;&lt;s5&gt;!&lt;/s5&gt;&lt;/c4&gt; and use parentheses for grouping.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、コンパイル条件を結合させることが論理演算子&lt;c0&gt;&lt;s1&gt;&amp;&amp;&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;||&lt;/s3&gt;&lt;/c2&gt;、そして&lt;c4&gt;&lt;s5&gt;!&lt;/s5&gt;&lt;/c4&gt;を使って可能です、そして丸括弧をグループにするのに使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can combine multiple logical operators to create longer compound expressions:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、より長く複雑な式をつくるために複数の論理演算子を結合することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can combine multiple protocols into a single requirement with a &lt;e0&gt;protocol composition&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;e0&gt;プロトコル合成&lt;/e0&gt;を使って複数のプロトコルを１つの要件に結合することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can compare two tuples if they have the same type and the same number of values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、２つのタプルを比較することが、それらが同じ型と同じ数の値を持つならば可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can constrain a tuple pattern to match certain kinds of tuple types by using type annotations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、型注釈を使うことによって特定の種類のタプル型にマッチするようにタプルパターンに制約を加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can construct a new &lt;c0&gt;&lt;s1&gt;Matrix&lt;/s1&gt;&lt;/c0&gt; instance by passing an appropriate row and column count to its initializer:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、そのイニシャライザに適切な行と列の数を渡すことによって新しい&lt;c0&gt;&lt;s1&gt;Matrix&lt;/s1&gt;&lt;/c0&gt;インスタンスを造ることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can create a new array by adding together two existing arrays with compatible types with the addition operator (&lt;c0&gt;&lt;s1&gt;+&lt;/s1&gt;&lt;/c0&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、互換性を持つ型の２つの既存の配列を加算演算子（&lt;c0&gt;&lt;s1&gt;+&lt;/s1&gt;&lt;/c0&gt;）を使って一緒に加えることによって、新しい配列をつくることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can create an array that holds &lt;c5&gt;&lt;s6&gt;Int&lt;/s6&gt;&lt;/c5&gt; values, or an array that holds &lt;c7&gt;&lt;s8&gt;String&lt;/s8&gt;&lt;/c7&gt; values, or indeed an array for any other type that can be created in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c5&gt;&lt;s6&gt;Int&lt;/s6&gt;&lt;/c5&gt;値を保持する配列、または&lt;c7&gt;&lt;s8&gt;String&lt;/s8&gt;&lt;/c7&gt;値を保持する配列、またはそれどころかスウィフトで作成可能なあらゆる他の型のためにも配列をつくることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can create an empty array of a certain type using initializer syntax:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、特定の型の空の配列をイニシャライザ構文を使って作成できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can create an empty set of a certain type using initializer syntax:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは特定の型の空の集合を初期化構文を使って作成することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can create an instance of the &lt;c0&gt;&lt;s1&gt;Player&lt;/s1&gt;&lt;/c0&gt; class for a new player, and see what happens when the player completes level one:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、新しいプレーヤーのために&lt;c0&gt;&lt;s1&gt;Player&lt;/s1&gt;&lt;/c0&gt;クラスのインスタンスをつくることができて、そのプレーヤーがレベル１を完了するとき、何が起こるか見ることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can create and print an &lt;c0&gt;&lt;s1&gt;HTMLElement&lt;/s1&gt;&lt;/c0&gt; instance as before:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;HTMLElement&lt;/s1&gt;&lt;/c0&gt;インスタンスを前の通り作成して出力することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can create multidimensional arrays by nesting pairs of square brackets, where the name of the base type of the elements is contained in the innermost pair of square brackets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、角括弧の対を入れにすることによって多次元配列をつくることができます、そこで要素の基本型の名前は最も内側の角括弧の対の中に含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can create tuples from any permutation of types, and they can contain as many different types as you like.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、いろいろな型をどんな順列にしてタプルを作っても構いません、そして、それらはあなたが望むだけ多くの異なる型を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can customize the initialization process with input parameters and optional property types, or by assigning constant properties during initialization, as described in the following sections.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、以下の節で記述されるように、入力パラメータとオプショナルプロパティ型を使って、または初期化の間に定数プロパティを割り当てることによって、初期化処理を目的に合わせて作り変えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can declare and implement your own &lt;e0&gt;custom operators&lt;/e0&gt; in addition to the standard operators provided by Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、スウィフトによって提供される標準の演算子に加えて、あなた独自の&lt;e0&gt;あつらえの演算子&lt;/e0&gt;を宣言して実装することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can declare multiple constants or multiple variables on a single line, separated by commas:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは複数の定数または複数の変数を、コンマで区切ることで１つの行に宣言することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can declare operators of three different fixities: infix, prefix, and postfix.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、３つの異なる定着性の演算子を宣言することができます：接中辞、接頭辞、そして接尾辞。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can decompose the tuple into temporary constants or variables as part of the iteration:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、繰り返しの一部としてそのタプルを一時的な定数または変数に分解することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can define &lt;e0&gt;optional requirements&lt;/e0&gt; for protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;e0&gt;オプショナル要件&lt;/e0&gt;をプロトコルに対して定義できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can define Swift enumerations to store associated values of any given type, and the value types can be different for each case of the enumeration if needed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはスウィフト列挙を、どんな与えられた型の関連値でも格納するように定義することができます、そして値の型は列挙のケース節それぞれで異なっていることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can define a &lt;e0&gt;default value&lt;/e0&gt; for any parameter in a function by assigning a value to the parameter after that parameter’s type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ある関数のすべてのパラメータに対して&lt;e0&gt;省略時の値&lt;/e0&gt;を定義することが、そのパラメーターの型の後でパラメーターに値を割り当てることによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can define a common set of related cases as part of one enumeration, each of which has a different set of values of appropriate types associated with it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、１つの列挙の一部として、関連したケース節のよくある集合を定義することができます、そのそれぞれはそれと結びつけられる適切な型の値の集合をそれぞれ別に持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can define a convenience initializer to call a designated initializer from the same class as the convenience initializer with some of the designated initializer’s parameters set to default values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ある便宜イニシャライザを定義して、同じクラスからある指定イニシャライザをその便宜イニシャライザとして呼び出し、その指定イニシャライザのパラメータのいくつかを省略時の値に設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can define anything from a simple utility function with a single unnamed parameter to a complex function with expressive parameter names and different parameter options.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ただ１つの無名のパラメータを持つ単純で便利な支援関数から、表現豊かなパラメータ名と種々のパラメータ・オプションを持つ複雑な関数まで何でも定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can define multiple related variables of the same type on a single line, separated by commas, with a single type annotation after the final variable name:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは同じ型の複数の関連した変数を、１行上に、コンマで区切って、型注釈を１つだけ最後の変数名の後につけて、定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can define multiple subscripts for a single type, and the appropriate subscript overload to use is selected based on the type of index value you pass to the subscript.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは１つの型のために複数の添え字を定義することができます、そしてあなたが添え字に渡すインデックス値の型に基づいて、使うのに適切な添え字のオーバーロードが選択されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can define your own type constraints when creating custom generic types, and these constraints provide much of the power of generic programming.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、独自の型制約をあつらえの総称体型を作成する時に定義することができます、そして、それらの制約は総称体プログラミングの力の多くを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can delegate from &lt;c0&gt;&lt;s1&gt;init?&lt;/s1&gt;&lt;/c0&gt; to &lt;c2&gt;&lt;s3&gt;init!&lt;/s3&gt;&lt;/c2&gt; and vice versa, and you can override &lt;c4&gt;&lt;s5&gt;init?&lt;/s5&gt;&lt;/c4&gt; with &lt;c6&gt;&lt;s7&gt;init!&lt;/s7&gt;&lt;/c6&gt; and vice versa.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;init?&lt;/s1&gt;&lt;/c0&gt;から&lt;c2&gt;&lt;s3&gt;init!&lt;/s3&gt;&lt;/c2&gt;への委任およびその逆が行えます、そしてあなたは&lt;c4&gt;&lt;s5&gt;init?&lt;/s5&gt;&lt;/c4&gt;を&lt;c6&gt;&lt;s7&gt;init!&lt;/s7&gt;&lt;/c6&gt;でオーバーライドすること、およびその逆もできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can do this even if that method does not define a return value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえそのメソッドが戻り値を定義しないとしても、あなたはこれをすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can drill down into subproperties, such as the &lt;c0&gt;&lt;s1&gt;width&lt;/s1&gt;&lt;/c0&gt; property in the &lt;c2&gt;&lt;s3&gt;resolution&lt;/s3&gt;&lt;/c2&gt; property of a &lt;c4&gt;&lt;s5&gt;VideoMode&lt;/s5&gt;&lt;/c4&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、下位プロパティへと掘り下っていくことができます、例えば、ある&lt;c4&gt;&lt;s5&gt;VideoMode&lt;/s5&gt;&lt;/c4&gt;の&lt;c2&gt;&lt;s3&gt;resolution&lt;/s3&gt;&lt;/c2&gt;プロパティの中の&lt;c0&gt;&lt;s1&gt;width&lt;/s1&gt;&lt;/c0&gt;プロパティ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can efficiently perform fundamental set operations, such as combining two sets together, determining which values two sets have in common, or determining whether two sets contain all, some, or none of the same values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは効率的に基本的な集合演算を実行することができます、例えば２つの集合を１つに結合する、２つの集合が共通して持つ値はどれか決定する、または２つの集合が同じ値のすべて、いくつか、または全く含まないかどうかを決定するなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can explicitly add the &lt;c2&gt;&lt;s3&gt;objc&lt;/s3&gt;&lt;/c2&gt; attribute to a subclass that meets these criteria, to specify its Objective-C name as discussed below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、明示的に&lt;c2&gt;&lt;s3&gt;objc&lt;/s3&gt;&lt;/c2&gt;属性をこの基準に合うサブクラスに適用して、下で議論されるように、それのObjective-C名を指定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can extend a class, structure, or enumeration in any access context in which the class, structure, or enumeration is available.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あるクラス、構造体、または列挙を拡張することが、そこにおいてそのクラス、構造体、または列挙が利用可能であるあらゆるアクセス文脈において可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can extend a generic type to conditionally conform to a protocol, so that instances of the type conform to the protocol only when certain requirements are met.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、条件付きでプロトコルに準拠するように総称体型を拡張できます、それでその型のインスタンスは特定の要件が満たされた場合にのみそのプロトコルに準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can extend an existing type to add conformance to a protocol, as described in &lt;a0&gt;&lt;s1&gt;Adding Protocol Conformance with an Extension&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;a0&gt;&lt;s1&gt;拡張を使ってプロトコル準拠を加える&lt;/s1&gt;&lt;/a0&gt;で記述されるように、既存の型を拡張することでプロトコルへの準拠を加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can extend an existing type to adopt and conform to a new protocol, even if you don’t have access to the source code for the existing type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ある新しいプロトコルを採用して準拠することで既存の型を拡張することができます、たとえあなたが既存の型のソース・コードにアクセスをしないとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can extend the &lt;c0&gt;&lt;s1&gt;Rect&lt;/s1&gt;&lt;/c0&gt; structure to provide an additional initializer that takes a specific center point and size:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;Rect&lt;/s1&gt;&lt;/c0&gt;構造体を拡張して、特定の中心点と大きさをとる追加のイニシャライザを提供することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can extend the behavior of a class type with an extension declaration, as discussed in &lt;a0&gt;&lt;s1&gt;Extension Declaration&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはクラス型の挙動を拡張宣言を使って拡張することができます、&lt;a0&gt;&lt;s1&gt;拡張宣言&lt;/s1&gt;&lt;/a0&gt;で議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can extend the behavior of a structure type with an extension declaration, as discussed in &lt;a0&gt;&lt;s1&gt;Extension Declaration&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは構造体型の挙動を拡張宣言を使って拡張することができます、&lt;a0&gt;&lt;s1&gt;拡張宣言&lt;/s1&gt;&lt;/a0&gt;で議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can extend the behavior of an enumeration type with an extension declaration, as discussed in &lt;a0&gt;&lt;s1&gt;Extension Declaration&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは列挙型の挙動を拡張宣言を使って拡張することができます、&lt;a0&gt;&lt;s1&gt;拡張宣言&lt;/s1&gt;&lt;/a0&gt;で議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can fit two &lt;c0&gt;&lt;s1&gt;4&lt;/s1&gt;&lt;/c0&gt;s inside &lt;c2&gt;&lt;s3&gt;9&lt;/s3&gt;&lt;/c2&gt;, and the remainder is &lt;c4&gt;&lt;s5&gt;1&lt;/s5&gt;&lt;/c4&gt; (shown in orange).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは２つの&lt;c0&gt;&lt;s1&gt;4&lt;/s1&gt;&lt;/c0&gt;を&lt;c2&gt;&lt;s3&gt;9&lt;/s3&gt;&lt;/c2&gt;の内部に収めることができます、そして余りは&lt;c4&gt;&lt;s5&gt;1&lt;/s5&gt;&lt;/c4&gt;です（オレンジ色で示されます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can give a setter a &lt;e0&gt;lower&lt;/e0&gt; access level than its corresponding getter, to restrict the read-write scope of that variable, property, or subscript.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、セッターにその対応するゲッターよりも&lt;e0&gt;より低い&lt;/e0&gt;アクセス水準を与えて、その変数、プロパティ、または添え字の読み書きのスコープを制限することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can implement a protocol initializer requirement on a conforming class as either a designated initializer or a convenience initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、イニシャライザ要件プロトコルを準拠クラス上で指定イニシャライザまたは便宜イニシャライザとして実装することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can include a generic &lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt; clause on an associated type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、総称体&lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt;節を関連型に関して含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can include additional spaces and tabs after that indentation; those spaces and tabs appear in the string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、追加の空白とタブをその字下げの後に含めることができます；それらの空白とタブは文字列の中に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can include as many optional bindings and Boolean conditions in a single &lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt; statement as you need to, separated by commas.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、単一の&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt;文の中に、コンマで区切ったオプショナル束縛とブール条件をあなたが必要とするだけ多く含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can include labels in a dynamic method call if you implement the &lt;c0&gt;&lt;s1&gt;dynamicallyCall(withKeywordArguments:)&lt;/s1&gt;&lt;/c0&gt; method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、いくつかのラベルを動的メソッド呼び出しに含めることができます、もしあなたが&lt;c0&gt;&lt;s1&gt;dynamicallyCall(withKeywordArguments:)&lt;/s1&gt;&lt;/c0&gt;メソッドを実装するならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can include multiple requirements in a generic &lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt; clause that is part of an extension, just like you can for a generic &lt;c2&gt;&lt;s3&gt;where&lt;/s3&gt;&lt;/c2&gt; clause that you write elsewhere.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、複数の要件を拡張の一部であるひとつの&lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt;節の中に含めることができます、ちょうどあなたがどこか他で書く総称体&lt;c2&gt;&lt;s3&gt;where&lt;/s3&gt;&lt;/c2&gt;節に対してできるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can include predefined &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; values within your code as &lt;e2&gt;string literals&lt;/e2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あらかじめ定義された&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;値を&lt;e2&gt;文字列リテラル&lt;/e2&gt;としてあなたのコードの内部に含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can initialize the &lt;c0&gt;&lt;s1&gt;Rect&lt;/s1&gt;&lt;/c0&gt; structure below in one of three ways—by using its default zero-initialized &lt;c2&gt;&lt;s3&gt;origin&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;size&lt;/s5&gt;&lt;/c4&gt; property values, by providing a specific origin point and size, or by providing a specific center point and size.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、以下の&lt;c0&gt;&lt;s1&gt;Rect&lt;/s1&gt;&lt;/c0&gt;構造体を３つの方法のうちの１つで初期化することができます ― それの省略時の０で初期化された&lt;c2&gt;&lt;s3&gt;origin&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;size&lt;/s5&gt;&lt;/c4&gt;プロパティ値を使うことによって、特定の原点とサイズを提供することによって、または特定の中心点とサイズを提供することによって。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can iterate over the entire set of values in an array with the &lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt; loop:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt;ループを使って配列中の値ひとそろい全部に渡って繰り返すことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can iterate over the key-value pairs in a dictionary with a &lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt; loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt;ループを使って、ある辞書の中の「キーと値」のすべてに対して操作を繰り返し適用していくことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can iterate over the string with a &lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt; statement, to access its individual &lt;c4&gt;&lt;s5&gt;Character&lt;/s5&gt;&lt;/c4&gt; values as Unicode extended grapheme clusters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは文字列の全体にわたって&lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt;文を使って繰り返すことができます、それでユニコードの拡張書記素クラスタとしてのそれの個々の&lt;c4&gt;&lt;s5&gt;Character&lt;/s5&gt;&lt;/c4&gt;値にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can iterate over the values in a set with a &lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt; loop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは集合の中の値すべてに渡って繰り返しすることが&lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt;ループによって行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can keep an index in a loop by using &lt;c0&gt;&lt;s1&gt;..&lt;&lt;/s1&gt;&lt;/c0&gt; to make a range of indexes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、インデックス（索引）をループにおいて保持することが、&lt;c0&gt;&lt;s1&gt;..&lt;&lt;/s1&gt;&lt;/c0&gt;を使ってインデックスの範囲を作ることで可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can limit protocol adoption to class types (and not structures or enumerations) by adding the &lt;c0&gt;&lt;s1&gt;AnyObject&lt;/s1&gt;&lt;/c0&gt; protocol to a protocol’s inheritance list.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、プロトコル採用をクラス型に制限する（つまり構造体や列挙で採用しない）ことが&lt;c0&gt;&lt;s1&gt;AnyObject&lt;/s1&gt;&lt;/c0&gt;プロトコルをプロトコルのもつ継承リストに加えることによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can link together multiple levels of optional chaining to drill down to properties, methods, and subscripts deeper within a model.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、オプショナル連鎖の複数の階層を結びつけて、あるモデル内のより深いプロパティ、メソッド、そして添え字に掘り下げていくことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can list as many protocols as you need, separating them with ampersands (&lt;c4&gt;&lt;s5&gt;&amp;&lt;/s5&gt;&lt;/c4&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あなたが必要とするだけ多くのプロトコルを、それらをアンパサンド（&lt;c4&gt;&lt;s5&gt;&amp;&lt;/s5&gt;&lt;/c4&gt;）で隔てて列記できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can make a generic type conditionally conform to a protocol by listing constraints when extending the type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ある総称体型を条件付きでプロトコルに準拠させることが、その型を拡張する時に制約を列記することによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can make generic forms of functions and methods, as well as classes, enumerations, and structures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは関数やメソッドだけでなく、クラス、列挙、そして構造体も総称体の形式にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can make the structure’s &lt;c4&gt;&lt;s5&gt;numberOfEdits&lt;/s5&gt;&lt;/c4&gt; property getter public, and its property setter private, by combining the &lt;c6&gt;&lt;s7&gt;public&lt;/s7&gt;&lt;/c6&gt; and &lt;c8&gt;&lt;s9&gt;private(set)&lt;/s9&gt;&lt;/c8&gt; access-level modifiers:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、この構造体の&lt;c4&gt;&lt;s5&gt;numberOfEdits&lt;/s5&gt;&lt;/c4&gt;プロパティゲッターを公開に、そしてそれのプロパティセッターを非公開にすることが、&lt;c6&gt;&lt;s7&gt;public&lt;/s7&gt;&lt;/c6&gt;と&lt;c8&gt;&lt;s9&gt;private(set)&lt;/s9&gt;&lt;/c8&gt;アクセス水準修飾子を組み合わせることによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can mark a declaration with one of the access-level modifiers below to specify the declaration’s access level.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、宣言を以下のアクセス水準修飾子のうちの１つで印して、その宣言のアクセス水準を指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can mark an entire class as final by writing the &lt;c0&gt;&lt;s1&gt;final&lt;/s1&gt;&lt;/c0&gt; modifier before the &lt;c2&gt;&lt;s3&gt;class&lt;/s3&gt;&lt;/c2&gt; keyword in its class definition (&lt;c4&gt;&lt;s5&gt;final&lt;/s5&gt; &lt;s6&gt;class&lt;/s6&gt;&lt;/c4&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、そのクラス定義において&lt;c2&gt;&lt;s3&gt;class&lt;/s3&gt;&lt;/c2&gt;キーワードの前に&lt;c0&gt;&lt;s1&gt;final&lt;/s1&gt;&lt;/c0&gt;修飾子を書くことによって（&lt;c4&gt;&lt;s5&gt;final&lt;/s5&gt; &lt;s6&gt;class&lt;/s6&gt;&lt;/c4&gt;）、そのクラス全体を最終版として印することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can mark designated and convenience initializers with the &lt;c0&gt;&lt;s1&gt;required&lt;/s1&gt;&lt;/c0&gt; declaration modifier to require that every subclass implement the initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは指定および便宜イニシャライザを&lt;c0&gt;&lt;s1&gt;required&lt;/s1&gt;&lt;/c0&gt;宣言修飾子で印して、全てのサブクラスがそのイニシャライザを実装することが必須であるようにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can match individual enumeration values with a &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; statement:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;文を使って個々の列挙値を照合することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can mix and match components of key paths to access values that are deeply nested within a type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、キーパスの構成要素をうまく組み合わせることで、ある型の内部に深く入れ子にされた値にアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can name the individual elements in a tuple when the tuple is defined:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、タプルの個々の要素に名前をつけることが、そのタプルが定義される時に可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can name the parameter or use the default parameter name of &lt;c2&gt;&lt;s3&gt;oldValue&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはパラメータに名をつけること、または省略時のパラメータ名の&lt;c2&gt;&lt;s3&gt;oldValue&lt;/s3&gt;&lt;/c2&gt;を使うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can nest labeled statements, but the name of each statement label must be unique.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはラベルをつけられた文を入れ子にすることができます、しかし、各文ラベルの名前は特有でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can now call the assigned function with the name &lt;c0&gt;&lt;s1&gt;mathFunction&lt;/s1&gt;&lt;/c0&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、今や、代入された関数を名前&lt;c0&gt;&lt;s1&gt;mathFunction&lt;/s1&gt;&lt;/c0&gt;を使って呼ぶことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can now create a &lt;c0&gt;&lt;s1&gt;Customer&lt;/s1&gt;&lt;/c0&gt; instance, and use it to initialize and assign a new &lt;c2&gt;&lt;s3&gt;CreditCard&lt;/s3&gt;&lt;/c2&gt; instance as that customer’s &lt;c4&gt;&lt;s5&gt;card&lt;/s5&gt;&lt;/c4&gt; property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、現在&lt;c0&gt;&lt;s1&gt;Customer&lt;/s1&gt;&lt;/c0&gt;インスタンスを作成して、それを使って、新しい&lt;c2&gt;&lt;s3&gt;CreditCard&lt;/s3&gt;&lt;/c2&gt;インスタンスを、その顧客の&lt;c4&gt;&lt;s5&gt;card&lt;/s5&gt;&lt;/c4&gt;プロパティとして初期化して代入することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can now create a new &lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt; instance and assign it to one of these three variables:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、いま新しい&lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt;インスタンスを作成して、それをこれらの３つの変数のうちの１つに代入することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can now create a specific &lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt; instance and &lt;c2&gt;&lt;s3&gt;Apartment&lt;/s3&gt;&lt;/c2&gt; instance and assign these new instances to the &lt;c4&gt;&lt;s5&gt;john&lt;/s5&gt;&lt;/c4&gt; and &lt;c6&gt;&lt;s7&gt;unit4A&lt;/s7&gt;&lt;/c6&gt; variables:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、今や特定の&lt;c0&gt;&lt;s1&gt;Person&lt;/s1&gt;&lt;/c0&gt;インスタンスと&lt;c2&gt;&lt;s3&gt;Apartment&lt;/s3&gt;&lt;/c2&gt;インスタンスを作成して、それらの新しいインスタンスを&lt;c4&gt;&lt;s5&gt;john&lt;/s5&gt;&lt;/c4&gt;および&lt;c6&gt;&lt;s7&gt;unit4A&lt;/s7&gt;&lt;/c6&gt;変数に代入することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can now link the two instances together so that the person has an apartment, and the apartment has a tenant.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは次に人がアパートを持つように、２つのインスタンスを結びつけることができます、するとアパートには賃借人があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can now try to set a property’s value, assign to a subscript, or call a mutating method or operator through &lt;a0&gt;&lt;s1&gt;Optional Chaining&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは今では&lt;a0&gt;&lt;s1&gt;オプショナル連鎖&lt;/s1&gt;&lt;/a0&gt;を通して、プロパティの値を設定する、ある添え字に代入する、または変更メソッドまたは演算子を呼び出すことを試みることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can now use &lt;c0&gt;&lt;s1&gt;chooseStepFunction(backward:)&lt;/s1&gt;&lt;/c0&gt; to obtain a function that will step in one direction or the other:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>現在あなたは&lt;c0&gt;&lt;s1&gt;chooseStepFunction(backward:)&lt;/s1&gt;&lt;/c0&gt;を使って、ある方向にまたはもう一方に進む関数を取得できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can now use the &lt;c0&gt;&lt;s1&gt;numbers&lt;/s1&gt;&lt;/c0&gt; array to create an array of &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt; values, by passing a closure expression to the array’s &lt;c4&gt;&lt;s5&gt;map(_:)&lt;/s5&gt;&lt;/c4&gt; method as a trailing closure:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、現在、この&lt;c0&gt;&lt;s1&gt;numbers&lt;/s1&gt;&lt;/c0&gt;配列を&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;値の配列をつくるために使うことが、あるクロージャ式を配列の&lt;c4&gt;&lt;s5&gt;map(_:)&lt;/s5&gt;&lt;/c4&gt;メソッドに後付クロージャとして渡すことによって、可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can now use this operator to check whether two &lt;c0&gt;&lt;s1&gt;Vector2D&lt;/s1&gt;&lt;/c0&gt; instances are equivalent:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、今ではこの演算子を使って２つの&lt;c0&gt;&lt;s1&gt;Vector2D&lt;/s1&gt;&lt;/c0&gt;インスタンスが等しいかどうか調べられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can omit either property or both properties, and the initializer uses the default value for anything you omit—for example:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、どちらかのプロパティまたは両方のプロパティを省略できます、そしてイニシャライザは省略時の値をあなたが省略するどんなものにも使います — 例えば：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can omit the assertion message—for example, when it would just repeat the condition as prose.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは表明メッセージを省略できます — 例えば、それが単に条件を単調に繰り返す場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can only call a dynamically callable instance with arguments and a return value that match the types you specify in one of your &lt;c0&gt;&lt;s1&gt;dynamicallyCall&lt;/s1&gt;&lt;/c0&gt; method implementations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは動的callableインスタンスを、あなたの&lt;c0&gt;&lt;s1&gt;dynamicallyCall&lt;/s1&gt;&lt;/c0&gt;メソッド実装の１つにおいてあなたが指定する型に合致する引数いくつかと戻り値ひとつで呼び出せるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can only pass a variable as the argument for an in-out parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、in-outパラメータに対する引数として、変数を渡すことだけができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can opt in to this behavior by placing the &lt;c0&gt;&lt;s1&gt;mutating&lt;/s1&gt;&lt;/c0&gt; keyword before the &lt;c2&gt;&lt;s3&gt;func&lt;/s3&gt;&lt;/c2&gt; keyword for that method:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、そのメソッドのための&lt;c2&gt;&lt;s3&gt;func&lt;/s3&gt;&lt;/c2&gt;キーワードの前に&lt;c0&gt;&lt;s1&gt;mutating&lt;/s1&gt;&lt;/c0&gt;キーワードを置くことによってこの挙動を取り入れることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can opt in to value overflow behavior by using Swift’s overflow operators (such as &lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt; &lt;s2&gt;&amp;+&lt;/s2&gt; &lt;s3&gt;b&lt;/s3&gt;&lt;/c0&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、スウィフトのオーバフロー演算子を使用することによって、値オーバフロー挙動を選ぶことが可能です（例えば&lt;c0&gt;&lt;s1&gt;a&lt;/s1&gt; &lt;s2&gt;&amp;+&lt;/s2&gt; &lt;s3&gt;b&lt;/s3&gt;&lt;/c0&gt;のように）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can opt in to value overflow behavior by using Swift’s overflow operators, as described in &lt;a14&gt;&lt;s15&gt;Overflow Operators&lt;/s15&gt;&lt;/a14&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a14&gt;&lt;s15&gt;オーバフロー演算子&lt;/s15&gt;&lt;/a14&gt;で記述されるように、あなたは、スウィフトのもつオーバフロー演算子を使うことによって、値オーバフロー挙動を選ぶことが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can overload a generic function or initializer by providing different constraints, requirements, or both on the type parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、総称体の関数やイニシャライザをオーバーロードすることが、異なる制約、要件、または両方を型パラメータ上で提供することによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can overload a subscript declaration in the type in which it is declared, as long as the &lt;e0&gt;parameters&lt;/e0&gt; or the &lt;e1&gt;return type&lt;/e1&gt; differ from the one you’re overloading.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ある添え字宣言を、そこにおいてそれが宣言される型においてオーバーロードすることができます、&lt;e0&gt;パラメーター&lt;/e0&gt;または&lt;e1&gt;戻り型&lt;/e1&gt;があなたがオーバーロードしているものと異なる限りはです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can overload the &lt;c0&gt;&lt;s1&gt;~=&lt;/s1&gt;&lt;/c0&gt; operator to provide custom expression matching behavior.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;~=&lt;/s1&gt;&lt;/c0&gt;演算子をオーバーロードして、あつらえの式マッチング挙動を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can override a failable initializer with a nonfailable initializer but not the other way around.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは失敗できるイニシャライザを、失敗できないイニシャライザでオーバーライドできます、しかし逆はできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can override a nonreturning method, but the new method must preserve its return type and nonreturning behavior.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは非復帰メソッドをオーバーライドすることができます、しかし新しいメソッドはそれの戻り型と非復帰挙動を維持しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can override a property in a subclass by marking the subclass’s property declaration with the &lt;c0&gt;&lt;s1&gt;override&lt;/s1&gt;&lt;/c0&gt; declaration modifier, as described in &lt;a2&gt;&lt;s3&gt;Overriding&lt;/s3&gt;&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;a2&gt;&lt;s3&gt;オーバーライド&lt;/s3&gt;&lt;/a2&gt;で記述されるように、サブクラスのプロパティ宣言を&lt;c0&gt;&lt;s1&gt;override&lt;/s1&gt;&lt;/c0&gt;宣言修飾子で印することによってサブクラスの中のプロパティをオーバーライドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can override a superclass failable initializer in a subclass, just like any other initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、スーパークラスの失敗できるイニシャライザをサブクラスにおいてオーバーライドすることが、何らかの他のイニシャライザとまったく同じようにできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can override an inherited instance or type method to provide a tailored or alternative implementation of the method within your subclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ある継承されたインスタンスまたは型メソッドをオーバーライドすることで、あなたのサブクラス内部でそのメソッドの特注のまたは代替の実装を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can override an inherited instance or type property to provide your own custom getter and setter for that property, or to add property observers to enable the overriding property to observe when the underlying property value changes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは継承されたインスタンスまたは型プロパティをオーバーライドして、そのプロパティのためにあなた独自のあつらえのゲッターとセッターを用意したり、根底にあるプロパティ値がいつ変化するか監視することをオーバーライドしているプロパティに可能にするプロパティオブザーバーを加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can override the default behavior for argument labels with one of the following forms:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは引数ラベルに対する初期状態の挙動をオーバーライドすることが以下の形式の１つで可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can override this default behavior by marking the declaration with an access-level modifier, as described in &lt;a0&gt;&lt;s1&gt;Access Control Levels&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;a0&gt;&lt;s1&gt;アクセス制御ラベル&lt;/s1&gt;&lt;/a0&gt;で記述されるように、この初期状態のふるまいをその宣言をアクセス水準修飾子で印することによってオーバーライドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can pass a value of any conforming type in to this parameter when initializing a new &lt;c6&gt;&lt;s7&gt;Dice&lt;/s7&gt;&lt;/c6&gt; instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい&lt;c6&gt;&lt;s7&gt;Dice&lt;/s7&gt;&lt;/c6&gt;インスタンスを初期化するとき、あなたはどんな準拠型の値でもこのパラメータに渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can pass any function of that type as the argument for this first parameter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、この最初のパラメータに対する引数として、その型のどんな関数でも渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can place a string literal within &lt;e0&gt;extended delimiters&lt;/e0&gt; to include special characters in a string without invoking their effect.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、文字列リテラルを&lt;e0&gt;拡張区切り記号&lt;/e0&gt;内に置くことで、いくらかの特殊文字を文字列の中にそれらの効果を発動することなしに含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can prefix a loop statement, an &lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt; statement, a &lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt; statement, or a &lt;c4&gt;&lt;s5&gt;do&lt;/s5&gt;&lt;/c4&gt; statement with a &lt;e6&gt;statement label&lt;/e6&gt;, which consists of the name of the label followed immediately by a colon (:).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはループ文、&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt;文、&lt;c2&gt;&lt;s3&gt;switch&lt;/s3&gt;&lt;/c2&gt;文、または&lt;c4&gt;&lt;s5&gt;do&lt;/s5&gt;&lt;/c4&gt;文の前に&lt;e6&gt;文ラベル&lt;/e6&gt;を置くことができます、それは、ラベルの名前とそれに直ちに続くコロン（:）から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can present an inherited read-only property as a read-write property by providing both a getter and a setter in your subclass property override.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのサブクラスプロパティオーバーライドにおいてゲッターとセッターの両方を提供することによって、あなたは継承された読み出し専用のプロパティを、読み書き両用のプロパティとして提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can prevent a method, property, or subscript from being overridden by marking it as &lt;e0&gt;final&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはメソッド、プロパティ、または添え字がオーバーライドされるのを、それを&lt;e0&gt;最終版（final）&lt;/e0&gt;と印することによって妨げることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can print the current value of a constant or variable with the &lt;c0&gt;&lt;s1&gt;print(_:separator:terminator:)&lt;/s1&gt;&lt;/c0&gt; function:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;print(_:separator:terminator:)&lt;/s1&gt;&lt;/c0&gt;関数で定数または変数の現在の値を出力することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can propagate the error from a function to the code that calls that function, handle the error using a &lt;c0&gt;&lt;s1&gt;do&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;catch&lt;/s3&gt;&lt;/c2&gt; statement, handle the error as an optional value, or assert that the error will not occur.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、エラーを関数からその関数を呼び出しているコードに伝えて、そのエラーを&lt;c0&gt;&lt;s1&gt;do&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;catch&lt;/s3&gt;&lt;/c2&gt;文を使って取り扱う、エラーをオプショナルとして取り扱う、またはそのエラーは起こらないことを表明することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can provide &lt;e0&gt;initialization parameters&lt;/e0&gt; as part of an initializer’s definition, to define the types and names of values that customize the initialization process.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、イニシャライザの定義の一部として&lt;e0&gt;初期化パラメータ&lt;/e0&gt;を提供することができます、それによって初期化処理をカスタマイズする値の型と名前を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can provide a &lt;e0&gt;type annotation&lt;/e0&gt; when you declare a constant or variable, to be clear about the kind of values the constant or variable can store.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あなたが定数または変数を宣言するとき、その定数または変数が格納することができる値の種類について明確にするために、&lt;e0&gt;型注釈&lt;/e0&gt;を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can provide a custom getter (and setter, if appropriate) to override &lt;e0&gt;any&lt;/e0&gt; inherited property, regardless of whether the inherited property is implemented as a stored or computed property at source.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あつらえのゲッターを（そして適切ならば、セッターも）提供することで、&lt;e0&gt;あらゆる&lt;/e0&gt;継承されたプロパティをオーバーライドできます、継承されたプロパティがその発生源で格納プロパティもしくは計算プロパティとして実装されるかは関係しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can provide a default value for a stored property as part of its definition, as described in &lt;a0&gt;&lt;s1&gt;Default Property Values&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a0&gt;&lt;s1&gt;省略時のプロパティ値&lt;/s1&gt;&lt;/a0&gt;で記述されるように、あなたは格納プロパティのために省略時の値をその定義の一部として用意することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can provide an explicit name in parentheses after &lt;c4&gt;&lt;s5&gt;set&lt;/s5&gt;&lt;/c4&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c4&gt;&lt;s5&gt;set&lt;/s5&gt;&lt;/c4&gt;の後に括弧の中ではっきりとした名前を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can provide more than one type parameter by writing multiple type parameter names within the angle brackets, separated by commas.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、山形括弧内に複数の型パラメータ名をコンマで区切って書くことによって、複数の型パラメータを提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can provide multiple &lt;c0&gt;&lt;s1&gt;catch&lt;/s1&gt;&lt;/c0&gt; blocks that handle specific errors.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、それぞれが特定のエラーを取り扱う複数の&lt;c0&gt;&lt;s1&gt;catch&lt;/s1&gt;&lt;/c0&gt;ブロックを提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can provide whatever arguments you need to the attribute, and they’re passed to the initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、どんなものでもあなたが必要とする引数それらを属性に提供できます、そしてそれらはイニシャライザに渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can put parentheses around a named type or a compound type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、名前付きの型や複合の型の周りに丸括弧を置くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can query the &lt;c0&gt;&lt;s1&gt;threeTimesTable&lt;/s1&gt;&lt;/c0&gt; instance by calling its subscript, as shown in the call to &lt;c2&gt;&lt;s3&gt;threeTimesTable[6]&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;threeTimesTable&lt;/s1&gt;&lt;/c0&gt;インスタンスにその添え字を呼ぶことによって問い合わせることが&lt;c2&gt;&lt;s3&gt;threeTimesTable[6]&lt;/s3&gt;&lt;/c2&gt;への呼び出しで示されるように可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can read this code as:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、このコードを次のように読むことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can refer to parameters by number instead of by name—this approach is especially useful in very short closures.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、名前によってでなく、数によってパラメータに言及することができます ― この取り組み方は、特に非常に短いクロージャで役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can remove an item from a set by calling the set’s &lt;c0&gt;&lt;s1&gt;remove(_:)&lt;/s1&gt;&lt;/c0&gt; method, which removes the item if it’s a member of the set, and returns the removed value, or returns &lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt; if the set did not contain it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはある項目を集合から取り除くことが集合の&lt;c0&gt;&lt;s1&gt;remove(_:)&lt;/s1&gt;&lt;/c0&gt;メソッドを呼ぶことによって行えます、それは、その項目をそれが集合のメンバーであるならば取り除きます、そして取り除かれた項目を返します、または集合がそれを含まないならば&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can revise the &lt;c0&gt;&lt;s1&gt;SurveyQuestion&lt;/s1&gt;&lt;/c0&gt; example from above to use a constant property rather than a variable property for the &lt;c2&gt;&lt;s3&gt;text&lt;/s3&gt;&lt;/c2&gt; property of the question, to indicate that the question does not change once an instance of &lt;c4&gt;&lt;s5&gt;SurveyQuestion&lt;/s5&gt;&lt;/c4&gt; is created.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、上記の&lt;c0&gt;&lt;s1&gt;SurveyQuestion&lt;/s1&gt;&lt;/c0&gt;例を、変数プロパティではなく定数プロパティを質問の&lt;c2&gt;&lt;s3&gt;text&lt;/s3&gt;&lt;/c2&gt;プロパティのために使うように見直して、その質問は一旦&lt;c4&gt;&lt;s5&gt;SurveyQuestion&lt;/s5&gt;&lt;/c4&gt;のインスタンスが作成されるならば変化しないことを示すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can rewrite the &lt;c0&gt;&lt;s1&gt;TemperatureUnit&lt;/s1&gt;&lt;/c0&gt; example from above to use raw values of type &lt;c2&gt;&lt;s3&gt;Character&lt;/s3&gt;&lt;/c2&gt; and to take advantage of the &lt;c4&gt;&lt;s5&gt;init?(rawValue:)&lt;/s5&gt;&lt;/c4&gt; initializer:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、上の&lt;c0&gt;&lt;s1&gt;TemperatureUnit&lt;/s1&gt;&lt;/c0&gt;例を&lt;c2&gt;&lt;s3&gt;Character&lt;/s3&gt;&lt;/c2&gt;型の生の値を使うように、そして&lt;c4&gt;&lt;s5&gt;init?(rawValue:)&lt;/s5&gt;&lt;/c4&gt;イニシャライザを活用するように書き直すことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can rewrite the &lt;c0&gt;&lt;s1&gt;chooseStepFunction(backward:)&lt;/s1&gt;&lt;/c0&gt; example above to use and return nested functions:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、入れ子にされた関数を使用して返すように、上記の&lt;c0&gt;&lt;s1&gt;chooseStepFunction(backward:)&lt;/s1&gt;&lt;/c0&gt;の例を書き直すことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can rewrite the &lt;c0&gt;&lt;s1&gt;possibleNumber&lt;/s1&gt;&lt;/c0&gt; example from the &lt;a2&gt;&lt;s3&gt;Optionals&lt;/s3&gt;&lt;/a2&gt; section to use optional binding rather than forced unwrapping:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは&lt;a2&gt;&lt;s3&gt;オプショナル&lt;/s3&gt;&lt;/a2&gt;節の&lt;c0&gt;&lt;s1&gt;possibleNumber&lt;/s1&gt;&lt;/c0&gt;例を、強制アンラップではなくて、オプショナル束縛を使うように書き直すことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can see a similar problem by thinking about how you update a budget that’s written on a piece of paper.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、一片の紙に書かれる予算案を更新する方法について考えることによって、同種の問題を調べられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can set a constant or variable to &lt;c0&gt;&lt;s1&gt;Planet.earth&lt;/s1&gt;&lt;/c0&gt;, and check for this value later.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、定数または変数を&lt;c0&gt;&lt;s1&gt;Planet.earth&lt;/s1&gt;&lt;/c0&gt;に設定することができて、後でその値について調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can set a value in a dictionary by providing a key of the dictionary’s key type within subscript brackets, and assigning a value of the dictionary’s value type to the subscript:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、添え字角括弧内にその辞書のキー型のキーを提供し、そしてその添え字に辞書の値型の値を代入することによって、値を辞書に設定することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can set an initial value for a stored property within an initializer, or by assigning a default property value as part of the property’s definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、イニシャライザの内部で、またはそのプロパティの定義の一部として省略時のプロパティの値を代入することによって、格納プロパティのために初期値を設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can set the &lt;c2&gt;&lt;s3&gt;hasBasket&lt;/s3&gt;&lt;/c2&gt; property to &lt;c4&gt;&lt;s5&gt;true&lt;/s5&gt;&lt;/c4&gt; for a particular &lt;c6&gt;&lt;s7&gt;Bicycle&lt;/s7&gt;&lt;/c6&gt; instance after that instance is created:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、特定の&lt;c6&gt;&lt;s7&gt;Bicycle&lt;/s7&gt;&lt;/c6&gt;インスタンスに対して&lt;c2&gt;&lt;s3&gt;hasBasket&lt;/s3&gt;&lt;/c2&gt;プロパティを&lt;c4&gt;&lt;s5&gt;true&lt;/s5&gt;&lt;/c4&gt;に設定することが、そのインスタンスを作成した後で行えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can set the initial value of a stored property from within an initializer, as shown above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはイニシャライザ内から格納プロパティの初期値を設定することが、上で示されるように、行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can simplify the declaration of a read-only computed property by removing the &lt;c0&gt;&lt;s1&gt;get&lt;/s1&gt;&lt;/c0&gt; keyword and its braces:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、読み出し専用の計算プロパティの宣言を&lt;c0&gt;&lt;s1&gt;get&lt;/s1&gt;&lt;/c0&gt;キーワードとそれの波括弧を取り除くことによって単純化することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can specify a name for this parameter as part of your &lt;c2&gt;&lt;s3&gt;willSet&lt;/s3&gt;&lt;/c2&gt; implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あなたの&lt;c2&gt;&lt;s3&gt;willSet&lt;/s3&gt;&lt;/c2&gt;実装の一部としてこのパラメータに名前を指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can specify a type annotation for these patterns to constrain them to match only values of a certain type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは型注釈をこれらのパターンに指定して、それらがある特定の型の値だけにマッチするように制約を加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can specify additional requirements on type parameters and their associated types by including a generic &lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt; clause right before the opening curly brace of a type or function’s body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、追加の要件を型パラメータおよびそれの関連型に指定することが総称体&lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt;節を型または関数の本文の開き波括弧のまさに前に含めることによって行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can subclass any class that can be accessed in the current access context and that’s defined in the same module as the subclass.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、現在のアクセス前後関係においてアクセスされることが出来るどんなクラスにでもサブクラスを作れます、それは同じモジュールの中でサブクラスとして定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can tell that the &lt;c0&gt;&lt;s1&gt;createAddress()&lt;/s1&gt;&lt;/c0&gt; function isn’t called, because nothing is printed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;createAddress()&lt;/s1&gt;&lt;/c0&gt;関数が呼ばれなかったと言うことができます、なぜなら何も出力されなかったからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can then create new barcodes using either type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはそれから新しいバーコードをどちらかの型を使って作成できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can therefore call the &lt;c8&gt;&lt;s9&gt;allItemsMatch(_:_:)&lt;/s9&gt;&lt;/c8&gt; function with these two containers as its arguments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、したがって、&lt;c8&gt;&lt;s9&gt;allItemsMatch(_:_:)&lt;/s9&gt;&lt;/c8&gt;関数をその引数としてこれらの２つのコンテナを使って呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can think of an implicitly unwrapped optional as giving permission for the optional to be force-unwrapped if needed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは暗黙的にアンラップされるオプショナルを、必要に応じて強制アンラップされる許可をそのオプショナルに与えていると考えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can think of an opaque type like being the reverse of a generic type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、不透明型を総称体の逆であるように考えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can think of the associated values as behaving like stored properties of the enumeration case instance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはそれら関連値を、その列挙ケース節インスタンスに属する格納プロパティのように振る舞うものとして考えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use &lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;let&lt;/s3&gt;&lt;/c2&gt; together to work with values that might be missing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;let&lt;/s3&gt;&lt;/c2&gt;を一緒に使って、見つからないかもしれない値を扱うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use &lt;c2&gt;&lt;s3&gt;defer&lt;/s3&gt;&lt;/c2&gt; to write setup and cleanup code next to each other, even though they need to be executed at different times.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c2&gt;&lt;s3&gt;defer&lt;/s3&gt;&lt;/c2&gt;を使うことでセットアップおよびクリーンアップコードを隣り合わせに書くことができます、たとえそれらが異なる時に実行される必要があるにしても。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use &lt;c4&gt;&lt;s5&gt;allCases&lt;/s5&gt;&lt;/c4&gt; like any other collection—the collection’s elements are instances of the enumeration type, so in this case they’re &lt;c6&gt;&lt;s7&gt;Beverage&lt;/s7&gt;&lt;/c6&gt; values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c4&gt;&lt;s5&gt;allCases&lt;/s5&gt;&lt;/c4&gt;を何らかの他のコレクションと同様に使うことができます — コレクションの持つ要素は列挙型のインスタンスです、それでこの場合においてそれらは&lt;c6&gt;&lt;s7&gt;Beverage&lt;/s7&gt;&lt;/c6&gt;値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use Xcode 11.4 to build targets that are written in either Swift 5.2, Swift 4.2, or Swift 4.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、Xcode 11.4を使ってSwift 5.2、Swift 4.2、またはSwift 4のいずれかで書かれたターゲットをビルドできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a &lt;c0&gt;&lt;s1&gt;defer&lt;/s1&gt;&lt;/c0&gt; statement even when no error handling code is involved.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;defer&lt;/s1&gt;&lt;/c0&gt;文を使うことが、エラー処理コードを伴わない時でさえも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a &lt;e0&gt;capture list&lt;/e0&gt; to explicitly control how values are captured in a closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは&lt;e0&gt;キャプチャリスト&lt;/e0&gt;を使って、どのようにあるクロージャにおいて値がキャプチャされるかを明示的に制御します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a failable initializer to select an appropriate enumeration case based on one or more parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、失敗できるイニシャライザを使って適切な列挙ケース節を１つ以上のパラメータに基づいて選ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a function type as the return type of another function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ある関数型をそれとは違う関数の戻り型として使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a function type such as &lt;c0&gt;&lt;s1&gt;(Int,&lt;/s1&gt; &lt;s2&gt;Int)&lt;/s2&gt; &lt;s3&gt;-&gt;&lt;/s3&gt; &lt;s4&gt;Int&lt;/s4&gt;&lt;/c0&gt; as a parameter type for another function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ある関数型、例えば&lt;c0&gt;&lt;s1&gt;(Int,&lt;/s1&gt; &lt;s2&gt;Int)&lt;/s2&gt; &lt;s3&gt;-&gt;&lt;/s3&gt; &lt;s4&gt;Int&lt;/s4&gt;&lt;/c0&gt;を、別の関数のためのパラメータ型として使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a generic &lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt; clause with extensions to a protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、総称体&lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt;節をプロトコルに対する拡張で使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a key path expression in contexts where you would normally provide a function or closure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはキーパス式を、あなたが通常は関数またはクロージャを提供するところの文脈において使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a protocol in many places where other types are allowed, including:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、プロトコルを、他の型が許可される多くの場所で使用できます、以下を含みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a protocol name just like any other named type—for example, to create a collection of objects that have different types but that all conform to a single protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、何かほかの名前付きの型のようにプロトコル名を使用することができます ― 例えば、それぞれ異なる型を持つが全てがただ１つのプロトコルに準拠するオブジェクトいくつかのコレクションをつくるためなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a set instead of an array when the order of items is not important, or when you need to ensure that an item only appears once.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、項目の順番が重要でないときに、またはあなたがひとつの項目がただ一度だけ現れることを確実にする必要があるときに、配列の代わりに集合を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a tuple to return multiple values from a function as a single compound value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはタプルを使って、関数から複数の値を１つの混成値として返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a tuple type as the return type for a function to return multiple values as part of one compound return value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、関数の戻り型としてタプル型を使って、複数の値をひとつの複合の戻り値の一部として返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use a tuple type as the return type of a function to enable the function to return a single tuple containing multiple values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、関数の戻り型としてタプル型を使って、その関数に複数の値を含んでいる１つのタプルを返すのを可能にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use all three of the inherited initializers to create a new &lt;c0&gt;&lt;s1&gt;ShoppingListItem&lt;/s1&gt;&lt;/c0&gt; instance:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、継承されたイニシャライザの３つ全てを新しい&lt;c0&gt;&lt;s1&gt;ShoppingListItem&lt;/s1&gt;&lt;/c0&gt;インスタンスをつくるために使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use an &lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt; statement to find out whether an optional contains a value by comparing the optional against &lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;if&lt;/s1&gt;&lt;/c0&gt;文を、あるオプショナルが値を含むかどうか知るために使うことができます、それは、そのオプショナルを&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;と比べることによって行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use an empty dictionary literal to create an empty dictionary literal of specified key and value types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、空の辞書リテラルを使って、指定されたキーと値型の空の辞書リテラルを作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use an extension to add protocol conformance to a type that is declared elsewhere, or even to a type that you imported from a library or framework.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは１つの拡張を使用することで、どこかほかで宣言される型に、またはあなたがライブラリやフレームワークからインポートした型にさえもプロトコル準拠を加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use an extension to add protocol conformance, like this:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはある拡張を使って、このようにプロトコル準拠を加えることが出来ます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use an instance of &lt;c0&gt;&lt;s1&gt;ThreeSource&lt;/s1&gt;&lt;/c0&gt; as the data source for a new &lt;c2&gt;&lt;s3&gt;Counter&lt;/s3&gt;&lt;/c2&gt; instance:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;ThreeSource&lt;/s1&gt;&lt;/c0&gt;のインスタンスを新しい&lt;c2&gt;&lt;s3&gt;Counter&lt;/s3&gt;&lt;/c2&gt;インスタンスのためのデータ・ソースとして使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use an instance of &lt;c0&gt;&lt;s1&gt;TowardsZeroSource&lt;/s1&gt;&lt;/c0&gt; with the existing &lt;c2&gt;&lt;s3&gt;Counter&lt;/s3&gt;&lt;/c2&gt; instance to count from &lt;c4&gt;&lt;s5&gt;-4&lt;/s5&gt;&lt;/c4&gt; to zero.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;TowardsZeroSource&lt;/s1&gt;&lt;/c0&gt;のインスタンスを既存の&lt;c2&gt;&lt;s3&gt;Counter&lt;/s3&gt;&lt;/c2&gt;インスタンスとともに使って、&lt;c4&gt;&lt;s5&gt;-4&lt;/s5&gt;&lt;/c4&gt;からゼロへと数えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use assignment syntax in the definition of a wrapped value to pass the expression on the right-hand side of the assignment as the argument to the &lt;c0&gt;&lt;s1&gt;wrappedValue&lt;/s1&gt;&lt;/c0&gt; parameter of the property wrapper’s initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、代入構文をラップ値の定義において使用して、代入の右手側での式を、プロパティラッパーのもつイニシャライザの&lt;c0&gt;&lt;s1&gt;wrappedValue&lt;/s1&gt;&lt;/c0&gt;パラメータに対する引数として渡せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use bit shifting to encode and decode values within other data types:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、他のデータ型内の値を符号化したり復号するために、ビットシフトを使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use both constants and variables with optional binding.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、定数と変数の両方をオプショナル束縛で使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use extended delimiters to create strings with characters that would ordinarily have a special effect such as generating a string interpolation, starting an escape sequence, or terminating the string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは拡張区切り記号を使うことで、例えば文字列補間を生成する、エスケープシーケンスを開始する、または文字列を終端するなど、通常は特別な効果を持つ文字で文字列を作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use extended delimiters to include the text &lt;c0&gt;&lt;s1&gt;"""&lt;/s1&gt;&lt;/c0&gt; in a multiline string, overriding the default behavior that ends the literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは拡張区切り文字を使うことで、テキスト&lt;c0&gt;&lt;s1&gt;"""&lt;/s1&gt;&lt;/c0&gt;を複数行文字列の中に含めることが、省略時の挙動であるリテラルの終わりをオーバーライドして行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use extended string delimiters to create strings containing characters that would otherwise be treated as a string interpolation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、拡張文字列区切り記号を使うことで、そうしなければ文字列補間とみなされる文字を含んでいる文字列を作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use forced unwrapping in an initializer to call a failable initializer from the superclass as part of the implementation of a subclass’s nonfailable initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、強制アンラップをイニシャライザの中で使うことで、失敗できるイニシャライザをスーパークラスから呼び出し、サブクラスの失敗できないイニシャライザの実装の一部とすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use nested functions to organize the code in a function that is long or complex.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、長いか複雑である関数においてコードを組織するために、入れ子にされた関数を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use optional binding to check whether this version of the &lt;c0&gt;&lt;s1&gt;minMax(array:)&lt;/s1&gt;&lt;/c0&gt; function returns an actual tuple value or &lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;minMax(array:)&lt;/s1&gt;&lt;/c0&gt;関数のこの改作が返すのは本当のタプルなのかまたは&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;なのかを調べるためにオプショナル束縛を使うことが出来ます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use optional chaining to call a method on an optional value, and to check whether that method call is successful.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはオプショナル連鎖を使って、オプショナルの値の上でメソッドを呼んで、そしてそのメソッド呼び出しが成功しているかどうか調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use optional chaining to try to retrieve and set a value from a subscript on an optional value, and to check whether that subscript call is successful.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、オプショナル連鎖を使って、あるオプショナルの値上の添え字から値を取り出したり設定したりすること、そしてその添え字がうまく呼び出されるかどうかを調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use optional chaining with calls to properties, methods, and subscripts that are more than one level deep.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、深さ１階層以上であるプロパティ、メソッド、そして添え字への呼び出しでオプショナル連鎖を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use parentheses to specify the precedence of operations by explicitly grouping expressions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは丸括弧を使って、明示的にいくらかの式をグループにまとめることによって演算の優先順位を指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use property overriding to add property observers to an inherited property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、プロパティをオーバーライドすることを継承されたプロパティにプロパティオブザーバーを追加するために使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use protocol extensions to provide a default implementation to any method or computed property requirement of that protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはプロトコル拡張を使うことで省略時の実装をそのプロトコルのどのメソッドまたは計算プロパティ要件に対しても提供できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use protocols to declare which methods a delegate of a class or structure should implement, as described in &lt;a0&gt;&lt;s1&gt;Delegation&lt;/s1&gt;&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはプロトコルを使って、あるクラスまたは構造体から委任を受ける側が実装しなければならないのはどのメソッドかを宣言することができます、&lt;a0&gt;&lt;s1&gt;委任&lt;/s1&gt;&lt;/a0&gt;で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use string interpolation in both single-line and multiline string literals.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、文字列補間を単一行および複数行文字列リテラルにおいて使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use subscript syntax to access the &lt;c0&gt;&lt;s1&gt;Character&lt;/s1&gt;&lt;/c0&gt; at a particular &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt; index.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、添え字構文を使うことで特定の&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;インデックス位置での&lt;c0&gt;&lt;s1&gt;Character&lt;/s1&gt;&lt;/c0&gt;へアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use subscript syntax to change an existing value at a given index:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、添え字構文を使って、与えられたインデックス位置にある既存の値を変えることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use subscript syntax to remove a key-value pair from a dictionary by assigning a value of &lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt; for that key:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは添え字構文を、そのキーに対して&lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;の値を代入することによって、辞書からある「キーと値」の対を削除するために使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the &lt;c0&gt;&lt;s1&gt;AudioChannel&lt;/s1&gt;&lt;/c0&gt; structure to create two new audio channels called &lt;c2&gt;&lt;s3&gt;leftChannel&lt;/s3&gt;&lt;/c2&gt; and &lt;c4&gt;&lt;s5&gt;rightChannel&lt;/s5&gt;&lt;/c4&gt;, to represent the audio levels of a stereo sound system:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;AudioChannel&lt;/s1&gt;&lt;/c0&gt;構造体を、&lt;c2&gt;&lt;s3&gt;leftChannel&lt;/s3&gt;&lt;/c2&gt;と&lt;c4&gt;&lt;s5&gt;rightChannel&lt;/s5&gt;&lt;/c4&gt;と呼ばれる２つの新しい音声チャンネルをつくるために使用して、ステレオ・オーディオ・システムの音声のレベルを表すことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the &lt;c0&gt;&lt;s1&gt;fatalError(_:file:line:)&lt;/s1&gt;&lt;/c0&gt; function during prototyping and early development to create stubs for functionality that hasn’t been implemented yet, by writing &lt;c2&gt;&lt;s3&gt;fatalError("Unimplemented")&lt;/s3&gt;&lt;/c2&gt; as the stub implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;fatalError(_:file:line:)&lt;/s1&gt;&lt;/c0&gt;関数を試作段階および開発初期の間に使って、まだ実装されていない機能性に対してスタブ（代用品）を作成することが、&lt;c2&gt;&lt;s3&gt;fatalError("Unimplemented")&lt;/s3&gt;&lt;/c2&gt;をスタブ実装として記述することによって行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the &lt;c0&gt;&lt;s1&gt;hasPrefix(_:)&lt;/s1&gt;&lt;/c0&gt; method with the &lt;c2&gt;&lt;s3&gt;romeoAndJuliet&lt;/s3&gt;&lt;/c2&gt; array to count the number of scenes in Act 1 of the play:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、劇の「一幕（Act 1）」の場面の数を数えるために&lt;c0&gt;&lt;s1&gt;hasPrefix(_:)&lt;/s1&gt;&lt;/c0&gt;メソッドを&lt;c2&gt;&lt;s3&gt;romeoAndJuliet&lt;/s3&gt;&lt;/c2&gt;配列で使用することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the &lt;c0&gt;&lt;s1&gt;insert(_:at:)&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;insert(contentsOf:at:)&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;remove(at:)&lt;/s5&gt;&lt;/c4&gt;, and &lt;c6&gt;&lt;s7&gt;removeSubrange(_:)&lt;/s7&gt;&lt;/c6&gt; methods on any type that conforms to the &lt;c8&gt;&lt;s9&gt;RangeReplaceableCollection&lt;/s9&gt;&lt;/c8&gt; protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;insert(_:at:)&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;insert(contentsOf:at:)&lt;/s3&gt;&lt;/c2&gt;、&lt;c4&gt;&lt;s5&gt;remove(at:)&lt;/s5&gt;&lt;/c4&gt;、そして&lt;c6&gt;&lt;s7&gt;removeSubrange(_:)&lt;/s7&gt;&lt;/c6&gt;メソッドを&lt;c8&gt;&lt;s9&gt;RangeReplaceableCollection&lt;/s9&gt;&lt;/c8&gt;プロトコルに準拠するあらゆる型で使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the &lt;c0&gt;&lt;s1&gt;is&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;as&lt;/s3&gt;&lt;/c2&gt; operators described in &lt;a4&gt;&lt;s5&gt;Type Casting&lt;/s5&gt;&lt;/a4&gt; to check for protocol conformance, and to cast to a specific protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;a4&gt;&lt;s5&gt;型キャスト&lt;/s5&gt;&lt;/a4&gt;で記述される&lt;c0&gt;&lt;s1&gt;is&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;as&lt;/s3&gt;&lt;/c2&gt;演算子を特定のプロトコルへキャストするために使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the &lt;c0&gt;&lt;s1&gt;startIndex&lt;/s1&gt;&lt;/c0&gt; and &lt;c2&gt;&lt;s3&gt;endIndex&lt;/s3&gt;&lt;/c2&gt; properties and the &lt;c4&gt;&lt;s5&gt;index(before:)&lt;/s5&gt;&lt;/c4&gt;, &lt;c6&gt;&lt;s7&gt;index(after:)&lt;/s7&gt;&lt;/c6&gt;, and &lt;c8&gt;&lt;s9&gt;index(_:offsetBy:)&lt;/s9&gt;&lt;/c8&gt; methods on any type that conforms to the &lt;c10&gt;&lt;s11&gt;Collection&lt;/s11&gt;&lt;/c10&gt; protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;startIndex&lt;/s1&gt;&lt;/c0&gt;と&lt;c2&gt;&lt;s3&gt;endIndex&lt;/s3&gt;&lt;/c2&gt;プロパティそして&lt;c4&gt;&lt;s5&gt;index(before:)&lt;/s5&gt;&lt;/c4&gt;、&lt;c6&gt;&lt;s7&gt;index(after:)&lt;/s7&gt;&lt;/c6&gt;、および&lt;c8&gt;&lt;s9&gt;index(_:offsetBy:)メ&lt;/s9&gt;&lt;/c8&gt;ソッドを&lt;c10&gt;&lt;s11&gt;Collection&lt;/s11&gt;&lt;/c10&gt;プロトコルに準拠するあらゆる型で使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the &lt;c7&gt;&lt;s8&gt;rawValue&lt;/s8&gt;&lt;/c7&gt; property to access the raw value of an enumeration case, as in &lt;c9&gt;&lt;s10&gt;ExampleEnum.b.rawValue&lt;/s10&gt;&lt;/c9&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c7&gt;&lt;s8&gt;rawValue&lt;/s8&gt;&lt;/c7&gt;プロパティを使うことで列挙ケース節の生の値にアクセスできます、&lt;c9&gt;&lt;s10&gt;ExampleEnum.b.rawValue&lt;/s10&gt;&lt;/c9&gt;におけるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the abbreviated form anytime the value’s type is already known.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、値の型がすでに知られているときはいつでも省略形を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use the postfix &lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt; expression to access a type as a value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、接尾辞&lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;式を使って、ある型に値としてアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use this argument to name classes, enumerations, enumeration cases, protocols, methods, getters, setters, and initializers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはこの引数を、クラス、列挙、列挙ケース、プロトコル、メソッド、ゲッター、セッター、そしてイニシャライザに名前をつけるために使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use this failable initializer to choose an appropriate enumeration case for the three possible states and to cause initialization to fail if the parameter does not match one of these states:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、この失敗できるイニシャライザを使って、適切な列挙ケース節を３つの可能な状態に対して選び取るように、そしてパラメータが３つの状態の内の１つに合わない場合に初期化が失敗するようにできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use this failable initializer to try to initialize a new &lt;c0&gt;&lt;s1&gt;Animal&lt;/s1&gt;&lt;/c0&gt; instance and to check if initialization succeeded:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、この失敗できるイニシャライザを使うことで、新しい&lt;c0&gt;&lt;s1&gt;Animal&lt;/s1&gt;&lt;/c0&gt;インスタンスを初期化することを試みて、初期化が成功したか確認することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use this initializer to initialize a new constant called &lt;c4&gt;&lt;s5&gt;theAceOfSpades&lt;/s5&gt;&lt;/c4&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c4&gt;&lt;s5&gt;theAceOfSpades&lt;/s5&gt;&lt;/c4&gt;と呼ばれる新しい定数を初期化するために、このイニシャライザを使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use this initializer to try to create a new instance of the enumeration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、このイニシャライザを使って、この列挙の新しいインスタンスを作成するように試みることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use this optional return value to check whether the optional chaining call was successful (the returned optional contains a value), or did not succeed due to a &lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt; value in the chain (the returned optional value is &lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、このオプショナルの戻り値を使って、オプショナル連鎖呼び出しが成功した（返されたオプショナルが値を含む）か、あるいは連鎖の中の&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;値のために成功しなかった（返されたオプショナルの値が&lt;c4&gt;&lt;s5&gt;nil&lt;/s5&gt;&lt;/c4&gt;である）かどうか確認することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use this syntax to hard wrap a multiline string literal in your source code, without changing the value of the resulting string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、この構文を使うことで、複数行文字列リテラルをあなたのソースコードにおいてハードラップする（次行に送る）ことが、結果となる文字列の値を変更することなく行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use this type like any other type in Swift, which makes it easy to pass functions as parameters to other functions, and to return functions from functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはスウィフトの他のあらゆる型と同じようにこの型を使うことができます、そしてそれは、他の関数へのパラメータとして関数を渡して、関数から関数を返すことを簡単にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use tuples to test multiple values in the same &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、複数の値を同じ&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;文において試験するためにタプルを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use type casting with a hierarchy of classes and subclasses to check the type of a particular class instance and to cast that instance to another class within the same hierarchy.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、いくつかのクラスおよびサブクラスからなるある階層とともに型キャストを使って、特定のクラスインスタンスの型を調べて、そのインスタンスを同じ階層内の別のクラスにキャストすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can use your own custom types as set value types or dictionary key types by making them conform to the &lt;c0&gt;&lt;s1&gt;Hashable&lt;/s1&gt;&lt;/c0&gt; protocol from Swift’s standard library.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あなた独自のあつらえの型を集合の値型または辞書のキー型として使用することが、それらをスウィフトの標準ライブラリからの&lt;c0&gt;&lt;s1&gt;Hashable&lt;/s1&gt;&lt;/c0&gt;プロトコルに適合させることで可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can write a closure without a name by surrounding code with braces (&lt;c0&gt;&lt;s1&gt;{}&lt;/s1&gt;&lt;/c0&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、名前なしで波括弧（&lt;c0&gt;&lt;s1&gt;{}&lt;/s1&gt;&lt;/c0&gt;）でコードを囲むことによってクロージャを書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can write code that avoids duplication and expresses its intent in a clear, abstracted manner.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、重複を避けて、明快な、抽象化された手法で、その意図を表すコードを書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can write the &lt;c0&gt;&lt;s1&gt;Fahrenheit&lt;/s1&gt;&lt;/c0&gt; structure from above in a simpler form by providing a default value for its &lt;c2&gt;&lt;s3&gt;temperature&lt;/s3&gt;&lt;/c2&gt; property at the point that the property is declared:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、上記の&lt;c0&gt;&lt;s1&gt;Fahrenheit&lt;/s1&gt;&lt;/c0&gt;構造体を、その&lt;c2&gt;&lt;s3&gt;temperature&lt;/s3&gt;&lt;/c2&gt;プロパティのために省略時の値をそのプロパティが宣言される時点で用意することによって、より単純な形式で書くことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can write the same functionality as a generic function by replacing any mention of strings with values of some type &lt;c0&gt;&lt;s1&gt;T&lt;/s1&gt;&lt;/c0&gt; instead.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは同じ機能性を総称体関数として書くことが、何であれ文字列への言及部分をその代わりにある何らかの型&lt;c0&gt;&lt;s1&gt;T&lt;/s1&gt;&lt;/c0&gt;の値で置き換えることで行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You cannot add property observers to inherited constant stored properties or inherited read-only computed properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、プロパティオブザーバーを、継承された定数格納プロパティに、または継承された読み出し専用の計算プロパティに加えることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You cannot define a failable and a nonfailable initializer with the same parameter types and names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、失敗できる及び失敗できないイニシャライザを同じパラメータの型と名前で定義することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You cannot pass a constant or a literal value as the argument, because constants and literals cannot be modified.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは引数として定数またはリテラル値を渡すことができません、なぜなら定数とリテラルは修正されることができないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You cannot, however, present an inherited read-write property as a read-only property.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、しかし、継承された読み書き両用プロパティを、読み出し専用のプロパティとして提示することができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can’t append a &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; or &lt;c2&gt;&lt;s3&gt;Character&lt;/s3&gt;&lt;/c2&gt; to an existing &lt;c4&gt;&lt;s5&gt;Character&lt;/s5&gt;&lt;/c4&gt; variable, because a &lt;c6&gt;&lt;s7&gt;Character&lt;/s7&gt;&lt;/c6&gt; value must contain a single character only.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;または&lt;c2&gt;&lt;s3&gt;Character&lt;/s3&gt;&lt;/c2&gt;を既存の&lt;c4&gt;&lt;s5&gt;Character&lt;/s5&gt;&lt;/c4&gt;変数に追加することはできません、なぜなら&lt;c6&gt;&lt;s7&gt;Character&lt;/s7&gt;&lt;/c6&gt;値がただ１つの文字だけを含まなければならないためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can’t iterate over a one-sided range that omits a first value, because it isn’t clear where iteration should begin.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、最初の値を省いた片側範囲に対して反復していくことができません、なぜならどこで反復が始まるべきかが明瞭でないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can’t mark a variadic parameter or a return type with the &lt;c2&gt;&lt;s3&gt;inout&lt;/s3&gt;&lt;/c2&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、可変長パラメータまたは戻り型に&lt;c2&gt;&lt;s3&gt;inout&lt;/s3&gt;&lt;/c2&gt;キーワードで印をつけることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can’t overload a function based only on whether the function can throw an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはある関数を、その関数がエラーをスローできるかどうかのみに基づいてオーバーロードできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can’t pass in &lt;e10&gt;any&lt;/e10&gt; type here, however—it has to be a type for which &lt;c11&gt;&lt;s12&gt;UInt16&lt;/s12&gt;&lt;/c11&gt; provides an initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら、あなたは&lt;e10&gt;あらゆる&lt;/e10&gt;型をここに渡すことはできません ― それは&lt;c11&gt;&lt;s12&gt;UInt16&lt;/s12&gt;&lt;/c11&gt;がイニシャライザを提供する型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can’t provide an explicit access-level modifier for an extension if you’re using that extension to add protocol conformance.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがプロトコル準拠を加えるためにその拡張を使っているならば、あなたは明確なアクセス水準修飾子を拡張のために用意することが出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can’t set a protocol requirement to a different access level than the protocol it supports.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あるプロトコル要件をそれが支えるプロトコルと異なるアクセス水準に設定することができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can’t specify a different access level for individual enumeration cases.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、個々の列挙ケース節に対して異なるアクセス水準を指定することができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can’t use &lt;c0&gt;&lt;s1&gt;Container&lt;/s1&gt;&lt;/c0&gt; as the return type of a function because that protocol has an associated type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは&lt;c0&gt;&lt;s1&gt;Container&lt;/s1&gt;&lt;/c0&gt;を関数の戻り型として使用できません、なぜならそのプロトコルが関連型を持つからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can’t use &lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt; with non-optional constants and variables.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;を非オプショナルの定数および変数で使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can’t use an unlabeled &lt;c4&gt;&lt;s5&gt;break&lt;/s5&gt;&lt;/c4&gt; statement to break out of an &lt;c6&gt;&lt;s7&gt;if&lt;/s7&gt;&lt;/c6&gt; statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ラベルを付けられない&lt;c4&gt;&lt;s5&gt;break&lt;/s5&gt;&lt;/c4&gt;文を&lt;c6&gt;&lt;s7&gt;if&lt;/s7&gt;&lt;/c6&gt;文を脱するために使うことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You check for an implementation of an optional method by writing a question mark after the name of the method when it’s called, such as &lt;c0&gt;&lt;s1&gt;someOptionalMethod?(someArgument)&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、それが呼ばれるときに疑問符をそのメソッドの後に書くことによって、あるオプショナルメソッドの実装について確認することができます、例えば&lt;c0&gt;&lt;s1&gt;someOptionalMethod?(someArgument)&lt;/s1&gt;&lt;/c0&gt;のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You could use generics to implement operations like flipping a shape vertically, as shown in the code below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは総称体を使って、ある形状を垂直に裏返すような演算を実装できました、下のコードで示されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You could write code that uses the behavior of a property wrapper, without taking advantage of the special attribute syntax.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはプロパティラッパーの挙動を使うコードを、この特別な属性構文を利用することなく記述できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You create a new &lt;c0&gt;&lt;s1&gt;Stack&lt;/s1&gt;&lt;/c0&gt; instance by writing the type to be stored in the stack within angle brackets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、新しい&lt;c0&gt;&lt;s1&gt;Stack&lt;/s1&gt;&lt;/c0&gt;インスタンスを、角括弧の内側にそのスタックの中に格納される型を書くことによって作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You create a new instance of &lt;c0&gt;&lt;s1&gt;Vehicle&lt;/s1&gt;&lt;/c0&gt; with &lt;e2&gt;initializer syntax&lt;/e2&gt;, which is written as a type name followed by empty parentheses:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;Vehicle&lt;/s1&gt;&lt;/c0&gt;の新しいインスタンスを&lt;e2&gt;初期化構文&lt;/e2&gt;を使って作成します、それは１つの型名に続く空の丸括弧として書かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You declare constants with the &lt;c0&gt;&lt;s1&gt;let&lt;/s1&gt;&lt;/c0&gt; keyword and variables with the &lt;c2&gt;&lt;s3&gt;var&lt;/s3&gt;&lt;/c2&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;let&lt;/s1&gt;&lt;/c0&gt;キーワードを使って定数を、&lt;c2&gt;&lt;s3&gt;var&lt;/s3&gt;&lt;/c2&gt;キーワードを使って変数を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You define properties and methods to add functionality to your structures and classes using the same syntax you use to define constants, variables, and functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはプロパティとメソッドを定義することで、あなたの構造体およびクラスに機能性を加えます、それには定数、変数、そして関数を定義するのにあなたが使うのと同じ構文を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You define protocols in a very similar way to classes, structures, and enumerations:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、クラス、構造体、および列挙と非常に類似した方法で、プロトコルを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You define this form of a variable declaration at global scope, the local scope of a function, or in the context of a class or structure declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、変数宣言のこの形式を、グローバルなスコープ、関数のローカルなスコープで、またはクラスおよび構造体宣言の文脈において定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You define this form of a variable declaration at global scope, the local scope of a function, or in the context of a class, structure, enumeration, or extension declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、変数宣言のこの形式を、グローバルなスコープ、関数のローカルなスコープで、またはクラス、構造体、列挙、および拡張宣言の文脈において定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You define type aliases with the &lt;c1&gt;&lt;s2&gt;typealias&lt;/s2&gt;&lt;/c1&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c1&gt;&lt;s2&gt;typealias&lt;/s2&gt;&lt;/c1&gt;キーワードで型エイリアスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You define type properties with the &lt;c0&gt;&lt;s1&gt;static&lt;/s1&gt;&lt;/c0&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、型プロパティを&lt;c0&gt;&lt;s1&gt;static&lt;/s1&gt;&lt;/c0&gt;キーワードを使って定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You do not have to provide an explicit implementation of a required initializer if you can satisfy the requirement with an inherited initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あなたがある継承されたイニシャライザの要件を満たすことができるならば、必須イニシャライザの明示的な実装を提供する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You do not have to provide convenience initializers if your class does not require them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのクラスがそれらを必要としないならば、あなたは便宜イニシャライザを提供する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You do not need to specify the type of the closure’s input parameter, &lt;c2&gt;&lt;s3&gt;number&lt;/s3&gt;&lt;/c2&gt;, because the type can be inferred from the values in the array to be mapped.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはクロージャの入力パラメータ、&lt;c2&gt;&lt;s3&gt;number&lt;/s3&gt;&lt;/c2&gt;の型を指定する必要がありません、なぜならその型が対応付けされる配列の値から推論されることができるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You do not specify a precedence when defining a prefix or postfix operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、接頭辞または接尾辞演算子を定義するときに優先順位を指定しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You do not write the &lt;c2&gt;&lt;s3&gt;override&lt;/s3&gt;&lt;/c2&gt; modifier when overriding a required designated initializer:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、必須指定イニシャライザをオーバーライドする時に&lt;c2&gt;&lt;s3&gt;override&lt;/s3&gt;&lt;/c2&gt;修飾子を書きません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You do this by defining a &lt;e0&gt;generic where clause&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはこれを&lt;e0&gt;総称体where節&lt;/e0&gt;を定義する事によって行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You do this by writing a complete function type immediately after the return arrow (&lt;c0&gt;&lt;s1&gt;-&gt;&lt;/s1&gt;&lt;/c0&gt;) of the returning function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、返すことになる関数の戻り矢印（&lt;c0&gt;&lt;s1&gt;-&gt;&lt;/s1&gt;&lt;/c0&gt;）の直後に完全な関数型を書くことによってこれをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You do this by writing the &lt;c4&gt;&lt;s5&gt;break&lt;/s5&gt;&lt;/c4&gt; statement as the entire body of the case you want to ignore.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c4&gt;&lt;s5&gt;break&lt;/s5&gt;&lt;/c4&gt;文をあなたが無視したいケース節の全本文として書くことによってこれをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You do this with an empty extension, as described in &lt;a16&gt;&lt;s17&gt;Declaring Protocol Adoption with an Extension&lt;/s17&gt;&lt;/a16&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&lt;a16&gt;&lt;s17&gt;拡張を使ってプロトコル採用を宣言する&lt;/s17&gt;&lt;/a16&gt;で記述されるように、あなたは空の拡張でこれを行います</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You don’t know in advance which actual class to use for each item, and so it is appropriate to use the conditional form of the type cast operator (&lt;c4&gt;&lt;s5&gt;as?&lt;/s5&gt;&lt;/c4&gt;) to check the downcast each time through the loop:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、前もって、各項目のために使われる実際のクラスがどれかを知りません、なので適切なのは、型キャスト演算子の条件形式（&lt;c4&gt;&lt;s5&gt;as?&lt;/s5&gt;&lt;/c4&gt;）を使用してループを通して毎回ダウンキャストを確認することです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You don’t need to define property observers for nonoverridden computed properties, because you can observe and respond to changes to their value in the computed property’s setter.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、オーバーライドされていない計算プロパティのためにプロパティオブザーバーを定義する必要はありません、なぜならあなたは計算プロパティのセッターにおいてそれらの値の変化を観察して応答することができるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You don’t need to import a separate library for functionality like input/output or string handling.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、入力／出力または文字列取り扱いのような機能性のために個々のライブラリをインポートする必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You don’t need to mark protocol initializer implementations with the &lt;c0&gt;&lt;s1&gt;required&lt;/s1&gt;&lt;/c0&gt; modifier on classes that are marked with the &lt;c2&gt;&lt;s3&gt;final&lt;/s3&gt;&lt;/c2&gt; modifier, because final classes can’t subclassed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは&lt;c2&gt;&lt;s3&gt;final&lt;/s3&gt;&lt;/c2&gt;修飾子で印されるクラス上でプロトコルイニシャライザ実装を&lt;c0&gt;&lt;s1&gt;required&lt;/s1&gt;&lt;/c0&gt;修飾子で印する必要はありません、なぜなら、finalクラスはサブクラスを作られることができないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You enable this by writing &lt;c0&gt;&lt;s1&gt;:&lt;/s1&gt; &lt;s2&gt;CaseIterable&lt;/s2&gt;&lt;/c0&gt; after the enumeration’s name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、これを&lt;c0&gt;&lt;s1&gt;:&lt;/s1&gt; &lt;s2&gt;CaseIterable&lt;/s2&gt;&lt;/c0&gt;を列挙の名前の後に書くことによって可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You extract each associated value as a constant (with the &lt;c2&gt;&lt;s3&gt;let&lt;/s3&gt;&lt;/c2&gt; prefix) or a variable (with the &lt;c4&gt;&lt;s5&gt;var&lt;/s5&gt;&lt;/c4&gt; prefix) for use within the &lt;c6&gt;&lt;s7&gt;switch&lt;/s7&gt;&lt;/c6&gt; case’s body:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、関連値それぞれを定数（&lt;c2&gt;&lt;s3&gt;let&lt;/s3&gt;&lt;/c2&gt;接頭辞を使って）または変数（&lt;c4&gt;&lt;s5&gt;var&lt;/s5&gt;&lt;/c4&gt;接頭辞を使って）として&lt;c6&gt;&lt;s7&gt;switch&lt;/s7&gt;&lt;/c6&gt;のケース節の本文内で使用するために抽出します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You get the same behavior of delayed evaluation when you pass a closure as an argument to a function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが同じ挙動の延期した評価を得るのは、あなたがクロージャを引数として関数に渡す時です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You give a function a name that identifies what it does, and this name is used to “call” the function to perform its task when needed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは関数にそれが何をするかについて識別する名前を与えます、そしてこの名前が必要なときその作業を実行するために関数を「呼び出す」のに使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have access to the type parameters (and any of their associated types) in the rest of the type, function, or initializer declaration, including in the signature of the function or initializer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、そのままの型、関数、またはイニシャライザ宣言の中の、さらに含めて関数またはイニシャライザのシグネチャの中の、型パラメータ（およびあらゆるそれの関連型）にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have several options for writing closures more concisely.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、より簡潔にクロージャを書くためにいくつかの選択肢を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You have the option to define either or both of these observers on a property:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あるプロパティに関してこれらのオブザーバーのどちらかまたは両方とも定義する選択肢を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You implement a prefix or postfix unary operator by writing the &lt;c0&gt;&lt;s1&gt;prefix&lt;/s1&gt;&lt;/c0&gt; or &lt;c2&gt;&lt;s3&gt;postfix&lt;/s3&gt;&lt;/c2&gt; modifier before the &lt;c4&gt;&lt;s5&gt;func&lt;/s5&gt;&lt;/c4&gt; keyword when declaring the operator method:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、接頭辞または接尾辞単項演算子を、&lt;c0&gt;&lt;s1&gt;prefix&lt;/s1&gt;&lt;/c0&gt;または&lt;c2&gt;&lt;s3&gt;postfix&lt;/s3&gt;&lt;/c2&gt;修飾子を&lt;c4&gt;&lt;s5&gt;func&lt;/s5&gt;&lt;/c4&gt;キーワードの前に演算子メソッドを宣言するときに書くことによって実装します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You implement this initialization process by defining &lt;e0&gt;initializers&lt;/e0&gt;, which are like special methods that can be called to create a new instance of a particular type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはこの初期化処理を&lt;e0&gt;イニシャライザ&lt;/e0&gt;を定義することによって実装します、それは、特定の型の新しいインスタンスをつくるために呼ばれることができる特別なメソッドのようなものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You indicate a lazy stored property by writing the &lt;c1&gt;&lt;s2&gt;lazy&lt;/s2&gt;&lt;/c1&gt; modifier before its declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c1&gt;&lt;s2&gt;lazy&lt;/s2&gt;&lt;/c1&gt;修飾子をその宣言の前に書くことによって遅延格納プロパティであることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You indicate a type subscript by writing the &lt;c1&gt;&lt;s2&gt;static&lt;/s2&gt;&lt;/c1&gt; keyword before the &lt;c3&gt;&lt;s4&gt;subscript&lt;/s4&gt;&lt;/c3&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは型添え字を、&lt;c1&gt;&lt;s2&gt;static&lt;/s2&gt;&lt;/c1&gt;キーワードを&lt;c3&gt;&lt;s4&gt;subscript&lt;/s4&gt;&lt;/c3&gt;キーワードの前に書くことによって指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You indicate a weak reference by placing the &lt;c1&gt;&lt;s2&gt;weak&lt;/s2&gt;&lt;/c1&gt; keyword before a property or variable declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、プロパティまたは変数の宣言の前に&lt;c1&gt;&lt;s2&gt;weak&lt;/s2&gt;&lt;/c1&gt;キーワードを置くことによって弱い参照を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You indicate an unowned reference by placing the &lt;c1&gt;&lt;s2&gt;unowned&lt;/s2&gt;&lt;/c1&gt; keyword before a property or variable declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、プロパティまたは変数の宣言の前に&lt;c1&gt;&lt;s2&gt;unowned&lt;/s2&gt;&lt;/c1&gt;キーワードを置くことによって非所有参照を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You indicate an unsafe unowned reference by writing &lt;c0&gt;&lt;s1&gt;unowned(unsafe)&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、安全でない非所有参照を&lt;c0&gt;&lt;s1&gt;unowned(unsafe)&lt;/s1&gt;&lt;/c0&gt;を書くことによって指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You indicate that an enumeration case is recursive by writing &lt;c1&gt;&lt;s2&gt;indirect&lt;/s2&gt;&lt;/c1&gt; before it, which tells the compiler to insert the necessary layer of indirection.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、ある列挙ケース節が再帰することをそれの前に&lt;c1&gt;&lt;s2&gt;indirect&lt;/s2&gt;&lt;/c1&gt;を書くことによって指し示します、それは、コンパイラに不可欠な間接参照の階層を差し入れるように伝えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You indicate the function’s return type with the &lt;e3&gt;return arrow&lt;/e3&gt; &lt;c4&gt;&lt;s5&gt;-&gt;&lt;/s5&gt;&lt;/c4&gt; (a hyphen followed by a right angle bracket), which is followed by the name of the type to return.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、関数の戻り型を、&lt;e3&gt;戻り矢印&lt;/e3&gt;&lt;c4&gt;&lt;s5&gt;-&gt;&lt;/s5&gt;&lt;/c4&gt;（ハイフンに続けて右の山形括弧）、それに続く返す型の名前で示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You indicate type methods by writing the &lt;c1&gt;&lt;s2&gt;static&lt;/s2&gt;&lt;/c1&gt; keyword before the method’s &lt;c3&gt;&lt;s4&gt;func&lt;/s4&gt;&lt;/c3&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、型メソッドを&lt;c1&gt;&lt;s2&gt;static&lt;/s2&gt;&lt;/c1&gt;キーワードをメソッドの&lt;c3&gt;&lt;s4&gt;func&lt;/s4&gt;&lt;/c3&gt;キーワードの前に書くことによって示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You indicate whether a particular &lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt; can be modified (or &lt;e2&gt;mutated&lt;/e2&gt;) by assigning it to a variable (in which case it can be modified), or to a constant (in which case it can’t be modified):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、特定の&lt;c0&gt;&lt;s1&gt;String&lt;/s1&gt;&lt;/c0&gt;が修正される（または&lt;e2&gt;変化する&lt;/e2&gt;）ことができるかどうか、それを変数（その場合それは修が可能です）にまたは定数（その場合それは修正できません）に代入することによって示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You introduce enumerations with the &lt;c0&gt;&lt;s1&gt;enum&lt;/s1&gt;&lt;/c0&gt; keyword and place their entire definition within a pair of braces:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、列挙を&lt;c0&gt;&lt;s1&gt;enum&lt;/s1&gt;&lt;/c0&gt;キーワードで始めて、一対の波括弧の内側にそれらの全ての定義を置きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You introduce structures with the &lt;c0&gt;&lt;s1&gt;struct&lt;/s1&gt;&lt;/c0&gt; keyword and classes with the &lt;c2&gt;&lt;s3&gt;class&lt;/s3&gt;&lt;/c2&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;struct&lt;/s1&gt;&lt;/c0&gt;キーワードで構造体を、そして&lt;c2&gt;&lt;s3&gt;class&lt;/s3&gt;&lt;/c2&gt;キーワードでクラスを始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You mark a compound assignment operator’s left input parameter type as &lt;c5&gt;&lt;s6&gt;inout&lt;/s6&gt;&lt;/c5&gt;, because the parameter’s value will be modified directly from within the operator method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは複合代入演算子の左入力パラメーター型を&lt;c5&gt;&lt;s6&gt;inout&lt;/s6&gt;&lt;/c5&gt;として印します、なぜなら、このパラメーターの値は直接にこの演算子メソッド内で修正されることになるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may have noticed that the bodies of the &lt;c0&gt;&lt;s1&gt;swapTwoInts(_:_:)&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;swapTwoStrings(_:_:)&lt;/s3&gt;&lt;/c2&gt;, and &lt;c4&gt;&lt;s5&gt;swapTwoDoubles(_:_:)&lt;/s5&gt;&lt;/c4&gt; functions are identical.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;swapTwoInts(_:_:)&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;swapTwoStrings(_:_:)&lt;/s3&gt;&lt;/c2&gt;、そして&lt;c4&gt;&lt;s5&gt;swapTwoDoubles(_:_:)&lt;/s5&gt;&lt;/c4&gt;関数の本文が同一であると気がついたかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You may, however, want to mark some parts of your code as file private or private in order to hide their implementation details from other code within the app’s module.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、しかし、あなたのコードのいくつかの部分をファイル外非公開または非公開として印して、それらの実施詳細をそのアプリのモジュール内の他のコードから隠したいかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You might expect this function to have the default access level of “internal”, but this isn’t the case.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはこの関数が省略時アクセス水準の「内部」を持つのを期待するかもしれません、しかし事実はそうではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You might want to run an extra piece of code when an error occurs, or to display a message when a value becomes too high or too low.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、エラーが発生する時にコードの臨時の小片を実行したいかもしれません、またある値があまりに高いかあまりに低くなる時にお知らせを表示したいかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must also write the &lt;c0&gt;&lt;s1&gt;required&lt;/s1&gt;&lt;/c0&gt; modifier before every subclass implementation of a required initializer, to indicate that the initializer requirement applies to further subclasses in the chain.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはまた、&lt;c0&gt;&lt;s1&gt;required&lt;/s1&gt;&lt;/c0&gt;修飾子を必須イニシャライザの全てのサブクラス実装の前に書かなければなりません、そうすることでそのイニシャライザ要件がさらにその連鎖のサブクラスに適用されることを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must always declare a lazy property as a variable (with the &lt;c0&gt;&lt;s1&gt;var&lt;/s1&gt;&lt;/c0&gt; keyword), because its initial value might not be retrieved until after instance initialization completes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは常に遅延プロパティを変数として（&lt;c0&gt;&lt;s1&gt;var&lt;/s1&gt;&lt;/c0&gt;キーワードを使って）宣言しなければなりません、なぜならその最初の値はインスタンスの初期化が完了する後まで取り出されないかもしれないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must always state both the name and the type of the property you are overriding, to enable the compiler to check that your override matches a superclass property with the same name and type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、常にあなたがオーバーライドしているプロパティの名前と型を明確に述べなければなりません、そうすることであなたのオーバーライドがスーパークラスの同じ名前と型をもつプロパティと合致することをコンパイラが確認できるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must declare computed properties—including read-only computed properties—as variable properties with the &lt;c0&gt;&lt;s1&gt;var&lt;/s1&gt;&lt;/c0&gt; keyword, because their value is not fixed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、計算プロパティ ― 読み出し専用の計算プロパティを含む ― を&lt;c0&gt;&lt;s1&gt;var&lt;/s1&gt;&lt;/c0&gt;キーワードをつかって変数プロパティとして宣言しなければなりません、なぜならそれらの値は固定されないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must specify the access level explicitly as part of the function’s definition if the function’s calculated access level doesn’t match the contextual default.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その関数の計算されたアクセス水準が省略時の文脈に合致しないと思うならば、あなたは関数の定義の一部として明確にアクセス水準を指定しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You need to mark an entity as open or public only if you want it to become part of your framework’s API.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、それにあなたのフレームワークのもつAPIの一部になってほしいならば、ある実在を開放または公開として印する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You now write &lt;c2&gt;&lt;s3&gt;prefix&lt;/s3&gt; &lt;s4&gt;operator&lt;/s4&gt;&lt;/c2&gt; rather than &lt;c5&gt;&lt;s6&gt;operator&lt;/s6&gt; &lt;s7&gt;prefix&lt;/s7&gt;&lt;/c5&gt;, for example.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは今や、&lt;c2&gt;&lt;s3&gt;prefix&lt;/s3&gt; &lt;s4&gt;operator&lt;/s4&gt;&lt;/c2&gt;と書きます、&lt;c5&gt;&lt;s6&gt;operator&lt;/s6&gt; &lt;s7&gt;prefix&lt;/s7&gt;&lt;/c5&gt;ではなく、例えば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You pass this function an expression that evaluates to &lt;c4&gt;&lt;s5&gt;true&lt;/s5&gt;&lt;/c4&gt; or &lt;c6&gt;&lt;s7&gt;false&lt;/s7&gt;&lt;/c6&gt; and a message to display if the result of the condition is &lt;c8&gt;&lt;s9&gt;false&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはこの関数に、&lt;c4&gt;&lt;s5&gt;true&lt;/s5&gt;&lt;/c4&gt;または&lt;c6&gt;&lt;s7&gt;false&lt;/s7&gt;&lt;/c6&gt;に評価する式と条件の結果が&lt;c8&gt;&lt;s9&gt;false&lt;/s9&gt;&lt;/c8&gt;であるならば表示するメッセージを渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You pass this initializer a default value of the appropriate type (called &lt;c2&gt;&lt;s3&gt;repeating&lt;/s3&gt;&lt;/c2&gt;): and the number of times that value is repeated in the new array (called &lt;c4&gt;&lt;s5&gt;count&lt;/s5&gt;&lt;/c4&gt;):</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、このイニシャライザに対して、適切な型のひとつの初期値（&lt;c2&gt;&lt;s3&gt;repeating&lt;/s3&gt;&lt;/c2&gt;と呼ばれます）、そしてその値が新しい配列の中で繰り返される回数（&lt;c4&gt;&lt;s5&gt;count&lt;/s5&gt;&lt;/c4&gt;と呼ばれます）とを渡します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You perform this comparison with the “equal to” operator (&lt;c4&gt;&lt;s5&gt;==&lt;/s5&gt;&lt;/c4&gt;) or the “not equal to” operator (&lt;c6&gt;&lt;s7&gt;!=&lt;/s7&gt;&lt;/c6&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、この比較を「同等」演算子（&lt;c4&gt;&lt;s5&gt;==&lt;/s5&gt;&lt;/c4&gt;）または「不等」演算子（&lt;c6&gt;&lt;s7&gt;!=&lt;/s7&gt;&lt;/c6&gt;）を使って実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You place an ampersand (&lt;c0&gt;&lt;s1&gt;&amp;&lt;/s1&gt;&lt;/c0&gt;) directly before a variable’s name when you pass it as an argument to an in-out parameter, to indicate that it can be modified by the function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは変数の名前の直前に、あなたがin-outパラメータに対する引数としてそれを渡すときに、それが関数によって修正されることができることを示すために、アンパサンド（&lt;c0&gt;&lt;s1&gt;&amp;&lt;/s1&gt;&lt;/c0&gt;）を置きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You place your string within quotation marks (&lt;c1&gt;&lt;s2&gt;"&lt;/s2&gt;&lt;/c1&gt;) and surround that with number signs (&lt;c3&gt;&lt;s4&gt;#&lt;/s4&gt;&lt;/c3&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あなたの文字列を引用符（&lt;c1&gt;&lt;s2&gt;"&lt;/s2&gt;&lt;/c1&gt;）内に置きます、そしてそれをシャープ記号（&lt;c3&gt;&lt;s4&gt;#&lt;/s4&gt;&lt;/c3&gt;）で囲みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You provide an implementation of the &lt;c0&gt;&lt;s1&gt;==&lt;/s1&gt;&lt;/c0&gt; operator in the same way as you implement other infix operators:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;==&lt;/s1&gt;&lt;/c0&gt;演算子の実装を、あなたが他の接中辞演算子を実装するのと同じ方法で提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You represent errors using any type that adopts the &lt;c0&gt;&lt;s1&gt;Error&lt;/s1&gt;&lt;/c0&gt; protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;Error&lt;/s1&gt;&lt;/c0&gt;プロトコルを採用するどんな型でも使用してエラーを表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You resolve a strong reference cycle between a closure and a class instance by defining a &lt;e0&gt;capture list&lt;/e0&gt; as part of the closure’s definition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、クロージャの定義の一部として&lt;e0&gt;捕獲リスト&lt;/e0&gt;を定義することによってクロージャとクラスインスタンスの間で強い参照循環を解消します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You resolve strong reference cycles by defining some of the relationships between classes as weak or unowned references instead of as strong references.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、クラス間の関係の一部を強い参照としてでなくて弱い、または非所有参照として定義することによって強い参照循環を解消します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You saw above how a strong reference cycle can be created when two class instance properties hold a strong reference to each other.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは上で、２つのクラスインスタンスプロパティが強い参照にお互いを守らせるとき、どのように強い参照循環がつくられることができるかを見ました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You set an optional variable to a valueless state by assigning it the special value &lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたが、あるオプショナルの変数を値が無い状態へと設定するには、それに特別な値&lt;c0&gt;&lt;s1&gt;nil&lt;/s1&gt;&lt;/c0&gt;を代入します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You specify a declaration modifier by writing the appropriate keyword or context-sensitive keyword between a declaration’s attributes (if any) and the keyword that introduces the declaration.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、宣言修飾子を適切なキーワードまたは文脈依存キーワードを宣言の属性（もしあれば）と宣言を導入するキーワードとの間に書くことによって指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You specify a default property value by assigning an initial value to the property when it is defined.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、それが定義されるときプロパティに初期値を代入することによって、省略時のプロパティ値を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You specify an attribute by writing the &lt;c0&gt;&lt;s1&gt;@&lt;/s1&gt;&lt;/c0&gt; symbol followed by the attribute’s name and any arguments that the attribute accepts:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;@&lt;/s1&gt;&lt;/c0&gt;記号に続いてその属性の名前そしてその属性が受け入れる任意の引数を書くことによって属性を指定します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You specify optional chaining by placing a question mark (&lt;c0&gt;&lt;s1&gt;?&lt;/s1&gt;&lt;/c0&gt;) after the optional value on which you wish to call a property, method or subscript if the optional is non-&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはオプショナル連鎖を、そのオプショナルが&lt;c2&gt;&lt;s3&gt;nil&lt;/s3&gt;&lt;/c2&gt;で無いならばあなたがプロパティ、メソッド、または添え字を呼び出したいオプショナルの値の後に疑問符（&lt;c0&gt;&lt;s1&gt;?&lt;/s1&gt;&lt;/c0&gt;）を置くことによって指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You specify the associativity of an operator by writing one of the context-sensitive keywords &lt;c1&gt;&lt;s2&gt;left&lt;/s2&gt;&lt;/c1&gt;, &lt;c3&gt;&lt;s4&gt;right&lt;/s4&gt;&lt;/c3&gt;, or &lt;c5&gt;&lt;s6&gt;none&lt;/s6&gt;&lt;/c5&gt;—if your omit the associativity, the default is &lt;c7&gt;&lt;s8&gt;none&lt;/s8&gt;&lt;/c7&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはある演算子の結合性を文脈依存キーワード&lt;c1&gt;&lt;s2&gt;left&lt;/s2&gt;&lt;/c1&gt;、&lt;c3&gt;&lt;s4&gt;right&lt;/s4&gt;&lt;/c3&gt;、または&lt;c5&gt;&lt;s6&gt;none&lt;/s6&gt;&lt;/c5&gt;のうちの１つを書くことによって指定します—あなたが結合性を省略するならば、初期状態は&lt;c7&gt;&lt;s8&gt;none&lt;/s8&gt;&lt;/c7&gt;です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You typically define a failable initializer that creates an optional instance of the appropriate type by placing a question mark after the &lt;c0&gt;&lt;s1&gt;init&lt;/s1&gt;&lt;/c0&gt; keyword (&lt;c2&gt;&lt;s3&gt;init?&lt;/s3&gt;&lt;/c2&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは一般的に、適切な型のオプショナルのインスタンスを作成する失敗できるイニシャライザを、疑問符を&lt;c0&gt;&lt;s1&gt;init&lt;/s1&gt;&lt;/c0&gt;キーワードの後において（&lt;c2&gt;&lt;s3&gt;init?&lt;/s3&gt;&lt;/c2&gt;）定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You typically use internal access when defining an app’s or a framework’s internal structure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは概して内部アクセスを、アプリのまたはフレームワークの内部用の構造体を定義するときに使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You typically use open or public access when specifying the public interface to a framework.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは概して開放または公開アクセスを、あるフレームワークに公開インタフェースを指定するときに使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use &lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt; to iterate over items in a dictionary by providing a pair of names to use for each key-value pair.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは&lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt;を使って、辞書の中の項目のすべてに対して繰り返すことを、一対の名前を提供してそれぞれの「キーと値」の対に使用することで行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use &lt;c0&gt;&lt;s1&gt;try?&lt;/s1&gt;&lt;/c0&gt; to handle an error by converting it to an optional value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;try?&lt;/s1&gt;&lt;/c0&gt;を使って、あるエラーをオプショナルの値に変換することによって取り扱うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use &lt;e0&gt;error handling&lt;/e0&gt; to respond to error conditions your program may encounter during execution.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;e0&gt;エラー処理&lt;/e0&gt;を使ってあなたのプログラムが実行の間に遭遇するエラー状態に応答することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use &lt;e0&gt;optional binding&lt;/e0&gt; to find out whether an optional contains a value, and if so, to make that value available as a temporary constant or variable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あるオプショナルが値を含むかどうか知るために、そしてもしそうならば、その値を一時的な定数または変数として利用可能にするために、&lt;e0&gt;オプショナル束縛&lt;/e0&gt;を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use &lt;e0&gt;optionals&lt;/e0&gt; in situations where a value may be absent.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは&lt;e0&gt;オプショナル&lt;/e0&gt;を、ある値が不在かもしれない状況において使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use a &lt;c0&gt;&lt;s1&gt;defer&lt;/s1&gt;&lt;/c0&gt; statement to execute a set of statements just before code execution leaves the current block of code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは&lt;c0&gt;&lt;s1&gt;defer&lt;/s1&gt;&lt;/c0&gt;文を使うことで、コード実行が現在のコードブロックから離れる直前に一揃いの文を実行するようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use a &lt;c0&gt;&lt;s1&gt;do&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;catch&lt;/s3&gt;&lt;/c2&gt; statement to handle errors by running a block of code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あるコードの塊を実行することによってエラーを処理するために、&lt;c0&gt;&lt;s1&gt;do&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;catch&lt;/s3&gt;&lt;/c2&gt;文を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use a &lt;c0&gt;&lt;s1&gt;throw&lt;/s1&gt;&lt;/c0&gt; statement to throw an error.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは&lt;c0&gt;&lt;s1&gt;throw&lt;/s1&gt;&lt;/c0&gt;文を使ってエラーをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use a &lt;c4&gt;&lt;s5&gt;guard&lt;/s5&gt;&lt;/c4&gt; statement to require that a condition must be true in order for the code after the &lt;c6&gt;&lt;s7&gt;guard&lt;/s7&gt;&lt;/c6&gt; statement to be executed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは&lt;c4&gt;&lt;s5&gt;guard&lt;/s5&gt;&lt;/c4&gt;文を使って、&lt;c6&gt;&lt;s7&gt;guard&lt;/s7&gt;&lt;/c6&gt;文の後のコードが実行されるためにはある条件が真でなけれればならないことを要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use a dictionary when you need to look up values based on their identifier, in much the same way that a real-world dictionary is used to look up the definition for a particular word.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>現実世界の辞書が特定の語の定義を調べるために使われるのと全く同様に、あなたが値をそれらの識別子に基づいて調べる必要があるとき、あなたは辞書を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use a generic &lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt; clause in a protocol declaration to add constraints to an associated types inherited from another protocol, without redeclaring the associated types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、総称体&lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt;節をプロトコル宣言の中で使うことで、別のプロトコルから継承された関連型に制約を追加します、その関連型を再宣言することなしに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use a variadic parameter to specify that the parameter can be passed a varying number of input values when the function is called.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは可変長パラメータを、関数が呼ばれる時にそのパラメータが変動する数の入力値を渡されることができることを示すために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use an &lt;e0&gt;availability condition&lt;/e0&gt; in an &lt;c1&gt;&lt;s2&gt;if&lt;/s2&gt;&lt;/c1&gt; or &lt;c3&gt;&lt;s4&gt;guard&lt;/s4&gt;&lt;/c3&gt; statement to conditionally execute a block of code, depending on whether the APIs you want to use are available at runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;e0&gt;有効性条件&lt;/e0&gt;を&lt;c1&gt;&lt;s2&gt;if&lt;/s2&gt;&lt;/c1&gt;または&lt;c3&gt;&lt;s4&gt;guard&lt;/s4&gt;&lt;/c3&gt;文の中で使って、あなたが使用したいAPIが実行時に有効かどうかに基づいて、条件付きでコードブロックを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use an availability condition to execute a block of code, depending on whether the APIs you want to use are available at runtime.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、有効性条件を使って、あなたが使用したいAPIが実行時に有効かどうかに基づいて、あるコードのブロックを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use assertions and preconditions to express the assumptions you make and the expectations you have while coding, so you can include them as part of your code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは表明と前提条件を使うことであなたのする想定とあなたが持つ期待をコーディングの間に表します、それであなたはそれらをあなたのコードの一部として含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use function types just like any other types in Swift.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、関数型をスウィフトでのあらゆる他の型と同じように使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use it to create logical expressions in which only &lt;e5&gt;one&lt;/e5&gt; of the two values has to be &lt;c6&gt;&lt;s7&gt;true&lt;/s7&gt;&lt;/c6&gt; for the overall expression to be &lt;c8&gt;&lt;s9&gt;true&lt;/s9&gt;&lt;/c8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはそれを、全体的な式が&lt;c8&gt;&lt;s9&gt;true&lt;/s9&gt;&lt;/c8&gt;になるためには２つの値のうちの&lt;e5&gt;１つ&lt;/e5&gt;だけが&lt;c6&gt;&lt;s7&gt;true&lt;/s7&gt;&lt;/c6&gt;であればよい論理式をつくるために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use key-path expressions in dynamic programming tasks, such as key-value observing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはキーパス式を動的なプログラミング作業、例えばキー値監視などにおいて使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use platform names such as &lt;c0&gt;&lt;s1&gt;iOS&lt;/s1&gt;&lt;/c0&gt;, &lt;c2&gt;&lt;s3&gt;macOS&lt;/s3&gt;&lt;/c2&gt;, &lt;c4&gt;&lt;s5&gt;watchOS&lt;/s5&gt;&lt;/c4&gt;, and &lt;c6&gt;&lt;s7&gt;tvOS&lt;/s7&gt;&lt;/c6&gt;—for the full list, see &lt;a8&gt;&lt;s9&gt;Declaration Attributes&lt;/s9&gt;&lt;/a8&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、例えば&lt;c0&gt;&lt;s1&gt;iOS&lt;/s1&gt;&lt;/c0&gt;、&lt;c2&gt;&lt;s3&gt;macOS&lt;/s3&gt;&lt;/c2&gt;、&lt;c4&gt;&lt;s5&gt;watchOS&lt;/s5&gt;&lt;/c4&gt;、そして&lt;c6&gt;&lt;s7&gt;tvOS&lt;/s7&gt;&lt;/c6&gt;のようなプラットホーム名を使います—完全なリストのために、&lt;a8&gt;&lt;s9&gt;宣言属性&lt;/s9&gt;&lt;/a8&gt;を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use subscripts to set and retrieve values by index without needing separate methods for setting and retrieval.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは添え字を使うことで、独立したメソッドを設定や検索のために必要とすることなしに、インデックスによって値を設定したり取得したりします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use the &lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt; loop to iterate over a sequence, such as items in an array, ranges of numbers, or characters in a string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは&lt;c0&gt;&lt;s1&gt;for&lt;/s1&gt;&lt;/c0&gt;-&lt;c2&gt;&lt;s3&gt;in&lt;/s3&gt;&lt;/c2&gt;ループを、ある連続物について、例えば配列の中の項目、数の範囲、または文字列の中の文字について、それに含まれるすべてに繰り返していくために使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use the &lt;c0&gt;&lt;s1&gt;nonobjc&lt;/s1&gt;&lt;/c0&gt; attribute to resolve circularity for bridging methods in a class marked with the &lt;c2&gt;&lt;s3&gt;objc&lt;/s3&gt;&lt;/c2&gt; attribute, and to allow overloading of methods and initializers in a class marked with the &lt;c4&gt;&lt;s5&gt;objc&lt;/s5&gt;&lt;/c4&gt; attribute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c2&gt;&lt;s3&gt;objc&lt;/s3&gt;&lt;/c2&gt;属性で印されるクラスの中のブリッジしているメソッドに対する循環性を解決するために、そして&lt;c4&gt;&lt;s5&gt;objc&lt;/s5&gt;&lt;/c4&gt;属性で印されるクラスにおいてメソッドとイニシャライザをオーバーロードすることを許可するために&lt;c0&gt;&lt;s1&gt;nonobjc&lt;/s1&gt;&lt;/c0&gt;属性を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use the &lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt; property to distinguish between the parameter name and the property name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;self&lt;/s1&gt;&lt;/c0&gt;プロパティをパラメータ名とプロパティ名を区別するために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use the &lt;c2&gt;&lt;s3&gt;self&lt;/s3&gt;&lt;/c2&gt; property to refer to the current instance within its own instance methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c2&gt;&lt;s3&gt;self&lt;/s3&gt;&lt;/c2&gt;プロパティを現在のインスタンスに言及するためにそれ自身のインスタンスメソッド内で使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use the &lt;c9&gt;&lt;s10&gt;case&lt;/s10&gt;&lt;/c9&gt; keyword to introduce new enumeration cases.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは&lt;c9&gt;&lt;s10&gt;case&lt;/s10&gt;&lt;/c9&gt;キーワードを使って、新しい列挙ケース節を導入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use the initializer expression in a function call expression to initialize a new instance of a type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、イニシャライザ式を関数呼び出し式において使うことで、ある型の新しいインスタンスを初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use the runtime name when calling functions that interact with the Objective-C runtime, like &lt;a2&gt;&lt;c3&gt;&lt;s4&gt;NSClassFromString&lt;/s4&gt;&lt;/c3&gt;&lt;/a2&gt;&lt;s5&gt; [https://developer.apple.com/documentation/foundation/1395135-nsclassfromstring]&lt;/s5&gt;, and when specifying class names in an app’s Info.plist file.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはランタイム名を、Objective-Cランタイムと相互作用する関数、&lt;a2&gt;&lt;c3&gt;&lt;s4&gt;NSClassFromString&lt;/s4&gt;&lt;/c3&gt;&lt;/a2&gt;&lt;s5&gt; [https://developer.apple.com/documentation/foundation/1395135-nsclassfromstring]&lt;/s5&gt;などを呼び出す時に、そしてクラス名をアプリのもつInfo.plistファイルの中で指定する時に使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use them to make sure an essential condition is satisfied before executing any further code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはそれらを使って、必要不可欠な条件が満たされるのを何らかのその先のコードが実行される前に確実なものにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You use these patterns in a case label of a &lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt; statement, a &lt;c2&gt;&lt;s3&gt;catch&lt;/s3&gt;&lt;/c2&gt; clause of a &lt;c4&gt;&lt;s5&gt;do&lt;/s5&gt;&lt;/c4&gt; statement, or in the case condition of an &lt;c6&gt;&lt;s7&gt;if&lt;/s7&gt;&lt;/c6&gt;, &lt;c8&gt;&lt;s9&gt;while&lt;/s9&gt;&lt;/c8&gt;, &lt;c10&gt;&lt;s11&gt;guard&lt;/s11&gt;&lt;/c10&gt;, or &lt;c12&gt;&lt;s13&gt;for&lt;/s13&gt;&lt;/c12&gt;-&lt;c14&gt;&lt;s15&gt;in&lt;/s15&gt;&lt;/c14&gt; statement.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはこれらのパターンを&lt;c0&gt;&lt;s1&gt;switch&lt;/s1&gt;&lt;/c0&gt;文のケース節ラベル、&lt;c4&gt;&lt;s5&gt;do&lt;/s5&gt;&lt;/c4&gt;文の&lt;c2&gt;&lt;s3&gt;catch&lt;/s3&gt;&lt;/c2&gt;節において、または&lt;c6&gt;&lt;s7&gt;if&lt;/s7&gt;&lt;/c6&gt;、&lt;c8&gt;&lt;s9&gt;while&lt;/s9&gt;&lt;/c8&gt;、&lt;c10&gt;&lt;s11&gt;guard&lt;/s11&gt;&lt;/c10&gt;、および&lt;c12&gt;&lt;s13&gt;for&lt;/s13&gt;&lt;/c12&gt;-&lt;c14&gt;&lt;s15&gt;in&lt;/s15&gt;&lt;/c14&gt;文のケース節条件において使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You usually implement the &lt;c7&gt;&lt;s8&gt;==&lt;/s8&gt;&lt;/c7&gt; operator, and use the standard library’s default implementation of the &lt;c9&gt;&lt;s10&gt;!=&lt;/s10&gt;&lt;/c9&gt; operator that negates the result of the &lt;c11&gt;&lt;s12&gt;==&lt;/s12&gt;&lt;/c11&gt; operator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは普通は&lt;c7&gt;&lt;s8&gt;==&lt;/s8&gt;&lt;/c7&gt;演算子を実装します、そして標準ライブラリのもつ&lt;c9&gt;&lt;s10&gt;!=&lt;/s10&gt;&lt;/c9&gt;演算子の省略時の実装を使います、それは&lt;c11&gt;&lt;s12&gt;==&lt;/s12&gt;&lt;/c11&gt;演算子の結果を否定するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You want to draw &lt;c0&gt;&lt;s1&gt;60&lt;/s1&gt;&lt;/c0&gt; tick marks, starting with the &lt;c2&gt;&lt;s3&gt;0&lt;/s3&gt;&lt;/c2&gt; minute.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c2&gt;&lt;s3&gt;0&lt;/s3&gt;&lt;/c2&gt;分から開始して、&lt;c0&gt;&lt;s1&gt;60&lt;/s1&gt;&lt;/c0&gt;個の目盛りを描こうと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write &lt;c1&gt;&lt;s2&gt;return&lt;/s2&gt; &lt;s3&gt;nil&lt;/s3&gt;&lt;/c1&gt; within a failable initializer to indicate a point at which initialization failure can be triggered.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは失敗できるイニシャライザの内部で&lt;c1&gt;&lt;s2&gt;return&lt;/s2&gt; &lt;s3&gt;nil&lt;/s3&gt;&lt;/c1&gt;を書くことで、そこにおいて初期化失敗が引き起こされる可能性がある地点を指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write a failable initializer by placing a question mark after the &lt;c0&gt;&lt;s1&gt;init&lt;/s1&gt;&lt;/c0&gt; keyword (&lt;c2&gt;&lt;s3&gt;init?&lt;/s3&gt;&lt;/c2&gt;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、失敗可能なイニシャライザを疑問符を&lt;c0&gt;&lt;s1&gt;init&lt;/s1&gt;&lt;/c0&gt;キーワードの後に置くこと（&lt;c2&gt;&lt;s3&gt;init?&lt;/s3&gt;&lt;/c2&gt;）によって記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write a generic &lt;c7&gt;&lt;s8&gt;where&lt;/s8&gt;&lt;/c7&gt; clause right before the opening curly brace of a type or function’s body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、総称体&lt;c7&gt;&lt;s8&gt;where&lt;/s8&gt;&lt;/c7&gt;節を、型や関数のもつ本文の開き波括弧のまさに前に記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write a pattern after &lt;c0&gt;&lt;s1&gt;catch&lt;/s1&gt;&lt;/c0&gt; to indicate what errors that clause can handle.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、&lt;c0&gt;&lt;s1&gt;catch&lt;/s1&gt;&lt;/c0&gt;の後にあるパターンを書いてどんなエラーをその節が取り扱えるかを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write a pattern after &lt;c2&gt;&lt;s3&gt;catch&lt;/s3&gt;&lt;/c2&gt; just as you do after &lt;c4&gt;&lt;s5&gt;case&lt;/s5&gt;&lt;/c4&gt; in a switch.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、まさにあなたがスイッチにおいて&lt;c4&gt;&lt;s5&gt;case&lt;/s5&gt;&lt;/c4&gt;の後にするように、&lt;c2&gt;&lt;s3&gt;catch&lt;/s3&gt;&lt;/c2&gt;の後にひとつのパターンを書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write a precondition by calling the &lt;a0&gt;&lt;c1&gt;&lt;s2&gt;precondition(_:_:file:line:)&lt;/s2&gt;&lt;/c1&gt;&lt;/a0&gt;&lt;s3&gt; [https://developer.apple.com/documentation/swift/1540960-precondition]&lt;/s3&gt; function.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、前提条件を&lt;a0&gt;&lt;c1&gt;&lt;s2&gt;precondition(_:_:file:line:)&lt;/s2&gt;&lt;/c1&gt;&lt;/a0&gt;&lt;s3&gt; [https://developer.apple.com/documentation/swift/1540960-precondition]&lt;/s3&gt;関数を呼び出すことによって記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write an argument label before the parameter name, separated by a space:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは引数ラベルを、パラメーター名の前に、空白で区切って書きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write an assertion by calling the &lt;a0&gt;&lt;c1&gt;&lt;s2&gt;assert(_:_:file:line:)&lt;/s2&gt;&lt;/c1&gt;&lt;/a0&gt;&lt;s3&gt; [https://developer.apple.com/documentation/swift/1541112-assert]&lt;/s3&gt; function from the Swift standard library.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは表明を&lt;a0&gt;&lt;c1&gt;&lt;s2&gt;assert(_:_:file:line:)&lt;/s2&gt;&lt;/c1&gt;&lt;/a0&gt;&lt;s3&gt; [https://developer.apple.com/documentation/swift/1541112-assert]&lt;/s3&gt;関数をSwift標準ライブラリから呼び出すことによって記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write an implicitly unwrapped optional by placing an exclamation point (&lt;c1&gt;&lt;s2&gt;String!&lt;/s2&gt;&lt;/c1&gt;) rather than a question mark (&lt;c3&gt;&lt;s4&gt;String?&lt;/s4&gt;&lt;/c3&gt;) after the type that you want to make optional.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは暗黙的にアンラップされるオプショナルを、あなたがオプショナルを作りたい型の後に疑問符（&lt;c3&gt;&lt;s4&gt;String?&lt;/s4&gt;&lt;/c3&gt;）ではなく感嘆符（&lt;c1&gt;&lt;s2&gt;String!&lt;/s2&gt;&lt;/c1&gt;）を置くことによって記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write an in-out parameter by placing the &lt;c0&gt;&lt;s1&gt;inout&lt;/s1&gt;&lt;/c0&gt; keyword right before a parameter’s type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、パラメータの型のすぐ前に&lt;c0&gt;&lt;s1&gt;inout&lt;/s1&gt;&lt;/c0&gt;キーワードを置くことによってin-outパラメータを書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write an instance method within the opening and closing braces of the type it belongs to.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、インスタンスメソッドを、それが属している型の開始と終わりの波括弧の内部に書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write an optional tuple return type by placing a question mark after the tuple type’s closing parenthesis, such as &lt;c3&gt;&lt;s4&gt;(Int,&lt;/s4&gt; &lt;s5&gt;Int)?&lt;/s5&gt;&lt;/c3&gt; or &lt;c6&gt;&lt;s7&gt;(String,&lt;/s7&gt; &lt;s8&gt;Int,&lt;/s8&gt; &lt;s9&gt;Bool)?&lt;/s9&gt;&lt;/c6&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはオプショナルタプルの戻り型をタプル型の閉じ括弧の後に疑問符を置くことによって書きます、例えば&lt;c3&gt;&lt;s4&gt;(Int,&lt;/s4&gt; &lt;s5&gt;Int)?&lt;/s5&gt;&lt;/c3&gt;または&lt;c6&gt;&lt;s7&gt;(String,&lt;/s7&gt; &lt;s8&gt;Int,&lt;/s8&gt; &lt;s9&gt;Bool)?&lt;/s9&gt;&lt;/c6&gt;など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write deinitializers with the &lt;c1&gt;&lt;s2&gt;deinit&lt;/s2&gt;&lt;/c1&gt; keyword, similar to how initializers are written with the &lt;c3&gt;&lt;s4&gt;init&lt;/s4&gt;&lt;/c3&gt; keyword.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、イニシャライザが&lt;c3&gt;&lt;s4&gt;init&lt;/s4&gt;&lt;/c3&gt;キーワードで書かれる方法と同様に、デイニシャライザを&lt;c1&gt;&lt;s2&gt;deinit&lt;/s2&gt;&lt;/c1&gt;キーワードを使って書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write nested comments by starting a multiline comment block and then starting a second multiline comment within the first block.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはひとつの複数行コメント・ブロックを始めて、それから第二の複数行を最初のブロック以内に始めることによって入れ子にされたコメントを書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write subscript definitions with the &lt;c0&gt;&lt;s1&gt;subscript&lt;/s1&gt;&lt;/c0&gt; keyword, and specify one or more input parameters and a return type, in the same way as instance methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、添え字定義を&lt;c0&gt;&lt;s1&gt;subscript&lt;/s1&gt;&lt;/c0&gt;キーワードを使って書きます、そしてインスタンスメソッドと同じ方法で、１つ以上の入力パラメータと戻り型を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write the diagnostic message as a static string literal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、診断メッセージを静的文字列リテラルとして書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write the placeholder type name inside angle brackets after &lt;c2&gt;&lt;s3&gt;subscript&lt;/s3&gt;&lt;/c2&gt;, and you write a generic &lt;c4&gt;&lt;s5&gt;where&lt;/s5&gt;&lt;/c4&gt; clause right before the opening curly brace of the subscript’s body.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、プレースホルダ型名を山括弧の内部に&lt;c2&gt;&lt;s3&gt;subscript&lt;/s3&gt;&lt;/c2&gt;の後に書きます、そしてあなたは総称体&lt;c4&gt;&lt;s5&gt;where&lt;/s5&gt;&lt;/c4&gt;節を添え字本文の開き波括弧の直前に書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write these constraints after the name of the protocol you’re extending by writing a generic &lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt; clause.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたはこれらの制約を、総称体&lt;c0&gt;&lt;s1&gt;where&lt;/s1&gt;&lt;/c0&gt;節を書くことによってあなたが拡張しているプロトコルの名前の後に書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write these initializers as part of the protocol’s definition in exactly the same way as for normal initializers, but without curly braces or an initializer body:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、これらのイニシャライザをプロトコル定義の一部として普通のイニシャライザと正確に同じ方法で書くことができます、しかし波括弧またはイニシャライザ本文はありません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You write type constraints by placing a single class or protocol constraint after a type parameter’s name, separated by a colon, as part of the type parameter list.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、型パラメーターリストの一部として、型パラメータの名前の後にコロンで区切って１つのクラスまたはプロトコル制約を置くことによって、型制約を書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Your code can interact with these identifiers, but you can’t declare identifiers with that prefix.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたのコードは、それらの識別子と相互作用できます、しかしあなたは識別子をその接頭辞で宣言できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You’re accessing only stored properties of an instance, not computed properties or class properties.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたがインスタンスの格納プロパティだけにアクセスしている、計算プロパティやクラスプロパティではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You’re likely to encounter this kind of error in two kinds of situations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、この種のエラーに２種類の状況において出くわしそうに思われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You’re not limited to the predefined operators.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、あらかじめ定義された演算子に制限されていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You’ve actually been using value types extensively throughout the previous chapters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あなたは、実際に前の章を通して広く値型を使っていました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Zeros are inserted in the spaces left behind after the original bits are moved to the left or right.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>元のビットが左または右へ移動した後に残される空きに、ゼロが差し込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Zeros become ones, and ones become zeros.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ゼロは１になります、そして１はゼロになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>but is written over multiple lines.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>（しかし複数行にわたって書かれます。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>giving a remainder value of &lt;c0&gt;&lt;s1&gt;-1&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そして&lt;c0&gt;&lt;s1&gt;-1&lt;/s1&gt;&lt;/c0&gt;の余り値を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>where &lt;c0&gt;&lt;s1&gt;some&lt;/s1&gt; &lt;s2&gt;multiplier&lt;/s2&gt;&lt;/c0&gt; is the largest number of multiples of &lt;c3&gt;&lt;s4&gt;b&lt;/s4&gt;&lt;/c3&gt; that will fit inside &lt;c5&gt;&lt;s6&gt;a&lt;/s6&gt;&lt;/c5&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここで&lt;c0&gt;&lt;s1&gt;some&lt;/s1&gt; &lt;s2&gt;multiplier&lt;/s2&gt;&lt;/c0&gt;は&lt;c3&gt;&lt;s4&gt;b&lt;/s4&gt;&lt;/c3&gt;の倍数で&lt;c5&gt;&lt;s6&gt;a&lt;/s6&gt;&lt;/c5&gt;の内部に収まる最も大きな数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>“A function that has two parameters, both of type &lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt;, and that returns a value of type &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;.”</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「２つのパラメータを持ち、両方とも型&lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt;で、そして型&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;の値をひとつ返す関数」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>“Consider the value of &lt;c0&gt;&lt;s1&gt;directionToHead&lt;/s1&gt;&lt;/c0&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「&lt;c0&gt;&lt;s1&gt;directionToHead&lt;/s1&gt;&lt;/c0&gt;の値を考慮する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>“Declare a new constant called &lt;c0&gt;&lt;s1&gt;maximumNumberOfLoginAttempts&lt;/s1&gt;&lt;/c0&gt;, and give it a value of &lt;c2&gt;&lt;s3&gt;10&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「&lt;c0&gt;&lt;s1&gt;maximumNumberOfLoginAttempts&lt;/s1&gt;&lt;/c0&gt;と呼ばれるある新しい定数を宣言して、それに&lt;c2&gt;&lt;s3&gt;10&lt;/s3&gt;&lt;/c2&gt;というひとつの値を与える。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>“Declare a variable called &lt;c0&gt;&lt;s1&gt;welcomeMessage&lt;/s1&gt;&lt;/c0&gt; that is of type &lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;.”</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「&lt;c0&gt;&lt;s1&gt;welcomeMessage&lt;/s1&gt;&lt;/c0&gt;と呼ばれる型&lt;c2&gt;&lt;s3&gt;String&lt;/s3&gt;&lt;/c2&gt;の変数を宣言する。」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>“Define a variable called &lt;c0&gt;&lt;s1&gt;mathFunction&lt;/s1&gt;&lt;/c0&gt;, which has a type of ‘a function that takes two &lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt; values, and returns an &lt;c4&gt;&lt;s5&gt;Int&lt;/s5&gt;&lt;/c4&gt; value.’ Set this new variable to refer to the function called &lt;c6&gt;&lt;s7&gt;addTwoInts&lt;/s7&gt;&lt;/c6&gt;.”</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「『２つの&lt;c2&gt;&lt;s3&gt;Int&lt;/s3&gt;&lt;/c2&gt;値をとり、１つの&lt;c4&gt;&lt;s5&gt;Int&lt;/s5&gt;&lt;/c4&gt;値を返す関数』の型を持ち、&lt;c0&gt;&lt;s1&gt;mathFunction&lt;/s1&gt;&lt;/c0&gt;と呼ばれる、ある変数を定義する。この新しい変数を&lt;c6&gt;&lt;s7&gt;addTwoInts&lt;/s7&gt;&lt;/c6&gt;と呼ばれる関数に言及するように設定する。」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>“Define an enumeration type called &lt;c0&gt;&lt;s1&gt;Barcode&lt;/s1&gt;&lt;/c0&gt;, which can take either a value of &lt;c2&gt;&lt;s3&gt;upc&lt;/s3&gt;&lt;/c2&gt; with an associated value of type (&lt;c4&gt;&lt;s5&gt;Int&lt;/s5&gt;&lt;/c4&gt;, &lt;c6&gt;&lt;s7&gt;Int&lt;/s7&gt;&lt;/c6&gt;, &lt;c8&gt;&lt;s9&gt;Int&lt;/s9&gt;&lt;/c8&gt;, &lt;c10&gt;&lt;s11&gt;Int&lt;/s11&gt;&lt;/c10&gt;), or a value of &lt;c12&gt;&lt;s13&gt;qrCode&lt;/s13&gt;&lt;/c12&gt; with an associated value of type &lt;c14&gt;&lt;s15&gt;String&lt;/s15&gt;&lt;/c14&gt;.”</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「&lt;c0&gt;&lt;s1&gt;Barcode&lt;/s1&gt;&lt;/c0&gt;と呼ばれる列挙型を定義します、それは&lt;c2&gt;&lt;s3&gt;upc&lt;/s3&gt;&lt;/c2&gt;の値で型（&lt;c4&gt;&lt;s5&gt;Int&lt;/s5&gt;&lt;/c4&gt;、&lt;c6&gt;&lt;s7&gt;Int&lt;/s7&gt;&lt;/c6&gt;、&lt;c8&gt;&lt;s9&gt;Int&lt;/s9&gt;&lt;/c8&gt;、&lt;c10&gt;&lt;s11&gt;Int&lt;/s11&gt;&lt;/c10&gt;）の関連値をもつ、または&lt;c12&gt;&lt;s13&gt;qrCode&lt;/s13&gt;&lt;/c12&gt;の値で型&lt;c14&gt;&lt;s15&gt;String&lt;/s15&gt;&lt;/c14&gt;の関連値をもつものをとることができます。」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>“If the optional &lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt; returned by &lt;c2&gt;&lt;s3&gt;Int(possibleNumber)&lt;/s3&gt;&lt;/c2&gt; contains a value, set a new constant called &lt;c4&gt;&lt;s5&gt;actualNumber&lt;/s5&gt;&lt;/c4&gt; to the value contained in the optional.”</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「&lt;c2&gt;&lt;s3&gt;Int(possibleNumber)&lt;/s3&gt;&lt;/c2&gt;によって返されるオプショナルの&lt;c0&gt;&lt;s1&gt;Int&lt;/s1&gt;&lt;/c0&gt;が値を含むならば、ある新しい定数&lt;c4&gt;&lt;s5&gt;actualNumber&lt;/s5&gt;&lt;/c4&gt;をそのオプショナルに含まれる値に設定してください。」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>“Try to access &lt;c0&gt;&lt;s1&gt;item&lt;/s1&gt;&lt;/c0&gt; as a &lt;c2&gt;&lt;s3&gt;Movie&lt;/s3&gt;&lt;/c2&gt;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「&lt;c0&gt;&lt;s1&gt;item&lt;/s1&gt;&lt;/c0&gt;に&lt;c2&gt;&lt;s3&gt;Movie&lt;/s3&gt;&lt;/c2&gt;としてアクセスを試みてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>…and so on.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>…などなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>…and so on:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>…などなど：</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
