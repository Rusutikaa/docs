<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="5.3.0_0_2fd7a9ecc" segtype="sentence" srclang="en-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv lang="en-US">
        <seg>(A generic version of these functions is defined below.)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（これらの関数の総称体版は、下で定義されます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>(A literal value is a value that appears directly in your source code, such as 42 and 3.14159 in the examples below.)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（リテラル値「文字通りの値」は、直接あなたのソース・コードで見かける値です、例えば下の例での42と3.14159）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>(For more information about capturing values in a closure, see Capturing Values.)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（クロージャにおいて値を捕獲することに関する詳細は、値を捕獲するを見てください。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>(In the swapTwoValues(_:_:) example above, T was replaced with Int the first time the function was called, and was replaced with String the second time it was called.)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（上のswapTwoValues(_:_:)の例では、Tは関数が呼ばれた最初の時にIntと取り替えられて、それが呼ばれた２番目の時にStringと取り替えられました）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>(It can’t contain anything else, such as a Bool value or a String value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg> （それは、他の何か、例えばBool値またはString値などを含むことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>(It’s assumed that all media items, including all movies and songs, will have a name.)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（全ての映画と歌を含む、全てのメディア項目が名前を持つと仮定されます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>(Neither stylistic technique is strictly necessary, but they lead to neater code.)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（文体上の技巧は絶対に必要な訳ではありません、しかしそれはすっきりしたコードにつながります。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>(Nested tuples are allowed.)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（入れ子にされたタプルは、認められます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>(Note that these type methods can access the highestUnlockedLevel type property without your needing to write it as LevelTracker.highestUnlockedLevel.)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（これらの型メソッドは、あなたがそれをLevelTracker.highestUnlockedLevelと書かなくても、highestUnlockedLevel型プロパティにアクセスできる点に注意してください）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>(Strings have a similar optimization, but if two strings share memory, they’re equal.)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（文字列は同様な最適化を待ちます、しかし２つの文字列がメモリを共有するならば、それらは等しいです。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>(Swift reports an error at compile time if a protocol requirement isn’t fulfilled.)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（プロトコル要件が満たされないならば、スウィフトは実行時にエラーを報告します）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>(The name property is an optional String property, and so it automatically receives a default value of nil, even though this value isn’t written in the code.)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（nameプロパティはオプショナルのStringプロパティです、なのでそれは自動的に省略時の値のnilを受け取ります、たとえこの値がそのコードに書かれないとしてもです。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>(The dice property is declared as a constant property because it doesn’t need to change after initialization, and the protocol only requires that it must be gettable.)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（diceプロパティは定数プロパティとして宣言されます、なぜなら、それが初期化の後に変化する必要がなく、そして、プロトコルはそれが取得可能なことを必要とするだけであるからです）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>(The Boolean return value of advance(to:) is ignored, because the level is known to have been unlocked by the call to LevelTracker.unlock(_:) on the previous line.)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（advance(to:)のブールの戻り値は無視されます、なぜなら、このレベルは前の行でLevelTracker.unlock(_:)呼び出しによってすでに錠を開けられていると分かるからです）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>(The examples below are based on 8-bit signed integers for simplicity, but the same principles apply for signed integers of any size.)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（下の例は、単純さのために8ビット符号つき整数に基づきます、しかし同じ原理はあらゆるサイズの符号つき整数に当てはまります）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>(The examples of modifying an inherited property’s default value in a subclass initializer have been moved to the Initialization chapter.)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（サブクラスのイニシャライザの継承されたプロパティの省略時の値を修正する例は章初期化に移動されました。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>(The expression number % 10 gives a value of 6 for 16, 8 for 58, and 0 for 510.)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（式数number % 10は、16のために6、58のために8、510のために0の値を与えます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>(The parameters to functions and closures are always constants.)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（関数およびクロージャに対するパラメータは常に定数です。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>(The property wrapper is responsible for storing the wrapped value, so there’s no synthesized code for that.)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（プロパティラッパーは、ラップ値を格納することに責任があります、それでそれに対する合成コードはありません。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>(The same isn’t true for structures and enumerations, because they’re always copied when they’re assigned to a constant or variable, or passed to a function.)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（同じことは構造体と列挙にあてはまりません、なぜなら、それらが値型であって、それらが定数または変数に代入されるか関数に渡される時に、常にコピーされるからです）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>(This raw Int value isn’t used for the Jack, Queen, King, and Ace cards.)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（この生のInt値は、ジャック、クイーン、キング、そしてエースのカードには使われません）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>(Unlike Objective-C categories, Swift extensions don’t have names.)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（Objective-Cカテゴリーとは異なり、スウィフト拡張には、名前がありません。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// "Apple International" isn't the real airport for APL, so delete it</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「アップル・インターナショナル」は、APLのための本当の空港ではないので、それを削除します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// "Imagination is more important than knowledge" - Einstein</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「想像は知識より重要です」 - アインシュタイン）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// "Maple Syrup" is now the first item in the list</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「メープルシロップ」が、現在はリストの最初の項目です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// "Voulez-vous un café?" using LATIN SMALL LETTER E WITH ACUTE</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「Voulez-vous un café?」は揚音付きラテン小文字eを使用している）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// "Voulez-vous un café?" using LATIN SMALL LETTER E and COMBINING ACUTE ACCENT</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「Voulez-vous un café?」はラテン小文字eと揚音アクセント結合を使用している）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// "required" from SomeProtocol conformance; "override" from SomeSuperClass</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（SomeProtocol準拠からの「required」；SomeSuperClasからの「override」）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// 1 times 5 is 5</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（１かける５は、５です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// 2 times 5 is 10</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（２かける５は、10です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// 3 times 5 is 15</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（３かける５は、15です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// 4 times 5 is 20</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（４かける５は、20です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// 5 times 5 is 25</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（５かける５は、25です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// A 12-sided dice</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（ひとつの12面のさいころ遊び）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// A game of Snakes and Ladders with 25 squares</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（25ますのヘビとはしごのゲーム）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// A game of Snakes and Ladders with 25 squares:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（25ますのヘビとはしごのゲーム：）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// A hamster named Simon</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（サイモンという名前のハムスター）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// A read access from the memory where one is stored.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（oneが格納されるところのメモリから読み出しアクセス。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// A write access to the memory where one is stored.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（oneが格納されるところのメモリに対する書き込みアクセス。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// APL has now been removed from the dictionary</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（APLは、現在この辞書から削除されました）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// About to set totalSteps to 200</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（totalStepsを200に設定している）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// About to set totalSteps to 360</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（totalStepsを360に設定している）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// About to set totalSteps to 896</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（totalStepsを896に設定している）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Added 160 steps</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（160の歩数が加えられた）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Added 200 steps</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（200の歩数が加えられた）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Added 536 steps</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（536の歩数が加えられた）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// All items match, so return true.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（全ての項目が合致、なのでtrueを返す。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Apply f to create an array of Number instances with integer values</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（fを適用して整数値を持つNumberインスタンスからなる配列を作成する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Area is 12.5663708</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（面積は、12.5663708です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Area is 243610.0</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（面積は、243610.0です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// AutomaticCar: traveling at 35.0 miles per hour in gear 4</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（AutomaticCar: 時速35.0マイル、４速ギアで運行中）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Baking Powder</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（膨らし粉）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Bananas</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（バナナ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Because 'fn' closes over 'index', it uses the new value</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（'fn'が'index'をしっかり掴むので、それは新しい値を使います）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Bicycle: 2 wheel(s)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（自転車: ２輪）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Bicycle: traveling at 15.0 miles per hour</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（自転車：時速15マイルで運行中）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Bind x and y to the elements of point.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（xとyをpointの要素へ束縛します。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// BlackjackCard properties and methods</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（BlackjackCardのプロパティとメソッド）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Both approaches below are equivalent.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（下の両方の取り組みは等しいです。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Call the underlying method directly.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（基礎をなすメソッドを直接に呼び出します。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Call the underlying subscript directly.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（基礎をなす添え字を直接に呼び出す。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Car: traveling at 25.0 miles per hour in gear 3</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（Car: ３速ギアで時速25.0マイルで運行中）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Check each pair of items to see if they're equivalent.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（各項目の対をそれらが等しいかどうか見るため調べる。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Check that both containers contain the same number of items.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（両方のコンテナが同じ数の項目を含むことを確認する。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Convert the result to a String for long-term storage.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（結果を長期保管のためのStringへ変換する。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Counting to zero:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「ゼロまで数えます：」）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Do something three times.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（３回何かをします。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Do the same thing using a key path.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（同じことをキーパスを使って行う。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Equivalent to compoundValue = (a: 10, b: 20)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（compoundValue = (a: 10, b: 20) に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Error: Not enough information to infer C.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（Error: Cを推論するための情報が十分でない。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Error: Protocol with associated types can't be used as a return type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（Error: 関連型を持つプロトコルは戻り型として使われることができません。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Error: await applies only to the first function call</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（エラー：awaitは、最初の関数呼び出しにだけ適用されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Error: conflicting access to properties of playerInformation</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（エラー：playerInformationのプロパティに対するアクセス衝突）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Error: conflicting accesses to oscar</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（エラー：oscarに対するアクセス衝突）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Error: conflicting accesses to playerOneScore</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（エラー：playerOneScoreに対するアクセス衝突）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Error: conflicting accesses to stepSize</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（エラー：stepSizeに対するアクセス衝突）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Error: redundant conformance of 'Array&lt;Element&gt;' to protocol 'Loggable'</seg>
      </tuv>
      <tuv lang="ja">
        <seg>// エラー: プロトコル 'Loggable' に対しての 'Array&lt;Element&gt;' の冗長な準拠</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Error: redundant conformance of 'Array&lt;Element&gt;' to protocol 'Serializable'</seg>
      </tuv>
      <tuv lang="ja">
        <seg>// エラー: プロトコル 'Serializable' に対しての 'Array&lt;Element&gt;' の冗長な準拠</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Error: try applies only to the first function call</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（エラー：tryは、最初の関数呼び出しにだけ適用されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Fall back to earlier iOS and macOS APIs</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（以前のiOSとmacOS APIに後退する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// First release</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（最初のリリース）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Flour</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（小麦粉）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Hello, Alex!</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（よろしく、アレックス！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Hello, Anna!</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（よろしく、アンナ！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Hello, Brian!</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（よろしく、ブライアン！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Hello, Jack!</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（よろしく、ジャック！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Hello, Michael</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（こんにちは、マイケル）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Here's how you call this function with a trailing closure instead:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（あなたが代わりに後付クロージャでどのようにこの関数を呼ぶのかがここにあります：）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Here's how you call this function without using a trailing closure:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（あなたが後付クロージャを使うことなくどのようにこの関数を呼ぶのかがここにあります：）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Hoverboard: 0 wheel(s) in a beautiful silver</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（ホバーボード: ０個の車輪、美しい銀色で）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// If you omit the second argument when calling this function, then</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（あなたが２番目の引数をこの関数を呼び出すときに省略したならば、その時）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// In the function body, firstParameterName and secondParameterName</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（関数本文において、firstParameterNameとsecondParameterNameは、）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// In the function body, parameterName refers to the argument value</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（関数本文において、parameterNameは）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// In the implementation of a subscript...</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（ある添え字の実装において...）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Inferred that Suffix is Stack.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（SuffixはStackであると推論される。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Inferred that Suffix is Stack&lt;Int&gt;.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（Suffix は Stack&lt;Int&gt;であると推論される。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Int8 can't store a number larger than its maximum value,</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（Int8はその最大の値より大きい数を格納することができません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Item 1: Six eggs</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（項目１：６つの卵）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Item 2: Milk</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（項目２：牛乳）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Item 3: Flour</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（項目３：小麦粉）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Item 4: Baking Powder</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（項目４：膨らし粉）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Item 5: Bananas</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（項目５：バナナ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Make a local copy and manually copy it back.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（ローカルコピーを作って手動でそれを元へコピーする。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Make an explicit copy.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（明示的なコピーを作る。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Match only non-nil values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（nilでない値にのみマッチする。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Match using an enumeration case pattern.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（列挙ケース節パターンを使っているマッチ。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Match using an optional pattern.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（オプショナルパターンを使っているマッチ。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Milk</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（牛乳）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Movie: Casablanca, dir. Michael Curtiz</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（映画：『カサブランカ』（監）マイケル・カーティス）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Movie: Citizen Kane, dir. Orson Welles</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（映画：『市民ケーン』（監）オーソン・ウェルズ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Now t is (20, 20, 30)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（tは、現在 (20, 20, 30)です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Operate on localX asynchronously, then wait before returning.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（非同期にlocalXを処理を施す、それから返すまえに待機する。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Overload the ~= operator to match a string with an integer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（~=演算子をオーバーロードして文字列を整数と照合するようにする。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Perform a suitable setting action here.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（ふさわしい設定動作をここで行う。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Person 1 is called Anna</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（人物は１、アンナと呼ばれる）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Person 2 is called Alex</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（人物２は、アレックスと呼ばれる）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Person 3 is called Brian</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（人物３は、ブライアンと呼ばれる）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Person 4 is called Jack</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（人物４は、ジャックと呼ばれる）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "(1, -1) is on the line x == -y"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「(1, -1)は、x == -yの線上にある」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "(1, 1) is inside the box"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「(1, 1）は、この四角の中にあります」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "(1, 2) is near the origin."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「（1, 2）は原点に近いです。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "0"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「0」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "10"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「10」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "12"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「12」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "2"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「2」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "27"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「27」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "3 to the power of 10 is 59049"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「３の10乗は、59049です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "325"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（ "325" を出力する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "6 mansion scenes; 2 cell scenes"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「６つの邸宅場面；２つの僧房場面」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "6"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「6」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "64"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「64」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "648.75"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「648.75」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "7"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「７」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "some default text"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「some default text」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "&lt;p&gt;hello, world&lt;/p&gt;"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「&lt;p&gt;よろしく、世界&lt;/p&gt;」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "A 12-sided dice"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「ひとつの12面さいころ」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "A game of Snakes and Ladders with 25 squares"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「25ますのヘビとはしごのゲーム」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "A hamster named Simon"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「サイモンという名前のハムスター」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "A marathon is 42195.0 meters long"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「マラソンは、42195.0メートルの長さです」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "A new player has joined the game with 100 coins"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「新しいプレーヤーが、100のコインを持ってゲームに参加しました」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "ACCESS DENIED"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「アクセス拒否」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "All items match."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「全ての項目が一致する」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "An animal was initialized with a species of Giraffe"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「一匹の動物がキリンの種族で初期化された」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "An implicitly unwrapped optional string."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「暗黙的にアンラップされるオプショナルの文字列。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "And another one: 0.729023776863283"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「さらにもう１つ：0.729023776863283」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "And here's a random Boolean: true"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「そしてここに任意のブール: trueがあります」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Another value."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「別の値。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Apartment 4A is being deinitialized"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「アパート4Aは、デイニシャライズされた」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Bonjour!"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「Bonjour!」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Canada's capital city is called Ottawa"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「カナダの首都はオタワです」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Card #1234567890123456 is being deinitialized"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「カード#1234567890123456は、デイニシャライズされた」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Choo Choo"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「シュッシュッ」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Collected 2 closures."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「２つのクロージャが集められた。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Do you like cheese?"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「あなたはチーズが好きですか？」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Eww, turnips are horrible."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「うー、カブ怖い。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Happy birthday, Malcolm, you're 21!"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「誕生日おめでとうマルコム、あなたは21です！」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Hello Jane!"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「こんにちはジェーン！」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Hello John!"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「こんにちはジョン！」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Hello again, Anna!"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「またあったね、アンナ！」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Hello again, Tim!"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「またあったね、ティム！」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Hello, Anna!"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「こんにちは、アンナ！」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Hello, Brian!"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「こんにちは、ブライアン！」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Here's a random number: 0.3746499199817101"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「ここに任意の数: 0.3746499199817101があります」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "How about beets?"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「赤かぶはどう？」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "I have 3 favorite music genres."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「私には大好きな音楽ジャンルが３つあります。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "I have particular music preferences."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「私には特定の音楽の好みがあります。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "I hope the weather is nice in Cupertino."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「クパチーノの天気がいいことを望むよ」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "I hope the weather is nice near you."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「あなたの近くの天気がいいといいね」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Insufficient funds. Please insert an additional 2 coins."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「金額が不足しています。さらに２コイン入れてください。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Int"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「Int」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "It was not possible to print the number of rooms."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「部屋の数を出力することは、可能ではありませんでした。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "It was not possible to set the address."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「住所を設定することは、可能ではありませんでした。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "It's not that cold. Wear a t-shirt."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「そんなに寒くありません。Tシャツを着てください。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "It's really warm. Don't forget to wear sunscreen."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「非常に暖かいです。日焼け止めを塗るのを忘れないでください。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "It's too funky in here."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「そりゃここじゃfunkyすぎる。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "It's very cold. Consider wearing a scarf."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「非常に寒いです。スカーフを巻くことを考えてください。 」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Item: sock, quantity: 2"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「項目：靴下、数量：２」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "John Appleseed is being deinitialized"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「John Appleseedは、デイニシャライズされた」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "John Appleseed is being initialized"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「John Appleseedは、初期化された」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "John's building identifier begins with "The"."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「ジョンの建物名は「月」で始まります」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "John's building identifier is The Larches."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「ジョンの建物名は月桂樹です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "John's residence has 1 room(s)."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「ジョンの邸宅には１部屋ある」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "John's street name is Laurel Street."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「ジョンの街路名は月桂樹通りです」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Made an index"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（"Made an index" を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Media library contains 2 movies and 3 songs"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「情報媒体書庫は、２つの映画と３つの歌を含みます」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Mostly harmless"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「おおむね無害」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Nothing to see here"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「ここで見るものは何も無し」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Now serving Alex!"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（今アレックスに対応中！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Now serving Barry!"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（今バリーに対応中！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Now serving Chris!"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（今クリスに対応中！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Now serving Daniella!"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（今ダニエラに対応中！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Now serving Ewa!"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（今エヴァに対応中！）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "On an axis, 9 from the origin"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「ある軸上で、原点から９」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "One inch is 0.0254 meters"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「１インチは、0.0254メートルです」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "PlayerOne has left the game"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「PlayerOneは、ゲームを離れました」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "PlayerOne won 2000 coins &amp; now has 2100 coins"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「PlayerOneは2000のコインを獲得＆現在2100のコインを持ちます」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "QR code: ABCDEFGHIJKLMNOP."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「QRコード：ABCDEFGHIJKLMNOP。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Result: 5"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「結果：５」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Result: 6"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「結果：６」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Result: 8"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「結果：８」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Rock? I'm over it."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「Rock？ もう済んだことさ（曲名？）。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Some value."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「ある値。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "SomeSubClass"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「 SomeSubClass 」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "The airports dictionary contains 2 items."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「airports辞書は２項目を含む。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "The bank now has 10000 coins"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「胴元には現在10000コインがあります」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "The bank now only has 7900 coins left"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「胴元には現在7900個のコインだけが残っています」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "The current value of friendlyWelcome is Bonjour!"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「The current value of friendlyWelcome is Bonjour!」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "The default temperature is 32.0° Fahrenheit"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「省略時の温度は華氏32.0°です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "The first number is 10."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「最初の数は、10です。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "The first room name is Living Room."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「最初の部屋名は、居間です。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "The frameRate property of tenEighty is now 30.0"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「tenEightyのframeRateプロパティは、現在は30.0です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "The index of llama is 2"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「ラマのインデックスは、２です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "The integer value of 三 is 3."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「三の整数値は３です。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "The name of the airport is Dublin Airport."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「空港名は「ダブリン空港です。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "The number 5 is a prime number, and also an integer."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「数５は素数で、そのうえ整数です。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "The number of edits is 3"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「編集数は、３です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "The old value for DUB was Dublin."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「DUBの古い値は「ダブリンでした。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "The point is at (1, 2)."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「pointは（1, 2）です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "The point is at (3, 2)."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「pointは（3, 2）です。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "The point is now at (3.0, 4.0)"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「ポイントは現在は(3.0, 4.0)です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "The removed airport's name is Dublin Airport."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「削除された空港の名前はダブリンです。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "The second number is 42."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（２番目の数は、42です。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "The shopping list contains 2 items."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「買い物リストは２つの項目を含みます。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "The status code is 200"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「状態コードは200です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "The status code is 404"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「状態コードは404です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "The status message is Not Found"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「状態メッセージが見つかりません」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "The status message is OK"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「状態メッセージはOKです」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "The top item on the stack is tres."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「このスタックの一番上の項目はtresです」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "The width of someResolution is 0"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「someResolutionの幅は0です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "The width of someVideoMode is 0"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「someVideoModeの幅は0です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "The width of someVideoMode is now 1280"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「someVideoModeの幅は、現在は1280です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "There are 5 scenes in Act 1"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「５つの場面が一幕にあります」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "There are dozens of moons orbiting Saturn."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「土星の軌道を回るたくさんの月がある。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "There are now 9900 coins left in the bank"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「現在9900個のコインが胴元に残されます」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "There isn't a planet at position 11"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「位置11に惑星は存在しない」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "These two characters aren't equivalent."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「これら２つの文字列は等しくない。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "These two strings are considered equal"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「これら２つの文字列は等しいと考えられる」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "These two vectors are also equivalent."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「これらの２つのベクトルはまた等しいです。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "These two vectors are equivalent."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「これらの２つのベクトルは等しいです。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "This is a defined temperature unit, so initialization succeeded."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「これは定義済み温度単位です、なので初期化は成功しました。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "This isn't a defined temperature unit, so initialization failed."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「これは定義済み温度単位ではありません、なので初期化は失敗しました。」を出力します」）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "This point is to the right of the line where x == 1.0"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「この点は線x == 1.0の右にある」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Three feet is 0.914399970739201 meters"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「３フィートは、0.914399970739201メートルです」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Unable to initialize one unnamed product"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「１個の名前のない製品を初期化できません」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Unable to initialize zero shirts"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「０個のシャツを初期化できません」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Unable to retrieve the address."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「住所を取り出すことができない」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Unable to retrieve the first room name."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「最初の部屋名を取り戻すことができない」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Unable to retrieve the number of rooms."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「部屋の数を取り出すことができない」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Watch out for penguins"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「ペンギンに気をつけろ」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "Welcome!"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「歓迎します！」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "cinema is now 2048 pixels wide"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「cinemaは、現在2048のピクセルの幅です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "convertedNumber contains some integer value."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「convertedNumberは、何らかの整数値を持ちます」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "convertedNumber has an integer value of 123."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「convertedNumberは、整数値123を持ちます」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "data.txt"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「data.txt」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "e is a vowel"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「eは、母音です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "false"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「false」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "hd is still 1920 pixels wide"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「hdは、依然として1920のピクセルの幅です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "hello, world"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「よろしく、世界」を出力ます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "hello, world", because name is indeed equal to "world".</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「hello, world」を出力します、nameが確かに「world」と等しいので。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "highest unlocked level is now 2"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「最も高い鍵の開いたレベルは現在２です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "letters is of type Set&lt;Character&gt; with 0 items."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「lettersは型Set&lt;Character&gt;で０項目を持ちます。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "min is -6 and max is 109"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「最小は-6で、最大は109です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "on the x-axis with an x value of 2"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「２のxの値でx-軸の上」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "p is being deinitialized"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「pは、デイニシャライズされている」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "six times three is 18"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「６かける３は18です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "someInt is now 107, and anotherInt is now 3"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「someIntは今は107、anotherIntは今は３です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "someInts is of type [Int] with 0 items."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「someIntsは型[Int]で0項目を持ちます。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "square.origin is now at (10.0, 10.0)"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「square.originは、現在(10.0, 10.0)です」を出力します））</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "tenEighty and alsoTenEighty refer to the same VideoMode instance."</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「tenEightyとalsoTenEightyは、同じVideoModeインスタンスに言及します。」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "the number of characters in cafe is 4"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「cafeの文字数は4です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "the number of characters in café is 4"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「caféの文字数は4です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "the volume of fourByFiveByTwo is 40.0"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「fourByFiveByTwoのボリュームは、40.0です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "theAceOfSpades: suit is ♠, value is 1 or 11"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「theAceOfSpades: 組み札は♠、値は１または11です」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "true"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「true」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Prints "unusualMenagerie has 40 characters"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「unusualMenagerieは、40の文字を持ちます」を出力します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Random dice roll is 3</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（無作為にさいころを転がして、３です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Random dice roll is 4</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（無作為にさいころを転がして、４です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Random dice roll is 5</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（無作為にさいころを転がして、５です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Reimplement the Swift standard library's optional type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（スウィフト標準ライブラリのオプショナル型の再実装）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Return an appropriate subscript value here.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（適切な添え字値をここで返す。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Return the appropriate value</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（適切な値を返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Rolled a 3</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（３を出した）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Rolled a 4</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（４を出した）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Rolled a 5</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（５を出した）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Setting 'index' to a new value doesn't affect 'path'</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（'index'を新しい値に設定することは、'path'に影響を与えない）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Six eggs</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（卵６つ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Something that doesn't have an area</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（面積を持たない何か）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Song: Blue Suede Shoes, by Elvis Presley</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（歌：『青い裏革靴』、エルヴィス・プレスリー）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Song: Never Gonna Give You Up, by Rick Astley</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（歌：『諦めないで』、リック・アストリー）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Song: The One And Only, by Chesney Hawkes</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（歌：『唯一無二の』、チェズニー・ホークス）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Started a new game of Snakes and Ladders</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（ヘビとはしごの新しいゲームを始める）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Subsequent release renames MyProtocol</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（続くリリースでMyProtocolに改名する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Tandem: traveling at 22.0 miles per hour</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（２人乗り：時速22.0マイルで運行中）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// The compile-time type of someInstance is SomeBaseClass,</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（someInstanceのコンパイル時での型は、SomeBaseClassです、）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// The following dictionaries have the same type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（以下の辞書は同じ型を持ちます。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// The game is using a 6-sided dice</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（ゲームは、６面のさいころを使っています）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// The game lasted for 4 turns</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（ゲームは、４回続きました）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// The line below calls makeIndex().</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（下の行は makeIndex() を呼び出します。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// The type of optionalString is "String?" and assumedString isn't force-unwrapped.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（optionalString の型は "String?" です、そして assumedString は強制アンラップされません。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// This assertion fails because -3 isn't &gt;= 0.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（この表明は失敗する、なぜなら-3 は &gt;= 0 ではないから。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// This code isn't valid.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（このコードは有効ではありません。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// This is a comment.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（これはコメントです。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// This is a compile-time error: languageName cannot be changed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（これはコンパイル時エラーです：anguageNameは変わることができません。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// This isn't valid, because x = y doesn't return a value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（これは有効ではありません、x = yが値を返さないので。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// This subclass doesn't refer to oldValue in its observer, so the</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（このサブクラスはoldValueをそれのオブザーバの中で参照しません、それで）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// This subclass refers to oldValue in its observer, so the superclass's</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（このサブクラスはoldValueをそれのオブザーバの中で参照します、それでスーパークラスのもつ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// This syntax is preferred.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（この構文はより好まれます。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// This syntax produces a warning.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（この構文は警告を生成します。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// This triggers an assert, because [2, 2] is outside of the matrix bounds.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（これはある表明の引き金となります、なぜなら [2, 2] はマトリックス境界の外であるからです。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// This will report a compile-time error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（これは、コンパイル時エラーを報告します。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Type annotation is required because String has multiple initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（型注釈は必須です、なぜならStringは複数のイニシャライザを持つからです。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// UInt8 can't store negative numbers, and so this will report an error</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（UInt8は負の数を格納することができません、それでこれはエラーを報告します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Update the original.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（元のものを更新する。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Use a dynamic method call.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（動的メソッド呼び出しを使います。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Use dynamic member lookup.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（動的メンバ検索を使います。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Use iOS 10 APIs on iOS, and use macOS 10.12 APIs on macOS</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（iOS 10 APIをiOSで、macOS 10.12 APIをmacOSで使う）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Using taskKeyPath doesn't call makeIndex() again.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（ taskKeyPath を使うことは、 makeIndex() を再び呼び出しません。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Vehicle: 0 wheel(s)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（乗り物: ０輪）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Vehicle: traveling at 0.0 miles per hour</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（Vehicle: 時速0.0マイルで運行中）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Weak capture of "self.parent" as "parent"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「parent」としての弱いキャプチャ「self.parent」）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Work with the file.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（ファイル処理。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// a is "test", b is 12, c is 3, and 9.45 is ignored</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（aは「test」です、bは12です、cは３です、そして9.45は無視されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// a is now equal to 10</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（aは今は10と等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// a is now equal to 3</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（aは現在、３と等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// a movie called Ghostbusters, dir. Ivan Reitman</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（『ゴーストバスターズ』と呼ばれる映画、監督アイヴァン・ライトマン）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// a positive double value of 3.14159</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（正の浮動小数点の値の3.14159）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// a string value of "hello"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（文字列値の「よろしく」）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// afterDoubling also has values of (2.0, 8.0)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（afterDoublingも(2.0, 8.0)の値を持ちます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// alsoPositive is a Vector2D instance with values of (3.0, 4.0)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（alsoPositiveは、値(-3.0, -4.0)をもつVector2Dインスタンです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// an (x, y) point at 3.0, 5.0</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（3.0、5.0の(x, y)座標点）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// an error was thrown</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（エラーがスローされた）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// an integer value of 42</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（整数値の42）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// and so this will also report an error</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（それでこれも同様にエラーを報告します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// and the runtime type of someInstance is SomeSubClass</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（そしてsomeInstanceの実行時での型は、SomeSubClassです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// anonymousCreature is of type Animal?, not Animal</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（anonymousCreatureは、型Animal?です、Animalではなく）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// anotherFunction takes an integer and two closures as its arguments</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（anotherFunctionは、その引数としてある整数と２つのクロージャをとります）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// anotherMathFunction is inferred to be of type (Int, Int) -&gt; Int</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（anotherMathFunctionは、型(Int, Int) -&gt; Intであると推論されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// anotherPi is also inferred to be of type Double</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（anotherPiもまたDouble型であると推論されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// anotherThreeDoubles is of type [Double], and equals [2.5, 2.5, 2.5]</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（anotherThreeDoublesは、型[Double]で、[2.5, 2.5, 2.5]に等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// ants have 6 legs</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（蟻は、６本の足を持っています）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// await applies to both function calls</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（awaitは、両方の関数呼び出しに適用されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// basicRect's origin is (0.0, 0.0) and its size is (0.0, 0.0)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（centerRectの原点は(0.0, 0.0)、そのサイズは(0.0, 0.0)です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// beginning is "Hello"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（beginningは "Hello" です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// bodyTemperature.temperatureInCelsius is 37.0</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（bodyTemperature.temperatureInCelsius は 37.0 です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// boilingPointOfWater.temperatureInCelsius is 100.0</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（boilingPointOfWater.temperatureInCelsiusは、100.0です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// cap the new audio level to the threshold level</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（新しい音声レベルを限界レベルに制限する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// cats have 4 legs</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（猫は、４本の足を持っています）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（centerRectの原点は(2.5, 2.5)、そのサイズは(3.0, 3.0)です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// class definition goes here</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（クラス定義が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// class-only protocol definition goes here</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（クラス専用プロトコル定義が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// close(file) is called here, at the end of the scope.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（close(file)がここで呼ばれます、このスコープの終わりで。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// closure body goes here</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（クロージャ本文が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// closure's body goes here</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（クロージャの本文がここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// combinedVector is a Vector2D instance with values of (5.0, 5.0)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（combinedVectorは(5.0, 5.0)の値をもつVector2Dインスタンスです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// conformance to the Container protocol</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（Containerプロトコルに準拠）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// convertedNumber is inferred to be of type "Int?", or "optional Int"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（convertedNumberは、型「Int?」または「オプショナルのInt」であると推論されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// create a default value for someProperty inside this closure</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（このクロージャの内側でsomePropertyのための省略時の値をつくる）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// customersInLine is ["Alex", "Ewa", "Barry", "Daniella"]</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（customersInLine（並んでいる顧客）は、["Alex", "Ewa", "Barry", "Daniella"]です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// customersInLine is ["Barry", "Daniella"]</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（customersInLine（並んでいる顧客）は、["Barry", "Daniella"]です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// customersInLine is ["Ewa", "Barry", "Daniella"]</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（customersInLine（並んでいる顧客）は、["Ewa", "Barry", "Daniella"]です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// diceRoll will move us beyond the final square, so roll again</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（diceRollは私たちを最後の正方形を越えて動かします、それで再度転がします）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// diceRoll will move us to the final square, so the game is over</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（diceRollは私たちを最後の正方形に動かします、なのでゲームは終わりです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// discard 'self' and return 'nil'</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「self」を廃棄して「nil」を返します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// do nothing - an arbitrary vehicle doesn't necessarily make a noise</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（何もしない - ある任意の乗り物が必ず音を出すわけではない）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// do something with the instance of 'SomeStruct'</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「SomeStruct」のインスタンスで何か行う）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// doubleIndex is an optional Int with no value, because 9.3 isn't in the array</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（9.3がこの配列の中にはないので、doubleIndexは値のないオプショナルのIntです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// eAcute is é, combinedEAcute is é</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（eAcuteはéです、combinedEAcuteはéです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// earthsOrder is 3</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（earthsOrderは、３です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// enclosedEAcute is é⃝</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（enclosedEAcute は é⃝ です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// enumeration definition goes here</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（列挙定義がここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// f is a function of type (Int) -&gt; Number</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（fは型(Int) -&gt; Numberの関数です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// favoriteGenres has been initialized with three initial items</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（favoriteGenresは３つの初期項目で初期化されています）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// favoriteGenres now contains 4 items</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（favoriteGenresは現在４項目を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// firstItem is equal to "Eggs"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（firstItemは、「Eggs」と等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// firstItem is now equal to "Six eggs"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（firstItemは、現在「６つの卵」と等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// for that parameter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（そのパラメータのための引数値に言及することができます。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// freezingPointOfWater.temperatureInCelsius is 0.0</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（freezingPointOfWater.temperatureInCelsiusは、0.0です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// friendlyWelcome is now "Bonjour!"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（friendlyWelcomeは、現在「Bonjour!」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// fromTheTop is equal to "cuatro", and the stack now contains 3 strings</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（fromTheTopは「cuatro」と等しいです、そしてスタックは現在は３つの文字列を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// function body goes here</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（関数本文が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// function implementation goes here</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（関数実装が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// getter is called once before the setter, and again to print the value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（ゲッターは、セッターの前に一度、そして値を出力するためにもう一度呼び出されます。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// heartsSymbol is "♡"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（heartsSymbol は "♡" です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// http404Error is of type (Int, String), and equals (404, "Not Found")</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（http404Errorは、型が(Int, String)です、そして(404, "Not Found")と等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// if we're still on the board, move up or down for a snake or a ladder</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（私達がまだ盤上ならば、ヘビまたははしごに対して上／下に移動する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// implementation of protocol requirements goes here</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（プロトコル要件の実装が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// initialization of 'SomeStruct' failed and the initializer returned 'nil'</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「SomeStruct」の初期化は失敗したのでイニシャライザは「nil」を返した）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// initializer implementation goes here</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（イニシャライザ実装がここに来ます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// instruction now equals "look over there"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（instructionは、現在「あそこを見て」に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// integerPi equals 3, and is inferred to be of type Int</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（integerPiは、３に等しく、型Intであると推測されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// its value is ["OneSix", "FiveEight", "FiveOneZero"]</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（その値は["OneSix", "FiveEight", "FiveOneZero"]です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// john.fullName is "John Appleseed"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（john.fullNameは、「John Appleseed」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// letters is now an empty set, but is still of type Set&lt;Character&gt;</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（lettersは現在空の集合です、しかし依然として型Set&lt;Character&gt;です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// letters now contains 1 value of type Character</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（lettersは型Characterの値を１つ持ちます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// lightSwitch is now equal to .on</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（lightSwitchは、現在.onと等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// maxAmplitudeFound is now 0</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（maxAmplitudeFoundは、現在0です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// meaningOfLife is inferred to be of type Int</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（meaningOfLifeはInt型であると推測されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// message is "3 times 2.5 is 7.5"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（messageは、「３かける2.５は7.５」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// move by the rolled amount</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（振られた量だけ移動）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// move up or down for a snake or ladder</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（ヘビまたははしごのための上下移動）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// moveNearerToZero now refers to the nested stepForward() function</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（moveNearerToZeroは、現在は入れ子にされたstepForward()関数に言及します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// moveNearerToZero now refers to the stepBackward() function</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（moveNearerToZeroは、現在はstepBackward()関数に言及します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// myGreeting is 'hola'</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（myGreeting は 'hola' です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// mysteryMeat's name is "[Unnamed]"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（nameMeatの名前は「[Unnamed]」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// namedMeat's name is "Bacon"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（nameMeatの名前は「ベーコン」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// namesOfIntegers is an empty [Int: String] dictionary</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（namesOfIntegersは、空の[Int: String]の辞書です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// namesOfIntegers is once again an empty dictionary of type [Int: String]</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（namesOfIntegersは、またもとのように型[Int: String]の空の辞書です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// namesOfIntegers now contains 1 key-value pair</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（namesOfIntegersは、現在は１つの「キーと値」の対を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// ncc1701.fullName is "USS Enterprise"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（ncc1701.fullNameは、USSエンタープライズです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// negative is a Vector2D instance with values of (-3.0, -4.0)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（negativeは、値(-3.0, -4.0)をもつVector2Dインスタンです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// nested Rank enumeration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（入れ子にされたRank列挙）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// nested Suit enumeration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（入れ子にされたSuit列挙）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// nestedValue is 24</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（nestedValue は 24 です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// new functionality to add to SomeType goes here</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（SomeTypeに加える新しい機能性が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// no error was thrown</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（エラーはスローされなかった）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// originRect's origin is (2.0, 2.0) and its size is (5.0, 5.0)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（centerRectの原点は (2.0, 2.0)、そのサイズは(5.0, 5.0)です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// original IntStack implementation</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（元々のIntStack実施）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// original Stack&lt;Element&gt; implementation</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（元々のStack&lt;Element&gt;実装）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// original now has values of (4.0, 6.0)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（originalは、現在(4.0, 6.0)の値を持ちます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// ovenLight is now equal to .high</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（ovenLightは現在.hightと等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// ovenLight is now equal to .off</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（ovenLightは現在.lowと等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// perform some initialization here</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（ここで何らかの初期化を行う）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// perform the deinitialization</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（デイニシャライズを実行する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// pi equals 3.14159, and is inferred to be of type Double</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（piは、3.14159に等しく、型Doubleであると推論されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// pi is inferred to be of type Double</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（パイはDouble型であると推測されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// plusMinusVector is a Vector2D instance with values of (4.0, -2.0)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（plusMinusVectorはVector2Dインスタンスで(4.0, -2.0)の値をもちます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// possiblePlanet is of type Planet? and equals Planet.uranus</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（possiblePlanetは、型Planet?で、Planet.uranusに等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// potentialOverflow equals 32767, which is the maximum value an Int16 can hold</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（potentialOverflowは32767と等しく、それはInt16が持つことができる最大限の値です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// precomposed is 한, decomposed is 한</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（合成済は「한」, 分解したものは「한」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// print(protocolValue.anotherProperty)  // Uncomment to see the error</seg>
      </tuv>
      <tuv lang="ja">
        <seg>// print(protocolValue.anotherProperty)  // コメントを外すとエラー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// prints "hello, world" and returns a value of 12</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「よろしく、世界」を出力して値12を返します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// prints "hello, world" but doesn't return a value</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「よろしく、世界」を出力しますが値を返しません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// produces an optional instance of 'SomeStruct'</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「SomeStruct」のオプショナルインスタンスを生成します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// protocol definition</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（プロトコル定義）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// protocol definition goes here</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（プロトコル定義が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// refer to the argument values for the first and second parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（最初と２番目のパラメーターに対する引き数の値を参照します。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// regionalIndicatorForUS is 🇺🇸</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（regionalIndicatorForUS は 🇺🇸 です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// render the tick mark each minute (60 times)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（各分に目盛りを描画する（60回））</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// render the tick mark every 3 hours (3, 6, 9, 12)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（３時間ごとに目盛りを描画する（3, 6, 9, 12））</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// render the tick mark every 5 minutes (0, 5, 10, 15 ... 45, 50, 55)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（５分毎に目盛りを描画する（0, 5, 10, 15 ... 45, 50, 55））</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// returns 0, as if you had requested:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（まるであなたが次のように要請したかのように、0を返します：）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// returns 10.0, which is the arithmetic mean of these three numbers</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（10.0を返します、それはこれら３つの数の算術平均です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// returns 2</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（2を返します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// returns 3.0, which is the arithmetic mean of these five numbers</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（3.0を返します、それはこれら５つの数の算術平均です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// returns 5</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（5を返します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// returns 7</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（7を返します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// returns 9</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（9を返します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// returns a value of 10</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（値10を返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// returns a value of 20</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（値20を返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// returns a value of 30</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（値30を返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// returns a value of 40</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（値40を返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// returns a value of 50</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（値50を返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// returns a value of 60</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（値60を返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// returns a value of 7</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（値7を返す）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// reversedNames is equal to ["Ewa", "Daniella", "Chris", "Barry", "Alex"]</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（reversedNamesは["Ewa", "Daniella", "Chris", "Barry", "Alex"]に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// roll the dice</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（さいころを振る）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// rowHeight is equal to 90</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（rowHeightは、90と等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// serverResponseCode contains an actual Int value of 404</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（serverResponseCodeは、実際にあるInt値404を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// serverResponseCode now contains no value</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（serverResponseCodeは、現在は値を含みません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// shoppingList has been initialized with two initial items</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（shoppingListが、２つの最初の項目で初期化された）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// shoppingList now contains 3 items, and someone is making pancakes</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（shoppingListは現在３つの項目を含みます、そして誰かはパンケーキを作っています）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// shoppingList now contains 4 items</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（shoppingListは、現在４つの項目を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// shoppingList now contains 5 items, and no apples</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（shoppingListは現在は５つの項目を含みます、そして「リンゴ」は含みません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// shoppingList now contains 6 items</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（shoppingListは、現在６つの項目を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// shoppingList now contains 6 items, and no Maple Syrup</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（shoppingListは、現在６つの項目、メープルシロップ以外を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// shoppingList now contains 7 items</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（shoppingListは、現在７つの項目を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// signedOverflow equals -128, which is the minimum value an Int8 can hold</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（signedOverflowは-128と等しく、それはInt8が持つことができる最小限の値です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// signedOverflow is now equal to 127</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（signedOverflowは、現在127と等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// sixDoubles is inferred as [Double], and equals [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（sixDoublesは、[Double]と推論され、 [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]に等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// someCreature is of type Animal?, not Animal</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（someCreatureは、型Animal?です、Animalではなく）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// someDictionary is now ["a": [100, 2, 3], "b": [10, 20]]</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（someDictionary は、現在 ["a": [100, 2, 3], "b": [10, 20]] です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// someDictionary is now ["a": [42, 2, 3], "b": [10, 20]]</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（omeDictionary は、現在 ["a": [42, 2, 3], "b": [10, 20]] です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// someDictionary is still ["a": [1, 2, 3], "b": [10, 20]]</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（someDictionary は、まだ ["a": [1, 2, 3], "b": [10, 20]] です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// someFunction takes an integer and a closure as its arguments</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（someFunctionは、その引数としてある整数とあるクロージャをとります）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// someFunctionWithSideEffects is evaluated and returns 42</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（someFunctionWithSideEffectsは、評価されて42を返します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// someInt is now 107, and anotherInt is now 3</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（someIntは今は107、anotherIntは今は３です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// someInt is now 9</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（someIntは、現在９です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// someInts is now an empty array, but is still of type [Int]</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（someIntsは、現在は空の配列です、しかし依然として型[Int]です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// someInts now contains 1 value of type Int</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（someIntsは、現在は型Intの値ひとつを含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// someMethod takes a closure as its only argument</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（someMethodは、そのただ１つの引数としてクロージャをとります）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// someString is now "world", and anotherString is now "hello"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（someStringは今は「world」、anotherStringは今は「hello」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// someValue must be of the same type as SomeType</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（someValueは、SomeTypeと同じ型でなければなりません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// spiders have 8 legs</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（蜘蛛は、８本の足を持っています）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// stepSize is now 2</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（stepSize は現在 2 です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// store this as the new overall maximum input level</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（これを新しい全体で最大の入力レベルとして格納する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// stringIndex is an optional Int containing a value of 2</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（stringIndexは、オプショナルのIntで値２を含んでいます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// strings is inferred to be of type [String]</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（stringsは型[String]と推論されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// structure definition goes here</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（構造体定義が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// subclass definition goes here</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（サブクラス定義がここに来ます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// subclass implementation of the required initializer goes here</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（必須イニシャライザのサブクラス実装がここに来ます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// subclass initialization goes here</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（サブクラスの初期化が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// suffix contains 20 and 30</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（suffix は 20 と 30を含む）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// sunsetDirection is "west"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（sunsetDirectionは、「west」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// super.init() implicitly called here</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（super.init() が暗黙的にここで呼び出されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// superclass's getter is called only once to print the value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（スーパークラスのもつゲッターはただ一度だけ呼び出されて、値を出力します。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// surveyAnswer is automatically set to nil</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（surveyAnswerは、自動的にnilに設定されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// the "Dave" array is now [91, 82, 84] and the "Bev" array is now [80, 94, 81]</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「Dave」配列は現在[91, 82, 84]です、そして「Bev」配列は現在[80, 94, 81]です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// the DataImporter class would provide data importing functionality here</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（DataImporterクラスは、データをインポートする機能性をここで提供します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// the DataImporter instance for the importer property has now been created</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（importerプロパティのためのDataImporterインスタンスが、今つくられました）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// the DataImporter instance for the importer property hasn't yet been created</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（importerプロパティのためのDataImporterインスタンスは、まだ作成されていません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// the DataManager class would provide data management functionality here</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（DataManagerクラスは、データ管理の機能性をここで提供します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// the airports dictionary now contains 3 items</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（airports辞書は、現在３つの項目を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// the apples constant is now equal to the removed "Apples" string</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（apples定数は、現在は削除された文字列「リンゴ」と等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// the counter's value is now 0</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（counterの値は、いま0です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// the counter's value is now 1</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（counterの値は、いま１です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// the counter's value is now 6</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（counterの値は、いま６です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// the first item in the list is now equal to "Six eggs" rather than "Eggs"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（リストの中の最初の項目は、現在「６つの卵」と等しいです、「卵」ではなく）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// the initial counter value is 0</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（counterの最初の値は、0です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// the item that was at index 0 has just been removed</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（インデックス0であった項目が、ちょうど今取り除かれました）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// the last item in the array has just been removed</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（配列での最後の項目が、ちょうど今取り除かれました）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// the mapleSyrup constant is now equal to the removed "Maple Syrup" string</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（定数mapleSyrupは、現在は削除された「メープルシロップ」文字列と等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// the range now represents integer values 6, 7, and 8</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（範囲は、現在は整数値６、７、そして８を表します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// the range represents integer values 0, 1, and 2</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（範囲は、整数値０、１、そして２を表します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// the stack now contains 4 strings</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（スタックは、現在４つの文字列を含みます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// the type of "library" is inferred to be [MediaItem]</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「library」の型は、[MediaItem]であると推測されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// the value for "LHR" has been changed to "London Heathrow"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「LHR」に対する値は、「ロンドン・ヒースロー」に変えられました）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// the value of parameterWithDefault is 12 inside the function body.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（parameterWithDefaultの値はこの関数本文の内部で12です。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// these two strings are both empty, and are equivalent to each other</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（これらの２つの文字列は両方とも空で、お互いに等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// this causes an error</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（これは、エラーを引き起こします）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// this equals 17</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（これは17に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// this example will compile successfully</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（この例は、うまくコンパイルします）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// this example will not compile, and will report an error</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（この例はコンパイルせず、エラーを報告します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// this function may or may not throw an error</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（この関数はエラーをスローするかもしれないししないかもしれない）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// this initializer creates a document with a nil name value</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（このイニシャライザはnilのname値を使って書類を作成します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// this initializer creates a document with a nonempty name value</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（このイニシャライザは空でないname値を使って書類を作成します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// this is a valid move, so find out its effect</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（これは有効な動きです、それでその効果を調べます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// this range represents integer values 0, 1, 2, and 3</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（この範囲構造体、整数値０、１、２、そして３を表します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// this reports a compile-time error - a constant string cannot be modified</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（これはコンパイル時エラー - 定数文字列は修正できません、を報告します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// this reports a compile-time error - argument labels are required</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（これはコンパイル時エラーを報告します - 引数ラベルが必要とされます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// this triggers a runtime error</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（これは、実行時エラーの引き金となります）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// this will report an error</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（これは、エラーを報告します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// this will report an error, even though firstValue is a variable property</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（これはエラーを報告します、たとえfirstValueが変数プロパティであるとしてもです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// threeDoubles is of type [Double], and equals [0.0, 0.0, 0.0]</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（threeDoublesは、型[Double]で、 [0.0, 0.0, 0.0]に等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// toBeDoubled now has values of (2.0, 8.0)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（toBeDoubledは、現在(2.0, 8.0)の値を持ちます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// trailing closure's body goes here</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（後付クロージャの本文がここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// try applies to both function calls</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（tryは、両方の関数呼び出しに適用されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// type method implementation goes here</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（型メソッドの実施が、ここにきます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// unsignedOverflow equals 0, which is the minimum value a UInt8 can hold</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（unsignedOverflowは0と等しく、それはUInt8が持つことができる最小限の値です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// unsignedOverflow equals 255, which is the maximum value a UInt8 can hold</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（unsignedOverflowは255に等しく、それはUInt８が持つことができる最大限の値です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// unsignedOverflow is now equal to 0</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（unsignedOverflowは、現在0と等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// unsignedOverflow is now equal to 255</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（unsignedOverflowは、現在255と等しいです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// userDefinedColorName is nil, so colorNameToUse is set to the default of "red"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（userDefinedColorNameはnilです、なのでcolorNameToUseは省略時の「赤」に設定されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// userDefinedColorName isn't nil, so colorNameToUse is set to "green"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（userDefinedColorNameはnilではありません、それでcolorNameToUseは「緑」に設定されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// value is 12</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（valueは12です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// valueChanged is of type Int?, not Int</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（valueChanged は、型 Int? のものです、Int ではなく）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// variableString is now "Horse and carriage"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（variableStringは、現在「馬と馬車」です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// welcome now equals "hello there!"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（welcomeは、現在「やあ！、こんにちは」に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// welcome now equals "hello there"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（welcomeは、現在「やあ、こんにちは」に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// welcome now equals "hello!"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（welcomeは、現在「こんにちは！」に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// welcome now equals "hello"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（welcomeは、現在「こんにちは」に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// x is 10, and 20 is ignored</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（xは10です、そして20は無視されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// x is equal to 1, and y is equal to 2</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（xは１と等しい、そしてyは２と等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// x is now 1</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（x は、現在 1 です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// zero as a Double</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（浮動小数点のゼロ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// zero as an Int</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（整数のゼロ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Advanced Operators covers Swift’s advanced operators, and describes how to define your own custom operators and implement the standard operators for your own custom types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>先進の演算子では、スウィフトの先進の演算子を取り扱い、加えてあなた独自のあつらえの演算子を定義する方法、そしてあなた独自のあつらえの型のために標準の演算子を実装する方法を解説します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Array Type Shorthand Syntax is now written as [SomeType] rather than SomeType[].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列型の短縮形構文は、現在は[SomeType]のように書かれます、SomeType[]ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Assertions and Preconditions can now use string interpolation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>表明と前提条件は今では文字列補間を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Optionals no longer implicitly evaluate to true when they have a value and false when they do not, to avoid confusion when working with optional Bool values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルはもはや暗黙的に、それが値を持つときtrueに、そしてそれがそうしないときfalseに評価されません、それによってオプショナルBoolを扱うときの混乱を防ぐためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>(3 % 4) is 3, so this is equivalent to:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>(3 % 4)は3なので、これは以下に等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>(3 * 5) is 15, so this is equivalent to:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>(3 * 5)は15なので、これは以下に等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>0xFp-2 means 15 x 2-2, or 3.75.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>0xFp-2は、15 × 2-2、または3.75を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>0xFp2 means 15 x 22, or 60.0.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>0xFp2は、15 × 22、または60.0を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>1.25e-2 means 1.25 x 10-2, or 0.0125.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>1.25e-2は、1.25 × 10-2、または0.0125を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>1.25e2 means 1.25 x 102, or 125.0.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>1.25e2は、1.25 × 102、または125.0を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>123456789[0] returns 9</seg>
      </tuv>
      <tuv lang="ja">
        <seg>123456789[0]は9を返します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>123456789[1] returns 8</seg>
      </tuv>
      <tuv lang="ja">
        <seg>123456789[1]は8を返します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>1 times 5 equals 5</seg>
      </tuv>
      <tuv lang="ja">
        <seg>1掛ける5は5に等しい</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>2 plus 3 equals 5</seg>
      </tuv>
      <tuv lang="ja">
        <seg>2足す3は5に等しい</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>5 remainder 4 equals 1</seg>
      </tuv>
      <tuv lang="ja">
        <seg>5割る4の余りは1に等しい</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>&gt;= or &lt; followed by a version number</seg>
      </tuv>
      <tuv lang="ja">
        <seg>&gt;=または&lt;にバージョン番号が続きます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>@autoclosure is now an attribute of the parameter declaration, not its type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>@autoclosureは今ではパラメーター宣言の属性です、それの型ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any can represent an instance of any type at all, including function types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Anyは、関数型を含めて、ともかくどんな型のインスタンスでも表すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>AnyObject can represent an instance of any class type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>AnyObjectは、どんなクラス型のインスタンスでも表すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Array&lt;SomeType&gt; can become UnsafePointer&lt;SomeType&gt;</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Array&lt;SomeType&gt;は、UnsafePointer&lt;SomeType&gt;になれます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Bank keeps track of the current number of coins it holds with its coinsInBank property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Bankは、それがそのcoinsInBankプロパティで保持するコインの現在の数の情報を得続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>C1 must conform to the Container protocol (written as C1: Container).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>C1は、Containerプロトコルに準拠しなければなりません（C1: Containerのように書かれます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>C2 must also conform to the Container protocol (written as C2: Container).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>C2もまた、Containerプロトコルに準拠しなければなりません（C2: Containerのように書かれます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Color provides an initializer with three appropriately named parameters of type Double for its red, green, and blue components.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Colorはイニシャライザに、それの赤、緑、および青の構成要素に対する３つの適切に命名された型Doubleのパラメータを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Department maintains a strong reference to each course that the department offers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Department（学科）は、ある強い参照をその学科が提供する課程それぞれに対して保守します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Dice also has an initializer, to set up its initial state.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Diceはまた、その最初の状態を設定するために、イニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Dice provides one instance method, roll, which returns an integer value between 1 and the number of sides on the dice.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Diceは１つのインスタンスメソッド、rollを提供します、それは、１とさいころ上の面の数との間の整数値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>DiceGameDelegate provides three methods for tracking the progress of a game.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>DiceGameDelegateは、３つのメソッドをゲームの進捗を追うために提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>DiceGameTracker implements all three methods required by DiceGameDelegate.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>DiceGameTrackerは、DiceGameDelegateによって要求される３つのメソッド全てを実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Double has a precision of at least 15 decimal digits, whereas the precision of Float can be as little as 6 decimal digits.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Doubleは少なくとも10進数で15桁の精度を持ちます、一方でFloatの精度は10進数で６桁ほどです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Double represents a 64-bit floating-point number.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Doubleは、64ビットの浮動小数点数を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Element defines a placeholder name for a type to be provided later.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Elementは、プレースホルダ名を、後で提供されることになるある型に対して定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Float represents a 32-bit floating-point number.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Floatは、32ビットの浮動小数点数を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>LevelTracker also defines two type functions to work with the highestUnlockedLevel property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>LevelTrackerはまた、２つの型関数を定義してhighestUnlockedLevelプロパティを取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Matrix provides an initializer that takes two parameters called rows and columns, and creates an array that’s large enough to store rows * columns values of type Double.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Matrixはひとつのイニシャライザを提供します、それはrowsとcolumnsと呼ばれる２つのパラメータをとり、型Doubleで個数rows * columnsの値を格納するのに十分大きい配列をつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Point encapsulates the x- and y-coordinate of a point.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Pointは、ある地点のxおよひy座標をカプセル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Rank also defines a computed property, values, which returns an instance of the Values structure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Rankはまた、ある計算プロパティ、valuesを定義します、それは、Values構造体のインスタンスを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>RecipeIngredient also defines a convenience initializer, init(name: String), which is used to create a RecipeIngredient instance by name alone.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>RecipeIngredientはまた、便宜イニシャライザ、init(name: String)を定義します、それは、名前だけでRecipeIngredientインスタンスを作成するのに使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Rect defines a rectangle by an origin point and a size.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Rectは、原点と大きさによって長方形を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Residence instances have a single Int property called numberOfRooms, with a default value of 1.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Residenceインスタンスは、numberOfRoomsと呼ばれる省略時の値1を持つIntプロパティただひとつを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>ShoppingListItem doesn’t define an initializer to provide an initial value for purchased, because items in a shopping list (as modeled here) always start out unpurchased.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ShoppingListItemはpurchasedに初期値を用意するイニシャライザを定義しません、なぜなら、購入品目リストの項目が（ここでモデル化されるように）常に未購入で始められるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Size encapsulates a width and a height.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Sizeは、widthとheightをカプセル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>SomeType(ofInitialValue) is the default way to call the initializer of a Swift type and pass in an initial value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>SomeType(ofInitialValue)は、あるスウィフト型のイニシャライザを呼んで、初期値を渡すために通常使う方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>String can become UnsafePointer&lt;CChar&gt;</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Stringは、UnsafePointer&lt;CChar&gt;になれます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>String values can be added together (or concatenated) with the addition operator (+) to create a new String value:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>String値は、新しいString値をつくるために加算演算子（+）を使って１つに足し合わされる（または連結される）ことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>String values can be constructed by passing an array of Character values as an argument to its initializer:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>String値は、Character値の配列をそれのイニシャライザへの引数として渡すことによって組み立てられることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Tandem inherits all of the properties and methods from Bicycle, which in turn inherits all of the properties and methods from Vehicle.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Tandemは、すべてのプロパティとメソッドをBicycleから継承します、そして今度はそれがすべてのプロパティとメソッドをVehicleから継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>UInt8 integers have eight bits and can store any value between 0 and 255.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>UInt8整数は、８ビットを持ち、0と255の間でのどんな値でも格納することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>anotherContainer is a container of type C2.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>anotherContainerは、型C2のコンテナです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>board[0] always equals 0 and has no effect.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>board[0]は、常に0に等しくて、効果を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>didSet is called immediately after the new value is stored.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>didSetは、新しい値が格納された直後に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>first, of type Int</seg>
      </tuv>
      <tuv lang="ja">
        <seg>first、型Intのもの</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>increment() increments the counter by 1.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>increment()は、1だけカウンターを増加させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>increment(by: Int) increments the counter by a specified integer amount.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>increment(by: Int)は、指定された量の整数でカウンターを増加させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>inout Array&lt;SomeType&gt; can become UnsafePointer&lt;SomeType&gt; or UnsafeMutablePointer&lt;SomeType&gt;</seg>
      </tuv>
      <tuv lang="ja">
        <seg>inout Array&lt;SomeType&gt;は、UnsafePointer&lt;SomeType&gt;またはUnsafeMutablePointer&lt;SomeType&gt;になれます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>inout SomeType can become UnsafePointer&lt;SomeType&gt; or UnsafeMutablePointer&lt;SomeType&gt;</seg>
      </tuv>
      <tuv lang="ja">
        <seg>inout SomeTypeは、UnsafePointer&lt;SomeType&gt;またはUnsafeMutablePointer&lt;SomeType&gt;になれます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>item is Movie returns true if the current MediaItem is a Movie instance and false if it’s not.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>item is Movieは、現在のMediaItemがMovieインスタンスであるならばtrueを、そうでないならばfalseを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>john.residence now contains an actual Residence instance, rather than nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>john.residenceは、今では実際のResidenceインスタンスを含みます、nilではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>nil and the Booleans true and false are now Literals.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>nilとブールのtrueおよびfalseは現在リテラルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>number.kind is already known to be of type Int.Kind.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>number.kindは、既に型Int.Kindであると知られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>repeat-while evaluates its condition at the end of each pass through the loop.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>repeat-whileは、その条件を、ループを通り抜けるそれぞれの終わりで評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>reset() resets the counter to zero.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>reset()は、カウンターをゼロに再設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>second, of type Int?, or “optional Int”</seg>
      </tuv>
      <tuv lang="ja">
        <seg>second、型Int?、つまり「オプショナルのInt」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>someContainer and anotherContainer contain the same type of items.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>someContainerとanotherContainerは、同じ型の項目を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>someContainer is a container of type C1.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>someContainerは、型C1のコンテナです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>while evaluates its condition at the start of each pass through the loop.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>whileは、その条件を、ループを通り抜けるそれぞれの始まりで評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>willSet is called just before the value is stored.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>willSetは、値が格納される直前に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>HTMLElement also defines an optional text property, which you can set to a string that represents the text to be rendered within that HTML element.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>HTMLElementはまた、オプショナルのtextプロパティを定義します、それは、あなたはそれをテキストがそのHTML要素の範囲内で提出されると述べる文字列に設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>tenEighty and alsoTenEighty themselves don’t “store” the VideoMode instance—instead, they both refer to a VideoMode instance behind the scenes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>tenEightyおよびalsoTenEightyそれら自身はVideoModeインスタンスを格納しません ― そうではなく、それらが両方とも言及するのは舞台裏でVideoModeインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any can be used as the concrete type for an instance of any of the following types:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Anyは、具象型として以下の型の何れかのインスタンスに対して使用できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Course has two unowned references, one to the department and one to the next course a student should take; a course doesn’t own either of these objects.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Course（課程）は２つの非所有参照を持ちます、学科に対して１つそして生徒が取るべき次の課程に対して１つ；ある課程はこれらオブジェクトのどちらも所有しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>currentValue has an initial value of 3, which means that currentValue &gt; 0 returns true, causing chooseStepFunction(backward:) to return the stepBackward(_:) function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>currentValueは3の初期値を持ちます、そしてそれは、currentValue &gt; 0がtrueを返して、chooseStepFunction(backward:)がstepBackward(_:)関数を返すことを引き起こすのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Dice instances have an integer property called sides, which represents how many sides they have, and a property called generator, which provides a random number generator from which to create dice roll values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Diceインスタンスは、それがどれくらいの面を持つのかを表すsidesと呼ばれる整数プロパティ、そしてそこからさいころを振った値を作成する乱数生成器を提供するgeneratorと呼ばれるプロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Character values are described in Strings and Characters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Character値は文字列と文字で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Color also provides a second initializer with a single white parameter, which is used to provide the same value for all three color components.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Colorはまた、ただ１つのwhiteパラメータを持つ第２のイニシャライザを提供します、それは３つの色構成要素すべてに同じ値を提供するのに使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Stack provides two methods, push and pop, to push and pop values on and off the stack.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Stackは２つのメソッド、pushとpopを提供します、それでスタック上に値を押し込んだり飛び出させたりします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Dictionary needs its keys to be hashable so that it can check whether it already contains a value for a particular key.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Dictionaryは、それが特定のキーのためにすでに値を含むかどうか確認できるように、そのキーにハッシュ化できることを必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>if and while statements are described in more detail in Control Flow.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ifおよびwhile文は更に詳細に「制御の流れ」で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>CartItem introduces a stored constant property called quantity and ensures that this property always has a value of at least 1:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>CartItemはquantityと呼ばれる格納定数プロパティを導入します、そしてこのプロパティが常に少なくとも1の値を持つことを確実にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>ShoppingListItem also adds a computed description property, which provides a textual description of a ShoppingListItem instance:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ShoppingListItemはまた、計算されるdescriptionプロパティを加えます、それは、ShoppingListItemインスタンスのテキストでの解説を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Suffix has two constraints: It must conform to the SuffixableContainer protocol (the protocol currently being defined), and its Item type must be the same as the container’s Item type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Suffixは、２つの制約を持ちます：それはSuffixableContainerプロトコル（そのプロトコルはいま定義されるところです）に準拠しなければなりません、そしてそれのItem型はコンテナのもつItem型と同じでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Person instances have an optional residence property of type Residence?.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Personインスタンスは、型Residence?のオプショナルresidenceプロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Access control restricts access to parts of your code from code in other source files and modules.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>アクセス制御は、あなたのコードの各部への他のソースファイルとモジュールの中のコードからのアクセスを制限します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Assertions and preconditions are checks that happen at runtime.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>表明と前提条件は、起こることを実行時で調べられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Asynchronous code can be suspended and resumed later, although only one piece of the program executes at a time.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非同期コードは、中断されて後で再開されることが可能です、とはいえプログラムの１つの断片だけは一度に遂行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Binary operators operate on two targets (such as 2 + 3) and are infix because they appear in between their two targets.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>二項演算子は、２つの目標に作用します（例えば2 + 3のように）、そしてそれがそれら２つの目標の間に現れるので接中辞です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Bitwise operators enable you to manipulate the individual raw data bits within a data structure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ビット単位演算子は、あなたにあるデータ構造内の個々の生のデータ・ビットを操作することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Closure expressions are a way to write inline closures in a brief, focused syntax.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャ式は、簡潔な、焦点のあった構文で、処理の流れに組み込まれた（行内の、インラインの）クロージャを書く方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Closures are self-contained blocks of functionality that can be passed around and used in your code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャは、機能性の完全独立のブロック、かたまりです、それは、あなたのコードにおいてあちこちに渡され使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Compound assignment operators combine assignment (=) with another operation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複合代入演算子は、代入（=）を別の操作と組み合わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Control transfer statements change the order in which your code is executed, by transferring control from one piece of code to another.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>制御移動文は、制御をコードのひとつの部分から別のものまで移すことによって、あなたのコードが実行される順番を変えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Convenience initializers are secondary, supporting initializers for a class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>便宜イニシャライザは副次的なもので、あるクラスのためのイニシャライザを支援します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Declaration modifiers are keywords or context-sensitive keywords that modify the behavior or meaning of a declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>宣言修飾子は、キーワードまたは文脈依存キーワードです、それは宣言のふるまいや意味することを修正します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Delegation is a design pattern that enables a class or structure to hand off (or delegate) some of its responsibilities to an instance of another type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>委任は、クラスまたは構造体にそれのもつ責務の一部を別の型のインスタンスへと手渡す（または委任する）ことを可能にするデザイン・パターンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Designated initializers are the primary initializers for a class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>指定イニシャライザは、あるクラスのための主要なイニシャライザです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Error handling is the process of responding to and recovering from error conditions in your program.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>エラー処理は、あなたのプログラムにおいてエラー状態へ応答してそこから復旧する過程です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extensions add new functionality to an existing class, structure, enumeration, or protocol type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張は、新しい機能性を既存のクラス、構造体、列挙、またはプロトコル型に加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>File-private access restricts the use of an entity to its own defining source file.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ファイル外非公開アクセス（ファイル私用）は、ある実在の使用をそれ自身の定義ソースファイルに制限します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Floating-point literals represent floating-point values of unspecified precision.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>浮動小数点リテラルは、不特定精度の浮動小数点値を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Floating-point numbers are numbers with a fractional component, such as 3.14159, 0.1, and -273.15.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>浮動小数点数は小数部を持つ数です、例えば3.14159、0.1、そして-273.15など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Functions are self-contained chunks of code that perform a specific task.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数は、特定の作業を実行する完全独立の大きな塊のコードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Generic code enables you to write flexible, reusable functions and types that can work with any type, subject to requirements that you define.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体コードは、あなたに柔軟な、再使用できる関数と型を書くことを可能にします、それは、あなたが定義する要件を満たした場合に限り、あらゆる型を扱うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Generic functions can work with any type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体関数は、どんな型でも扱うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Identifiers begin with an uppercase or lowercase letter A through Z, an underscore (_), a noncombining alphanumeric Unicode character in the Basic Multilingual Plane, or a character outside the Basic Multilingual Plane that isn’t in a Private Use Area.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>識別子は、大文字または小文字のAからZ、アンダースコア（_）、基本多言語面の非合成英数字のUnicode文字、または基本他言語面の外側ての使用領域の中でない文字で始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Infix expressions combine an infix binary operator with the expression that it takes as its left- and right-hand arguments.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>接中辞式は、接中辞二項演算子を、それがその左および右手側の引数としてとる式と組み合わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Initialization is the process of preparing an instance of a class, structure, or enumeration for use.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>初期化は、クラス、構造体、または列挙のインスタンスを使用するために前準備する処理です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Initializers are called to create a new instance of a particular type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>イニシャライザは、特定の型の新しいインスタンスをつくるために呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instance methods are functions that belong to instances of a particular class, structure, or enumeration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>インスタンスメソッドは、特定のクラス、構造体、または列挙のインスタンスに属している機能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Integer literals represent integer values of unspecified precision.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>整数リテラルは、無限精度の整数値を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Integers are whole numbers with no fractional component, such as 42 and -23.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>整数は、小数部分のない数すべてです、例えば42や-23など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Internal access enables entities to be used within any source file from their defining module, but not in any source file outside of that module.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>内部アクセス（内部用）は、実在それらが、それらの定義モジュールからのあらゆるソースファイル内で使われることを可能にします、しかし、そのモジュールの外側のいかなるソースファイルの中も除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Logical operators modify or combine the Boolean logic values true and false.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>論理演算子は、ブールの論理値trueおよびfalseを修正または結合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Methods are functions that are associated with a particular type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メソッドは、特定の型と結び付けられる関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Open access and public access enable entities to be used within any source file from their defining module, and also in a source file from another module that imports the defining module.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>開放アクセスと公開アクセス（公開用）は、実在それらが、それらの定義モジュールからのあらゆるソースファイル内で、そのうえに、定義モジュールをインポートする別のモジュールからのソースファイルの中で、使われることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Optional chaining is a process for querying and calling properties, methods, and subscripts on an optional that might currently be nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル連鎖は、現時点でnilであるかもしれないオプショナル上での、プロパティ、メソッド、および添え字への問い合わせや呼び出しのための処理です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Postfix expressions are formed by applying a postfix operator or other postfix syntax to an expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>接尾辞式は、接尾辞演算子または他の接尾辞構文を式に適用することによって作り上げられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Prefix expressions combine an optional prefix operator with an expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>接頭辞式では、ある任意の接頭辞演算子をひとつの式と組み合わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Primary expressions are the most basic kind of expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>基本式は、最も基本的な種類の式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Private access restricts the use of an entity to the enclosing declaration, and to extensions of that declaration that are in the same file.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非公開アクセス（私用）は、ある実在の使用をそれを囲んでいる宣言に、そしてその宣言の拡張で同じファイル中のものに制限します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Properties associate values with a particular class, structure, or enumeration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティは、いくつかの値を特定のクラス、構造体、または列挙と結びつけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>String interpolation is a way to construct a new String value from a mix of constants, variables, literals, and expressions by including their values inside a string literal.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列補間は、定数、変数、リテラル、および式の混合から、それらの値をひとつのリテラル文字列に含めることで、新しいString値を造る方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Structures and classes are general-purpose, flexible constructs that become the building blocks of your program’s code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体およびクラスは、あなたのプログラムのコードの建築ブロックになる、万能で、柔軟な構造物です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Subclassing is the act of basing a new class on an existing class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>サブクラスをつくることは、既存のクラスをもとに新しいクラスを構築する行為です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Ternary operators operate on three targets.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>三項演算子は、３つの目標に作用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Tuples group multiple values into a single compound value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タプルは、複数の値を１つの複合値にまとめます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type aliases define an alternative name for an existing type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型エイリアスは、既存の型の代替の名前を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type casting is a way to check the type of an instance, or to treat that instance as a different superclass or subclass from somewhere else in its own class hierarchy.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型キャストは、あるインスタンスの型を調べるための、またはそのインスタンスを、それ自身のクラス階層中のどこか他の別のスーパークラスやサブクラスとして扱うための方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unary operators operate on a single target (such as -a).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>単項演算子は、１つだけの目標に作用します（例えば-aなど）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unicode is an international standard for encoding, representing, and processing text in different writing systems.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ユニコードは、異なる表記体系のテキストを符号化、表現、そして処理するための国際的な基準です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Parallel code means multiple pieces of code run simultaneously—for example, a computer with a four-core processor can run four pieces of code at the same time, with each core carrying out one of the tasks.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>並列コードは、複数のコード断片が同時に動作することを意味します — 例えば、4コアプロセッサをもつコンピュータは４つのコード断片を、各コアがそれらタスクの１つを実施することで一度に実行できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Identical to means that two constants or variables of class type refer to exactly the same class instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同一は、クラス型の２つの定数または変数が、正確に同じクラスインスタンスに言及することを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Equal to means that two instances are considered equal or equivalent in value, for some appropriate meaning of equal, as defined by the type’s designer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同等は、２つのインスタンスが、値で「等しい」あるいは「相当する」と、ある適切な等しいの意味で、型の設計者によって定義されたとおりに、考慮されることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Boolean literal</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（ブールのリテラル）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Floating-point literal</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（リテラル浮動小数点）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Integer literal</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（リテラル整数）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// String literal</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（リテラル文字列）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Valid, uses default value</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（有効、省略時の値を使う）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// COMBINING ACUTE ACCENT, U+0301</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（アキュート・アクセント、U+0301を追加する）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Error: return types don't match</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（エラー：戻り型は一致しません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Error</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（エラー）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Invalid, alwaysThrows() isn't a throwing parameter</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（無効、alwaysThrows()はスローパラメータではありません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Invalid, missing argument label</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（無効、引数ラベルが欠けている）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Invalid, the case has an empty body</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（無効、このケース節は空の本文を持ちます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// No actual side effects.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（実際の副作用なし）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// equals "hello, world"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（「こんにちは、世界よ」に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// equals -1</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（-１に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// equals 1</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（１に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// equals 2</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（２に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// equals 3</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（３に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// equals 4.0</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（4.0に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// equals 6</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（６に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// implicitly file-private class member</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（暗黙的にファイル外非公開のクラス・メンバー）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// implicitly internal class</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（暗黙的に内部のクラス）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// implicitly internal</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（暗黙的に内部です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// implicitly private class member</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（暗黙のうちに非公開のクラス・メンバー）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// true because 1 is equal to 1</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（１が1と同等なので真）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// true because 1 is greater than or equal to 1</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（１が１以上なので真）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// true because 1 is less than 2</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（１が２より小さいので真）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// true because 2 is greater than 1</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（２が１より大きいので真）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// 17 in binary notation</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（２進法での17）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// 17 in hexadecimal notation</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（16進法での17）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// 17 in octal notation</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（８進法での17）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// OK: names are inferred</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（OK: 名前は推論されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// T is inferred to be Double</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（TはDoubleであると推論されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// T is inferred to be Int</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（Tは、Intであると推論されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// The type of e is inferred to be Double.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（eの型は、Doubleであると推測されます。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// The type of f is (Int, Int) -&gt; Void, not (left: Int, right: Int) -&gt; Void.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（ f の型は (Int, Int) -&gt; Void です、 (left: Int, right: Int) -&gt; Void ではなく）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Valid, uses the value provided</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（有効、提供された値を使う）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Warning</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（警告）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// alsoMinusSix equals -6</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（alsoMinusSixは、-6に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// empty string literal</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（空の文字列リテラル）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// equals 11110000</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（11110000に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// explicitly file-private class member</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（明示的にファイル外非公開のクラス・メンバー）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// explicitly file-private class</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（明示的にファイル外非公開のクラス）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// explicitly private class member</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（明示的に非公開のクラス・メンバー）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// explicitly private class</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（明示的に非公開のクラス）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// explicitly public class</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（明示的に公開のクラス）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// implicitly internal class member</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（暗黙的に内部のクラス・メンバー）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// implicitly internal</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（暗黙的に内部です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// initializer syntax</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（イニシャライザ構文）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// minusThree equals -3</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（minusThreeは、-3に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// plusThree equals 3, or "minus minus three"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（plusThreeは、3に、または「マイナス マイナス three」に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>//  count is labeled, greeting is not</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（countはラベルを付けられます、greetingは違います）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// 00000100 in binary</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（２進数での00000100）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Ambiguous</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（あいまい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Chinese symbol for the number 3</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（数３に対する中国語記号）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Error because &lt; can't compare Boolean values</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（エラー、なぜなら &lt; がブール値を比較できないため）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Error: return types don't match</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（エラー：戻り型は一致しません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// OK, evaluates to true</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（OK、trueと評価します）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// The type of eFloat is Float.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（eFloatの型はFloatです。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// blueComponent is 0x99, or 153</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（blueComponent は 0x99 または 153 です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// e followed by ́</seg>
      </tuv>
      <tuv lang="ja">
        <seg>// e に続けて ́</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// equals 00010001</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（00010001に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// equals 00111100</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（00111100に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// equals 11111110</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（11111110に等しい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// explicitly public class member</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（明示的に公開のクラス・メンバー）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// implicit strong capture</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（暗黙の強いキャプチャ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// maxValue is equal to 255, and is of type UInt8</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（maxValuesは255に等しく、そしてUInt8型です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// minValue is equal to 0, and is of type UInt8</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（minValuesは0に等しく、そしてUInt8型です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// no need for an exclamation point</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（感嘆符の必要はありません）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// requires an exclamation point</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（感嘆符が要求されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// true because 1 is less than 2; "zebra" and "apple" aren't compared</seg>
      </tuv>
      <tuv lang="ja">
        <seg>// １は２より少ないので真；「zebra」と「apple」は比較されません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// true because 3 is equal to 3, and "apple" is less than "bird"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（３は３と等しく、「apple」は「bird」より少ないので真）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// true because 4 is equal to 4, and "dog" is equal to "dog"</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（４は４と等しく、「dog」は「dog」と等しいので真）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Error: names don't match</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（エラー: 名前が一致しない）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// No warning</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（警告なし）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// OK: names match</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（OK: 名前が一致）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// both x and y are labeled</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（xとyの両方ともラベルをつけられます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// greenComponent is 0x66, or 102</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（greenComponent は 0x66 または 102 です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// redComponent is 0xCC, or 204</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（redComponent は 0xCC または 204 です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Still ambiguous</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（依然あいまい）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Unambiguous</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（あいまいさ無し）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// someTuple is of type (top: Int, bottom: Int)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（someTupleは型 (top: Int, bottom: Int) です）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// unowned capture</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（非所有キャプチャ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// weak capture</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（弱いキャプチャ）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>// Unambiguous</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（あいまいさ無し）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A break statement ends program execution of a loop, an if statement, or a switch statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>break文は、ループ、if文、またはswitch文のプログラム実行を終えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A catch clause that has multiple patterns matches the error if any of its patterns match the error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複数のパターンを持つcatch節は、エラーと合致します、それのパターンのどれかがそのエラーと合致するならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A continue statement ends program execution of the current iteration of a loop statement but doesn’t stop execution of the loop statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>continue文は、ループ文の現在の繰り返しのプログラム実行を終了しますが、ループ文の実行は止めません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A defer statement defers execution until the current scope is exited.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>defer文は、現在のスコープが終了されるまで実行を延期します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A defer statement has the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>defer文は以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A defer statement is used for executing code just before transferring program control outside of the scope that the defer statement appears in.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>defer文は、defer文が現れるスコープの外側にプログラムの制御を移す直前でのコード実行のために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A do statement creates a new containing scope, which allows errors to be propagated to one or more catch clauses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>do文はひとつの新しく取り囲んでいるスコープを作成します、それはエラーに１つ以上のcatch節に伝えられることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A do statement has the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>do文は以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A do statement in Swift is similar to curly braces ({}) in C used to delimit a code block, and doesn’t incur a performance cost at runtime.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトのdo文は、Cにおいてひとつのコードのブロックの境界を定めるために使われる波括弧（{}）に似ていて、実行時に性能上の損失を被りません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A fallthrough statement can appear anywhere inside a switch statement, not just as the last statement of a case block, but it can’t be used in the final case block.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>fallthrough文は、switch文のどこにでも現れることができます、あるケース節ブロックの最後の文としてだけではなく、しかしそれは最後のケース節ブロックにおいては使われることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A fallthrough statement consists of the fallthrough keyword and occurs only in a case block of a switch statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>fallthrough文は、fallthroughキーワードから成って、switch文のケース節ブロックだけに現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A for loop becomes a temporary variable, a for loop, and call to the buildArray(_:) method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>forループは、ある一時的な変数、あるforループ、そしてbuildArray(_:)メソッドへの呼び出しになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A for-in statement allows a block of code to be executed once for each item in a collection (or any type) that conforms to the Sequence [https://developer.apple.com/documentation/swift/sequence] protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>for-in文は、コードの１ブロックをSequence [https://developer.apple.com/documentation/swift/sequence]プロトコルに準拠するあるコレクション（または何らかの型）の中のそれぞれの項目に対して一度だけ実行されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A for-in statement has the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>for-in文は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A guard statement has the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>guard文は以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A guard statement is used to transfer program control out of a scope if one or more conditions aren’t met.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>guard文は、１つ以上の条件が満たされないならば、プログラムの制御をあるスコープの外に転移させるために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A guard statement, like an if statement, executes statements depending on the Boolean value of an expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>guard文は、if文と同じく、ある式のブール値に基づいて他の文を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A repeat-while statement allows a block of code to be executed one or more times, as long as a condition remains true.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>repeat-while文は、ある条件が真のままである限り、ひとかたまりのコードを一回以上実行されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A repeat-while statement has the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>repeat-while文は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A repeat-while statement is executed as follows:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>repeat-while文は、次のように実行されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A return statement can consist of only the return keyword, or it can consist of the return keyword followed by an expression, as shown below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>return文はキーワードreturnだけから成ることができます、あるいはそれは、以下に示すように、キーワードreturnとそれに続く式から成ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A return statement occurs in the body of a function or method definition and causes program execution to return to the calling function or method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>return文は、関数またはメソッド定義の本文に現れて、プログラム実行を関数またはメソッド呼んでいるところに戻るようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A switch case can name the value or values it matches to temporary constants or variables, for use in the body of the case.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>switchケース節は、それがマッチする値または複数の値に名前を付けて一時的な定数や変数に束縛することが、そのケース節の本文で使うために行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A switch case can optionally contain a where clause after each pattern.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>switchケース節は、各パターンの後に随意にwhere節を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A switch case can use a where clause to check for additional conditions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>switchケース節は、where節を、追加の条件で調べるために使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A switch case that contains only a comment is reported as a compile-time error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>１つのコメントだけを含むswitchケース節は、コンパイル時エラーとして報告されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A switch statement allows certain blocks of code to be executed depending on the value of a control expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>switch文は、コードの特定のブロックをある制御式の値に従って実行されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A switch statement can also include a default case, introduced by the default keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>switch文はまた、キーワードdefaultによって導入される、省略時のケース節を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A switch statement considers a value and compares it against several possible matching patterns.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>switch文は、ある値について考察して、それをいくつかの候補のマッチングパターンと比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A switch statement has the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>switch文は以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A throw statement causes a program to end execution of the current scope and begin error propagation to its enclosing scope.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>throw文は、プログラムに現在のスコープの実行を終了させます、そしてそれを囲んでいるスコープにエラーの伝達を始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A throw statement consists of the throw keyword followed by an expression, as shown below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>throw文は、以下のように、throwキーワードとそれに続くひとつの式から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A throw statement occurs in the body of a throwing function or method, or in the body of a closure expression whose type is marked with the throws keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>throw文はスロー関数やメソッドの本文中に、またはthrowsキーワードで印される型のクロージャ式の中に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A try expression can’t appear on the right-hand side of an infix operator, unless the infix operator is the assignment operator or the try expression is enclosed in parentheses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>try式が接中辞演算子の右手側に現れることは、その接中辞演算子が代入演算子であるかtry式が丸括弧の中に入れられるかしない限りはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A while loop is appropriate in this case, because the length of the game isn’t clear at the start of the while loop.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>whileループはこの場合に適切なものです、なぜならゲームの長さはwhileループの開始時点ではっきりしないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A while loop performs a set of statements until a condition becomes false.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>whileループは、ひとまとめにした文を、ある条件がfalseになるまで実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A while loop starts by evaluating a single condition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>whileループは、１つだけ条件を評価することによって始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A while statement allows a block of code to be executed repeatedly, as long as a condition remains true.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>while文は、条件が真のままである限り、コードの１ブロックを繰り返して実行されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A while statement has the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>while文は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A while statement is executed as follows:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>while文は、次のように実行されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A willSet observer is called just before the value of the variable or property is set.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>willSetオブザーバーは、変数またはプロパティの値が設定される直前に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A for-await-in loop potentially suspends execution at the beginning of each iteration, when it’s waiting for the next element to be available.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>for-await-inループは、潜在的に遂行を各反復の始まりで中断します、次の要素が利用可能になるのをそれが待っている場合は。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A continue statement can consist of only the continue keyword, or it can consist of the continue keyword followed by the name of a statement label, as shown below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>continue文は、以下に示すように、キーワードcontinueだけから成ることができます、また、それはキーワードcontinueとそれに続く文ラベルから成ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A switch statement provides an alternative to the if statement for responding to multiple potential states.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>switch文は、複数の起こりうる状況に応答するためにif文に代わるものを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A switch statement can include only one default case, which must appear at the end of the switch statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>switch文は１つの省略時のケース節だけを含むことができます、それは、switch文の終わりに現れなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A break statement can consist of only the break keyword, or it can consist of the break keyword followed by the name of a statement label, as shown below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>break文はキーワードbreakだけから成ることができます、あるいは、それは、以下に示すように、キーワードbreakとそれに続く文ラベルの名前から成ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A fallthrough statement causes program execution to continue from one case in a switch statement to the next case.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>fallthrough文によって、プログラム実行がswitch文の１つのケース節から次のケース節に続くようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A CreditCard instance never outlives the Customer that it refers to.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>CreditCardインスタンスは、それが参照するCustomerより決して長生きしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A binary number, with a 0b prefix</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２進数は、接頭辞0bつきで</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A class declaration introduces a named class type into your program.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラス宣言は、名前をつけられたクラス型をあなたのプログラムに導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A closure expression creates a closure, also known as a lambda or an anonymous function in other programming languages.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャ式はクロージャ、他のプログラミング言語ではまたlambdaまたは匿名関数として知られるものをつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A code block is used by a variety of declarations and control structures to group statements together.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コード・ブロックは、いくつかの文をまとめるために、いろいろな宣言や制御構造で使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A compound type is a type without a name, defined in the Swift language itself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複合の型は名前のない型です、そしてスウィフト言語自身によって定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A constant declaration introduces a constant named value into your program.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数宣言は、名前をつけられた一定不変の値をあなたのプログラムにもたらします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A decimal number, with no prefix</seg>
      </tuv>
      <tuv lang="ja">
        <seg>10進数は、接頭辞なしで</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A declaration introduces a new name or construct into your program.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>宣言は、新しい名前または構造物をあなたのプログラムに導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A deinitializer declaration declares a deinitializer for a class type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>デイニシャライザ宣言は、クラス型のためにデイニシャライザを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A deinitializer is called immediately before a class instance is deallocated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>デイニシャライザは、クラスインスタンスが割り当て解除される直前に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A dictionary literal is an unordered collection of key-value pairs.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>辞書リテラルは、「キーと値」の対の順序付けされないコレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A dictionary stores associations between keys of the same type and values of the same type in a collection with no defined ordering.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>辞書は、同じ型のキーと同じ型の値との間の関連性をあるコレクションの中に順序を定義しないでしまっておきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A failable initializer is a type of initializer that produces an optional instance or an implicitly unwrapped optional instance of the type the initializer is declared on.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>失敗できるイニシャライザは、イニシャライザの一種で、そのイニシャライザが宣言されている型の、オプショナルのインスタンスまたは暗黙的にアンラップされるオプショナルのインスタンスを生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A forced-try expression consists of the try! operator followed by an expression that can throw an error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>強制try式は、try!演算子と後につづくエラーをスローできる１つの式から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A forced-value expression unwraps an optional value that you are certain isn’t nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>強制された値式は、あなたがnilでないことを確信しているオプショナルの値をアンラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A function call expression consists of a function name followed by a comma-separated list of the function’s arguments in parentheses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数呼び出し式は、関数名の後にその関数の引数のコンマ区切りのリストを丸括弧の中に続けることから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A function declaration introduces a function or method into your program.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数宣言は、あなたのプログラムに関数またはメソッドをもたらします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A function type represents the type of a function, method, or closure and consists of a parameter and return type separated by an arrow (-&gt;):</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数型は、ある関数、メソッド、またはクロージャの型を表して、矢印（-&gt;）で区切られたパラメータと戻り型から成ります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A generic argument clause specifies the type arguments of a generic type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体引数節は、総称体型の型引数を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A generic parameter clause specifies the type parameters of a generic type or function, along with any associated constraints and requirements on those parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体パラメータ節は、総称体の型や関数の型パラメータを、それらのパラメータに関するあらゆる付随する制約と要件と一緒に指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A hexadecimal number, with a 0x prefix</seg>
      </tuv>
      <tuv lang="ja">
        <seg>16進数は、接頭辞0xつきで</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A key-path expression refers to a property or subscript of a type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>キーパス式は、ある型のプロパティまたは添え字を参照します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A key-value pair is a combination of a key and a value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>「キーと値」の対は、ひとつのキーとひとつの値の組合せです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A lazy stored property is a property whose initial value isn’t calculated until the first time it’s used.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>遅延格納プロパティは、初めてそれが使われるまで、初期値が計算されないプロパティです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A literal expression consists of either an ordinary literal (such as a string or a number), an array or dictionary literal, a playground literal, or one of the following special literals:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>リテラル式は、普通のリテラル（例えば、ある文字列または数）、配列または辞書リテラル、プレイグラウンドリテラル、または以下の特別なリテラルのうちの１つから成ります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A literal is the source code representation of a value of a type, such as a number or string.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>リテラルは、ある型のある値をソースコードに表わしたものです、例えばある数や文字列など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A metatype type refers to the type of any type, including class types, structure types, enumeration types, and protocol types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるメタタイプ型は、クラス型、構造体型、列挙型、そしてプロトコル型を含む、何らかの型のその型に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A module is a single unit of code distribution—a framework or application that’s built and shipped as a single unit and that can be imported by another module with Swift’s import keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>モジュールは、コード分類の１つの単位 ― フレームワークまたはアプリケーションです、それは、単一の構成単位として構築され出荷されて、スウィフトのimportキーワードを使って別のモジュールによってインポートされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A named type is a type that can be given a particular name when it’s defined.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>名前付きの型は、それが定義される時に特定の名前を与えられることができる型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A nonfrozen enumeration is a special kind of enumeration that may gain new enumeration cases in the future—even after you compile and ship an app.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非凍結列挙は特別な種類の列挙です、それは新しい列挙ケース節を将来に — あなたがアプリをコンパイルおよび出荷する後でさえ、手に入れるかもしれないものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A parenthesized expression consists of an expression surrounded by parentheses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>括弧に入れられた式は、丸括弧で囲まれたある式から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A pattern represents the structure of a single value or a composite value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるパターンは、ある単一の値または複合の値の構造を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A playground literal is used by Xcode to create an interactive representation of a color, file, or image within the program editor.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プレイグラウンドリテラルは、Xcodeによって使われて、プログラムエディタ内でいろ、ファイル、または画像の双方向の表現を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A postfix operator is a unary operator that’s written immediately after its operand, such as the postfix forced-unwrap operator (!) in the expression a!.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>接尾辞演算子は単項演算子です、それはその演算数の直後に書かれます、例えば式a!での論理否定演算子（!）など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A precedence group declaration introduces a new grouping for infix operator precedence into your program.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>優先順位グループは、接中辞演算子優先順位に対する新しいグループをあなたのプログラムへ導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A prefix operator is a unary operator that’s written immediately before its operand, such as the prefix logical NOT operator (!) in the expression !a.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>接頭辞演算子は単項演算子です、それはその演算数の直前に書かれます、例えば式!aでの論理否定演算子（!）など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A protocol composition type defines a type that conforms to each protocol in a list of specified protocols, or a type that’s a subclass of a given class and conforms to each protocol in a list of specified protocols.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル合成型が定義するのは、指定されたプロトコルのリストの中の各プロトコルに準拠する型、または指定されたクラスのサブクラスであるそして指定されたプロトコルのリストの中の各プロトコルに準拠する型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A protocol declaration introduces a named protocol type into your program.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル宣言は、名前をつけられたプロトコル型をあなたのプログラムに導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A protocol defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるプロトコル（規約）は、メソッド、プロパティ、そして他の要件からなるひとつの青写真を定義します、それは、ある特定の作業またはある機能性断片にふさわしくするものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A recursive enumeration is an enumeration that has another instance of the enumeration as the associated value for one or more of the enumeration cases.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>再帰列挙は、１つ以上の列挙ケース節のための関連値としてその列挙の別のインスタンスを持つ列挙です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A result builder is a type that builds a nested data structure step by step.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>リザルトビルダーは、ある型です、それは入れ子にされたデータ構造を着実に組み立てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A result builder is a type you define that adds syntax for creating nested data, like a list or tree, in a natural, declarative way.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>リザルトビルダーはあなたが定義する型です、それは入れ子にされたデータ、たとえばリストやツリーなどを自然な、宣言的な方法で作成するための構文を加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A set stores distinct values of the same type in a collection with no defined ordering.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>集合は、同じ型の異なった値をひとつのコレクションの中に決まった順序なしで格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A source file is a single Swift source code file within a module (in effect, a single file within an app or framework).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ソースファイルは、あるモジュール内の単一のスウィフトソースコード・ファイルです（実質的には、アプリまたはフレームワーク内の単一のファイル）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A string is a series of characters, such as "hello, world" or "albatross".</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ひとつの文字列は、一連なりの文字です、例えば"hello, world"または"albatross"など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A structure declaration introduces a named structure type into your program.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体宣言は、名前をつけられた構造体型をあなたのプログラムに導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A subscript expression provides subscript access using the getter and setter of the corresponding subscript declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字式は、対応する添え字宣言のゲッターとセッターを使用して、添え字アクセスを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A subscript declaration allows you to add subscripting support for objects of a particular type and are typically used to provide a convenient syntax for accessing the elements in a collection, list, or sequence.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字宣言は、特定の型のオブジェクトに対する添え字サポートを付け加えることをあなたに可能にして、コレクション、リスト、またはシーケンスの中の要素にアクセスするための便利な構文を提供するために概して使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A superclass expression lets a class interact with its superclass.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スーパークラス式は、あるクラスをそのスーパークラスと相互に作用させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A task is a unit of work that can be run asynchronously as part of your program.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タスクは、ひとつの仕事の単位です、それは非同期にあなたのプログラムの一部として実行されることが可能なものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A try expression consists of the try operator followed by an expression that can throw an error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>try式は、try演算子と後につづくエラーをスローできる１つの式から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A tuple expression consists of a comma-separated list of expressions surrounded by parentheses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タプル式は、丸括弧に囲まれているコンマ区切りの式のリストから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A tuple pattern is a comma-separated list of zero or more patterns, enclosed in parentheses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タプルパターンは、丸括弧で囲まれた、０個以上のパターンのコンマ区切りのリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A tuple type is a comma-separated list of types, enclosed in parentheses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タプル型は、丸括弧で囲まれた、いくつかの型からなるコンマ区切りのリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A type alias declaration introduces a named alias of an existing type into your program.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型エイリアス宣言は、あなたのプログラムに既存の型の名前をつけられたエイリアスを導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A type annotation explicitly specifies the type of a variable or expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある型注釈は、明確に変数または式の型を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A type identifier refers to either a named type or a type alias of a named or compound type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型識別子は、名前付きの型か、名前付きまたは複合の型の型エイリアスに言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A type inheritance clause is used to specify which class a named type inherits from and which protocols a named type conforms to.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある型継承節は、ある名前付きの型が継承するのはどのクラスからか、およびある名前付きの型が準拠するのはどのプロトコルに対してかを指定するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A value type is a type whose value is copied when it’s assigned to a variable or constant, or when it’s passed to a function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>値型は、それが変数または定数に代入される時に、あるいは、それが関数に渡されるときに、値がコピーされる型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A value-binding pattern binds matched values to variable or constant names.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>値束縛パターンは、マッチした値を変数または定数の名前に縛り付けてひとつに束ねます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A variable declaration introduces a variable named value into your program and is declared using the var keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>変数宣言は、名前をつけられた変えられる値をあなたのプログラムにもたらします、そしてキーワードvarを使って宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A variadic parameter accepts zero or more values of a specified type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>可変長パラメータは、指定された型の０個以上の値を受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A weak reference is a reference that doesn’t keep a strong hold on the instance it refers to, and so doesn’t stop ARC from disposing of the referenced instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>弱い参照は、それが言及するインスタンスに対する強い支配力を保たない参照です、なのでARCは参照をつけられたインスタンスを処分するのを止めません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A wildcard expression is used to explicitly ignore a value during an assignment.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ワイルドカード式は、代入の間に明示的に値を無視するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A wildcard pattern matches and ignores any value and consists of an underscore (_).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ワイルドカード・パターンは、どんな値にでもマッチして無視します、そしてアンダースコア（_）から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A type argument is the name of an actual concrete type that replaces a corresponding type parameter in the generic parameter clause of a generic type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型引数は実際の具象型の名前です、それは、ある総称体型のもつ総称体パラメータ節の中の対応する型パラメータを置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A type parameter is simply the name of a placeholder type (for example, T, U, V, Key, Value, and so on).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型パラメータは、単にプレースホルダ型の名前です（たとえばT、U、V、Key、Valueなど）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A where clause is introduced by the where keyword followed by an expression, and is used to provide an additional condition before a pattern in a case is considered matched to the control expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>where節は、キーワードwhereのあとにひとつの式を続けることによって導入されます、そしてケース節の中のあるパターンがその制御式にマッチしたと考えられるより前に更なる条件を与えるために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A Swift Tour</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトツアー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A Swift constant or variable that refers to an instance of some reference type is similar to a pointer in C, but isn’t a direct pointer to an address in memory, and doesn’t require you to write an asterisk (*) to indicate that you are creating a reference.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある参照型のインスタンスに言及するスウィフト定数または変数はCの中のポインターに似ています、しかしメモリ中のアドレスへの直接のポインターでなくて、あなたに参照をつくっていることを示すために星印（*）を書くことを要求しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A Swift property doesn’t have a corresponding instance variable, and the backing store for a property isn’t accessed directly.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトのプロパティには対応するインスタンス変数がありません、そしてプロパティのための支援外部記憶は直接にアクセスされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A Unicode scalar value is a unique 21-bit number for a character or modifier, such as U+0061 for LATIN SMALL LETTER A ("a"), or U+1F425 for FRONT-FACING BABY CHICK ("🐥").</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるユニコードスカラー値は、ある文字または修飾子のための固有な21ビットの数字です、例えばU+0061はLATIN SMALL LETTER A（"a"）に対して、またはU+1F425はFRONT-FACING BABY CHICK（"🐥"）に対してなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A branch statement becomes a series of nested calls to the buildEither(first:) and buildEither(second:) methods.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある分岐文は、一連の入れ子にされたbuildEither(first:)とbuildEither(second:)メソッドそれらへの呼び出しになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A branch statement that checks an availability condition becomes a call to the buildLimitedAvailability(_:) method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある有効性条件を検査する分岐文は、buildLimitedAvailability(_:)メソッドへの呼び出しになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A branch statement that might not produce a value, like an if statement without an else clause, becomes a call to buildOptional(_:).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>値を生成しないかもしれない分岐文、たとえばif文でelse節なしなどは、buildOptional(_:)への呼び出しになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A capture list defines the rules to use when capturing one or more reference types within the closure’s body.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>捕獲リストは、クロージャの本文内で１つ以上の参照型を捕獲するとき使用する規則を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A capture list is written as a comma-separated list of expressions surrounded by square brackets, before the list of parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>キャプチャリストは、角括弧に囲まれたいくらかの式からなる「コンマ区切り」のリストとして、パラメータのリストの前に書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A class can inherit methods, properties, and other characteristics from another class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスは、メソッド、プロパティ、および他の特徴を別のクラスから継承することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A class can override properties, methods, subscripts, and initializers of its superclass.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスは、それのスーパークラスのプロパティ、メソッド、添え字、そしてイニシャライザをオーバーライドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A class or structure can provide as many subscript implementations as it needs, and the appropriate subscript to be used will be inferred based on the types of the value or values that are contained within the subscript brackets at the point that the subscript is used.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスや構造体はそれが必要とする多くの添え字実装を提供することが可能です、そして使用されるのに適切な添え字が、添え字が使われる時点でその添え字角括弧内に含まれる値または複数の値の型に基づいて、推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A class type can inherit from only one parent class, its superclass, but can adopt any number of protocols.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラス型は、ただ１つの親クラス、それのスーパークラスから継承することだけが許されます、しかし随意の数のプロトコルに準拠することはできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A class type method marked with the class declaration modifier can be overridden by a subclass implementation; a class type method marked with class final or static can’t be overridden.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>class宣言修飾子で印されるクラス型メソッドは、サブクラス実装によってオーバーライドされることができます；class finalまたはstaticで印されるクラス型メソッドはオーバーライドされることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A class, structure, or enumeration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラス、構造体、または列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A class, structure, or enumeration type can enable syntactic sugar for function call syntax by declaring one of several methods, as described in Methods with Special Names.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラス、構造体、または列挙型は、構文糖を関数呼び出し構文に対して可能にすることが、幾つかのメソッドの１つを宣言することによって可能です、特殊名を持つメソッドで記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A class, structure, or enumeration type can support function call syntax by defining a dynamicallyCall(withArguments:) method or a dynamicallyCall(withKeywordArguments:) method, as described in dynamicCallable, or by defining a call-as-function method, as described below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラス、構造体、または列挙は、関数呼び出し構文をサポートできます。dynamicallyCall(withArguments:)メソッドまたはdynamicallyCall(withKeywordArguments:)メソッドを定義することによって、dynamicCallableにおいて記述されるように、またはcall-as-functionメソッドを定義することによって、下で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A class-only protocol is marked by its inheritance from AnyObject, as discussed in Class-Only Protocols.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラス専用プロトコルは、AnyObjectからのそれの継承によって印されます、クラス専用プロトコルにおいて議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A closure can capture constants and variables from the surrounding context in which it’s defined.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャは、それが定義される周囲の前後関係から、定数と変数を捕獲（キャプチャ）できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A closure can omit the types of its parameters, its return type, or both.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャは、そのパラメータの型、その戻り型、または両方を省略することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A closure expression is nonescaping if it’s called immediately or passed as a nonescaping function argument.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャ式は、もしそれが直接に呼び出されるか、または非脱出関数引数として渡されるならば非脱出です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A closure is said to escape a function when the closure is passed as an argument to the function, but is called after the function returns.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャが引数として関数に渡される、しかしその関数が戻った後に呼び出されるとき、クロージャは関数を脱出すると言われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A closure may omit names for its parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャは、そのパラメータの名前を省略することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A closure or function type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャまたは関数型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A closure or nested function that captures an in-out parameter must be nonescaping.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>in-outパラメータをキャプチャするクロージャまたは入れ子にされた関数は、非脱出でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A closure passed as the last argument to a function can appear immediately after the parentheses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最後の引数として関数に渡されるクロージャは、丸括弧の直後に現れることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A closure that consists of only a single expression is understood to return the value of that expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>１つの式だけから成るクロージャは、その式の値を返すと理解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A code block or do statement becomes a call to the buildBlock(_:) method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コードブロックまたはdo文は、buildBlock(_:)メソッドへの呼び出しになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A collection of 21-bit Unicode scalar values, equivalent to the string’s UTF-32 encoding form (accessed with the string’s unicodeScalars property)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>21ビットのUnicodeスカラー値の集まり、その文字列のUTF-32符号化方式と等しい（文字列のunicodeScalarsプロパティでアクセスされます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A collection of UTF-16 code units (accessed with the string’s utf16 property)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>UTF-16符号単位の集まり（文字列のutf16プロパティでアクセスされます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A collection of UTF-8 code units (accessed with the string’s utf8 property)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>UTF-８符号単位の集まり（文字列のutf8プロパティでアクセスされます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A comma is allowed after the last element.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ひとつのコンマが最後の要素のあとに許容されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A compile-time diagnostic statement causes the compiler to emit an error or a warning during compilation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コンパイル時診断文は、コンパイラにエラーまたは警告をコンパイルの間に発せさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A compile-time diagnostic statement has the following forms:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コンパイル時診断文は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A compound type may contain named types and other compound types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ひとつの複合の型は、名前付きの型や他の複合の型を含むかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A computed property with a getter but no setter is known as a read-only computed property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ゲッターを持つ、しかしセッターはない計算プロパティは、読み出し専用の計算プロパティとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A concrete type can conform to a particular protocol only once.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある具象型は、特定のプロトコルにただ一度だけ準拠できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A conditional compilation block allows code to be conditionally compiled depending on the value of one or more compilation conditions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>条件コンパイルブロックは、１つ以上のコンパイル条件の値に依存してコードが条件付きでコンパイルされるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A conflicting access to memory can occur when different parts of your code are trying to access the same location in memory at the same time.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メモリアクセスの衝突は、あなたのコードの異なる部分がメモリの同じ位置に同じ時にアクセスしようとする場合に生じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A conforming type can provide additional functionality, as long as it satisfies these three requirements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それに準拠している型は、それがこれらの３つの要件を満たす限り、追加の機能性を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A conforming type can satisfy a failable protocol initializer requirement by implementing any kind of initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある準拠している型は、失敗できるプロトコルイニシャライザ要件を満たすことが、どんな種類のイニシャライザを実装することによっても可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A conforming type can satisfy a nonfailable protocol initializer requirement by implementing a nonfailable initializer or an init! failable initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある準拠している型は、失敗できないプロトコルイニシャライザ要件を満たすことが、失敗できないイニシャライザまたはinit!失敗できるイニシャライザを実装することによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A consistent use of Int for integer values aids code interoperability, avoids the need to convert between different number types, and matches integer type inference, as described in Type Safety and Type Inference.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>整数値のためのIntの一貫した使用は、コードの相互運用性を支援して、異なる数の型の間で変換する必要を避けて、「型安全と型推論」で記述されるように、整数型推論に合致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A constant declaration defines an immutable binding between the constant name and the value of the initializer expression; after the value of a constant is set, it can’t be changed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数宣言は、定数名とイニシャライザ式の値の間の不変の束縛を定義します；定数の値が設定されたあと、それは変更されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A constant or variable must have the same type as the value you want to assign to it.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数または変数は、あなたがそれに代入したい値と同じ型を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A constant or variable of a certain class type may actually refer to an instance of a subclass behind the scenes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>特定のクラス型の定数または変数は、舞台裏で実際にはあるサブクラスのインスタンスを参照するかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A constant type property of a class is always implicitly final; you can’t mark it with the class or final declaration modifier to allow or disallow overriding by subclasses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるクラスの定数型プロパティは、常に暗黙的に最終的なものです；あなたはそれをclassまたはfinal宣言修飾子で印できません、またはサブクラスによるオーバーライドを許可したり不許可にしたりできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A constant, variable, or property can’t be more public than its type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数、変数、またはプロパティは、その型よりもより公開であることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A convenience initializer must call another initializer from the same class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>便宜イニシャライザは、別のイニシャライザを同じクラスから呼ばなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A convenience initializer must delegate to another initializer before assigning a value to any property (including properties defined by the same class).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>便宜イニシャライザは、値を何らかのプロパティ（同じクラスによって定義されるプロパティを含む）に代入する前に、別のイニシャライザに委任しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A convenience initializer must ultimately call a designated initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>便宜イニシャライザは、最終的に指定イニシャライザを呼ばなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A custom infix operator that isn’t explicitly placed into a precedence group is given a default precedence group with a precedence immediately higher than the precedence of the ternary conditional operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある優先順位グループの中に明示的に置かれないあつらえの接中辞演算子は、三項条件演算子の優先順位のすぐ上の優先順位を持つ省略時の優先順位グループを与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A decimal integer greater than zero</seg>
      </tuv>
      <tuv lang="ja">
        <seg>０より大きい10進法整数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A default initializer has the same access level as the type it initializes, unless that type is defined as public.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>省略時のイニシャライザは、それが初期化する型と同じアクセス水準を持ちます、その型がpublicとして宣言される場合を除いて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A default parameter called newValue is provided to your setter if you don’t provide one yourself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが独自のものを提供しないならば、newValueと呼ばれる省略時のパラメータがあなたのセッターに提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A deinitializer can be declared only in the body of a class declaration—but not in an extension of a class—and each class can have at most one.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>デイニシャライザは、クラス宣言の本文においてのみ ― しかしクラスの拡張においてではなく ― 宣言されることができます、そして各クラスが多くとも１つしか持つことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A deinitializer is called automatically when there are no longer any references to a class object, just before the class object is deallocated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>デイニシャライザは、あるクラスオブジェクトに対するいかなる参照ももはやない時、そのクラスオブジェクトが割り当て解除される直前に、自動的に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A designated initializer for that class confirms that all stored properties introduced by that class have a value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのクラスのための指定イニシャライザは、そのクラスによって導入される全ての格納プロパティが値を持つことを確かめます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A designated initializer fully initializes all properties introduced by that class and calls an appropriate superclass initializer to continue the initialization process up the superclass chain.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>指定イニシャライザは、そのクラスによって導入される全てのプロパティを完全に初期化して、適切なスーパークラスのイニシャライザを呼んで初期化プロセスを続けていきスーパークラス連鎖を上っていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A designated initializer must call a designated initializer from its immediate superclass.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>指定イニシャライザは、その直接のスーパークラスから指定イニシャライザを呼ばなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A designated initializer must delegate up to a superclass initializer before assigning a value to an inherited property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>指定イニシャライザは、継承されたプロパティに代入する前にスーパークラスのイニシャライザへ委任しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A designated initializer must ensure that all of the properties introduced by its class are initialized before it delegates up to a superclass initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>指定イニシャライザは、それがスーパークラスのイニシャライザへと委任する前に、そのクラスによって導入されるプロパティの全てが初期化されることを確実にしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A designated initializer of a class initializes all of the class’s properties directly.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるクラスの指定イニシャライザは、直接そのクラスのプロパティの全てを初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A designated or convenience initializer is called on a class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>指定または便宜イニシャライザが、あるクラスで呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A dictionary Key type must conform to the Hashable protocol, like a set’s value type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある辞書のKey型は、集合の持つ値型のように、Hashableプロトコルに準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A dictionary literal is a shorthand way to write one or more key-value pairs as a Dictionary collection.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>辞書リテラルは、Dictionaryコレクションとして１つ以上の「キーと値」の対を書く簡便な方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A different function with the same matching type can be assigned to the same variable, in the same way as for nonfunction types:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じ適合型を持つ異なる関数は、同じ変数に代入されることが可能です、それは非関数型に対するのと同じ方法で行えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A failable designated initializer can be overridden in a subclass by any kind of designated initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>失敗できる指定イニシャライザは、サブクラスにおいて任意の種類の指定イニシャライザでオーバーライドされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A failable initializer can also delegate to a nonfailable initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>失敗できるイニシャライザは、また、失敗できないイニシャライザへと委任することもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A failable initializer can delegate to any kind of initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>失敗できるイニシャライザは、あらゆる種類のイニシャライザへ委任することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A failable initializer can return nil at any point in the implementation of the initializer’s body.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>失敗できるイニシャライザは、そのイニシャライザの本文の中の任意の地点でnilを返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A failable initializer creates an optional value of the type it initializes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>失敗できるイニシャライザは、そのイニシャライザの型のオプショナルの値を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A failable initializer is used to find an appropriate enumeration case for a Character value representing a temperature symbol:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>失敗できるイニシャライザは、ある温度記号で表されているCharacter値に対して適切な列挙ケース節を見つけるために使用されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A failable initializer of a class, structure, or enumeration can delegate across to another failable initializer from the same class, structure, or enumeration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラス、構造体、または列挙のための失敗できるイニシャライザは、同じクラス、構造体、または列挙からの別の失敗できるイニシャライザに横つながりに委任することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A failable initializer requirement can be satisfied by a failable or nonfailable initializer on a conforming type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>失敗できるイニシャライザ要件は、準拠している型上の失敗できるもしくは失敗できないイニシャライザによって満たされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A fourth value is pushed onto the top of the stack.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>第４の値がスタックのてっぺんに押し込まれ（プッシュされ）ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A function call can include multiple trailing closures; however, the first few examples below use a single trailing closure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数呼び出しは、複数の後付クロージャを含むことができます；しかしながら、下の最初の幾つかの例はただ１つだけ後付クロージャを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A function call expression can include trailing closures in the form of closure expressions immediately after the closing parenthesis.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数呼び出し式は、閉じ丸括弧の直後にクロージャ式の形で後付クロージャいくつかを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A function can have multiple variadic parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数は、複数の可変長パラメータを持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A function can take another function as one of its arguments.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある関数は、その引数の１つとして別の関数をとることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A function can’t have a higher access level than its parameter types and return type, because the function could be used in situations where its constituent types are unavailable to the surrounding code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数は、そのパラメータ型および戻り型より高いアクセス水準を持つことができません、なぜなら、その関数は、それの組成の型が周囲のコードに利用できない状況において使われることができるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A function declaration whose statements include only a single expression is understood to return the value of that expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それのstatementsがただ１つの式だけを含む関数宣言は、その式の値を返すものと理解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A function declared in the context of class, structure, enumeration, or protocol is referred to as a method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラス、構造体、列挙、またはプロトコルの文脈において宣言される関数は、メソッドとして言及されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A function definition can appear inside another function declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数定義は、別の関数宣言の内部に現れることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A function has long-term write access to all of its in-out parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある関数は長期書き込みアクセスをそれのin-outパラメータの全てに対して持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A function indicates that it can throw an error by including the throws keyword in its declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある関数は、それがエラーをスローできることをthrowsキーワードをそれの宣言に含めることによって示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A function marked with throws is called a throwing function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>throwsで印された関数は、スロー関数と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A function or method can be declared with the rethrows keyword to indicate that it throws an error only if one of its function parameters throws an error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数またはメソッドは、rethrowsキーワードとともに宣言されて、それの関数パラメータの１つがエラーをスローする場合にのみそれがエラーをスローすることを指し示すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A function or method with an opaque return type hides its return value’s type information.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>不透明戻り型をもつ関数またはメソッドは、それの戻り値のもつ型情報を隠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A function that tries to retrieve a web page might return the (Int, String) tuple type to describe the success or failure of the page retrieval.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ウェブ・ページを探してくるある関数は、ページ検索の成功または失敗を記述するために(Int, String)のタプル型を返すかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A function that uses an opaque type as its return type must return values that share a single underlying type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>不透明型をそれの戻り型として使う関数は、ある単一の基礎をなす型を共有する値を返さなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A function type can have variadic parameters in its parameter type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数型は、そのパラメータ型において可変長パラメータいくつかを持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A function with a defined return type can’t allow control to fall out of the bottom of the function without returning a value, and attempting to do so will result in a compile-time error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある定義された戻り型を持つ関数は、値を返すことなく関数の底を抜け落ちるように制御されることができません、そしてそうしようとすることはコンパイル時エラーに終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A function with the Objective-C block calling convention can’t be converted to the C calling convention.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Objective-Cブロック呼出規約での関数は、C呼出規約に変換されることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A function’s arguments must always be provided in the same order as the function’s parameter list.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数の引数は、常にその関数のパラメータ一覧と同じ順序で提供されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A future version of Swift will always use the left-to-right ordering.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトの将来のバージョンは、常に左から右順を使うでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A future version of Swift will print “110 -”.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトの将来のバージョンは、“110 -” を出力するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A generic where clause can appear as part of a declaration that includes type parameters, or as part of a declaration that’s nested inside of a declaration that includes type parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体where節は、型パラメータを含む宣言の一部として、または型パラメータを含む宣言の内部に入れ子にされる宣言の一部として現れることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A generic where clause enables you to require that an associated type must conform to a certain protocol, or that certain type parameters and associated types must be the same.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体where節は、ある関連型が特定のプロトコルに準拠しなければならないこと、または特定の型パラメータおよび関連型が同じでなければならないことをあなたが要求できるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A generic where clause consists of the where keyword, followed by a comma-separated list of one or more requirements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体where節は、whereキーワード、それに続けてコンマ区切りのリストのひとつ以上の要件（requirements）から構成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A generic where clause starts with the where keyword, followed by constraints for associated types or equality relationships between types and associated types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体where節は、whereキーワードで始まり、関連型に対する制約がいくつか、または型と関連型の間の同等関係性がいくつか続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A generic argument clause is enclosed in angle brackets (&lt;&gt;) and has the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体引数節は、山形括弧（&lt;&gt;）に囲まれて、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A generic parameter clause is enclosed in angle brackets (&lt;&gt;) and has the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体パラメータ節は、山形括弧（&lt;&gt;）において囲まれて、以下の書式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A generic parameter consists of a type parameter followed by an optional constraint.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体パラメータは、型パラメータとそれに続く任意の制約から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A generic type may be able to satisfy the requirements of a protocol only under certain conditions, such as when the type’s generic parameter conforms to the protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体型は、あるプロトコルの要件を満たすことが一定の条件の下でのみ可能でしょう、例えばその型のもつ総称体パラメータがそのプロトコルに準拠する場合など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A hash value is an Int value that’s the same for all objects that compare equally, such that if a == b, the hash value of a is equal to the hash value of b.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるハッシュ値はあるひとつのInt値です、それは同等とみなされる全てのオブジェクトに対して同じものです、たとえばa == bならば、aのハッシュ値はbのハッシュ値に等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A key-path string expression lets you access the string used to refer to a property in Objective-C, for use in key-value coding and key-value observing APIs.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>キーパス文字列式は、あなたにObjective-Cでのプロパティを参照するために使われる文字列にアクセスさせます、キー値コーディングとキー値監視APIで使用するために。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A labeled statement is indicated by placing a label on the same line as the statement’s introducer keyword, followed by a colon.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ラベルをつけられた文は、あるラベルをその文の導入子キーワードとして、コロンをその後に続けて同じ行に置くことによって示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A line control statement has the following forms:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>行制御文は以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A line control statement is used to specify a line number and filename that can be different from the line number and filename of the source code being compiled.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>行制御文は、ある行番号とファイル名を指定するために使われます、それはコンパイルされているソースコードの行番号とファイル名とは異なっていることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A literal doesn’t have a type on its own.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>リテラルはそれ独自の型を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A long-term access can overlap with other long-term accesses and instantaneous accesses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>長期アクセスは、他の長期アクセスおよび即時アクセスでオーバーラップ可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A metatype, such as Int.self</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メタタイプ、たとえばInt.self</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A method marked with the nonobjc attribute can’t override a method marked with the objc attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>nonobjc属性で印されるメソッドは、objc属性で印されるメソッドをオーバーライドできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A module name</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるモジュール名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A multiline string can be indented to match the surrounding code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複数行文字列は、字下げされることによって、囲んでいるコードに調和します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A multiline string literal can be indented using any combination of spaces and tabs; this indentation isn’t included in the string.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複数行文字列リテラルは、空白とタブの任意の組み合わせを使って字下げできます；この字下げはその文字列に含まれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A multiline string literal includes all of the lines between its opening and closing quotation marks.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複数行文字列リテラルは、それの開始および終了引用符の間のすべての行を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A multiline string literal is surrounded by three double quotation marks and has the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複数行の文字列リテラルは、３つの二重引用符によって囲まれて、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A mutating method on a structure has write access to self for the duration of the method call.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある構造体での変更メソッドは、selfに対する書き込みアクセスをそのメソッド呼び出しの継続期間にわたって持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A name before the parameter name gives the parameter an explicit argument label, which can be different from the parameter name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>パラメータ名の前の名前は、そのパラメータに明示的な引数ラベルを与えます、それはパラメーター名と異なるものにできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A nested function can capture any of its outer function’s arguments and can also capture any constants and variables defined within the outer function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>入れ子にされた関数は、その外側の関数の持つ引数の何でも捕獲することができ、また外側の関数の範囲内で定義されるどんな定数や変数でも捕獲することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A nested function is nonescaping if it captures a value that’s guaranteed to never escape—such as an in-out parameter—or passed as a nonescaping function argument.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>入れ子にされた関数は、もしそれが、決して脱出しないことを保証される値を — たとえばin-outパラメータ — または非脱出関数引数として渡される値をキャプチャするならば非脱出です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A new Player instance is created, with a request for 100 coins if they’re available.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>新しいPlayerインスタンスが、それが可能ならば100のコインを要請して作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A nonfailable designated initializer can be overridden in a subclass by a nonfailable designated initializer only.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>失敗できない指定イニシャライザは、サブクラスにおいて失敗できない指定イニシャライザでのみオーバーライドされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A nonfailable initializer can delegate to an init? failable initializer by force-unwrapping the result of the superclass’s initializer—for example, by writing super.init()!.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>失敗できないイニシャライザは、init?失敗できるイニシャライザに委任することが、スーパークラスのイニシャライザの結果を強制アンラップすることによって可能です ― 例えば、super.init()!と書くことによって。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A nonfailable initializer can delegate to another nonfailable initializer or to an init! failable initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>失敗できないイニシャライザは、別の失敗できないイニシャライザへ、または失敗できるイニシャライザinit!へ委任することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A nonfailable initializer requirement can be satisfied by a nonfailable initializer or an implicitly unwrapped failable initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>失敗できないイニシャライザ要件は、失敗できないイニシャライザまたは暗黙的にアンラップされる失敗できるイニシャライザによって満たされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A nongeneric global function, a local function that doesn’t capture any local variables, or a closure that doesn’t capture any local variables can be converted to the C calling convention.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非総称体グローバル関数、何らローカル変数をキャプチャしないローカル関数、または何らローカル変数をキャプチャしないクロージャは、C呼出規約に変換されることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A nonisolated member executes like code outside of the actor: It can’t interact with any of the actor’s isolated state, and callers don’t mark it with await when using it.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非隔離メンバーは、アクターの外側のコードのように遂行します：それはアクターのもつ隔離された状態のどれとも相互作用できません、そして呼び出し側は、それを使う時にそれをawaitで印しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A nonreturning function or method can be called to conclude the else clause of a guard statement, as discussed in Guard Statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非復帰関数およびメソッドは、guard文のelse節で終わるために呼び出されることができます、guard文で議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A number that won’t fit into a constant or variable of a sized integer type is reported as an error when your code is compiled:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたのコードがコンパイルされるとき、ある大きさを設定された整数型の定数または変数に収まらない数はエラーとして報告されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A pair of parentheses still wrap the entire argument for the method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>一対の丸括弧は、依然としてこのメソッドに対する引数をすべて包みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A parameter structurally resembles a function type if the parameter isn’t an in-out parameter, and the parameter is one of the following:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>パラメータは、そのパラメータがin-outパラメータでないならば関数型と構造的に似ています、そしてそのパラメータは以下の１つです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A parameter has a name, which is used within the function body, as well as an argument label, which is used when calling the function or method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>パラメータは名前を持ちます、それは関数本文内部で使われます、それだけでなく引数ラベルも、それは関数やメソッドが呼ばれる時に使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A parameter of the function type () -&gt; T (where T is any type) can apply the autoclosure attribute to implicitly create a closure at its call sites.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数型() -&gt; T（ここでTはどんな型でも）のあるパラメータは、autoclosure属性を適用することによって、あるクロージャを暗黙的にそれの呼び出し領域で作成することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A parameter that immediately follows a variadic parameter must have an argument label.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある可変長パラメータに直ちに続くパラメータは、引数ラベルを持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A parameter that’s a nonescaping function can’t be passed as an argument to another nonescaping function parameter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非脱出関数であるパラメータは、別の非脱出関数パラメータに引数として渡されることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A parameter that’s a nonescaping function can’t be stored in a property, variable, or constant of type Any, because that might allow the value to escape.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非脱出関数であるパラメータは、型Anyのプロパティ、変数、または定数に格納できません、なぜならそれは値を脱出させることを許可するかもしれないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A parameter whose type combines these allowed types, like (Optional&lt;(Bool) -&gt; Int&gt;)...</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それの型は許可される型それらを組み合わせるものであるパラメータ、たとえば(Optional&lt;(Bool) -&gt; Int&gt;)...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A parameter whose type is a function type, like (Bool) -&gt; Int</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それの型が関数型であるパラメータ、たとえば(Bool) -&gt; Int</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A parameter whose type is wrapped in one or more layers of optional, like Optional&lt;(Bool) -&gt; Int&gt;</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それの型が１つ以上のオプショナルのレイヤーの中にラップされるパラメータ、たとえばOptional&lt;(Bool) -&gt; Int&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A parameter with a base type name followed immediately by three dots (...) is understood as a variadic parameter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>基本の型の名前に直ちに３つの点（...）が続くパラメータは、可変長パラメータとして理解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A parameter with an equals sign (=) and an expression after its type is understood to have a default value of the given expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その型の後に等号（=）と式をもつパラメータは、与えられた式からなる省略時の値を持つと理解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A pointer that’s created by these implicit conversions is valid only for the duration of the function call.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの暗黙的変換によって作成されるポインタは、その関数呼び出しの間だけ有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A postfix self expression consists of an expression or the name of a type, immediately followed by .self.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>接尾辞self式は、ある式または型の名前と、それに直ちに続く.selfから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A precedence group declaration has the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>優先順位グループ定義は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A precedence group specifies an operator’s precedence relative to other infix operators, as well as the operator’s associativity.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>優先順位グループは、他の接中辞演算子と相対的にある演算子の優先順位を、それだけでなく演算子の結合性も指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A program that uses parallel and asynchronous code carries out multiple operations at a time; it suspends operations that are waiting for an external system, and makes it easier to write this code in a memory-safe way.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>並列および非同期のコードを使用するプログラムは、複数の演算を一度に実施します；それは、外部システムを待つ演算を中断します、そしてこのコードをメモリ安全な方法で書くのをより簡単にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A property declaration in a class is written the same way as a constant or variable declaration, except that it’s in the context of a class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスの中のプロパティ宣言は、定数または変数の宣言と同じ方法で書かれます、ただしそれはクラスの前後関係の中にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A property that has a property wrapper can include willSet and didSet blocks, but it can’t override the compiler-synthesized get or set blocks.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティラッパーを持つプロパティは、willSetとdidSetブロックを含むことができます、しかしそれはコンパイラが合成したgetまたはsetブロックをオーバーライドできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A property that normally returns an Int will return an Int? when accessed through optional chaining.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>通常はIntを返すプロパティは、オプショナル連鎖を通してアクセスされるときInt?を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A property wrapper adds a layer of separation between code that manages how a property is stored and the code that defines a property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティラッパーは、プロパティが格納される方法を管理するコードとプロパティを定義するコードとの間に分離のレイヤー（層）を加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A property wrapper can return a value of any type as its projected value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティラッパーは、あらゆる型の値をそれの投影値として返せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A protocol can inherit one or more other protocols and can add further requirements on top of the requirements it inherits.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルは、１つ以上の他のプロトコルを継承することができて、それが継承する要件の上に、更なる要件を加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A protocol can appear as part of its own requirements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるプロトコルは、それ自身の要件の一部として現れることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A protocol can be used as the type to be stored in a collection such as an array or a dictionary, as mentioned in Protocols as Types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型としてのプロトコルで言及されるように、プロトコルは型として使われることで、コレクション、例えば配列や辞書などに保管されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A protocol can require any conforming type to provide an instance property or type property with a particular name and type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるプロトコルは、あらゆる準拠型に、特定の名前と型をもつインスタンスプロパティまたは型プロパティを提供するように要求することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A protocol composition type allows you to specify a value whose type conforms to the requirements of multiple protocols without explicitly defining a new, named protocol that inherits from each protocol you want the type to conform to.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル合成型は、あなたにそれの型が複数のプロトコルに属する要件に準拠するある値を、あなたがその型に準拠して欲しいプロトコル各々から継承する名前をつけられたある新しいプロトコルを明示的に定義する必要なしに指定させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A public type defaults to having internal members, not public members.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>公開の型は特に何もしない状態では内部のメンバーを持ちます、公開のメンバーではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A public variable can’t be defined as having an internal, file-private, or private type, because the type might not be available everywhere that the public variable is used.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>公開の変数は、内部、ファイル外非公開、または非公開の型のものを持つように定義されることができません、なぜなら、その型は公開の変数が使われるあらゆる所で利用可能ではないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A read-only computed property always returns a value, and can be accessed through dot syntax, but can’t be set to a different value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>読み出し専用の計算プロパティは常にある値を返します、そしてドット構文を通してアクセスされることができますが、異なる値に設定されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A recursive function is a straightforward way to work with data that has a recursive structure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>再帰関数は、率直な方法で再帰構造を持つデータを扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A reference to the returned function is stored in a constant called moveNearerToZero.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>返された関数への参照は、moveNearerToZeroと呼ばれる定数に格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A required initializer must have the same access level as the class it belongs to.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>必須イニシャライザは、それが属しているクラスと同じアクセス水準を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A result builder implements static methods described below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>リザルトビルダーは、下で記述される静的メソッドを実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A result builder lets you rewrite code like this so that it looks like normal Swift code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>リザルトビルダーは、あなたにこのようなコードを、それが通常のスウィフトコードのように見えるように書き直させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A result builder must implement this method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>リザルトビルダーは、このメソッドを実装しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A rethrowing function or method can contain a throw statement only inside a catch clause.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>再度スローする関数やメソッドは、throw文をcatch節の内部にのみ含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A selector expression lets you access the selector used to refer to a method or to a property’s getter or setter in Objective-C.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>セレクタ式は、あなたに、Objective-Cにおけるあるメソッドをまたはあるプロパティの持つゲッターやセッターを参照するために使われるセレクタにアクセスをさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A semicolon (;) can optionally appear after any statement and is used to separate multiple statements if they appear on the same line.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>セミコロン（;）はあらゆる文の後に任意に現れることができて、複数の文をそれらが同じ行に現れる場合に別々に分けるために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A set type can’t be inferred from an array literal alone, so the type Set must be explicitly declared.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>集合の型は配列リテラルのみでは推論されることができません、それで型Setが明示的に宣言されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A sign bit of 0 means positive, and a sign bit of 1 means negative.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>0の符号ビットは正を意味します、そして、1の符号ビットは負であることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A similar principle is used to check for Song instances, and to print an appropriate description (including artist name) whenever a Song is found in the library.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>類似した原則が使用されて、Songインスタンスか確認して、そしてSongがlibraryで見つけられるときはいつでも、適切な説明（artist名を含む）を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A simple conditional compilation block has the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>単純な条件コンパイルブロックは、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A simple way to remember this is:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これを覚えている単純な方法は、以下の通りです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A single expression inside parentheses is a parenthesized expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>丸括弧で囲まれたただ１つだけの式は、括弧で囲まれた式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A single-line string literal is surrounded by double quotation marks and has the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>単一行の文字列リテラルは、二重引用符によって囲まれて、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A speed of 35.0 produces a gear of 4:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>速度35.0はギア4を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A stack is a useful collection model whenever you need a strict “last in, first out” approach to managing a collection.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スタックは、厳格に「最後に入れたものが、最初に取り出される」取り組みをコレクションを管理するために必要とするときはいつでも、役に立つコレクション・モデルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A stack is an ordered set of values, similar to an array, but with a more restricted set of operations than Swift’s Array type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スタックは、順序付けられたいくつかの値の集合であり、配列に似ています、しかしスウィフトのArray型より制限された操作具合を持つものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A stack, however, allows new items to be appended only to the end of the collection (known as pushing a new value on to the stack).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スタックは、しかし、新しい項目をコレクション終わりにのみ追加されることが許されます（新しい値をスタックにプッシュするとして知られます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A status code of 404 Not Found is returned if you request a webpage that doesn’t exist.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>状態コード404 Not Foundは、あなたが存在しないウェブ・ページを要請するならば返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A stored variable or property declared with observers has the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オブザーバーとともに宣言される格納変数やプロパティは、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A string delimited by extended delimiters has the following forms:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張区切り記号によって区切られた文字列は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A string delimited by extended delimiters is a sequence of characters surrounded by quotation marks and a balanced set of one or more number signs (#).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張区切り記号によって区切られる文字列は、引用符そして均衡のとれたひとまとめの１つ以上のシャープ記号（#）によって囲まれる一連の文字です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A string literal is a sequence of characters surrounded by double quotation marks (").</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列リテラルは、二重引用符（"）によって囲まれた一連の文字です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A string literal is a sequence of characters surrounded by quotation marks.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列リテラルは、引用符によって囲まれた一連の文字です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A strong reference cycle can also occur if you assign a closure to a property of a class instance, and the body of that closure captures the instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>強い参照循環はまた、あなたがあるクロージャをクラスインスタンスのプロパティに代入して、そのクロージャの本文がそのインスタンスを捕獲するならば、起こることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A strong reference cycle is created between the two.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>強い参照循環は、２つ作られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A structure or class marked usableFromInline can use only types that are public or usableFromInline for its properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>usableFromInlineで印される構造体またはクラスは、それのプロパティに対してパブリックまたはusableFromInlineである型のみに使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A subclass can implement a superclass designated initializer as a subclass convenience initializer as part of satisfying rule 2.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>サブクラスは、規則２を満たすことの一部として、スーパークラスの指定イニシャライザをサブクラスの便宜イニシャライザとして実装することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A subclass can provide its own custom implementation of an instance method, type method, instance property, type property, or subscript that it would otherwise inherit from a superclass.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>サブクラスは、それ独自のあつらえの実装のインスタンスメソッド、型メソッド、インスタンスプロパティ、型プロパティ、または添え字を提供することができます、それらはそれがそうしなければスーパークラスから継承するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A subclass can’t have a higher access level than its superclass—for example, you can’t write a public subclass of an internal superclass.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>サブクラスには、そのスーパークラスより高いアクセス水準があることができません ― 例えば、あなたは内部のスーパークラスに属する公開のサブクラスを書くことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A subclass inherits its superclass’s deinitializer, which is implicitly called just before the subclass object is deallocated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>サブクラスはそのスーパークラスのデイニシャライザを継承します、それは、サブクラスオブジェクトが割り当て解除される直前に、暗黙のうちに呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A subclass’s implementation of that initializer must also be marked with the required declaration modifier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのイニシャライザのサブクラスでの実装は、また、required宣言修飾子で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A subscript parameter can have a default value, using the syntax described in Special Kinds of Parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字バラメータは省略時の値を持つことができます、特別な種類のパラメータで記述される構文を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A switch statement over a frozen enumeration doesn’t require a default case, as discussed in Switching Over Future Enumeration Cases.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>凍結列挙に対するスイッチ文は、defaultケース節を必要しません、未来列挙ケース節に対してスイッチするで議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A target written in Swift 5.6 can depend on a target that’s written in Swift 4.2 or Swift 4, and vice versa.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Swift 5.6で記述されるターゲットは、Swift 4.2またはSwift 4で記述されるターゲットを頼りにできます、そして逆も同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A throwing function propagates errors that are thrown inside of it to the scope from which it’s called.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スロー関数は、それの内部でスローされるエラーを、そこからそれが呼び出されるスコープへと伝えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A throwing method can’t override a nonthrowing method, and a throwing method can’t satisfy a protocol requirement for a nonthrowing method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スローメソッドは、非スローメソッドをオーバーライドすることができません、そしてスローメソッドは、非スローメソッド用のプロトコル要件を満たすことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A throwing method can’t override a rethrowing method, and a throwing method can’t satisfy a protocol requirement for a rethrowing method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スローメソッドは、再スローメソッドをオーバーライドできません、そしてスローメソッドは再スローメソッド用のプロトコル要件を満たすことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A token consists of an identifier, keyword, punctuation, literal, or operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるトークンは１つの識別子、キーワード、句読点、リテラル、または演算子からなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A tuple expression can contain zero expressions, or it can contain two or more expressions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タプル式はゼロ個の式を含むことができます、またはそれは２つまたはそれ以上の式を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A tuple type’s access level is determined automatically from the types that make up the tuple type, and can’t be specified explicitly.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるタプル型のアクセス水準は、そのタプル型を作り上げる型から自動的に決定されます、したがって明示的に指定されることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A tuple with any types of components</seg>
      </tuv>
      <tuv lang="ja">
        <seg>何らかの型の構成要素をもつタプル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A type alias can forward an existing type’s generic parameters by omitting all generic parameters from the declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型エイリアスは、既存の型の持つ総称体パラメータを、全ての総称体パラメータを宣言から省略することによって、転送できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A type alias can have an access level less than or equal to the access level of the type it aliases.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型エイリアスは、それがエイリアスする型のアクセス水準と同等またはそれより下のアクセス水準を持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A type alias declaration can use generic parameters to give a name to an existing generic type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型エイリアス宣言は、総称体パラメータを使ってある名前を既存の総称体型に与えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A type alias whose underlying type is a protocol composition type, a protocol, or a class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それの基礎をなす型がプロトコル合成型、プロトコル、またはクラスである型エイリアス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A type can conform to a protocol with a lower access level than the type itself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある型は、その型自体よりも低いアクセス水準を持つプロトコルに準拠することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A type inheritance clause begins with a colon (:), followed by a list of type identifiers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型継承節はコロン（:）で始まり、型識別子のリストが続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A type inheritance clause in an enumeration definition can be either a list of protocols, or in the case of an enumeration that assigns raw values to its cases, a single, named type that specifies the type of those raw values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙定義における型継承節は、プロトコルのリスト、または生の値をそれのケース節に割り当てる列挙のケース節においては、それらの生の値を指定する単一の名前付き型、このどちらかであることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A type method can call another type method with the other method’s name, without needing to prefix it with the type name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある型メソッドは、別の型メソッドを他のメソッドの名前を使って呼ぶことができます、その型名をそれの前に置く必要なしに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A type must be hashable in order to be stored in a set—that is, the type must provide a way to compute a hash value for itself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある型は、集合のキー型として使われるためにハッシュ化される必要があります ― すなわち、その型はそれ自身でハッシュ値を計算するためのある方法を提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A type safe language encourages you to be clear about the types of values your code can work with.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型安全な言語は、あなたのコードが扱うことができる値の型について、あなたが確信を持つように促します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A value can be used as an instance of the opaque type only if it’s an instance of a type that conforms to the listed protocol or protocol composition, or inherits from the listed class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>値は、不透明型のインスタンスとして使われることが、それが、そのリストされたプロトコルまたはプロトコル合成に準拠する、またはリストされたクラスから継承するある型のインスタンスである場合にのみ、可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A value of true in the array represents a black square and a value of false represents a white square.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この配列の中のtrueの値は黒の正方形を表します、そしてfalseの値は白い正方形を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A variadic parameter is treated as an array that contains elements of the base type name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>可変長パラメータは、基本の型の名前の要素それらが入っている配列とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A variadic parameter whose array element type is a function type, like ((Bool) -&gt; Int)...</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それの配列要素型が関数型である可変長パラメータ、たとえば((Bool) -&gt; Int)...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A wrapper that needs to expose more information can return an instance of some other data type, or it can return self to expose the instance of the wrapper as its projected value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>さらに情報を露出する必要があるラッパーは、何らかの他のデータ型のインスタンスを返せます、またはそれは、selfを返すことでラッパーのインスタンスをそれの投影値として露出できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>ARC automatically frees up the memory used by class instances when those instances are no longer needed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ARCはクラスインスタンスによって使われるメモリを、それらのインスタンスがもはや必要でないとき、自動的に自由にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>ARC doesn’t deallocate the Person instance until the third and final strong reference is broken, at which point it’s clear that you are no longer using the Person instance:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ARCは、Personインスタンスの割り当て解除を３番目で最後に残ったの強い参照が壊れるまで行いません、その時点では、あなたがもはやPersonインスタンスを使っていないことは明白です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>ARC in Action</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ARCの動作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>ARC will not deallocate an instance as long as at least one active reference to that instance still exists.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ARCは、そのインスタンスへの少なくとも１つの活発な参照がまだ存在する限り、インスタンスの割り当て解除をしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>About Swift</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトについて</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>About the Language Reference</seg>
      </tuv>
      <tuv lang="ja">
        <seg>言語リファレンスについて</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Abstract concepts like Hashable characterize types in terms of their conceptual characteristics, rather than their concrete type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Hashableのような抽象的な概念それらは、それらの概念上の特徴の観点から型を特徴づけます、その具象型そのものではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Access Control</seg>
      </tuv>
      <tuv lang="ja">
        <seg>アクセス制御</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Access Control Levels</seg>
      </tuv>
      <tuv lang="ja">
        <seg>アクセス制御水準</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Access Control Syntax</seg>
      </tuv>
      <tuv lang="ja">
        <seg>アクセス制御構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Access Levels</seg>
      </tuv>
      <tuv lang="ja">
        <seg>アクセス水準</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Access Levels for Frameworks</seg>
      </tuv>
      <tuv lang="ja">
        <seg>フレームワークのためのアクセス水準</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Access Levels for Single-Target Apps</seg>
      </tuv>
      <tuv lang="ja">
        <seg>単一ターゲットアプリのためのアクセス水準</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Access Levels for Unit Test Targets</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ユニットテストターゲットのためのアクセス水準</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Access control is discussed in detail in Access Control.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>アクセス制御は、アクセス制御で詳細に議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Access levels in Swift follow an overall guiding principle: No entity can be defined in terms of another entity that has a lower (more restrictive) access level.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトの中のアクセス水準は、以下の全体的な原理指針に従います：実在は、より低い（制限のより多い）アクセス水準をもつ別の実在の観点から定義されることができない。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Access properties of a class instance with dot (.) syntax, as described in Accessing Properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスインスタンスのプロパティはドット（.）構文でアクセスしてください、プロパティにアクセスするで記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Access to memory happens in your code when you do things like set the value of a variable or pass an argument to a function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メモリへのアクセスは、あなたが変数の値を設定するまたは関数に引数を渡すといったような事を行う時にあなたのコードで起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Access to that member is never inlined or devirtualized by the compiler.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのメンパーに対するアクセスは、決してコンパイラによってインラインまたはデバーチャライズされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Accessing logger.max without writing await fails because the properties of an actor are part of that actor’s isolated local state.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>logger.maxにawaitを書くことなくアクセスすることは失敗します、なぜならアクターのプロパティはそのアクターのもつ隔離されたローカルな状態の一部だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Accessing Enumeration Cases</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙ケース節にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Accessing Properties</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティにアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Accessing Properties Through Optional Chaining</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル連鎖を通してプロパティにアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Accessing Subscripts Through Optional Chaining</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル連鎖を通して添え字にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Accessing Subscripts of Optional Type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル型の添え字にアクセスする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Accessing Superclass Methods, Properties, and Subscripts</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スーパークラスメソッド、プロパティ、そして添え字へのアクセス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Accessing and Modifying a Dictionary</seg>
      </tuv>
      <tuv lang="ja">
        <seg>辞書へのアクセスと変更</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Accessing and Modifying a Set</seg>
      </tuv>
      <tuv lang="ja">
        <seg>集合へのアクセスと変更</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Accessing and Modifying a String</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列へのアクセスと修正</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Accessing and Modifying an Array</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列へのアクセスと変更</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Accessing the original is a simultaneous access of the value, which violates Swift’s memory exclusivity guarantee.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>元のものにアクセスすることは、その値に対する同時的なアクセスです、それはスウィフトのメモリ排他保証を破ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Action</seg>
      </tuv>
      <tuv lang="ja">
        <seg>動作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Actor Declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>アクター宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Actor declarations are declared using the actor keyword and have the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>アクター宣言は、actorキーワードを使用して宣言され、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Actor types can adopt any number of protocols, but can’t inherit from classes, enumerations, structures, or other actors.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>アクター型は、随意の数のプロトコルに準拠することができます、しかしクラス、列挙、構造体、または他のアクターから継承することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Actor-isolated stored properties can be passed as in-out parameters to synchronous functions, but not to asynchronous functions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>アクター隔離された格納プロパティは、in-outパラメータとして同期関数へと渡されることができます、しかし非同期関数へとはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Actors</seg>
      </tuv>
      <tuv lang="ja">
        <seg>アクター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Actors are reference types; instances of an actor are referred to, rather than copied, when assigned to variables or constants, or when passed as arguments to a function call.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>アクターは、参照型です；アクターのインスタンスは、変数または定数に代入されるとき、または引数として関数呼び出しに渡されるときに、コピーされるのではなく、参照されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Actors can also have nonisolated members, whose declarations are marked with the nonisolated keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>アクターはまた、非隔離メンバーを持つことができます、それの宣言はnonisolatedキーワードで印されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Add a color() method to Suit that returns “black” for spades and clubs, and returns “red” for hearts and diamonds.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>color()メソッドをSuitに加えてください、それはスペードとクラブのために「黒」を、そしてハートとダイヤのために「赤」を返すものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Add a constant property with let, and add another method that takes an argument.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数プロパティをletを使って１つ加えてください、そして１つの引数をとる別のメソッドを加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Add a parameter to include today’s lunch special in the greeting.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>今日のスペシャル・ランチをこの挨拶に含めるために、パラメータをひとつ加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Add a third case to ServerResponse and to the switch.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>第３の場合をServerResponseに、そしてスイッチに加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Add an else clause that sets a different greeting if optionalName is nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>optionalNameがnilならば異なる挨拶を設定するelse節を加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Add another requirement to ExampleProtocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>別の要件をExampleProtocolに加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Add code to throw an error inside the do block.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コードを加えてエラーをdoブロック内部でスローしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Add computed instance properties and computed type properties</seg>
      </tuv>
      <tuv lang="ja">
        <seg>計算インスタンスプロパティと計算型プロパティを加える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added #filePath to the Literal Expression section, and updated the discussion of #file.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>#filePathをリテラル式の節に加えました、そして#fileの議論を更新しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added macCatalyst to the list of target environments in Conditional Compilation Block.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>macCatalystをターゲット環境のリストに加えました、条件コンパイルブロックにおいて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added a description of Failable Initializer Requirements for protocols.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティのための失敗できるイニシャライザ要件の説明を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added a full guide to Failable Initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>完全なガイドを失敗できるイニシャライザに加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added a new chapter about Access Control.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>新しい章をアクセス制御について加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added a new guide section about String Indices.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列インデックスについての新しいガイド節を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added a new reference section about Failable Initializers, which can trigger initialization failure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>新しいリファレンス節を失敗できるイニシャライザについて加えました、それは初期化失敗を起こすことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added a new section about Accessing Subscripts of Optional Type through optional chaining.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル連鎖を通してオプショナル型の添え字にアクセスすることについての新しい節を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added a new section about Class-Only Protocols.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラス専用プロトコルについての新しい節を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added a new section about Dictionary Type Shorthand Syntax, which is written as [KeyType: ValueType].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>辞書型の略記構文についての新しい節を加えました、それは[KeyType: ValueType]のように書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added a new section about Hash Values for Set Types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Set型のためのハッシュ値についての新しい節を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added a new section about Initializer Parameters Without Argument Labels.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>引数ラベルなしのイニシャライザ・パラメーターについての新しい節を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added a new section about Initializer Requirements in protocols.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルにイニシャライザ要件についての新しい節を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added a new section about Optional Tuple Return Types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルタプルの戻り型についての新しい節を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added a new section about Required Initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>必須イニシャライザについての新しい節を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added a note about the order in which Prefix and Postfix Operators are applied when both a prefix and a postfix operator are applied to the same operand.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>接頭辞および接尾辞演算子の両方が同じ演算数に適用される時に、接頭辞および接尾辞演算子が適用される順番についての注記を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added a note that the start value a for the Range Operators a...b and a..&lt;b must not be greater than the end value b.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>開始値aは範囲演算子のa...bとa..&lt;bに対して、終了値bより大きくてはならないことの注意を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added a note to the Access Levels section with information about the scope of private access.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>節アクセス水準にprivateアクセスのスコープについての情報の注意書きを加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added a note to the Debugging with Assertions section about when user-defined assertions are disabled.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>表明を使ってデバッグする節に、ユーザ定義の表明が使用不能にされた時についての注を加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added a note to the Handling Errors section about the performance of executing a throw statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>エラーを処理する節にthrow文の実行性能について注意を追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added a note to the Metatype Type section about constructing class instances from metatype values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メタタイプ値からクラスインスタンスを構成することについての注をメタタイプ型節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added a note to the Property Observers section about property observers being called when you pass a property as an in-out parameter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある注意をプロパティオブザーバー節に加えました、あなたがあるプロパティをin-outパラメータとして渡すとき呼び出されているプロパティオブザーバーについて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added a note to the Rethrowing Functions and Methods section that rethrowing functions can’t directly throw errors.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある注意を再スローを行う関数とメソッド節に加えた、それは再スロー関数が直接にエラーをスローできないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added a note to the Type Casting for Any and AnyObject section about using an optional value when a value of type Any is expected.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ひとつの注をAnyおよびAnyObjectに対する型キャストの節へ型Anyの値が期待される時にオプショナル値を使うことについて加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added a note to the Weak References section about the differences in weak references between garbage collected systems and ARC.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>節弱い参照にガベージコレクトシステムとARCとの間の弱い参照における違いについての情報の注意書きを加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added a note to the Weak References section about weak references being unsuitable for caching.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>キャッシュするのにふさわしくない弱い参照についての注を弱い参照節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added a section about error handling to the A Swift Tour chapter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>エラー処理についての節をスウィフトツアー章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added an example of Extending a Generic Type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体型を拡張するの例を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added an example of failable numeric conversions to the Failable Initializers section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>失敗できる数値変換の例を、失敗できるイニシャライザの節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added an example of using multiple optional bindings with a where clause to the Optional Binding section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複数のオプショナル束縛をwhere節とともに使う例をオプショナルの束縛節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added an example that uses the ?? operator to the A Swift Tour chapter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>??演算子を使う例をスウィフトツアー節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added examples of iterating over a range to the For-In Loops section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある範囲のすべてにわたって反復する例をfor-inループの節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about #dsohandle to the Literal Expression section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>#dsohandleについての情報をリテラル式の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about #error and #warning to the Compile-Time Diagnostic Statement section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>#errorと#warningについての情報をコンパイル時診断文の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about API availability checking to the Checking API Availability section of the Control Flow chapter and the Availability Condition section of the Statements chapter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>API有効性確認についての情報を節API有効性の確認に章制御の流れで、そして節有効性条件に章文で追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about access control for unit testing to the Access Levels for Unit Test Targets section of the Access Control chapter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ユニットテストのためのアクセス制御についての情報をユニットテストターゲットのためのアクセス水準の節にアクセス制御の章で追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about accessing all of an enumeration’s cases to the Iterating over Enumeration Cases section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙の持つケース節の全てにアクセスすることについての情報を列挙ケース節の全てにわたって反復するの節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about accessing the selector of an Objective-C property’s getter or setter to the Selector Expression section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Objective-Cプロパティのゲッターやセッターのセレクタにアクセスすることについての情報をセレクタ式の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about asynchronous functions, tasks, and actors to the Concurrency chapter, and to the Actor Declaration, Asynchronous Functions and Methods, and Await Operator sections.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非同期の関数、タスク、アクターについての情報を並行性の章に、およびアクター宣言、非同期の関数とメソッド、そして待機演算子の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about build configuration and line control statements to the Compiler Control Statements section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ビルド設定および行制御文についての情報をコンパイラ制御文節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about comparing tuples to the Comparison Operators section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タプルの比較についての情報を比較演算子節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about conditional protocol conformance to the Extension Declaration section of the Declarations chapter, and to the Conditionally Conforming to a Protocol section of the Protocols chapter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>条件プロトコル準拠についての情報を拡張宣言の節に宣言章で、そしてあるプロトコルに条件付きで準拠するの節にプロトコル章で加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about dynamic members that are looked up by key path at runtime to the dynamicMemberLookup section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>実行時にキーパスによって検索される動的メンバーについての情報をdynamicMemberLookupの節に加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about enumerations and structures that are frozen for library evolution to the frozen section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ライブラリ進化に対して凍結される列挙と構造体についての情報をfrozenの節に加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about error handling to the Error Handling chapter, the Do Statement section, the Throw Statement section, the Defer Statement section, and the Try Operator section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>エラー処理についての情報を章エラー処理、節do文、節throw文、節defer文、そして節try演算子に追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about exclusive access to memory to the Memory Safety chapter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メモリに対する排他アクセスについての情報をメモリ安全の章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about explicitly referencing an initializer to the Initializer Expression section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>明示的にあるイニシャライザを参照することについての情報をイニシャライザ式節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about functions that specify a protocol that their return value conforms to, instead of providing a specific named return type, to the Opaque Types chapter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある指定された名前付き戻り型を提供する代わりに、それらの戻り値が準拠するあるプロトコルを指定する関数それらについての情報を不透明型の章へ加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about how to conditionally compile code depending on the Swift compiler version being used to the Conditional Compilation Block section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>使われているスウィフトコンパイラバージョンに基づいて条件付きでコードをコンパイルする方法についての情報を条件コンパイルブロックの節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about how to conditionally compile code depending on the version of Swift being used to the Conditional Compilation Block section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>使われているスウィフトのバージョンに基づいて条件付きでコードをコンパイルする方法についての情報を条件コンパイルブロック節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about how to distinguish between methods or initializers whose names differ only by the names of their arguments to the Explicit Member Expression section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらの名前がそれらの引数の名前でだけ異なるところのメソッド間またはイニシャライザ間で区別をする方法についての情報を明示的メンバー式節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about how type inference works with Literals.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型推論がリテラルで働く方法についての情報を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about inlining to the Declaration Attributes section under the inlinable and usableFromInline attributes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>インラインについての情報を宣言属性の節にinlinableとusableFromInline属性の下で加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about members that are looked up by name at runtime to the Declaration Attributes section under the dynamicMemberLookup attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>実行時に名前によって捜されるメンバについての情報を宣言属性の節にdynamicMemberLookup属性の下で加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about multiline string literals to the String Literals section of the Strings and Characters chapter, and to the String Literals section of the Lexical Structure chapter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複数行文字列リテラルについての情報を文字列リテラルの節へ文字列と文字の章で、そして文字列リテラルの節へ語彙の構造の章で加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about multiple trailing closures to the Trailing Closures section, and added information about how trailing closures are matched to parameters to the Function Call Expression section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複数の後付クロージャについての情報を後付クロージャの節に加えました、そしてどのように後付クロージャがパラメータそれらと組み合わされるかについての情報を関数呼び出し式の節に加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about operator precedence groups to the Precedence for Custom Infix Operators section of the Advanced Operators chapter, and to the Precedence Group Declaration section of the Declarations chapter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>演算子優先順位グループについての情報をあつらえの演算子に対する優先順位の節に先進の演算子の章で、そして優先順位グループ定義の節に宣言の章で加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about passing a key path instead of a closure to the Key-Path Expression section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>キーパスをクロージャの代わりに渡すことについての情報をキーパス式の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about playground literals to the Literal Expression section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プレイグラウンドリテラルについての情報をリテラル式の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about preconditions and fatal errors to the Assertions and Preconditions section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>前提条件と致命的なエラーについての情報を表明と前提条件の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about property wrappers to the Property Wrappers section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティラッパーについての情報をプロパティラッパーの節に加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about protocol extensions to the Protocol Extensions section of the Protocols chapter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル拡張についての情報をプロトコル拡張の節にプロトコルの章で追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about recursive enumerations to the Recursive Enumerations section of the Enumerations chapter and the Enumerations with Cases of Any Type section of the Declarations chapter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>再帰列挙についての情報を再帰列挙節に列挙章で、そして随意の型のケース節をもつ列挙節に宣言章で加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about recursive protocol constraints to the Using a Protocol in Its Associated Type’s Constraints section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>再帰的プロトコル制約についての情報をあるプロトコルをその関連型のもつ制約において使用するの節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about switch cases that have multiple patterns to the Switch section of the Control Flow chapter and the Switch Statement section of the Statements chapter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複数のパターンを持つスイッチケース節についての情報を、節スイッチに章制御の流れで、そして節スイッチ文に章文で加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about synthesized implementations of Comparable for enumerations to the Adopting a Protocol Using a Synthesized Implementation section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙に対するComparableの合成実装についての情報をプロトコルを合成実装を使って採用するの節に加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about synthesized implementations of equivalence operators to the Equivalence Operators section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>等価演算子の合成実装についての情報を等価演算子の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about the #selector syntax for Objective-C selectors to the Selector Expression section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Objective-Cセレクタのための#selector構文についての情報をセレクタ式節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about the @GKInspectable attribute to the Declaration Attributes section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>@GKInspectable属性についての情報を宣言属性節に加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about the @autoclosure attribute—including its @autoclosure(escaping) form—to the Autoclosures section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>@autoclosure属性についての情報を ― それの@autoclosure(escaping)形式を含めて ― 自動クロージャ節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about the @main attribute to the main section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>@main属性についての情報をmainの節に加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about the availability attribute to the Declaration Attributes section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>availability属性についての情報を宣言属性節に加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about the canImport() and targetEnvironment() platform conditions to Conditional Compilation Block.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>canImport()およびtargetEnvironment()プラットホーム条件についての情報を条件コンパイルブロックに加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about the dynamic declaration modifier in Declaration Modifiers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>宣言修飾子においてdynamic宣言修飾子についての情報を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about the open and fileprivate access-level modifiers to the Access Control chapter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>openおよびfileprivateアクセス水準修飾子についての情報をアクセス制御の章に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about the requires_stored_property_inits and warn_unqualified_access attributes to the Declaration Attributes section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>requires_stored_property_initsとwarn_unqualified_access属性についての情報を属性宣言の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about the unowned, unowned(safe), and unowned(unsafe) declaration modifiers in the Declaration Modifiers section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>unowned、unowned(safe)、そしてunowned(unsafe)宣言修飾子についての情報を宣言修飾子の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about the behavior of enumeration cases with String raw values to the Implicitly Assigned Raw Values section of the Enumerations chapter and the Enumerations with Cases of a Raw-Value Type section of the Declarations chapter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Stringの生の値を持つ列挙ケース節の挙動についての情報を暗黙的に割り当てられる生の値節に列挙章でそして「生の値」型のケース節を持つ列挙節に宣言章で追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about the behavior of in-out parameters to the In-Out Parameters section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>in-outパラメータの挙動についての情報をin-outパラメータ節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about the identity key path (\.self) to the Key-Path Expression section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同一性キーパス（\.self）についての情報をキーパス式の節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about the new guard statement to the Early Exit section of the Control Flow chapter and the Guard Statement section of the Statements chapter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>新しいguard文についての情報を節早期退出に章制御の流れで、そして節guard文に章文で追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about the new try? keyword to the Converting Errors to Optional Values section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>新しいtry?キーワードについての情報をエラーをオプショナルの値に変換する節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about the new Swift standard library print(_:separator:terminator) function to the Printing Constants and Variables section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>新しいスウィフト標準ライブラリprint(_:separator:terminator)関数についての情報を定数と変数を出力する節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about the new optional pattern to the Optional Pattern section of the Patterns chapter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>新しいオプショナルパターンについての情報を節オプショナルパターンに章パターンで追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about throwing an error inside the catch block of a rethrowing function to the Rethrowing Functions and Methods section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>再スロー関数のcatchブロック内部でエラーをスローすることについての情報を、節再スローを行う関数とメソッドに加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about using enumeration cases as functions to the Enumerations with Cases of Any Type section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙ケース節を関数として使うことについての情報を随意の型のケース節をもつ列挙節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about using keywords as external parameter names to the Keywords and Punctuation section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>キーワードを外部パラメータ名として使うことについての情報をキーワードと句読点節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about using subscripts on types to the Type Subscripts section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型の上で添え字を使うことについての情報を型添え字の節に加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information about using the less than (&lt;) operator in platform conditions to the Conditional Compilation Block section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>より小さい（&lt;）演算子をプラットホーム条件において使うことについての情報を条件コンパイルブロックの節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information to the Capture Lists section about how values specified in closure capture lists are captured.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>どのようにクロージャキャプチャリストにおいて指定された値がキャプチャされるかについて情報をキャプチャリスト節に加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information to the Declaration Attributes section about using the available attribute with a Swift language version.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>宣言属性節に、スウィフト言語版でのavailable属性を使うことについて情報を加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information to the Metatype Type section about comparing metatype values and using them to construct instances with initializer expressions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メタタイプ型節に、メタタイプ値の比較と、それらをインスタンスを作り上げるためにイニシャライザ式とともに使う事についての情報を加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information to the Overriding a Failable Initializer section about how a nonfailable initializer can delegate up to a failable initializer by force-unwrapping the result of the superclass’s initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>失敗できるイニシャライザのオーバーライド節に失敗できないイニシャライザが失敗できるイニシャライザにまで委任することを、スーパークラスのイニシャライザの結果を強制アンラップすることでできる方法についての情報を加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information to the String Literals section about how concatenating string literals using the + operator happens at compile time.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列リテラル節に、どのように+演算子を使った文字列リテラルの連結がコンパイル時に起こるかについての情報を加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added information to the Type Alias Declaration section about generic type aliases and using type aliases inside of protocols.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>情報を型エイリアス宣言の節に加えた、プロトコルの内部での総称体型エイリアスと型エイリアス利用について。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added more information about Any and moved it into the new Any Type section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Anyについてのさらなる情報を加えて、そしてそれを新しいAny型節へと移動しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added more information about curried functions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>カリー化関数についての更なる情報を加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added similar information about the do statement in the Do Statement section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>do文について同様の情報をdo文の節において追加した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added the Associated Types with a Generic Where Clause section, now that you can use generic where clauses to constrain associated types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体where節を持つ関連型の節を加えた、今ではあなたは総称体where節を使って関連型を制約できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added the Contextual Where Clauses section now that you can write a generic where clause in more places.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文脈where節の節を加えました、今ではあなたは総称体where節をより多くの場所で書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added the Escaping Closures section with information about the @noescape attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>脱出クロージャの節を@noescape属性についての情報とともに加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added the Extended String Delimiters section and updated the String Literals section with information about extended string delimiters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張文字列区切り記号の節を加えて文字列リテラルの節を拡張文字列区切り記号についての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added the Extensions with a Generic Where Clause section with information about extensions that include requirements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体where節を持つ拡張の節を、要件を含む拡張についての情報とともに加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added the Functions With an Implicit Return and Shorthand Getter Declaration sections with information about functions that omit return.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>暗黙的returnを持つ関数と 略記ゲッター宣言の節をreturnを省略する関数についての情報とともに加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added the Generic Subscripts section, now that subscripts can be generic.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体添え字の節を追加した、今では添え字は総称体にできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added the Implicit Conversion to a Pointer Type section with information about how in-out parameters can be implicitly converted to unsafe pointers in a function call.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ポインタ型への暗黙的変換の節を、どのようにインアウトパラメータは暗黙的にアンセーフポインタへとある関数呼び出しにおいて変換され得るかについての情報とともに加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added the Methods with Special Names section with information about syntactic sugar the lets instances of classes, structures, and enumerations be used with function call syntax.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>特殊名を持つメソッドの節を、クラス、構造体、そして列挙のインスタンスが関数呼び出し構文で使われるようにする構文糖についての情報とともに加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added the Result Builders and resultBuilder sections with information about result builders.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>リザルトビルダーとresultBuilderの節をリザルトビルダーについての情報とともに加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added the Unowned Optional References section with information about using unowned references with optional values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非所有オプショナル参照の節を非所有参照をオプショナル値と共に使うことについての情報と共に加えました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added the dynamicCallable section with information about dynamically calling instances as functions using the dynamicCallable attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg> dynamicCallableの節を、動的にインスタンスを関数としてdynamicCallable属性を使って呼び出すことについての情報とともに加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Added the unknown and Switching Over Future Enumeration Cases sections with information about handling future enumeration cases in switch statements using the unknown switch case attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>unknownと未来列挙ケース節にわたってスイッチするの節をスイッチ文において未来列挙ケース節をunknownスイッチケース節属性を使って取り扱うことについての情報とともに加えた。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Adding Constraints to Protocol Extensions</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル拡張に制約を加える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Adding Constraints to an Associated Type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関連型に制約を加える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Adding Protocol Conformance with an Extension</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張を使ってプロトコル準拠を加える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Adding protocol conformance in this way is described in Adding Protocol Conformance with an Extension.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この方法でプロトコル準拠を加えることは拡張を使ってプロトコル準拠を加えるで記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Addition (+)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>加算（+）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Additionally, although operators can contain an exclamation point (!), postfix operators can’t begin with either a question mark or an exclamation point.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それに加えて、演算子は感嘆符（!）を含むことができますが、接尾辞演算子は、疑問符または感嘆符のどちらかで始まることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Additionally, when an instance is no longer needed, ARC frees up the memory used by that instance so that the memory can be used for other purposes instead.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その上に、インスタンスがもはや必要でないとき、ARCはそのインスタンスによって使われるメモリを開放します、それでメモリが代わりに他の目的のために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Adopting a Protocol Using a Synthesized Implementation</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルを合成実装を使って採用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Advanced Operators</seg>
      </tuv>
      <tuv lang="ja">
        <seg>先進の演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>After downloadPhoto(named:) returns, its return value is assigned to photo and then passed as an argument when calling show(_:).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>downloadPhoto(named:)が返った後、それの戻り値はphotoに割り当てられます、そしてそれから引数としてshow(_:)を呼び出す時に渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>After listPhotos(inGallery:) returns, this code continues execution starting at that point.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>listPhotos(inGallery:)が返った後、このコードはその地点で開始して遂行を続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>After a type alias is declared, the aliased name can be used instead of the existing type everywhere in your program.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型エイリアスが宣言されたあと、エイリアス（別名）にされた名前は、あなたのプログラムの至る所で既存の型の代わりに使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>After applying the provided closure to each array element, the map(_:) method returns a new array containing all of the new mapped values, in the same order as their corresponding values in the original array.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>提供されたクロージャを各配列要素に適用した後に、map(_:)メソッドは、新しい対応付けられる値の全てを、もとの配列のそれらの対応する値と同じ順序で含んでいる新しい配列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>After calling increment(forCount:), the optional Int that it returns is unwrapped into a constant called amount, using optional binding.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>increment(forCount:)呼び出しの後、それが返すオプショナルのIntは、オプショナル束縛を使って、amountと呼ばれる定数へとアンラップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>After calling super.init(), the original value of numberOfWheels is replaced with a new value of 2.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>super.init()の呼び出しの後、numberOfWheelsのもとの値は新しい値の2で置き換えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>After capturing these values, incrementer is returned by makeIncrementer as a closure that increments runningTotal by amount each time it’s called.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの値を捕獲した後に、incrementerはmakeIncrementerによって、それが呼ばれるたびにrunningTotalをamountによって増加させるクロージャとして返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>After creating the dictionary, this example uses subscript assignment to add a String key of "bird" and an Int value of 2 to the dictionary.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>辞書を作成した後に、この例は、辞書にStringキーの"bird"とInt値の2を加えるために添え字代入を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>After declaring a new operator, you implement it by declaring a static method that has the same name as the operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある新しい演算子を宣言した後に、あなたはその演算子と同じ名前を持つ静的メソッドを宣言することによってそれを実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>After defining this extension, you can call the repetitions(task:) method on any integer to perform a task that many number of times:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この拡張を定義した後、あなたはrepetitions(task:)メソッドをあらゆる整数上で呼び出して、ある作業をそれだけ多くの回数実行できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>After defining this extension, you can use any Array as a Container.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この拡張を定義した後に、あなたはどんなArrayでもContainerとして使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>After doing so, the initializer delegates up to the init(name: String) initializer of the Food class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そうした後に、イニシャライザは上ってFoodクラスのinit(name: String)イニシャライザに委任します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>After executing the code inside the switch case that matched, the program exits from the switch statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>合致したスイッチのケース節（case、場合、事例）の内部のコードを実行した後に、プログラムはスイッチ文から出ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>After finding a match, scanning continues with the next trailing closure and the next parameter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある合致を見つけた後、走査は、次の後付クロージャと次のパラメータで継続します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>After making this check, the function iterates over all of the items in someContainer with a for-in loop and the half-open range operator (..&lt;).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この確認の後、関数はsomeContainerの項目の全てに渡ってfor-inループと半開範囲演算子（..&lt;）を使って繰り返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>After popping a value, the stack once again holds three values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>値をポップした後では、スタックは再び３つの値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>After rolling the dice, the player moves forward by diceRoll squares.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>さいころを転がした後、プレーヤーは正方形をdiceRoll分だけ前進します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>After storing a small number like four, the value of someStructure.$someNumber is false.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>４のような小さい値を格納後、someStructure.$someNumberの値はfalseです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>After the switch statement completes its execution, the example uses optional binding to determine whether a value was found.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>switch文がその実行を完了したあと、この例は値が見つけられたかどうか決定するためにオプショナル束縛を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>After the switch statement has finished executing, the number’s description is printed using the print(_:separator:terminator:) function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>switch文が実行を終えたあと、その数の解説はprint(_:separator:terminator:)関数を使用して出力されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>After the array is created, the name of the ShoppingListItem at the start of the array is changed from "[Unnamed]" to "Orange juice" and it’s marked as having been purchased.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列がつくられたあと、配列の始めのShoppingListItemの名前は、"[Unnamed]"から"Orange juice"へ変えられます、そしてそれは購入済みとして印されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>After the code checks for snakes and ladders, the dice is rolled and the player is moved forward by diceRoll squares.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コードがヘビとはしごについて調べた後、さいころが振られてプレーヤーはdiceRollだけの正方形を前進させられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>After the code within a matched case has finished executing, the program exits from the switch statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>マッチされたケース節内のコードが実行を終えたあと、プログラムはswitch文から出ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>After the first character, combining Unicode characters are also allowed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初の文字の後は、合成ユニコード文字もまた許されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>After the first character, digits and combining Unicode characters are also allowed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初の文字の後は、桁および合成Unicode文字もまた、許されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>After the statement is executed, the value of index is updated to contain the second value in the range (2), and the print(_:separator:terminator:) function is called again.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文が実行されたあと、indexの値は範囲の２番目の値（2）を含むように更新されます、そしてprint(_:separator:terminator:)関数が再び呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>After the temporary constants are declared, they can be used within the case’s code block.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>一時的な定数が宣言された後、それらはケース節のもつコードのかたまり内で使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>After this happens, there are no more strong references to the CreditCard instance, and it too is deallocated:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これが起こったあと、CreditCardインスタンスへの強い参照はもうありません、そして、それも割り当て解除されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Again, the first three codeUnit values (68, 111, 103) represent the characters D, o, and g, whose UTF-16 code units have the same values as in the string’s UTF-8 representation (because these Unicode scalars represent ASCII characters).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>再び、最初の３つのcodeUnit値（68、111、103）は文字D、o、そしてgを表します、これらのUTF-16符号単位はこの文字列のUTF-８叙述の場合と同じ値を持ちます（なぜなら、これらのユニコード・スカラーがASCII文字を表わすからです）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All addition and subtraction for signed integers is performed in bitwise fashion, with the sign bit included as part of the numbers being added or subtracted, as described in Bitwise Left and Right Shift Operators.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>符号つき整数に対する全ての加算と減算は、ビット単位の左および右シフト演算子で記述されるように、加算または減算される数の一部として含めらる符号ビットとともに、ビット単位流儀で実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All asynchronous code runs as part of some task.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>全ての非同期コードは、あるタスクの一部として動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All classes implicitly conform to AnyObject.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>全てのクラスは、暗黙的にAnyObjectに準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All entities in your code (with a few specific exceptions, as described later in this chapter) have a default access level of internal if you don’t specify an explicit access level yourself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたのコードの中の全ての実在は（この章の後刻に記述されるように、２、３の特定の例外を除いて）、あなたが明示的に独自にアクセス水準を指定しないならば、省略時のアクセス水準である内部を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All game logic is moved into the protocol’s play method, which uses the protocol’s required dice property to provide its dice roll values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>全てのゲーム論理は、プロトコルのplayメソッドに引っ越します、それは、プロトコルの要求するdiceプロパティを使ってそれのさいころ振りの値を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All information about the property—including its name, type, and memory management characteristics—is defined in a single location as part of the type’s definition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティに関する全ての情報は ― その名前、型、そしてメモリ管理などの特徴を含めて ― その型の定義の一部として１つの場所で定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All is not lost, however.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、道がないわけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All of Swift’s basic types (such as String, Int, Double, and Bool) are hashable by default, and can be used as set value types or dictionary key types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトの基本の型の全て（String、Int、Double、そしてBoolなど）は、特に何もしなくてもハッシュ化されます、そして集合の値型または辞書のキー型として使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All of Swift’s basic types (such as String, Int, Double, and Bool) are hashable by default.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトの基本の型（例えばString、Int、Double、そしてBool）の全ては、初期状態でハッシュ化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All of Swift’s standard types automatically support the Equatable protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトの標準の型の全ては、自動的にEquatableプロトコルをサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All of a class’s stored properties—including any properties the class inherits from its superclass—must be assigned an initial value during initialization.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるクラスの全ての格納プロパティは ― そのクラスがそれのスーパークラスから継承するあらゆるプロパティを含めて ― 初期化の間に初期値を代入される必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All of the functions you have encountered so far in this chapter have been examples of global functions, which are defined at a global scope.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがこの章においてこれまで遭遇した関数の全てはグローバルな関数の例でした、そしてそれは、グローバルなスコープで定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All of the game’s levels (apart from level one) are locked when the game is first played.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ゲームが最初にプレイされるとき、ゲームのレベルの全ては鍵をかけられます（レベル１は別として）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All of the other bits in firstBits and otherBits match and are set to 0 in the output value:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>firstBitsとotherBitsでの他の全てのビットは一致していて、出力値において0に設定されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All of the patterns of a compound case have to include the same set of value bindings, and each binding has to get a value of the same type from all of the patterns in the compound case.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある複合ケース節のパターンのすべては、同じひとそろいの値束縛を含まなければなりません、そしてそれぞれの束縛は同じ型の値をその複合ケース節のパターンのすべてから得なければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All of these floating-point literals have a decimal value of 12.1875:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の浮動小数点リテラルの全ては、10進の値で12.1875を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All of these integer literals have a decimal value of 17:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>次の整数リテラルの全ては、10進の値で17を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All of these overflow operators begin with an ampersand (&amp;).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらのオーバフロー演算子の全ては、アンパサンド（&amp;）から始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All of this information is rolled up into the function’s definition, which is prefixed with the func keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この情報の全ては、funcキーワードを前に置かれる、関数の定義にまとめ上げられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All of this means that you can create the Country and City instances in a single statement, without creating a strong reference cycle, and the capitalCity property can be accessed directly, without needing to use an exclamation point to unwrap its optional value:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これの全ては、あなたがCountryとCityインスタンスを１つの文において、強い参照循環をつくることなく作成できることを意味します、そして、capitalCityプロパティはそのオプショナルの値をアンラップするために感嘆符を使う必要なしに直接にアクセスされることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All options you can use with string interpolation are described in String Interpolation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが文字列補間で使うことができるオプション全ては、「文字列補間」で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All parameters must have unique names.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>すべてのパラメーターは、特有な名前を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All structures and enumerations are value types in Swift.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>全ての構造体と列挙は、スウィフトでは値型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All structures have an automatically generated memberwise initializer, which you can use to initialize the member properties of new structure instances.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>全ての構造体は自動的に生成されるメンバー関連イニシャライザを持ちます、それはあなたが新しい構造体インスタンスのメンバープロパティを初期化するために使うことが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All three of these initializers can be used to create new RecipeIngredient instances:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらのイニシャライザの３つ全てが、新しいRecipeIngredientインスタンスを作るために使用されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All tuple types contain two or more types, except for Void which is a type alias for the empty tuple type, ().</seg>
      </tuv>
      <tuv lang="ja">
        <seg>すべてのタプル型は２つまたはそれ以上の型を含みます、しかし空のタプル型、()に対する型エイリアスであるVoidを除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Also clarified the assignment and copy behavior for strings arrays and dictionaries.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>また「文字列、配列、および辞書のための代入およびコピーの挙動」がわかりやすくされました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Alternative grammar productions are separated by vertical bars (|).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>代替の文法導出は、垂直バー（|）で区別されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Alternatively, a type that conforms to SuffixableContainer can have a Suffix type that’s different from itself—meaning the suffix operation can return a different type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるいはまた、SuffixableContainerに準拠する型は、それ自身とは異なるSuffix型を持つことができます—suffix演算は異なる型を返すことができることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Alternatively, access a String value in one of three other Unicode-compliant representations:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるいは代わりに、３つの他のUnicode対応の表現の１つでString値にアクセスしてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Alternatively, access the individual element values in a tuple using index numbers starting at zero:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるいは、ゼロから始まっているインデックス番号を使ってタプルの個々の要素の値にアクセスしてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Alternatively, all items in a set can be removed with its removeAll() method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるいはまた、集合の全ての項目はremoveAll()メソッドを使って取り除かれることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Alternatively, append an array of one or more compatible items with the addition assignment operator (+=):</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるいはまた、互換性を持つ１つ以上の項目からなる配列を、追加代入演算子（+=）を使って加えることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Alternatively, enumeration cases can specify associated values of any type to be stored along with each different case value, much as unions or variants do in other languages.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>代わりに、列挙ケース節は、ほとんど他の言語における共用体型やバリアント型がするように、それぞれ異なるケース節の値と一緒に格納されるために、あらゆる型の関連値を指定することが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Alternatively, if the context already provides type information, such as a function argument or an already typed variable or constant, you can create an empty array with an empty array literal, which is written as [] (an empty pair of square brackets):</seg>
      </tuv>
      <tuv lang="ja">
        <seg>代わりに、前後関係がすでに型の情報を、例えば関数の引数またはすでに型指定された変数や定数などを提供するならば、あなたは空の配列を空の配列リテラル、[]（１対の空の角括弧）のように書かれるものでつくることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Alternatively, if the context already provides type information, such as a function argument or an already typed variable or constant, you can create an empty set with an empty array literal:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるいはまた、関数の引数や既に型付けされた変数や定数のように、文脈がすでに型情報を提供するならば、あなたは空の集合を空の配列リテラルで作成することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Alternatively, remove a key-value pair from a dictionary with the removeValue(forKey:) method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるいは代わりに、removeValue(forKey:)メソッドで辞書から「キーと値」の対を削除してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Alternatively, specify a default property value as part of the property’s declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その代わりの方法として、省略時のプロパティ値をそのプロパティの宣言の一部として指定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Alternatively, use the underscore character (_), also known as the wildcard pattern, to match any possible value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるいはまた、起こりうるどんな値にもマッチするにはアンダースコア文字（_）、またワイルドカードパターンとして知られるもの、を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Alternatively, you can create a stand-alone Character constant or variable from a single-character string literal by providing a Character type annotation:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるいは、あなたは１文字だけの文字列リテラルから単独のCharacter定数または変数を作成することが、Character型注釈を提供することによって可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Alternatively, you can define a failable initializer that creates an implicitly unwrapped optional instance of the appropriate type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>またはその代わりに、あなたは適切な型の暗黙的にアンラップされるオプショナルのインスタンスを作成する失敗できるイニシャライザを定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Alternatively, you can mark an extension with an explicit access-level modifier (for example, private) to set a new default access level for all members defined within the extension.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>代わりに、あなたは拡張に明確なアクセス水準修飾子（例えばprivate）で印して、新しい省略時のアクセス水準をその拡張内で定義される全てのメンバーに設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Alternatively, you can override a superclass failable initializer with a subclass nonfailable initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>または代わりに、あなたはスーパークラスの失敗できるイニシャライザをサブクラスの失敗できないイニシャライザでオーバーライドできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although break isn’t required in Swift, you can use a break statement to match and ignore a particular case or to break out of a matched case before that case has completed its execution.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>breakはスウィフトでは必要とされないけれども、あなたはbreak文を特定のケース節を適合してから無視するために、または適合したケース節をそのケース節がそれの実行を完了してしまう前に抜け出すために使うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although both functions have names that begin with greet, the greet(person:alreadyGreeted:) function takes two arguments but the greet(person:) function takes only one.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>両方の関数がgreetで始まる名前を持つとはいえ、greet(person:alreadyGreeted:)関数は２つの引数を取りますがgreet(person:)関数はただ１つだけ取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although conforming types don’t have to provide their own implementation of either, requirements with default implementations can be called without optional chaining.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>どちらにおいても準拠する型がそれ自身の実装を提供しなくても良いけれども、省略時の実装を持つ要件はオプショナル連鎖なしに呼ばれることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although either inlinable or usableFromInline can be applied to internal declarations, applying both attributes is an error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>けれどもinlinableまたはusableFromInlineのどちらかは、internal宣言に適用できます、両方の属性を適用することはエラーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although it’s common for all of the chained postfix expressions to have the same type, the only requirement is that the whole chained implicit member expression needs to be convertible to the type implied by its context.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>連鎖にされた接尾辞式の全てが同じ型を持つのが普通であるとはいえ、唯一の要件は、連鎖暗黙的メンバー式の全体がそれの文脈によってほのめかされた型へと変換可能でなければならないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although it’s common to define individual types in separate source files, a single source file can contain definitions for multiple types, functions, and so on.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>通常は個々の型を別々のソースファイルに定義しますが、単一のソースファイルは、複数の型、関数、その他の定義を含むことが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although it’s not specified as part of the protocol, it’s assumed that this value will be a number from 0.0 up to (but not including) 1.0.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それはプロトコルの一部として指定されないけれども、この値は0.0から1.0まで（しかし含めてではない）のある数であるのを仮定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although it’s possible for multiple parameters to have the same argument label, unique argument labels help make your code more readable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複数のパラメータが同じ引数ラベルを持つことは可能であるとは言え、特有な引数ラベルはあなたのコードをより読みやすくする助けとなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although it’s possible to write concurrent code without using Swift’s language support, that code tends to be harder to read.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>並行性コードをスウィフトのもつ言語サポートを使うことなく書くことは可能であるとはいえ、そのコードは読むのがより困難になりがちです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although properties and methods declared in the superclass are inherited by the current class, designated initializers declared in the superclass are only inherited when the subclass meets the conditions described in Automatic Initializer Inheritance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スーパークラスの中で宣言されるプロパティやメソッドは現在のクラスによって継承されるけれども、スーパークラスの中で宣言される指定イニシャライザはただサブクラスが自動的なイニシャライザ継承で記述される条件と出会う場合に継承されるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although technically allowed, this wouldn’t make for a very good data source.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>技術的には可能であるけれども、これはあまり良いデータ・ソースにつながりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although the method name and the property name are expressions, they’re never evaluated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>method name（メソッド名）とproperty name（プロパティ名）は式であるけれども、それらは決して評価されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although the property name is an expression, it’s never evaluated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>property name（プロパティ名）は式であるけれども、それは決して評価されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although the actual execution order of pattern-matching operations, and in particular the evaluation order of patterns in cases, is unspecified, pattern matching in a switch statement behaves as if the evaluation is performed in source order—that is, the order in which they appear in source code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>けれどもパターンマッチ操作の実際の実行順序、とりわけケース節の中のパターンの評価順序は指定されません、switch文のパターンマッチングはまるでその評価がソース順 ― すなわち、それらがソース・コードにおいて現れる順番、で実行されるかのようにふるまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although the generic where clause provides syntactic sugar for expressing simple constraints on type parameters (for example, &lt;T: Comparable&gt; is equivalent to &lt;T&gt; where T: Comparable and so on), you can use it to provide more complex constraints on type parameters and their associated types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体where節は、型パラメータ上で単純な制約を表すために糖衣構文を提供しますが（例えば、&lt;T: Comparable&gt;は&lt;T&gt; where T: Comparableに等しいなどなど）、あなたはそれを使ってより複雑な制約を型パラメータとそれの関連型に提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although the indexes used to access the elements can be of any type, each parameter must include a type annotation to specify the type of each index.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>要素にアクセスするために使用されるインデックスは、どんな型でも可能であるけれども、各パラメータは型注釈を含んで、各インデックスの型を指定しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although the rest of its functionality isn’t shown, the purpose of this DataManager class is to manage and provide access to this array of String data.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その機能性の残りの部分は示されないけれども、このDataManagerクラスの目的はこのStringデータの配列を管理して、アクセス提供することになっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although the transformation behavior is described in terms of temporary variables, using a result builder doesn’t actually create any new declarations that are visible from the rest of your code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>変換挙動は一時的な変数それらに基づいて記述されるとはいえ、リザルトビルダーを使うことは、あなたのコードの残りから可視であるどんな新しい宣言も実際は作成しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although the two forms are functionally equivalent, the shorthand form is preferred whenever possible.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２つの書式は機能的に等しいですが、可能であればいつでも略記書式が好ましいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although the two forms are functionally identical, the shorthand form is preferred and is used throughout this guide when referring to the type of a dictionary.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２つの書式は機能的に同一であるけれども、短縮形がむしろ好まれ、このガイドを通して辞書の型に言及するときに使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although the two forms are functionally identical, the shorthand form is preferred and is used throughout this guide when referring to the type of an array.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２つの書式は機能的に同一であるけれども、短縮形がむしろ好まれ、このガイドを通して配列の型に言及するとき使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although the unary plus operator doesn’t actually do anything, you can use it to provide symmetry in your code for positive numbers when also using the unary minus operator for negative numbers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>単項プラス演算子は実際に何もしないけれども、あなたは、負の数に単項マイナス演算子を使うときに、正の数に対してもまたあなたのコードで釣り合いを取るためにそれを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although these types, functions, and operators aren’t part of the Swift language itself, they’re used extensively in the discussions and code examples in this part of the book.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの型、関数、そして演算子は、スウィフト言語自身の一部ではないけれども、それらは本のこの部分の議論とコード例で広く使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although they’re implemented as computed properties, the names of these properties can be appended to a floating-point literal value with dot syntax, as a way to use that literal value to perform distance conversions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらは計算プロパティとして実装されるけれども、これらのプロパティの名前はある浮動小数点リテラル値に、そのリテラル値を距離変換を実行するために使う方法として、ドット構文で追加されることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although you can define custom operators that contain a question mark (?), they can’t consist of a single question mark character only.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは疑問符（?）を含むあつらえの演算子を定義できるけれども、それは単一の疑問符文字だけから構成されることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although you can query the current value of the numberOfEdits property from within another source file, you can’t modify the property from another source file.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは別のソースファイル内からnumberOfEditsプロパティの現在の値についてたずねることができるけれども、あなたは別のソースファイルからこのプロパティを修正できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although you don’t call these methods in your own code, showing the result of the transformation makes it easier to see how Swift transforms your code when you use the DrawingBuilder syntax.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがそれらのメソッドをあなた自身のコードにおいて呼び出さないとはいえ、変換の結果を見せることは、どのようにスウィフトがあなたのコードをあなたがDrawingBuilder構文を使う時に変換するかを理解しやすくします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although you take on some of the responsibility for correctness, the explicit parent-child relationships between tasks lets Swift handle some behaviors like propagating cancellation for you, and lets Swift detect some errors at compile time.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが正しさに対する責任の一部を負うとはいえ、タスク間の明確な親子関係は、取り消しをあなたに代わって伝播することのようないくつかの挙動をスウィフトに取り扱わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although you write return nil to trigger an initialization failure, you don’t use the return keyword to indicate initialization success.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはreturn nilを書くことで初期化失敗を引き起こすけれども、あなたはreturnキーワードを初期化成功を指し示すためには使いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Always give type parameters upper camel case names (such as T and MyTypeParameter) to indicate that they’re a placeholder for a type, not a value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらが、値ではなく、型のためのプレースホルダであることを示すために、型パラメータに常にアッパーキャメルケース名（例えばTやMyTypeParameterなど）を与えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Always make sure that an optional contains a non-nil value before using ! to force-unwrap its value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>必ずあるオプショナルがnilではない値を含むことを、それの値を強制アンラップする!を使う前に確かめてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Always prefix type property requirements with the static keyword when you define them in a protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがあるプロトコルにおいてそれを定義するとき、常に、型プロパティ要件の前にstaticキーワードを置いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Always use a break statement to ignore a switch case.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>switchケース節を無視するために、常にbreak文を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Always use a normal optional type if you need to check for a nil value during the lifetime of a variable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがある変数の生涯のある時期にnil値について確認する必要があるならば、必ず普通のオプショナル型を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An Optional-Chaining Expression must appear within a postfix expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ひとつのオプショナル連鎖式が、ひとつの接尾辞式の内部に現れなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An Int8 constant or variable can store numbers between -128 and 127, whereas a UInt8 constant or variable can store numbers between 0 and 255.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Int8定数または変数は、-128と127の間の数を格納することができる一方、UInt8定数または変数は、0と255の間の数を格納することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An available attribute that specifies availability using a Swift version number can’t additionally specify a declaration’s platform availability.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトバージョン数を使って有効性を指定しているavailable属性は、ある宣言の持つプラットホーム有効性を追加的に指定することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An await expression can appear only within an asynchronous context, such as the trailing closure passed to the async(priority:operation:) function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>await式は、非同期の文脈、たとえばasync(priority:operation:)関数に渡される後付クロージャなど、の内部でのみ現れることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An await expression can’t appear on the right-hand side of an infix operator, unless the infix operator is the assignment operator or the await expression is enclosed in parentheses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>await式が接中辞演算子の右手側に現れることは、その接中辞演算子が代入演算子であるかawait式が丸括弧の中に入れられるかしない限りはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An if statement is used for executing code based on the evaluation of one or more conditions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>if文は、１つ以上の条件の評価に基づいてコードを実行するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An available attribute that specifies availability using a Swift version number can’t use the asterisk.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトバージョン数を使って有効性を指定するavailable属性は、アスタリスクを使用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An if statement chained together in this way has the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このやり方で一緒につながれるif文は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An actor declaration introduces a named actor type into your program.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>アクター宣言は、名前をつけられたアクター型をあなたのプログラムに導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An array literal is an ordered collection of values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列リテラルは、順序付けられた値のコレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An array stores values of the same type in an ordered list.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列は、同じ型の値を順序リストに保管します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An associated type gives a placeholder name to a type that’s used as part of the protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関連型は、プロトコルの一部として使われる型にプレースホルダ名を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An asynchronous function or asynchronous method is a special kind of function or method that can be suspended while it’s partway through execution.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非同期関数または非同期メソッドは、関数またはメソッドのある特別な種類です、それはそれが遂行の途中である間に中断されることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An autoclosure is a closure that’s automatically created to wrap an expression that’s being passed as an argument to a function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>自動クロージャは、自動的に作成されて、引数として関数に渡されている式を包み込むクロージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An availability condition is used as a condition of an if, while, and guard statement to query the availability of APIs at runtime, based on specified platforms arguments.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>有効性条件は、if、while、そしてguard文の条件として使われて、APIの有効性を実行時に、指定されたプラットホーム引数に基づいて問いただします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An await expression consists of the await operator followed by an expression that uses the result of an asynchronous operation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>await式は、await演算子と、非同期演算の結果を使うある式が続くものから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An enumeration case pattern matches a case of an existing enumeration type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙ケース節パターンは、既存の列挙型のケース節にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An enumeration declaration introduces a named enumeration type into your program.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙宣言は、名前をつけられた列挙型をあなたのプログラムに導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An enumeration defines a common type for a group of related values and enables you to work with those values in a type-safe way within your code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙は、一群の関連した値のための共通の型を定義して、それらの値を型安全な方法であなたのコード内で扱えるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An explicit member expression allows access to the members of a named type, a tuple, or a module.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>明示的メンバー式は、名前付きの型、タプル、またはモジュールのメンバーに対するアクセスを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An expression pattern represents the value of an expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>式パターンは、ある式の値を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An extension declaration allows you to extend the behavior of existing types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張宣言があなたに可能にするのは、既存の型の挙動を拡張することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An identifier pattern matches any value and binds the matched value to a variable or constant name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>識別子パターンは、どんな値にでもマッチして、マッチされた値を変数や定数の名前に縛りつけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An implicit member expression is an abbreviated way to access a member of a type, such as an enumeration case or a type method, in a context where type inference can determine the implied type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>暗黙のメンバー式は、型推論が暗黙の型を決定することができる文脈においてある型のメンバー、たとえば列挙ケース節や型メソッド、にアクセスするための簡略された方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An import declaration lets you access symbols that are declared outside the current file.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>インポート宣言は、あなたに現在のファイルの外側で宣言されるシンボルにアクセスさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An in-out expression marks a variable that’s being passed as an in-out argument to a function call expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>in-out expressionは、in-out引数として関数呼び出し式に渡されている変数を印します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An infix operator is a binary operator that’s written between its two operands, such as the familiar addition operator (+) in the expression 1 + 2.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>接中辞演算子は、それの２つ演算数の間で書かれる二項演算子です、例えば式1 + 2でのよく知られた加算演算子（+）など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An initializer declaration introduces an initializer for a class, structure, or enumeration into your program.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>イニシャライザ宣言は、あなたのプログラムにクラス、構造体、または列挙のためのイニシャライザを導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An initializer expression provides access to a type’s initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた、スーパークラスのイニシャライザに委任するために、イニシャライザ式を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An n-times-table is based on a fixed mathematical rule.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>九九のnの段は、決められた数学的な規則に基づきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An octal number, with a 0o prefix</seg>
      </tuv>
      <tuv lang="ja">
        <seg>８進数は、接頭辞0oつきで</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An opaque type defines a type that conforms to a protocol or protocol composition, without specifying the underlying concrete type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>不透明型は、あるプロトコルまたはプロトコル合成に準拠するある型を定義します、基礎をなす具象型を指定することなしに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An operator declaration introduces a new infix, prefix, or postfix operator into your program and is declared using the operator keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>演算子宣言は、新しい接中辞、接頭辞、または接尾辞演算子をあなたのプログラムに導入します、そしてキーワードoperatorを使って宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An operator is a special symbol or phrase that you use to check, change, or combine values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>演算子は、あなたがいろいろな値を調べたり、変えたり、結合したりするために使う、特別な記号または語句です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An optional pattern matches values wrapped in a some(Wrapped) case of an Optional&lt;Wrapped&gt; enumeration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルパターンは、Optional&lt;Wrapped&gt;列挙のSome(Wrapped)ケース節でラップされる値にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An optional-chaining expression provides a simplified syntax for using optional values in postfix expressions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル連鎖式は、オプショナルの値を使うために単純化された構文を接尾辞式において提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An optional-try expression consists of the try? operator followed by an expression that can throw an error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルtry式は、try?演算子と後につづくエラーをスローできる１つの式から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An HTTP status code is a special value returned by a web server whenever you request a web page.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>HTTP状態コードは、あなたがウェブ・ページを要請するときはいつでもウェブ・サーバーによって返されるある特別な値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An access is instantaneous if it’s not possible for other code to run after that access starts but before it ends.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるアクセスは、もしそのアクセスが始まった後でしかしそれが終わる前に他のコードに実行が可能でないならば、即時的です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An arbitrary Unicode scalar value, written as \u{n}, where n is a 1–8 digit hexadecimal number (Unicode is discussed in Unicode below)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>随意のユニコードスカラー値、\u{n}のように書かれます、ここでnは1–8桁の16進数です（ユニコードは下のUnicodeで議論されます）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An array allows new items to be inserted and removed at any location in the array.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列は、新しい項目を差し込まれたり取り外除かれることがその配列のどんな場所においても許されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An array literal is written as a list of values, separated by commas, surrounded by a pair of square brackets:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列リテラルは、一対の角括弧に囲まれて、コンマで区切られる値のリストとして書かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An arrow (→) is used to mark grammar productions and can be read as “can consist of.”</seg>
      </tuv>
      <tuv lang="ja">
        <seg>矢印（→）を使って文法導出を示します、「その文法はこうしたものから成り立つことができる」と読まれることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An assertion is triggered if you try to access a subscript that’s outside of the matrix bounds:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがマトリックス境界の外にある添え字にアクセスしようとするならば、表明が引き起こされます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An assignment statement is transformed like an expression, but is understood to evaluate to ().</seg>
      </tuv>
      <tuv lang="ja">
        <seg>代入文は、式のように変換されます、しかし()を評価すると理解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An associated type provides an alias for a type that’s used as part of a protocol’s declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関連型は、エイリアスをプロトコルの宣言の一部として使われる型のために用意します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An asynchronous function in Swift can give up the thread that it’s running on, which lets another asynchronous function run on that thread while the first function is blocked.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトにおける非同期関数は、それがその上で動作しているところのスレッドを諦めることができます、それは別の非同期関数にそのスレッド上で動作させます、一方で最初の関数はブロック（遮断）されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An asynchronous function or method still does one of those three things, but it can also pause in the middle when it’s waiting for something.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非同期の関数やメソッドは依然としてそれら３つのことの１つを行います、しかしそれはまた、それが何かを待っている時に途中で一時停止できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An attribute provides additional information about the declaration or type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>属性は、宣言または型についての追加的な情報を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An autoclosure lets you delay evaluation, because the code inside isn’t run until you call the closure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>自動クロージャは、あなたに評価を延期させます、内部のコードはあなたがそのクロージャを呼び出すまで実行されないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An autoclosure parameter whose wrapped expression’s type is a function type, like @autoclosure () -&gt; ((Bool) -&gt; Int)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それのラップした式のもつ型が関数型である自動クロージャパラメータ、たとえば@autoclosure () -&gt; ((Bool) -&gt; Int)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An availability condition has the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>有効性条件は以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An eight-bit number has seven value bits, so this means 2 to the power of 7, or 128.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>８ビットの数は７つの値ビットを持ちますので、これは2の7乗、つまり128を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An element name consists of an identifier followed immediately by a colon (:).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>要素名は、識別子に直ちにコロン（：）が続くものから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An empty dictionary literal is written as a colon inside a pair of brackets ([:]) to distinguish it from an empty array literal.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>空の辞書リテラルは、一対の角括弧の中のコロン（[:]）として書かれることで、空の配列リテラルからそれを区別します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An enclosing function can also return one of its nested functions to allow the nested function to be used in another scope.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>囲んでいる関数は、また、入れ子にされた関数が別のスコープにおいて使われるのを許可するために、その入れ子にされた関数のうちの１つを返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An enumeration case pattern also matches values of that case wrapped in an optional.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙ケースパターンはまた、オプショナルの中にラップされたそのケース節の値それらにマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An enumeration marked usableFromInline can use only types that are public or usableFromInline for the raw values and associated values of its cases.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>usableFromInlineで印される列挙は、生の値およびそれの列挙節の関連値に対してパブリックまたはusableFromInlineである型のみに使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An enumeration that’s marked with the indirect modifier can contain a mixture of cases that have associated values and cases those that don’t.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>indirect修飾子で印される列挙は、関連値を持つケース節とそうでないケース節の入り交じったものを持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An escaping closure that refers to self needs special consideration if self refers to an instance of a class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>selfを参照する脱出クロージャは、もしselfがあるクラスのインスタンスを参照するならば、特別な配慮を必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An explicit spelling of unowned.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>unownedの明確なつづり方。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An expression marked with await is called a potential suspension point.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>awaitで印された式は、潜在的中断地点と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An extended grapheme cluster is a sequence of one or more Unicode scalars that (when combined) produce a single human-readable character.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある拡張書記素クラスタは１つ以上のユニコード・スカラーの連なりです、それは（組み合わされて）人間の読み取り可能な１つの文字を作り出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An extension can be used to extend an existing generic type, as described in Extending a Generic Type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張は、既存の総称体型を拡張するために使われることができます、総称体型を拡張するで記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An extension can extend an existing type to make it adopt one or more protocols.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張は、既存の型を拡張して、それが１つ以上のプロトコルを採用するようにできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An implementation of subscript(dynamicMember:) can accept key paths using an argument of type KeyPath [https://developer.apple.com/documentation/swift/keypath], WritableKeyPath [https://developer.apple.com/documentation/swift/writablekeypath], or ReferenceWritableKeyPath [https://developer.apple.com/documentation/swift/referencewritablekeypath].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>subscript(dynamicMember:)の実装はキーパスを、型KeyPath [https://developer.apple.com/documentation/swift/keypath]、WritableKeyPath [https://developer.apple.com/documentation/swift/writablekeypath]、またはReferenceWritableKeyPath [https://developer.apple.com/documentation/swift/referencewritablekeypath]の引数を使って受け入れ可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An implicitly unwrapped optional is a normal optional behind the scenes, but can also be used like a non-optional value, without the need to unwrap the optional value each time it’s accessed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>暗黙的にアンラップされるオプショナルは、舞台裏では普通のオプショナルです、しかしまたオプショナルでない値のように扱うこともできます、それがアクセスされるたびにオプショナルの値をアンラップする必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An in-out parameter has a value that’s passed in to the function, is modified by the function, and is passed back out of the function to replace the original value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>in-outパラメータはある値を持ち、それは関数の中に渡されて、その関数によって修正されて、それから逆にその関数の外に渡されて本来の値に取って代わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An indirect case must have an associated value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関節参照のケース節は、関連値を持っていなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An initializer can’t call any instance methods, read the values of any instance properties, or refer to self as a value until after the first phase of initialization is complete.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>イニシャライザは、初期化の最初の段階が完了するまで、どんなインスタンスメソッドも呼ぶこと、どんなインスタンスプロパティの値も読むこと、またはselfをひとつの値として参照することができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An instance method can be called only on a specific instance of the type it belongs to.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>インスタンスメソッドは、それが属している型のある特定のインスタンスでだけ呼ばれることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An instance method has implicit access to all other instance methods and properties of that type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるインスタンスメソッドは、無条件にその型の他のインスタンスメソッドとプロパティの全てへのアクセスを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An instance of Hoverboard uses the default number of wheels supplied by the Vehicle initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Hoverboardのインスタンスは、Vehicleイニシャライザによって提供される省略時の車輪数を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An instance of a class is traditionally known as an object.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスのインスタンスは、伝統的にオブジェクトとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An integer type can be initialized with a Double or Float value:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>整数型は、DoubleまたはFloat値で初期化されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An opaque type lets the function implementation pick the type for the value it returns in a way that’s abstracted away from the code that calls the function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある不透明型は、関数実装に、それが返す値に対する型を、その関数を呼び出すコードから離れて抽象化されるある方法で選択させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An opaque type refers to one specific type, although the caller of the function isn’t able to see which type; a protocol type can refer to any type that conforms to the protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>不透明型は１つの特定の型を参照します、とはいえ関数の呼び出し側はどの型か知ることができません；プロトコル型はそのプロトコルに準拠するどんな型でも参照できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An operation is atomic if it uses only C atomic operations; otherwise it’s nonatomic.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある演算は、アトミックです、もしそれがCアトミック演算子だけを使うならば；そうでなければそれは非アトミックです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An optional Int is written as Int?, not Int.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルのIntは、Int?のように書かれます、Intではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An optional protocol requirement can be called with optional chaining, to account for the possibility that the requirement was not implemented by a type that conforms to the protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルのプロトコル要件は、オプショナル連鎖を使って呼び出されることができます、それによってプロトコルに準拠する型によって要件が満たされなかったという可能性に対応します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An optional represents two possibilities: Either there is a value, and you can unwrap the optional to access that value, or there isn’t a value at all.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるオプショナルは２つの可能性を表します：ある値が存在する、するとあなたはそのオプショナルをアンラップすることでその値を利用できます、または値がそもそも存在しないかのいずれか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An optional tuple type such as (Int, Int)? is different from a tuple that contains optional types such as (Int?, Int?).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>(Int, Int)?のようなオプショナルタプル型は、(Int?, Int?)のようなオプショナル型を含むタプルとは異なる方式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An optional value either contains a value or contains nil to indicate that a value is missing.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルの値は、ある値を含むか、値が見つからないことを示すnilを含むかのどちらかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An optional variable is used here, because players can leave the game at any point.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルの変数がここで使われます、なぜなら、プレーヤーはどの時点でもゲームから離れることができるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An overridden method named someMethod() can call the superclass version of someMethod() by calling super.someMethod() within the overriding method implementation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>someMethod()という名前のオーバーライドされたメソッドは、オーバーライドしているメソッド実装内でsuper.someMethod()を呼ぶことによって、スーパークラス版のsomeMethod()を呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An overridden property called someProperty can access the superclass version of someProperty as super.someProperty within the overriding getter or setter implementation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>somePropertyと呼ばれるオーバーライドされたプロパティは、オーバーライドしているゲッターまたはセッター実装内で、super.somePropertyのようにしてスーパークラス版のsomePropertyにアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An overridden subscript for someIndex can access the superclass version of the same subscript as super[someIndex] from within the overriding subscript implementation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>someIndexのためのオーバーライドされた添え字は、オーバーライドしている添え字実装内からsuper[someIndex]のようにしてスーパークラス版の同じ添え字にアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An override can make an inherited class member more accessible than its superclass version.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オーバーライドは、継承されたクラス・メンバーを、そのスーパークラス版よりもアクセス度を高くすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An underscore (_) before a parameter name suppresses the argument label.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>パラメーター名の前のアンダースコア（_）は、引数ラベルを抑制します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An underscore (_) parameter is explicitly ignored and can’t be accessed within the body of the function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ひとつのアンダースコア（_）のパラメータは、明確に無視されます、そして関数の本体内でアクセスされることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An unowned optional reference doesn’t keep a strong hold on the instance of the class that it wraps, and so it doesn’t prevent ARC from deallocating the instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非所有オプショナル参照は、強い保持をそれがラップするクラスのインスタンス上で持ち続けません、それゆえそれはARCがインスタンスをデアロケートするのを妨げません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An unowned reference is the appropriate capture method to use to resolve the strong reference cycle in the HTMLElement example from Strong Reference Cycles for Closures above.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非所有参照は、上のクロージャのための強い参照循環のHTMLElement例での強い参照循環を解消するのために使うのに適切な捕獲の手法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>And SomeProtocol.self returns SomeProtocol itself, not an instance of a type that conforms to SomeProtocol at runtime.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そして、SomeProtocol.selfは、SomeProtocol自身を返します、実行時にSomeProtocolに準拠するある型のインスタンスではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>And because the value of ExampleEnum.c is explicitly set to 5, the value of ExampleEnum.d is automatically incremented from 5 and is therefore 6.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そしてExampleEnum.cの値が明示的に5に設定されるので、ExampleEnum.dの値は5から自動的に増加して、したがって6です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>And just like functions and methods, you use the throws or rethrows keyword after an initializer’s parameters to indicate the appropriate behavior.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そして関数やメソッドのように、あなたはthrowsまたはrethrowsキーワードをイニシャライザのパラメータの後に使って、ふさわしい挙動を指し示すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>And just like functions, you can get a reference to an enumeration case and apply it later in your code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>さらにまさに関数のように、あなたはある列挙ケース節の参照を得ることができ、それを後であなたのコードに応用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>And so on.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>などなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>And, because weak references need to allow their value to be changed to nil at runtime, they’re always declared as variables, rather than constants, of an optional type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そしてまた、弱い参照はそれらの値を実行時にnilに変更されるのを許される必要があることから、それらは常にオプショナル型の変数として宣言されます、定数ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Another approach is to wait for one element of the collection at a time using an asynchronous sequence.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>別の取り組み方は、非同期シーケンスを使用して一度にコレクションの１つの要素に対して待機することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Another choice for enumeration cases is to have values associated with the case—these values are determined when you make the instance, and they can be different for each instance of an enumeration case.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙ケース節の別の選択はそのケース節と結びつけられる値を持つことになります — それらの値はあなたがインスタンスを作る時に決定されます、そしてそれらはある列挙ケース節のインスタンスそれぞれで異なることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Another consequence of long-term write access to in-out parameters is that passing a single variable as the argument for multiple in-out parameters of the same function produces a conflict.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>in-outパラメータに対する長期書き込みアクセスの別の帰着は、同じ関数の複数in-outパラメータのための引数として単一の変数を渡すことが衝突を生み出すことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Another problem with this approach is that the shape transformations don’t nest.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この取り組みの別の問題は、形状変換が入れ子にされないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Another way to catch several related errors is to list them after catch, separated by commas.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>いくつかの関連したエラーをキャッチする別の方法は、それらをcatchの後に、コンマで区切って列記することになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Another way to describe the requirements of the main attribute is that the type you write this attribute on must satisfy the same requirements as types that conform to the following hypothetical protocol:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>main属性の要件を記述する別の方法は、あなたがそれの上でこの属性を書くところの型は以下の仮定的なプロトコルに準拠する型と同じ要件を満たさなければならない、ということになります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Another way to handle errors is to use try? to convert the result to an optional.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>エラーを取り扱う別の方法は、try?を使って結果をオプショナルに変換することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Another way to handle optional values is to provide a default value using the ?? operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルの値を取り扱うもう１つの方法は、省略時の値を??演算子を使って提供することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any Dice instance can now be treated as TextRepresentable:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>どんなDiceインスタンスでも、今やTextRepresentableとして扱われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any Type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Any型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any Unicode scalar value except  ",  \, U+000A, or U+000D</seg>
      </tuv>
      <tuv lang="ja">
        <seg>何らかのユニコードスカラー値、しかし", \、U+000A、またはU+000Dを除く</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any Unicode scalar value except  /* or  */</seg>
      </tuv>
      <tuv lang="ja">
        <seg>任意のユニコードスカラー値、 しかし/* または */ を除く</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any Unicode scalar value except  \</seg>
      </tuv>
      <tuv lang="ja">
        <seg>任意のユニコードスカラー値、しかし\を除く</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any Unicode scalar value except U+000A or U+000D</seg>
      </tuv>
      <tuv lang="ja">
        <seg>任意のユニコードスカラー値、 しかし U+000A または U+000D を除く</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any additional setup work that uses methods, getters, or setters can also be done at this point.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メソッド、ゲッター、またはセッターを使うどんな追加の準備作業も、また、この時点で行われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any attempt to override a final method, property, or subscript in a subclass is reported as a compile-time error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるサブクラスの中の最終的なメソッド、プロパティ、または添え字をオーバーライドするどんな試みも、コンパイル時エラーとして報告されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any attempt to set a property through optional chaining returns a value of type Void?, which enables you to compare against nil to see if the property was set successfully:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル連鎖を通してプロパティを設定しようとするあらゆる試みは、型Void?の値を返します、それは、あなたにnilと比較することでそのプロパティがうまく設定されたかどうか調べることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any attempt to subclass a final class is reported as a compile-time error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最終版クラスにサブクラスを作る試みは何であれ、コンパイル時エラーを報告します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any bits that are moved beyond the bounds of the integer’s storage are discarded.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>整数の格納量の境界を越えて動かされるあらゆるビットは、捨てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any class that doesn’t inherit from another class is known as a base class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>別のクラスから継承しない何らかのクラスは、基盤クラスとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any constants or variables assigned a value from an optional binding declaration in a guard statement condition can be used for the rest of the guard statement’s enclosing scope.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>guard文条件の中のオプショナル束縛宣言由来のあらゆる定数または変数は、guard文の囲むスコープの他の部分で使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any errors thrown inside a nonthrowing function must be handled inside the function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スローしない関数の内部でスローされるどんなエラーも、その関数の内部で取り扱われなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any function that you write as just one return line can omit the return.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがただ１つだけのreturn行として書くあらゆる関数は、returnを省略できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any gaps in an array are closed when an item is removed, and so the value at index 0 is once again equal to "Six eggs":</seg>
      </tuv>
      <tuv lang="ja">
        <seg>項目が取り外されるとき、配列でのどんな隙間でも閉じられます、なのでインデックス0での値はふたたび"Six eggs"と等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any identifier, keyword, literal, or operator</seg>
      </tuv>
      <tuv lang="ja">
        <seg>任意の識別子、キーワード、リテラル、または演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any initializer in the diagram above can be used to create a fully initialized instance of the class they belong to.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の図の中のどんなイニシャライザでも、それらが属しているクラスの充分に初期化されたインスタンスをつくるために使用されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any internal implementation details of your framework can still use the default access level of internal, or can be marked as private or file private if you want to hide them from other parts of the framework’s internal code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたのフレームワークのあらゆる内部的実装詳細は、依然として省略時のアクセス水準である内部を使用します、もしくはあなたがそれらをそのフレームワークの内部コードの他の部分から隠したいならば非公開またはファイル限定として印されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any other errors are propagated to the surrounding scope, including any vending-machine errors that might be added later.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>何らかの他のエラーは、周囲のスコープに伝播されます、後で加えられるかもしれないあらゆる自動販売機エラーを含めて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any protocol that inherits from a protocol that’s marked with the AnyObject requirement can likewise be adopted only by class types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>AnyObject要件で印されるプロトコルから継承するどんなプロトコルも、同じようにクラス型でのみ採用されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any punctuation except  (,  ),  [,  ],  {, or  }</seg>
      </tuv>
      <tuv lang="ja">
        <seg>任意の句読点、しかし(,  ),  [,  ],  {, または  }を除く</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any side effects of a key path expression are evaluated only at the point where the expression is evaluated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>キーパス式のあらゆる副作用は、式が評価されるところの時点でのみ評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any type aliases you define are treated as distinct types for the purposes of access control.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが定義するどんな型エイリアスでも、アクセス制御の目的のためにはっきりした型とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any type argument substituted for a type parameter must meet all the constraints and requirements placed on the type parameter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型パラメータと置き換えられるどんな型引数でも、型パラメータに設置された制約と要件の全てに応じなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any type can be explicitly declared to be (or implicitly converted to) an optional type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あらゆる型は、オプショナル型であるとして明示的に宣言される（または暗黙的に変換される）ことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any type members added in an extension have the same default access level as type members declared in the original type being extended.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張において加えられるどんな型メンバーでも、拡張されているところの本来の型で宣言される型メンバーと同じ省略時のアクセス水準を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any type that conforms to the Container protocol must be able to specify the type of values it stores.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Containerプロトコルに準拠するあらゆる型は、それが格納する値の型を指定することができなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any type that satisfies the requirements of a protocol is said to conform to that protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるプロトコルの要件を満たす何らかの型は、そのプロトコルに準拠すると言われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any type that’s Equatable can be used safely with the findIndex(of:in:) function, because it’s guaranteed to support the equal to operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Equatableであるどんな型でもfindIndex(of:in:)関数で問題なく使われることができます、なぜなら、それが同等演算子をサポートすると保証されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any variables or constants that were assigned values using an optional binding as part of the condition are available for the rest of the code block that the guard statement appears in.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル束縛を使ってこの条件の一部として値を代入された、あらゆる変数や定数は、guard文が現れるコードブロックの残りの部分で利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any whitespace between the backslash and the line break is also omitted.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>バックスラッシュとラインブレークの間のあらゆる空白もまた省かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Anything that adopts PrettyTextRepresentable must satisfy all of the requirements enforced by TextRepresentable, plus the additional requirements enforced by PrettyTextRepresentable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>PrettyTextRepresentableを採用するどんなものでも、TextRepresentableによって強制される要件の全て、それに加えてPrettyTextRepresentableによって強制される追加の要件を満たさなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Anything that’s PrettyTextRepresentable must also be TextRepresentable, and so the implementation of prettyTextualDescription starts by accessing the textualDescription property from the TextRepresentable protocol to begin an output string.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>PrettyTextRepresentableであるものは何でも、またTextRepresentableでなければなりません、なのでprettyTextualDescriptionの実装は出力文字列を開始するためにTextRepresentableプロトコルからのtextualDescriptionプロパティにアクセスすることによって始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply that new attribute to a property of a class, structure, or enumeration to wrap access to the property through an instance of the wrapper type; apply the attribute to a local stored variable declaration to wrap access to the variable the same way.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その新しい属性をクラス、構造体、または列挙のプロパティに適用することで、そのプロパティに対するアクセスを、ラッパー型のインスタンスによってラップしてください；その属性をあるローカル格納変数宣言に適用することで、その変数に対するアクセスを同じ方法でラップしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this attribute to a class declaration to require all stored properties within the class to provide default values as part of their definitions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性をあるクラス宣言に適用することで、そのクラス内の全ての格納プロパティに、省略時の値をそれら宣言の一部として提供することを要求してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this attribute to a class declaration, to implicitly apply the objc attribute to all Objective-C compatible members of the class, its extensions, its subclasses, and all of the extensions of its subclasses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性をあるクラス宣言に適用してください、暗黙的にobjc属性をそのクラスの全てのObjective-C互換メンバー、それの拡張、それのサブクラス、そしてそれのサブクラスの全ての拡張に適用するには。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this attribute to a class to indicate that it’s the application delegate.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性をあるクラスに適用することで、それがアプリケーション委任先であることを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this attribute to a class, structure, enumeration to use that type as a result builder.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性をクラス、構造体、列挙に適用することで、その型をリザルトビルダーとして使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this attribute to a class, structure, enumeration, or protocol to enable members to be looked up by name at runtime.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性をクラス、構造体、列挙、またはプロトコルに適用して、メンバが実行時に名前で検索されることを可能にしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this attribute to a class, structure, enumeration, or protocol to treat instances of the type as callable functions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性をクラス、構造体、列挙、またはプロトコルに適用することで、その型のインスタンスをcallable関数として扱ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this attribute to a class, structure, or enumeration declaration to use that type as a property wrapper.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性をクラス、構造体、または列挙の宣言に適用して、その型をプロパティラッパーとして使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this attribute to a function or method declaration to suppress the compiler warning when the function or method that returns a value is called without using its result.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性を関数またはメソッド宣言に適用して、値を返す関数やメソッドがそれの結果を使うことなく呼び出された時にコンパイラが警告を発するのを抑制してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this attribute to a function, method, computed property, subscript, convenience initializer, or deinitializer declaration to expose that declaration’s implementation as part of the module’s public interface.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性を関数、メソッド、計算プロパティ、添え字、便宜イニシャライザ、またはデイニシャライザ宣言に適用することで、宣言の実装をモジュールの公開インターフェイスの一部として露出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this attribute to a function, method, computed property, subscript, initializer, or deinitializer declaration to allow that symbol to be used in inlinable code that’s defined in the same module as the declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性を関数、メソッド、計算プロパティ、添え字、便宜イニシャライザ、またはデイニシャライザ宣言に適用することで、そのシンボルが、同じモジュールの中で宣言として定義されるインライン可能コードにおいて使用できるようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this attribute to a method, property, subscript, or initializer declaration to suppress an implicit objc attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性をメソッド、プロパティ、添え字、およびイニシャライザ宣言に適用することで、暗黙的にobjc属性となるのを抑制してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this attribute to a parameter’s type in a function or method declaration to indicate that the parameter’s value can be stored for later execution.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性をパラメータのもつ型に対して関数やメソッドの宣言において適用して、そのパラメータのもつ値がその後の実行のために保管されることができるのを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this attribute to a stored variable property of a class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性をクラスの格納変数プロパティに適用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this attribute to a structure or enumeration declaration to restrict the kinds of changes you can make to the type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性を構造体または列挙宣言に適用して、あなたがその型にすることが出来る変更の種類を制約してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this attribute to a structure, class, or enumeration declaration to indicate that it contains the top-level entry point for program flow.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性を構造体、クラス、または列挙宣言に適用して、それがプログラム流れに対するトップレベルエントリポイントを含むことを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this attribute to a switch case to indicate that it isn’t expected to be matched by any case of the enumeration that’s known at the time the code is compiled.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性をスイッチケース節に適用して、コードがコンパイルされる時点で既知である列挙のどんなケース節によってもそれが合致されることは期待されないことを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this attribute to a top-level function, instance method, or class or static method to trigger warnings when that function or method is used without a preceding qualifier, such as a module name, type name, or instance variable or constant.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性をトップレベルの関数、インスタンスメソッド、もしくはクラスまたは静的メソッドに適用することで、その関数またはメソッドが、例えばモジュール名、型名、またはインスタンス変数や定数など、先行する修飾語無しで使われる場合に警告を引き起こしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this attribute to an import declaration to import that module with changes to its access control that simplify testing the module’s code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性をあるimport宣言に適用することで、そのモジュールのインポートをそれのアクセス制御への、モジュールの持つコードを試験するのを簡単にする変更とともに行ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this attribute to an instance method or stored variable property of a class that inherits from NSManagedObject to indicate that Core Data dynamically provides its implementation at runtime, based on the associated entity description.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性をNSManagedObjectから継承するクラスのインスタンスメソッドまたは格納変数プロパティに適用することで、関連する実体記述に基づいて、Coreデータが動的にそれの実装に実行時に提供されることを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this attribute to any declaration that can be represented in Objective-C—for example, nonnested classes, protocols, nongeneric enumerations (constrained to integer raw-value types), properties and methods (including getters and setters) of classes, protocols and optional members of a protocol, initializers, and subscripts.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性をObjective-Cにおいて表わされることができる何らかの宣言に適用してください ― 例えば、入れ子にされないクラス、プロトコル、総称体でない列挙（整数の生の値型に制限される）、クラスのプロパティとメソッド（ゲッターやセッターを含む）、プロトコルおよびあるプロトコルのオプショナルメンバ、イニシャライザ、そして添え字など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this attribute to delay the evaluation of an expression by automatically wrapping that expression in a closure with no arguments.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性を適用することで、ある式の評価の延期を、自動的にその式を引数なしクロージャの中にラップすることによって行ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this attribute to expose a custom GameplayKit component property to the SpriteKit editor UI.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性を適用することであつらえのGameplayKitコンポーネントプロパティをSpriteKitエディタUIに露出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this attribute to indicate a declaration’s life cycle relative to certain Swift language versions or certain platforms and operating system versions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性を適用することで、ある宣言の寿命を、特定のスウィフト言語バージョンまたは特定のプラットホームおよびオペレーティングシステムバージョンに相関的に指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this attribute to the type of a function to indicate its calling conventions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性を関数の型に適用して、それの呼出規約を示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this modifier to a class or to a property, method, or subscript member of a class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この修飾子をクラスに、またはプロパティ、メソッド、またはクラスの添え字メンバーに適用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this modifier to a declaration to indicate the declaration can be accessed and subclassed by code in the same module as the declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この修飾子を宣言に適用して、その宣言がアクセスされることおよびサブクラスを作られることが、宣言と同じモジュールの中のコードによって可能なのを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this modifier to a declaration to indicate the declaration can be accessed only by code in the same module as the declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この修飾子を宣言に適用して、その宣言が、宣言と同じモジュールの中のコードによってのみアクセスされることができるのを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this modifier to a declaration to indicate the declaration can be accessed only by code in the same source file as the declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この修飾子を宣言に適用して、その宣言が、宣言と同じソースファイルの中のコードによってのみアクセスされることができるのを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this modifier to a declaration to indicate the declaration can be accessed only by code within the declaration’s immediate enclosing scope.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この修飾子を宣言に適用して、その宣言がアクセスされることは、宣言が直に囲んでいるスコープ内のコードによってのみ可能なのを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this modifier to a designated or convenience initializer of a class to indicate that every subclass must implement that initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この修飾子をクラスの必須または便宜イニシャライザに適用して、全てのサブクラスがそのイニシャライザを実装しなければならないことを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this modifier to a member of a class to indicate that the member is a member of the class itself, rather than a member of instances of the class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この修飾子をクラスのメンバーに適用して、そのメンバーがそのクラスそれ自身のメンバーであることを指し示してください、そのクラスのインスタンスのメンバーではなくて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this modifier to a member of a structure, class, enumeration, or protocol to indicate that the member is a member of the type, rather than a member of instances of that type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この修飾子を構造体、クラス、列挙、またはプロトコルのメンバーに適用して、そのメンバーがその型のメンバーであることを指し示してください、その型のインスタンスのメンバーではなくて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this modifier to a protocol’s property, method, or subscript members to indicate that a conforming type isn’t required to implement those members.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この修飾子をプロトコルのプロパティ、メソッド、または添え字メンバーに適用して、ある準拠型がそれらのメンバーを実装する必要がないことを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this modifier to a stored variable or stored variable property to indicate that the variable or property has a weak reference to the object stored as its value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この修飾子を格納変数または格納変数プロパティに適用して、その変数またはプロパティがそれの値として格納されるオブジェクトに対して弱い参照を持つことを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this modifier to a stored variable property of a class or structure to indicate that the property’s initial value is calculated and stored at most once, when the property is first accessed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この修飾子をクラスまたは構造体の格納変数プロパティに適用して、そのプロパティの初期値が最大でも一度だけ、そのプロパティが最初にアクセスされるときに、計算または格納されることを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this modifier to a stored variable, constant, or stored property to indicate that the variable or property has an unowned reference to the object stored as its value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この修飾子を格納変数、定数、または格納プロパティに適用して、その変数またはプロパティがそれの値として格納されるオブジェクトに対して非所有参照を持つことを指し示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Apply this modifier to any member of a class that can be represented by Objective-C.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この修飾子をObjective-Cによって表わされることのできるクラスのあらゆるメンバーに適用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Applying a result builder attribute doesn’t impact ABI compatibility.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>リザルトビルダー属性を適用することは、ABI互換性に影響を与えません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Applying a result builder attribute to a parameter makes that attribute part of the function’s interface, which can effect source compatibility.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>リザルトビルダー属性をあるパラメータに適用することは、その属性を関数のもつインターフェイスの一部にします、それはソース互換性に影響を及ぼす可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Applying the IBAction, IBSegueAction, IBOutlet, IBDesignable, or IBInspectable attribute also implies the objc attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>IBAction、IBSegueAction、IBOutlet、IBDesignable、またはIBInspectable属性を適用することはまた、暗黙的にobjc属性を伴います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Applying the objc attribute when it isn’t needed can increase your binary size and adversely affect performance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それが必要とされない時にobjc属性を適用することは、あなたのバイナリサイズを増加させ性能に逆効果です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Applying this attribute also implies the objc attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性を適用することはまた、objc属性も暗に意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Applying this attribute also implies the objc attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性を適用することはさらにまたobjc属性も意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Applying this attribute to an extension has the same effect as applying it to every member of that extension that isn’t explicitly marked with the nonobjc attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性をある拡張に適用することは、その拡張のあらゆるメンバで明示的にnonobjc属性で印されていないものにそれを適用することと同じ効果を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Applying this attribute to an extension has the same effect as applying it to every member of that extension that isn’t explicitly marked with the objc attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性をある拡張に適用することは、明示的にobjc属性で印されていないその拡張のあらゆるメンバにそれを適用することと同じ効果を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Argument labels must always be used in an initializer if they’re defined, and omitting them is a compile-time error:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>引数ラベルは、それらが定義されるならば常にイニシャライザで使われなければなりません、そして、それらを省略することはコンパイル時エラーになります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Argument names in functions and methods aren’t part of the corresponding function type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数やメソッドの引数名は、対応する関数型の一部ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Arithmetic Operators</seg>
      </tuv>
      <tuv lang="ja">
        <seg>算術演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Arithmetic operators (+, -, *, /, % and so forth) detect and disallow value overflow, to avoid unexpected results when working with numbers that become larger or smaller than the allowed value range of the type that stores them.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>算術演算子（+、-、*、/、%その他）は、値があふれること（オーバフロー）を検知して承認しません、数を扱うときにそれらを格納する型の許容される値の範囲より大きいか小さくなる予想外の結果を防ぐためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Array Type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Array Type Shorthand Syntax</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列型の短縮形構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Array indices are checked for out-of-bounds errors.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列インデックスは、境界外エラーを確認される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Arrays</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Arrays are ordered collections of values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列は、順番をつけられた値のコレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Arrays automatically grow as you add elements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列は、あなたが要素を追加するとき自動的に増大します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Arrays in Swift are always zero-indexed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトの配列は、常に０からのインデックスをつけられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Arrays, sets, and dictionaries in Swift are always clear about the types of values and keys that they can store.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトの配列、集合、そして辞書は、それらが格納できる値とキーの型について常に明確です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Array’s existing append(_:) method and subscript enable Swift to infer the appropriate type to use for Item, just as for the generic Stack type above.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列の既存のappend(_:)メソッドと添え字は、スウィフトに、ちょうど上の総称体Stack型と同じように、Itemに使うのに適当な型を推論するのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a general guideline, prefer structures because they’re easier to reason about, and use classes when they’re appropriate or necessary.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>一般的な指針として、構造体を選んでください、なぜならそれらは推論するのがより簡単だからです、そしてそれが適切または必要である場合はクラスを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a parameter type or return type in a function, method, or initializer</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数、メソッド、またはイニシャライザにおいてパラメータ型または戻り型として</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a result, a failable initializer can return nil to indicate that initialization failed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>結果として、失敗できるイニシャライザは、そのイニシャライザが失敗したのを指し示すためにnilを返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a result, code is not just easier to write, but easier to read and maintain as well.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>結果として、コードは書くのがより簡単なだけでなく、読むことおよび保守するのもまたより簡単です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a result, if multiple cases contain patterns that evaluate to the same value, and thus can match the value of the control expression, the program executes only the code within the first matching case in source order.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その結果、複数のケース節が同じ値に評価される、そしてそれゆえ制御式の値にマッチすることができるパターンを含むならば、プログラムはソース順において最初のマッチしているケース節内のコードだけを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a result, in many cases you don’t need to specify an explicit access level in your code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その結果、多くの場合には、あなたはあなたのコードにおいて明示的にアクセス水準を指定する必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a result, it automatically receives a default initializer, as described in Default Initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>結果として、省略時のイニシャライザで記述されるように、それは自動的に省略時のイニシャライザを受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a result, marking a value as unowned doesn’t make it optional, and ARC never sets an unowned reference’s value to nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>結果として、ある値を非所有と印することは、それをオプショナルにしません、そしてARCは決して非所有参照のもつ値をnilに設定しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a result, only class types can adopt and conform to a protocol that contains optional member requirements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>結果として、クラス型だけがオプショナルメンバー要件を含むプロトコルを採用および準拠することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a result, the endIndex property isn’t a valid argument to a string’s subscript.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>結果として、endIndexプロパティは、文字列の添え字として有効な引数ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a result, the statements are compiled and executed only if the compilation condition evaluates to true at compile time.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>結果として、statements（文）がコンパイル及び実行されるのはcompilation conditionがコンパイル時にtrueに評価される場合に限ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a result, the number of characters in a string can’t be calculated without iterating through the string to determine its extended grapheme cluster boundaries.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その結果、ある文字列の中の文字の数は、それの拡張書記素クラスタ境界を解決するためにその文字列の最初から終わりまで繰り返していくことなしに計算されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a result, the value of the customerProvider argument must be allowed to escape the function’s scope.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その結果、customerProvider引数の値は関数のスコープを脱出することを許されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a result, they have a rawValue property and a failable initializer with the signature init?(rawValue: RawValue).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>結果として、それはrawValueプロパティとシグネチャinit?(rawValue: RawValue)を持つ失敗できるイニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a result, they’re both evaluated before the addition is considered.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>結果として、それらは両方とも、加算が考慮される前に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a result, whether a closure expression is escaping or nonescaping depends on the surrounding context of the expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>結果として、あるクロージャ式が脱出または非脱出であるかどうかは、その式を取り囲んでいる前後関係に依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a result, you can use a nonthrowing function in a context where as a throwing one is expected.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>結果として、あなたは非スロー関数を、スローするものが期待されるのと同じ文脈の中で使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a result, you can use a nonthrowing function in the same places as a throwing one.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>結果として、あなたは非スロー関数をスロー関数と同じ場所で使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a result, you can use a synchronous function in a context where an asynchronous function is expected.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>結果として、あなたは同期関数を、非同期関数が期待されるところの文脈の中で使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a result, you can:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>結果として、あなたは次のことが出来ます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a result, you don’t implement the getter or setter directly in the protocol in which it’s declared.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>結果として、それが宣言されるプロトコルにおいて、あなたは直接ゲッターまたはセッターを実装しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a result, you don’t need to add whitespace to disambiguate between the closing &gt; characters in constructs like Dictionary&lt;String, Array&lt;Int&gt;&gt;.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その結果、あなたは空白を加えて閉じ&gt;文字の間の曖昧さをなくす必要はありません、Dictionary&lt;String, Array&lt;Int&gt;&gt;のような構造物においては。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a result, you don’t write the override modifier when providing a matching implementation of a superclass convenience initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>結果として、あなたはスーパークラスの便宜イニシャライザに一致する実装を提供している時にoverride修飾子を書きません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a result, you must include at least one statement following the colon (:) of each case label.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その結果、あなたはそれぞれのケース節ラベルのコロン（:）に続いている文を少なくとも１つは含めなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a result, you never need to write an inline closure in its fullest form when the closure is used as a function or method argument.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その結果、あなたは、行内クロージャをその最も完全な形式で書くことは、そのクロージャが関数やメソッドの引数として使われる時にまったく必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a shortcut to accessing its rooms array, this version of Residence provides a read-write subscript that provides access to the room at the requested index in the rooms array.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのrooms配列にアクセスすることへの近道として、Residenceのこの版は読み出し専用の添え字を提供します、それは、rooms配列の中の要求されたインデックスでの部屋へのアクセスを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As an alternative to associated values, enumeration cases can come prepopulated with default values (called raw values), which are all of the same type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関連値に代わるものとして、列挙ケース節は全て同じ型の（生の値と呼ばれる）初期値があらかじめ入れられた状態であることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As an alternative to querying their value properties, each UnicodeScalar value can also be used to construct a new String value, such as with string interpolation:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらのvalueプロパティについて尋ねることに代わるものとして、各UnicodeScalar値は、また、新しいString値を造るために使われることもできます、例えば文字列補間を使って：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As an alternative to subscripting, use a dictionary’s updateValue(_:forKey:) method to set or update the value for a particular key.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字指定に代わるものとして、辞書のupdateValue(_:forKey:)メソッドを、特定のキーに対する値を設定したり更新したりするために使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As an example, Swift’s Array type has a map(_:) method, which takes a closure expression as its single argument.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例として、スウィフトのArray型はmap(_:)メソッドを持ちます、それは、そのただ１つの引数としてクロージャ式をとります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As an example, consider the task of reading and processing data from a file on disk.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ひとつの例として、ディスク上のファイルからデータを読み込んで処理する作業を考えてみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As an example, many functions that start an asynchronous operation take a closure argument as a completion handler.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例として、非同期の演算を開始する多くの関数は、クロージャ引数を完了ハンドラとして取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As an example, the +++ operator in a+++ b is treated as a postfix unary operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例として、a+++ bにおける+++演算子は、接尾辞単項演算子とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As an example, the +++ operator in a+++b and a +++ b is treated as an infix operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例として、+++演算子はa+++bとa +++ bにおいて、接中辞演算子とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As an example, the +++ operator in a +++b is treated as a prefix unary operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例として、a +++bにおける+++演算子は、接頭辞単項演算子とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As an example, the +++ operator in a+++.b is treated as a postfix unary operator (a+++ .b rather than a +++ .b).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例として、+++演算子はa+++.bにおいて、接尾辞単項演算子（a+++ .b、a +++ .bではなく）とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As an example, the grammar of a getter-setter block is defined as follows:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例として、ゲッターセッター・ブロックの文法は、次のように定義されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As an optimization, Swift may instead capture and store a copy of a value if that value isn’t mutated by a closure, and if the value isn’t mutated after the closure is created.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ひとつの最適化として、その値がクロージャによって変化させられないならば、そしてその値がクロージャが作成された後に変化されられないならば、スウィフトはそれよりむしろ値のコピーをキャプチャして保管するかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As an optimization, when the argument is a value stored at a physical address in memory, the same memory location is used both inside and outside the function body.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ひとつの最適化として、引数がメモリにおいて物理的番地に格納される値である時、同じメモリ位置は関数本体の内側と外側の両方で使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As can be seen above, the getter correctly returns a center point of (5, 5).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上で見られるように、ゲッターは正しく中心点(5, 5)を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As demonstrated in Optional Chaining as an Alternative to Forced Unwrapping, you can use optional chaining to access a property on an optional value, and to check if that property access is successful.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>強制アンラップに代わるものとしてのオプショナル連鎖で例示されるように、あなたはオプショナル連鎖を使って、あるオプショナル上でプロパティにアクセスして、そのプロパティへのアクセスが成功したか調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As described above, optionals indicate that a constant or variable is allowed to have “no value”.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>先に述べたように、オプショナルは、ある定数や変数が「値がない」状態でも許されることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As described above, the ultimate return type of this method call after optional chaining is also String?:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>先に述べたように、オプショナル連鎖の後ろのこのメソッド呼び出しの最終的な戻り型は、また、String?です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As described in Control Flow, a switch statement must be exhaustive when considering an enumeration’s cases.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>制御の流れで記述されるように、switch文は列挙のケース節を考慮するとき、徹底的でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As described in Default Initializers, Swift automatically provides a default initializer without any arguments for any structure or base class that provides default values for all of its properties and doesn’t provide at least one initializer itself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>省略時のイニシャライザで記述されるように、スウィフトは、全く引数を持たない省略時のイニシャライザを、あらゆる構造体または基盤クラスで、それのプロパティの全てに省略時の値を提供して、とにかく１つのイニシャライザもそれ自身では提供しないもののために、自動的に提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As described in Failable Initializers, a special form of the return statement (return nil) can be used in a failable initializer to indicate initialization failure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>失敗できるイニシャライザで記述されるように、return文の特別な形式（return nil）は、失敗できるイニシャライザの中で使用されて初期化失敗を指し示すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As described in Dictionaries, the type of a dictionary’s keys must be hashable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>辞書で記述されるように、辞書のキーの型は、ハッシュ化できなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As discussed in Initializer Declaration, classes can have designated and convenience initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>イニシャライザ宣言で議論されるように、クラスは、指定および便宜イニシャライザを持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As expected, the counter’s count property increases by three each time increment() is called.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>予想されるように、counterのcountプロパティは、increment()が呼ばれるたびに３つずつ増加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As in the previous example, the final case matches all possible remaining values, and so a default case isn’t needed to make the switch statement exhaustive.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>前の例の場合のように、最後のケース節は全てのあり得る残りの値に適合します、そしてdefaultケース節はこのswitch文を網羅的なものにするのに必要ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As in this example, careful choice of Boolean constant and variable names can help to keep code readable and concise, while avoiding double negatives or confusing logic statements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例の場合のように、ブールの定数と変数の名前の慎重な選択はコードを読みやすく簡潔にしておくのを助けることができます、その一方で、二重の否定や、混乱させる論理文を避けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As its name suggests, the toggle() method is intended to toggle or invert the state of any conforming type, typically by modifying a property of that type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その名前が暗示するように、toggle()メソッドはあらゆる準拠型の状態を切り換えるか逆にすることを意図します、概してその型のプロパティの修正によって。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As mentioned above, different characters can require different amounts of memory to store, so in order to determine which Character is at a particular position, you must iterate over each Unicode scalar from the start or end of that String.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上で述べたように、異なる文字は格納するのに異なるメモリ量を必要とすることがあり得ます、それでCharacterがある特定の位置にあることを確定するために、あなたはそのStringの始まりまたは終わりからユニコードスカラーそれぞれにわたってずっと繰り返さなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As mentioned above, subclasses don’t inherit their superclass initializers by default.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上で述べたように、サブクラスは何もしなければそれらのスーパークラスのイニシャライザを継承しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As mentioned above, substrings aren’t suitable for long-term storage—because they reuse the storage of the original string, the entire original string must be kept in memory as long as any of its substrings are being used.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上で言及したように、下位文字列は長期保管に適していません — それらがオリジナルの文字列のストレージを再利用することから、オリジナルの文字列全体はそれの下位文字列が使われている限りメモリに保持されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As mentioned above, the Rank enumeration defines a further nested structure of its own, called Values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上で言及されるように、Rank列挙は独自の更なる入れ子にされた構造体を定義します、それはValuesと呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As mentioned above, the memory for an object is only considered fully initialized once the initial state of all of its stored properties is known.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上で言及したように、いったんその格納プロパティの全ての最初の状態が知られる場合にのみ、あるオブジェクトに対するメモリが充分に初期化されたとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As mentioned in Generic Parameter Clause, you don’t use a generic argument clause to specify the type arguments of a generic function or initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体パラメータ節で言及されるように、あなたは、総称体の関数やイニシャライザの型引数を指定するために総称体引数節を使いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As shown in the figure below, both number and stepSize refer to the same location in memory.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の図で示すように、numberとstepSizeの両方ともメモリ中の同じ位置を参照します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As shown in the figure below, they access different locations in memory.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の図で示すように、それらはメモリ中の異なる位置を参照します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As soon as all properties of the superclass have an initial value, its memory is considered fully initialized, and phase 1 is complete.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スーパークラスの全てのプロパティが初期値を持つとすぐに、そのメモリは完全に初期化されるとみなされます、そして第１段階は完了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As soon as the default case is matched, the break statement ends the switch statement’s execution, and code execution continues from the if let statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>defaultケース節が適合したならすぐに、break文がswitch文の実行を終えます、そしてコード実行はif let文から続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As such, index doesn’t have to be declared before it’s used.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このように、indexは、それが使われる前に宣言される必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As such, the performance characteristics of a throw statement are comparable to those of a return statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>throw文のいろいろな性能特徴は、それ自体としては、return文のそれと同程度です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As the above example shows, patterns in a case can also bind constants using the let keyword (they can also bind variables using the var keyword).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例で示されるように、あるケース節中のいくつかのパターンはまた、letキーワードを使って定数に束縛できます（それらはまたvarキーワードを使って変数に束縛もできます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As the return type of a method</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メソッドの戻り型として</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As the return type of a read-only subscript</seg>
      </tuv>
      <tuv lang="ja">
        <seg>読出し専用添え字の戻り型として</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As the type of a constant, variable, or property</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数、変数、またはプロパティの型として</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As the type of a read-only computed property</seg>
      </tuv>
      <tuv lang="ja">
        <seg>読出し専用の計算プロパティの型として</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As the type of items in an array, dictionary, or other container</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列、辞書、または他のコンテナ中の項目の型として</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As their names suggest, the value of a stored variable or a stored variable property is stored in memory.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらの名前が示すように、格納変数または格納変数プロパティの値はメモリに格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As with Int and Double above, you don’t need to declare constants or variables as Bool if you set them to true or false as soon as you create them.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のIntとDoubleと同様に、あなたがそれらを作成するやいなやtrueまたはfalseに設定するならば、あなたは定数または変数をBoolとして宣言する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As with all unsafe operations, you take on the responsibility for checking that code for safety.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>すべての安全でない操作と同様に、あなたはコードの安全について検査する責任を持つようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As with an array, you find out the number of items in a Dictionary by checking its read-only count property:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列と同様に、あなたはあるDictionaryの中の項目の数を、それの読み出し専用のcountプロパティを調べることによって突き止めます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As with an overridden property, method or subscript, the presence of the override modifier prompts Swift to check that the superclass has a matching designated initializer to be overridden, and validates that the parameters for your overriding initializer have been specified as intended.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オーバーライドされるプロパティ、メソッドや添え字を書く時と同様に、override修飾子の存在はスウィフトにスーパークラスが一致している、オーバーライドされる指定イニシャライザを持つのを確認すること、そしてあなたがオーバーライドするイニシャライザのパラメータが意図されるように指定されてしまっているのを検証することを促します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As with any other type, you can leave it to Swift to infer the function type when you assign a function to a constant or variable:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あらゆる他の型と同様に、あなたが関数を定数または変数に代入するとき、あなたはスウィフトに関数型を推論するように任せることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As with arrays, you can create an empty Dictionary of a certain type by using initializer syntax:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列と同様に、あなたは、特定の型の空のDictionaryを作成することが、イニシャライザ構文を使うことで行えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As with arrays, you don’t have to write the type of the dictionary if you’re initializing it with a dictionary literal whose keys and values have consistent types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列と同様に、キーと値が首尾一貫した型をもつ辞書リテラルでそれを初期化しているならば、あなたは辞書の型を書く必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As with computed properties, subscript declarations support reading and writing the value of the accessed elements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>計算プロパティと同様に、添え字宣言はアクセスされた要素の値を読み書きすることをサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As with computed properties, you can choose not to specify the setter’s (newValue) parameter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>計算プロパティと同様に、あなたはセッターの(newValue)パラメータを指定しないほうを選ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As with constant declarations, if the variable name is a tuple pattern, the name of each item in the tuple is bound to the corresponding value in the initializer expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数宣言と同様に、変数名がタプルパターンであるならば、タプルの中の各項目の名前はイニシャライザ式の対応する値に縛りつけられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As with function and method parameters, initialization parameters can have both a parameter name for use within the initializer’s body and an argument label for use when calling the initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数とメソッドのパラメータと同様に、初期化パラメータは、イニシャライザの本文内で使用するためのパラメータ名とイニシャライザを呼ぶ時に使用するための引数ラベルの両方を持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As with function and method parameters, the types of an initializer’s parameters can’t be more private than the initializer’s own access level.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数やメソッドパラメータと同様に、イニシャライザのパラメーターの型は、そのイニシャライザ自身のアクセス水準よりも非公開にすることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As with methods, properties, and subscripts, you need to mark overridden designated initializers with the override declaration modifier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メソッド、プロパティ、そして添え字と同様に、あなたはオーバーライドした指定イニシャライザをoverride宣言修飾子で印する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As with optionals, if you don’t provide an initial value when you declare an implicitly unwrapped optional variable or property, its value automatically defaults to nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルと同様に、あなたが暗黙的にアンラップされるオプショナルの変数やプロパティに初期値を提供しないならば、その値は自動的に省略時のnilになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As with other examples of type safety in Swift, this approach avoids accidental errors and ensures that the intention of a particular section of code is always clear.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトにおける型安全に関する他の例と同様に、このやり方は、偶然のエラーを避けること、そしてコードの特定の節の意図を常にはっきりさせることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As with other protocol member declarations, these property declarations declare only the getter and setter requirements for types that conform to the protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>他のプロトコルメンバー宣言と同様に、これらのプロパティ宣言はそのプロトコルに準拠する型のためのゲッターとセッター要件だけを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As with prefix operators, postfix operator declarations don’t specify a precedence level.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>接頭辞演算子と同様に、接尾辞演算子宣言は、優先順位レベルを指定しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As with read-only computed properties, you can simplify the declaration of a read-only subscript by removing the get keyword and its braces:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>読み出し専用の計算プロパティでのように、あなたは読み出し専用の添え字の宣言を単純化することが、getキーワードとそれの波括弧を取り除くことによって行えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As with strong reference cycles between two class instances, you declare each captured reference to be a weak or unowned reference rather than a strong reference.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２つのクラスインスタンスの間の強い参照循環と同様に、あなたは各捕らえられた参照が強い参照というよりは弱いまたは非所有参照であると宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As with the closed range operator, the value of a must not be greater than b.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>完結範囲演算子と同じように、aの値はbより大きくてはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As with the default initializer above, if you want a public structure type to be initializable with a memberwise initializer when used in another module, you must provide a public memberwise initializer yourself as part of the type’s definition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上記の省略時のイニシャライザと同様に、あなたがある公開の構造体型を別のモジュール内で使うときにメンバー関連イニシャライザを使って初期化できるようにしたいならば、あなたは公開のメンバー関連イニシャライザをあなた自身でその型定義の一部として提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As with type property requirements, you always prefix type method requirements with the static keyword when they’re defined in a protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型プロパティ要件と同様に、あなたは常に型メソッド要件の前に、それらがプロトコルにおいて定義されるとき、staticキーワードを置きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As you’ll see in Shorthand Getter Declaration, property getters can also use an implicit return.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが略記ゲッター宣言で見るように、プロパティゲッターもまた暗黙的なreturnを使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Assertions and Preconditions</seg>
      </tuv>
      <tuv lang="ja">
        <seg>表明と前提条件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Assertions help you find mistakes and incorrect assumptions during development, and preconditions help you detect issues in production.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>表明は、あなたが失策や間違った想定を見つけるのを開発中に助けます、そして前提条件は、あなたが製品における問題点を見抜くのを助けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Assigning Constant Properties During Initialization</seg>
      </tuv>
      <tuv lang="ja">
        <seg>初期化の間に定数プロパティを割り当てる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Assigning to self Within a Mutating Method</seg>
      </tuv>
      <tuv lang="ja">
        <seg>変更メソッド内部でselfに代入する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Assignment Operator</seg>
      </tuv>
      <tuv lang="ja">
        <seg>代入演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Assignment is performed from each part of the value to the corresponding part of the expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>代入は、値の各部分から式の対応する部分へと実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Associated Types</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関連型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Associated Types in Action</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関連型の動作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Associated Types with a Generic Where Clause</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体where節を持つ関連型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Associated Values</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関連値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Associated types are similar to type parameters in generic parameter clauses, but they’re associated with Self in the protocol in which they’re declared.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関連型は、総称体パラメータ節の中の型パラメータに似ています、しかしそれらは、それらが宣言されるプロトコルにおいてSelfと結び付けられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Associated types are specified with the associatedtype keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関連型は、associatedtypeキーワードで指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Associated values are set when you create a new constant or variable based on one of the enumeration’s cases, and can be different each time you do so.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関連値は、あなたが列挙のケース節のうちの１つに基づいて新しい定数または変数を作るときに設定されます、そしてあなたがそうするたびに違ったものにすることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Assuming that you provide default values for any new properties you introduce in a subclass, the following two rules apply:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが省略時の値をあなたがサブクラスで導入するあらゆる新しいプロパティに用意すると仮定して、以下の２つの規則が適用されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Asynchronous Functions and Methods</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非同期の関数とメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Asynchronous Sequences</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非同期シーケンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>At compile time, a key-path expression is replaced by an instance of the KeyPath [https://developer.apple.com/documentation/swift/keypath] class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コンパイル時に、キーパス式はKeyPath [https://developer.apple.com/documentation/swift/keypath]クラスのインスタンスによって置き換えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>At compile time, the key-path string expression is replaced by a string literal.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コンパイル時で、キーパス文字列式は文字列リテラルによって置き換えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>At least one is a write access or a nonatomic access.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>少なくとも１つが書き込みアクセスか非アトミックアクセスである。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>At parse time, an expression made up of infix operators is represented as a flat list.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構文解析の時、接中辞演算子から成り立つ式は、平坦なリストとして表わされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>At runtime, if the cast succeeds, the value of expression is wrapped in an optional and returned; otherwise, the value returned is nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>実行時に、キャストが成功したならば、式の値がひとつのオプショナルの中にラップされて返されます；そうでなければ返される値はnilです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>At the end of resize(to:), the return statement checks $height and $width to determine whether the property wrapper adjusted either height or width.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>resize(to:)の終わりで、return文は$heightと$widthを確認して、プロパティラッパーがheightまたはwidthのどちらを調節したかを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>At the end of the for-in loop, the values of movieCount and songCount contain a count of how many MediaItem instances were found of each type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>for-inループの終わりに、movieCountとsongCountの値は、各型のMediaItemインスタンスがどれくらい見つけられたかの総数を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>At the end of the matching process, all trailing closures must have a match.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>合致処理の終わりで、全ての後付クロージャはある合致を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>At the start of the game, the player is on “square zero”.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ゲームの開始時点で、プレーヤーは−「正方形ゼロ」の上にいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>At this point, the original Barcode.upc and its integer values are replaced by the new Barcode.qrCode and its string value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この点で、最初のBarcode.upcおよびその整数値は、新しいBarcode.qrCodeおよびその文字列値と取り替えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Attempting to access an index outside of a string’s range or a Character at an index outside of a string’s range will trigger a runtime error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある文字列の範囲外のインデックスにまたはある文字列の範囲外のインデックスでCharacterにアクセスを試みることは、実行時エラーの引き金となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Attempting to do so is reported as an error when your code is compiled:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そうしようとすることは、あなたのコードがコンパイルされる時にエラーとして報告されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Attempting to do so results in a compile-time error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そうしようとすることは、それでコンパイル時エラーという結果となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Attributes</seg>
      </tuv>
      <tuv lang="ja">
        <seg>属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Autoclosures</seg>
      </tuv>
      <tuv lang="ja">
        <seg>自動クロージャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Automatic Initializer Inheritance</seg>
      </tuv>
      <tuv lang="ja">
        <seg>自動的なイニシャライザ継承</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Automatic Reference Counting</seg>
      </tuv>
      <tuv lang="ja">
        <seg>自動参照カウント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Availability Condition</seg>
      </tuv>
      <tuv lang="ja">
        <seg>有効性条件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Avoid combining multiple instances of the ternary conditional operator into one compound statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>三項条件演算子を使用したもの複数を１つの複合文に結合することを避けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Avoid using #filePath outside of tests, build scripts, or other code that doesn’t become part of the shipping program.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>#filePathを、テスト、スクリプトのビルド、または出荷プログラムの一部とはならないその他のコード以外で使うのを避けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Avoiding default fallthrough means that Swift switch statements are much more concise and predictable than their counterparts in C, and thus they avoid executing multiple switch cases by mistake.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>何もしなくても抜け落ちることを避けることは、スウィフトのswitch文がCでのそれに対応する物よりずっと簡潔で予測できること、そしてそれゆえに、それは誤って複数のswitchケース節を実行することを回避することを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Await Operator</seg>
      </tuv>
      <tuv lang="ja">
        <seg>await演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Backslash (\\)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>バックスラッシュ（\\）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Based on the values of enteredDoorCode, passedRetinaScan, and hasDoorKey, the first two subexpressions are false.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>enteredDoorCode、passedRetinaScan、そしてhasDoorKeyの値に基づいて、最初の２つの下位の式はfalseです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Basic Operators</seg>
      </tuv>
      <tuv lang="ja">
        <seg>基本の演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Be careful to ensure that operator interactions still behave in the way you intend when porting existing code to Swift.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>既存のコードをスウィフトに移植するとき、依然としてあなたが意図するやり方で演算子相互作用が振る舞うことを確実にするように注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Be extended to expand their functionality beyond a default implementation</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらの機能性を元の実装を越えて広げるために、拡張されます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Be warned, though—this function doesn’t compile, for reasons explained after the example:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>注意するように、とは言うものの ― この関数はコンパイルしません、この例の後に説明される理由のために：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because 1 is less than 2, (1, "zebra") is considered less than (2, "apple"), regardless of any other values in the tuples.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>1は2より少ないことから、(1, "zebra")は(2, "apple")より少ないとみなされます、タプルの中のあらゆる他の値に関係なく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because BlackjackCard is a structure with no custom initializers, it has an implicit memberwise initializer, as described in Memberwise Initializers for Structure Types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>BlackjackCardがあつらえのイニシャライザのない構造体であるので、構造型のためのメンバー関連イニシャライザで記述されるように、それは暗黙のメンバー関連イニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because Int and Double, for example, both conform to the Comparable protocol, this function accepts arguments of either type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、IntとDoubleは両方ともComparableプロトコルに準拠するので、この関数はどちらの型の引数でも受け入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because capitalCity has a default nil value, a new Country instance is considered fully initialized as soon as the Country instance sets its name property within its initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>capitalCityが省略時のnil値を持つので、新しいCountryインスタンスは、Countryインスタンスがそのイニシャライザ内でそのnameプロパティを設定するとすぐに、完全に初期化されると見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because john.residence is nil, this optional chaining call fails in the same way as before.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>john.residenceがnilであるため、このオプショナル連鎖呼び出しは前と同じやり方で失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because playerOne is an optional, it’s qualified with an exclamation point (!) when its coinsInPurse property is accessed to print its default number of coins, and whenever its win(coins:) method is called:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>playerOneがオプショナルであることから、それは感嘆符（!）で修飾されます、それのもつcoinsInPurseプロパティがその省略時のコイン数を出力するためにアクセスされる時に、そして何時でもそれのwin(coins:)メソッドが呼ばれる時に：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because rangeOfFourItems is declared as a constant (with the let keyword), it isn’t possible to change its firstValue property, even though firstValue is a variable property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>rangeOfFourItemsが定数（letキーワードを使って）として宣言されるので、たとえfirstValueが変数プロパティであるとしても、そのfirstValueプロパティを変えることは可能ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because T is a placeholder, Swift doesn’t look for an actual type called T.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Tがプレースホルダであるので、スウィフトはTと呼ばれる実際の型を捜しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because generator is known to adopt RandomNumberGenerator, it’s guaranteed to have a random() method to call.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>generatorがRandomNumberGeneratorを採用すると知られているので、それはrandom()メソッドを呼ぶことを保証されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because #fileID doesn’t embed the full path to the source file, unlike #filePath, it gives you better privacy and reduces the size of the compiled binary.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>#fileIDは、#filePathとは違い、ソースファイルへの完全パスを埋め込みません、それはあなたにより良いプライバシーを与えます、そしてコンパイル済みバイナリの大きさを減らします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because userDefinedColorName is nil, the expression userDefinedColorName ?? defaultColorName returns the value of defaultColorName, or "red".</seg>
      </tuv>
      <tuv lang="ja">
        <seg>userDefinedColorNameはnilなので、式userDefinedColorName ?? defaultColorNameは、defaultColorNameの値、すなわち"red"を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because Void is a type alias for (), you can use it to write an empty tuple type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Voidが()に対する型エイリアスであることから、あなたはそれを使って空のタプル型を書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because beginning is a substring of greeting, it reuses the memory that greeting uses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>beginningがgreetingの下位文字列であることから、それはgreetingが使うメモリを再利用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because makeASandwich() can throw an error, the function call is wrapped in a try expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>makeASandwich()はエラーをスロー可能なので、この関数呼び出しはtry式で包まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because Resolution is a structure, a copy of the existing instance is made, and this new copy is assigned to cinema.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Resolutionが構造体であるので、既存のインスタンスのコピーが作成されます、そして、この新しいコピーはcinemaに代入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because item is a MediaItem instance, it’s possible that it might be a Movie; equally, it’s also possible that it might be a Song, or even just a base MediaItem.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>itemがMediaItemインスタンスであるので、それがMovieであるかもしれない可能性があります；等しく、それがSongかもしれない可能性もまたあります、または単に基盤MediaItemであることさえも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because update(with:) doesn’t contain any suspension points, no other code can access the data in the middle of an update.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>update(with:)がまったく中断地点を含まないことから、１つとして他のコードは更新の中途でデータにアクセスできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because $1 is the shorthand argument with highest number, the closure is understood to take two arguments.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>$1は最も高い数をもつ略記引数であることから、クロージャは２つの引数を取ると理解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because 0x000099 already equals 0x99, which has a decimal value of 153, this value is used without shifting it to the right,</seg>
      </tuv>
      <tuv lang="ja">
        <seg>0x000099はもう既に0x99と等しいので、それは10進数の153を持ちます、この値はそれを右へとシフトすることなく使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because AutomaticallyNamedDocument copes with the empty string case in a different way than its superclass, its initializer doesn’t need to fail, and so it provides a nonfailable version of the initializer instead.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>AutomaticallyNamedDocumentが空の文字列の場合をそれのスーパークラスと異なるやり方でうまく処理するので、それのイニシャライザは失敗する必要はありません、それでそれはそうせずに、失敗できない改作のイニシャライザを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because IntStack conforms to all of the requirements of the Container protocol, Swift can infer the appropriate Item to use, simply by looking at the type of the append(_:) method’s item parameter and the return type of the subscript.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>IntStackがContainerプロトコルの要件の全てに準拠するので、スウィフトは、単にappend(_:)メソッドのitemパラメータの型、そして、添え字の戻り型を見ることによって、使用するのに適切なitemを推論することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because Person conforms to both protocols, this call is valid, and the wishHappyBirthday(to:) function can print its birthday greeting.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Personが両方のプロトコルに準拠するので、これは有効な呼び出しです、それでwishHappyBirthday(to:)関数はその誕生日のお祝いを出力できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because game is known to conform to the DiceGame protocol, it’s guaranteed to have a dice property, and so the gameDidStart(_:) method is able to access and print the dice’s sides property, regardless of what kind of game is being played.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>gameがDiceGameプロトコルに従うと知られているので、それはdiceプロパティを持つと保証されます、なので、gameDidStart(_:)メソッドは、どんな種類のゲームがプレイされているかに関係なく、diceのsidesプロパティにアクセスして出力することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because john.residence is currently nil, the subscript call fails:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>john.residenceが現在nilなので、添え字呼び出しは失敗します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because userDefinedColorName is of an optional type, you can use the nil-coalescing operator to consider its value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>userDefinedColorNameがオプショナル型であるため、あなたはその値を考慮するためにnil合体演算子を使うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because anotherPoint is always a tuple of two values, this case matches all possible remaining values, and a default case isn’t needed to make the switch statement exhaustive.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>anotherPointが常に２つの値のタプルであることから、このケース節は全てのあり得る残りの値にマッチします、そしてdefaultケース節はこのswitch文を網羅的にするのに必要ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because Swift is type safe, it performs type checks when compiling your code and flags any mismatched types as errors.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトが型安全であるので、それは、あなたのコードをコンパイルするとき型チェックを実行して、あらゆる組合せを誤った型をエラーとして合図します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because Swift manages memory automatically, most of the time you don’t have to think about accessing memory at all.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトはメモリを自動的に管理することから、ほとんどの場合あなたはメモリアクセスについて考える必要は全くありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because Swift’s switch statement is exhaustive and doesn’t allow empty cases, it’s sometimes necessary to deliberately match and ignore a case in order to make your intentions explicit.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトのswitch文は網羅的でありそして中身が空のケース節を許さないので、あなたの意図を明確にするために故意にあるケース節にマッチしてから無視することが時々必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because a throw statement immediately transfers program control, an item will be vended only if all of these requirements are met.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>throw文が直ちにプログラム制御を移すので、これらの必要なものすべてが満たされる場合にのみ項目は販売されることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because a credit card will always have a customer, you define its customer property as an unowned reference, to avoid a strong reference cycle:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クレジットカードが常にひとりの顧客を持つので、強い参照循環を避けるために、あなたはそのcustomerプロパティを非所有参照として定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because a failed assertion or precondition indicates an invalid program state, there’s no way to catch a failed assertion.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>失敗した表明または前提条件は無効なプログラム状態を示すことから、失敗した表明を受け止めるための方法はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because a selector is created at compile time, not at runtime, the compiler can check that a method or property exists and that they’re exposed to the Objective-C runtime.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるセレクタが作成されるのはコンパイル時であり、実行時でないので、コンパイラはそのメソッドまたはプロパティが存在すること、そしてそれらがObjective-Cランタイムに露出されていることを確かめることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because a weak reference doesn’t keep a strong hold on the instance it refers to, it’s possible for that instance to be deallocated while the weak reference is still referring to it.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>弱い参照がそれが言及するインスタンスに対する強い支配力を保たないので、弱い参照がまだそれに言及している間にそのインスタンスが割り当て解除されることは可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because addition isn’t part of the essential behavior for a vector, the type method is defined in an extension of Vector2D rather than in the main structure declaration of Vector2D.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>加算はベクトルの欠くことのできない挙動の部分ではないので、この型メソッドはVector2Dの拡張において定義されます、Vector2Dの主構造定義においてではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because all keys in the literal are of the same type as each other, and likewise all values are of the same type as each other, Swift can infer that [String: String] is the correct type to use for the airports dictionary.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このリテラルの全てのキーが互いに同じ型である、そして全ての型が互いに他と同じ型であるので、スウィフトは、[String: String]がairports辞書に使うために適切な型であると推測することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because all of the result builder’s functionality is exposed through static methods, you don’t ever initialize an instance of that type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>リザルトビルダーのもつ機能性の全ては静的メソッドを通して露出されることから、あなたは決してその型のインスタンスを初期化しないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because all of the types can be inferred, the return arrow (-&gt;) and the parentheses around the names of the parameters can also be omitted:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型の全てが推論されることができるので、戻り矢印（-&gt;）と、パラメータの名前のまわりの丸括弧もまた省略することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because all properties of the ShoppingListItem class have default values, and because it’s a base class with no superclass, ShoppingListItem automatically gains a default initializer implementation that creates a new instance with all of its properties set to their default values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ShoppingListItemクラスの全てのプロパティ省略時の値を持つことから、そしてそれがスーパークラスを持たない基盤クラスであることから、ShoppingListItemは自動的に省略時のイニシャライザ実装を獲得します、それは、それのプロパティの全てをそれらの省略時の値に設定して、新しいインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because all values in the array literal are of the same type, Swift can infer that Set&lt;String&gt; is the correct type to use for the favoriteGenres variable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列リテラルの中の全ての値が同じ型であることから、スウィフトはSet&lt;String&gt;が正しい型であると推論することができ、favoriteGenres変数に使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because all values in the array literal are of the same type, Swift can infer that [String] is the correct type to use for the shoppingList variable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この配列リテラルの値の全てが同じ型であるので、スウィフトは[String]がshoppingList変数のために利用されるのに正しい型であると推測することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because an addition operator was defined earlier, you don’t need to reimplement the addition process here.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>加算演算子は以前に定義されたので、あなたはここでは加算プロセスを再実装する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because an instance isn’t deallocated until after its deinitializer is called, a deinitializer can access all properties of the instance it’s called on and can modify its behavior based on those properties (such as looking up the name of a file that needs to be closed).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>インスタンスはそれのデイニシャライザが呼ばれる後までは割り当て解除されないので、デイニシャライザはそれが呼ばれるところのインスタンスの全てのプロパティにアクセスすることができて、それらのプロパティに基づいてその挙動を修正することができます（たとえば閉じられる必要があるファイルの名前を調べることなど）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because argument labels aren’t part of a function’s type, you omit them when writing a function type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>引数ラベルは関数の型の一部ではないことから、あなたはそれらを関数型を書く時に省略します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because arrays conform to Collection and integers conform to Equatable, equalNumbers and differentNumbers can use the allEqual() method:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それら配列はCollectionに準拠し、それら整数はEquatableに準拠することから、equalNumbersとdifferentNumbersはallEqual()メソッドを使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because both of them refer to the same closure, they both increment and return the same running total.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらの両方ともが同じクロージャを参照することから、それらは両方とも漸増しますそして同じ実行総数を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because both sides of the addition are now of type UInt16, the addition is allowed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>加算の両側が今では型UInt16であるので、加算は許されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because classes are reference types, tenEighty and alsoTenEighty actually both refer to the same VideoMode instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスが参照型であるので、tenEightyとalsoTenEightyは両方とも実際に同じVideoModeインスタンスに言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because classes are reference types, it’s possible for multiple constants and variables to refer to the same single instance of a class behind the scenes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスが参照型であるので、複数の定数と変数があるクラスの同じ１つのインスタンスに言及することが舞台裏で可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because code with await needs to be able to suspend execution, only certain places in your program can call asynchronous functions or methods:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>awaitをもつコードは遂行を中断できる必要があることから、あなたのプログラムの中の特定の部分だけが非同期の関数やメソッドを呼び出すことが可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because declarations marked with the dynamic modifier are dispatched using the Objective-C runtime, they must be marked with the objc attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>dynamic修飾子で印される宣言はObjective-Cランタイムを使ってディスパッチされるので、それらはobjc属性で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because downcasting can fail, the type cast operator comes in two different forms.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ダウンキャストは失敗することがありえるので、型キャスト演算子は２つの異なる書式になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because each numeric type can store a different range of values, you must opt in to numeric type conversion on a case-by-case basis.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それぞれの数の型は、値の異なる幅を格納できるので、あなたは数の型変換を一件一件を原則に決めていかなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because fatal errors are never optimized out, unlike assertions or preconditions, you can be sure that execution always halts if it encounters a stub implementation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>致命的なエラーは決して間違って最適化されません、表明や前提条件と違います、あなたは実行が常に停止することをそれがスタブ実装に遭遇する場合には確信できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because implicit unwrapping changes the meaning of the declaration that contains that type, optional types that are nested inside a tuple type or a generic type—such as the element types of a dictionary or array—can’t be marked as implicitly unwrapped.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>暗黙的にアンラップされることがその型を含む宣言の意味することを変えることから、タプル型や総称体型の内部に入れ子にされたオプショナル型—例えば辞書や配列に属する要素型など—は、暗黙的にアンラップされるように印されることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because implicitly unwrapped optionals have the same Optional&lt;Wrapped&gt; type as optional values, you can use implicitly unwrapped optionals in all the same places in your code that you can use optionals.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>暗黙的にアンラップされるオプショナルがオプショナル値と同じOptional&lt;Wrapped&gt;型を持つことから、あなたは、あなたのコードにおいてあなたがオプショナルを使うことができるのと同じ場所すべてで暗黙的にアンラップされるオプショナルを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because it doesn’t need to return a value, the function’s definition doesn’t include the return arrow (-&gt;) or a return type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それが値を返す必要がないので、この関数の定義は戻り矢印（-&gt;）または戻り型を含みません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because it provides a default value for all of the properties it introduces and doesn’t define any initializers itself, ShoppingListItem automatically inherits all of the designated and convenience initializers from its superclass.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それが、省略時の値をそれが導入するプロパティの全てに与えて、そしてまったくイニシャライザを定義しないので、ShoppingListItemはそのスーパークラスから自動的に指定および便宜イニシャライザの全てを継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because its type is RandomNumberGenerator, code inside the Dice class can only interact with generator in ways that apply to all generators that conform to this protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それの型がRandomNumberGeneratorであることから、Diceクラスの内部のコードは、全ての生成子にこのプロトコルに準拠することを適用するという方法でgeneratorと相互作用できるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because it’s a generic type, Stack can be used to create a stack of any valid type in Swift, in a similar manner to Array and Dictionary.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それが総称体型であるので、Stackは、ArrayとDictionaryに類似したやり方で、スウィフトにおけるあらゆる有効な型のスタックを作るために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because it’s an alias, the call to AudioSample.min actually calls UInt16.min, which provides an initial value of 0 for the maxAmplitudeFound variable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それがエイリアスであるので、AudioSample.minへの呼び出しは実際にはUInt16.minを呼び、それは0の初期値をmaxAmplitudeFound変数のために提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because it’s an integer, it’s rounded down during the division, so 16 becomes 1, 58 becomes 5, and 510 becomes 51.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それが整数であるので、除算のときに端数を切り捨てられます、それで16が1に、58が5に、そして510は51になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because it’s in essence an “additive” operator, it has been given the same precedence group as additive infix operators such as + and -.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは本質的には「加法的な」演算子であるので、それは+や-といった加法的な接中辞演算子と同じ優先順位グループを与えられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because it’s marked with the lazy modifier, the DataImporter instance for the importer property is only created when the importer property is first accessed, such as when its filename property is queried:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それがlazy修飾子という特徴をもつので、importerプロパティのためのDataImporterインスタンスは、importerプロパティが最初にアクセスされるsgにだけ作成されます、例えばそのfilenameプロパティがたずねられるときなど：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because it’s not necessarily a mistake for code that calls the advance(to:) method to ignore the return value, this function is marked with the @discardableResult attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>advance(to:)メソッドを呼び出して戻り値を無視することが必ずしもコードの誤りでないことから、この関数は@discardableResult属性で印されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because it’s not practical to list every possible Character value in the example above, a default case handles any characters that aren’t matched.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>すべてのあり得るCharacter値を並べることは上の例では実際的ではないので、defaultケース節が適合しないあらゆる文字を取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because it’s of an optional type, the delegate property is automatically set to an initial value of nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それがオプショナル型であるので、delegateプロパティは自動的に初期値のnilに設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because it’s possible for a DataManager instance to manage its data without ever importing data from a file, DataManager doesn’t create a new DataImporter instance when the DataManager itself is created.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>DataManagerインスタンスにはそれのデータを管理することがファイルからデータを一度もインポートせずに可能なので、DataManagerは新しいDataImporterインスタンスの作成をDataManagerそれ自身が作成される時に行いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because it’s possible to request a key for which no value exists, a dictionary’s subscript returns an optional value of the dictionary’s value type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それに対する値が存在しないキーへの要請が可能であるので、ある辞書の添え字は、その辞書の値型のオプショナルの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because multiline string literals use three double quotation marks instead of just one, you can include a double quotation mark (") inside of a multiline string literal without escaping it.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複数行文字列リテラルは、ただ１つではなく３つの二重引用符を使います、あなたは二重引用符（"）を複数行文字列リテラルの内部にそれをエスケープすることなく含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because nothing is marked await on these lines, there aren’t any possible suspension points.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>まったくawaitで印されるものがこれらの行にないので、可能な中断地点は何もありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because of the explicit relationship between tasks and task groups, this approach is called structured concurrency.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タスクとタスクグループの間のこの明確な関係のために、この取り組みは構造化された並行性と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because of the special way that positive and negative numbers are stored, shifting either of them to the right moves them closer to zero.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>正および負の数が格納される特別な方法のため、それらのどちらでも右へシフトすることは、それらをゼロの近くに動かします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because of the unowned customer reference, when you break the strong reference held by the john variable, there are no more strong references to the Customer instance:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非所有customer参照であることから、あなたがjohn変数によって保持される強い参照を壊すとき、Customerインスタンスへの強い参照はもうそれ以上ありません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because of this behavior, the switch cases case let (x, y): and case (let x, let y): match the same values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この挙動のため、switchケース節case let (x, y):とcase (let x, let y):は、同じ値にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because of this uncertainty, the as? form of the type cast operator returns an optional value when attempting to downcast to a subclass type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この不確実性のために、サブクラス型へのダウンキャストを試みるとき、型キャスト演算子のas?形式はオプショナルの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because of this, Swift provides an automatic argument label for every parameter in an initializer if you don’t provide one.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これのため、スウィフトは、あなたがそれを独自に提供しないならば、自動的な引数ラベルをイニシャライザのあらゆるパラメータに用意します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because of this, all of the Int.Kind case values can be written in shorthand form inside the switch statement, such as .negative rather than Int.Kind.negative.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのことから、Int.Kindのケース節の値の全ては、switch文内で略記形式で書かれることができます、たとえばInt.Kind.negativeではなく.negativeのように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because of this, characters in Swift don’t each take up the same amount of memory within a string’s representation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これのため、スウィフトの中の文字は、それぞれが同じ量のメモリを文字列の表現において取るわけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because of this, it isn’t possible to guarantee that this code will work for every possible type T, and an appropriate error is reported when you try to compile the code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このため、このコードがすべての可能な型Tのために機能することを保証することは可能ではありません、それであなたがこのコードをコンパイルしようとする場合は該当するエラーが報告されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because of this, the call to john.residence?.address?.street fails.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このことから、john.residence?.address?.streetへの呼び出しは、失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because of this, the more general term instance is used.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これのため、より一般的な語インスタンスが使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because of this, the raw value initializer always returns an optional enumeration case.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのため、生の値のイニシャライザは常にオプショナルの列挙ケース節を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because of type inference, Swift requires far fewer type declarations than languages such as C or Objective-C.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型推論のため、スウィフトはCまたはObjective-Cのような言語よりはるかに少ない型宣言しか必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because one value is true, the overall expression also evaluates to true, and access is allowed:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>１つの値がtrueなので、式全体もまたtrueです、そしてアクセスは許可されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because operators are functions, they can also have long-term accesses to their in-out parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これら演算が関数であることから、それらはまた長期アクセスをそれらのin-outパラメータに対して持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because optional patterns are syntactic sugar for Optional enumeration case patterns, the following are equivalent:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルパターンはOptional列挙ケース節パターンに対する糖衣構文であるので、以下のものは等価です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because patterns represent the structure of a value rather than any one particular value, you can match them with a variety of values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>パターンがどれかひとつの特定の値ではなく値の構造を表すので、あなたはそれをいろいろな値と照合（マッチング）できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because property wrapper syntax is just syntactic sugar for a property with a getter and a setter, accessing height and width behaves the same as accessing any other property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティラッパー構文がゲッターとセッターをもつプロパティに対する単なる糖衣構文であることから、heightとwidthにアクセスすることは、何か他のプロパティと同じ挙動をします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because protocols are types, begin their names with a capital letter (such as FullyNamed and RandomNumberGenerator) to match the names of other types in Swift (such as Int, String, and Double).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルが型であるので、それらの名前を大文字で開始してください（例えばFullyNamedとRandomNumberGeneratorのように）、それによってスウィフトでの他の型の名前（例えばInt、String、およびDouble）と釣り合いがとれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because superclass A and subclass B are defined in the same source file, it’s valid for the B implementation of someMethod() to call super.someMethod().</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スーパークラスAとサブクラスBが同じソースファイルにおいて定義されるので、B実装のsomeMethod()がsuper.someMethod()を呼ぶことは有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the Rect structure provides default values for all of its properties, it receives a default initializer and a memberwise initializer automatically, as described in Default Initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Rect構造体がそのプロパティの全てに省略時の値を与えるので、省略時のイニシャライザで記述されるように、それは自動的に省略時のイニシャライザとメンバー関連イニシャライザを受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the delegate property is an optional DiceGameDelegate, the play() method uses optional chaining each time it calls a method on the delegate.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>delegateプロパティがオプショナルのDiceGameDelegateであるので、play()メソッドは、それが委任先でメソッドを呼ぶたびにオプショナル連鎖を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the first and second parameters are nonescaping functions, they can’t be passed as arguments to another nonescaping function parameter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>firstおよびsecondパラメータは非脱出関数であることから、それらは引数として別の非脱出関数パラメータとして渡されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the listPhotos(inGallery:) and downloadPhoto(named:) functions both need to make network requests, they could take a relatively long time to complete.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>listPhotos(inGallery:)およびdownloadPhoto(named:)関数の両方がネットワーク要請をする必要があることから、それらは完了するのに比較的に長い時間がかかる可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the vend(itemNamed:) method propagates any errors it throws, any code that calls this method must either handle the errors—using a do-catch statement, try?, or try!—or continue to propagate them.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このvend(itemNamed:)メソッドはそれがスローするどんなエラーも伝達するので、このメソッドを呼び出す何らかのコードは、それらのエラーを取り扱うか ― do-catch文、try?、またはtry!を使って ― またはそれらの伝達を続けるか、どちらかをしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the vend(itemNamed:) method can throw an error, it’s called with the try keyword in front of it.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>vend(itemNamed:)メソッドはエラーをスローできることから、それはそれの前のtryキーワードとともに呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the switch must have a case for every possible character, not just every alphabetic character, this switch statement uses a default case to match all characters other than a and z.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>switchは、単にすべてのアルファベット文字ではなく、すべての可能な文字に対してひとつのケース節を持たなければならないことから、このswitch文はaとzのほかのすべての文字にマッチするためにdefaultケース節を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the sorted(by:) function here expects a closure whose arguments are both strings, the shorthand arguments $0 and $1 are both of type String.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>sorted(by:)関数はここではそれの引数が両方とも文字列であるクロージャを期待することから、略記引数$0と$1は両方とも型Stringのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the x, y, and z properties are all of an Equatable type, Vector3D receives synthesized implementations of the equivalence operators.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>x、y、そしてzプロパティはみんなEquatable型なので、Vector3Dは等価演算子の合成された実装それらを受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the DiceGameDelegate protocol is class-only, you can declare the delegate to be weak to prevent reference cycles.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>DiceGameDelegateプロトコルがクラス専用であることから、あなたは委任先をweakであると宣言して参照循環を防ぐことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the return type can be a tuple type, function types support functions and methods that return multiple values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>return typeはタプル型であることが可能なので、関数型は複数の値を返す関数およびメソッドをサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the actor allows only one task at a time to access its mutable state, if code from another task is already interacting with the logger, this code suspends while it waits to access the property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>アクターが一度に１つのタスクだけにそれの可変状態へのアクセスを許可することから、別のタスクからのコードが既にloggerと相互作用しているならば、このコードはそれがプロパティにアクセスするために待つ間ずっと中断します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the arithmetic addition operator is a binary operator, this operator method takes two input parameters of type Vector2D and returns a single output value, also of type Vector2D.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>算術加算演算子は二項演算子なので、この演算子メソッドはVector2D型の２つの入力パラメーターを取り、同じくVector2D型のただ１つの出力値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the attempt to access numberOfRooms has the potential to fail, the optional chaining attempt returns a value of type Int?, or “optional Int”.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>numberOfRoomsにアクセスする試みは失敗する可能性があるので、オプショナル連鎖は型Int?の値、すなわち「オプショナルのInt」、を返すことを試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the body of the closure is so short, it can even be written on a single line:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャの本文がたいへん短いので、それは１つの行に書かれさえすることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the call to increment(forCount:) can fail for either of these two reasons, the call returns an optional Int value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>increment(forCount:)への呼び出しがこれらの２つの理由のどちらによっても失敗する可能性があるので、呼び出しはオプショナルのInt値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the closure’s body contains a single expression (s1 &gt; s2) that returns a Bool value, there’s no ambiguity, and the return keyword can be omitted.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャの本文がある単一の式（s1 &gt; s2）でBool値を返すものを含むので、曖昧さはありません、それでreturnキーワードは省略されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the data is nested, the enumeration used to store the data also needs to support nesting—this means the enumeration needs to be recursive.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>データが入れ子にされるため、データを格納するために使われる列挙もまた、入れ子をサポートする必要があります—これは列挙が再帰することを必要とするのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the function returns a String value, greet(person:) can be wrapped in a call to the print(_:separator:terminator:) function to print that string and see its return value, as shown above.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この関数はString値を返すので、上で見られるように、greet(person:)はprint(_:separator:terminator:)関数への呼び出しの中に包まれて、その文字列を出力してその戻り値を見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the function’s return type is private, you must mark the function’s overall access level with the private modifier for the function declaration to be valid:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数の戻り型が非公開であるので、あなたはこの関数宣言が有効になるために関数の全体的なアクセス水準にprivate修飾子で印しなければなりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the initializer might fail, it returns an optional Int, rather than an Int.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このイニシャライザが失敗するかもしれないので、それはIntではなくて、オプショナルのIntを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the key path string is created at compile time, not at runtime, the compiler can check that the property exists and that the property is exposed to the Objective-C runtime.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>キーパス文字列は実行時ではなく、コンパイル時に作成されるため、コンパイラはプロパティが存在することおよびプロパティがObjective-Cランタイムへと露出されることを確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the last line of badStart doesn’t end with a line break, that line gets combined with the first line of end.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>badStartの最後の行は改行で終わらないことから、その行はendの最初の行と結合されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the new Person instance has been assigned to the reference1 variable, there’s now a strong reference from reference1 to the new Person instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>新しいPersonインスタンスがreference1変数に代入されたので、現在は強い参照がreference1から新しいPersonインスタンスまで存在します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the players start off the board, on “square zero”, the board is initialized with 26 zero Int values, not 25.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プレイヤーは、「正方形ゼロ」で盤を始めることから、この盤は26個のゼロInt値で初期化されます、25ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the property wrapper doesn’t allow values higher than 12, it sets myNumber to 12 instead of 24.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティラッパーが12より高い値を許可しないので、それはmyNumberを12に設定します、24の代わりに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the sorting closure is passed as an argument to a method, Swift can infer the types of its parameters and the type of the value it returns.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ソート（分類）するクロージャが引数としてメソッドに渡されるので、スウィフトは、それのパラメータの型とそれが返す値の型を推論することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the temperature has increased to 40 degrees Fahrenheit, it’s no longer cold enough to advise wearing a scarf and so the else branch is triggered instead.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>温度が華氏40度まで増加したので、スカーフを着けることを助言するに足りるほどもはや寒くありません、それで代わりにelse分岐が作動させられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the temperature is neither too cold nor too warm to trigger the if or else if conditions, no message is printed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この気温はifまたはelse if条件の引き金になるにはあまり寒くもなくあまり暖かくもないので、メッセージは出力されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the tuple’s member values are named as part of the function’s return type, they can be accessed with dot syntax to retrieve the minimum and maximum found values:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タプルの構成要素値は、この関数の戻り型の部分で命名されるので、それらは最小および最大の見つけられた値を取り出すためにドット構文でアクセスされることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the type alias and the existing type can be used interchangeably, the type alias can’t introduce additional generic constraints.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型エイリアスと既存の型は交換可能に使われることができるので、型エイリアスは追加的な総称体制約を導入することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the value of approximateCount falls between 12 and 100, naturalCount is assigned the value "dozens of", and execution is transferred out of the switch statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>approximateCountの値が12と100の間で失敗することから、naturalCountは、値"dozens of"を代入されます、そして実行はswitch文の外に移されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the value of the condition is evaluated after the statements are executed, the statements in a repeat-while statement are executed at least once.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文が実行された後で条件の値が評価されるので、repeat-while文の中の文は少なくとも一回は実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the value of the condition is evaluated before the statements are executed, the statements in a while statement can be executed zero or more times.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文が実行される前に、条件の値が評価されるので、while文の中の文は０回またはそれ以上実行される可能性を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because there are no more strong references to the Apartment instance, it too is deallocated:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Apartmentインスタンスへの強い参照はもうこれ以上ないので、それも割り当て解除されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because there are no more strong references to the Customer instance, it’s deallocated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Customerインスタンスへの強い参照はもうないので、それは割り当て解除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because there are no more strong references to the Person instance, it’s deallocated and the tenant property is set to nil:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>もうこれ以上Personインスタンスへの強い参照はないことから、それは割り当て解除されます、そしてtenant特性はnilに設定されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because there are no other specific cases, integerToDescribe is matched by the default case.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>他のいかなる特定のケース節もないことから、integerToDescribeはdefaultケース節に適合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because there’s at least one strong reference, ARC makes sure that this Person is kept in memory and isn’t deallocated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>少なくとも１つの強い参照があるので、ARCはこのPersonがメモリの中に保たれて割り当て解除されないことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because these are value types, mutating any piece of the value mutates the whole value, meaning read or write access to one of the properties requires read or write access to the whole value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらが値型であることから、その値の何か１つを変更することは値全体を変更し、プロパティの１つに対する読み出しや書き込みアクセスを意図することは値全体への読み出しや書き込みアクセスを必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because these variables are of an optional type (Person?, not Person), they’re automatically initialized with a value of nil, and don’t currently reference a Person instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの変数がオプショナル型（Personではなく、Person?）であることから、それらは自動的にnilの値で初期化されて、今はPersonインスタンスに参照をつけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because they’re named types, you can extend their behavior to suit the needs of your program, using an extension declaration, discussed in Extensions and Extension Declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらが名前付きの型であるので、あなたはそれらの挙動を、拡張および拡張宣言で議論される拡張宣言を使って、あなたのプログラムの必要に応じて拡張することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because this convenience initializer overrides a designated initializer from its superclass, it must be marked with the override modifier (as described in Initializer Inheritance and Overriding).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この便宜イニシャライザがそれのスーパークラスからの指定イニシャライザをオーバーライドするので、それはoverride修飾子で印されなければなりません（イニシャライザの継承およびオーバーライドで記述されるように）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because this particular array has specified a value type of String, it’s allowed to store String values only.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この特定の配列がStringの値型を指定したので、それが貯蔵を許可されるのはString値のみです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because this particular set has specified a value type of String, it’s only allowed to store String values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この問題の集合が明確に指定されたStringの値型を持つことから、それはString値を格納することだけが許されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because this version of Residence stores an array of Room instances, its numberOfRooms property is implemented as a computed property, not a stored property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Residenceのこの改作がRoomインスタンスの配列を格納するので、そのnumberOfRoomsプロパティは計算プロパティとして実装されます、格納プロパティではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because your code can’t define properties that start with $ the projected value never interferes with properties you define.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたのコードが$で始まるプロパティを定義できないことから投影値は決してあなたが定義するプロパティと干渉しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Before and after the update, you can read any information from the budget and get a correct answer, as shown in the figure below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>更新の前後で、あなたはあらゆる情報を予算案から読み出して正しい答えを得ることができます、下の図で示すように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Before updating currentLevel, this method checks whether the requested new level is already unlocked.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>currentLevelを更新する前に、このメソッドは要請された新しいレベルがすでに錠を開けられるかどうか調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Before you can fix the conflicting access, you have to determine what it was intended to do.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがこのアクセス衝突を修正するためには、あなたは実行を意図されたものは何かを判定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Before your code can update max, code elsewhere reads the maximum value and the array of temperatures.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたのコードがmaxを更新可能になる前に、コードがどこか他のところで最大値と温度配列とを読み出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Behind the scenes, UInt16 has an initializer that accepts a UInt8 value, and so this initializer is used to make a new UInt16 from an existing UInt8.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>舞台裏で、UInt16はUInt8値を受け入れるイニシャライザを持ちます、それでこのイニシャライザが新しいUInt16を既存のUInt8から作るために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Behind the scenes, Swift’s compiler optimizes string usage so that actual copying takes place only when absolutely necessary.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>舞台裏で、スウィフトのコンパイラは、実際にコピーすることは絶対に必要なときだけ起こるように、文字列使用を最適化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Behind the scenes, Swift’s native String type is built from Unicode scalar values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>舞台裏で、スウィフト生得のString型はユニコードスカラー値によって組み立てられています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Between #if, #endif, and other compilation directives, the conditional compilation block can contain an implicit member expression followed by zero or more postfixes, to form a postfix expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>#if、#endif、そしてその他のコンパイル指令の間で、条件コンパイルブロックは、ある接尾辞式を形成するため、０個以上の接尾辞をその後に続ける、ある暗黙的メンバー式を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Between one and eight hexadecimal digits</seg>
      </tuv>
      <tuv lang="ja">
        <seg>１から８桁の16進数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Binary literals begin with 0b, octal literals begin with 0o, and hexadecimal literals begin with 0x.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２進のリテラルは0bから始まります、８進のリテラルは0oから始まります、そして16進のリテラルは0xから始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Binary literals contain 0 and 1, octal literals contain 0 through 7, and hexadecimal literals contain 0 through 9 as well as A through F in upper- or lowercase.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２進のリテラルは0と1を含みます、８進のリテラルは0から7までを含みます、そして、16進のリテラルは0から9までに加えて大文字または小文字でのAからFまでを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Bitwise AND Operator</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ビット単位の論理積演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Bitwise Left and Right Shift Operators</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ビット単位の左および右シフト演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Bitwise NOT Operator</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ビット単位の論理否定演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Bitwise OR Operator</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ビット単位の論理和演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Bitwise Operators</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ビット単位演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Bitwise XOR Operator</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ビット単位の排他的論理和演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Bitwise left and right shifts have the effect of multiplying or dividing an integer by a factor of two.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ビット単位の左または右シフトは、２の因数によって、ある整数を掛けるまたは割る効果を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Bitwise operators can also be useful when you work with raw data from external sources, such as encoding and decoding data for communication over a custom protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ビット単位演算子はまた、あなたが外部のソースからの生のデータを扱うとき、役に立つことがありえます、例えば、あつらえのプロトコルを越えて通信するためのデータの符号化や復号など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Blue numbers are shifted, gray numbers are discarded, and orange zeros are inserted:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>青色の数はシフトされます、灰色の数は捨てられます、そしてオレンジ色のゼロが差し込まれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Boolean values are particularly useful when you work with conditional statements such as the if statement:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがif文のような条件つきの文で作業するとき、ブールの値は特に役に立ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Boolean values are referred to as logical, because they can only ever be true or false.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ブールの値は、論理として参照されます、なぜならそれらは真か偽であることだけができるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Booleans</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ブール</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Both String and Substring conform to the StringProtocol [https://developer.apple.com/documentation/swift/stringprotocol] protocol, which means it’s often convenient for string-manipulation functions to accept a StringProtocol value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>StringとSubstringの両方ともStringProtocol [https://developer.apple.com/documentation/swift/stringprotocol]プロトコルに準拠します、それはStringProtocol値を受け取ることは文字列操作関数それぞれにとってしばしば都合が良いのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Both await and async-let allow other code to run while they’re suspended.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>awaitとasync-letの両方は、それらが中断される間に他のコードが動作するのを許可します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Both C1 and C2 are type parameters for two container types to be determined when the function is called.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>C1とC2の両方は、２つのコンテナ型のための型パラメータで、関数が呼ばれるときに決定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Both playerInformation.health and playerInformation.energy are passed as in-out parameters, which means balance(_:_:) needs write access to them for the duration of the function call.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>playerInformation.healthとplayerInformation.energyの両方ともin-outパラメータとして渡されます、それはbalance(_:_:)がそれらへの書き込みアクセスを関数呼び出しの期間中に必要とすることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Both an empty tuple expression and an empty tuple type are written () in Swift.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>空のタプル式と空のタプル型は両方とも、()とスウィフトでは書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Both can:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>両方とも以下のことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Both classes correctly conform to the HasArea protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>両方のクラスは、正しくHasAreaプロトコルに従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Both constants can now be used independently:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>両方の定数は、今や独立して使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Both designated initializers must call the single designated initializer from the superclass, to satisfy rule 1 from above.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上記の規則１を満たすために、両方の指定イニシャライザは、スーパークラスからその１つだけある指定イニシャライザを呼ばなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Both functions are generic because the types they rely on are generic, and the type parameters to the function pass along the type information needed by FlippedShape and JoinedShape.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>両方の関数は総称体です、なぜならそれらが頼りにする型が総称体であるからです、そして関数への型パラメータは、FlippedShapeとJoinedShapeによって必要とされる型情報を伝達します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Both functions have a type of (Int) -&gt; Int:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>両方の関数は、(Int) -&gt; Intの型を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Both functions include a generic where clause that adds type constraints to the generic Item type parameter from the original declaration of Container.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>両方の関数は、ある総称体where節を含みます、それは型制約をContainerの元の宣言由来の総称体Item型パラメータに加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Both initializers can be used to create a new Color instance, by providing named values for each initializer parameter:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>両方のイニシャライザとも、新しいColorインスタンスを作成するために、各イニシャライザ・パラメータに名前を付けられた値を提供することで、使用されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Both initializers convert their single argument into the corresponding Celsius value and store this value in a property called temperatureInCelsius.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>両方のイニシャライザは、それらのただ１つの引数を相当する摂氏の値に変えて、その値をtemperatureInCelsiusと呼ばれるプロパティに保管します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Both integers and floats can be padded with extra zeros and can contain underscores to help with readability.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>整数と浮動小数点は、余分のゼロを詰められることができ、読みやすくするためにアンダースコアを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Both of these classes also define a deinitializer, which prints the fact that an instance of that class is being deinitialized.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらのクラスの両方ともデイニシャライザを定義します、それは、そのクラスのインスタンスがデイニシャライズされているという事実を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Both of these extended grapheme clusters are valid ways to represent the character é, and so they’re considered to be canonically equivalent:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの拡張書記素クラスタの両方とも、文字éを表わす有効な方法です、そういうわけでそれらは正準等価とみなされます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Both of these operations return a task handle that lets you interact with the task—for example, to wait for its result or to cancel it.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これら演算の両方ともあるタスクハンドルを返します、それはあなたにタスクと相互作用させるものです — 例えば、それの結果を待つためまたはそれを取り消すために。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Both of these representations qualify as a single Character value in Swift:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの表し方の双方とも、スウィフトでは単一のCharacter値としての基準を満たします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Both of these values can be changed by #sourceLocation, as described in Line Control Statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの値の両方とも、#sourceLocationによって変更されることが、行制御文で記述されるように可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Both of these variables have an initial value of nil, by virtue of being optional:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルである利点によって、これらの変数の両方とも、nilの初期値を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Both patterns include a binding for distance and distance is an integer in both patterns—which means that the code in the body of the case can always access a value for distance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>両方のパターンは、distanceに対する束縛を含みます、そしてdistanceは両方のパターンにおいて整数です—それはcaseの本文のコードは常にdistanceに対する値にアクセスできることを編みします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Both place their entire definition within a pair of braces:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>両方とも、それらの全ての定義を一対の波括弧の範囲内に置きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Both properties are inferred to be of type Double by assigning a default value of 0.0.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>両方のプロパティは、省略時の値の0.0を代入することによってDouble型であると推測されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Both protocols are adopted by a structure called Person.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>両方のプロトコルは、Personと呼ばれる構造体によって採用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Both the protocol and the optional requirement must be marked with the @objc attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルとオプショナル要件の両方は、@objc属性で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Braces around the body are required.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>本文のまわりの波括弧は必須です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Branch Statements</seg>
      </tuv>
      <tuv lang="ja">
        <seg>分岐文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Branch statements allow the program to execute certain parts of code depending on the value of one or more conditions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>分岐文は、プログラムが１つ以上の条件の値に従いコードの特定の部分を実行するようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Break Statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ブレーク文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Break in a Loop Statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ループ文の中断</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Break in a Switch Statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>switch文の中断</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Bridging lets you use an expression of a Swift standard library type such as String as its corresponding Foundation type such as NSString without needing to create a new instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ブリッジは、あなたにStringのようなスウィフト標準ライブラリ型の式を、NSStringのようなそれの対応しているFoundation型として使用させます、新しいインスタンスを作成する必要なしに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Builds a final result from a partial result.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある最終的な結果をある部分的な結果から組み立てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Builds a partial result from a partial result that can be nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある部分的結果を、nilであることが可能なある部分的結果から組み立てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Builds a partial result from an array of partial results.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある部分的結果を、部分的結果それらからなるある配列から組み立てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Builds a partial result from an expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある部分的結果をある式から組み立てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Builds a partial result that propagates or erases type information outside a compiler-control statement that performs an availability check.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある部分的結果を組み立てます、それはある有効性検査を実行するコンパイラ制御文の外側に型情報を伝播または消去するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Builds a partial result whose value varies depending on some condition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある部分的結果を組み立てます、それの値はなんらかの条件に依存して変化するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But if you provide a setter clause, you must also provide a getter clause.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしあなたがセッター節を提供するならば、あなた同様にゲッター節を提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By constraining a collection’s elements to the Equatable protocol, a part of the standard library, you can use the == and != operators to check for equality and inequality between two elements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるコレクションの持つ要素をEquatableプロトコル、標準ライブラリの１つ、に制約することで、あなたは==と!=演算子を使って同等性と同一性を２つの要素間で確認できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By contrast, C requires you to insert an explicit break statement at the end of every switch case to prevent fallthrough.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>対照的に、Cはあなたに抜け落ちること（フォールスルー）を防ぐために明示的にbreak文をあらゆるswitchケース節の終わりに書き入れることを要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By creating an extension on the protocol, all conforming types automatically gain this method implementation without any additional modification.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張をプロトコル上に作成することによって、すべての準拠している型が自動的にこのメソッド実装をなんら追加の修正なしに手に入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By default, Swift assigns the raw values starting at zero and incrementing by one each time, but you can change this behavior by explicitly specifying values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>初期状態で、スウィフトはゼロで開始して毎回１つ増加させながら生の値を割り当てます、しかしあなたは明示的にそれらの値を指定することでこの挙動を変更できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By default, Swift prevents unsafe behavior from happening in your code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>初期状態では、スウィフトはあなたのコードにおける偶発事由来の安全でない挙動を防止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By default, a closure expression captures constants and variables from its surrounding scope with strong references to those values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>初期状態では、クロージャ式は、それの周囲のスコープから定数や変数をそれらの値への強い参照を使ってキャプチャします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By default, any new Bicycle instance you create will not have a basket.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>特に何もしなければ、あなたが作成するあらゆる新しいBicycleインスタンスは、入れ物かごを持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By default, custom classes and structures don’t have an implementation of the equivalence operators, known as the equal to operator (==) and not equal to operator (!=).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>初期状態では、あつらえのクラスと構造体は、「同等」演算子（==）そして「不等」演算子（!=）として知られる、等価演算子の実装を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By default, floating-point literals are expressed in decimal (with no prefix), but they can also be expressed in hexadecimal (with a 0x prefix).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>初期状態で、浮動小数点リテラルは10進において（接頭辞なしで）表されます、しかしそれらはまた、16進法において（0x接頭辞で）表されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By default, functions use their parameter names as labels for their arguments.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>特に何もしなくとも、関数はそれらのパラメータ名をそれらの引数のラベルとして使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By default, initializers declared in a superclass aren’t inherited by subclasses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>初期状態では、スーパークラスで宣言されるイニシャライザは、サブクラスによって継承されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By default, integer literals are expressed in decimal; you can specify an alternate base using a prefix.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>初期状態では、整数リテラルは10進法で表されます；あなたは、接頭辞を使用して代替の基数を指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By default, members of an actor are isolated to that actor.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>初期状態では、あるアクターのメンバーそれらはそのアクターへと隔離されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By default, most declarations are implicitly marked with the internal access-level modifier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>省略時では、大部分の宣言は暗黙的にinternalアクセス水準修飾子で印されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By default, only entities marked as open or public are accessible to other modules.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>特に何もしない状態では、開放または公開と印される実在だけが他のモジュールに利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By default, parameter names are also used as argument labels.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>特に何もしなければ、パラメータ名はまた引数ラベルとしても使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By default, parameters use their parameter name as their argument label.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>特に何もしなければ、パラメータはそれらのパラメータ名をそれらの引数ラベルとして使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By default, the asHTML property is assigned a closure that returns a string representation of an HTML tag.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>特に何もしなければ、asHTMLプロパティは、あるHTMLタグの文字列表現を返すクロージャを代入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By default, the ~= operator compares two values of the same type using the == operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>初期状態で、~=演算子は、同じ型の２つの値を==演算子を使用して比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By default, the function terminates the line it prints by adding a line break.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>初期状態では、この関数はそれが出力する行を改行を加えて終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By default, the parameters used in subscripting don’t have argument labels, unlike functions, methods, and initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>初期状態で、添字において使用されるパラメータは引数ラベルを持ちません、関数、メソッド、およびイニシャライザとは違って。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By default, the properties of a value type can’t be modified from within its instance methods.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>初期状態では、ある値型に属するプロパティは、それのインスタンスメソッド内から修正されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By default, types that conform to a protocol must implement all properties, methods, and subscripts declared in the protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>初期状態では、あるプロトコルに準拠する型は、そのプロトコルにおいて宣言される全てのプロパティ、メソッド、そして添え字を実装しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By default, variables, constants, and other named declarations that are declared at the top-level of a source file are accessible to code in every source file that’s part of the same module.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>初期状態では、あるソースファイルのトップレベルで宣言される変数、定数、そして他の名前をつけられる宣言は、同じモジュールの一部であるすべてのソースファイルの中のコードにアクセス可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By including arguments to the property wrapper, you can set up the initial state in the wrapper or pass other options to the wrapper when it’s created.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>引数をプロパティラッパーに含めることによって、あなたは初期状態をラッパーにおいて準備することまたは他のオプションをラッパーに渡すことが、それが作成される時に可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By making if x = y invalid, Swift helps you to avoid these kinds of errors in your code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>if x = yを無効にすることによって、スウィフトはあなたがこれらの種類のエラーをあなたのコードにおいて避けるのを手伝います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By returning a tuple with two distinct values, each of a different type, the function provides more useful information about its outcome than if it could only return a single value of a single type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２つの別の値をそれぞれ異なる型で持つひとつのタプルを返すことによって、その関数は、それが１つの型の１つの値を返すことができるだけよりも、その結果に関するより役に立つ情報を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By their nature, two instantaneous accesses can’t happen at the same time.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>本質的に、２つの即時アクセスは同時に起こりえません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By wrapping the function call in a do statement, any errors that are thrown will be propagated to the provided catch clauses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その関数呼び出しをdo文の中に包み込むことによって、スローされるどんなエラーも添付のcatch節に伝えられるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Call a function by following its name with a list of arguments in parentheses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数は、その名前の後に丸括弧に入れた引数の目録（リスト）を続けることで呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Call asynchronous functions with async-let when you don’t need the result until later in your code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非同期関数をasync-letと共に呼び出してください、あなたが結果をあなたのコードにおいてもっと後まで必要としない場合は。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Call asynchronous functions with await when the code on the following lines depends on that function’s result.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非同期関数をawaitと共に呼び出してください、続く行でのコードがその関数の結果に依存する場合は。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Call one of the initializers declared within the actor, as described in Initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのアクターの内部で宣言されるイニシャライザの内の１つを呼び出してください、イニシャライザで記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Call one of the initializers declared within the class, as described in Initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのクラス内で宣言されるイニシャライザのうちの１つを呼び出してください、イニシャライザで記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Call one of the initializers declared within the structure, as described in Initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その構造体の内部で宣言されるイニシャライザの内の１つを呼び出してください、イニシャライザで記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Calling Asynchronous Functions in Parallel</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非同期関数を並列に呼び出す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Calling Methods Through Optional Chaining</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル連鎖を通してメソッドを呼ぶ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Calling an asynchronous function with await runs only one piece of code at a time.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非同期関数をawaitとともに呼び出すことは、ただコードの１断片を一度実行するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Calling it with playerOneScore and playerTwoScore as arguments doesn’t produce a conflict—there are two write accesses that overlap in time, but they access different locations in memory.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それをplayerOneScoreとplayerTwoScoreを引数として使って呼び出すことは衝突を生み出しません — 時間内にオーバーラップする２つの書き込みアクセスがあります、しかしそれらはメモリ中の異なる位置にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Calling the function multiple times shows this behavior in action:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この関数を複数回呼ぶことは、活動中にこの挙動を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Calling the original incrementer (incrementByTen) again continues to increment its own runningTotal variable, and doesn’t affect the variable captured by incrementBySeven:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初のインクリメンタ（incrementByTen）を再び呼ぶことは、それ独自のrunningTotal変数を増加させることを継続します、そしてincrementBySevenによってキャプチャされる変数に影響しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Calling the superclass’s initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スーパークラスのイニシャライザを呼ぶ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Calling this initializer returns a Rect instance whose origin and size properties are both initialized with the default values of Point(x: 0.0, y: 0.0) and Size(width: 0.0, height: 0.0) from their property definitions:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このイニシャライザを呼ぶことはRectインスタンスを返します、それは、originとsizeプロパティが両方ともそれらのプロパティ定義からの省略時の値のPoint(x: 0.0, y: 0.0)とSize(width: 0.0, height: 0.0)で初期化されるものです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Calls to a throwing function or method must be wrapped in a try or try! expression (that is, in the scope of a try or try! operator).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スロー関数またはメソッドに対する呼び出しは、tryまたはtry!式の中に（即ち、tryまたはtry!演算子のスコープの中に）包まれなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Calls to an asynchronous function or method must be wrapped in an await expression—that is, they must be in the scope of an await operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非同期関数またはメソッドに対する呼び出しは、await式の中に包まれなければなりません — 即ち、それらはawait演算子のスコープの中になければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Capture Lists</seg>
      </tuv>
      <tuv lang="ja">
        <seg>キャプチャリスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Capturing self in an escaping closure makes it easy to accidentally create a strong reference cycle.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>selfを脱出クロージャの中にキャプチャすることは、誤って強い参照循環を作りやすくします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Capturing Values</seg>
      </tuv>
      <tuv lang="ja">
        <seg>値を捕獲する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Capturing by reference ensures that runningTotal and amount don’t disappear when the call to makeIncrementer ends, and also ensures that runningTotal is available the next time the incrementer function is called.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>参照を捕獲することは、runningTotalとamountが、makeIncrementerへの呼び出しが終わる時に消えてなくならないことを確かなものにします、そしてまたrunningTotalが、incrementer関数が呼ばれる次の時に利用可能であることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Carriage return (\r)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>キャリッジリターン「復帰文字」（\r）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Cases can match many different patterns, including interval matches, tuples, and casts to a specific type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらのケース節は、区間マッチ、タプル、そして特定の型への型キャストを含む、多くの異なるパターンにマッチすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Casting doesn’t actually modify the instance or change its values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>キャストは、実際にインスタンスを修正したり、その値を変えたりしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Chaining on Methods with Optional Return Values</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルの戻り値をもつメソッド上で連鎖する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Change optionalName to nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>optionalNameをnilに変えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Change the printer name to "Never Has Toner", so that the send(job:toPrinter:) function throws an error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プリンタ名を"Never Has Toner"に変更してください、そうするとsend(job:toPrinter:)関数はエラーをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Changing the value of currentDirection thereafter doesn’t affect the copy of the original value that was stored in rememberedDirection.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それ以降にcurrentDirectionの値を変えることは、本来の値のコピーに、rememberedDirectionに格納されたものに影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Changing the value of properties defined by the superclass.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スーパークラスによって定義されるプロパティの値を変える。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Characteristics of Memory Access</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メモリアクセスの特徴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Checking API Availability</seg>
      </tuv>
      <tuv lang="ja">
        <seg>API有効性の確認</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Checking Type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型を調べる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Checking for Protocol Conformance</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル準拠の確認</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Checking for an empty string value (such as "" rather than "Giraffe") isn’t the same as checking for nil to indicate the absence of an optional String value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>空の文字列値（例えば"Giraffe"といったものでなく""）について調べることは、オプショナルのString値の不在を指し示すnilについて調べることと同じではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Checking for and casting to a protocol follows exactly the same syntax as checking for and casting to a type:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるプロトコルについて調べたりそれにキャストすることは、ある型について調べたりキャストするのと正確に同じ構文に従います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Checking the frameRate property of tenEighty shows that it correctly reports the new frame rate of 30.0 from the underlying VideoMode instance:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>tenEightyのframeRateプロパティを調べてみると、それが根底にあるVideoModeインスタンス由来の新しいフレームレートの30.0を正しく報告することがわかります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Checking the width property of cinema shows that it has indeed changed to be 2048:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>cinemaのwidthプロパティをチェックすると、2048になるように変えられたことを示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Chess is played on an 8 x 8 board, with alternating black and white squares.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>チェスは、黒と白の正方形を互い違いに持つ、８×８マスの盤上で行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Clarified the full list of characters that can be used when defining Custom Operators.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あつらえの演算子を定義するとき使われることが出来る文字の完全なリストをわかりやすくしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Class B is a subclass of A, with a reduced access level of “internal”.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスBはAのサブクラスです、そして減少させられたアクセス水準の「内部」を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Class Declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラス宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Class Implementations of Protocol Initializer Requirements</seg>
      </tuv>
      <tuv lang="ja">
        <seg>イニシャライザ要件プロトコルのクラス実装</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Class Inheritance and Initialization</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラス継承と初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Class and structure initialization is described in more detail in Initialization.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスと構造体の初期化は、更に詳細に初期化で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Class declarations are declared using the class keyword and have the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラス宣言は、キーワードclassを使用して宣言されて、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Class declarations can’t contain protocol declarations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラス宣言は、プロトコル宣言を含むことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Class definitions can have at most one deinitializer per class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラス定義は、クラスごとに多くとも１つのデイニシャライザしか持つことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Class initialization in Swift is a two-phase process.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトでのクラス初期化は、２段階処理です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Class types can inherit from a single superclass and conform to any number of protocols.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラス型は、１つのスーパークラスから継承することができ、任意の数のプロトコルに準拠することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Class-Only Protocols</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラス専用プロトコル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Classes Are Reference Types</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスは、参照型です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Classes and actors share many of the same characteristics and behaviors.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスおよびアクターは、多くの同じ特徴および挙動を共有します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Classes and class members that are marked with the internal or public access-level modifier are imported as if they were declared with the open access-level modifier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>internalまたはpublicアクセス水準修飾子で印されるクラスまたはクラスメンバは、まるでそれらがopenアクセス水準修飾子で宣言されたかのようにインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Classes and structures must set all of their stored properties to an appropriate initial value by the time an instance of that class or structure is created.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスと構造体は、それらの格納プロパティの全てを、そのクラスや構造体のインスタンスがつくられる時には適切な初期値に設定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Classes and structures can also provide implementations of the standard unary operators.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスと構造体は、また、標準の単項演算子の実施も提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Classes and structures can provide their own implementations of existing operators.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスと構造体は、既存の演算子のそれら独自の実装を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Classes are reference types; instances of a class are referred to, rather than copied, when assigned to variables or constants, or when passed as arguments to a function call.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスは、参照型です；クラスのインスタンスは、変数または定数に代入されるとき、または引数として関数呼び出しに渡されるときに、コピーされるのではなく、参照されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Classes can also add property observers to inherited properties in order to be notified when the value of a property changes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスはまた、プロパティの値が変化するとき通知されるように継承されたプロパティにプロパティオブザーバー（監視者）を加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Classes can mark type computed properties with the class declaration modifier instead to allow subclasses to override the superclass’s implementation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスは、型計算プロパティを代わりにclass宣言修飾子で印をつけて、サブクラスがスーパークラスの実装をオーバーライドすることを許可することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Classes can use the class keyword instead, to allow subclasses to override the superclass’s implementation of that method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスは代わりにclassキーワードを使って、サブクラスにスーパークラスのもつそのメソッドの実装をオーバーライドすることを許可できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Classes can use the class keyword instead, to allow subclasses to override the superclass’s implementation of that subscript.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスは、classキーワードを代わりに使用して、サブクラスにスーパークラスのもつその添え字の実装のオーバーライドを許可できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Classes can’t use an opaque type as the return type of a nonfinal method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスは、不透明型を非最終メソッドの戻り型として使用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Classes don’t have a default memberwise initializer, and so the Food class provides a designated initializer that takes a single argument called name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらのクラスには省略時のメンバー関連イニシャライザがありません、なので、Foodクラスはnameと呼ばれる１つの引数をとる指定イニシャライザを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Classes have additional capabilities that structures don’t have:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスは以下の追加の能力を持ちます、それは構造体が持たないものです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Classes in Swift can call and access methods, properties, and subscripts belonging to their superclass and can provide their own overriding versions of those methods, properties, and subscripts to refine or modify their behavior.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトのクラスは、それらのスーパークラスに属しているメソッド、プロパティ、そして添え字の呼び出しやアクセスが行えて、それらのメソッド、プロパティ、そして添え字の独自の優先的に使われる改変板を提供することでそれらの挙動の洗練や修正を行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Classes tend to have very few designated initializers, and it’s quite common for a class to have only one.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスはほとんど指定イニシャライザを持たない傾向があります、そして、あるクラスが１つだけしか持たないことは全く普通です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Classes you define without specifying a superclass automatically become base classes for you to build upon.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スーパークラスを指定することなくあなたが定義するクラスは、自動的に基盤クラスになり、あなたが基礎とするために使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Classes, enumerations, and structs can all adopt protocols.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラス、列挙、そして構造体は、全てそのようなプロトコルを採用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Classes, however, can inherit from other classes, as described in Inheritance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスはしかし、継承で記述されるように、他のクラスから継承することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Classes, structures, and enumerations can all define instance methods, which encapsulate specific tasks and functionality for working with an instance of a given type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それぞれのクラス、構造体、および列挙は、すべてインスタンスメソッドを定義することができます、それは、ある定められた型のあるインスタンスで働くために特定の作業や機能性をカプセル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Classes, structures, and enumerations can also define type methods, which are associated with the type itself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラス、構造体、および列挙は、また、型メソッドを定義することができます、それは型それ自身に結び付けられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Classes, structures, and enumerations can define subscripts, which are shortcuts for accessing the member elements of a collection, list, or sequence.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラス、構造体、および列挙は、添え字を定義することができます、それは、コレクション、リスト、またはシーケンスのメンバー要素にアクセスするための近道です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Closed Range Operator</seg>
      </tuv>
      <tuv lang="ja">
        <seg>完結範囲演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Closed ranges are also available, by using stride(from:through:by:) instead:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>完結範囲も利用可能です、代わりにstride(from:through:by:)を使うことで：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Closure Expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャ式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Closure Expression Syntax</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャ式構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Closure Expressions</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャ式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Closure expression syntax has the following general form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャ式構文は、以下の一般的な形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Closure expressions are unnamed closures written in a lightweight syntax that can capture values from their surrounding context.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャ式は、それの周囲の前後関係から値を捕獲することができる軽快な構文で書かれる無名のクロージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Closure expressions can be used without being stored in a variable or constant, such as when you immediately use a closure as part of a function call.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャ式は、変数や定数の中に格納されることなく利用できます、例えばあなたが直接にクロージャを関数呼び出しの一部として使う場合など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Closure expressions provide several syntax optimizations for writing closures in a shortened form without loss of clarity or intent.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャ式は、いくつかの構文最適化を、ある省略形式で明快さや意図の損失なしでクロージャを書くために提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Closures</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Closures Are Reference Types</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャは参照型です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Closures can capture and store references to any constants and variables from the context in which they’re defined.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャは、それが定義されている前後関係からのあらゆる定数や変数への参照を捕獲して、格納することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Closures in Swift are similar to blocks in C and Objective-C and to lambdas in other programming languages.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトにおけるクロージャは、CとObjective-Cでのブロックに、そして他のプログラミング言語でのラムダ（lambda）に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Closures take one of three forms:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャは、３つの書式のうちの１つをとります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Code Blocks</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コード・ブロック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Code in an unstructured child task, as shown in Unstructured Concurrency below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の構造化されない並行性の中で示されるような、ある構造化されない子タスクの中のコード。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Code in the body of an asynchronous function, method, or property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非同期の関数、メソッド、またはプロパティの本体の中のコード。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Code in the static main() method of a structure, class, or enumeration that’s marked with @main.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>@mainで印される構造体、クラス、または列挙の静的main()メソッドの中のコード。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Code that interacts with an opaque value can use the value only in ways that are part of the interface defined by the constraint.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>不透明型と相互作用するコードは、constraintによって定義されるインターフェイスの一部であるやり方それらにおいてのみ値を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Code that uses this property wrapper can’t specify a different initial value for a property that’s wrapped by TwelveOrLess—for example, the definition of SmallRectangle can’t give height or width initial values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このプロパティラッパーを使うコードは、TwelveOrLessによってラップされるプロパティに対して異なる初期値を指定できません — 例えば、SmallRectangleの定義はheightやwidthに初期値を与えることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Code that’s compiled in library evolution mode, code in the standard library, Swift overlays for Apple frameworks, and C and Objective-C code can declare nonfrozen enumerations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ライブラリ進化モードでコンパイルされるコード、標準ライブラリでのコード、Appleフレームワークに対するスウィフトオーバーレイ、そしてCとObjective-Cコードは、非凍結列挙を宣言できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Code that’s written anywhere else accesses the value using the getter and setter for wrappedValue, and can’t use number directly.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>どこか他で書かれるコードは、wrappedValueに対するゲッターとセッターを使って値にアクセスします、そしてnumberを直接に使用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Code within the actor can interact with them synchronously because that code is already running on the same actor, but code outside the actor must mark them with await to indicate that this code is asynchronously running code on another actor.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>アクター内部のコードは、それらと同期的に相互作用できます、なぜならそのコードは既に同じアクター上で動作しているからです、しかしアクターの外側のコードは、それらをawaitで印して、そのコードが別のアクター上で非同期に動作しているコードであることを指し示さなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Code written at global scope is used as the entry point for the program, so you don’t need a main() function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>グローバルなスコープで書かれるコードは、プログラムのエントリポイントとして使われるので、あなたはmain()関数を必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Code, such as the body of a method or the getter for a property, is executed on that actor.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コード、たとえばあるメソッドの本体またはあるプロパティのゲッターなどは、そのアクター上で遂行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Collection Types</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コレクション型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Collections defined by the standard library like arrays, dictionaries, and strings use an optimization to reduce the performance cost of copying.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列、辞書、そして文字列のような、標準ライブラリによって定義されるコレクションは、ある最適化を使うことでコピーすることによる性能損失を減らします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Collections of Protocol Types</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル型のコレクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Combines an array of partial results into a single partial result.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>部分的結果それらからなるある配列を単一の部分的結果へと結合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Combining Logical Operators</seg>
      </tuv>
      <tuv lang="ja">
        <seg>論理演算子を結合する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Comments</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Comments are ignored by the Swift compiler when your code is compiled.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたのコードがコンパイルされるとき、コメントはスウィフトのコンパイラによって無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Comments are treated as whitespace by the compiler.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コメントは、コンパイラによって空白とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Comments aren’t statements and don’t cause a switch case to be ignored.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コメントは、文でなくて、switchケース節を無視されるようにはしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Comments can contain additional formatting and markup, as described in Markup Formatting Reference [https://developer.apple.com/library/content/documentation/Xcode/Reference/xcode_markup_formatting_ref/index.html].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コメントは、さらに追加の書式とマークアップを含む事が、Markup Formatting Reference [https://developer.apple.com/library/content/documentation/Xcode/Reference/xcode_markup_formatting_ref/index.html]で記述されるように可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Comments in Swift are very similar to comments in C. Single-line comments begin with two forward-slashes (//):</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトのコメントは、Cのコメントに非常に似ています。一行コメントは２つのスラッシュで始まります（//）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Compare the return value from the printNumberOfRooms call against nil to see if the method call was successful:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>printNumberOfRooms呼び出しからの戻り値をnilと比較して、そのメソッドがうまく呼び出されたか見てください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Comparing Strings</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列を比較する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Comparing Structures and Classes</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体とクラスを比較する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Comparison Operators</seg>
      </tuv>
      <tuv lang="ja">
        <seg>比較演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Comparison operators are often used in conditional statements, such as the if statement:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>比較演算子は、条件文においてしばしば使われます、例えばif文など：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Comparisons like i == 1 are discussed in Basic Operators.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>i == 1のような比較は「基本の演算子」で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Compile-Time Diagnostic Statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コンパイル時診断文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Compiler Control Statements</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コンパイラ制御文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Compiler control statements allow the program to change aspects of the compiler’s behavior and include a conditional compilation block and a line control statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コンパイラ制御文は、プログラムにコンパイラの挙動のいろいろな面を変更できるようにします、そして条件コンパイルブロックと行制御文を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Compiler control statements allow the program to change aspects of the compiler’s behavior.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コンパイラ制御文は、プログラムに、コンパイラの挙動の様々な面を変更できるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Compound Assignment Operators</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複合代入演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Compound Cases</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複合ケース節</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Compound cases can also include value bindings.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複合ケース節はまた、値束縛を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Computed Properties</seg>
      </tuv>
      <tuv lang="ja">
        <seg>計算プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Computed Variables and Computed Properties</seg>
      </tuv>
      <tuv lang="ja">
        <seg>計算変数と計算プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Computed properties are provided by classes, structures, and enumerations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>計算プロパティは、クラス、構造体、および列挙で提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Computed properties that you inherit</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが継承する計算プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Computed type properties are always declared as variable properties, in the same way as computed instance properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>計算型プロパティは、計算インスタンスプロパティと同じ方法で、常に変数プロパティとして宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Computed variables calculate their value, rather than storing it, and they’re written in the same way as computed properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>計算変数は値を計算します、それの貯蔵ではなくて、そして計算プロパティと同じ方法で書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Computed variables, global variables, and constants can’t use property wrappers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>計算変数、グローバル変数、そして定数は、プロパティラッパーを使用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Concatenating Strings and Characters</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列と文字の連結</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Concurrency</seg>
      </tuv>
      <tuv lang="ja">
        <seg>並行性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Concurrency requires Swift 5.6 or later, and a version of the Swift standard library that provides the corresponding concurrency types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>並行性はSwift 5.6以降、および対応している並行性型を提供するSwift標準ライブラリのあるバージョンを必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Conditional Compilation Block</seg>
      </tuv>
      <tuv lang="ja">
        <seg>条件コンパイルブロック</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Conditional Conformance</seg>
      </tuv>
      <tuv lang="ja">
        <seg>条件準拠</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Conditional Statements</seg>
      </tuv>
      <tuv lang="ja">
        <seg>条件つきの文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Conditional compilation blocks that contain multiple branches have the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複数の分岐を含む条件コンパイルブロックは、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Conditional statements such as the if statement are covered in more detail in Control Flow.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>if文のような条件つきの文は、更に詳細に「制御の流れ」で扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Conditionally Conforming to a Protocol</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるプロトコルに条件付きで準拠する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Conflicting Access to In-Out Parameters</seg>
      </tuv>
      <tuv lang="ja">
        <seg>in-outパラメータに対するアクセスの衝突</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Conflicting Access to Properties</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティに対するアクセスの衝突</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Conflicting Access to self in Methods</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メソッドの中でのselfに対するアクセスの衝突</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Conform to protocols to provide standard functionality of a certain kind</seg>
      </tuv>
      <tuv lang="ja">
        <seg>特定の種類の標準の機能性を提供するために、プロトコルに準拠します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Consider drawing the tick marks for every minute on a watch face.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>時計盤上のすべての分表示に目盛りを描画することを考えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Consider this example, which uses the Resolution structure from the previous example:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例を考慮してください、それは、前の例からResolution構造体を使用します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Consider two arrays of integers, one where all the elements are the same, and one where they aren’t:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>いくつかの整数からなる２つの配列を考えてください、すべての要素が同じであるもの、そしてそうではないもの：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Constant Declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Constant and variable names can contain almost any character, including Unicode characters:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数と変数の名前は、ユニコード文字を含めて、ほとんどどんな文字でも含むことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Constant and variable names can’t contain whitespace characters, mathematical symbols, arrows, private-use Unicode scalar values, or line- and box-drawing characters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数と変数の名前は、空白文字、数学記号、矢印、私的使用Unicodeスカラー値、または罫線文字を含むことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Constant declarations are declared using the let keyword and have the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数宣言は、letキーワードを使用して宣言され、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Constant declarations aren’t computed properties and therefore don’t have getters or setters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数宣言は、計算プロパティではなく、したがって、ゲッターまたはセッターを持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Constant properties must always have a value before initialization completes, and therefore can’t be declared as lazy.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数プロパティは常に値を、初期化が完了する前に持たなければなりません、それゆえに遅延であると宣言されることが出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Constants and Variables</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数と変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Constants and variables are still explicitly typed, but much of the work of specifying their type is done for you.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数と変数は依然として明確に型を決められます、しかしそれらの型を指定する行為のほとんどは、あなたのために行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Constants and variables associate a name (such as maximumNumberOfLoginAttempts or welcomeMessage) with a value of a particular type (such as the number 10 or the string "Hello").</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数と変数は、ひとつの名前（例えばmaximumNumberOfLoginAttemptsまたはwelcomeMessageなど）を特定の型のひとつの値（例えば数10または文字列"Hello"など）と結びつけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Constants and variables created with optional binding in an if statement are available only within the body of the if statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>if文の中でオプショナル束縛を使って作成された定数と変数は、そのif文の本文の内部でのみ利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Constants and variables must be declared before they’re used.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数と変数は、それらが使われる前に宣言されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Constants and variables of type Any can now contain function instances.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型Anyの定数と変数は、今では関数インスタンスを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Constants and variables of type Barcode can store either a .upc or a .qrCode (together with their associated values), but they can store only one of them at any given time.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型Barcodeの定数と変数は、.upcまたは.qrCodeのどちらでも（それらの関連値と共に）格納することができます、しかしそれらはどんな時でもそれらの１つを格納することだけができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Constants can now be declared without being initialized in local function scope.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数は今では初期化されることなくローカル関数のスコープ内で宣言されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Constants, Variables, Properties, and Subscripts</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数、変数、プロパティ，そして添え字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Contextual Where Clauses</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文脈where節</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Continue Statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>継続文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Control Flow</seg>
      </tuv>
      <tuv lang="ja">
        <seg>制御の流れ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Control Transfer Statements</seg>
      </tuv>
      <tuv lang="ja">
        <seg>制御移動文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Control flow in a loop statement can be changed by a break statement and a continue statement and is discussed in Break Statement and Continue Statement below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ループ文の中の制御の流れは、break文そしてcontinue文によって変えられることができます、そして下記のブレーク文と継続文で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Control flow in an if statement or a switch statement can be changed by a break statement and is discussed in Break Statement below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>if文またはswitch文の中の制御の流れは、break文によって変えられることができます、それは下記のブレーク文で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Control flow statements are used to control the flow of execution in a program.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>制御の流れ文は、プログラムにおいて実行の流れを制御するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Control transfer statements are discussed in Control Transfer Statements below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>制御移動文は、下の制御移動文で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Control transfer statements can change the order in which code in your program is executed by unconditionally transferring program control from one piece of code to another.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>制御移動文は、あなたのプログラムの中のコードが実行される順番を、プログラム制御を１つのコード片から他のものまで無条件に移すことによって変えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Convenience initializers are written in the same style, but with the convenience modifier placed before the init keyword, separated by a space:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>便宜イニシャライザは同じ形式で書かれます、しかしconvenience修飾子がinitキーワードの前に空白で区切って置かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Convenience initializers can delegate the initialization process to another convenience initializer or to one of the class’s designated initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>便宜イニシャライザは、初期化プロセスを別の便宜イニシャライザに、またはそのクラスの指定イニシャライザのうちの１つに委任することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Convenience initializers can’t call a superclass’s initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>便宜イニシャライザは、スーパークラスのイニシャライザを呼ぶことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Convenience initializers must always delegate across.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>便宜イニシャライザは、常に横に委任しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Conversely, LATIN CAPITAL LETTER A (U+0041, or "A"), as used in English, is not equivalent to CYRILLIC CAPITAL LETTER A (U+0410, or "А"), as used in Russian.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>反対に、英語で使われるような、LATIN CAPITAL LETTER A（U+0041、または"A"）は、ロシアで使われるような、CYRILLIC CAPITAL LETTER A（U+0410、または"А"）と等しくありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Conversely, define a capture as a weak reference when the captured reference may become nil at some point in the future.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>逆に、捕らえられた参照が将来どこかの時点でnilになるかもしれないときは、捕獲を弱い参照として定義してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Conversely, if you write a subclass initializer that matches a superclass convenience initializer, that superclass convenience initializer can never be called directly by your subclass, as per the rules described above in Initializer Delegation for Class Types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>逆に言えば、上記のクラス型のためのイニシャライザ委任で記述される規則どおりに、あなたがスーパークラスの便宜イニシャライザに一致するサブクラスのイニシャライザを書くならば、そのスーパークラスの便宜イニシャライザは直接にあなたのサブクラスによって呼び出されることが決してできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Conversely, set b is a subset of set a, because all elements in b are also contained by a.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>逆に言えば、集合bは集合aの下位集合です、bの要素すべてはaによってまた含まれるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Conversions between integer and floating-point numeric types must be made explicit:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>整数と浮動小数点数型の間の変換は、明示的に行われる必要があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Converting Errors to Optional Values</seg>
      </tuv>
      <tuv lang="ja">
        <seg>エラーをオプショナルの値に変換する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Corrected the discussion of the @NSApplicationMain attribute in the Declaration Attributes section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>@NSApplicationMain属性の解説を宣言属性の節において訂正した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Counting Characters</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字を数える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Create a constant with an explicit type of Float and a value of 4.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>明確にFloatの型で値4の定数をつくってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Create an instance of a class by putting parentheses after the class name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラス名の後に丸括弧を置くことによって、クラスのインスタンスをつくってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Create arrays and dictionaries using brackets ([]), and access their elements by writing the index or key in brackets.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>角括弧（[]）を使って配列および辞書（連想配列）を作ってください、そしてインデックスまたはキーを角括弧の中に記述することによってそれらの要素にアクセスしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Create convenience initializers whenever a shortcut to a common initialization pattern will save time or make initialization of the class clearer in intent.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>共通の初期化の繰り返しに対する近道が時間を節約したり、そのクラスの初期化を意図においてより明白にするときはいつでも、便宜イニシャライザをつくってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Creating a Dictionary with a Dictionary Literal</seg>
      </tuv>
      <tuv lang="ja">
        <seg>辞書を辞書リテラルで作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Creating a Set with an Array Literal</seg>
      </tuv>
      <tuv lang="ja">
        <seg>集合を配列リテラルで作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Creating a result builder type creates a custom attribute with the same name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるリザルトビルダー型を作成することは、あるあつらえの属性を同じ名前で作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Creating an Array by Adding Two Arrays Together</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２つの配列を一緒にすることで１つの配列を作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Creating an Array with a Default Value</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列を１つの初期値で作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Creating an Array with an Array Literal</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列を配列リテラルで作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Creating an Empty Array</seg>
      </tuv>
      <tuv lang="ja">
        <seg>空の配列の作成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Creating an Empty Dictionary</seg>
      </tuv>
      <tuv lang="ja">
        <seg>空の辞書を作成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Creating and Initializing an Empty Set</seg>
      </tuv>
      <tuv lang="ja">
        <seg>空の集合の作成と初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Currently, #file has the same value as #filePath.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>現在は、#fileは#filePathと同じ値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Custom Operators</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あつらえの演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Custom Result-Builder Attributes</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あつらえのリザルトビルダー属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Custom Types</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あつらえの型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Custom infix operators each belong to a precedence group.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あつらえの接中辞演算子それぞれは、ある優先順位グループに属しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Custom initializers can be assigned an access level less than or equal to the type that they initialize.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あつらえのイニシャライザは、それらが初期化する型と同じか低いアクセス水準を割り当てられることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Custom operators can begin with one of the ASCII characters /, =, -, +, !, *, %, &lt;, &gt;, &amp;, |, ^, ?, or ~, or one of the Unicode characters defined in the grammar below (which include characters from the Mathematical Operators, Miscellaneous Symbols, and Dingbats Unicode blocks, among others).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あつらえの演算子は、ASCII文字/、=、-、+、!、*、%、&lt;、&gt;、&amp;、|、^、?、および~のうちの１つ、または以下の文法において定義されるユニコード文字のうちの１つで始まります（それはMathematical Operators、Miscellaneous Symbols、そしてDingbatsユニコードブロックなどからの文字を含みます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Custom operators can now contain the ? character.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あつらえの演算子は、今では?文字を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Custom types state that they adopt a particular protocol by placing the protocol’s name after the type’s name, separated by a colon, as part of their definition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あつらえの型は、それが特定のプロトコルを採用することを、型の名前の後に、コロンで区切って、それらの定義の一部としてプロトコルの名前を置くことによって示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Customizing Initialization</seg>
      </tuv>
      <tuv lang="ja">
        <seg>初期化をカスタマイズする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Data types that are normally considered basic or primitive in other languages—such as types that represent numbers, characters, and strings—are actually named types, defined and implemented in the Swift standard library using structures.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>他の言語で通常は基本的またはプリミティブであるとみなされるデータ型 ― 例えば数、文字、そして文字列を表す型 ― これらは実際に名前付きの型で、構造体を使用してスウィフト標準ライブラリにおいて定義および実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>DataImporter is a class to import data from an external file.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（DataImporterは、データを外部ファイルからインポートするクラスです。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Debugging with Assertions</seg>
      </tuv>
      <tuv lang="ja">
        <seg>表明を使ってデバッグする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Decimal floating-point literals consist of a sequence of decimal digits followed by either a decimal fraction, a decimal exponent, or both.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>10進の浮動小数点リテラルは、一連の10進の桁に、小数部か10進の指数のどちらか、または両方が続くものから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Decimal floats can also have an optional exponent, indicated by an uppercase or lowercase e; hexadecimal floats must have an exponent, indicated by an uppercase or lowercase p.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>10進浮動小数点はまた、任意に指数を持つことができ、大文字か小文字のeで示されます；16進浮動小数点は、指数を持つ必要があり、大文字か小文字のpで示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Decimal literals contain the digits 0 through 9.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>10進のリテラルは、0から9までの桁を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Declaration Attributes</seg>
      </tuv>
      <tuv lang="ja">
        <seg>宣言属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Declaration Attributes Used by Interface Builder</seg>
      </tuv>
      <tuv lang="ja">
        <seg>インターフェイスビルダーで使用される宣言属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Declaration Modifiers</seg>
      </tuv>
      <tuv lang="ja">
        <seg>宣言修飾子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Declarations</seg>
      </tuv>
      <tuv lang="ja">
        <seg>宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Declarations in a protocol extension can’t be marked final.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル拡張の中の宣言は、finalで印されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Declarations marked with the inlinable attribute are implicitly usable from inlinable code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>inlinable属性で印される宣言は、暗黙的にインライン可能コードから利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Declarations marked with the open access-level modifier can also be accessed and subclassed by code in a module that imports the module that contains that declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>openアクセス水準修飾子で印される宣言はまた、アクセスされることおよびサブクラスを作られることが、その宣言を含むモジュールをインポートするモジュール内のコードによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Declarations marked with the public access-level modifier can also be accessed (but not subclassed) by code in a module that imports the module that contains that declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>publicアクセス水準修飾子で印される宣言はまた、アクセスされる（しかしサブクラスは作られない）ことが、その宣言を含むモジュールをインポートするモジュール内のコードによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Declare a private member in an extension, and access that member from the original declaration in the same file.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある非公開メンバをある拡張の中で宣言する、そしてそのメンバに対して同じファイル中のオリジナルの宣言からアクセスする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Declare a private member in one extension, and access that member from another extension in the same file.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある非公開メンバを一方の拡張の中で宣言する、そしてそのメンバに対して同じファイル中の別の拡張からアクセスする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Declare a private member in the original declaration, and access that member from extensions in the same file.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある非公開メンバをオリジナルの宣言の中で宣言する、そしてそのメンバに対して同じファイル中の拡張からアクセスする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Declare extensions with the extension keyword:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>extensionキーワードによって拡張を宣言してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Declaring Constants and Variables</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数と変数の宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Declaring Protocol Adoption with an Extension</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張を使ってプロトコル採用を宣言する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Default Access Levels</seg>
      </tuv>
      <tuv lang="ja">
        <seg>省略時のアクセス水準</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Default Initializers</seg>
      </tuv>
      <tuv lang="ja">
        <seg>省略時のイニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Default Memberwise Initializers for Structure Types</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体体型のための省略時のメンバー関連イニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Default Parameter Values</seg>
      </tuv>
      <tuv lang="ja">
        <seg>省略時のパラメータ値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Default Property Values</seg>
      </tuv>
      <tuv lang="ja">
        <seg>省略時のプロパティ値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Default values, however, can’t be specified for method parameters within a protocol’s definition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>省略時の値は、しかしながら、プロトコル定義の内部のメソッドパラメーターに対して指定されることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Defer Statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>defer文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Deferred actions are executed in the reverse of the order that they’re written in your source code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>延期された動作は、それらがあなたのソースコードに書かれた順序の逆に実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Define a capture in a closure as an unowned reference when the closure and the instance it captures will always refer to each other, and will always be deallocated at the same time.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>捕獲をクロージャにおいて非所有参照として定義してください、クロージャとそれが捕らえるインスタンスが常に互いに言及する、そして常に同時に割り当て解除される時は。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Define and use new nested types</seg>
      </tuv>
      <tuv lang="ja">
        <seg>新しい入れ子にされた型を定義して、使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Define initializers to set up their initial state</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらの初期状態を設定するために、イニシャライザを定義します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Define instance methods and type methods</seg>
      </tuv>
      <tuv lang="ja">
        <seg>インスタンスメソッドと型メソッドを定義する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Define methods to provide functionality</seg>
      </tuv>
      <tuv lang="ja">
        <seg>機能性を提供するために、メソッドを定義します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Define properties to store values</seg>
      </tuv>
      <tuv lang="ja">
        <seg>値を格納するために、プロパティを定義します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Define subscripts</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字を定義する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Define subscripts to provide access to their values using subscript syntax</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字構文を使用してそれらの値の利用することを提供するために、添え字を定義します</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Define the access level for an entity by placing one of the open, public, internal, fileprivate, or private modifiers at the beginning of the entity’s declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある実在にアクセス水準を定義するには、open、public、internal、fileprivate、またはprivate修飾子のうちの１つをその実在の宣言の始まりに置いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Defining Model Classes for Optional Chaining</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル連鎖のモデル・クラスを定義する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Defining a Base Class</seg>
      </tuv>
      <tuv lang="ja">
        <seg>基盤クラスを定義すること</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Defining a Capture List</seg>
      </tuv>
      <tuv lang="ja">
        <seg>捕獲リストの定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Defining a Class Hierarchy for Type Casting</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型キャストのためにクラス階層を定義する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Defining a call-as-function method, or a method from the dynamicCallable attribute, doesn’t let you use an instance of that type as if it were a function in any context other than a function call expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>call-as-functionメソッド、またはdynamicCallable属性からのメソッドを定義することは、あなたにその型のインスタンスを使わせません、まるでそれが関数呼び出し式と違う何か他の文脈での関数だったかのようには。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Defining and Calling Asynchronous Functions</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非同期関数の定義と呼び出し</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Defining and Calling Functions</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数の定義と呼び出し</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Definition Syntax</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定義構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Deinitialization</seg>
      </tuv>
      <tuv lang="ja">
        <seg>デイニシャライズ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Deinitializer Declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>デイニシャライザ宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Deinitializers are called automatically, just before instance deallocation takes place.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>デイニシャライザは、インスタンスの割り当て解除が起こる直前に、自動的に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Deinitializers are only available on class types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>デイニシャライザは、クラス型で利用可能なだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Deinitializers aren’t called directly.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>デイニシャライザは、直接に呼ばれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Deinitializers enable an instance of a class to free up any resources it has assigned.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>デイニシャライザは、クラスのインスタンスにそれが代入したどんなリソースでも解放するのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Deinitializers in Action</seg>
      </tuv>
      <tuv lang="ja">
        <seg>デイニシャライザの動作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Deinitializers take no parameters and have the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>デイニシャライザは、パラメータを取らない以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Delaying evaluation is useful for code that has side effects or is computationally expensive, because it lets you control when that code is evaluated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>評価を遅らせることは、副作用を持つまたは計算的に高くつくコードに対して有用です、なぜならそれがあなたに何時そのコードが評価されるかを制御させるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Delegation</seg>
      </tuv>
      <tuv lang="ja">
        <seg>委任</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Delegation can be used to respond to a particular action, or to retrieve data from an external source without needing to know the underlying type of that source.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>委任は、特定の動作に応答したり、外部ソースからそのソースの根底の型を知る必要なしにデータを取り出したりするのに使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Depending on the work you’re doing, that usually means one of the following:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが行っている作業に依存して、それは通常は以下の１つを意味します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Designated Initializers and Convenience Initializers</seg>
      </tuv>
      <tuv lang="ja">
        <seg>指定イニシャライザと便宜イニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Designated and Convenience Initializers in Action</seg>
      </tuv>
      <tuv lang="ja">
        <seg>指定および便宜イニシャライザの動作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Designated initializers and deinitializers must always be provided by the original class implementation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>指定イニシャライザとデイニシャライザは、常に最初のクラス実施によって提供されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Designated initializers are “funnel” points through which initialization takes place, and through which the initialization process continues up the superclass chain.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>指定イニシャライザは、「漏斗」地点です、そこを通して初期化が行われ、そこを通して初期化処理がスーパークラス連鎖を上って続いていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Designated initializers can be declared in the context of a class declaration only and therefore can’t be added to a class using an extension declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>指定イニシャライザは、クラス宣言の文脈においてのみ宣言されることができて、したがって拡張宣言を使ってあるクラスに加えられることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Designated initializers for classes are written in the same way as simple initializers for value types:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスのための指定イニシャライザは、値型のための単純なイニシャライザと同様に書かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Designated initializers must always delegate up.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>指定イニシャライザは、常に上に委任しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Despite this simplicity of syntax, Swift’s String type is a fast, modern string implementation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構文のこの単純さにもかかわらず、スウィフトのString型は、速く、現代的な文字列の実装です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Dictionaries</seg>
      </tuv>
      <tuv lang="ja">
        <seg>辞書</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Dictionaries are an unordered collection, so their keys and values are iterated over in an arbitrary order.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>辞書は、順序付けられないコレクションです、なのでそのキーと値は気まぐれな順番で繰り返されていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Dictionaries are unordered collections of key-value associations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>辞書は、「キーと値」を結びつけたものの順番をつけられないコレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Dictionary Type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>辞書型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Dictionary Type Shorthand Syntax</seg>
      </tuv>
      <tuv lang="ja">
        <seg>辞書型の略記構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Differences Between Opaque Types and Protocol Types</seg>
      </tuv>
      <tuv lang="ja">
        <seg>不透明型とプロトコル型の間の違い</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Digit 0 or 1</seg>
      </tuv>
      <tuv lang="ja">
        <seg>アラビア数字の0または1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Digit 0 through 7</seg>
      </tuv>
      <tuv lang="ja">
        <seg>アラビア数字の0から7</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Digit 0 through 9</seg>
      </tuv>
      <tuv lang="ja">
        <seg>アラビア数字の0から9</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Digit 0 through 9, a through f, or A through F</seg>
      </tuv>
      <tuv lang="ja">
        <seg>アラビア数字の0から9、aからf、またはAからF</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Disabling Error Propagation</seg>
      </tuv>
      <tuv lang="ja">
        <seg>エラー伝達を抑制する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Distinguishing among these different situations allows a program to resolve some errors and to communicate to the user any errors it can’t resolve.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの異なった状況を区別することは、プログラムにいくらかのエラーを解消すること、そしてなんらかのそれが解消できないエラーを利用者に伝えることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Division (/)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>除算（/）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Do Statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>do文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Do this by placing an exclamation point after the init keyword (init!) instead of a question mark.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これを、疑問符ではなく、感嘆符をinitキーワードの後に置くこと（init!）によって行ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Do this by writing the final modifier before the method, property, or subscript’s introducer keyword (such as final var, final func, final class func, and final subscript).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メソッド、プロパティ、または添え字の導入子キーワードの前にfinal修飾子を書くことによって、これをしてください（例えば、final var、final func、final class func、そしてfinal subscriptなど）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Document Revision History</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文書改訂履歴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Doing so clarifies that you intend to provide an override and haven’t provided a matching definition by mistake.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そうすることは、あなたがオーバーライドを提供するつもりであって、誤って同じ定義を提供したのでないことを明らかにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Doing so is consistent with the label’s use alongside the break statement and helps make the game’s logic clearer to read and understand.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そうすることは、break文と並べるとラベルの使用で調和して、ゲームの論理を読み取って理解するのをより明快にする助けとなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Doing so makes it easier for you to reason about your code and enables the Swift compiler to optimize the performance of the collections you create.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そうすることは、あなたがあなたのコードについて推論するのをより容易にして、スウィフトのコンパイラにあなたが作成するコレクションの運用性能を最適なものにすることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Don’t use an implicitly unwrapped optional when there’s a possibility of a variable becoming nil at a later point.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある変数がその後のある時点でnilになる可能性がある時には、暗黙的にアンラップされるオプショナルを使用しないでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Don’t worry if you aren’t familiar with the concept of capturing.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがキャプチャの概念に馴染みがなくても、心配いりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Don’t worry if you don’t understand something—everything introduced in this tour is explained in detail in the rest of this book.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>わからないことがあっても心配することはありません ― このツアーにおいて紹介されるすべてのことは、この本の残りで詳細に説明されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Double quotation mark (\")</seg>
      </tuv>
      <tuv lang="ja">
        <seg>二重引用符（\"）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Downcasting</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ダウンキャスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Downcasting to Movie fails when applied to the Song instances in the library array.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Movieにダウンキャストすることは、library配列のSongインスタンスに適用されるとき失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Dynamic member lookup by key path can be used to implement a wrapper type in a way that supports compile-time type checking.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>キーパスによる動的メンバー検索は、ラッパー型を、コンバイル時型検査をサポートするある方法で実装するために使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Dynamic member lookup by member name can be used to create a wrapper type around data that can’t be type checked at compile time, such as when bridging data from other languages into Swift.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メンバー名による動的メンバー検索は、コンパイル時に型検査されることができないデータを取り囲むラッパー型を作成するために使用できます、たとえば他の言語からスウィフトへとブリッジしている時など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each Player instance is initialized with a starting allowance of a specified number of coins from the bank during initialization, although a Player instance may receive fewer than that number if not enough coins are available.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>各Playerインスタンスは、初期化の間に、胴元からの指定された数のコインの開始手当で初期化されます、とは言え、十分なコインが利用可能でなければPlayerインスタンスはその数より少ないものを受け取るかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each String value has an associated index type, String.Index, which corresponds to the position of each Character in the string.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それぞれのString値は、結び付けられたインデックス型、String.Indexを持ちます、それは、各Characterのその文字列中での位置に対応しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each UnicodeScalar has a value property that returns the scalar’s 21-bit value, represented within a UInt32 value:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>各UnicodeScalarはひとつのvalueプロパティを持ちます、それはそのスカラーの21ビットの値を返します、そしてそれはUInt32値の範囲内で表されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each Starship class instance stores a mandatory name and an optional prefix.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>各Starshipクラスインスタンスは、義務的なnameそしてオプショナルのprefixを格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each case compares that value to a number or interval.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>各caseは、その値をある数または区間と比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each access-level modifier above optionally accepts a single argument, which consists of the set keyword enclosed in parentheses (for example, private(set)).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上記のそれぞれのアクセス水準修飾子は、任意に１つだけの引数を受け入れます、それは丸括弧に囲まれたキーワードsetからなります（例えば、private(set)）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each approach is described in a section below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>各取り組みは、以下の節で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each barcode has a number system digit, followed by five manufacturer code digits and five product code digits.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>各バーコードは、１つの「ナンバーシステム」桁、それに続く５桁の「製造者コード」そして５桁の「商品コード」を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each build target (such as an app bundle or framework) in Xcode is treated as a separate module in Swift.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Xcodeでの各ビルドターゲット（例えばアプリ・バンドルまたはフレームワーク）は、スウィフトにおいて別々のモジュールとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each case can also specify that it stores values of a given type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>各ケース節は、また、それが特定の型の値を格納することを示すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each case must have a unique name and be assigned a unique raw value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それぞれのケース節は、固有な名前を持ち固有な生の値を割り当てられなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each channel has an integer audio level between 0 and 10 inclusive.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>各チャンネルは、0から10を含むまでの整数オーディオ・レベルがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each element of the tuple can be tested against a different value or interval of values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タプルの各要素は、ある異なる値または値の区間に対して試験されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each enumeration definition defines a new type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>各列挙定義は、ある新しい型を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each example below shows a different representation of the following string, which is made up of the characters D, o, g, ‼ (DOUBLE EXCLAMATION MARK, or Unicode scalar U+203C), and the 🐶 character (DOG FACE, or Unicode scalar U+1F436):</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の各例は、次の文字列の異なる表現を示します、それは文字D、o、g、‼（DOUBLE EXCLAMATION MARK、またはユニコードスカラーU+203C）、そして🐶文字（DOG FACEまたはユニコードスカラーU+1F436）から成ります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each expression can have an optional identifier before it, separated by a colon (:).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>各式はそれの前に、コロン（:）で区切られる任意の識別子を持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each form encodes the string in small chunks known as code units.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>各方式は、文字列を、符号単位として知られている小さいかたまりで符号化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each function parameter has both an argument label and a parameter name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数パラメーターそれぞれは、引数ラベルとパラメーター名の両方を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each identifier in a tuple expression must be unique within the scope of the tuple expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるタプル式の中の各識別子は、そのタプル式のスコープ内で特有でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each instance of Person has a single stored property called fullName, which is of type String.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Personの各インスタンスは、fullNameと呼ばれる１つの格納プロパティを持ちます、それは、型Stringです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each item in a capture list is a pairing of the weak or unowned keyword with a reference to a class instance (such as self) or a variable initialized with some value (such as delegate = self.delegate).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>捕獲リストの各項目は、weakまたはunownedキーワードと、クラスインスタンスへの参照（例えばself）またはなんらかの値で初期化された変数（例えばdelegate = self.delegate）を対にしたものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each item in a protocol composition list is one of the following; the list can contain at most one class:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル合成リストの各項目は以下のうちの１つです；リストは最大１つのクラスを含むことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each item in the dictionary is returned as a (key, value) tuple when the dictionary is iterated, and you can decompose the (key, value) tuple’s members as explicitly named constants for use within the body of the for-in loop.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>辞書の中の各項目は、辞書が繰り返されるとき、(key, value)タプルとして返されます、そしてあなたは(key, value)タプルの構成要素をfor-inループの本文内で使用するわかりやすい名前の定数として分解することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each item in the dictionary is returned as a (key, value) tuple, and you can decompose the tuple’s members into temporary constants or variables as part of the iteration:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>辞書の中の各項目は、(key, value)タプルとして返されます、そしてあなたはタプルの構成要素を一時的な定数または変数に分解することが、この繰り返しの一部として行えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each item that you insert into the string literal is wrapped in a pair of parentheses, prefixed by a backslash (\):</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがリテラル文字列に差し込む各項目は、一対の丸括弧に包まれて、バックスラッシュ（\）を前に置かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each kind of expression is described in detail in the sections below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>各種類の式は、以下の節において詳細に記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each of the comparison operators returns a Bool value to indicate whether or not the statement is true:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それぞれの比較演算子は、Bool値を返して、その文が真かどうかを指し示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each of the statements inside of the block is transformed, one at a time, and they become the arguments to the buildBlock(_:) method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ブロックの内部の文のそれぞれは変換されます、一度に１つずつ、そしてそれらはbuildBlock(_:)メソッドへの引数になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each of these key-path components can be repeated as many times as needed, in any order.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらキーパス構成要素のそれぞれは、必要なだけ、任意の順序で、何度も繰り返されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each pair of characters in a hexadecimal number uses 8 bits, so a move 16 places to the right will convert 0xCC0000 into 0x0000CC.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>16進数の中の文字の各ペアは８ビットを使うので、右への16桁の移動は0xCC0000を0x0000CCへと変えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each photo downloads completely before the next one starts downloading.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>各写真は、次のものがダウンロードを開始する前に、完全にダウンロードされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each player has a certain number of coins stored in their purse at any time.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>各々のプレーヤーは、特定の数のコインをいつでもかれらの財布に保管しておきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each position in the matrix is given an initial value of 0.0.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>行列の中の各位置は、0.0の初期値を与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each raw value must be unique within its enumeration declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>生の値それぞれは、その列挙宣言の範囲内で固有でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each statement in the body of a conditional compilation block is parsed even if it’s not compiled.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>条件コンパイルブロックの本文中の各文は、たとえそれがコンパイルされなくとも、構文解析されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each task checks whether it has been canceled at the appropriate points in its execution, and responds to cancellation in whatever way is appropriate.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>各タスクは、それがそれの遂行において適切な地点で取り消されたかどうか確認します、そしてなんでも適切な方法で取り消しに応答します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each task in a task group has the same parent task, and each task can have child tasks.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タスクグループの中の各タスクは、同じ親タスクを持ちます、そして各タスクは子タスクいくつかを持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each time swapTwoValues(_:_:) is called, the type to use for T is inferred from the types of values passed to the function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>swapTwoValues(_:_:)が呼ばれるたびに、Tのために使われる型は関数に渡される値の型から推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each time through the while loop, diceRoll is incremented by one and is then checked to see whether it has become too large.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>毎回whileループの間、diceRollは１増やされて、それからそれが大きくなりすぎていないか調べられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each turn, you roll a six-sided dice and move by that number of squares, following the horizontal path indicated by the dotted arrow above.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>順番になるたび、あなたは六面のさいころを転がします、そしてその数だけ正方形を移動します、上の点線の矢印で示される水平移動の経路をたどっていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each type argument must satisfy all the constraints of the generic parameter it replaces, including any additional requirements specified in a generic where clause.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>各型引数は、それが置き換える総称体パラメータの全ての制約を、総称体where節で指定される任意の追加の要件を含めて、満たさなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each type method is explicitly scoped to the type it supports.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>各型メソッドは、当然ながらそれが支える型にスコープを指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each unassigned case of type Int is implicitly assigned a raw value that’s automatically incremented from the raw value of the previous case.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型Intの未割り当てのケース節それぞれは、暗黙のうちに生の値を割り当てられます、それは、前のケース節の生の値から自動的に増やされたものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each value is associated with a unique key, which acts as an identifier for that value within the dictionary.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>各値は固有のキーと結び付けられます、そして、それはその辞書の内部でその値のために識別子の働きをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Early Exit</seg>
      </tuv>
      <tuv lang="ja">
        <seg>早期退出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Effectively, the addition and the assignment are combined into one operator that performs both tasks at the same time.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>実質的に、加算と代入は１つの演算子に結合され、同時に両方の作業を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Effectively, they’re just two different names for the same single instance, as shown in the figure below:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>事実上、それらは同じ１つのインスタンスに対する単なる２つの異なる名前です、以下の図で示されるように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Empty array literals are written using an empty pair of square brackets and can be used to create an empty array of a specified type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>空の配列リテラルは、空の角括弧の対を使って書かれて、指定された型の空の配列をつくるために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Enforcing Preconditions</seg>
      </tuv>
      <tuv lang="ja">
        <seg>前提条件の遵守</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Entities in the imported module that are marked with the internal access-level modifier are imported as if they were declared with the public access-level modifier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>internalアクセス水準修飾子で印されるインポートされたモジュールの中の存在それらは、まるでそれらがpublicアクセス水準修飾子で宣言されたかのようにインポートされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Enumeration Case Pattern</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙ケース節パターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Enumeration Declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Enumeration Syntax</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Enumeration Types</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Enumeration case patterns appear in switch statement case labels and in the case conditions of if, while, guard, and for-in statements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙ケース節パターンは、switch文のケース節ラベル（ケース節表記）において、そしてif、while、guard、およびfor-in文のケース節条件において現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Enumeration case values without associated values (as described in Enumerations) are also hashable by default.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関連値なしでの列挙ケース節の値（列挙で記述されます）もまた、そのままでハッシュ化できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Enumeration cases that store associated values can be used as functions that create instances of the enumeration with the specified associated values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関連値を格納する列挙ケース節は、関数として使われることができ、それは指定された関連値を持つその列挙のインスタンスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Enumeration declarations can’t contain deinitializer or protocol declarations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙宣言は、デイニシャライザまたはプロトコル宣言を含むことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Enumeration declarations have two basic forms and are declared using the enum keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙宣言は、２つの基本の形式を持ち、キーワードenumを使って宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Enumeration types can adopt any number of protocols, but can’t inherit from classes, structures, or other enumerations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙型は、任意の数のプロトコルに準拠することができます、しかしクラス、構造体、または他の列挙から継承することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Enumerations</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Enumerations and Structures</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙と構造体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Enumerations are often created to support a specific class or structure’s functionality.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙は、特定のクラスまたは構造体の機能性を支えるためにたびたびつくられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Enumerations can also define initializers to provide an initial case value; can be extended to expand their functionality beyond their original implementation; and can conform to protocols to provide standard functionality.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙は、さらに、最初のケース節値を提供するためにイニシャライザを定義することができます；それらの本来の実装を越えてそれらの機能性を広げるために拡張されることができます；そして、標準の機能性を提供するためにプロトコルに準拠することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Enumerations can have a recursive structure, that is, they can have cases with associated values that are instances of the enumeration type itself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙は、再帰構造を持つことができます、すなわち、それは、その列挙型それ自身のインスタンスである関連値を伴うケース節を持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Enumerations declared in this form are sometimes called discriminated unions in other programming languages.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この形式で宣言される列挙は、時として他のプログラミング言語では判別共用体と呼ばれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Enumerations in Swift are first-class types in their own right.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトの列挙は、れっきとした第一級の型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Enumerations in Swift are much more flexible, and don’t have to provide a value for each case of the enumeration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトの列挙は、ずっと柔軟で、列挙のケース節の各々に値を与える必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Enumerations similar to these are known as discriminated unions, tagged unions, or variants in other programming languages.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これに似ている列挙は、他のプログラミング言語で判別共用体、タグ付き共用体、またはバリアントとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Enumerations that have cases of a raw-value type implicitly conform to the RawRepresentable protocol, defined in the Swift standard library.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>「生の値」型のケース節を持つ列挙は、スウィフト標準ライブラリで定義されるRawRepresentableプロトコルに暗黙的に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Enumerations that have no associated types</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関連型を持たない列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Enumerations that have only associated types that conform to the Equatable protocol</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Equatableプロトコルに準拠する関連型だけを持つ列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Enumerations that have only associated types that conform to the Hashable protocol</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Hashableプロトコルに準拠する関連型だけを持つ列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Enumerations with Cases of Any Type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>随意の型のケース節をもつ列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Enumerations with Cases of a Raw-Value Type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>「生の値」型のケース節を持つ列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Enumerations with Indirection</seg>
      </tuv>
      <tuv lang="ja">
        <seg>間接参照を持つ列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Enumerations with raw values automatically receive a failable initializer, init?(rawValue:), that takes a parameter called rawValue of the appropriate raw-value type and selects a matching enumeration case if one is found, or triggers an initialization failure if no matching value exists.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>生の値を持つ列挙は、自動的にひとつの失敗できるイニシャライザ、init?(rawValue:)を受け取ります、それは、適切な「生の値」型のrawValueと呼ばれるパラメータを取って、適合する列挙ケース節をそれが見つかったならば選択します、または適合する値が存在しないならば初期化失敗を引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Enumerations with raw values now have a rawValue property rather than a toRaw() method and a failable initializer with a rawValue parameter rather than a fromRaw() method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>生の値を持つ列挙は、今ではtoRaw()メソッドではなくrawValueプロパティを、そしてfromRaw()メソッドではなくrawValueパラメーターを使う失敗できるイニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Equal to (a == b)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同等である (a == b)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Equivalence Operators</seg>
      </tuv>
      <tuv lang="ja">
        <seg>等価演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Error Handling</seg>
      </tuv>
      <tuv lang="ja">
        <seg>エラーの処理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Error handling allows controlled recovery from unexpected failures.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>エラー処理が、予期せぬ失敗からの制御された復旧を可能にする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Error handling in Swift interoperates with error handling patterns that use the NSError class in Cocoa and Objective-C.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトでのエラー処理は、CocoaとObjective-CでのNSErrorクラスを使うエラー処理パターンと相互運用性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Error handling in Swift resembles exception handling in other languages, with the use of the try, catch and throw keywords.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトにおけるエラー処理は、try、catch、そしてthrowキーワードの使用とともに、他の言語での例外処理に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Escaping Closures</seg>
      </tuv>
      <tuv lang="ja">
        <seg>脱出クロージャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Evaluating an expression returns a value, causes a side effect, or both.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある式を評価することは、ひとつの値を返す、ある副作用を引き起こす、あるいはその両方です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Even if your source file has a mix of carriage returns and line feeds, all of the line breaks in the string will be the same.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>たとえあなたのソースファイルがキャリッジリターンとラインフィードの混合を持つとしても、文字列の中のラインブレークの全ては同じになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Even in this simple case, because the code has to be written as a series of completion handlers, you end up writing nested closures.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この単純な事例においてさえ、コードが一連の完了ハンドラとして書かれなければならないことから、あなたは最終的に複数のクロージャを入れ子にして書くことになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Even on 32-bit platforms, Int can store any value between -2,147,483,648 and 2,147,483,647, and is large enough for many integer ranges.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>32ビットのプラットホーム上でさえ、Intは-2,147,483,648と2,147,483,647の間のどんな値でも格納することができ、多くの整数範囲のために十分に大きいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Even though Rank and Suit are nested within BlackjackCard, their type can be inferred from context, and so the initialization of this instance is able to refer to the enumeration cases by their case names (.ace and .spades) alone.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>たとえRankとSuitがBlackjackCard内部に入れ子にされるとしても、それらの型は前後関係から推論されることができます、なのでこのインスタンスの初期化は、列挙ケース節を参照することがもっぱらそれらのケース節名（.aceと.spades）のみによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Even though RecipeIngredient provides the init(name: String) initializer as a convenience initializer, RecipeIngredient has nonetheless provided an implementation of all of its superclass’s designated initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>たとえRecipeIngredientが便宜イニシャライザとしてinit(name: String)イニシャライザを提供するとしても、RecipeIngredientはそれでもやはりそれのスーパークラスの指定イニシャライザの全ての実装を提供しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Even though hd and cinema now have the same width and height, they’re two completely different instances behind the scenes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>たとえhdとcinemaが現在同じ幅と高さを持つとしても、それらは舞台裏では２つの完全に異なるインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Even though the text property is now a constant, it can still be set within the class’s initializer:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>たとえtextプロパティが今や定数であるとしても、それはクラスのイニシャライザの内部ではまだ設定されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Even though the closure refers to self multiple times, it only captures one strong reference to the HTMLElement instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>たとえクロージャが複数回selfに言及するとしても、それはそのHTMLElementインスタンスへの１つの強い参照を捕獲するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Even though the first element of the customersInLine array is removed by the code inside the closure, the array element isn’t removed until the closure is actually called.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>たとえcustomersInLine配列の最初の要素がクロージャ内部のコードによって取り除かれるとしても、その配列要素はクロージャが実際に呼び出されるまで実行されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Even though the stack and the array are of a different type, they both conform to the Container protocol, and both contain the same type of values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>たとえスタックと配列が異なる型であるとしても、それらは両方ともContainerプロトコルに準拠して、両方とも同じ型の値を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Even though the two write accesses overlap in time, they don’t conflict.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>たとえ２つの書き込みアクセスが時間内にオーバーラップしても、それらは衝突しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Even though the variable protocolValue has a runtime type of SimpleClass, the compiler treats it as the given type of ExampleProtocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>たとえ変数protocolValueが実行時の型としてSimpleClassを持つとしても、コンパイラはそれを与えられた型ExampleProtocolとみなします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Even though there are two optional chaining operations, one after another, the result is still wrapped in a single optional.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>たとえ２つのオプショナル連鎖演算があったとしても、後から後から、その結果は依然としてただ１つのオプショナルの中にラップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Even though you don’t write an explicit getter and setter for a stored property, Swift still synthesizes an implicit getter and setter for you to provide access to the stored property’s backing storage.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>たとえあなたが格納プロパティのために明確なゲッターとセッターを書かないとしても、スウィフトは格納プロパティのもつ支援外部記憶へのアクセスを提供するためにあなたのためにまだ暗黙のゲッターとセッターを総合的に扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Every Person instance has a name property of type String and an optional apartment property that’s initially nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あらゆるPersonインスタンスは、型Stringのnameプロパティと初期時にはnilであるオプショナルのapartmentプロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Every switch statement consists of multiple possible cases, each of which begins with the case keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あらゆるswitch文は複数の起こりうるケース節から成ります。そして、それぞれはcaseキーワードから始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Every switch statement must be exhaustive.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あらゆるswitch文は、網羅的でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Every class must have at least one designated initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あらゆるクラスは、少なくとも１つの指定イニシャライザを持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Every conditional compilation block begins with the #if compilation directive and ends with the #endif compilation directive.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>すべての条件コンパイルブロックは、#ifコンパイル指令で始まって、#endifコンパイル指令で終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Every course is part of some department so the department property isn’t an optional.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あらゆる課程は、なんらかの学科の一部です、なのでdepartmentプロパティはオプショナルではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Every function has a function name, which describes the task that the function performs.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あらゆる関数は関数名を持ち、それはその関数が実行する作業を形容します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Every function has a specific function type, made up of the parameter types and the return type of the function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あらゆる関数は特定の関数型を持ちます、それは、その関数のパラメータ型と戻り型から成り立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Every function in Swift has a type, consisting of the function’s parameter types and return type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトのあらゆる関数は、その関数のパラメータ型と戻り型から成る、ある型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Every instance of Swift’s Character type represents a single extended grapheme cluster.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトのCharacter型の全てのインスタンスは、単一の拡張書記素クラスタ（房、群）を表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Every instance of a type has an implicit property called self, which is exactly equivalent to the instance itself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある型のすべてのインスタンスは、暗黙的にselfと呼ばれるプロパティを持ちます、それは、正確にそのインスタンスそれ自身に等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Every item in the shopping list starts out as “unpurchased”.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>購入品目リストでのあらゆる項目は、「未購入」として始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Every property needs a value assigned—either in its declaration (as with numberOfSides) or in the initializer (as with name).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あらゆるプロパティは、代入される値を必要とします ― その宣言において（numberOfSidesでのように）またはイニシャライザにおいて（nameでのように）のどちらでも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Every string is composed of encoding-independent Unicode characters, and provides support for accessing those characters in various Unicode representations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あらゆる文字列は、符号化に依存しないUnicode文字から構成されます、そして多彩なUnicode表現においてそのような文字にアクセスするための支援を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Every time a player finishes a level, that level is unlocked for all players on the device.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プレーヤーがあるレベルを終了するごとに、そのレベルはその装置上の全てのプレーヤーのために鍵を外されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Every time you create a new instance of a class, ARC allocates a chunk of memory to store information about that instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがクラスの新しいインスタンスをつくるたびに、ARCはメモリのある量を割り当てて、そのインスタンスに関する情報を格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Every time you create a new instance of that type, it has its own set of property values, separate from any other instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがその型の新しいインスタンスをつくるたびに、それは、他のあらゆるインスタンスから独立した、独自のひと組のプロパティ値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Examples of Closure Expressions now use the global sorted(_:_:) function rather than the global sort(_:_:) function, to reflect the new array value semantics.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャ式の例は、現在はグローバルなsorted(_:_:)関数を、グローバルなsort(_:_:)関数のかわりに使用します、それによって新しい配列値意味論を反映します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Executable top-level code contains statements and expressions, not just declarations, and is allowed only as the top-level entry point for the program.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>実行可能トップレベルコードは、文と式を含みます、宣言だけでなく、そしてプログラムのトップレベルエントリポイントとしてのみ許可されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Executing the last defer statement in a given scope first means that statements inside that last defer statement can refer to resources that will be cleaned up by other defer statements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある特定のスコープ中の最後のdefer文の実行が最初であることは、その最後のdefer文内の文は別のdefer文によってクリーンアップされることになるリソースを参照できるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Execution Does Not Fall Through Cases Implicitly</seg>
      </tuv>
      <tuv lang="ja">
        <seg>実行は暗黙のうちにケース節を抜け落ちません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Execution doesn’t continue to the next case, so you don’t need to explicitly break out of the switch at the end of each case’s code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>実行は次のケース節に続かないので、あなたは各ケース節のコードの終わりで明示的にスイッチから抜け出す必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Execution of an asynchronous function can be suspended at each expression that’s marked with await.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非同期関数の遂行は、awaitで印される式それぞれで中断されることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Existing bits are moved to the left or right by the requested number of places.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>既存のビットは、左または右へ要請された桁数だけ動かされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Existing instances of a type automatically adopt and conform to a protocol when that conformance is added to the instance’s type in an extension.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある型の既存のインスタンスそれらは、そのインスタンスの型に拡張の中で準拠が加えられるとき、そのプロトコルを自動的に採用して準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Experiment</seg>
      </tuv>
      <tuv lang="ja">
        <seg>試してください</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Experts are additionally ranked by the number of stars they have.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>expertsは加えて、彼らが持つ星の数によってランク付けされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Explicit Member Expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>明示的メンバー式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Explicit Parentheses</seg>
      </tuv>
      <tuv lang="ja">
        <seg>明確な括弧</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Exposing detailed information about the creation of a shape allows types that aren’t meant to be part of the ASCII art module’s public interface to leak out because of the need to state the full return type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある形状の作成についての詳細な情報を露出することは、ASCIIアートモジュールのもつパブリックインターフェイスの一部であることを意図する型それらに漏れ出ていくのを許します、完全な戻り型を公表する必要があるのが原因で。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Expression Pattern</seg>
      </tuv>
      <tuv lang="ja">
        <seg>式パターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Expression patterns appear only in switch statement case labels.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>式パターンは、switch文のケース節ラベルにおいてのみ現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Expressions</seg>
      </tuv>
      <tuv lang="ja">
        <seg>式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extended Grapheme Clusters</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張書記素クラスタ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extended String Delimiters</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張文字列区切り記号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extended grapheme clusters are a flexible way to represent many complex script characters as a single Character value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張書記素クラスタは、多くの複雑な書き方の文字を単一のCharacter値として表わす適応性に富む方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extended grapheme clusters are canonically equivalent if they have the same linguistic meaning and appearance, even if they’re composed from different Unicode scalars behind the scenes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張書記素クラスタが正準等価であるのは、それらが同じ言語的な意味と外観を持つ場合です、たとえそれらが舞台裏で異なるユニコードスカラーから組み立てられるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extended grapheme clusters can be composed of multiple Unicode scalars.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張書記素クラスタは、多数のユニコード・スカラーから構成される可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extended grapheme clusters enable scalars for enclosing marks (such as COMBINING ENCLOSING CIRCLE, or U+20DD) to enclose other Unicode scalars as part of a single Character value:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張書記素クラスタは、囲み記号としてのスカラー（COMBINING ENCLOSING CIRCLE、またはU+20DD）を可能にして、単一のCharacter値の一部として他のユニコード・スカラーを囲み入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extending a Generic Type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体型を拡張する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extending an Existing Type to Specify an Associated Type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>既存の型を拡張して関連型を指定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extending existing types to provide initializers that accept new types (including your own type definitions) is covered in Extensions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>新しい型（あなた独自の型定義を含む）を受け入れるイニシャライザを提供するように既存の型を拡張することは、「拡張」で扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extension Declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extension Syntax</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extension declarations are declared using the extension keyword and have the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張宣言は、キーワードextensionキーワードを使って宣言され、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extension declarations can add protocol conformance to an existing class, structure, or enumeration type by specifying adopted protocols:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張宣言は、プロトコル準拠を既存のクラス、構造体、または列挙型に加えることが採用プロトコルを指定することによって可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extension declarations can contain initializer declarations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張宣言は、イニシャライザ宣言を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extension declarations can’t add class inheritance to an existing class, and therefore you can specify only a list of protocols after the type name and colon.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張宣言は、クラス継承を既存のクラスに加えることができません、従ってあなたは幾らかのプロトコルからなるリストのみをtype name 型名とコロンの後に指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extension declarations can’t contain deinitializer or protocol declarations, stored properties, property observers, or other extension declarations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張宣言は、デイニシャライザまたはプロトコル宣言、格納プロパティ、プロパティオブザーバー、または他の拡張宣言を含むことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extension declarations that extend a generic type or a protocol with associated types can include requirements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体型またはプロトコルを関連型で拡張する拡張宣言は、requirements いくつかの要件を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extensions</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extensions are similar to categories in Objective-C.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張は、Objective-Cでのカテゴリーに似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extensions can add computed instance properties and computed type properties to existing types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張は、既存の型に計算インスタンスプロパティと計算型プロパティを加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extensions can add new computed properties, but they can’t add stored properties, or add property observers to existing properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張は新しい計算プロパティを加えることができます、しかし、それは格納プロパティを加えることができません、またプロパティオブザーバーを既存のプロパティに加えることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extensions can add new convenience initializers to a class, but they can’t add new designated initializers or deinitializers to a class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張は、新しい便利なイニシャライザをクラスに加えることができます、しかし、それは新しい指定イニシャライザまたはデイニシャライザをクラスに加えることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extensions can add new functionality to a type, but they can’t override existing functionality.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張は、新しい機能性をある型に加えることができます、しかしそれは既存の機能性をオーバーライドすることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extensions can add new initializers to existing types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張は、新しいイニシャライザを既存の型に加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extensions can add new instance methods and type methods to existing types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張は、新しいインスタンスメソッドと型メソッドを既存の型に加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extensions can add new nested types to existing classes, structures, and enumerations:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張は、新しい入れ子にされた型を既存のクラス、構造体、および列挙に加えることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extensions can add new properties, methods, and subscripts to an existing type, and are therefore able to add any requirements that a protocol may demand.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張は、新しいプロパティ、メソッド、そして添え字を既存の型に加えることができます、したがって、あるプロトコルが要求するであろうどんな要件でも加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extensions can add new subscripts to an existing type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張は、新しい添え字を既存の型に加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extensions in Swift can:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトの拡張は、以下が可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extensions of a generic type can also include requirements that instances of the extended type must satisfy in order to gain the new functionality, as discussed in Extensions with a Generic Where Clause below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある総称体型のそれぞれの拡張はまた、拡張された型のインスタンスが新しい機能性を獲得する手段として満たさなければならない要件を含むことができます、下の総称体where節を持つ拡張で議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extensions that add protocol conformance to a structure, enumeration, or class use the same keyword as the type they extend uses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル準拠を構造体、列挙、またはクラスに加える拡張それらは、同じキーワードをそれらが利用を拡張するところの型として使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extensions that are in the same file as the class, structure, or enumeration that they extend behave as if the code in the extension had been written as part of the original type’s declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それが拡張するクラス、構造体、または列挙と同じファイルの中にある拡張は、まるでその拡張の中のコードがオリジナルの型の持つ宣言の一部として書かれたかのように振る舞います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extensions that provide a default implementation for a static subscript requirement use the static keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>静的添え字要件に省略時の実装を提供する拡張は、staticキーワードを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extensions that provide a default implementation for a type method requirement use the static keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型メソッド要件に省略時の実装を提供する拡張は、staticキーワードを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extensions that provide a default implementation for a type property requirement use the static keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型プロパティ要件に省略時の実装を提供する拡張は、staticキーワードを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Extensions with a Generic Where Clause</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体where節を持つ拡張</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Failable Initializer Requirements</seg>
      </tuv>
      <tuv lang="ja">
        <seg>失敗できるイニシャライザ要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Failable Initializers</seg>
      </tuv>
      <tuv lang="ja">
        <seg>失敗できるイニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Failable Initializers for Enumerations</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙のための失敗できるイニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Failable Initializers for Enumerations with Raw Values</seg>
      </tuv>
      <tuv lang="ja">
        <seg>生の値を使う列挙のための失敗できるイニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Fallthrough</seg>
      </tuv>
      <tuv lang="ja">
        <seg>抜け落ちる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Fallthrough Statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>フォールスルー文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Finally, Residence defines an optional property called address, with a type of Address?.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最終的に、Residenceはaddressと呼ばれるオプショナルのプロパティを、Address?の型で定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Finally, any convenience initializers in the chain have the option to customize the instance and to work with self.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最後に、連鎖の中のあらゆる便宜イニシャライザは、インスタンスを好みに合わせて作り変えるために、selfを扱うために選択肢を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Finally, once the subclass’s designated initializer is finished, the convenience initializer that was originally called can perform additional customization.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最後に、一旦サブクラスの指定イニシャライザが作業をし終えるならば、最初に呼ばれた便宜イニシャライザは追加の特注処理を実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Finally, the default case matches any other character.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最終的に、defaultケース節が他の文字のすべてにマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Finally, the blue component is obtained by performing a bitwise AND between the numbers 0xCC6699 and 0x0000FF, which gives an output value of 0x000099.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最後に、青の構成要素は数0xCC6699と0x0000FFとの間のビット単位の論理積を実行することによって得られます、それは、0x000099の出力値を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Finally, the overall minimum and maximum values are returned as a tuple of two Int values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最後に、全体で最も小さいそして最も大きい値が２つのInt値のタプルとして返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Find out whether a String value is empty by checking its Boolean isEmpty property:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるString値が空かどうかを、それのブールのisEmptyプロパティを調べることで確認してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>First, it’s possible that dataSource may be nil, and so dataSource has a question mark after its name to indicate that increment(forCount:) should be called only if dataSource isn’t nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>第１に、dataSourceがnilかもしれない可能性があります、なので、dataSourceはその名前の後に疑問符を持ち、dataSourceがnilでない場合にのみincrement(forCount:)が呼ばれるべきであるのを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>First, two classes called Person and Residence are defined:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初に、PersonとResidence（個人と邸宅）と呼ばれる２つのクラスが定義されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>First, you can add -1 to -4, simply by performing a standard binary addition of all eight bits (including the sign bit), and discarding anything that doesn’t fit in the eight bits once you’re done:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>第１に、あなたは-1を-4に加えることが、単純に８つのビット全て（符号ビットを含む）の通常のバイナリの加算を実行して、あなたがそうしたならばその８ビットに収まらない何でも捨てることによって行えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Floating-Point Literals</seg>
      </tuv>
      <tuv lang="ja">
        <seg>浮動小数点リテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Floating-Point Numbers</seg>
      </tuv>
      <tuv lang="ja">
        <seg>浮動小数点数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Floating-point literals can be decimal (with no prefix), or hexadecimal (with a 0x prefix).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>浮動小数点リテラルは、10進（接頭辞なし）、または16進（接頭辞0xつき）であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Floating-point literals can begin with leading zeros (0), but they’re likewise ignored and don’t affect the base or value of the literal.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>浮動小数点リテラルは、いくつかのゼロ（0）を先頭に始まることができます、しかしそれらは同様に無視されて、リテラルの基数または値に影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Floating-point to integer conversion must also be made explicit.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>浮動小数点を整数に変換することは、また、明示的に行われる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Floating-point types can represent a much wider range of values than integer types, and can store numbers that are much larger or smaller than can be stored in an Int.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>浮動小数点型は、整数型よりずっと広い値の幅を表すことができ、そしてIntに格納できるよりずっと大きいまたは小さい数を格納できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Floating-point values are always truncated when used to initialize a new integer value in this way.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この方法で新しい整数値を初期化するとき、浮動小数点値は常に切り詰められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For a complete list of how Swift transforms builder syntax into calls to the builder type’s methods, see resultBuilder.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>どのようにスウィフトがビルダー構文をビルダー型のもつメソッドそれらへと変換するかの完全な一覧として、resultBuilderを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For a complete list of precedence groups provided by the Swift standard library, see Operator Declarations [https://developer.apple.com/documentation/swift/operator_declarations].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフト標準ライブラリによって提供される優先順位グループの完全なリストとして、さまざまな演算子宣言 [https://developer.apple.com/documentation/swift/operator_declarations]を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For a computed property that you define, use the property’s setter to observe and respond to value changes, instead of trying to create an observer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが定義する計算プロパティに対して、プロパティのもつセッターを使うことで値の変化を監視および応答してください、オブザーバを作成しようとするのではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For a description of the Snakes and Ladders gameplay, see Break.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ヘビとはしごのゲームプレイの解説として、Breakを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For a detailed discussion of the Swift standard library Array type, see Arrays.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフト標準ライブラリArray型の詳細な議論のために、配列を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For a detailed discussion of the Swift standard library Dictionary type, see Dictionaries.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフト標準ライブラリDictionary型の詳細な議論として、辞書を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For a detailed discussion of the behavior of in-out parameters and associated compiler optimizations, see In-Out Parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>in-outパラメータの挙動と関連するコンパイラ最適化の詳細な議論として、in-outパラメータを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For a detailed discussion of the behavior of in-out parameters, see In-Out Parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>in-outパラメータの振る舞いの詳細な議論のために、in-outパラメータを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For a dictionary that stores String values, for example, the method returns a value of type String?, or “optional String”.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、String値を格納する辞書に対しては、このメソッドは型String?、すなわち「オプショナルのString」の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For a discussion and several examples of actors that include various kinds of declarations, see Actors.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>いろいろな種類の宣言を含むアクターの解説といくつかの例のために、アクターを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For a discussion and several examples of classes that include various kinds of declarations, see Structures and Classes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>議論および、さまざまな種類の宣言を含むクラスの例のいくつかのために、構造体とクラスを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For a discussion and several examples of extensions that include various kinds of declarations, see Extensions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>いろいろな種類の宣言を含む拡張の解説といくつかの例のために、拡張を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For a discussion and several examples of structures that include various kinds of declarations, see Structures and Classes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>議論および、さまざまな種類の宣言を含む構造体の例のいくつかのために、構造体とクラスを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For a discussion of nested functions, see Nested Functions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>入れ子にされた関数の議論のために、入れ子にされた関数を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For a function or method that’s both asynchronous and throwing, you write async before throws.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非同期とスローの両方である関数やメソッドに対して、あなたはasyncをthrowsの前に書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For a generic function, that return type can use the function’s generic type parameters, but it must still be a single type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体関数に対して、その戻り型は、関数のもつ総称体型パラメータを使用できます、しかしそれは依然として単一の型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For a list of characters that can be used to define custom operators, see Operators.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あつらえの演算子を定義するために使用できる文字のリストとして、演算子を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For a list of those functions, see the stdatomic(3) man page.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そういった演算子の一覧として、stdatomic(3) manページを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For a more detailed comparison, see Choosing Between Structures and Classes [https://developer.apple.com/documentation/swift/choosing_between_structures_and_classes].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>詳細な比較は、構造体とクラスから選ぶ [https://developer.apple.com/documentation/swift/choosing_between_structures_and_classes]を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For a paragraph element, the closure would return "&lt;p&gt;some text&lt;/p&gt;" or "&lt;p /&gt;", depending on whether the text property equals "some text" or nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>段落要素のために、このクロージャは、"&lt;p&gt;some text&lt;/p&gt;"または"&lt;p /&gt;"を返します、textプロパティが"some text"に等しいまたはnilかどうかに従って。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For a property marked with the NSManaged attribute, Core Data also provides the storage at runtime.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>NSManaged属性で印されるプロパティに対して、Coreデータはまたストレージを実行時に提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For a protocol that inherits from another protocol, you add a constraint to an inherited associated type by including the generic where clause in the protocol declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>別のプロトコルから継承するプロトコルに対して、あなたは継承された関連型への制約の追加を、総称体where節をそのプロトコル宣言の中で含めることによって行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For a type that’s defined as public, the default initializer is considered internal.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>publicとして定義される型のために、その省略時のイニシャライザは内部と見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For an alternative way to write this example without defining the init() and init(origin:size:) initializers yourself, see Extensions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>init()とinit(origin:size:)イニシャライザをあなた自身で定義することなくこの例を書く代わりの方法のために、拡張を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For an example and more information about the unowned modifier, see Unowned References.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>unowned修飾子についての例とさらなる情報として、非所有参照を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For an example and more information about the weak modifier, see Weak References.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>weak修飾子についての例と更なる情報のために、弱い参照を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For an example of an autoclosure function type parameter, see Autoclosures.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>自動クロージャ関数型パラメータの例として、自動クロージャを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For an example of an enumeration definition that uses a type inheritance clause to specify the type of its raw values, see Raw Values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その生の値の型を指定するために型継承節を使う列挙定義の例のために、生の値を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For an example of how to use a fallthrough statement in a switch statement, see Control Transfer Statements in Control Flow.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>fallthrough文をswitch文において使う方法の例のために、制御移動文を章制御の流れで見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For an example of how to use a throw statement, see Propagating Errors Using Throwing Functions in Error Handling.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>throw文を使う方法の例のために、スロー関数を使ってエラーを伝えるをエラー処理の章で見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For an example of how to use a deinitializer in a class declaration, see Deinitialization.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラス宣言においてデイニシャライザを使う方法の例のために、デイニシャライズを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For an example of how to use protocol inheritance, see Protocol Inheritance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル継承を使う方法の例のために、プロトコル継承を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For an example of how to use the autoclosure attribute, see Autoclosures and Function Type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>autoclosure属性を使用する方法の例として、自動クロージャと関数型を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For an example of how to use the final attribute, see Preventing Overrides.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>final属性を使う方法の例として、オーバーライドを防ぐを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For an example of how to use the lazy modifier, see Lazy Stored Properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>lazy修飾子を使う方法の例として、遅延格納プロパティを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For an example of how to use the unknown attribute, see Switching Over Future Enumeration Cases.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>unknown属性を使う方法の例のために、未来列挙ケース節に対してスイッチするを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For an example of how to use the resultBuilder attribute, see Result Builders.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>どのようにresultBuilder属性を使うかの例として、リザルトビルダーを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For an example of how to use the escaping attribute, see Escaping Closures.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>escaping属性を使う方法の例として、脱出クロージャを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For an example that demonstrates both of these features, see Functions with Multiple Return Values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの特徴の両方を示す例のために、複数の戻り値をもつ関数を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For an example that uses a switch statement to match enumeration cases containing associated values, see Associated Values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関連値を含んでいる列挙ケース節にマッチするためにswitch文を使う例のために、関連値を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For an example that uses a switch statement to match values with is and as patterns, see Type Casting for Any and AnyObject.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>switch文を使用して、さまざまに値をisやasパターンとマッチする例のために、AnyおよびAnyObjectに対する型キャストを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For an example that uses a variadic parameter, see Variadic Parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>可変長パラメータを使う例のために、可変長パラメータを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For an example that uses a variadic parameter, see Variadic Parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>可変長パラメータを使う例のために、可変長パラメータを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For an example that uses the ternary conditional operator, see Ternary Conditional Operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>三項条件演算子を使用する例のために、三項条件演算子を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For an extended discussion and several examples of class inheritance, see Inheritance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラス継承の広範囲にわたる議論といくつかの例のために、継承を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For an inherited property, you add a property observer by overriding that property in a subclass.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>継承されたプロパティに対して、あなたはプロパティオブザーバを、そのプロパティをサブクラスの中でオーバーライドすることによって追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For an overview of generics in Swift, see Generics.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトでの総称体の概要のために、総称体を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For both signed and unsigned integers, overflow in the positive direction wraps around from the maximum valid integer value back to the minimum, and overflow in the negative direction wraps around from the minimum value to the maximum.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>符号つきおよび符号なし整数の両方に対して、正の方向でのオーバフローは最大限の有効な整数値から逆に最小限へとぐるっと送り込まれ、負の方向でのオーバフローは最小限の値から最大限へとぐるっと送り込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For brevity, multiple values are covered in a single switch case.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>簡潔にするため、複数の値が１つのswitchケース節で扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For characters in strings, “greater than” means “appears later in the alphabet than”.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列の中の文字のために、「より大きい」は「アルファベットにおいてより後に現れる」ことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For class instances, a constant property can be modified during initialization only by the class that introduces it.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスインスタンスのために、定数プロパティは、それを導入するクラスによってのみ初期化の間に修正されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For class instances, the initializer that’s called must be marked with the required keyword or the entire class marked with the final keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスインスタンスに対しては、呼び出されるイニシャライザがrequiredキーワードで印されるか、クラス全体がfinalキーワードで印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For classes that are defined in another module, you can override any open class member.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>別のモジュールにおいて定義されるクラスに対して、あなたはどんな開放クラスメンバーでもオーバーライドできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For computed type properties for class types, you can use the class keyword instead to allow subclasses to override the superclass’s implementation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラス型のための計算型プロパティに対しては、あなたは代わりにclassキーワードを使って、サブクラスにそのスーパークラスの実装のオーバーライドを許可することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For convenience and because the distinction isn’t that important in Swift, the term declaration covers both declarations and definitions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>便利さとその区別がスウィフトにおいてそんなに重要でないことから、用語宣言は、宣言と定義を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For decimal numbers with an exponent of exp, the base number is multiplied by 10exp:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>expの指数を持つある10進数に対して、その基数は10expを掛けられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For details, see Break in a Switch Statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>詳細はスイッチ文の中断を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For each entry in the capture list, a constant is initialized to the value of the constant or variable that has the same name in the surrounding scope.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>キャプチャリストのそれぞれの登録項目に対して、その定数や変数の値へとひとつの定数が初期化されます、それは周囲のスコープの中で同じ名前を待ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For each integer in the array, the function considers the kind computed property for that integer, and prints an appropriate description.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その配列の各整数に対して、この関数はその整数に対するkind計算プロパティを考慮して、適切な説明を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For each item in the array, the enumerated() method returns a tuple composed of an integer and the item.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この配列の各項目に対して、enumerated()メソッドは、整数とその項目から成るひとつのタプルを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For each item, the function checks whether the item from someContainer isn’t equal to the corresponding item in anotherContainer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>各項目のために、関数はsomeContainerからの項目がanotherContainerでの対応する項目と同等でないかどうか確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example in the code below, a is included in the capture list but b is not, which gives them different behavior.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば以下のコードにおいて、aはキャプチャリストに含まれますがbはそうではありません、そのことはそれらに異なる挙動を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, ((Int, Int)) -&gt; Void is the type of a function that takes a single parameter of the tuple type (Int, Int) and doesn’t return any value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、((Int, Int)) -&gt; Voidは、タプル型(Int, Int)の単一のパラメータを取り、何ら値を返さない関数の型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, (Int) is equivalent to Int.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、(Int)はIntに等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, (a: 10, a: 20) is invalid because the label a appears twice at the same level.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、(a: 10, a: 20)は無効です、なぜならラベルaが同じ水準で二度現れるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, Int is a type identifier that directly refers to the named type Int, and the type identifier Dictionary&lt;String, Int&gt; directly refers to the named type Dictionary&lt;String, Int&gt;.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、Intは、直接に名前付きの型Intに言及する型識別子です、そして型識別子Dictionary&lt;String, Int&gt;は、直接に名前付きの型Dictionary&lt;String, Int&gt;に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, LATIN SMALL LETTER E WITH ACUTE (U+00E9) is canonically equivalent to LATIN SMALL LETTER E (U+0065) followed by COMBINING ACUTE ACCENT (U+0301).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、LATIN SMALL LETTER E WITH ACUTE（U+00E9）は、LATIN SMALL LETTER E（U+0065）にCOMBINING ACUTE ACCENT（U+0301）を続けたものと正準等価です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, UInt64(0xffff_ffff_ffff_ffff) evaluates to the correct value rather than overflowing.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、UInt64(0xffff_ffff_ffff_ffff)は正しい値に評価されます、オーバーフローするのではなくて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, Int8 conforms to the ExpressibleByIntegerLiteral protocol, and therefore it can be used in the type annotation for the integer literal 42 in the declaration let x: Int8 = 42.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、Int8はExpressibleByIntegerLiteralプロトコルに準拠します、したがってそれは宣言let x: Int8 = 42の中の整数リテラル42のための型注釈において使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, &lt;S: Sequence&gt; where S.Iterator.Element: Equatable specifies that S conforms to the Sequence protocol and that the associated type S.Iterator.Element conforms to the Equatable protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、&lt;S: Sequence&gt; where S.Iterator.Element: Equatableが指定するのは、SがSequenceプロトコルに準拠すること、そして関連型S.Iterator.ElementがEquatableプロトコルに準拠することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, x.self evaluates to x.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、x.selfはxに評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, .+. is treated as a single operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、.+.は単一の演算子とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, &lt;S1: Sequence, S2: Sequence&gt; where S1.Iterator.Element == S2.Iterator.Element expresses the constraints that S1 and S2 conform to the Sequence protocol and that the elements of both sequences must be of the same type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、&lt;S1: Sequence, S2: Sequence&gt; where S1.Iterator.Element == S2.Iterator.Elementが表す制約は、S1とS2がSequenceプロトコルに準拠すること、そして両方のシーケンスの要素が同じ型でなければならないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, SomeClass.self returns SomeClass itself, not an instance of SomeClass.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、SomeClass.selfは、SomeClass自身を返します、SomeClassのインスタンスではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, class isn’t a valid identifier, but `class` is valid.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、classは有効な識別子ではありません、しかし、`class`は有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, +.+ is treated as the + operator followed by the .+ operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、+.+は、+演算子に.+演算子が続くとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, 0xFp2 represents 15 x 22, which evaluates to 60.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、0xFp2は15 × 22を表します、それは60に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, 1.25e2 represents 1.25 x 102, which evaluates to 125.0.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、1.25e2は1.25 × 102を表します、それは125.0に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, Hangul syllables from the Korean alphabet can be represented as either a precomposed or decomposed sequence.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、コリアン・アルファベットのハングル音節は、最初から組み立てられるか、または分解されて並べたもののどちらでも表わすことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, Swift ensures that variables are initialized before they’re used, memory isn’t accessed after it’s been deallocated, and array indices are checked for out-of-bounds errors.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、変数はそれらが使用される前に初期化されること、メモリはそれがデアロケートされてしまった後にアクセスされないこと、そして配列インデックスは境界外エラーを調べられることを、スウィフトは確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, Swift transforms the call to caps(_:) in that example into code like the following:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、スウィフトはその例におけるcaps(_:)呼び出しを以下のようなコードに変換します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, Swift’s Dictionary type implements a subscript to set and retrieve the values stored in a Dictionary instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、スウィフトのDictionary型は、Dictionaryインスタンスに格納される値を設定したり取り出すために添え字を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, Swift’s Dictionary type places a limitation on the types that can be used as keys for a dictionary.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、スウィフトのDictionary型は、辞書のキーとして使われることができる型に制限を置きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, Swift’s Array and Dictionary types are both generic collections.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、スウィフトのArrayとDictionary型は、両方とも総称体コレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, a control expression matches the case in the example below only if it’s a tuple that contains two elements of the same value, such as (1, 1).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、ある制御式は、それが同じ値の２つの要素を持つタプル、例えば(1, 1)のようなものである場合にのみ、以下の例におけるケース節にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, a case named venus in a Swift Planet enumeration is exposed to Objective-C code as a case named PlanetVenus.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、スウィフトのPlanet列挙の中のvenusと名付けられるケース節は、Objective-CコードにPlanetVenusと名付けられるケース節として暴露されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, a function someFunction&lt;T&gt;() could return a value of type T or Dictionary&lt;String, T&gt;.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、関数someFunction&lt;T&gt;()は、型TまたはDictionary&lt;String, T&gt;の値を返すことができました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, a method of type (Int) -&gt; String becomes ((Int) -&gt; String)?.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、型(Int) -&gt; Stringのメソッドは((Int) -&gt; String)?になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, a private type alias can alias a private, file-private, internal, public, or open type, but a public type alias can’t alias an internal, file-private, or private type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、非公開の型エイリアスは、非公開、ファイル外非公開、内部、公開、または開放型のエイリアス（別名）となることができます、しかし公開型エイリアスは、内部、ファイル外非公開、または非公開型をエイリアスできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, a task that’s downloading photos from a gallery might need to delete partial downloads and close network connections.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、写真をギャラリーからダウンロードするタスクは、中途半端なダウンロードを削除してネットワーク接続を閉じる必要があるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, a variadic parameter with a name of numbers and a type of Double... is made available within the function’s body as a constant array called numbers of type [Double].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、numbersの名前とDouble...の型を持つある可変長パラメータは、関数の本文内で型[Double]のnumbersと呼ばれるある定数配列として利用可能にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, all of the following string literals have the same value:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、以下の文字列リテラルの全ては、同じ値を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, all the read and write accesses in the code listing below are instantaneous:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、以下のコード出力での全ての読み出しおよび書き込みアクセスは即時的です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, as demonstrated in the code below, you can compare two tuples of type (String, Int) because both String and Int values can be compared using the &lt; operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、下のコードで実演されるように、あなたは型(String, Int)の２つのタプルを比較できます、なぜならStringとIntの値の両方とも&lt;演算子を使って比較できるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, because SomeClass.self evaluates to the SomeClass type itself, you can pass it to a function or method that accepts a type-level argument.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、SomeClass.selfはSomeClass型それ自体に評価されるので、あなたはそれを型レベルの引数を受け入れる関数またはメソッドへ渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, both functions below have the same behavior:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、下の両方の関数は同じ挙動を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, consider a game where each player has a health amount, which decreases when taking damage, and an energy amount, which decreases when using special abilities.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、あるゲームを考えてください、そこにおいて各プレイヤーはダメージを受ける場合に減少する体力量、そして特別な能力を使う場合に減少するエネルギー量を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, consider the case of requesting the sunrise and sunset times from a server.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、日の出と日没の時間をあるサーバーに要請する場合を考えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, given the following simple protocol:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、以下の簡単なプロトコルを与えられて：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, here is an enumeration that stores simple arithmetic expressions:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、ここに単純な算術式を格納する列挙があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, here’s a function that evaluates an arithmetic expression:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、ここに算術式の数値を求める関数があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, here’s a method that updates a TemperatureLogger with a new temperature:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、ここにあるメソッドがあります、それはTemperatureLoggerを新しい温度で更新します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, here’s a protocol that refines the Container protocol, adding the requirement of a suffix(_:) method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、ここにContainerプロトコルを改良したプロトコルがあり、suffix(_:)メソッドという要件を追加しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, here’s a version of SmallRectangle from the previous code listing that wraps its properties in the TwelveOrLess structure explicitly, instead of writing @TwelveOrLess as an attribute:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、ここに前のコード出力からのSmallRectangleの変形版があります、それはそれのプロパティをTwelveOrLess構造体の中に明示的にラップします、@TwelveOrLessを属性として書く代わりに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, here’s a version of flip(_:) that uses a protocol type as its return type instead of an opaque return type:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、ここにflip(_:)のあるバージョンがあります、それはあるプロトコル型をそれの戻り型として使います、不透明戻り型の代わりに：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, here’s a version of the Container protocol from Generics:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、ここに総称体からの、Containerプロトコルのあるバージョンがあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, here’s an invalid version of the shape-flipping function that includes a special case for squares:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、ここに形状反転関数の無効なバージョンがあります、それは正方形に対する特別な場合を含みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, here’s an actor that records temperatures:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、ここに温度を記録するあるアクターがあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, here’s an extension to the nongeneric IntStack type that adds SuffixableContainer conformance, using Stack&lt;Int&gt; as its suffix type instead of IntStack:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、ここに非総称体IntStack型に対する拡張があります、それはSuffixableContainer準拠を、Stack&lt;Int&gt;をそれのsuffix型としてIntStackの代わりに使って追加します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, here’s how you might fetch the names of photos in a gallery:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、ここにあなたがあるギャラリーの写真の名前を取って来るかもしれない方法があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, here’s how you might represent the error conditions of operating a vending machine inside a game:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、ここにあなたが表すかもしれないあるゲーム内の自動販売機操作のエラー状況がどのようなものかがあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, if balance(_:_:) was an operator function named &lt;^&gt;, writing playerOneScore &lt;^&gt; playerOneScore would result in the same conflict as balance(&amp;playerOneScore, &amp;playerOneScore).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、balance(_:_:)が&lt;^&gt;という名前の演算子関数であったならば、書き込みplayerOneScore &lt;^&gt; playerOneScoreは、balance(&amp;playerOneScore, &amp;playerOneScore)と同じ衝突という結果になるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, if a public type conforms to an internal protocol, the type’s implementation of each protocol requirement must be at least internal.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、ある公開型が内部プロトコルに準拠するならば、その型の持つ各プロトコル要件の実装は、少なくとも内部でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, if a type is public, but a protocol it conforms to is internal, the type’s conformance to that protocol is also internal.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、ある型が公開である、しかしそれが準拠するプロトコルは内部であるならば、その型のもつそのプロトコルに対する準拠もまた内部です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, if the parameter’s type is an optional type, the closure is wrapped in Optional automatically.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、パラメータのもつ型がオプショナル型であるならば、クロージャは自動的にOptionalにラップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, if the variable holly in the example above is changed to a local variable instead of a global variable, the compiler can prove that overlapping access to stored properties of the structure is safe:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、変数hollyが上の例においてグローバル変数ではなくローカル変数に変更されるならば、コンパイラは構造体に属する格納プロパティへのオーバーラッブするアクセスが安全であることを立証できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, if you assign a literal value of 42 to a new constant without saying what type it is, Swift infers that you want the constant to be an Int, because you have initialized it with a number that looks like an integer:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、あなたがそれがどんな型であるかについて言うことなく、新しい定数にリテラル値42を代入するならば、スウィフトは、あなたがその定数にIntであって欲しいのだと推測します、なぜならあなたがそれを整数のように見える数で初期化したからです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, if you compile your code using the Swift 5 compiler in Swift 4.2 mode, the compiler version is 5 and the language version is 4.2.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、あなたがSwift 5コンパイラを使ってSwift 4.2モードであなたのコードをコンパイルするならば、コンパイラバージョンは5で、言語バージョンは4.2です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, if you compose a tuple from two different types, one with internal access and one with private access, the access level for that compound tuple type will be private.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、あなたが２つの異なる型、内部アクセスを持つものと非公開アクセスを持つものからタプルを組み立てるならば、その複合のタプル型のためのアクセス水準は非公開になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, if you create a custom class to open a file and write some data to it, you might need to close the file before the class instance is deallocated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、あなたがファイルを開いてそれに何かのデータを書くあつらえのクラスを作成するならば、クラスインスタンスが割り当て解除される前に、あなたはファイルを閉じる必要があるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, if you define a file-private class, that class can only be used as the type of a property, or as a function parameter or return type, in the source file in which the file-private class is defined.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、あなたがあるファイル外非公開のクラスを定義するならば、そのクラスは、プロパティの型として、または関数パラメータや戻り型として、そのファイル外非公開クラスが定義されるソースファイルの中で使われることだけができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, if you have properties that provide thread-safety checks or store their underlying data in a database, you have to write that code on every property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、あなたがスレッド安全検査を提供するまたはそれらの基礎をなすデータをデータベースに格納するプロパティそれらを持つならば、あなたはそのコードをあらゆるプロパティ上で書かなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, if you initialize a new string with the four-character word cafe, and then append a COMBINING ACUTE ACCENT (U+0301) to the end of the string, the resulting string will still have a character count of 4, with a fourth character of é, not e:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、あなたがある新しい文字列を４文字の単語cafeで初期化して、それからCOMBINING ACUTE ACCENT（U+0301）をその文字列の終わりに加えたならば、結果の文字列は依然として文字数4で、eではなく、éの４番目の文字を持ちます：&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, if you make a function call inside a subscript in a key path expression, the function is called only once as part of evaluating the expression, not every time the key path is used.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、あなたがキーパス式の中の添え字内で関数呼び出しを作るならば、関数は式の評価の一部としてただ一度だけ呼び出されます、キーパス式が使われるたびごとではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, if you provide an initial value and a maximum value, Swift uses the init(wrappedValue:maximum:) initializer:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、あなたが初期値と最大値を提供するならば、スウィフトはinit(wrappedValue:maximum:)イニシャライザを使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, if you write let dict: Dictionary = ["A": 1], the compiler infers that dict has the type Dictionary&lt;String, Int&gt;.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>たとえば、あなたがlet dict: Dictionary = ["A": 1]を書くならば、コンパイラはdictが型Dictionary&lt;String, Int&gt;を持つと推測します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, if you write a switch statement that has three cases, the compiler uses a binary tree with three leaf nodes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、あなたが３つの事例を持つある切替文を書くならば、コンパイラは３つのリーフノードを備えるあるバイナリツリーを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, if your app uses a custom subclass of UIApplication as its principal class, call the UIApplicationMain(_:_:_:_:) function instead of using this attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、あなたのアプリがそれの主役クラス（プリンシパルクラス）としてUIApplicationのあつらえのサブクラスを使うならば、UIApplicationMain(_:_:_:_:)関数をこの属性を使用する代わりに呼んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, if your string is #"Line 1\nLine 2"# and you want to break the line, you can use #"Line 1\#nLine 2"# instead.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、あなたの文字列が#"Line 1\nLine 2"#であるそしてあなたが行を改めることを望むならば、あなたは#"Line 1\#nLine 2"#を代わりに使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, in addition to the values of scalar types, such as integers and characters, your code can branch on the values of any type, including floating-point numbers, strings, tuples, instances of custom classes, and optionals.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>たとえば、整数と文字のようなスカラー型の値に加えて、あなたのコードは、浮動小数点数、文字列、タプル、あつらえのクラスのインスタンス、そしてオプショナルを含むあらゆる型の値に関して分岐することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, in the code below, myNumber uses SmallNumber as a property wrapper.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、下のコードにおいて、myNumberはSmallNumberをプロパティラッパーとして使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, in the code below, SomeStruct calls each of the initializers that SomeWrapper defines.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、下のコードにおいて、SomeStructは、SomeWrapperが定義するイニシャライザそれぞれを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, in the code below, the closure passed to someFunctionWithEscapingClosure(_:) refers to self explicitly.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、下のコードにおいて、someFunctionWithEscapingClosure(_:)に渡されるクロージャは、selfを明示的に参照します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, in the declaration let x: Int8 = 42, Swift uses the explicit type annotation (: Int8) to infer that the type of the integer literal 42 is Int8.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、宣言let x: Int8 = 42において、スウィフトは明示的な型注釈（: Int8）を使って、整数リテラル42の型はInt8であると推論します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, in the declaration let str = "Hello, world", the default inferred type of the string literal "Hello, world" is String.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、宣言let str = "Hello, world"において、文字列リテラル"Hello, world"の省略時の推論される型はStringです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, in the following assignment 10 is assigned to x and 20 is ignored:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、以下の代入において、10はxに代入されて20は無視されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, in the following code x and y have the same value and behavior:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、以下のコードにおいてxとyは、同じ値と挙動を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, in the following constant declaration, someValue is an identifier pattern that matches the value 42 of type Int:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、以下の定数宣言において、someValueは、型Intの値42にマッチする識別子パターンです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, in the generic function below, the generic parameter T: Comparable indicates that any type argument substituted for the type parameter T must conform to the Comparable protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>たとえば、下記の総称体関数において、総称体パラメータT: Comparableは、型パラメータTと置き換えられる任意の型の引数はComparableプロトコルに準拠しなければならないことを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, instances of a user-defined class named MyClass have the type MyClass.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、MyClassという名前をつけられるユーザー定義のクラスのインスタンスは、型MyClassを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, instead of writing var x: Int = 0, you can write var x = 0, omitting the type completely—the compiler correctly infers that x names a value of type Int.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、var x: Int = 0を書く代わりに、あなたは型を完全に省略してvar x = 0と書くことができます ― コンパイラは、xが型Intの値に名をつけると正しく推測します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, it’s not possible to write an == operator comparing results returned by this function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、この関数によって返される結果を比較する==演算子を書くことは可能ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, maybe a long-running background task continues updating a list of new photo galleries.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、たぶん長期動作のバックグラウンドタスクは、新しい写真ギャラリーのリストの更新を続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, operator precedence explains why the following expression equals 17.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、演算子優先順位は、なぜ以下の式が17に等しいのかを説明します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, overlapping write accesses to the elements of a tuple produces a conflict:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、あるタプルの要素いくつかへの書き込みアクセスがオーバーラップすると衝突を生み出します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, printing the string literal #"Line 1\nLine 2"# prints the line feed escape sequence (\n) rather than printing the string across two lines.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、文字列リテラル#"Line 1\nLine 2"#をブリントすることは、行送りエスケープシーケンス（\n）をプリントします、プリントする文字列が２つの行に渡るのではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, suppose an inventory tracking system needs to track products by two different types of barcode.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、ある在庫追跡システムが、２つの異なる型のバーコードによって製品を追跡する必要があると思ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, suppose you want to make a version of Container that includes an iterator, like what the Sequence protocol uses in the standard library.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、あなたがContainerのあるバージョンを作りたいと仮定してください、それはあるイテレータ、標準ライブラリで使われているSequenceプロトコルのようなものを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, suppose you’re writing a module that draws ASCII art shapes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、あなたがさまざまなASCIIアート形状を描くモジュールを記述していると仮定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the Diccionario type alias declared here has the same generic parameters and constraints as Dictionary.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、ここで宣言されるDiccionario型エイリアスは、Dictionaryと同じ総称体パラメータと制約を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the Int16 integer type can hold any signed integer between -32768 and 32767.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、Int16整数型は、-32768と32767の間のどんな符号つき整数でも持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the PrettyTextRepresentable protocol, which inherits the TextRepresentable protocol can provide a default implementation of its required prettyTextualDescription property to simply return the result of accessing the textualDescription property:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、TextRepresentableプロトコルを継承するprettyTextualDescriptionプロパティは、それの必須プロパティprettyTextualDescriptionの省略時の実装を提供して、単にtextualDescriptionプロパティの結果を返すようにできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the RandomNumberGenerator protocol can be extended to provide a randomBool() method, which uses the result of the required random() method to return a random Bool value:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、RandomNumberGeneratorプロトコルは拡張されてrandomBool()メソッドを提供することができます、それは必須メソッドのrandom()を利用してランダムなBool値を返すものです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the UntitledDocument subclass below is always named "[Untitled]", and it uses the failable init(name:) initializer from its superclass during initialization.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、下のUntitledDocumentサブクラスは、常に"[Untitled]"と名前をつけられます、そしてそれは失敗できるinit(name:)イニシャライザをそれのスーパークラスから初期化の間に使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the asHTML property could be set to a closure that defaults to some text if the text property is nil, in order to prevent the representation from returning an empty HTML tag:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、asHTMLプロパティは、あるクロージャに設定されることができます、それはtextプロパティがnilならば特に何もしなくともいくらかのテキストになり、その表現が空のHTMLタグを返すことを予防する手段となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the discardableResult attribute on a function declaration indicates that, although the function returns a value, the compiler shouldn’t generate a warning if the return value is unused.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、ある関数宣言上でのdiscardableResult属性が指し示すのは、たとえその関数が値を返すとしても、コンパイラは戻り値が使われなくても警告を生成すべきでないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the buildEither(first:) and buildEither(second:) methods below use a generic type that captures type information about both branches.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、下のbuildEither(first:)とbuildEither(second:)メソッドは、ある総称体型を使います、それは両方の分岐について型情報をキャプチャします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the buyFavoriteSnack(person:vendingMachine:) in the example below is also a throwing function, and any errors that the vend(itemNamed:) method throws will propagate up to the point where the buyFavoriteSnack(person:vendingMachine:) function is called.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>たとえば、下の例のbuyFavoriteSnack(person:vendingMachine:)もまたスロー関数です、そしてvend(itemNamed:)メソッドがスローするあらゆるエラーは、buyFavoriteSnack(person:vendingMachine:)関数が呼び出される地点へとさかのぼり伝えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the &lt; operator has an associativity of none, which means 1 &lt; 2 &lt; 3 isn’t a valid expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、&lt;演算子は、noneの関係性を持ちます、それは1 &lt; 2 &lt; 3が有効な式でないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the assert(condition:message:file:line:) function takes an autoclosure for its condition and message parameters; its condition parameter is evaluated only in debug builds and its message parameter is evaluated only if condition is false.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、assert(condition:message:file:line:)関数は自動クロージャをそれのconditionとmessageパラメータとして取ります；それのconditionパラメータはデバッグビルドにおいてのみ評価されます、そしてそれのmessageパラメータはconditionがfalseである場合にのみ評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the Swift standard library includes both a top-level min(_:_:) [https://developer.apple.com/documentation/swift/1538339-min/] function and a min() [https://developer.apple.com/documentation/swift/sequence/1641174-min] method for sequences with comparable elements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、Swift標準ライブラリはトップレベルのmin(_:_:) [https://developer.apple.com/documentation/swift/1538339-min/]関数と比較可能要素を持つシーケンスに対するmin() [https://developer.apple.com/documentation/swift/sequence/1641174-min]メソッドの両方を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the above example can be written so any error that isn’t a VendingMachineError is instead caught by the calling function:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、上の例はVendingMachineErrorでないあらゆるエラーが、呼び出し側の関数によって代わりにキャッチされるように書かれることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the addition (+) and subtraction (-) operators belong to the AdditionPrecedence group, and the multiplication (*) and division (/) operators belong to the MultiplicationPrecedence group.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、加算（+）および減算（-）演算子は、AdditionPrecedenceグルーブに所属し、そして乗算（*）および減算（/）演算子はMultiplicationPrecedenceグルーブに属します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the addition assignment operator (+=) combines addition and assignment into a single operation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、加算代入演算子（+=）は、加算と代入を一回の操作に結合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the addition operator (+) adds two numbers, as in let i = 1 + 2, and the logical AND operator (&amp;&amp;) combines two Boolean values, as in if enteredDoorCode &amp;&amp; passedRetinaScan.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、加算演算子（+）は、let i = 1 + 2のように、２つの数を加えてひとつにします、そして論理積演算子（&amp;&amp;）は、if enteredDoorCode &amp;&amp; passedRetinaScanのように、２つのブール値を組み合わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the class below ensures that the side length of its triangle is always the same as the side length of its square.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、下のクラスは、その三角形の横の長さが常にその正方形の横の長さと同じものであることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the code below builds an AnyDrawable value from its availability check.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、下のコードはAnyDrawable値をそれの有効性検査から作り上げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the code below defines a simple result builder that builds an array of integers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、下のコードはある単純なリザルトビルダーを定義します、それは整数それらからなるある配列を組み立てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the code below fetches the names of all the pictures in a gallery and then shows the first picture:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、下のコードは、あるギャラリーの全ての画像の名前を取ってきて、それから最初の画像を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the code below shows an instance method f whose return type is Self.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、以下のコードはインスタンスメソッドfを示します、それの戻り型はSelfです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the code in resize(to:) accesses height and width using their property wrapper.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、resize(to:)でのコードは、heightとwidthにそれらのプロパティラッパーを使ってアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the declarations of SubProtocol below are equivalent:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、下のSubProtocolの宣言は同等です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the definition of PQR in the code below is equivalent to P &amp; Q &amp; R.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、以下のコードでのPQRの定義は、P &amp; Q &amp; Rと同等です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the expression 2 + 3 * 5 is initially understood as a flat list of five items, 2, +, 3, *, and 5.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、式2 + 3 * 5は、最初に５つの項目、2、+、3、*、そして5の平坦なリストとして理解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the expression 4 + 5 * 6 becomes buildExpression(4 + 5 * 6) rather multiple calls to that function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、式4 + 5 * 6はbuildExpression(4 + 5 * 6)になります、その関数に対する複数の呼び出しではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the expression (5 + 4) * 2 has a number on the right-hand side of the multiplication and another expression on the left-hand side of the multiplication.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、式(5 + 4) * 2は、１つの数を掛け算の右手側に、そして別の式を掛け算の左手側に持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the following are equivalent:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、以下のものはどれも等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the following code contains both a read access and a write access:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、以下のコードは読み出しアクセスと書き込みアクセスの両方を含みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the following code declares a ComparableContainer protocol that requires Item to conform to Comparable:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、以下のコードはComparableContainerプロトコルを宣言します、それはItemがComparableに準拠することを要求します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the following code defines a version of Container that requires the items in the container to be equatable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、以下のコードはContainerのあるバージョンを定義します、それはコンテナの中の項目に同等評価可能であることを要求するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the following code downloads a list of photo names, downloads the first photo in that list, and shows that photo to the user:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、以下のコードは写真名のリストをダウンロードして、そのリストの最初の写真をダウンロードして、そしてその写真をユーザに示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the following code isn’t valid because the element 0 in the tuple pattern (x, 0) is an expression pattern:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、以下のコードは有効ではありません、タプルパターン(x, 0)の中の要素0が式パターンであるためです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the following code iterates through the closed range 1...3, ignoring the current value of the range on each iteration of the loop:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、完結範囲1...3のすべてに繰り返す以下のコードは、ループの各繰り返しにおいて範囲の現在の値を無視しています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the following code matches against all three cases of the VendingMachineError enumeration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、以下のコードはVendingMachineError列挙の３つのケース節すべてに対して適合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the following code throws an error to indicate that five additional coins are needed by the vending machine:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、以下のコードはあるエラーをスローして、５つの追加のコインが自動販売機に必要とされることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the following code uses a loadImage(atPath:) function, which loads the image resource at a given path or throws an error if the image can’t be loaded.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、以下のコードはloadImage(atPath:)関数を使います、それは画像リソースを与えられたパスでロードします、または画像がロードできないならばエラーをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the following code uses a different filtering rule on iOS:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、以下のコードはiOS上では異なるフィルタ規則を使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the following code uses several approaches to fetch data, or returns nil if all of the approaches fail.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、以下のコードはいくつかの取り組みを使ってデータを取ってきます、またはすべての取り組みが失敗するならばnilを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the following declarations are equivalent:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、以下の宣言は同等です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the following is invalid because the catch clause would handle the error thrown by alwaysThrows().</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、以下のものは無効です、なぜならcatch節がalwaysThrows()によってスローされるエラーを取り扱おうとするからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the following listing shows chained method calls split over several lines:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、以下のコード出力は、連結されたメソッド呼び出しがいくつかの行に分けられるのを示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the following protocol can be adopted only by class types:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、以下のプロトコルはクラス型によってのみ採用されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the function below loads a picture for a photo gallery:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、下の関数はあるピクチャをフォトギャラリーに対してロードします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the function in the following code returns a type that depends on its caller:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、以下のコードの関数は、それの呼び出し側に依存する、ある型を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the function in the following example returns a trapezoid without exposing the underlying type of that shape.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、以下の例での関数は、ある台形を、その形状の基礎をなす型を露出することなしに返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the function type (Int) -&gt; (Int) -&gt; Int is understood as (Int) -&gt; ((Int) -&gt; Int)—that is, a function that takes an Int and returns another function that takes and returns an Int.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、関数型(Int) -&gt; (Int) -&gt; Intは、(Int) -&gt; ((Int) -&gt; Int)として理解されます ― すなわち、ひとつのIntを取って、ひとつのIntを取りそして返す別の関数を返す関数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the initializer for the PurchasedSnack structure in the listing below calls a throwing function as part of the initialization process, and it handles any errors that it encounters by propagating them to its caller.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、以下のコード出力のPurchasedSnack構造体のためのイニシャライザは、スロー関数を初期化処理の一部として呼び出します、そしてそれは、それが遭遇するどんなエラーもそれの呼び出し側にそれらを伝達することによって取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the metatype of the class type SomeClass is SomeClass.Type and the metatype of the protocol SomeProtocol is SomeProtocol.Protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、クラス型SomeClassのメタタイプはSomeClass.Typeです、そして、プロトコルSomeProtocolのメタタイプはSomeProtocol.Protocolです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the structure of a tuple (1, 2) is a comma-separated list of two elements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、タプル(1, 2)の構造は、コンマで区切られた２つの要素のリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the subtraction operator (-) is left-associative, so the expression 4 - 5 - 6 is grouped as (4 - 5) - 6 and evaluates to -7.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、減算演算子（-）は左結合です、それで式4 - 5 - 6は(4 - 5) - 6のようにグループにされて、-7に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the tuple pattern (x, y): (Int, Int) in the constant declaration let (x, y): (Int, Int) = (1, 2) matches only tuple types in which both elements are of type Int.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、定数宣言let (x, y): (Int, Int) = (1, 2)におけるタプルパターン(x, y): (Int, Int)は、両方の要素が型Intであるタプル型だけにマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the tuple type (Int, (Int, Int)) contains two elements: The first is the named type Int, and the second is another compound type (Int, Int).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>たとえば、タプル型(Int, (Int, Int))は、２つの要素を含みます：第一は名前付きの型Intです、そして第二は別の複合の型(Int, Int)です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the type identifier in the following code references the named type MyType that’s declared in the ExampleModule module.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、以下のコードの型識別子は、ExampleModuleモジュールで宣言される名前付きの型MyTypeを参照します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the values of textA and textB in the example below are identical—no runtime concatenation is performed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>たとえば、以下の例のtextAとtextBの値は同一です ― 実行時連結は行われません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the variadic parameter Int... is treated as [Int].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>たとえば、可変長パラメータInt...は[Int]とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, there are two things named x in the code below, a variable in the outer scope and a constant in the inner scope, but they both refer to the same object because of reference semantics.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、xと名前をつけられる２つのものが以下のコードにはあります、外側のスコープの中の変数と内側のスコープの中の定数、しかしそれらは両方とも同じオブジェクトを参照します、なぜなら参照意味論だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, this code defines a result builder called DrawingBuilder, which lets you use a declarative syntax to describe a drawing:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、このコードはDrawingBuilderと呼ばれるリザルトビルダーを定義します、それはあなたに宣言的な構文を使って描画を記述させます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, this protocol, called TextRepresentable, can be implemented by any type that has a way to be represented as text.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、このプロトコル、TextRepresentableと呼ばれるものは、テキストとして表わされる方法を持つどんな型によってでも実装されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, to create a new stack of strings, you write Stack&lt;String&gt;():</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、新しく文字列のスタックを作成するために、あなたはStack&lt;String&gt;()を書きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, to fetch the first three photos from a gallery, you could await three calls to the downloadPhoto(named:) function as follows:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、最初の３枚の写真をあるギャラリーから取ってくるには、あなたはdownloadPhoto(named:)関数への３つの呼び出しに対して待機します、次のように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, use as? to conditionally downcast the first object in a heterogeneous array to a String as follows:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、as?を使うことで、ある雑多な配列の中の最初のオブジェクトをStringオブジェクトへと、条件付きでダウンキャストしてください、以下のように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, use a precondition to check that a subscript isn’t out of bounds, or to check that a function has been passed a valid value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、前提時要件を使って、ある添え字が範囲外でないことを調べてください、またはある関数が有効な値を渡されていることを確認してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, when a computed property or a property with observers is passed as an in-out parameter, its getter is called as part of the function call and its setter is called as part of the function return.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、計算プロパティまたはオブザーバを持つプロパティがin-outパラメータとして渡される時、それのゲッターは関数呼び出しの一部として呼び出され、それのセッターは関数の戻りの一部として呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, when integers are used for raw values, the implicit value for each case is one more than the previous case.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、整数が生の値のために使われるとき、各ケース節に対する暗黙の値は、その前のケース節よりも１つ多くなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, writing shoppingList[shoppingList.count] = "Salt" to try to append an item to the end of the array results in a runtime error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、shoppingList[shoppingList.count] = "Salt"と書くことでこの配列の終わりに項目を加えようとするのは実行時エラーという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, you access elements in an Array instance as someArray[index] and elements in a Dictionary instance as someDictionary[key].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、あなたはあるArrayインスタンスの中の要素にsomeArray[index]として、そしてあるDictionaryインスタンスの中の要素にsomeDictionary[key]のようにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, you can assign values of implicitly unwrapped optionals to variables, constants, and properties of optionals, and vice versa.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>たとえば、あなたは暗黙的にアンラップされるオプショナルの値を、オプショナルの変数、定数、そしてプロパティに代入することができます、その逆もまたできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, you can constrain the associated types of type parameters to conform to protocols.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>たとえば、あなたは型パラメータの関連型をいくらかのプロトコルに準拠するように制約することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, you can create a three-dimensional array of integers using three sets of square brackets:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、あなたは３つ固めた角括弧を使って整数の三次元配列をつくることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, you can decompose the elements of a tuple and bind the value of each element to a corresponding identifier pattern.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、あなたはタプルの要素を分解して、各要素の値を対応する識別子パターンへと縛り付けることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, you can define a constant or variable to be of a function type and assign an appropriate function to that variable:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、あなたはある関数型となる定数または変数を定義して、適切な関数をその変数に代入することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, you can define a public type that can be used in other modules, but whose conformance to an internal protocol can only be used within the internal protocol’s defining module.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>たとえば、あなたは、別のモジュール内で使われることができる公開の型を定義することができます、しかし内部プロトコルに準拠するものは、ただその内部プロトコルの定義するモジュール内で使われることができるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, you can define an extension to the Collection protocol that applies to any collection whose elements conform to the Equatable protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、それの要素がEquatableプロトコルに準拠するあらゆるコレクションに適用されるCollectionプロトコルに対して、あなたはある拡張を定義できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, you can override an asynchronous method with a synchronous method, and a synchronous method can satisfy a protocol requirement that requires an asynchronous method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、あなたは非同期メソッドを同期メソッドでオーバーライドできます、そして同期メソッドは、非同期メソッドを必要とするプロトコル要件を満たすことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, you can refine the behavior of that existing implementation, or store a modified value in an existing inherited variable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、あなたはその既存の実施の挙動を洗練させたり、既存の継承された変数に修正された値を格納することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, you can replace the type parameter Element in Array&lt;Element&gt; with a specialized version of an array, Array&lt;Int&gt;, to form an array whose elements are themselves arrays of integers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、あなたはArray&lt;Element&gt;における型パラメータElementを配列の特殊化版、Array&lt;Int&gt;で置き換えて、要素それ自身が整数の配列である配列を作り出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, you can rewrite the above example to compare the point expression with a string representations of points.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、あなたは上記の例を書き直して、point式をpoint（座標）の文字列表現と比較するようにできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, you can use a defer statement to ensure that file descriptors are closed and manually allocated memory is freed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、あなたはdefer文を使ってファイル記述子が閉じられて手動割り当てメモリが解放されることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, you can use the protocol composition type ProtocolA &amp; ProtocolB &amp; ProtocolC instead of declaring a new protocol that inherits from ProtocolA, ProtocolB, and ProtocolC.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、プロトコル合成型ProtocolA &amp; ProtocolB &amp; ProtocolCを使うことが、ProtocolA、ProtocolB、そしてProtocolCから継承する新しいプロトコルを宣言する代わりに行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, you can use this syntax with an array that was bridged to Array from an NSArray subclass that makes no API contract about its storage.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、あなたはこの構文をArrayからNSArrayサブクラスへとブリッジされた配列でそれのストレージについてAPI協定をしないものに使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, you can write a generic where clause on a subscript of a generic type or on a method in an extension to a generic type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、あなたは総称体where節をある総称体型の添え字上でまたはある総称体型への拡張の中のメソッド上で書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, you can’t use print(13) as an implicit return value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、あなたはprint(13)を暗黙的戻り値として使用することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, you can’t use a private type as the raw-value type of an enumeration with an internal access level.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、あなたはある非公開型を、内部のアクセス水準をもつ列挙の「生の値」型として使うことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, you can’t write let b = a += 2.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、あなたはlet b = a += 2を書くことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, you can’t write a public protocol that inherits from an internal protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、あなたは内部のプロトコルから継承する公開のプロトコルを書くことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, you use declarations to introduce functions and methods, to introduce variables and constants, and to define enumeration, structure, class, and protocol types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、あなたは宣言を使うことで、関数やメソッドを導入したり、変数や定数を導入したり、そして列挙、構造体、クラス、そしてプロトコル型を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For examples of conforming types that implement the method requirements of a protocol, see Method Requirements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるプロトコルのメソッド要件を満たすものである準拠している型の例のために、メソッド要件を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For examples of conforming types that implement the property requirements of a protocol, see Property Requirements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるプロトコルのプロパティ要件を実装するものである、準拠している型の例のために、プロパティ要件を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For examples of how to use a break statement, see Break and Labeled Statements in Control Flow.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>break文を使う方法の例のために、ブレークとラベルをつけられた文を章制御の流れで見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For examples of how to use a continue statement, see Continue and Labeled Statements in Control Flow.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>continue文を使う方法の例のために、続けるとラベルをつけられた文を章制御の流れで見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For examples of how to use these various types of values in switch statements, see Switch in Control Flow.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらのいろいろな型の値をswitch文で使う方法の例のために、スイッチを制御の流れで見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For hexadecimal numbers with an exponent of exp, the base number is multiplied by 2exp:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>expの指数を持つある16進数に対して、その基数は２expを掛けられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For information about private, see Access Control.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>privateに対する情報として、アクセス制御を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For information about #file, #fileID, and #filePath, see Literal Expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>#file、#fileID、そして#filePathについての情報として、リテラル式を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For information about actors, see Concurrency.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>アクターについての情報として、並行性を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For information about avoiding conflicting access to memory, see Memory Safety.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メモリへのアクセスの衝突の回避についての情報として、メモリ安全を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For information about conforming to protocols, see Protocols.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルに準拠することについての情報として、Protocolsを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For information about frozen and nonfrozen enumerations, see frozen.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>凍結および非凍結列挙についての情報として、frozenを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For information about how you can wrap explicit member expressions in conditional compilation blocks, see Explicit Member Expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>どのようにあなたが明示的メンバー式を条件コンパイルブロックの中にラップできるかについての情報として、明示的メンバー式を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For information about implementing the required hash(into:) method, see Hashable [https://developer.apple.com/documentation/swift/hashable].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>必須hash(into:)メソッドを実装することについての情報として、Hashable [https://developer.apple.com/documentation/swift/hashable]を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For information about initialization and initializer syntax, see Initialization.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>初期化とイニシャライザ構文についての情報として、初期化を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For information about key-value coding and key-value observing, see Key-Value Coding Programming Guide [https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i] and Key-Value Observing Programming Guide [https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>キー値コーディングとキー値監視についての情報として、キー値コーディングプログラミングガイド [https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i]とキー値監視プログラミングガイド [https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i]を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For information about making your own custom types conform to the Hashable protocol, see Conforming to the Hashable Protocol [https://developer.apple.com/documentation/swift/hashable#2849490].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなた独自のあつらえの型をHashableプロトコルに準拠させることについての情報として、Hashableプロトコルに準拠する [https://developer.apple.com/documentation/swift/hashable#2849490]を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For information about parameters with default values, see Default Parameter Values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>省略時の値を持つパラメータについての情報として、省略時のパラメータ値を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For information about passing a closure as an argument to a function, see Function Call Expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャを引数として関数に渡すことに関する情報については、関数呼び出し式を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For information about protocols, see Protocols.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルについての情報として、プロトコルを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For information about reference cycles, see Automatic Reference Counting.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>参照循環についての情報として、自動参照カウントを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For information about reference types, see Classes Are Reference Types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>参照型に関して詳しくは、クラスは参照型ですを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For information about subscript declarations, see Protocol Subscript Declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字宣言に関して詳しくは、プロトコル添え字宣言を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For information about the behavior of these operators, see Basic Operators and Advanced Operators.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの演算子の挙動に関して詳しくは、基本の演算子と先進の演算子を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For information about the operators provided by the Swift standard library, including a complete list of the operator precedence groups and associativity settings, see Operator Declarations [https://developer.apple.com/documentation/swift/operator_declarations].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフト標準ライブラリによって提供される演算子についての情報として、演算子優先順位と結合性の設定の完全なリストを含めて、さまざまな演算子宣言 [https://developer.apple.com/documentation/swift/operator_declarations]を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For information about the operators provided by the Swift standard library, including a complete list of the operator precedence groups and associativity settings, see Operator Declarations [https://developer.apple.com/documentation/swift/operator_declarations].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフト標準ライブラリによって提供される演算子についての情報として、演算子優先順位と結合性の設定の完全なリストを含めて、さまざまな演算子宣言 [https://developer.apple.com/documentation/swift/operator_declarations]を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For information about the operators provided by the Swift standard library, see Operator Declarations [https://developer.apple.com/documentation/swift/operator_declarations].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフト標準ライブラリによって提供される演算子についての情報のために、さまざまな演算子宣言 [https://developer.apple.com/documentation/swift/operator_declarations]を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For information about value types, see Structures and Enumerations Are Value Types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>値型に関して詳しくは、構造体と列挙は値型ですを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For information about weak references, see Strong Reference Cycles Between Class Instances.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>弱い参照についての詳細は、クラスインスタンス間の強い参照循環を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For information on optional chaining, see Optional Chaining.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル連鎖に関する情報のために、オプショナル連鎖を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For information on using playground literals in Xcode, see Add a color, file, or image literal [https://help.apple.com/xcode/mac/current/#/dev4c60242fc] in Xcode Help.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Xcodeにおけるプレイグラウンドリテラルの使用に関するさらなる情報として、Add a color, file, or image literal [https://help.apple.com/xcode/mac/current/#/dev4c60242fc]をXcodeヘルプで見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For instance methods on value types (that is, structures and enumerations) you place the mutating keyword before a method’s func keyword to indicate that the method is allowed to modify the instance it belongs to and any properties of that instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>値型（すなわち、構造体と列挙）のインスタンスメソッドのために、あなたはmutatingキーワードをメソッドのfuncキーワードの前に置いて、メソッドがそれが属しているインスタンスおよびそのインスタンスのあらゆるプロパティを修正するのを許可されることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For instance, failable initializers are implemented for numeric type conversions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、いくつかの失敗できるイニシャライザが数値型変換のために実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For instance, in the example below, the use of Point in the type annotation refers to the tuple type (Int, Int).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>たとえば、下記の例で、型注釈においてPointを使うことは、タプル型(Int, Int)に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For instance, the pattern (x, y) matches the tuple (1, 2) and any other two-element tuple.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>たとえば、パターン(x, y)はタプル(1, 2)および他のどんな２要素タプルにでもマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For instance, the variadic parameter Int... is treated as [Int].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>たとえば、可変長パラメータInt...は[Int]とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more about for-in loops, see Control Flow.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>for-inループに関する詳細は、制御の流れを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more about arrays and dictionaries, see Collection Types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列と辞書に関する詳細は、コレクション型を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more about arrays, see Arrays.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列に関する詳細は、配列を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more about extensions, see Extensions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張についてのより多くのために、拡張を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more about generic where clauses, see Generic Where Clauses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体where節に関する詳細は、総称体where節を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more about generic types and collections, see Generics.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体型とコレクションに関する詳細は「総称体」を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more about operator methods, see Operator Methods.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>演算子メソッドについてさらに、演算子メソッドを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more about ranges, see Range Operators.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>範囲に関する詳細は、範囲演算子を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more about reference and value semantics, see Structures and Enumerations Are Value Types and Classes Are Reference Types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>参照および値意味論に関する詳細は、構造体と列挙は値型ですとクラスは、参照型ですを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more about the for-in loop, see For-In Loops.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>更にfor-inループについて、for-inループを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more about the if statement, see Control Flow.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>if文に関する詳細は、制御の流れを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more about the final modifier, see Preventing Overrides.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>final修飾子に関する詳細は、オーバーライドを防ぐを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more about these capabilities, see Properties, Methods, Initialization, Extensions, and Protocols.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの能力に関する詳細は、プロパティ、メソッド、初期化、拡張、そしてプロトコルを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more details, see Protocol Extensions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>詳細は、プロトコル拡張を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more discussion and examples of in-out parameters, see In-Out Parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>in-outパラメータの議論と例のために、in-outパラメータを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information about Dictionary subscripting, see Accessing and Modifying a Dictionary.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Dictionaryで添え字を使うことの詳細については、辞書へのアクセスと修正を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information about capture lists, see Capture Lists.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>キャプチャリストについての更なる情報として、キャプチャリストを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information about casting, see Type Casting.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>キャストについてのさらなる情報として、型キャストを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information about compound cases, see Compound Cases.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複合ケース節についてのさらなる情報として、複合ケース節を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information about constants and for guidance about when to use them, see Constants and Variables and Stored Properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数の詳細について、そしていつそれらを使うべきかの手引きとして、定数と変数および格納プロパティを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information about deinitializers, see Deinitialization.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>デイニシャライザの詳細については、デイニシャライザを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information about escaping closures, see Escaping Closures.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>脱出クロージャについてのさらなる情報として、脱出クロージャを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information about generic where clauses and to see an example of one in a generic function declaration, see Generic Where Clauses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体where節のさらなる情報のために、そして総称体関数宣言におけるそれの一例を見るために、総称体where節を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information about how to use the optional modifier and for guidance about how to access optional protocol members—for example, when you’re not sure whether a conforming type implements them—see Optional Protocol Requirements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>optional修飾子を使う方法についての更なる情報のために、そしてオプショナルプロトコルメンバーにアクセスする方法についての手引きとして ― 例えば、あなたがある準拠型がそれらを実装するかどうか確信が持てない時など ― オプショナルのプロトコル要件を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information about how to use the optional declaration modifier and for guidance about how to access optional protocol members—for example, when you’re not sure whether a conforming type implements them—see Optional Protocol Requirements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>optional宣言修飾子を働かせる方法に関する詳細は、そして、オプショナルのプロトコルメンバーにアクセスする方法 ― 例えば、ある準拠している型がそれらを実装するかどうかについてあなたが確信が持てない時など ― についての手引きとしてオプショナルのプロトコル要件を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information about implicitly unwrapped optional types, see Implicitly Unwrapped Optionals.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>暗黙的にアンラップされるオプショナル型の詳細については、暗黙的にアンラップされるオプショナルを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information about in-out parameters and to see an example, see In-Out Parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>In-Outパラメータについてのより多くの情報のために、そして例を見るために、In-Outパラメータを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information about initializer delegation, see Initializer Delegation for Value Types and Initializer Delegation for Class Types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>イニシャライザ委任についての更なる情報として、値型のためのイニシャライザ委任とクラス型のためのイニシャライザ委任を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information about managing detached tasks, see Task [https://developer.apple.com/documentation/swift/task].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>分離されたタスクを管理することについての更なる情報として、Task [https://developer.apple.com/documentation/swift/task]を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information about memory safety and memory exclusivity, see Memory Safety.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メモリ安全とメモリ排他についての更なる情報として、メモリ安全を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information about pattern matching, see Patterns.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>パターンマッチングについての更なる情報として、パターンを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information about precedence groups and to see the syntax for defining your own operators and precedence groups, see Operator Declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>優先順位グループについてのさらなる情報として、そしてあなた独自の演算子と優先順位グループを定義するための構文を見るには、演算子宣言を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information about subscripting and to see examples of subscript declarations, see Subscripts.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字に関するより多くの情報のために、そして、添え字宣言の例を見るために、添え字を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information about task groups, see TaskGroup [https://developer.apple.com/documentation/swift/taskgroup].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タスクグループについての更なる情報として、TaskGroup [https://developer.apple.com/documentation/swift/taskgroup]を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information about the String type, see Strings and Characters and String [https://developer.apple.com/documentation/swift/string].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>String型についての詳細として、文字列と文字とString [https://developer.apple.com/documentation/swift/string]を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information about the fallthrough statement, see Fallthrough Statement below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>fallthrough文の詳細については、下記のフォールスルー文を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information about the patterns you can use in a catch clause, see Patterns.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがcatch節において使うパターンについての更なる情報として、パターンを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information about this attribute, see Attributes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性についてのさらなる情報として、属性を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information about this class, see Handling Cocoa Errors in Swift [https://developer.apple.com/documentation/swift/cocoa_design_patterns/handling_cocoa_errors_in_swift].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このクラスについてのさらなる情報として、CocoaエラーをSwiftにおいて処理する [https://developer.apple.com/documentation/swift/cocoa_design_patterns/handling_cocoa_errors_in_swift]を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information about type casting and to see examples that use the type-casting operators, see Type Casting.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型キャストに関するより多くの情報のために、そして、型キャスト演算子を使用する例をより多く見るために、型キャストを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information about using Array with Foundation and Cocoa, see Bridging Between Array and NSArray [https://developer.apple.com/documentation/swift/array#2846730].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>FoundationとCocoaとともにArrayを使うことについてのさらなる情報として、ArrayとNSArrayの間のブリッジ [https://developer.apple.com/documentation/swift/array#2846730]を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information about using Dictionary with Foundation and Cocoa, see Bridging Between Dictionary and NSDictionary [https://developer.apple.com/documentation/swift/dictionary#2846239].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>FoundationとCocoaとともにDictionaryを使うことについてのさらなる情報として、ArrayとNSArrayの間のブリッジ [https://developer.apple.com/documentation/swift/dictionary#2846239]を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information about using Set with Foundation and Cocoa, see Bridging Between Set and NSSet [https://developer.apple.com/documentation/swift/set#2845530].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>FoundationとCocoaとともにSetを使うことについてのさらなる情報として、ArrayとNSArrayの間のブリッジ [https://developer.apple.com/documentation/swift/set#2845530]を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information about using String with Foundation and Cocoa, see Bridging Between String and NSString [https://developer.apple.com/documentation/swift/string#2919514].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>FoundationとCocoaとともにStringを使うことについてのさらなる情報として、ArrayとNSArrayの間のブリッジ [https://developer.apple.com/documentation/swift/string#2919514]を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information about using key paths in Swift code that interacts with Objective-C APIs, see Using Objective-C Runtime Features in Swift [https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Objective-C APIと相互作用するSwiftコードにおけるキーパスの使用についてのさらなる情報として、Objective-Cランタイム機能をSwiftで使用する [https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift]を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information about using key paths in code that interacts with Objective-C APIs, see Using Objective-C Runtime Features in Swift [https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Objective-C APIと相互作用するコードにおけるキーパスの使用についてのさらなる情報として、Objective-Cランタイム機能をSwiftで使用する [https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift]を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information about using multiple optional chaining operations, see Linking Multiple Levels of Chaining.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複数のオプショナル連鎖演算を使用することについての更なる情報として、連鎖の複数の階層を結ぶを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information about using selectors in Swift code that interacts with Objective-C APIs, see Using Objective-C Runtime Features in Swift [https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Objective-C APIと相互作用するSwiftコードにおけるセレクタの使用についてのさらなる情報として、Objective-Cランタイム機能をSwiftで使用する [https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift]を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information and examples of capture lists, see Resolving Strong Reference Cycles for Closures.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>キャプチャリストのより多くの情報と例のために、クロージャのための強い参照循環の解消を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information and examples of closure expressions, see Closure Expressions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャ式のより多くの情報と例のために、クロージャ式を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information and examples, see Associated Types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>より多くの情報と例のために、関連型を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information and to see an example of how to use property observers, see Property Observers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>より多くの情報のために、そして、プロパティオブザーバーを使う方法の例を見るために、プロパティオブザーバーを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information and to see examples of cases with associated value types, see Associated Values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>より多くの情報のために、そして関連値型をもつケース節の例を見るために、関連値を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information and to see examples of cases with raw-value types, see Raw Values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>より多くの情報のために、そして「生の値」型をもつケース節の例を見るために、生の値を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information and to see examples of computed properties, see Computed Properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>より多くの情報のために、そして、計算プロパティの例を見るために、計算プロパティを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information and to see examples of failable initializers, see Failable Initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>さらなる情報と、失敗できるイニシャライザの例を見るために、失敗できるイニシャライザを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information and to see examples of how to use try, try?, and try!, see Error Handling.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>より多くの情報のために、そしてtry、try?、そしてtry!文を使う方法の例を見るために、エラーを処理するを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information and to see examples of how to use statement labels, see Labeled Statements in Control Flow.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>より多くの情報のために、そして、文ラベルを使用する方法の例を見るために、ラベルをつけられた文を制御の流れで見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information and to see examples that show how to use optional types, see Optionals.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>より多くの情報のために、そしてオプショナル型を使う方法を示す例を見るために、オプショナルを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information on bridging, see Working with Foundation Types [https://developer.apple.com/documentation/swift/imported_c_and_objective_c_apis/working_with_foundation_types].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ブリッジに関するより多くの情報のために、Foundation型を扱う [https://developer.apple.com/documentation/swift/imported_c_and_objective_c_apis/working_with_foundation_types]を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information on functions with the Never return type, see Functions that Never Return.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Never戻り型を持つ関数でのさらなる情報は、決して戻らない関数を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information on property observers, see Property Observers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティオブザーバーの詳細については、プロパティオブザーバーを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information on required initializers, see Required Initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>必須イニシャライザに関する更なる情報として、必須イニシャライザを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information see Type Variable Properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>更なる情報として、型変数プロパティを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information, see type(of:) [https://developer.apple.com/documentation/swift/2885064-type] in the Swift standard library.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>詳細は、type(of:) [https://developer.apple.com/documentation/swift/2885064-type]をスウィフト標準ライブラリで見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information, see Assigning Constant Properties During Initialization.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>更なる情報として、初期化の間に定数プロパティを割り当てるを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information, see Constant Declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>更なる情報として、定数宣言を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information, see Extensions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>詳細は、拡張を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information, see Failable Initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>さらなる情報として、失敗できるイニシャライザを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information, see Inheritance, Type Casting, Deinitialization, and Automatic Reference Counting.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>詳細は、継承、型キャスト、デイニシャライズ、そして自動参照カウントを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information, see Properties, Methods, Subscripts, Initialization, Extensions, and Protocols.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>詳細は、プロパティ, メソッド、添え字、初期化、拡張、そしてプロトコルを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information, see Structures and Classes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>詳細は、クラスと構造体を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information, see Importing Swift into Objective-C [https://developer.apple.com/documentation/swift/imported_c_and_objective-c_apis/importing_swift_into_objective-c].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>さらなる情報は、SwiftをObjective-Cにインポートする [https://developer.apple.com/documentation/swift/imported_c_and_objective-c_apis/importing_swift_into_objective-c]を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information, see Class-Only Protocols and AnyObject [https://developer.apple.com/documentation/swift/anyobject].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>さらなる情報として、クラス専用プロトコルとAnyObject [https://developer.apple.com/documentation/swift/anyobject]を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information, see Automatic Initializer Inheritance below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>更なる情報は、以下の自動的なイニシャライザ継承を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information, see Strong Reference Cycles for Closures.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>詳細は、クロージャのための強い参照循環を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information, see Optional Binding.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>更なる情報として、オプショナルの束縛を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information, see Sets.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>更なる情報として、集合を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information, see Functions with Multiple Return Values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>詳細は、「複数の戻り値をもつ関数」を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information, see Checking for Protocol Conformance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>更なる情報として、プロトコル準拠の確認を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information, see Declaration Attributes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>更なる情報として、宣言属性を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information, see Precedence Group Declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>さらなる情報は、優先順位グループ定義を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information, see Identity Operators.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>更なる情報として、同一性演算子を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information, see Type-Casting Operators.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>更なる情報として、型キャスト演算子を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information, see Raw Values and Enumerations with Cases of a Raw-Value Type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>更なる情報として、生の値と「生の値」型のケース節を持つ列挙を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For more information, see the propertyWrapper section of the Attributes chapter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>さらなる情報として、属性の章のpropertyWrapperの節を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For multithreaded code, use Thread Sanitizer [https://developer.apple.com/documentation/xcode/diagnosing_memory_thread_and_crash_issues_early] to help detect conflicting access across threads.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>マルチスレッドコードに対しては、Thread Sanitizer [https://developer.apple.com/documentation/xcode/diagnosing_memory_thread_and_crash_issues_early]を使うことでスレッドをまたぐアクセス衝突を検出する助けとしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For readability, a compound case can also be written over multiple lines.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>可読性のために、複合ケース節はまた複数行にわたって書かれることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For simple numeric values, the unary minus operator converts positive numbers into their negative equivalent and vice versa.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>単純な数の値のために、この単項マイナス演算子は正の数をその負の等価物に変えます、逆の場合も同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For some enumerations, it’s useful to have a collection of all of that enumeration’s cases.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>いくつかの列挙に対して、その列挙の持つケース節の全てからなるコレクションを持つことは役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For the numberOfLegs dictionary above, the key-value subscript takes and returns a value of type Int?, or “optional int”.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のnumberOfLegs辞書のために、その「キーと値」添え字は型Int?、つまり「オプショナルのint」の値を受け取りそして返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For the example above, this enables the names of Suit, Rank, and Values to be kept deliberately short, because their names are naturally qualified by the context in which they’re defined.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例で、これは、Suit、Rank、そしてValuesの名前が故意に短いままにしておかれるようにします、なぜなら、それらが定義される文脈によってそれらの名前が自然に修飾されて限定されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For the numeric cards, it uses the rank’s raw Int value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>数字カードのために、それは等級の生のInt値を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For the other three properties, new VideoMode instances will be initialized with an interlaced setting of false (meaning “noninterlaced video”), a playback frame rate of 0.0, and an optional String value called name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>他の３つのプロパティのために、新しいVideoModeインスタンスは、falseに設定されるinterlaced（「ノンインタレース・ビデオ」を意味します）、0.0の再生フレームレート、nameというオプショナルのString値で初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For the purpose of access control, extensions to the same type that are in the same file share an access-control scope.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>アクセス制御の目的のために、同じ型で同じファイルの中にあるものに対する拡張それらは、アクセス制御スコープを共有します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For the purposes of these rules, the characters (, [, and { before an operator, the characters ), ], and } after an operator, and the characters ,, ;, and : are also considered whitespace.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの規則を理由に、演算子の前の文字(、[、および{、演算子の後の文字)、]、および}、そして文字,、;、および:は、また、空白と見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For the purposes of this example, +++ is treated as a new “prefix doubling” operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例の目的のために、+++は新しい「接頭辞倍加」演算子とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For the same reason, you can’t pass the same value to multiple in-out parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じ理由のために、あなたは複数のin-outパラメータに対して同じ値を渡すことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For these types, Objective-C methods typically return a special value (such as NSNotFound) to indicate the absence of a value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの型のために、Objective-Cメソッドは、値の欠如を示すために概して特別な値（例えばNSNotFound）を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For this calculation, the individual counter values each time through the loop are unnecessary—the code simply executes the loop the correct number of times.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この計算では、ループするごとに個別のカウンタ値は必要ではありません ― このコードは単に正しい回数ループを実行するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For this reason, Swift strings can’t be indexed by integer values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この理由のために、スウィフトの文字列は整数値でインデックス付けされることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For this reason, the default implementation provided by the Loggable protocol is used instead.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この理由のために、Loggableプロトコルによって提供される省略時の実装が代わりに使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For value types, you use self.init to refer to other initializers from the same value type when writing your own custom initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>値型のために、あなたはself.initを使って、あなた独自のあつらえのイニシャライザを書くとき同じ値型の他のイニシャライザに言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For-In Loops</seg>
      </tuv>
      <tuv lang="ja">
        <seg>for-inループ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For-In Statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>For-In文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Forced-Value Expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>強制された値式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Foundation also extends String to expose methods defined by NSString.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Foundationはまた、Stringを拡張してNSStringによって定義されるメソッドに触れさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Frozen types, the types of the stored properties of frozen structures, and the associated values of frozen enumeration cases must be public or marked with the usableFromInline attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>凍結型、凍結構造体の格納プロパティの型、そして凍結列挙ケース節の関連値は、パブリックであるかusableFromInline属性で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Function Argument Labels and Parameter Names</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数の引数ラベルとパラメータ名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Function Call Expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数呼び出し式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Function Declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Function Parameters and Return Values</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数のパラメータと戻り値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Function Type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Function Types</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Function Types as Parameter Types</seg>
      </tuv>
      <tuv lang="ja">
        <seg>パラメータ型としての関数型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Function Types as Return Types</seg>
      </tuv>
      <tuv lang="ja">
        <seg>戻り型としての関数型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Function call expressions have the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数呼び出し式は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Function declarations are declared using the func keyword and have the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数宣言は、キーワードfuncを使って宣言されます、そして以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Function parameters and return values are extremely flexible in Swift.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数パラメータと戻り値は、スウィフトではとても柔軟です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Function parameters are a comma-separated list where each parameter has one of several forms.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数パラメータはひとつの「コンマ区切り」のリストです、そこにおいて各パラメータはいくつかの書式のうちの１つを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Function parameters are constants by default.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数パラメータは、特に何もしなければ定数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Function parameters can have both a name (for use within the function’s body) and an argument label (for use when calling the function), as described in Function Argument Labels and Parameter Names.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数パラメータは、名前（関数の本文内で使うため）と引数ラベル（関数を呼び出すとき使うため）の両方を持つことができます、関数の引数ラベルとパラメータ名で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Function type parameters with the escaping type attribute require explicit use of self. for properties or methods.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>escaping型属性を持つ関数型パラメーターは、明示的なself.の使用をプロパティやメソッドに対して必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Function types that can throw or rethrow an error must be marked with the throws keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>エラーをスローまたは再スローできる関数型は、throwsキーワードで印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Functions</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Functions With Multiple Parameters</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複数のパラメーターを持つ関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Functions With an Implicit Return</seg>
      </tuv>
      <tuv lang="ja">
        <seg>暗黙的なreturnをもつ関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Functions Without Parameters</seg>
      </tuv>
      <tuv lang="ja">
        <seg>パラメータのない関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Functions Without Return Values</seg>
      </tuv>
      <tuv lang="ja">
        <seg>戻り値のない関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Functions and Closures</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数とクロージャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Functions and closures that are defined inside an inlinable function are implicitly inlinable, even though they can’t be marked with this attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>インライン可能関数内部で定義される関数とクロージャは、暗黙的にインライン可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Functions and methods that can throw an error must be marked with the throws keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>エラーをスローできる関数とメソッドは、throwsキーワードで印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Functions and methods that run asynchronously must be marked with the async keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非同期に動作する関数とメソッドは、asyncキーワードで印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Functions and methods with the Never return type are called nonreturning.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Never戻り型を持つ関数およびメソッドは、非復帰と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Functions are a first-class type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数は、第一級（ファーストクラス）の種類のものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Functions are actually a special case of closures: blocks of code that can be called later.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数は、実際のところクロージャ：後刻に呼び出されることができるコードのひとまとまり、の特別な場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Functions aren’t required to define a return type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数は、戻り型を定義することを要求されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Functions aren’t required to define input parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数は、入力パラメータを定義することを要求されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Functions can also be written within other functions to encapsulate useful functionality within a nested function scope.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数は、また、他の関数の内部で記述されることで、役に立つ機能性を入れ子にされた関数スコープ内でカプセル化することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Functions can be nested.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数は、入れ子にされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Functions can have multiple input parameters, which are written within the function’s parentheses, separated by commas.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数は複数の入力パラメータを持つことが出来ます、それは関数の丸括弧内に書かれ、コンマで区切られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Functions can return multiple values using a tuple type as the return type of the function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数は、関数の戻り型としてタプル型を使って、複数の値を返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Functions that Never Return</seg>
      </tuv>
      <tuv lang="ja">
        <seg>決して返らない関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Functions that return an opaque type require the Swift 5.1 runtime.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>不透明型を返す関数は、Swift 5.1ランタイムを必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Functions with Multiple Return Values</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複数の戻り値を持つ関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Functions without a defined return type return a special value of type Void.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>戻り型定義のない関数は、型Voidの特別な値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Fundamental Set Operations</seg>
      </tuv>
      <tuv lang="ja">
        <seg>集合演算の基本</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Furthermore, a new CreditCard instance can only be created by passing a number value and a customer instance to a custom CreditCard initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>さらに、新しいCreditCardインスタンスは、number値とcustomerインスタンスをあつらえのCreditCardイニシャライザに渡すことによってのみ作成されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Future versions of the library can’t change the declaration by adding, removing, or reordering an enumeration’s cases or a structure’s stored instance properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ライブラリの将来のバージョンは、追加、削除、または列挙のもつケース節や構造体のもつ格納インスタンスプロパティの再配列によって宣言を変更できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Generally speaking, protocol types give you more flexibility about the underlying types of the values they store, and opaque types let you make stronger guarantees about those underlying types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>一般的に言えば、プロトコル型はそれらが格納する値の基礎をなす型についてあなたにより柔軟性を与えます、そして不透明型はそれらの基礎をなす型についてあなたにより確固とした保証をさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Generic Argument Clause</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体引数節</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Generic Functions</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Generic Parameter Clause</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体パラメータ節</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Generic Parameters and Arguments</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体パラメータと引数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Generic Subscripts</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体添え字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Generic Types</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Generic Where Clauses</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体where節</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Generic classes can inherit from other generic and nongeneric classes, but a nongeneric class can inherit only from other nongeneric classes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体クラスは、他の総称体および非総称体クラスから継承することができます、しかし非総称体クラスはただ他の非総称体クラスからのみ継承することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Generic code enables you to write such a function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体コードは、あなたにこのような関数を書くことを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Generic types let the code that calls a function pick the type for that function’s parameters and return value in a way that’s abstracted away from the function implementation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体型は、ある関数を呼び出すコードに、その関数のもつパラメータと戻り値に対する型を、関数実装から離れて抽象化されるある方法で選択させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Generics</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Generics are one of the most powerful features of Swift, and much of the Swift standard library is built with generic code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体は、スウィフトの最も強力な特徴のうちの１つです、そして、多くのスウィフト標準ライブラリは総称体コードで組み立てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Gettable and settable properties are indicated by writing { get set } after their type declaration, and gettable properties are indicated by writing { get }.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>取得可能かつまた設定可能なプロパティは、それらの型宣言の後に{ get set }を書くことによって示されます、そして取得可能なプロパティは{ get }を書くことによって示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Getters and Setters</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ゲッターとセッター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Getters and setters for constants, variables, properties, and subscripts automatically receive the same access level as the constant, variable, property, or subscript they belong to.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数、変数、プロパティ、そして添え字のためのゲッターとセッターは、自動的に、それらが属している定数、変数、プロパティまたは添え字と同じアクセス水準を受けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Give enumeration types singular rather than plural names, so that they read as self-evident:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙型に複数形よりむしろ単数形の名前を与えてください、わかりきったことという印象を受けるので：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Give properties and methods lowerCamelCase names (such as frameRate and incrementCount) to differentiate them from type names.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティとメソッドにlowerCamelCase ローワーキャメルケース名（例えばframeRateやincrementCountなど）を与えて、それらを型名と区別するようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Give types UpperCamelCase names (such as SomeStructure and SomeClass here) to match the capitalization of standard Swift types (such as String, Int, and Bool).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それら型にUpperCamelCase アッパーキャメルケース名（ここでのSomeStructureやSomeClassのような）を与えて、標準のスウィフト型（例えばString、Int、そしてBoolなど）の大文字の使用法に合わせてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Global and Local Variables</seg>
      </tuv>
      <tuv lang="ja">
        <seg>グローバルおよびローカル変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Global and nested functions, as introduced in Functions, are actually special cases of closures.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数で紹介される、グローバルおよび入れ子にされた関数は、実際にはクロージャの特別な場合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Global constants and variables are always computed lazily, in a similar manner to Lazy Stored Properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>グローバルな定数と変数は、遅延格納プロパティと似たやり方で、常に遅延計算されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Global functions are closures that have a name and don’t capture any values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>グローバルな関数は、名前を持ち、まったく値をキャプチャしない（捕獲しない）クロージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Global variables are variables that are defined outside of any function, method, closure, or type context.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>グローバルな変数は、あらゆる関数、メソッド、クロージャ、または型の文脈の外で定義される変数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a Self type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Self型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a branch statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>分岐文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a break statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ブレーク文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a class declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラス宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a closure expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャ式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a code block</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コードブロックの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a compile-time diagnostic statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コンパイル時診断文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a compiler control statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コンパイラ制御文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a conditional compilation block</seg>
      </tuv>
      <tuv lang="ja">
        <seg>条件コンパイルブロックの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a conditional operator</seg>
      </tuv>
      <tuv lang="ja">
        <seg>条件演算子の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a constant declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a continue statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>継続文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a control transfer statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>制御移動文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a declaration modifier</seg>
      </tuv>
      <tuv lang="ja">
        <seg>宣言修飾子の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a defer statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>defer文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a deinitializer declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>デイニシャライザ宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a dictionary type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>辞書型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a do statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>do文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a fallthrough statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>フォールスルー文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a floating-point literal</seg>
      </tuv>
      <tuv lang="ja">
        <seg>浮動小数点リテラルの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a for-in statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>for-in文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a forced-value expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>強制された値の式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a function call expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数呼び出し式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a function declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a function type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a generic argument clause</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体引数節の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a generic parameter clause</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体パラメータ節の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a getter-setter block</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ゲッターセッター・ブロックの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a guard statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>guard文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a implicit member expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>暗黙的メンバー式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a key-path expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>キーパス式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a key-path string expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>キーパス文字列式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a labeled statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ラベルをつけられた文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a line control statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>行制御文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a literal</seg>
      </tuv>
      <tuv lang="ja">
        <seg>リテラルの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a literal expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>リテラル式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a loop statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ループ文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a metatype type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メタタイプ型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a parenthesized expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>丸括弧に入れられた式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a pattern</seg>
      </tuv>
      <tuv lang="ja">
        <seg>パターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a postfix expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>接尾辞式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a postfix self expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>接尾辞self式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a precedence group declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>優先順位グループ宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a prefix expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>接頭辞式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a primary expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>基本式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a protocol associated type declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル関連型宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a protocol composition type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル合成型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a protocol declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a protocol initializer declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル・イニシャライザ宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a protocol method declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルメソッド宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a protocol property declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルプロパティ宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a protocol subscript declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル添え字宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a repeat-while statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>repeat-while文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a return statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>return文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a selector expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>セレクタ式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a self expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>self式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a string literal</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列リテラルの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a structure declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a subscript declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a subscript expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a superclass expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スーパークラス式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a switch statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>switch文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a throw statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スロー文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a top-level declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>トップレベル宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a try expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>try式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a tuple expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タプル式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a tuple pattern</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タプル・パターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a tuple type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タプル型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a type alias declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型エイリアス宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a type annotation</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型注釈の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a type casting pattern</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型キャスト・パターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a type identifier</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型識別子の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a type inheritance clause</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型継承節の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a type-casting operator</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型キャスト演算子の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a value-binding pattern</seg>
      </tuv>
      <tuv lang="ja">
        <seg>値束縛パターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a variable declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>変数宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a while statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>while文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a wildcard expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ワイルドカード式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of a wildcard pattern</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ワイルドカード・パターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of an Any type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Any型の構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of an actor declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>アクター宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of an array type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of an assignment operator</seg>
      </tuv>
      <tuv lang="ja">
        <seg>代入演算子の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of an attribute</seg>
      </tuv>
      <tuv lang="ja">
        <seg>属性の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of an availability condition</seg>
      </tuv>
      <tuv lang="ja">
        <seg>有効性条件の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of an await expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>await式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of an enumeration case pattern</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙ケース節パターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of an enumeration declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of an explicit member expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>明示的メンバー式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of an expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of an expression pattern</seg>
      </tuv>
      <tuv lang="ja">
        <seg>式パターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of an extension declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of an identifier</seg>
      </tuv>
      <tuv lang="ja">
        <seg>識別子の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of an identifier pattern</seg>
      </tuv>
      <tuv lang="ja">
        <seg>識別子パターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of an if statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>if文の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of an implicitly unwrapped optional type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>暗黙的にアンラップされるオプショナル型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of an import declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>インポート宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of an in-out expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>in-out式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of an infix expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>接中辞式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of an initializer declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>イニシャライザ宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of an initializer expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>イニシャライザ式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of an integer literal</seg>
      </tuv>
      <tuv lang="ja">
        <seg>整数リテラルの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of an opaque type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>不透明型の構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of an operator declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>演算子宣言の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of an optional pattern</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルパターンの文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of an optional type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル型の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of an optional-chaining expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル連鎖式の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of operators</seg>
      </tuv>
      <tuv lang="ja">
        <seg>演算子の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grammar of whitespace</seg>
      </tuv>
      <tuv lang="ja">
        <seg>空白の文法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Greater than (a &gt; b)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>より大きい (a &gt; b)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Greater than or equal to (a &gt;= b)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>より大きいか等しい、以上 (a &gt;= b)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Greet n times</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（n回あいさつします）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Grouping parentheses don’t change an expression’s type—for example, the type of (1) is simply Int.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>グループ化括弧はある式のもつ型を変えません — 例えば、(1)の型は単にIntです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Guard Statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>guard文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Guiding Principle of Access Levels</seg>
      </tuv>
      <tuv lang="ja">
        <seg>アクセス水準の原理指針</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Half-Open Range Operator</seg>
      </tuv>
      <tuv lang="ja">
        <seg>半開範囲演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Half-open ranges are particularly useful when you work with zero-based lists such as arrays, where it’s useful to count up to (but not including) the length of the list:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>半開範囲は、あなたが配列のようなゼロに基づくリストを扱うとき特に便利です、そこにおいて、そのリストの長さまで（しかしそれは含まずに）数え上げるのに役に立ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Handling Errors</seg>
      </tuv>
      <tuv lang="ja">
        <seg>エラーを処理する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Handling Errors Using Do-Catch</seg>
      </tuv>
      <tuv lang="ja">
        <seg>do-catchを使ってエラーを処理する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Hash Values for Set Types</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Set型のためのハッシュ値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Having created a new Vehicle instance, you can access its description property to print a human-readable description of the vehicle’s current speed:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>新しいVehicleインスタンスを作成したら、あなたはそれのdescriptionプロパティにアクセスして、その乗り物の現在速度の説明を人の読めるように出力することが出来ます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here are two classes, Circle and Country, both of which conform to the HasArea protocol:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その両方ともHasAreaプロトコルに従う２つのクラス、CircleとCountryが、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here is the general form of a do-catch statement:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここにdo-catch文の一般的な形式があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here the function returns an integer, so x and y are optional integers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここに整数を返す関数があります、それでxとyはオプショナル整数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here, $0 and $1 refer to the closure’s first and second String arguments.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここでは、$0と$1は、クロージャの１番目と２番目のString引数に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here, AudioSample is defined as an alias for UInt16.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここでは、AudioSampleはUInt16に対するエイリアス（別名）として定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here, self disambiguates between a method parameter called x and an instance property that’s also called x:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここでは、selfは、xと呼ばれるメソッドパラメータと同様にまたxと呼ばれるインスタンスプロパティの間の曖昧さをなくします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here, a new array called breakfastList is created from an array literal containing three new ShoppingListItem instances.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここでは、breakfastListと呼ばれる新しい配列は、３つの新しいShoppingListItemインスタンスを含んでいる配列リテラルからつくられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here, an additional if statement was added to respond to particularly warm temperatures.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここでは、追加のif文は、特に暖かい気温に反応するために加えられました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here, the favoriteGenres set is initialized with three String values ("Rock", "Classical", and "Hip hop"), written within an array literal.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここでは、favoriteGenres集合は、配列リテラル内に書かれる、３つのString値（"Rock"、"Classical"、そして"Hip hop"）で初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here, the shoppingList array is initialized with two String values ("Eggs" and "Milk"), written within an array literal.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここで、shoppingList配列は、配列リテラル内に書かれる２つのString値（"Eggs"と"Milk"）で初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here, the deinitializer simply returns all of the player’s coins to the bank:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここでは、デイニシャライザは単に胴元にプレーヤーのコインの全てを返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here, the function type of the sorted(by:) method’s argument makes it clear that a Bool value must be returned by the closure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここでは、sorted(by:)メソッドの引数である関数型は、Bool値がクロージャによって返されなければならないことを明白にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here, the player has won 2,000 coins.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここでは、プレーヤーは2,000個のコインを獲得しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here, the possibility that increment(forCount:) might not be implemented is also handled by optional chaining.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここでは、increment(forCount:)が実装されないかもしれないという可能性もまたオプショナル連鎖によって取り扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here, the raw values for an enumeration called ASCIIControlCharacter are defined to be of type Character, and are set to some of the more common ASCII control characters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここでは、ASCIIControlCharacterと呼ばれる列挙に対する生の値は、型Characterであると定義されて、たいへんありふれたASCII制御文字のいくつかに設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here, the superclass has a single designated initializer and two convenience initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここでは、スーパークラスは１つの指定イニシャライザと２つの便宜イニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here, the value of the constant three is used to create a new value of type Double, so that both sides of the addition are of the same type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここでは、定数threeの値が、Double型の新しい値をつくるために使われます、それでこの加算の両側は同じ型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here, they’re used to print the categorization of the point.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここでは、それらはポイントの分類を出力するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s a class called Animal, which doesn’t conform to the HasArea protocol:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>HasAreaプロトコルに従わないAnimalと呼ばれるクラスが、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s a function called chooseStepFunction(backward:), whose return type is (Int) -&gt; Int.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここにchooseStepFunction(backward:)と呼ばれる関数があります、それの戻り型は(Int) -&gt; Intです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s a function with no input parameters, which always returns the same String message whenever it’s called:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここに入力パラメータのない関数があります、そしてそれは、それが呼ばれるときはいつでも、常に同じStringメッセージを返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s a generic version of the swapTwoInts(_:_:) function from above, called swapTwoValues(_:_:):</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここに、上記のswapTwoInts(_:_:)関数の総称体版があります、それはswapTwoValues(_:_:)と呼ばれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s a generic version of the same code:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じコードの総称体版は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s a more complex class, which also adopts and conforms to the FullyNamed protocol:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>また、FullyNamedプロトコルを採用して準拠するさらに複雑なクラスが、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s a more complex data source called TowardsZeroSource, which makes a Counter instance count up or down towards zero from its current count value:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>TowardsZeroSourceと呼ばれるより複雑なデータ・ソースがここにあります、それは、Counterインスタンスをその現在のcount値から上下にゼロの方へ数えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s a nongeneric function called findIndex(ofString:in:), which is given a String value to find and an array of String values within which to find it.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここにfindIndex(ofString:in:)と呼ばれる非総称体関数があります、それは、見つけるString値と、そこにおいてそれを捜すString値からなる配列を与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s a simple CounterDataSource implementation where the data source returns a constant value of 3 every time it’s queried.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある単純なCounterDataSource実装がここにあります、そこにおいて、データ・ソースは3の定数値をそれが問い合わされるたびに返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s a skeleton outline of how a closure can be used to provide a default property value:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここに、あるクロージャが省略時のプロパティ値を提供するために使われることができる方法の骨組み概要があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s a standard, nongeneric function called swapTwoInts(_:_:), which swaps two Int values:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここに、通常の、非総称体のswapTwoInts(_:_:)と呼ばれる関数があります、それは、２つのInt値を交換します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s a structure that stores a rectangle that uses the TwelveOrLess property wrapper to ensure its dimensions are always 12 or less:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここにある構造体があります、それはある矩形を格納します、それはTwelveOrLessプロパティラッパーを使うことでそれの寸法を常に12かそれ以下にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s a variation of the greet(person:) function that takes a person’s name and hometown and returns a greeting:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここにgreet(person:)関数の変形があります、それはある個人の名前と出身地をとって挨拶を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s a version of doSomething() that captures self by including it in the closure’s capture list, and then refers to self implicitly:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここにdoSomething()のある変異版があります、それはselfを、それをクロージャのもつキャプチャリストの中に含めることによってキャプチャします、そしてそれからselfを暗黙的に参照します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s a version of the greet(person:) function, which prints its own String value rather than returning it:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここにgreet(person:)関数の改作があります、それはString値を自身で出力します、それを返すのではなく：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s a version of the listPhotos(inGallery:) function that uses sleep(nanoseconds:) to simulate waiting for a network operation:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここにlistPhotos(inGallery:)関数のあるバージョンがあります、それはsleep(nanoseconds:)を使ってネットワーク演算を待つことの模擬実験をします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s a version of the Snakes and Ladders game originally introduced in Control Flow.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>制御の流れで元々は紹介されるヘビとはしごゲームのひとつの改作が、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s a version of the nongeneric IntStack type from Generic Types above, adapted to conform to the Container protocol:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここに、上の総称体型からの非総称体IntStack型の改作、Containerプロトコルに準拠するために適応させたものがあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an alternative version of the Rect structure that takes advantage of this shorthand notation:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここにRect構造体の代替のバージョンがあります、それはこの短縮形表記法を利用します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an another version of the Rect structure that takes advantage of this shorthand notation and the shorthand notation for setters:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここにRect構造体の別のバージョンがあります、それはこの省略形表記法とセッターに対する省略形表記法を利用します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example for the four main points of a compass:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここに、コンパスの主な４方位のための例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example of makeIncrementer in action:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>動作しているmakeIncrementerの例がここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example of willSet and didSet in action.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>willSetとdidSetの作動する例が、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example of a deinitializer in action.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>デイニシャライザの動作の例は、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example of a function called makeIncrementer, which contains a nested function called incrementer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここに、makeIncrementerと呼ばれる関数の例があります、それはincrementerと呼ばれる入れ子にされた関数を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example of a function called swapTwoInts(_:_:), which has two in-out integer parameters called a and b:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここにswapTwoInts(_:_:)と呼ばれる関数の例があります、それは、aとbと呼ばれる２つのin-out整数パラメータを持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example of a function that incorporates its type parameter into the underlying type of the value it returns:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここに、ある関数の例があります、それはそれの型パラメータを、それが返す値のその基礎をなす型へと組み入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example of a protocol called Container, which declares an associated type called Item:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Containerと呼ばれるプロトコルの例がここにあります、それはItemと呼ばれる関連型を宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example of a protocol that inherits the TextRepresentable protocol from above:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のTextRepresentableプロトコルを継承するプロトコルの例は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example of a protocol used as a type:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型として使われるプロトコルの例は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example of a protocol with a single instance property requirement:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ただ１つのインスタンスプロパティ要件を持つプロトコルの例が、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example of a read-only subscript implementation, which defines a TimesTable structure to represent an n-times-table of integers:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここに読み出し専用の添え字の実施の例があります、それは、整数の九九のn段を表すTimesTable構造体を定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example of a simple structure that adopts and conforms to the FullyNamed protocol:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>FullyNamedプロトコルを採用して準拠する単純な構造体の例は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example of a structure definition and a class definition:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体定義とクラス定義の例は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example of how Automatic Reference Counting works.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>自動参照カウントがどのように働くかの例は、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example of how a strong reference cycle can be created by accident.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>強い参照循環がどのように偶然に作られることができるかの例は、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example of how constants and variables can be used to track the number of login attempts a user has made:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここに定数と変数が、どのようにあるユーザーが行ったログインの試みの数を追跡するために使われることができるかの例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example of how error handling can be used to respond to different error conditions:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここにどのようにエラー処理が異なるエラー状態に応答するために使われることができるかの例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example of how optionals can be used to cope with the absence of a value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここに、値の欠如に対処するためにどのようにオプショナルが使われることができるかの１つの例があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example of this syntax for a while loop, although the principle is the same for all loops and switch statements:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここに、この構文のwhileループに対する例があります、とはいえその原則は全てのループとswitch文のための同じです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example of using Any to work with a mix of different types, including function types and nonclass types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数型と非クラス型を含む、異なった型の混合を扱うためにAnyを使う例が、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example of using these classes:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここにこれらクラスを使う例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example of what happens when an unsigned integer is allowed to overflow in the positive direction, using the overflow addition operator (&amp;+):</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここに、オーバフロー加算演算子（&amp;+）を使用して、正の向きにおいて符号なし整数がオーバフローを許されるとき何が起こるかの例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example that combines the Named protocol from the previous example with a Location class:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここに１つの例があります、それは前の例からのNamedプロトコルをLocationクラスと結び付けます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example that combines two protocols called Named and Aged into a single protocol composition requirement on a function parameter:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここに、関数パラメータ上でNamedとAgedと呼ばれる２つのプロトコルを１つのプロトコル合成要件に結合する例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example that defines a simple Counter class, which can be used to count the number of times an action occurs:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>単純なCounterクラスを定義する例がここにあります、それは、ある動作が起こる回数を数えるために使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example that keeps track of the courses offered by a particular department at a school:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここに例があります、それはある学校でのある特定の学科（Department）によって提供される課程（Course）それらの情報を得続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example that stores raw ASCII values alongside named enumeration cases:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>指定した列挙ケース節の傍らに生のASCII値を格納する例は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example to print the results of the math functions from above:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここに上記の数学関数の結果を出力する例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example using the overflow subtraction operator (&amp;-):</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここにオーバフロー減算演算子（&amp;-）を使った例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example, using the VideoMode class defined above:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上で定義されるVideoModeクラスを使用している例がここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example, which calculates the height for a table row.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここにひとつの例があります、それはあるテーブルの列の高さを計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここにひとつの例があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an example:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここにある例があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an expanded version of TwelveOrLess called SmallNumber that defines initializers that set the wrapped and maximum value:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここにある拡張されたバージョンのTwelveOrLess、SmallNumberと呼ばれるものがあります、それはラップされたそして最大限の値を設定するイニシャライザそれらを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an expanded version of the Celsius example from Initialization Parameters above, with an additional initializer to create a new Celsius instance from a Double value that’s already in the Celsius scale:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここに上の初期化パラメータからのCelsius例の拡張版があります、それは追加のイニシャライザを使って、既に摂氏尺度であるDouble値から新しいCelsiusインスタンスを作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an extension of the Stack type from Generic Types above that adds conformance to the SuffixableContainer protocol:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここに、上のGeneric TypesからのStack型の拡張があります、それはSuffixableContainerプロトコルへの準拠を加えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s an implementation of a class that adopts and conforms to the RandomNumberGenerator protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>RandomNumberGeneratorプロトコルを採用して準拠するクラスの実施が、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s another example, for a function with no parameters or return value:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>もう１つの例がここにあります、パラメータおよび戻り値のないある関数です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s how DiceGameTracker looks in action:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>動作中のDiceGameTrackerがどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s how stackOfStrings looks after pushing these four values on to the stack:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの４つの値をそのスタックにプッシュした後でstackOfStringsがどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s how bit shifting looks in Swift code:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ビットシフトがスウィフトコードにおいてどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s how phase 1 looks for an initialization call for a hypothetical subclass and superclass:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>第１段階がある仮定のサブクラスとスーパークラスのための初期化呼び出しを捜す方法がここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s how phase 2 looks for the same initialization call:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>第２段階が同じ初期化呼び出しを捜す方法は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s how the Dice class can be used to create a six-sided dice with a LinearCongruentialGenerator instance as its random number generator:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Diceクラスが、６面のさいころをつくるためにその乱数生成器としてLinearCongruentialGeneratorインスタンスをつかってどのように使われることができるかが、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s how the allItemsMatch(_:_:) function looks in action:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>動作中のallItemsMatch(_:_:)関数がどのように見えるかが、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s how the isTop(_:) method looks in action:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>動作中のisTop(_:)メソッドがどのように見えるかが、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s how the bits inside an Int8 look for the number -4:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Int8内のビットが数-4に対してどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s how the bits inside an Int8 look for the number 4:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Int8内のビットが数4に対してどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s how the cycle looks:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>循環がどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s how the first lines compare:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初の行がどのくらい似ているかが、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s how the method looks:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>どのようにそのメソッドが見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s how the references look now that you’ve linked the two instances together:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが２つのインスタンスを結びつけた今、参照がどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s how the references look with the capture list in place:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>捕獲リストで適切にされた参照がどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s how the references look, now that you’ve linked the two instances:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが２つのインスタンスを結んだ今、これらの参照がどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s how the remainder operator works.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここに剰余演算子が機能する方法があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s how the stack looks after popping its top value:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スタックがその一番上の値をポップした後にどう見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s how the strong references look after creating and assigning these two instances.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらの２つのインスタンスの作成と代入の後に強い参照がどのように見えるかが、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s how the strong references look after you link the two instances together:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが２つのインスタンスを結びつけた後に強い参照がどのように見えるかが、ここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s how the strong references look after you set the john and unit4A variables to nil:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがjohnとunit4A変数をnilに設定したあと、強い参照がどのように見えるかは、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s how to write a nongeneric version of a stack, in this case for a stack of Int values:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スタックの非総称体版を書く方法がここにあります、これはInt値のスタックの場合です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s how two-phase initialization plays out, based on the four safety checks above:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２段階初期化が、上の４つの安全点検に基づいて最後までやり終える方法がここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s how you call a type method on a class called SomeClass:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが型メソッドをSomeClassと呼ばれるクラスの上で呼び出す方法がここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s how you can think about the differences between these two approaches:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここに、あなたがこれら２つの取り組みの間の違いについてどのように考えることが可能かがあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s how you can use the map(_:) method with a trailing closure to convert an array of Int values into an array of String values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここに、あなたがInt値の配列をString値の配列に変えるために後付クロージャとともにmap(_:)メソッドをどのように使用できるかがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s how you might expect a generic version of findIndex(ofString:in:), called findIndex(of:in:), to be written.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが予想するfindIndex(ofString:in:)の総称体版、findIndex(of:in:)と呼ばれるものが書かれる方法はここにあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s how you use the HTMLElement class to create and print a new instance:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが新しいインスタンスを作成して出力するためにHTMLElementクラスを使用する方法は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s how you write that:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがそれをどう書くかここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s how you write the HTMLElement class to avoid the cycle:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここに、あなたがHTMLElementクラスを循環を避けるように書く方法があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s the Snakes and Ladders example again, written as a repeat-while loop rather than a while loop.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここに再び「ヘビとはしご」の例があります、それはrepeat-whileループとして書かれます、whileループではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s the general form of a repeat-while loop:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>repeat-whileループの一般的な形式は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s the general form of a while loop:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>whileループの一般的な形式は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s the initial array to be sorted:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>分類される最初の配列は、ここにあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here’s what iterating over an asynchronous sequence looks like:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここに、ある非同期シーケンスのすべてにわたって反復することがどのように見えるかがあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Hexadecimal floating-point literals consist of a 0x prefix, followed by an optional hexadecimal fraction, followed by a hexadecimal exponent.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>16進の浮動小数点リテラルは、0x接頭辞、続けて任意の16進の小数部、それに続く16進の指数から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Hiding type information is useful at boundaries between a module and code that calls into the module, because the underlying type of the return value can remain private.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型情報を隠すことは、あるモジュールとモジュールへと呼び出しをするコードとの間の境界で役立ちます、なぜなら戻り値のその基礎をなす型は、プライベートのままであることが可能だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Higher-precedence operators are evaluated before lower-precedence ones.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>より高い優先順位の演算子は、より低い優先順位のもの前に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Horizontal tab (\t)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>水平タブ（\t）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>How ARC Works</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ARCは、どのように働きますか</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>How Deinitialization Works</seg>
      </tuv>
      <tuv lang="ja">
        <seg>デイニシャライズはどのように働くか</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>How to Read the Grammar</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この文法を読む方法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, 24 is larger than TwelveOrLess allows, so trying to store 24 end up setting rectangle.height to 12 instead, the largest allowed value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、24はTwelveOrLessが許可するより大きいので、24を格納する試みは、rectangle.heightを代わりに12、最も大きな許可される値へと設定することに結局なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, (a: 10, b: (a: 1, x: 2)) is valid—although a appears twice, it appears once in the outer tuple and once in the inner tuple.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、(a: 10, b: (a: 1, x: 2))は有効です — もっともaが二度現れますが、それは一度だけ外側タプルに、そして一度だけ内側タプルに現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, Swift structures and classes are much closer in functionality than in other languages, and much of this chapter describes functionality that applies to instances of either a class or a structure type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、スウィフトの構造体とクラスは他の言語においてよりも機能性において非常に近いものです、したがってこの章の多くはクラスまたは構造体型の両方のインスタンスに適用される機能性を記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, a method marked with the objc attribute can override a method marked with the nonobjc attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、objc属性で印されるメソッドはnonobjc属性で印されるメソッドをオーバーライドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, a unit test target can access any internal entity, if you mark the import declaration for a product module with the @testable attribute and compile that product module with testing enabled.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、あなたが製品モジュールのためのインポート宣言を@testable属性で印して、その製品モジュールをテスト可能な状態にコンパイルするならば、ユニットテストターゲットはあらゆる内部実在にアクセス可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, a value of a protocol type doesn’t conform to that protocol; the value returned by protoFlip(_:) doesn’t conform to Shape.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、あるプロトコル型からなるある値は、そのプロトコルに準拠しません；protoFlip(_:)によって返される値は、Shapeに準拠しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, adding concurrency to slow or buggy code isn’t a guarantee that it will become fast or correct.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、並行性を低速またはバグのあるコードに加えることは、それが高速または正しくなることを保証しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, adding parentheses around a type doesn’t have any effect.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>けれども、ある型の周りに丸括弧を加えることは全く影響はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, an actor that is marked with the @objc attribute implicitly conforms to the NSObjectProtocol protocol and is exposed to the Objective-C runtime as a subtype of NSObject.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、@objc属性で印されるアクターは、暗黙的にNSObjectProtocolプロトコルに準拠します、そしてObjective-C runtimeへとNSObjectの下位型として暴露されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, an escaping closure can’t capture a mutable reference to self when self is an instance of a structure or an enumeration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、脱出クロージャはselfに対する可変参照をキャプチャすることが、selfが構造体または列挙のインスタンスである場合はできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, at the point that they’re stored in the objectWithArea constant, they’re only known to be of type HasArea, and so only their area property can be accessed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、それらが定数のobjectWithAreaに格納される時点で、それらは型HasAreaであるということを知られているだけです、なので、それらのareaプロパティだけがアクセスされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, avoid using keywords as names unless you have absolutely no choice.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、あなたに選択が全くない場合を除き、キーワードをなんらかの名前として使用することを避けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, because asHTML is a closure property rather than an instance method, you can replace the default value of the asHTML property with a custom closure, if you want to change the HTML rendering for a particular HTML element.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、asHTMLはインスタンスメソッドではなくクロージャプロパティであるので、あなたが特定のHTML要素に対してHTML解釈を変更したいならば、あなたはあつらえのクロージャでasHTMLプロパティの省略時の値を置き替えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, because it’s called with a string constant, you can see that the initializer won’t fail, so no runtime error can occur in this case.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、それは文字列定数で呼び出されるので、あなたはこのイニシャライザが失敗することはないと分かります、それで実行時エラーはこの場合には起こりえません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, because of Swift’s type inference, you don’t have to write the type of the set’s elements if you’re initializing it with an array literal that contains values of just one type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、スウィフトのもつ型推論のために、あなたは集合の持つ要素それらの型を書くことは、あなたがそれをただ１つの型だけの値それらを含む配列リテラルを使って初期化しているならば、必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, because some courses don’t have a recommended follow-on course, the nextCourse property is an optional.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、いくつかの課程は推奨される後続の課程を持たないことから、nextCourseプロパティはオプショナルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, because the closure refers to self within its body (as a way to reference self.name and self.text), the closure captures self, which means that it holds a strong reference back to the HTMLElement instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、クロージャがその本文内でselfに言及する（self.nameとself.textを参照する方法として）ので、クロージャはselfを捕獲します、それは、今度は逆にそれがHTMLElementインスタンスへの強い参照を保持することを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, because they’re separate instances, setting the width of cinema to 2048 doesn’t affect the width stored in hd, as shown in the figure below:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、それらが別々のインスタンスであるので、cinemaの幅を2048に設定することはhdに格納される幅に影響を及ぼしません、下の図で示されるように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, before you learn how to break a strong reference cycle with a closure capture list, it’s useful to understand how such a cycle can be caused.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、あなたがクロージャ捕獲リストで強い参照循環を壊す方法を学ぶ前に、そのような循環がどのように引き起こされることがありえるか理解することは役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, before you learn how to resolve a strong reference cycle, it’s useful to understand how such a cycle is caused.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、あなたが強い参照循環を解消する方法を学ぶ前に、そのような循環がどのように引き起こされるか理解することは役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, code outside the module might still be able to interact with the declaration’s symbol by using runtime behavior.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、モジュール外部のコードは、依然として宣言のシンボルと実行時挙動を使うことによって相互作用可能かもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, constant type properties of a class are an exception: static has its normal, nonclass meaning there because you can’t write class or final on those declarations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、クラスの定数型プロパティは例外です：staticはそれの通常の、非クラスの意味をそこで持ちません、なぜならあなたはclassまたはfinalをそれらの宣言上で書けないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, for the inline closure expression, the parameters and return type are written inside the curly braces, not outside of them.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、行内クロージャ式のために、パラメータと戻り型は、波括弧の内側に書かれます、その外側ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, functions and methods with no return type have an implicit return type of Void, as described in Functions Without Return Values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、戻り値のない関数で記述されるように、戻り型のない関数やメソッドは、Voidの暗黙の戻り型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, if ARC were to deallocate an instance that was still in use, it would no longer be possible to access that instance’s properties, or call that instance’s methods.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、ARCがまだ使用中だったインスタンスの割り当て解除をすることになったならば、そのインスタンスのプロパティにアクセスすることや、そのインスタンスのメソッドを呼ぶことは、もはや可能でないでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, if multiple matches are possible, the first matching case is always used.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、複数の適合が出来るならば、最初の適合するケース節が常に使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, if you apply both a prefix and a postfix operator to the same operand, the postfix operator is applied first.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、あなたが接頭辞演算子と接尾辞演算子の両方を同じ演算数を適用したならば、接尾辞演算子が最初に適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, if you iterate over the contents of this array, the items you receive back are typed as MediaItem, and not as Movie or Song.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、あなたがこの配列の内容上に繰り返すならば、あなたがそこから取り出す項目は、MediaItem型としてであって、MovieまたはSongではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, if you need to modify the properties of your structure or enumeration within a particular method, you can opt in to mutating behavior for that method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、あなたがある特定のメソッド内であなたの構造体または列挙のプロパティを修正する必要があるならば、あなたはそのメソッドのために可変挙動を選ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, if you pass oscar as the argument to shareHealth(with:), there’s a conflict:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、あなたがoscarを引数としてshareHealth(with:)に渡すならば、衝突が存在します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, if you write whitespace at the beginning of a line in addition to what’s before the closing quotation marks, that whitespace is included.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、あなたが終了引用符の前のものに加えて空白文字をある行の始まりで書くならば、その空白文字は含められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, in a few cases ARC requires more information about the relationships between parts of your code in order to manage memory for you.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、２、３の場合には、ARCは、あなたのためにメモリを管理するために、あなたのコードの部分間の関係に関するより多くの情報を要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, initializers don’t have an identifying function name before their parentheses in the way that functions and methods do.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、イニシャライザは、関数とメソッドがするように識別する関数名をその括弧の前に持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, instances of enumeration types have value semantics, which means they have a fixed layout in memory.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、列挙型のインスタンスは値意味論を持ちます、それは、それらがメモリにおいてある固定された配置を持つことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, its behavior in Swift for negative numbers means that, strictly speaking, it’s a remainder rather than a modulo operation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、スウィフトでの負数に対するそれの挙動は、それが、厳密に言って、剰余（remainder）であり、モジュロ（modulo）演算でないのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, it’s important to understand where potential conflicts can occur, so you can avoid writing code that has conflicting access to memory.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、潜在的に衝突が起こり得るところを理解するのは重要です、そうすることであなたはメモリへのアクセスが衝突するコードを書くのを防止できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, it’s more convenient (and clearer in intent) for the init(center:size:) initializer to take advantage of an existing initializer that already provides exactly that functionality.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、すでに正確にその機能性を提供する既存のイニシャライザを利用するほうが、init(center:size:)イニシャライザにとってより便利です（そして意図においてより明白です）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, it’s not appropriate for an animal to have an empty string as the value of its species property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、ある動物にとってそれのspecies（種族）プロパティの値として空の文字列を持つことはふさわしくありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, it’s possible to write code in which an instance of a class never gets to a point where it has zero strong references.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、あるクラスのあるインスタンスが、強い参照を１つも持たない状態になることが決してないコードを書くことは、可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, it’s sometimes useful to be able to store values of other types alongside these case values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、他の型の値をこれらのケース節値の傍らに格納することができることは、時々役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, it’s sometimes useful to enforce certain type constraints on the types that can be used with generic functions and generic types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、総称体関数と総称体型で使われることができる型に、特定の型制約を強制することは、時々役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, it’s sometimes useful to write shorter versions of function-like constructs without a full declaration and name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、まるまる完全な宣言や名前なしに、関数のような構造物のより短いものをいろいろと書くことは、時々役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, like all type aliases, Void is always a type—you can’t use it to write an empty tuple expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、すべての型エイリアスのように、Voidは常にある型です—あなたはそれを使って空のタプル式を書くことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, loops and conditional statements can both use the break statement to end their execution prematurely.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、ループと条件文は、両方ともしかるべき時よりも早くそれらの実行を終えるためにbreak文を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, multiple levels of optional chaining don’t add more levels of optionality to the returned value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、オプショナル連鎖の複数の階層は、返された値にさらにオプショナルの階層を加えません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, not every string can be converted into an integer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、すべての文字列が、整数に変えられることができるというわけでありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, optionals are an exception to the rule that value types can’t be marked with unowned.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、オプショナルそれらは、値型はunownedで印されることが出来ないという規則に対するひとつの例外です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, properties can also be associated with the type itself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、プロパティはまた、型それ自体に結び付けられることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, rather than two class instances, this time it’s a class instance and a closure that are keeping each other alive.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし２つのクラスインスタンスではなく、今度は、それはお互いを生かし続けているクラスインスタンスとクロージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, remainder and multiplication have the same precedence as each other.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、剰余と乗算は、互いに同じ優先順位を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, semicolons are required if you want to write multiple separate statements on a single line:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それにもかかわらず、セミコロンは必要とされます、もしあなたが１つの行に複数の別々の文を書きたい場合には：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, superclass initializers are automatically inherited if certain conditions are met.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、スーパークラスのイニシャライザは、決まった条件が満たされるならば、自動的に継承されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, that argument is now an inline closure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、この引数は今では１つの行内クロージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, that property declaration can’t be implemented as a constant property or a read-only computed property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、そのプロパティ宣言は、定数プロパティまたは読み出し専用の計算プロパティとして実装されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, the width property of the original hd instance still has the old value of 1920:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、最初のhdインスタンスのwidthプロパティは、まだ1920の古い値を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, the fatalError(_:file:line:) function always halts execution, regardless of optimization settings.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、fatalError(_:file:line:)関数は常に実行を停止します、最適化設定に関係なく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, the &amp;&amp; and || operators still operate on only two values, so this is actually three smaller expressions chained together.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、&amp;&amp;と||演算子は依然として２つの値だけに作用します、なのでこれは実際のところ１つに繋がれた３つのより小さい式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, the access level for the numberOfEdits property is marked with a private(set) modifier to indicate that the property’s getter still has the default access level of internal, but the property is settable only from within code that’s part of the TrackedString structure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、numberOfEditsプロパティのためのアクセス水準は、private(set)修飾子を使って印を付けられて、そのプロパティの持つゲッターが依然として省略時のアクセス水準の内部を持つ、しかしプロパティはTrackedString構造体の部分であるコード内からのみ設定可能であることを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, the actual answer is 17, not 5.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、実際の答えは17です、5ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, the alternative example below is valid:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、これに代わる以下の例は有効です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, the conflicting access discussed here can happen on a single thread and doesn’t involve concurrent or multithreaded code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、ここで議論するアクセス衝突は、単一スレッド上で起こることが可能で、並列またはマルチスレッドのコードを伴いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, the cost of that flexibility is that some operations aren’t possible on the returned values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、その柔軟性の対価は、いくつかの演算がその返される値の上で可能でないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, the emergency override password is known, so the overall compound expression still evaluates to true.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、非常用解除パスワードは知られているので、複合式全体はなおtrueと評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, the first line of swapTwoValues(_:_:) is slightly different from swapTwoInts(_:_:).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、swapTwoValues(_:_:)の最初の行は、わずかにswapTwoInts(_:_:)と異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, the function doesn’t perform any safety checks on the array it’s passed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、この関数は、それが渡される配列に関してどんな安全確認も実行しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, the initializer for Country can’t pass self to the City initializer until a new Country instance is fully initialized, as described in Two-Phase Initialization.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、Countryのためのイニシャライザは、selfをCityイニシャライザに渡すことが、新しいCountryインスタンスが完全に初期化されるまでできません、２段階初期化で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, the method is still able to use type casting to query the type of the underlying instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、このメソッドは依然として基盤インスタンスの型についてたずねるために型キャストを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, the projected value is true after trying to store a number that’s too large, like 55.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、その投影値は、55のような大きすぎる数を格納しようとする後はtrueです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, the propagated error must be handled by some surrounding scope.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、伝えられるエラーは周囲のスコープの何れかによって処理される必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, the read access to stepSize overlaps with the write access to number.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、stepSizeに対する読み出しアクセスはnumberに対する書き込みアクセスとオーバーラップします（重なります）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, the same letter can also be represented as a pair of scalars—a standard letter e (LATIN SMALL LETTER E, or U+0065), followed by the COMBINING ACUTE ACCENT scalar (U+0301).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、同じ文字はまた、一対のスカラー ― 通常の文字e（LATIN SMALL LETTER E、またはU+0065）、それに続けてCOMBINING ACUTE ACCENTスカラー（U+0301）として表わされることも出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, the subclass must not be generic, and must not inherit from any generic classes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、サブクラスは総称体である必要はありません、そして何らかの総称体クラスから継承する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, the value of john.residence.address is currently nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、john.residence.addressの値は、現在はnilです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, there are several ways to access memory, called long-term accesses, that span the execution of other code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、メモリにアクセスするための幾つかの方法、長期アクセスと呼ばれる、他のコードの実行の期間にまたがるいくつかのものがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, there’s a third scenario, in which both properties should always have a value, and neither property should ever be nil once initialization is complete.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、第３の筋書きがあります、そこにおいて両方のプロパティは常に値を持たなければなりません、そして一旦初期化が終了しているならば、どちらのプロパティも決してnilであってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, there’s an exception if the compilation condition includes a swift() or compiler() platform condition: The statements are parsed only if the language or compiler version matches what is specified in the platform condition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、例外があります、それはコンパイル条件がswift()またはcompiler()プラットホーム条件を含む場合です：文が構文解析されるのは、言語またはコンパイラのバージョンがプラットホーム条件において指定されるものと合致する場合にのみです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, there’s an important limitation to this approach: The flipped result exposes the exact generic types that were used to create it.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、重大な限界がこの取り組みにはあります：その裏返された結果は、それを作成するのに使われた正確な総称体型を露出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, there’s no harm in using the gameLoop label with the continue statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、gameLoopラベルをcontinue文で使用することに害はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, there’s no need for these operations to wait—each photo can download independently, or even at the same time.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、それら演算が待機する必要はありません — 各写真は独立して、または同時にさえダウンロード可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, they can contain other string literals.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、それは、他の文字列リテラルを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, this approach causes a problem in code that has availability checks:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、この取り組みは有効性検査を持つコードにおいて問題を引き起こします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, this code always triggers a runtime error when residence is nil, as illustrated above.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、residenceがnilのとき、上で説明するように、このコードは常に実行時エラーの引き金となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, this doesn’t mean that you have to specify the type of every constant and variable that you declare.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、これはあなたがすべてのあなたが宣言する定数と変数の型を指定しなければならないことを意味しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, this is a rather long-winded way to write what is essentially a single-expression function (a &gt; b).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、これは本質的に単一式の関数（a &gt; b）であるものを書くには、相当に長たらしい方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, this means that they aren’t exactly the same as in C-based languages.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、これはCに基づく言語とそれらが厳密には同じでないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, type properties are queried and set on the type, not on an instance of that type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、型プロパティは、その型のインスタンスにではなく、その型に問い合わせられ設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, unlike functions, subscripts can’t use in-out parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、関数とは違い、添え字はin-outパラメータを使用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, unlike strings, you use substrings for only a short amount of time while performing actions on a string.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、文字列と違い、ある文字列に関して様々な行為を行う間の短いある程度の時間だけのために、あなたは下位文字列を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, unlike the value in that example, flip(_:) and join(_:_:) wrap the underlying types that the generic shape operations return in an opaque return type, which prevents those types from being visible.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、その例での値と違い、flip(_:)とjoin(_:_:)は基礎をなす型それらをラップします、それらは総称体の形状演算が不透明戻り型において返すものです、それはこれらの型が可視であるのを防ぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, using Swift’s language-level support for concurrency in code that needs to be concurrent means Swift can help you catch problems at compile time.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、並行性に対するスウィフトのもつ言語水準サポートを使うことは、並行である（共同して働く、同時に起こる）ことを必要とするコードにおいて、あなたがコンパイル時に問題を捕まえるのをスウィフトが助け得るのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, using them to enforce valid data and state causes your app to terminate more predictably if an invalid state occurs, and helps make the problem easier to debug.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、それらを使って有効なデータと状態を遵守させることは、あなたのアプリに不正な状態が生じる場合により予測のつく結びとなるようにします、そして問題をより簡単にデバッグする助けとなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, when oneAndTwo is used in a generic context or as an instance of the Loggable protocol, the specialized version isn’t used.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、oneAndTwoがある総称体文脈においてまたはLoggableプロトコルのインスタンスとして使われる場合、この特殊化版は使用されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, when calling functions from other Swift code, avoid using &amp; instead of using the unsafe APIs explicitly.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、他のスウィフトコードからの関数呼び出しの場合、&amp;を明示的なアンセーフAPIの使用の代わりに使うことは避けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, when the tuples’ first elements are the same, their second elements are compared—this is what happens on the second and third line.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、タプルのもつ最初の要素が同じ場合、２番目の要素は比較されます — これが２番目と３番目の行で起こることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, when there isn’t a meaningful relationship between them, it’s traditional to name them using single letters such as T, U, and V, such as T in the swapTwoValues(_:_:) function above.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、意味がある関係がそれらの間に無かった時、T、U、そしてVなどの一文字を使ってそれらに名前をつけるのが伝統的です、例えば上のswapTwoValues(_:_:)関数におけるTのように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, when you are working with your own resources, you might need to perform some additional cleanup yourself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、あなたがあなた独自のリソース（計算資源）を扱うとき、あなたは追加のいくらかの掃除をあなた自身でする必要があるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, when you specifically want an overflow condition to truncate the number of available bits, you can opt in to this behavior rather than triggering an error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、あなたがに利用できるビットの数を切り詰めるために特にオーバフロー条件を望むとき、あなたはエラーを引き起こすのではなくこの挙動を選ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, with ARC, values are deallocated as soon as their last strong reference is removed, making weak references unsuitable for such a purpose.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、ARCでは、値はその最後の強い参照が削除されるやいなや割り当て解除されて、弱い参照をそのような目的のためにふさわしくないものにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, you call type methods on the type, not on an instance of that type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、あなたは型のメソッドを型の上で呼び出します、その型のインスタンスの上ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, you can also define computed variables and define observers for stored variables, in either a global or local scope.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、あなたはまた、計算変数を定義すること、そして格納変数のためにオブザーバーを定義することが、グローバルなまたはローカルなスコープのどちらにおいても可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, you can downcast from a protocol type to an underlying type in the same way you can downcast from a superclass to a subclass, as discussed in Downcasting.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、あなたはあるプロトコル型からある基礎をなす型へとダウンキャストすることが、あなたがスーパークラスからサブクラスへとダウンキャスト出来るのと同じ方法で可能です、ダウンキャストで記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, you can provide explicit argument labels using the same syntax that functions, methods, and initializers use.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、あなたは明示的に引数ラベルを提供することが、関数、メソッド、およびイニシャライザが使うのと同じ構文を使うことで可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, you can still change tenEighty.frameRate and alsoTenEighty.frameRate because the values of the tenEighty and alsoTenEighty constants themselves don’t actually change.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、あなたはそれでもなおtenEighty.frameRateとalsoTenEighty.frameRateを変更することができます、なぜならtenEightyおよびalsoTenEighty定数それら自身の値は実のところ変わらないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, you can use a function that never returns like fatalError("Oh no!") as an implicit return value, because Swift knows that the implicit return doesn’t happen.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、あなたは決して復帰しない関数、たとえばfatalError("Oh no!")を暗黙的戻り値として使用できます、なぜならスウィフトは暗黙的戻り値が生じないことがわかるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, you can use this syntax to iterate any collection, including your own classes and collection types, as long as those types conform to the Sequence [https://developer.apple.com/documentation/swift/sequence] protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、あなたはこの構文を使ってどんなコレクションにも、あなた独自のクラスおよびコレクション型を含めて、繰り返し処理できます、それらの型がSequence [https://developer.apple.com/documentation/swift/sequence]プロトコルに準拠する限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, you can’t construct an instance of a protocol, because protocols don’t actually provide the implementations for the requirements they specify.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、あなたはプロトコルからインスタンスを造ることができません、なぜならプロトコルは実際にはそれらが指定する要件に対する実装を用意しないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, you don’t always have to write the type explicitly.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、あなたは必ずしも明確に型を書く必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Identical to (===)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同一である（===）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Identifier Pattern</seg>
      </tuv>
      <tuv lang="ja">
        <seg>識別子パターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Identifiers</seg>
      </tuv>
      <tuv lang="ja">
        <seg>識別子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Identifiers patterns within a value-binding pattern bind new named variables or constants to their matching values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある値束縛パターン内の複数の識別子パターンは、複数の新しい名前をつけられた変数または定数を、それらがマッチしている値に縛りつけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Identity Operators</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同一性演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If self is an instance of a structure or an enumeration, you can always refer to self implicitly.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>selfがある構造体または列挙のインスタンスであるならば、あなたは常にselfを暗黙的に参照できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If someThrowingFunction() throws an error, the value of x and y is nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>someThrowingFunction()がエラーをスローするならば、xとyの値はnilです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If tenEighty and alsoTenEighty were far apart in your program’s code, it could be difficult to find all the ways that the video mode is changed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>tenEightyとalsoTenEightyがあなたのプログラムのコードの中で離ればなれになってしまったら、ビデオモードが変更される全ての道筋を見つけるのは難しくなるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If true, execution continues to step 2.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>trueならば、実行はステップ２に続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If true, execution returns to step 1.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>trueならば、実行はステップ１に戻ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If false, the program is finished executing the repeat-while statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>falseならば、プログラムはrepeat-while文の実行を終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If false, the program is finished executing the while statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>falseならば、プログラムはwhile文の実行を終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a and b aren’t of the same type, it isn’t possible to swap their values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>aとbが同じ型でないならば、それらの値を交換することは可能ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If count is already zero, the method returns 0 to indicate that no further counting should take place.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>countがすでにゼロであるならば、メソッドは0を返して、これ以上数えることは必要ないことを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If square is valid, the value stored in board[square] is added to the current square value to move the player up or down any ladders or snakes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>squareが有効ならば、board[square]に格納される値は現在のsquareの値に加えられて、はしごや蛇があればプレーヤーを上や下に動かします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If question is true, it evaluates answer1 and returns its value; otherwise, it evaluates answer2 and returns its value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>questionが真実ならば、それはanswer1を評価して、その値を返します；そうでなければ、それはanswer2を評価して、その値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If Statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>if文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If Statements and Forced Unwrapping</seg>
      </tuv>
      <tuv lang="ja">
        <seg>if文と強制アンラップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a String is empty, startIndex and endIndex are equal.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるStringが空ならば、startIndexとendIndexは同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a catch clause contains multiple patterns, all of the patterns must contain the same constant or variable bindings, and each bound variable or constant must have the same type in all of the catch clause’s patterns.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>catch節が複数のパターンを含むならば、パターンの全ては同じ定数または変数バインディングを含まなければなりません、そして各バインドされた変数または定数は、catch節のもつパターンの全てにおいて同じ型を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a catch clause doesn’t have a pattern, the clause matches any error and binds the error to a local constant named error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>catch節がパターンを持たないならば、その節はあらゆるエラーにマッチします、そしてそのエラーをerrorと名前を付けられるローカル定数に束縛します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a catch clause doesn’t specify a pattern, the catch clause matches and binds any error to a local constant named error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>catch節がパターンを指定しないならば、そのcatch節はあらゆるエラーに合致してerrorと名前をつけられるローカル定数へとバインドします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a where clause is present, the statements within the relevant case are executed only if the value of the control expression matches one of the patterns of the case and the expression of the where clause evaluates to true.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>where節が存在するならば、関連するケース節の範囲内のいくらかの文は、制御式の値がケース節のパターンの１つとマッチして、そしてwhere節がtrueに評価される場合にだけ、実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a class has a superclass, list the superclass name before any protocols it adopts, followed by a comma:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるクラスがスーパークラスを持つならば、それが採用するあらゆるプロトコルの前に、コンマに続けてスーパークラス名を列記してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a closure doesn’t specify a parameter list or return type because they can be inferred from context, place the capture list at the very start of the closure, followed by the in keyword:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャがパラメータ・リストまたは戻り型を、それらが前後関係から推論されることができるために指定しないならば、捕獲リストをクロージャのまさしくその始まりに、inキーワードに続けて置いてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a closure expression is provided as the function’s or method’s only argument and you provide that expression as a trailing closure, you don’t need to write a pair of parentheses () after the function or method’s name when you call the function:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるクロージャ式が関数のもつまたはメソッドのもつ唯一の引数として提供され、そしてあなたが後付クロージャとしてその式を提供するならば、あなたがその関数を呼ぶ時に、一対の丸括弧()を関数やメソッドの名前の後に書く必要はありません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a computed property’s setter doesn’t define a name for the new value to be set, a default name of newValue is used.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>計算プロパティのもつセッターがその設定される新しい値に名前を定義しないならば、newValueの省略時の値が使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a conforming type provides its own implementation of a required method or property, that implementation will be used instead of the one provided by the extension.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>準拠している型がある必須のメソッドやプロパティのそれ自身の実装を提供する場合は、その実装が拡張によって提供されるものの代わりに使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a conforming type satisfies the requirements for multiple constrained extensions that provide implementations for the same method or property, Swift uses the implementation corresponding to the most specialized constraints.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある準拠型が同じメソッドやプロパティに対する実装を提供する複数の制約拡張に対する要件を満たすならば、スウィフトは最も特殊化した制約と一致する実装を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a constant or variable in your code needs to work with the absence of a value under certain conditions, always declare it as an optional value of the appropriate type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたのコードの中の定数または変数が特定の条件下で値の欠如を取り扱う必要があるならば、常に、それを適切な型のオプショナルの値として宣言してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a constant, variable, property, or subscript makes use of a private type, the constant, variable, property, or subscript must also be marked as private:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数、変数、プロパティ、または添え字が非公開の型を利用するならば、定数、変数、プロパティ、または添え字はまた、privateと印しされなければなりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a default value is defined, you can omit that parameter when calling the function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>省略時の値が定義されるならば、あなたは関数を呼ぶときそのパラメータを省略することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a function takes multiple closures, you omit the argument label for the first trailing closure and you label the remaining trailing closures.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数が複数のクロージャを取るならば、あなたは最初の後付クロージャに対して引数ラベルを省きます、そしてあなたは残りの後付クロージャにラベルをつけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a function type has only one parameter and that parameter’s type is a tuple type, then the tuple type must be parenthesized when writing the function’s type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある関数型がただ１つだけのパラメータを持ちそしてそのパラメータの型がタプル型であるならば、その場合そのタプル型は関数の型を記述する時に丸括弧に入れられなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a function type includes more than a single arrow (-&gt;), the function types are grouped from right to left.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある関数型がただ１つだけの矢印（-&gt;）ではなくもっと多く含むならば、その関数型は右から左にグループにされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a function with an opaque return type returns from multiple places, all of the possible return values must have the same type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>不透明戻り型をもつ関数が複数の場所から返るならば、可能な戻り値の全ては、同じ型を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a match is found, one of the switch statement’s cases sets an optional Int? variable called possibleIntegerValue to an appropriate integer value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ひとつの適合が見つけられるならば、switch文のケース節の１つは、possibleIntegerValueと呼ばれるあるオプショナルのInt?変数を適切な整数値に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a match is found, the program executes the statements listed within the scope of that case.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>マッチが見つけられるならば、プログラムはそのケース節のスコープ内で列記される文を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a nonfailable initializer delegates to an init! failable initializer that fails and returns nil, then a runtime error is raised (as if you used the ! operator to unwrap an optional that has a nil value).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>失敗できないイニシャライザが、ある失敗してnilを返す失敗できるイニシャライザinit!へと委任するならば、その時は実行時エラーが（まるであなたがnilの値を持つオプショナルをアンラップするために!演算子を使ったかのように）引き起こされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a parameter has an argument label, the argument must be labeled when you call the function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある引数が引数ラベルを持つならば、その引数は、あなたがその関数を呼ぶ時にラベルを付けられる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a particular dice roll would take you beyond square 25, you must roll again until you roll the exact number needed to land on square 25.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある特定のさいころを振る回が、正方形25を越えてあなたを連れて行くならば、あなたは正方形25に到着するのに必要な正確な数を出すまで、再びさいころを振らなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a period appears at the beginning of a line, it’s understood as part of an explicit member expression, not as an implicit member expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ピリオドがある行の初めに現れたならば、それはある明示的なメンバー式の一部として理解されます、ひとつの明示的なメンバー式としてではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a postfix expression that contains an optional-chaining expression is nested inside other postfix expressions, only the outermost expression returns an optional type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル連鎖式を含む接尾辞式が、他の接尾辞式の内部に入れ子にされるならば、最も外部の式だけがオプショナル型を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a property always takes the same initial value, provide a default value rather than setting a value within an initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるプロパティが常に同じ初期値をとるならば、イニシャライザ内で値を設定することよりむしろ省略時の値を提供してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a property declaration includes both the get and set keywords, a conforming type can implement it with a stored variable property or a computed property that’s both readable and writeable (that is, one that implements both a getter and a setter).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるプロパティ宣言がgetとsetキーワードを両方とも含むならば、準拠している型はそれを、格納変数プロパティや計算プロパティを使って実装することができます、それは読み出し可能と書き込み可能の両方であるものです（すなわち、ゲッターとセッターのどちらも実装できるもの）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a property declaration includes only the get keyword, it can be implemented as any kind of property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティ宣言がgetキーワードだけを含むならば、それはどんな種類のプロパティとしてでも実装されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a property marked with the lazy modifier is accessed by multiple threads simultaneously and the property hasn’t yet been initialized, there’s no guarantee that the property will be initialized only once.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>lazy修飾子で印されるプロパティが複数のスレッドによって同時にアクセスされ、そのプロパティがその時まだ初期化されないならば、そのプロパティがただ一度だけ初期化されるとは保障されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a protocol is marked with the objc attribute, the AnyObject requirement is implicitly applied to that protocol; there’s no need to mark the protocol with the AnyObject requirement explicitly.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるプロトコルがobjc属性で印されるならば、AnyObject要件は暗黙的にそのプロトコルに適用されます；AnyObject要件で明示的に印する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a protocol requires a property to be gettable and settable, that property requirement can’t be fulfilled by a constant stored property or a read-only computed property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるプロトコルがプロパティに取得可能かつまた設定可能であることを要求するならば、そのプロパティ要件は、定数格納プロパティまたは読み出し専用の計算プロパティによって満たされることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a stored property’s default value requires some customization or setup, you can use a closure or global function to provide a customized default value for that property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある格納プロパティの省略時の値が、いくらかの特別な注文または準備を必要とするならば、あなたは特注の省略時の値をそのプロパティのために用意するために、クロージャまたはグローバル関数を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a stored value in your code won’t change, always declare it as a constant with the let keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある格納された値をあなたのコードにおいて変化させる予定がないならば、常にletキーワードを使ってそれを定数として宣言してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a subclass initializer performs no customization in phase 2 of the initialization process, and the superclass has a zero-argument designated initializer, you can omit a call to super.init() after assigning values to all of the subclass’s stored properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>サブクラスのイニシャライザが初期化過程の第２段階においてなんら特注の挙動を実行しない、そしてスーパークラスがゼロ個引数の指定イニシャライザを持つならば、あなたはサブクラスの持つ格納プロパティの全てに値を割り当てた後、super.init()の呼び出しを省略できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a subclass overrides a designated initializer from a superclass, and also implements a matching initializer requirement from a protocol, mark the initializer implementation with both the required and override modifiers:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるサブクラスが、スーパークラスからの指定イニシャライザをオーバーライドして、またプロトコルからのイニシャライザ要件にも合致するものを実装するならば、そのイニシャライザ実装をrequiredとoverrideの両方の修飾子を使って印してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a subscript returns a value of optional type—such as the key subscript of Swift’s Dictionary type—place a question mark after the subscript’s closing bracket to chain on its optional return value:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある添え字がオプショナル型の値を返すならば ― 例えばスウィフトのDictionary型のキー添え字 ― 疑問符をその添え字の閉じ括弧の後ろに置いて、そのオプショナルの戻り値の上に連鎖を繋げてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a type already conforms to all of the requirements of a protocol, but hasn’t yet stated that it adopts that protocol, you can make it adopt the protocol with an empty extension:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある型があるプロトコルの要件の全てにすでに準拠するが、それがそのプロトコルを採用するとまだ示していなかったならば、あなたは空の拡張を使ってそれがそのプロトコルを採用するようにできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a type defines one of these methods, instances of the type can be used in function call syntax.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある型がそれらメソッドの１つを定義するならば、その型のインスタンスは関数呼び出し構文において使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a value (known as a raw value) is provided for each enumeration case, the value can be a string, a character, or a value of any integer or floating-point type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>値（rawの値として知られるもの）が列挙のケース節の各々のために提供されている場合には、その値は文字列、文字、またはあらゆる整数または浮動小数点型の値であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If all of the associated values for an enumeration case are extracted as constants, or if all are extracted as variables, you can place a single var or let annotation before the case name, for brevity:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙ケース節の関連値の全てが定数として抽出されるならば、または全てが変数として抽出されるならば、あなたは簡潔にvarまたはlet注釈１つだけをケース節名の前に置くことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If all the elements are equal, then the tuples themselves are equal.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>すべての要素が等しいならば、その時それらのタプル自体が等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If an available attribute only specifies an introduced argument in addition to a platform or language name argument, you can use the following shorthand syntax instead:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>available属性がただ１つのintroduced引数をプラットホームまたは言語名引数に加えて指定するならば、あなたは以下の略記構文が代わりに利用可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If an audio signal comes in with a higher value than 10, it will be capped to this threshold value (as described below).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある音声信号が10より高い値でやってくるならば、それはこの限界値に制限されます（下記のように）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If an empty string is found, an initialization failure is triggered.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>もし空の文字列が見つけられたならば、初期化失敗が引き起こされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If an enumeration has raw values, those values are determined as part of the declaration, which means every instance of a particular enumeration case always has the same raw value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある列挙が生の値を持つならば、それらの値は宣言の一部として決定されます、それはある特定の列挙ケース節のすべてのインスタンスが常に同じ生の値を持つことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If an error actually is thrown, you’ll get a runtime error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>エラーが実際はスローされるならば、あなたは実行時エラーを受け取るでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If an error is thrown and it matches the SandwichError.outOfCleanDishes case, then the washDishes() function will be called.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>エラーがスローされてそれがSandwichError.outOfCleanDishesケース節にマッチするならば、そのときwashDishes()関数が呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If an error is thrown and it matches the SandwichError.missingIngredients case, then the buyGroceries(_:) function is called with the associated [String] value captured by the catch pattern.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>エラーがスローされてそれがSandwichError.missingIngredientsケース節にマッチするならば、そのときbuyGroceries(_:)関数がそのcatchパターンによってキャプチャされた[String]関連値とともに呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If an error is thrown by the code in the do clause, it’s matched against the catch clauses to determine which one of them can handle the error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるエラーがdo節の中にあるコードによってスローされるならば、それはcatch節と照合されて、それらの１つがそのエラーを処理できると決定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If an error is thrown while evaluating the try? expression, the value of the expression is nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>try?式を評価している間にエラーがスローされるならば、式の値はnilになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If an error is thrown, execution immediately transfers to the catch clauses, which decide whether to allow propagation to continue.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>エラーがスローされるならば、実行は直ちにcatch節に移ります、それは伝達を継続させるかどうか結論を下します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If an error is unhandled at the top level, program execution stops with a runtime error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>エラーがトップレベルで取り扱われないならば、プログラム遂行はランタイムエラーで停止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If an expression includes both the await and try operator, the try operator must appear first.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある式がawaitとtry演算子の両方を含むならば、try演算子は最初に現れなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If an expression includes both the try and await operator, the try operator must appear first.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある式がtryとawait演算子の両方を含むならば、try演算子は最初に現れなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If an implicitly unwrapped optional is nil and you try to access its wrapped value, you’ll trigger a runtime error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>暗黙的にアンラップされるオプショナルがnilであり、あなたがそれのラップされた値にアクセスしようとするならば、あなたは実行時エラーを引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If an instance of an optional type contains a value, you can access that value using the postfix operator !, as shown below:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル型のインスタンスが値を含むならば、あなたが接尾辞演算子!を使用してその値にアクセスすることができます、以下に示すように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If an instance of the extended type or of a type that conforms to the extended protocol satisfies the requirements, the instance gains the behavior specified in the declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張された型のまたは拡張されたプロトコルに準拠する型のインスタンスがrequirements 要件を満たすならば、そのインスタンスは宣言において指定される挙動を獲得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If an operator doesn’t begin with a dot, it can’t contain a dot elsewhere.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある演算子がドットで始まらないならば、それはどこか他にドットを含むことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If an operator has no whitespace on the left but is followed immediately by a dot (.), it’s treated as a postfix unary operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある演算子が左側では空白を持たないが直ちに続けて１つのドット（.）を持つならば、それは接尾辞単項演算子と見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If an operator has whitespace around both sides or around neither side, it’s treated as an infix operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある演算子が、空白をそのまわりの両側に持つか、そのまわりのどちら側にも持たないならば、それは接中辞演算子とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If an operator has whitespace on the left side only, it’s treated as a prefix unary operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある演算子が左側だけで空白を持つならば、それは接頭辞単項演算子とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If an operator has whitespace on the right side only, it’s treated as a postfix unary operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある演算子が右側だけで空白を持つならば、それは接尾辞単項演算子とみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If an optional has a value, it’s considered to be “not equal to” nil:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるオプショナルが値を持つならば、それはnilと「同等でない」と判断されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If any of the patterns match, then the case is considered to match.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらのパターンのどれかが合致するならば、そのときそのケース節は合致するとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If any of the three listed errors are thrown, this catch clause handles them by printing a message.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>３つのリストされたエラーのどれかがスローされるならば、このcatch節はそれらをあるメッセージを出力することによって取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If any of the values in the optional bindings are nil or any Boolean condition evaluates to false, the whole if statement’s condition is considered to be false.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>何れかのオプショナル束縛の中の値がnilであるか何かのブール条件の評価がfalseになるならば、if文の条件の全体がfalseであるとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If any statement in the do code block throws an error, program control is transferred to the first catch clause whose pattern matches the error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>doコードブロックの中の何らかの文がエラーをスローするならば、プログラム制御は、それのパターンがエラーと合致する最初のcatch節に移されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If casting to the specified type is guaranteed to fail or is guaranteed to succeed, a compile-time error is raised.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>指定された型へのキャストが失敗すると保証されるまたは成功すると保証される場合には、コンパイル時エラーが引き起こされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If either value is false, the overall expression will also be false.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>どちらかの値がfalseならば、全体的な式もまたfalseになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If it doesn’t, the new value the convenience initializer assigns will be overwritten by its own class’s designated initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それがそうしないならば、便宜イニシャライザが代入する新しい値は、それ自身のクラスの指定イニシャライザによって上書きされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If it doesn’t, the new value the designated initializer assigns will be overwritten by the superclass as part of its own initialization.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それがそうしないならば、指定イニシャライザが代入する新しい値は、スーパークラスによってそれ自身の初期化の一部として上書きされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If it is, a message is printed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>もしそうならば、メッセージが出力されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If it’s not possible to retrieve a value from the increment(forCount:) method—either because dataSource is nil, or because the data source doesn’t implement increment(forCount:)—then the increment() method tries to retrieve a value from the data source’s fixedIncrement property instead.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>値をincrement(forCount:)メソッドから取り出すことが可能でないならば ― dataSourceがnilであるから、またはデータ・ソースがincrement(forCount:)を実装しないからのどちらでも ― その時increment()メソッドはその代わりに値をデータ・ソースのfixedIncrementプロパティから取り出そうとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If it’s not appropriate to provide a case for every possible value, you can define a default case to cover any values that aren’t addressed explicitly.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>すべてのあり得る値に対してひとつのケース節を用意することが妥当でないならば、あなたはdefault（省略時）ケース節を定義することで、明確に言及されないどんな値にも対応できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If multiple defer statements appear in the same scope, the order they appear is the reverse of the order they’re executed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複数のdefer文が同じスコープに現れるならば、それらが現れる順番が、それらが実行される順番の逆です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If no error is thrown, the eatASandwich() function is called.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>エラーがスローされないならば、eatASandwich()関数が呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If no error is thrown, the remaining statements in the do statement are executed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>エラーがスローされることが全く無いならば、do文に残っている文が遂行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If no initializers are declared, and all properties of the actor declaration were given initial values, call the actor’s default initializer, as described in Default Initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>イニシャライザが宣言されない、そしてそのアクター宣言の全てのプロパティが初期値を与えられたならば、アクターの省略時のイニシャライザを呼び出してください、省略時のイニシャライザで記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If no initializers are declared, and all properties of the class declaration were given initial values, call the class’s default initializer, as described in Default Initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>イニシャライザが宣言されない、そしてそのクラス宣言の全てのプロパティが初期値を与えられたならば、クラスの省略時のイニシャライザを呼び出してください、省略時のイニシャライザで記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If no initializers are declared, and all properties of the structure declaration were given initial values, call the structure’s default initializer, as described in Default Initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>イニシャライザが宣言されない、そしてその構造体宣言の全てのプロパティが初期値を与えられたならば、構造体の省略時のイニシャライザを呼び出してください、省略時のイニシャライザで記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If no initializers are declared, call the structure’s memberwise initializer, as described in Memberwise Initializers for Structure Types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>イニシャライザが宣言されないならば、その構造体のメンバー関連イニシャライザを呼び出してください、構造型のためのメンバー関連イニシャライザで記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If no pattern is matched, the error gets caught by the final catch clause and is bound to a local error constant.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>パターンが適合することが全く無いならば、エラーは最後のcatch節によってキャッチされて、あるローカルerror定数に束縛されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If none of the catch clauses handle the error, the error propagates to the surrounding scope.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>どのcatch節もエラーを処理しないならば、エラーは周囲のスコープへと伝えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If none of the clauses match, the error propagates to the surrounding scope.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それら条項のどれも合致しないならば、エラーは周囲のスコープへと伝えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If one of the copies of the collection is modified, the elements are copied just before the modification.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのコレクションのいくつかのコピーのうちの１つが修正されるならば、それら要素はその修正の直前にコピーされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If part of your code requires a String, type safety prevents you from passing it an Int by mistake.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたのコードの一部がStringを要求するならば、型安全はあなたが間違ってそれにIntを渡すことを防ぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If part of your code requires a String, you can’t pass it an Int by mistake.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたのコードの一部がStringを要求するならば、あなたは誤ってそれにIntを渡すことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If such a determination can be made, the error is considered handled.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのような決定が為されるならば、エラーは処理されたと判断されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If that condition isn’t met, the code inside the else branch is executed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その条件が満たされないならば、else分岐の内部のコードが実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the ! or ? predefined operator has no whitespace on the left, it’s treated as a postfix operator, regardless of whether it has whitespace on the right.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あらかじめ定義された演算子!または?が左側に空白を持たないならば、それは接尾辞演算子と見なされます、それが右側に空白を持つかどうかに関係なく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the Int value doesn’t have enough digits for the requested index, the subscript implementation returns 0, as if the number had been padded with zeros to the left:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Int値には要十分な桁が請されたインデックスに対してないならば、この添え字実装は、まるで数が左にゼロを詰められたように0を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the break statement above didn’t use the gameLoop label, it would break out of the switch statement, not the while statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のbreak文がgameLoopラベルを使用しないならば、それは、while文ではなく、switch文から抜け出すでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the guard statement’s condition is met, code execution continues after the guard statement’s closing brace.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>guard文の条件が満たされるならば、コード実行はguard文の閉じ中括弧の後に続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the array argument contains an empty array, the minMax(array:) function, as defined above, will trigger a runtime error when attempting to access array[0].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>array引数が空の配列を含んでいるならば、上で定義されるminMax(array:)関数は、array[0]にアクセスしようとする時に実行時エラーを引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the case for .west is omitted, this code doesn’t compile, because it doesn’t consider the complete list of CompassPoint cases.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>.westのためのcaseが省略されるならば、このコードはコンパイルしません、なぜなら、それがCompassPointのケース節の完全なリストを考慮しないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the if statement’s condition is satisfied, its code block is transformed and passed as the argument; otherwise, buildOptional(_:) is called with nil as its argument.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>if文のもつ条件が満たされるならば、それのコードブロックは変換されてそして引数として渡されます；そうでなければ、buildOptional(_:)が呼び出されます、nilをそれの引数として。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the quantity is invalid, the entire initialization process fails immediately and no further initialization code is executed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>quantityが無効ならば、初期化処理全体が直ちに失敗して、以降の初期化コードは実行されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the delegate property is nil, these delegate calls fail gracefully and without error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>delegateプロパティがnilならば、これらの委任先呼び出しはエラーなしで美しく失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the delegate property is non-nil, the delegate methods are called, and are passed the SnakesAndLadders instance as a parameter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>delegateプロパティがnilでないならば、委任先のさまざまなメソッドが呼ばれます、そしてパラメータとしてSnakesAndLaddersインスタンスを渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the condition evaluates to true, the conditional operator evaluates the first expression and returns its value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>条件がtrueに評価されるならば、条件演算子は最初の式を評価して、その値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the constant name of a constant declaration is a tuple pattern, the name of each item in the tuple is bound to the corresponding value in the initializer expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数宣言の定数名がタプルパターンであるならば、タプルの中の各項目の名前は、イニシャライザ式の中の対応する値に縛りつけられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the expression doesn’t throw an error, the value of the optional-try expression is an optional containing the value of the expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このexpression（式）がエラーをスローしないならば、オプショナルtry式の値はひとつのオプショナルになり、そのexpression（式）の値を含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the type name is a class, structure, or enumeration type, the extension extends that type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>type nameがクラス、構造体、または列挙型ならば、その拡張はその型を拡張します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the expression throws an error, a runtime error is produced.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このexpressionがエラーをスローするならば、実行時エラーが生み出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the type name is a protocol type, the extension extends all types that conform to that protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>type nameがプロトコル型ならば、その拡張はそのプロトコルに準拠するすべての型を拡張します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the expression is a tuple, the value must be a tuple with the same number of elements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>式がタプルであるならば、値は同じ数の要素をもつタプルでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the Boolean condition in the assertion or precondition evaluates to true, code execution continues as usual.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>表明または前提条件におけるブール条件がtrueに評価されるならば、コードは普段通り続けて実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the body of the didSet observer refers to the old value, the getter is called before the observer, to make the old value available.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>didSetオブザーバの本文が古い値を参照するならば、ゲッターはオブザーバの前に呼び出されます、古い値を利用可能にするために。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the captured reference will never become nil, it should always be captured as an unowned reference, rather than a weak reference.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>捕獲された参照が決してnilにならないならば、それは常に、非所有参照として捕らえられなければなりません、弱い参照ではなくて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the case contains multiple patterns that match the control expression, all of the patterns must contain the same constant or variable bindings, and each bound variable or constant must have the same type in all of the case’s patterns.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>制御式にマッチする複数のパターンをケース節が含むならば、そのパターンのすべてが同じ定数または変数束縛を含まなければなりません、そして束縛された変数または定数の各々は、そのケース節の持つパターンのすべてで同じ型を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the cast fails, a runtime error is raised.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>キャストが失敗したならば、実行時エラーが引き起こされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the class doesn’t inherit from another class, the list can begin with a protocol instead.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスが別のクラスから継承しないならば、このリストは代わりにプロトコルで始まることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the class inherits any properties from its superclass, one of the superclass’s designated initializers must be called before any of these properties can be set or modified in the current class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスが何らかのプロパティをそのスーパークラスから受け継ぐならば、これらのプロパティのどれかが現在のクラスにおいて設定または修正されることができる前に、スーパークラスの指定イニシャライザのうちの１つが呼ばれなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the closure is never called, the expression inside the closure is never evaluated, which means the array element is never removed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このクロージャが決して呼び出されないならば、クロージャ内部の式は決して評価されません、それは配列要素が決して取り除かれないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the code already checks the condition, you use the assertionFailure(_:file:line:) [https://developer.apple.com/documentation/swift/1539616-assertionfailure] function to indicate that an assertion has failed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コードがすでに条件を調べるならば、あなたはassertionFailure(_:file:line:) [https://developer.apple.com/documentation/swift/1539616-assertionfailure]関数を使って表明が失敗していることを示してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the compiler can prove that the constant’s value is never read, the constant isn’t required to have a value set at all.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数のもつ値が決して読み出されないことをコンパイラが立証できるならば、定数は値を設定されることを全く要求されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the compiler can’t prove the access is safe, it doesn’t allow the access.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コンパイラがそのアクセスを安全であると立証できないならば、それはアクセスを許可しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the condition evaluates to false, the current state of the program is invalid; code execution ends, and your app is terminated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>条件がfalseに評価されるならば、プログラムの現在の状態は無効です；コード実行は止まり、そしてあなたのアプリは終了させられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the condition is true, a set of statements is repeated until the condition becomes false.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その条件がtrueならば、条件がfalseになるまで、ひとかたまりの文が繰り返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the context already provides type information, you can create an empty dictionary with an empty dictionary literal, which is written as [:] (a colon inside a pair of square brackets):</seg>
      </tuv>
      <tuv lang="ja">
        <seg>前後関係がすでに型の情報を提供するならば、あなたは[:]（一対の角括弧の内側のひとつのコロン）として書かれる空の辞書リテラルを使って、空の辞書を作成することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the conversion is successful, the actualNumber constant becomes available for use within the first branch of the if statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>変換が成功しているならば、定数actualNumberは、if文の最初の分岐の内部での利用に役立てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the dice roll will move the player beyond the final square, the move is invalid and the player needs to roll again.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>さいころの目が最後の正方形を越えてプレーヤーを動かすならば、その移動は無効です、そしてプレーヤーは再びさいころを振る必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the dice roll will move the player onto the final square, the game is over.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>さいころの目が最後の正方形の上へプレーヤーを動かすならば、ゲームは終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the dictionary contains a value for the requested key, the subscript returns an optional value containing the existing value for that key.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その辞書が要請されたキーに対する値を含むならば、添え字はそのキーに対する既存の値を含んでいるオプショナルの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the downcasting succeeds, the properties of movie are then used to print a description for that Movie instance, including the name of its director.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ダウンキャストが成功するならば、movieのプロパティがそれから使用されて、そのMovieインスタンスの、それのdirector（監督）の名前を含む説明を出力することになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the enclosing declaration also has a where clause, the requirements from both clauses are combined.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>囲んでいる宣言がまたwhere節を持つならば、両方の節からの要件は結合されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the entire body of a getter is a single expression, the getter implicitly returns that expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ゲッターの全本文が単一の式ならば、ゲッターは暗黙的にその式を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the entire body of the function is a single expression, the function implicitly returns that expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数の本文全体がある単一の式であるならば、その関数は暗黙的にその式を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the enumeration case you’re trying to match has any associated values, the corresponding enumeration case pattern must specify a tuple pattern that contains one element for each associated value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがマッチしようとしている列挙ケース節が関連値を持つならば、対応する列挙ケース節パターンは、各関連値に対して１つの要素を含んでいるタプルパターンを指定しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the enumeration has associated types, they must all conform to the Comparable protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙が関連型いくつかを持つならば、それらは全てComparableプロトコルに準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the error propagates to the top-level scope without being handled, you’ll get a runtime error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>エラーが取り扱われることなくトップレベルスコープに伝わるならば、あなたは実行時エラーを得るでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the first case doesn’t have a value set, its value is 0.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初のケース節が値を設定されないならば、それの値は0です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the first string (s1) is greater than the second string (s2), the backward(_:_:) function will return true, indicating that s1 should appear before s2 in the sorted array.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初の文字列（s1）が第二の文字列（s2）より大きいならば、backward(_:_:)関数は、ソートされた配列においてs1がs2の前に現れなければならないことを示す、trueを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the function definition includes names for its parameters, the function call must include names before its argument values, separated by a colon (:).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数定義がそれのパラメータそれらの名前を含むならば、関数呼び出しはそれの引数値の前に名前を、コロン（:）で区切って含まなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the function has a return type of Void, the return type can be omitted as follows:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数がVoidの戻り型を持つならば、次のように戻り型は省略されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the function or method returns a value, you write async before the return arrow (-&gt;).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数またはメソッドが値を返すならば、あなたはasyncをその戻り矢印（-&gt;）の前に書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the function specifies a return type, you write the throws keyword before the return arrow (-&gt;).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その関数が戻り型を指定するならば、あなたはthrowsキーワードを戻り矢印（-&gt;）の前に書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the function throws an error, the specific error is discarded and the result is nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数がエラーをスローするならば、その具体的なエラーは廃棄されます、そしてその結果はnilになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the inferred type is an optional, you can also use a member of the non-optional type in an implicit member expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>推論された型がオプショナルならば、あなたはまた非オプショナル型のメンバーを暗黙的メンバー式において使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the initial value doesn’t provide enough information (or if isn’t an initial value), specify the type by writing it after the variable, separated by a colon.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初の値が十分な情報を提供しないならば（または最初の値がないならば）、変数の後にコロンで区切ってそれを書くことによって型を指定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the labels are the same, the closure matches the parameter; otherwise, the parameter is skipped.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ラベルそれらが同じならば、クロージャはパラメータと合致します；そうでなければ、パラメータは飛ばされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the left side of a Logical OR expression is true, the right side isn’t evaluated, because it can’t change the outcome of the overall expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>論理和式の左側がtrueならば、右側は評価されません、なぜならそれが式全体の結論を変えることができないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the loop finishes without finding a mismatch, the two containers match, and the function returns true.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ループが一致しない組合せを見つけることなく終わるならば、２つのコンテナは合致します、そして関数はtrueを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the match succeeds, the type of the matched value is cast to the pattern specified in the right-hand side of the as pattern.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>マッチが成功するならば、マッチされた値の型は、asパターンの右手側で指定されるパターンにキャストされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the module is present, the platform condition returns true; otherwise, it returns false.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのモジュールが存在するならば、プラットホーム条件はtrueを返します；そうでなければ、それはfalseを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the new value of currentLevel (after any capping) is higher than any value previously received by any AudioChannel instance, the property observer stores the new currentLevel value in the maxInputLevelForAllChannels type property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>currentLevelの新しい値が（制限を受けた後に）あらゆるAudioChannelインスタンスで以前に受けた値より高いならば、プロパティオブザーバーは、新しいcurrentLevel値を型プロパティmaxInputLevelForAllChannelsに保管します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the new value of currentLevel is greater than the allowed thresholdLevel, the property observer caps currentLevel to thresholdLevel.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>currentLevelの新しい値が許可されたthresholdLevelより大きいならば、このプロパティオブザーバーはcurrentLevelをthresholdLevelに制限します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the omitted types can’t be inferred, a compile-time error is raised.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>省略された型が推論されることができないならば、コンパイル時エラーが引き起こされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the optional Int does contain a value—that is, if the delegate and method both exist, and the method returned a value—the unwrapped amount is added onto the stored count property, and incrementation is complete.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルのIntが値を含むならば ― すなわち、委任先とメソッドが両方とも存在する、そしてメソッドが値を返すならば ― アンラップされたamountが格納countプロパティへと加えられます、そして増加作業は完了です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the optional contains a value, the property, method, or subscript call succeeds; if the optional is nil, the property, method, or subscript call returns nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのオプショナルが値を含むならば、プロパティ、メソッド、または添え字の呼び出しは成功します；そのオプショナルがnilであるならば、プロパティ、メソッド、または添え字の呼び出しはnilを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the optional value is nil, the conditional is false and the code in braces is skipped.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルの値がnilならば、この条件文はfalseになります、そして波括弧の中のコードはスキップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the optional value is missing, the default value is used instead.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル値が見つからないならば、省略時の値が代わりに使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the parameter is omitted when calling the function, the default value is used instead.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>パラメーターが関数呼び出し時に省略されるならば、省略時の値が代わりに使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the parameter structurally resembles a function type, as defined below, the closure matches the parameter; otherwise, the parameter is skipped.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下で定義されるように、パラメータが構造的に関数型に似ているならば、クロージャはそのパラメータと合致します；そうでなければ、パラメータは飛ばされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the player has moved on or beyond square number 25, the loop’s condition evaluates to false and the game ends.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プレーヤーが25番目の正方形の上にまたは越えて移動したならば、ループの条件はfalseに評価してゲームは終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the protocol only requires a property to be gettable, the requirement can be satisfied by any kind of property, and it’s valid for the property to be also settable if this is useful for your own code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルがプロパティに取得可能であるのを要求するだけならば、その要件はどんなプロパティにでもよって満たされることができます、そして、同時にまた設定可能でもあることは、もしそれがあなた自身のコードに役立つ場合には、そのプロパティにとって有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the raw-value type is specified as Int and you don’t assign a value to the cases explicitly, they’re implicitly assigned the values 0, 1, 2, and so on.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>もし生の値型がIntとして指定され、あなたが明示的に値をそれぞれのケース節に割り当てないならば、それらは暗黙のうちに値0、1、2、等々を割り当てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the raw-value type is specified as String and you don’t assign values to the cases explicitly, each unassigned case is implicitly assigned a string with the same text as the name of that case.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>「生の値」型がStringとして指定されてあなたが明示的に値をそのケース節に割り当てないならば、未割り当てのケース節のそれぞれは暗黙的にそのケース節の名前である同じテキストをもつ文字列を割り当てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the result builder has a buildExpression(_:) method, each expression becomes a call to that method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>リザルトビルダーがあるbuildExpression(_:)メソッドを持つならば、各々の式はそのメソッドへの呼び出しになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the result builder has a buildFinalResult(_:) method, the final result becomes a call to that method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>リザルトビルダーがあるbuildFinalResult(_:)メソッドを持つならば、最終的結果はそのメソッドへの呼び出しになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the right side of the assignment is a tuple with multiple values, its elements can be decomposed into multiple constants or variables at once:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>代入の右側が、複数の値をもつタプルであるならば、その要素は同時に複数の定数または変数に分解されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the scan directions produce different results, the old right-to-left ordering is used and the compiler generates a warning.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>走査方向が異なる結果を生じるならば、古い右から左順が使われます、そしてコンパイラは警告を生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the specified key isn’t contained in the dictionary, the subscript returns nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>指定されたキーがその辞書に含まれないならば、添え字はnilを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the square’s value is greater than 0, it’s the base of a ladder, and is represented by ▲.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>正方形の値が0より大きいならば、それははしごの基部であって、▲によって表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the square’s value is less than 0, it’s the head of a snake, and is represented by ▼.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>正方形の値が0より小さいならば、それはヘビの頭であって、▼によって表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the stack is empty, topItem returns nil; if the stack isn’t empty, topItem returns the final item in the items array.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スタックが空ならば、topItemはnilを返します；スタックが空でないならば、topItemはitems配列の最後の項目を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the subclass overrides all of the superclass’s designated initializers, it inherits the superclass’s convenience initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>サブクラスがスーパークラスの指定イニシャライザのすべてをオーバーライドするならば、それはスーパークラスの便宜イニシャライザそれらを継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the subscript declaration includes both the get and set keywords, a conforming type must implement both a getter and a setter clause.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字宣言がgetとsetキーワードを両方とも含むならば、準拠している型はゲッターとセッター節を両方とも実装しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the subscript declaration includes only the get keyword, a conforming type must implement at least a getter clause and optionally can implement a setter clause.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字宣言がgetキーワードだけを含むならば、準拠している型は、少なくともゲッター節を実装しなければなりません、そして随意にセッター節を実装することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the total number of steps has increased, a message is printed to indicate how many new steps have been taken.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総歩数が増加したならば、どれくらいの新たな歩数がとられたかについて示すためにメッセージが出力されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the trailing closure is the function’s only argument, you can omit the parentheses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>後付クロージャがその関数のもつただ１つの引数であるならば、あなたは丸括弧を省略できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the tuple type to be returned from a function has the potential to have “no value” for the entire tuple, you can use an optional tuple return type to reflect the fact that the entire tuple can be nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある関数から返されるタプル型がタプル全体として「値がない」見込みがあるならば、あなたはタプル全体がnilであることが出来るのを反映するためにオプショナルタプルの戻り型を使うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the two items aren’t equal, then the two containers don’t match, and the function returns false.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２つの項目が等しくないならば、２つのコンテナは合致しません、そして関数はfalseを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the type already implements all of the requirements, you can leave the body of the extension declaration empty.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その型が要件の全てをすでに実装するならば、あなたは拡張宣言の本文を空のままにしておいてかまいません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the type conversion can’t maintain the value, the initializer fails.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型変換が値を維持できないならば、イニシャライザは失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the type defines both a call-as-function method and one of the methods used by the dynamicCallable attribute, the compiler gives preference to the call-as-function method in circumstances where either method could be used.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その型がcall-as-functionメソッドとdynamicCallableによって使われるメソッドの１つを両方とも定義するならば、コンパイラは、どちらのメソッドも使用できる環境ではcall-as-functionメソッドを優先します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the type of the expression’s value is a class, you can mark the expression in a capture list with weak or unowned to capture a weak or unowned reference to the expression’s value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この式の値の型がクラスならば、あなたはその式をキャプチャリストの中でweakまたはunownedを使って印を付けて、式の値に対する弱いまたは非所有の参照をキャプチャすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the type they extend is also in the same file, they share the type’s access-control scope.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらが拡張した型もまた同じファイルにあるならば、それらはその型のもつアクセス制御スコープを共有します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the type you are trying to retrieve is already optional, it will not become more optional because of the chaining.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが取り出そうとしている型がすでにオプショナルならば、それは連鎖であることからさらにオプショナルにはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the type you are trying to retrieve isn’t optional, it will become optional because of the optional chaining.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが取り出そうとしている型がオプショナルでないならば、それはオプショナル連鎖であることからオプショナルになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the value before the ? is nil, everything after the ? is ignored and the value of the whole expression is nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>?の前の値がnilならば、?の後のすべてのものは、無視されて、その全体の式の値はnilです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the value is nil, no operation is performed and therefore no runtime error is produced.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その値がnilならば、演算は実行されません、したがって、実行時エラーは生じません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the value of a is non-nil, the value of b isn’t evaluated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>aの値がnilでないならば、bの値は評価されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the value of a is equal to b, then the resulting range will be empty.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>aの値がbと等しいならば、そのとき結果として生じる範囲は空になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the value of age is negative, as in the code above, then age &gt;= 0 evaluates to false, and the assertion fails, terminating the application.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ageの値が負であるならば、上のコードでのように、そのときage &gt;= 0はfalseに評価され、そして表明は失敗して、アプリケーションを終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the value of integerToDescribe is one of the prime numbers in the list, the function appends text to the end of description, to note that the number is prime.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>integerToDescribeの値がリストにある素数の１つであるならば、数が素数であることを書き留めるために、関数はdescriptionの終わりにテキストを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the value of the expression isn’t nil, the optional value is unwrapped and returned with the corresponding non-optional type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>式の値がnilでないならば、オプショナルの値は包装を取られて（アンラップされて）、対応する非オプショナル型で返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the value of the expression doesn’t match the value of the return type declared in the function or method declaration, the expression’s value is converted to the return type before it’s returned to the calling function or method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>式の値が関数またはメソッド宣言において宣言される戻り型の値にマッチしないならば、それが関数またはメソッドを呼んでいるところに返される前に、式の値は戻り型に変換されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the value of the optional-chaining expression is nil, all of the other operations in the postfix expression are ignored and the entire postfix expression evaluates to nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル連鎖式の値がnilならば、接尾辞式での他の演算の全ては無視されます、そして接尾辞式の全体はnilに評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the value of the optional-chaining expression is nil, the expression on the right-hand side of the assignment operator isn’t evaluated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル連鎖式の値がnilならば、代入演算子の右手側での式は評価されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the value of the optional-chaining expression isn’t nil, the value of the optional-chaining expression is unwrapped and used to evaluate the rest of the postfix expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル連鎖式の値がnilでないならば、オプショナル連鎖式の値はアンラップされて、接尾辞式の残りを評価するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the value returned isn’t nil, it’s assigned to the item pattern, the program executes the statements, and then continues execution at the beginning of the loop.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>返される値がnilでないならば、それはitem（項目）パターンに割り当てられて、プログラムはstatements（文）を実行して、それからループの初めに戻って実行を続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If there are enough system resources available, they can run at the same time.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>十分なシステムリソースが利用可能ならば、それらは同時に動作可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If there are expressions of multiple types, T is their closest common supertype.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複数の型の式があるならば、Tはそれらの最も近い共通のスーパー型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If there are expressions of multiple types, Key and Value are the closest common supertype for their respective values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複数の型の式があるならば、KeyとValueはそれらめいめいの値に対して最も近い共通のスーパー型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If there are multiple in-out parameters, the write accesses start in the same order as the parameters appear.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複数のin-outパラメータが存在するならば、書き込みアクセスはパラメータが現れるのと同じ順番で始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If there aren’t enough coins, Bank returns a smaller number than the number that was requested (and returns zero if no coins are left in the bank).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>十分なコインがないならば、Bankは要請された数より少ない数を返します（そしてコインが胴元に残っていないならばゼロを返します）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If there isn’t suitable type information available, Swift infers that the literal’s type is one of the default literal types defined in the Swift standard library.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>適した型情報が得られなかったならば、スウィフトはそのリテラルの型はスウィフト標準ライブラリで定義される省略時のリテラル型の１つと推論します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If they contain a different number of items, there’s no way that they can match, and the function returns false.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらが異なる数の項目を含むならば、それらが合致することができる術はありません、そして関数はfalseを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If this check isn’t performed, board[square] might try to access a value outside the bounds of the board array, which would trigger a runtime error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この確認が行われなかったならば、board[square]はboard配列の境界外で値にアクセスしようとするかもしれません、それは実行時エラーを引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If this is successful, set a new temporary constant called movie to the value stored in the returned optional Movie.”</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これが成功するならば、movieと呼ばれる新しい一時的な定数を、返されたオプショナルのMovieに格納される値に設定してください。」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If this isn’t the case, Int is preferred, even when the values to be stored are known to be nonnegative.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この場合でないならば、保存される値が負数でないことがわかっている時でさえ、Intがむしろ好まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If type information can be inferred, you can write an empty array as [] and an empty dictionary as [:]—for example, when you set a new value for a variable or pass an argument to a function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型情報が推論されることが出来るならば、あなたは空の配列を[]のように、そして空の辞書を[:]のように書くことができます ― 例えば、あなたが新しい値を変数に設定したり、関数に引数を渡す時に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If we’ve entered the correct door code and passed the retina scan, or if we have a valid door key, or if we know the emergency override password, then allow access.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>私達が正しいドア・コードを入力して網膜走査をパスしたならば、または私達が有効なドア・キーを持つならば、または私達が非常用解除パスワードを知っているならば、その時アクセスを許可してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you access the variable or property after the object has been deallocated, its value is nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが変数またはプロパティにそのオブジェクトがデアロケートされてしまった後にアクセスするならば、それの値はnilです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you add additional cases in the future, the compiler generates a warning to indicate that you need to update the switch statement to take the new cases into account.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが追加のケース節を将来において加えるならば、コンパイラは警告を生成して、あなたがスイッチ文を更新して新しいケース節を考慮に入れる必要があることを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you apply the objc attribute to an enumeration, each enumeration case is exposed to Objective-C code as the concatenation of the enumeration name and the case name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがobjc属性をある列挙に適応したならば、個々の列挙ケース節はObjective-Cコードに列挙名とそのケース節名を連結したものとして暴露されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you are familiar with C, you will know that C enumerations assign related names to a set of integer values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがCに精通しているならば、あなたはCの列挙がひとまとめの整数値それぞれに対して関連した名前を割り当てるということを知っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you are working with particularly long string values, be aware that the count property must iterate over the Unicode scalars in the entire string in order to determine the characters for that string.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが特に長い文字列値を扱う場合は、countプロパティは、その文字列の文字を決定する目的で文字列全体のユニコード・スカラーのすべてに繰り返しを行わなければならないことを知っていてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you ask it to store a larger number, it stores 12 instead.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがそれにより大きな数を格納するように頼むならば、それは代わりに12を格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you assign a closure to a property of a class instance, and the closure captures that instance by referring to the instance or its members, you will create a strong reference cycle between the closure and the instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが、あるクロージャをあるクラスインスタンスのプロパティに代入して、そしてクロージャがそのインスタンスを、インスタンスまたはそのメンバ（属するもの）に言及することによって捕獲するならば、あなたはクロージャとインスタンスの間で強い参照循環をつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you assign a non-nil value to userDefinedColorName and perform the nil-coalescing operator check again, the value wrapped inside userDefinedColorName is used instead of the default:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがnilでない値をuserDefinedColorNameに代入して、nil合体演算子による確認をふたたび実行するならば、userDefinedColorName内にラップされた値は省略時のものの代わりに使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you assign a value to a property within its own didSet observer, the new value that you assign replaces the one that was just set.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが独自のdidSetオブザーバーの内部で値をプロパティに代入するならば、あなたが代入する新しい値はついさっき設定されたものを置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you assign an array, a set, or a dictionary to a constant, that collection is immutable, and its size and contents can’t be changed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがある配列、集合、または辞書をある定数に代入したならば、そのコレクションは不変になります、そしてそれの大きさと内容は変更されることが出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you assign an instance of a reference type to a constant, you can still change that instance’s variable properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが参照型のインスタンスを定数に代入するならば、あなたは依然としてそのインスタンスの変数プロパティを変えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you assign the same Person instance to two more variables, two more strong references to that instance are established:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが同じPersonインスタンスをさらに２つの変数に代入するならば、そのインスタンスへのさらに２つの強い参照が確立されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you break that strong reference, there are no more strong references to the Apartment instance:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがその強い参照を壊すならば、Apartmentインスタンスへの強い参照はもうこれ以上ありません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you break two of these strong references (including the original reference) by assigning nil to two of the variables, a single strong reference remains, and the Person instance isn’t deallocated:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが変数のうちの２つにnilを代入することによってこれらの強い参照のうちの（最初の参照を含む）２つを壊すならば、１つの強い参照が残ります、そしてPersonインスタンスは割り当て解除されません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you call resize(to: .large), the switch case for .large sets the rectangle’s height and width to 100.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがresize(to: .large)を呼び出すならば、.largeに対するスイッチケース節は、矩形のもつ高さと幅を100に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you call this function with a Square, it returns a Square; otherwise, it returns a FlippedShape.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがこの関数をSquareで呼び出すならば、それはSquareを返します；そうでなければ、それはFlippedShapeを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you call this method on an optional value with optional chaining, the method’s return type will be Void?, not Void, because return values are always of an optional type when called through optional chaining.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがこのメソッドをあるオプショナルの値の上でオプショナル連鎖を使って呼ぶならば、メソッドの戻り値はVoid?になります、Voidではなく、なぜならば、オプショナル連鎖を通して呼び出されるとき戻り値は常にオプショナルだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you combine integer and floating-point literals in an expression, a type of Double will be inferred from the context:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがある式の中で整数と浮動小数点リテラルを結合するならば、その前後関係からDoubleの型が推論されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you compile in unchecked mode (-Ounchecked), preconditions aren’t checked.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが未検査モード（-Ounchecked）でコンパイルするならば、前提条件は調べられません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you create a CartItem instance with a nonempty name and a quantity of 1 or more, initialization succeeds:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがCartItemインスタンスを空でない名前と1以上の数量で作成するならば、初期化は成功します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you create a TrackedString instance and modify its string value a few times, you can see the numberOfEdits property value update to match the number of modifications:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがTrackedStringインスタンスをつくって、２、３回その文字列値を修正するならば、あなたはnumberOfEditsプロパティが修正の数に合うように更新されるのを見ることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you create a new Person instance, its residence property is default initialized to nil, by virtue of being optional.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが新しいPersonインスタンスをつくるならば、そのresidenceプロパティは、オプショナルである長所によって、省略時でnilに初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you create a new String value, that String value is copied when it’s passed to a function or method, or when it’s assigned to a constant or variable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが新しいString値をつくるならば、そのString値は、それが関数またはメソッドに渡される時に、またはそれが定数または変数に代入される時に、コピーされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you create a new instance of Train and call its makeNoise() method, you can see that the Train subclass version of the method is called:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがTrainの新しいインスタンスを作成してそれのmakeNoise()メソットを呼び出すならば、あなたはサブクラス板のTrainメソッドが呼び出されるのを見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you create a second incrementer, it will have its own stored reference to a new, separate runningTotal variable:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが第２のインクリメンタをつくるならば、それは、独自に格納された、ある新しい、別個のrunningTotal変数への参照を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you create a second player, whom you try to move to a level that’s not yet unlocked by any player in the game, the attempt to set the player’s current level fails:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが二番目のプレーヤーを作成して、あなたがその人をそのゲームにおいてどのプレーヤーによってもまだ錠を開けられていないレベルへ動かそうとするならば、プレーヤーの現在のレベルを決めるその試みは失敗します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you create an array, a set, or a dictionary, and assign it to a variable, the collection that’s created will be mutable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがある配列、集合、または辞書を作成して、それをある変数に代入したならば、作成されたコレクションは可変となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you create an instance of Bicycle, you can call its inherited description computed property to see how its numberOfWheels property has been updated:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがBicycleのインスタンスを作成するならば、あなたはそれの継承されたdescription計算プロパティを呼び出して、どのようにそれのnumberOfWheelsプロパティが更新されたか見ることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you create an instance of Tandem, you can work with any of its new and inherited properties, and query the read-only description property it inherits from Vehicle:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがTandemのインスタンスを作成するならば、あなたはそれの新規および継承するプロパティを扱うことができて、それがVehicleから継承する読み込み専用のdescriptionプロパティについて問い合わせることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you create an instance of a structure and assign that instance to a constant, you can’t modify the instance’s properties, even if they were declared as variable properties:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが構造体のインスタンスをつくって、そのインスタンスを定数に代入するならば、あなたはそのインスタンスのもつプロパティを、たとえそれらが変数プロパティとして宣言されたとしても、修正することはできません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you create an instance of the Car class and set its gear and currentSpeed properties, you can see that its description property returns the tailored description defined within the Car class:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがCarクラスのインスタンスを作成して、それのgearとcurrentSpeedプロパティを設定するならば、あなたはそれのdescriptionプロパティがCarクラス内で定義される特注の説明を返すのを見ることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you create and assign an actual Residence instance to john.residence, with one or more Room instances in its rooms array, you can use the Residence subscript to access the actual items in the rooms array through optional chaining:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが実際のResidenceインスタンスをつくってjohn.residenceに代入して、そのrooms配列の中に１つ以上のRoomインスタンスをもつならば、あなたはResidence添え字を使って、オプショナル連鎖を通してrooms配列の実際の項目にアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you create your own class or structure to represent a complex data model, for example, then the meaning of “equal to” for that class or structure isn’t something that Swift can guess for you.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが例えば独自のクラスまたは構造体を作成してある複合データモデルを表すならば、そのときそのクラスまたは構造体のための「同等」の意味することはスウィフトがあなたのために推測することができる何かではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you define a new protocol that inherits from an existing protocol, the new protocol can have at most the same access level as the protocol it inherits from.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが既存のプロトコルから継承する新しいプロトコルを定義するならば、新しいプロトコルは最大ではそれが継承するプロトコルと同じアクセス水準を持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you define a protocol instance method requirement that’s intended to mutate instances of any type that adopts the protocol, mark the method with the mutating keyword as part of the protocol’s definition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがそのプロトコルを採用するあらゆる型のインスタンスを変化させることを意図したインスタンスメソッド要件プロトコルを定義するならば、プロトコルの定義の一部としてそのメソッドにmutatingキーワードで印をつけてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you define a public protocol, the protocol’s requirements require a public access level for those requirements when they’re implemented.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがある公開プロトコルを定義するならば、そのプロトコルの持つ要件は、それら要件に対してそれらが実装されるときに公開アクセス水準を必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you define a type’s access level as internal or public (or use the default access level of internal without specifying an access level explicitly), the default access level of the type’s members will be internal.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがある型のアクセス水準を内部または公開として定義する（または明示的にアクセス水準を指定することなく省略時のアクセス水準である内部を使用する）ならば、その型のメンバーの省略時のアクセス水準は内部になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you define a type’s access level as private or file private, the default access level of its members will also be private or file private.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがある型のアクセス水準を非公開またはファイル外非公開として定義するならば、そのメンバーの省略時のアクセス水準も、非公開またはファイル外非公開になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you define an enumeration with a raw-value type, the enumeration automatically receives an initializer that takes a value of the raw value’s type (as a parameter called rawValue) and returns either an enumeration case or nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが列挙を「生の値」型を使って定義したならば、その列挙は生の値の方の値を（rawValueと呼ばれるパラメーターとして）とって、１つの列挙ケース節かnilのどちらかを返すイニシャライザを自動的に受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you define an extension to add new functionality to an existing type, the new functionality will be available on all existing instances of that type, even if they were created before the extension was defined.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが新しい機能性を既存の型に加えるために拡張を定義するならば、新しい機能性はその型の全ての既存の例で利用可能になります、たとえそれらが拡張が定義される前につくられたとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you define an optional variable without providing a default value, the variable is automatically set to nil for you:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが既定値を提供することなくオプショナルの変数を定義するならば、その変数はあなたのために自動的にnilに設定されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you didn’t mark the parameter of this function with @escaping, you would get a compile-time error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがこの関数のパラメータを@escapingで印しないならば、あなたはコンパイル時エラーを得るでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you don’t explicitly write self, Swift assumes that you are referring to a property or method of the current instance whenever you use a known property or method name within a method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが明示的にselfを書かないならば、スウィフトは、あなたがメソッド内で既知のプロパティまたはメソッド名を使用するときはいつでも、あなたが現在のインスタンスに属するプロパティまたはメソッドに言及していると仮定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you don’t need each value from a sequence, you can ignore the values by using an underscore in place of a variable name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがある連続物からの各値を必要としないならば、あなたは変数の名前の代わりにアンダースコアを使うことによってその値を無視することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you don’t need to compute the property but still need to provide code that’s run before and after setting a new value, use willSet and didSet.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが、プロパティを計算する必要がないにもかかわらず新しい値の設定の前や後で実行されるコードを提供する必要があるならば、willSetやdidSetを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you don’t provide a setter name, the default parameter name to the setter is newValue, as described in Shorthand Setter Declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがセッター名を提供しないならば、短縮形セッター宣言で記述されるように、セッターへの省略時のパラメータ名はnewValueです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you don’t provide a setter name, the default parameter name to the setter is value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがセッター名を提供しないならば、セッターへの省略時のパラメータ名はvalueです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you don’t provide an initial value when you declare an optional variable or property, its value automatically defaults to nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルの変数またはプロパティを宣言する時にあなたが最初の値を提供しないならば、その値は自動的に省略時のnilになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you don’t provide setter names, the default parameter name to the willSet observer is newValue and the default parameter name to the didSet observer is oldValue.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがセッター名を提供しないならば、willSetオブザーバーへの初期状態でのパラメータ名はnewValueです、そして、didSetオブザーバーへの初期状態でのパラメータ名はoldValueです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you don’t specify the type of value you need, Swift uses type inference to work out the appropriate type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが必要とする値の型をあなたが指定しないならば、スウィフトは適切な型を導きだすために型推論を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you don’t use this attribute, supply a main.swift file with code at the top level that calls the UIApplicationMain(_:_:_:_:) [https://developer.apple.com/documentation/uikit/1622933-uiapplicationmain] function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがこの属性を使わないならば、UIApplicationMain(_:_:_:_:) [https://developer.apple.com/documentation/uikit/1622933-uiapplicationmain]関数を呼ぶトップレベルでのコードを持つmain.swiftファイルを提供してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you don’t use this attribute, supply a main.swift file with code at the top level that calls the NSApplicationMain(_:_:) function as follows:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがこの属性を使わないならば、NSApplicationMain(_:_:)関数を呼ぶトップレベルコードを持つmain.swiftファイルを以下のように提供してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you don’t want an argument label for a parameter, write an underscore (_) instead of an explicit argument label for that parameter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがあるパラメーターに引数ラベルを使うことを望まないならば、そのパラメーターに対して明示的な引数ラベルの代わりにひとつのアンダースコア（_）を書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you don’t want to modify the inherited property’s value within the overriding getter, you can simply pass through the inherited value by returning super.someProperty from the getter, where someProperty is the name of the property you are overriding.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがオーバーライドのゲッター内で継承されたプロパティの値を修正したくないならば、あなたは、そのゲッターからsuper.somePropertyを返すことによって、単に継承された値を通り抜けさせることができます、ここでsomePropertyはあなたがオーバーライドしているプロパティの名前です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you don’t want to use an argument label for an initializer parameter, write an underscore (_) instead of an explicit argument label for that parameter to override the default behavior.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがイニシャライザ・パラメータのために引数ラベルを使うことを望まないならば、そのパラメータに対して明示的な引数ラベルを書くのではなくひとつのアンダーバー（_）を書いて、省略時の挙動をオーバーライドしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you don’t write the parameter name and parentheses within your implementation, the parameter is made available with a default parameter name of newValue.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがパラメータ名と丸括弧をあなたの実装内で書かないならば、パラメータは省略時のパラメータ名のnewValueを使って利用可能にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you extend a file-private type, any new type members you add have a default access level of file private.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがあるファイル外非公開型を拡張するならば、あなたが加えるどんな新しい型メンバーでも省略時のアクセス水準であるファイル外非公開を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you extend a private type, any new type members you add have a default access level of private.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがある非公開型を拡張するならば、あなたが加えるどんな新しい型メンバーでも省略時のアクセス水準である非公開を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you extend a public or internal type, any new type members you add have a default access level of internal.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがある公開または内部型を拡張するならば、あなたが加えるどんな新しい型メンバーでも省略時のアクセス水準である内部を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you group together aspects of your app’s code as a stand-alone framework—perhaps to encapsulate and reuse that code across multiple applications—then everything you define within that framework will be part of a separate module when it’s imported and used within an app, or when it’s used within another framework.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが、あなたのアプリのコードのさまざまな面をスタンドアローンのフレームワークとして ― おそらくそのコードをカプセル化して複数のアプリケーションに渡って再利用するために ― １つにまとめるならば、あなたがそのフレームワーク内で定義するすべてのものは、それがアプリ内にインポートされて使われるとき、またはそれがもう１つのフレームワーク内で使われるとき、別々のモジュール部分になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you have conflicting access to memory from within a single thread, Swift guarantees that you’ll get an error at either compile time or runtime.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがシングルスレッド内部からのメモリアクセス衝突を起こしているならば、スウィフトはコンパイル時または実行時のどちらかであなたがエラーを得るのを保証します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you have experience with C, C++, or Objective-C, you may know that these languages use pointers to refer to addresses in memory.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがC、C++、またはObjective-Cで経験を持つならば、あなたはこれらの言語がメモリのアドレスに言及するためにポインターを使用するということを知っているかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you have experience with Objective-C, you may know that it provides two ways to store values and references as part of a class instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがObjective-Cでの経験を持つならば、あなたはそれがクラスインスタンスの一部として値や参照を格納するために２つの方法を提供するということを知っているかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you have written code in C or Objective-C, this syntax looks familiar to you—in Swift, this line of code is a complete program.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがCまたはObjective-Cでコードを書いたことがあるならば、この構文はあなたにとって馴染みがあるものでしょう ― スウィフトにおいて、コードのこの行は、ひとつの完全なプログラムです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you implement a willSet observer, it’s passed the new property value as a constant parameter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがwillSetオブザーバーを実装するならば、それは新しいプロパティ値を定数パラメータとして渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you implement both dynamicallyCall methods, dynamicallyCall(withKeywordArguments:) is called when the method call includes keyword arguments.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが両方のdynamicallyCallメソッドを実装するならば、dynamicallyCall(withKeywordArguments:)が呼び出されるのは、メソッド呼び出しがキーワード引数を含む時です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you implement the Togglable protocol for a structure or enumeration, that structure or enumeration can conform to the protocol by providing an implementation of the toggle() method that’s also marked as mutating.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがTogglableプロトコルをある構造体または列挙のために実装するならば、その構造体または列挙は、同様にmutatingとして印されるtoggle()メソッドの実施を提供することによって、このプロトコルに準拠できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you mark a protocol instance method requirement as mutating, you don’t need to write the mutating keyword when writing an implementation of that method for a class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがインスタンスメソッド要件プロトコルにmutatingとして印するならば、あるクラスのためにそのメソッドの実装を書くとき、あなたはmutatingキーワードを書く必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you mark an initializer with the required declaration modifier, you don’t also mark the initializer with the override modifier when you override the required initializer in a subclass.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがイニシャライザをrequired宣言修飾子で印するならば、あなたはさらにそのイニシャライザをoverride宣言修飾子で印することは、あなたがサブクラスの必須イニシャライザをオーバーライドする場合には、しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you name the elements in a tuple, you can use the element names to access the values of those elements:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがタプルの要素に名をつけるならば、あなたはそれらの要素の値にアクセスするために要素名を使用することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you need C-style fallthrough behavior, you can opt in to this behavior on a case-by-case basis with the fallthrough keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがC形式のフォールスルー挙動を必要とするならば、あなたはfallthroughキーワードを使ってそれぞれ個別にこの挙動を選択できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you need a string that spans several lines, use a multiline string literal—a sequence of characters surrounded by three double quotation marks:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがいくつかの行に及ぶ文字列を必要とするならば、複数行文字列リテラル — ３つの二重引用符で囲まれる一連の文字、を使ってください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you need a type to conditionally conform to two protocols that inherit from a single parent, explicitly declare conformance to the parent protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがある型に単一の親から継承する２つのプロトコルに対して条件準拠して欲しいならば、明示的に親プロトコルに対する準拠を宣言してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you need the behavior of the swapTwoValues(_:_:) function in your own code, you can use Swift’s existing swap(_:_:) function rather than providing your own implementation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがあなた自身のコードにおいてswapTwoValues(_:_:)関数の挙動を必要とするならば、あなたはあなた自身の実施を提供するのではなくスウィフトの既存のswap(_:_:)関数を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you need the integer index of each item as well as its value, use the enumerated() method to iterate over the array instead.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがその値のみならず各項目の整数インデックスを必要とするならば、代わりにenumerated()メソッドを配列じゅうを繰り返し処理するのに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you need the special effects of a character in a string literal, match the number of number signs within the string following the escape character (\).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが文字列リテラルの中のある文字の特別な効果を必要とするならば、文字列内のエスケープ文字（\）に続くシャープ記号の数を一致させてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you need to add conditional conformance based on multiple concrete types, create a new protocol that each type can conform to and use that protocol as the requirement when declaring conditional conformance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが複数の具象型に基づく条件準拠を加える必要があるならば、それぞれの型が準拠できる新しいプロトコルを作成してください、そしてそのプロトコルを条件準拠を宣言する時に要件として使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you need to avoid this restriction, mark one of the parameters as escaping, or temporarily convert one of the nonescaping function parameters to an escaping function by using the withoutActuallyEscaping(_:do:) function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがこの規制を回避する必要があるならば、パラメータの１つを脱出すると印してください、または一時的に非脱出関数パラメータの１つを脱出関数へとwithoutActuallyEscaping(_:do:)関数を使うことによって変換してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you need to capture an in-out parameter without mutating it, use a capture list to explicitly capture the parameter immutably.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがin-outパラメータをそれを変化させることなしにキャプチャする必要があるならば、キャプチャリストを使うことで明示的にそのパラメータを不変にキャプチャしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you need to capture and mutate an in-out parameter, use an explicit local copy, such as in multithreaded code that ensures all mutation has finished before the function returns.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがin-outパラメータをキャプチャして変化させる必要があるならば、明示的なローカルコピーを使ってください、例えばすべての変化がその関数が返るまえに完了してしまっていることを保証するマルチスレッド化されたコードにおいてなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you need to convert a value to a different type, explicitly make an instance of the desired type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがある値を異なる型に変換する必要があるならば、明示的に望む型のインスタンスにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you need to expose many declarations, you can group them in an extension that has the objc attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが多くの宣言を露出する必要があるならば、あなたはそれらをobjc属性を持つある拡張にまとめることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you need to give a constant or variable the same name as a reserved Swift keyword, surround the keyword with backticks (`) when using it as a name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが予約済みのスウィフトのキーワードと同じ名前を定数または変数に与える必要があるならば、名前としてそれを使うときバッククォート（`）でそのキーワードを囲んでください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you need to guarantee that the array’s storage is already contiguous, so the implicit conversion never needs to do this work, use ContiguousArray instead of Array.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列のもつストレージが既に隣接する、そのため暗黙的変換はこの仕事をするために絶対に必要ないことをあなたが保証する必要があるならば、ContiguousArrayをArrayの代わりに使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you need to pass a closure expression to a function as the function’s final argument and the closure expression is long, it can be useful to write it as a trailing closure instead.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが関数の最後の引数としてクロージャ式を関数に渡す必要がある、そしてそのクロージャ式が長いならば、代わりに後付クロージャとしてそれを書くことは役に立つことがありえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you need to use a dictionary’s keys or values with an API that takes an Array instance, initialize a new array with the keys or values property:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが、ある辞書のキーまたは値を、Arrayインスタンスを引数にとるAPIで使う必要があるならば、keysまたはvaluesプロパティによってひとつの新しい配列を初期化してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you needed to include switches or for loops to build up part of the drawing, there’s no way to do that.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがスイッチ条件分岐またはforループを含めることで描画の一部を作り上げる必要があるとしても、それをする方法はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you omit the argument, the name used in Objective-C code matches the name in Swift code, and the runtime name follows the normal Swift compiler convention of name mangling.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが引数を省略するならば、Objective-Cコードにおいて使われる名前はSwiftコードにおける名前と合致します、そしてランタイム名は名前修飾の通常のSwiftコンパイラ慣例に従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you omit the parameter names and both types, omit the in keyword before the statements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがパラメータ名と両方の型を省略するならば、文の前のinキーワードを省略します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you omit the precedence group for an operator, Swift uses the default precedence group, DefaultPrecedence, which specifies a precedence just higher than TernaryPrecedence.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが優先順位グループを省略するならば、スウィフトは省略時の優先順位グループ、DefaultPrecedenceを使います、それはTernaryPrecedenceのすぐ上の優先順位を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you omit the version number, omit the colon (:) as well.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがこのバージョン番号を省略したならば、コロン（:）も同様に省いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you omit these parentheses, you are trying to assign the closure itself to the property, and not the return value of the closure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがこの丸括弧を省略するならば、あなたはプロパティにクロージャそれ自体を代入することを試みています、つまりそのクロージャの戻り値でなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you only need some of the tuple’s values, ignore parts of the tuple with an underscore (_) when you decompose the tuple:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがタプルの値の一部を必要とするだけならば、あなたがタプルを分解するとき、アンダースコア（_）で、タプルの一部を無視してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you overwrite the property’s initial value without reading it, this expression is evaluated before the first time you write to the property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがプロパティのもつ初期値をそれを読み出すことなくオーバーライドするならば、この式は、あなたがプロパティに書き込む最初の時の前に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you pass a property that has observers to a function as an in-out parameter, the willSet and didSet observers are always called.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがオブザーバーを持つプロパティをある関数へin-outパラメータとして渡すならば、willSetとdidSetオブザーバーは常に呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you pass an empty string value to the failable initializer’s species parameter, the initializer triggers an initialization failure:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが失敗できるイニシャライザのspeciesパラメータに空の文字列値を渡すならば、イニシャライザは初期化失敗を引き起こします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you provide a new initializer with an extension, you are still responsible for making sure that each instance is fully initialized once the initializer completes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが新しいイニシャライザを拡張によって提供する場合、あなたは依然として、一旦イニシャライザが完了するならば各インスタンスが完全に初期化されることを確かにする責任があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you provide a setter as part of a property override, you must also provide a getter for that override.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがプロパティオーバーライドの一部としてセッターを提供するならば、あなたはまたそのオーバーライドのためにゲッターも提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you provide a setter name, it’s used as the name of the parameter to the setter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがセッター名を提供するならば、それがセッターにパラメータの名前として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you provide an initial value for a constant or variable at the point that it’s defined, Swift can almost always infer the type to be used for that constant or variable, as described in Type Safety and Type Inference.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが最初の値を定数または変数に、それが定義される時点で提供するならば、スウィフトはたいていその定数または変数のために使われる型を推測することが、「型安全と型推論」で記述されるように可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you provide setter names, they’re used as the parameter names to the willSet and didSet observers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがセッター名を提供するならば、それらがwillSetとdidSetオブザーバーへのパラメータ名として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you read strictly from left to right, you might expect the expression to be calculated as follows:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが厳密に左から右に読んだならば、あなたはこの式を以下のように計算されることを期待するでしょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you really do need to use an optional value as an Any value, you can use the as operator to explicitly cast the optional to Any, as shown below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが本当にオプショナル値をAny値として使う必要があるならば、あなたはas演算子を使って明示的にオプショナルをAnyへキャストすることが、以下で示すように行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you set an actual Address instance as the value for john.residence.address, and set an actual value for the address’s street property, you can access the value of the street property through multilevel optional chaining:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが実際のAddressインスタンスをjohn.residence.addressのための値として設定して、そしてアドレスのもつstreetプロパティのために実際の値を設定するならば、あなたは複数階層のオプショナル連鎖を通してstreetプロパティの値にアクセスすることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you set the currentLevel of the left channel to 7, you can see that the maxInputLevelForAllChannels type property is updated to equal 7:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが左のチャンネルのcurrentLevelを7に設定するならば、あなたは型プロパティmaxInputLevelForAllChannelsが7に等しくなるよう更新されるのを見ることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you set the paragraph variable to nil and break its strong reference to the HTMLElement instance, neither the HTMLElement instance nor its closure are deallocated, because of the strong reference cycle:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがparagraph変数をnilに設定して、HTMLElementへのそれの強い参照を壊すならば、HTMLElementインスタンスもそれのクロージャも割り当て解除されません、強い参照循環のためです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you set the strong reference from the paragraph variable to nil, the HTMLElement instance is deallocated, as can be seen from the printing of its deinitializer message in the example below:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが強い参照であるparagraph変数をnilに設定するならば、そのHTMLElementインスタンスは、下の例におけるそれのデイニシャライザのメッセージの出力から分かるように、割り当て解除されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you specify a name by passing an argument, that name is used as the name in Objective-C code and as the runtime name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが名前を引数を渡す事によって指定するならば、その名前はObjective-Cコードにおける名前としてそしてランタイム名として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you specify a type by name, you can access the type’s initializer without using an initializer expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがある型を名前で指定するならば、あなたはその型のイニシャライザにイニシャライザ式を使うことなくアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you specify the Objective-C name for a class, protocol, or enumeration, include a three-letter prefix on the name, as described in Conventions [https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Conventions/Conventions.html#//apple_ref/doc/uid/TP40011210-CH10-SW1] in Programming with Objective-C [https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011210].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがObjective-C名をクラス、プロトコル、または列挙に指定するならば、ある３文字接頭辞をその名前に含めて下さい、Conventions [https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Conventions/Conventions.html#//apple_ref/doc/uid/TP40011210-CH10-SW1]でProgramming with Objective-C [https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011210]において記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you subtract 1 from 00000000 using the overflow subtraction operator (&amp;-), the number will overflow and wrap around to 11111111, or 255 in decimal.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがオーバフロー減算演算子（&amp;-）を使用して00000000から1を減ずるならば、その数はあふれ出てぐるっと送り込まれて11111111、10進での255になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you throw an error in a function, the function returns immediately and the code that called the function handles the error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが関数においてエラーをスローするならば、その関数は直ちに返ります、そして関数を呼んだコードがエラーを取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you tried to do this without a generic where clause, you would have a problem: The implementation of isTop(_:) uses the == operator, but the definition of Stack doesn’t require its items to be equatable, so using the == operator results in a compile-time error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが総称体where節なしにこれをしようとするならば、あなたは問題を抱えることになるでしょう：isTop(_:)の実装は==演算子を使います、しかしStackの定義はそれの項目に同等評価可能であることを要求しません、それで==演算子の使用はコンパイル時エラーという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you try adding one, the next issue you’ll encounter is that the == operator needs to know the types of its left-hand and right-hand arguments.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがそれを加えることを試みるならば、あなたがぶつかる次の問題は、==演算子はそれの左手および右手の引数の型を知る必要があることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you try to access numberOfRooms with the same optional chaining as before, it will now return an Int? that contains the default numberOfRooms value of 1:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが前と同じオプショナル連鎖でnumberOfRoomsにアクセスしようとするならば、それは今では省略時のnumberOfRooms値の1を含むInt?を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you try to access an unsafe unowned reference after the instance that it refers to is deallocated, your program will try to access the memory location where the instance used to be, which is an unsafe operation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが安全でない非所有参照に、それが参照するインスタンスがデアロケートされてしまった後にアクセスすることを試みるならば、あなたのプログラムはそのインスタンスが存在するのに使われたところの位置でメモリにアクセスしようと試みるでしょう、それはメモリ安全ではない操作です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you try to access or modify a value for an index that’s outside of an array’s existing bounds, you will trigger a runtime error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが配列のもつ存在する境界の外にあるインデックスに対する値にアクセスまたは変更しようとするならば、あなたは実行時エラーの引き金を引くことになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you try to access the numberOfRooms property of this person’s residence, by placing an exclamation point after residence to force the unwrapping of its value, you trigger a runtime error, because there’s no residence value to unwrap:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがこの人のresidenceのnumberOfRoomsプロパティに、その値を強制アンラップするためresidenceの後に感嘆符を置くことによって、アクセスしようとするならば、あなたは実行時エラーを引き起こします、なぜなら、アンラップするresidence値はないからです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you try to access the value of an unowned reference after that instance has been deallocated, you’ll get a runtime error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがある非所有参照の値に、そのインスタンスがデアロケートされてしまった後にアクセスしようとするならば、あなたは実行時エラーを得るでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you try to access the variable or property after the object has been deallocated, a runtime error is raised.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが変数またはプロパティにそのオブジェクトがデアロケートされてしまった後にアクセスすることを試みるならば、実行時エラーが引き起こされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you try to access the variable or property after the object has been deallocated, you’ll access the memory at the location where the object used to be, which is a memory-unsafe operation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが変数またはプロパティに、そのオブジェクトがデアロケートされてしまった後にアクセスすることを試みるならば、あなたはそのオブジェクトが存在するのに使われたところの位置でメモリにアクセスするでしょう、それはメモリ安全ではない操作です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you try to access those properties from outside the actor, like you would with an instance of a class, you’ll get a compile-time error; for example:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがそれらプロパティにアクターの外側からアクセスを、あなたがクラスのインスタンスでするように、試みるならば、あなたはコンパイル時エラーを得るでしょう；例えば：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you try to call the isTop(_:) method on a stack whose elements aren’t equatable, you’ll get a compile-time error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがisTop(_:)メソッドを、それの持つ要素が同等評価可能でないスタック上で呼び出そうとするならば、あなたはコンパイル時エラーを得るでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you try to create a CartItem instance with a quantity value of 0, the CartItem initializer causes initialization to fail:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがCartItemインスタンスを0のquantity値で作成することを試みるならば、CartItemイニシャライザが初期化を失敗する原因となります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you try to find a planet with a position of 11, the optional Planet value returned by the raw value initializer will be nil:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが11の位置で惑星を見つけようとするならば、生の値のイニシャライザによって返されるオプショナルのPlanet値は、nilになります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you try to insert a number into an integer constant or variable that can’t hold that value, by default Swift reports an error rather than allowing an invalid value to be created.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがある数をその値を持つことができない整数の定数や変数の中へ入れようとするならば、初期状態では、スウィフトは無効な値がつくられるようにするのではなく、エラーを報告します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you try to retrieve an Int value through optional chaining, an Int? is always returned, no matter how many levels of chaining are used.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがオプショナル連鎖を通してInt値を取り出そうと試すならば、Int?が常に返されます、どんなに多くの連鎖階層が使われようともです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you try to set the currentLevel of the right channel to 11, you can see that the right channel’s currentLevel property is capped to the maximum value of 10, and the maxInputLevelForAllChannels type property is updated to equal 10:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが右のチャンネルのcurrentLevelを11に設定しようとするならば、あなたは右のチャンネルのcurrentLevelプロパティが最大値の10に制限されるのを見ることができます、そして型プロパティmaxInputLevelForAllChannelsは10に等しくなるよう更新されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you try to use an implicitly unwrapped optional that has a value of nil, you’ll get a runtime error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがnilの値を持つ暗黙的にアンラップされるオプショナルを使うことを試みるならば、あなたは実行時エラーを得るでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you use a capture list, you must also use the in keyword, even if you omit the parameter names, parameter types, and return type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがキャプチャリストを使うならば、あなたはまたinキーワードも使わなければなりません、たとえあなたがパラメータ名、パラメータ型、そして戻り型を省略するとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you use a closure to initialize a property, remember that the rest of the instance hasn’t yet been initialized at the point that the closure is executed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがプロパティを初期化するためにクロージャを使うならば、そのクロージャが実行される時点で、残りのインスタンスはまだ初期化されていないのを思い出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you use an extension to add an initializer to a structure that was declared in another module, the new initializer can’t access self until it calls an initializer from the defining module.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが拡張を使ってイニシャライザを別のモジュールの中で宣言された構造体へと加えるならば、その新しいイニシャライザはselfにアクセスすることが、それがあるイニシャライザを定義されているモジュールから呼び出すまでは出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you use an extension to add an initializer to a value type that provides default values for all of its stored properties and doesn’t define any custom initializers, you can call the default initializer and memberwise initializer for that value type from within your extension’s initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが拡張を、その格納プロパティの全てに省略時の値を与えて全くあつらえのイニシャライザを定義しない値型に、イニシャライザを加えるために使うならば、あなたはその値型のための省略時のイニシャライザとメンバー関連イニシャライザを、あなたの拡張のイニシャライザ内から呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you use more than one number sign to form a string delimited by extended delimiters, don’t place whitespace in between the number signs:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが１つ以上のシャープ記号を使って拡張区切り記号によって区切られる文字列を形成するならば、空白をシャープ記号の間に置かないでください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you use multiple available attributes, the effective availability is the combination of the platform and Swift availabilities.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが複数のavailable属性を使うならば、有効な有効性はプラットホームとスウィフト有効性の組み合わせとなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you use these shorthand argument names within your closure expression, you can omit the closure’s argument list from its definition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがこれらの短縮形引数名をあなたのクロージャ式の中で使用するならば、あなたはクロージャの引数リストをその定義から省略することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you want a custom subclass to present one or more of the same initializers as its superclass, you can provide a custom implementation of those initializers within the subclass.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが、あるあつらえのサブクラスにそれのスーパークラスと同じイニシャライザがひとつ以上存在することを望むならば、あなたはそれらのイニシャライザのあつらえの実装をそのサブクラスにおいて提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you want a function to modify a parameter’s value, and you want those changes to persist after the function call has ended, define that parameter as an in-out parameter instead.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがある関数にパラメータの値を修正して欲しいならば、そしてあなたが関数呼び出しが終わった後それらの変化に存続して欲しいならば、代わりにそのパラメータをin-outパラメータとして定義してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you want a nested type within a public type to be publicly available, you must explicitly declare the nested type as public.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが公開型の内側で入れ子にされた型に公開的に利用できて欲しいならば、あなたは明確に入れ子にされた型を公開として宣言しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you want a public type to be initializable with a no-argument initializer when used in another module, you must explicitly provide a public no-argument initializer yourself as part of the type’s definition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがある公開型を別のモジュール内で使うときに引数のないイニシャライザを使って初期化できるようにしたいならば、あなたはある公開の引数のないイニシャライザをあなた自身でその型定義の一部として明示的に提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you want a type member to be public, you must explicitly mark it as such.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがある型メンバーに公開であって欲しいならば、あなたは明確にそれをそのように印しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you want an autoclosure that’s allowed to escape, use both the @autoclosure and @escaping attributes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが脱出を許可される自動クロージャを望むならば、@autoclosureと@escaping属性を両方とも使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you want to assign an explicit access level to a protocol type, do so at the point that you define the protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが明確なアクセス水準をあるプロトコル型に割り当てたいならば、あなたがそのプロトコルを定義する時点でそうしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you want to capture self, write self explicitly when you use it, or include self in the closure’s capture list.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがselfをキャプチャしたいならば、selfを明示的にあなたがそれを使う時に書いてください、またはselfをクロージャのもつキャプチャリストの中に含めてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you want to observe changes to a property’s value, and you are already providing a custom setter for that property, you can simply observe any value changes from within the custom setter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがあるプロパティの値に対する変更を監視したい、そしてあなたが既にあつらえのセッターをそのプロパティのために提供しているならば、あなたは簡単にあつらえのセッター内からどんな値の変化でも監視することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you want to perform further optional chaining on this method’s return value, place the optional chaining question mark after the method’s parentheses:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがこのメソッドの戻り値の上でさらにオプショナル連鎖を実行したいならば、メソッドの丸括弧の後にオプショナル連鎖の疑問符を置いてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you want to remove the final item from an array, use the removeLast() method rather than the remove(at:) method to avoid the need to query the array’s count property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが配列から最後の項目を取り除きたいならば、removeLast()メソッドをremove(at:)メソッドよりむしろ使用して、配列のcountプロパティについてたずねる必要を避けるようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you want to specify an explicit access level for a custom type, do so at the point that you define the type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがあつらえの型のために明示的にアクセス水準を指定したいならば、あなたが型を定義する時点でそうしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you want to swap two String values, or two Double values, you have to write more functions, such as the swapTwoStrings(_:_:) and swapTwoDoubles(_:_:) functions shown below:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが２つのString値、または２つのDoubleの値を交換したいならば、あなたはより多くの関数を書かなければなりません、例えば以下で示されるswapTwoStrings(_:_:)とswapTwoDoubles(_:_:)関数のように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you want to use line breaks to make your source code easier to read, but you don’t want the line breaks to be part of the string’s value, write a backslash (\) at the end of those lines:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが改行を使うことであなたのソースコードを読みやすくしたい、しかしあなたがその改行に文字列の値の一部であることを望まないならば、バックスラッシュを（\）それらの行の終わりに書いてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you want to write this code without using contextual where clauses, you write two extensions, one for each generic where clause.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがこのコードを文脈where節を使うことなく書きたいならば、あなたは２つの拡張を書きます、各where節のために１つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you want your custom value type to be initializable with the default initializer and memberwise initializer, and also with your own custom initializers, write your custom initializers in an extension rather than as part of the value type’s original implementation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが、あなたのあつらえの値型に省略時のイニシャライザとメンバー関連イニシャライザで、その上にあなた自身のあつらえのイニシャライザで初期化可能にされて欲しいならば、あなたのあつらえのイニシャライザを値型の元々の実装の一部としてではなく、ある拡張の中で書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you wanted to manipulate the value of actualNumber within the first branch of the if statement, you could write if var actualNumber instead, and the value contained within the optional would be made available as a variable rather than a constant.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがactualNumberの値をif文の最初の分岐内で取り扱うことを望むならば、あなたはif var actualNumberを代わりに書くことができたでしょう、そしてオプショナル内部に含まれる値は定数ではなく変数として利用可能にされたでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you write inout in front of a parameter’s type, the parameter can be modified inside the scope of the function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがinoutをパラメータの型のすぐ前に書くならば、そのパラメータは関数のスコープ内部において修正されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If your code does contain conflicts, you’ll get a compile-time or runtime error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたのコードが衝突を含むならば、あなたはコンパイル時または実行時エラーを得るでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If your custom type has a stored property that’s logically allowed to have “no value”—perhaps because its value can’t be set during initialization, or because it’s allowed to have “no value” at some later point—declare the property with an optional type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたの特注で作った型が論理的に「無い値」を持つことを許される格納プロパティを ― もしかしたらそれの値が初期化の間に設定されることができないかもしれないため、または後の時点でそれが「無い値」を持つことを許されるため ― 持つならば、そのプロパティをオプショナルの型で宣言してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If your data structure is likely to be more complex, model it as a class or structure, rather than as a tuple.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたのデータ構造体がより複雑になるようならば、それをクラスまたは構造体として形作ってください、タプルとしてよりも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If your result-building methods don’t specify a type for Expression or FinalResult, they default to being the same as Component.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたのリザリトビルドメソッドがExpressionまたはFinalResultに対して型を指定しないならば、それらは初期状態でComponentと同じになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If your subclass doesn’t define any designated initializers, it automatically inherits all of its superclass designated initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたのサブクラスがまったく指定イニシャライザを定義しないならば、それは自動的にそれのスーパークラスの指定イニシャライザの全てを継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If your subclass provides an implementation of all of its superclass designated initializers—either by inheriting them as per rule 1, or by providing a custom implementation as part of its definition—then it automatically inherits all of the superclass convenience initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>もしあなたのサブクラスがそれのスーパークラスの指定イニシャライザの実装の全てを ― 規則１に従ってそれらを継承することによって、またはあつらえの実装をそれの定義の一部として提供することによってのどちらかで ― 提供するならば、その時それは自動的にスーパークラスの便宜イニシャライザの全てを継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If your turn ends at the bottom of a ladder, you move up that ladder.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたの番がはしごの下で終わるならば、あなたはそのはしごを上ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If your turn ends at the head of a snake, you move down that snake.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたの番がヘビの頭のところで終わるならば、あなたはそのヘビを下ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you’re implementing a prefix or postfix operator, you must also mark that method declaration with the corresponding prefix or postfix declaration modifier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが接頭辞または接尾辞演算子を実装しているならば、あなたはまたそのメソッド宣言を対応するprefixまたはpostfix宣言修飾子で印をしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you’re using multiline string literals to build up the lines of a longer string, you want every line in the string to end with a line break, including the last line.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが複数行文字列リテラルを使ってたくさんの行の長い文字列を作り上げようとしているならば、あなたはその文字列のすべての行を、最後の行を含めて改行で終わりたいと思うでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you’ve written concurrent code before, you might be used to working with threads.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが並行性コードを前に書いたことがあるならば、あなたはスレッドを扱うことに慣れているかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you’ve written concurrent or multithreaded code, conflicting access to memory might be a familiar problem.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが並列のまたはマルチスレッドのコードを書いたことがあるならば、メモリアクセスの衝突はおなじみの問題でしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Implement an area() and a simpleDescription() method on the Circle class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>area()およびsimpleDescription()メソッドをCircleクラス上で実装してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Implement both this method and buildEither(first:) to support switch statements and if statements that include an else clause.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このメソッドとbuildEither(first:)を両方とも実装することで、switch文と、if文でelse節を含むものをサポートしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Implement both this method and buildEither(second:) to support switch statements and if statements that include an else clause.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このメソッドとbuildEither(second:)を両方とも実装することで、switch文と、if文でelse節を含むものをサポートしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Implement this method to support for loops.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このメソッドを実装することで、forループをサポートしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Implement this method to support if statements that don’t include an else clause.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このメソッドを実装することで、if文をサポートしてください、それはelse節を含まないものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Implicit Conversion to a Pointer Type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ポインター型への暗黙的変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Implicit Member Expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>暗黙のメンバー式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Implicit Returns from Single-Expression Closures</seg>
      </tuv>
      <tuv lang="ja">
        <seg>単一式のクロージャからの値を暗黙的に返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Implicit member expressions can be followed by a postfix operator or other postfix syntax listed in Postfix Expressions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>暗黙的メンバー式は、接尾辞式において一覧にされる接尾辞演算子または他の接尾辞構文を後に続けることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Implicit returns from single-expression closures</seg>
      </tuv>
      <tuv lang="ja">
        <seg>単一式のクロージャからの値を暗黙的に返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Implicitly Assigned Raw Values</seg>
      </tuv>
      <tuv lang="ja">
        <seg>暗黙的に割り当てられる生の値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Implicitly Unwrapped Optional Type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>暗黙的にアンラップされるオプショナルの型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Implicitly Unwrapped Optionals</seg>
      </tuv>
      <tuv lang="ja">
        <seg>暗黙的にアンラップされるオプショナル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Implicitly unwrapped optionals are useful when an optional’s value is confirmed to exist immediately after the optional is first defined and can definitely be assumed to exist at every point thereafter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>暗黙的にアンラップされるオプショナルは、あるオプショナルの値が存在するのをそのオプショナルが最初に定義された直後に確かめられて、それ以降あらゆる所で存在するのを自信を持って仮定出来るようにされる場合に役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Import Declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>インポート宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Important</seg>
      </tuv>
      <tuv lang="ja">
        <seg>重要</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Improved the discussion of autoclosures in the Autoclosures section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>自動クロージャの説明を自動クロージャ節において改善した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Blackjack, the Ace cards have a value of either one or eleven.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ブラックジャックにおいて、「エース」のカードは、１または11のどちらかの値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In C and Objective-C, you define static constants and variables associated with a type as global static variables.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>CとObjective-Cでは、あなたは静的定数およびグローバルな静的変数として型と結びついた変数を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Objective-C, nil is a pointer to a nonexistent object.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Objective-Cでは、nilは、ある存在しないオブジェクトへのポインターです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Objective-C, classes are the only types that can define methods.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Objective-Cでは、クラスはメソッドを定義することができる唯一の型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Objective-C, you can define type-level methods only for Objective-C classes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Objective-Cでは、あなたはObjective-Cクラスのためにだけ型レベルのメソッドを定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Swift, switch statements don’t fall through the bottom of each case and into the next one.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトでは、switch文は、それぞれのケース節の底を抜け落ちて次のものにいきません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Swift, nil isn’t a pointer—it’s the absence of a value of a certain type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトでは、nilはポインターではありません ― それは、ある特定の型のある値の不在です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Swift, an enumeration to define product barcodes of either type might look like this:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトにおいて、両方の種類の製品バーコードを定義する列挙は、これのように見えるかもしれません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Swift, as in C, the remainder operator (%) and the multiplication operator (*) have a higher precedence than the addition operator (+).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトでは、Cでのように、剰余演算子（%）と乗算演算子（*）は、加算演算子（+）より高い優先順位を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Swift, as in Objective-C, protocol conformance is global—it isn’t possible for a type to conform to a protocol in two different ways within the same program.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトにおいて、Objective-Cにおいてと同様に、プロトコル準拠はグローバルです ― ひとつの型にとって、同じプログラム内でひとつのプロトコルに２つの異なる方法で準拠することは、可能ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Swift, errors are represented by values of types that conform to the Error protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトでは、エラーはErrorプロトコルに準拠する型の値によって表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Swift, every possible value of the control expression’s type must match the value of at least one pattern of a case.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトにおいて、制御式のもつ型のあらゆる可能な値は、少なくともあるケース節の１つのパターンの値にマッチしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Swift, however, type properties are written as part of the type’s definition, within the type’s outer curly braces, and each type property is explicitly scoped to the type it supports.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトでは、しかしながら、型プロパティは、型の定義の一部として、型の外縁の波括弧の内部に書かれます、そして各型プロパティは、明確にそれが支持する型にスコープを定められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Swift, most declarations are also definitions in the sense that they’re implemented or initialized at the same time they’re declared.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトにおいて、大部分の宣言はまた、それらが宣言されるのと同時にそれらが実装または初期化されるという意味で定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Swift, the simplest form of a closure that can capture values is a nested function, written within the body of another function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトにおいて、値をキャプチャできるクロージャの最も単純な形式は、別の関数の本文内に書かれる、入れ子にされた関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Swift, there are four kinds of expressions: prefix expressions, infix expressions, primary expressions, and postfix expressions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトには、４種類の式があります：接頭辞式、接中辞式、基本式、そして接尾辞式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Swift, there are three kinds of statements: simple statements, compiler control statements, and control flow statements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトには、３種類の文があります：単純な文、コンパイラ制御文、そして制御の流れ文。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Swift, there are two basic kinds of patterns: those that successfully match any kind of value, and those that may fail to match a specified value at runtime.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトには、２つの基本的な種類のパターンがあります：あらゆる種類の値に成功裏にマッチするものそれら、そして指定された値にマッチするのを実行時に失敗するものそれら。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Swift, there are two kinds of types: named types and compound types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトには、２つの種類の型：名前付きの型と複合の型があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Swift, there are ways to modify a value that span several lines of code, making it possible to attempt to access a value in the middle of its own modification.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトには、複数コード行にまたがるある値を修正する方法があります、それが可能にするのはある値に対してそれ自身の修正の途中でアクセスを試みることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Swift, this can be done in a single line:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトにおいて、これは１つの行でされることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Swift, this would be written as:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトでは、これはこのように書かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Swift, type information can also flow in the opposite direction—from the root down to the leaves.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトでは、型情報は逆方向にも流れます ― 根から下って葉っぱまで。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Swift, you can choose whether to define a class, structure, or enumeration, and still have the flexibility to define methods on the type you create.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトでは、あなたは、クラス、構造体、または列挙を定義すべきかを選択することができます、そしてまだあなたがつくる型でメソッドを定義する柔軟性を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Swift, you can define type-level methods for all classes, structures, and enumerations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトでは、あなたは全てのクラス、構造体、および列挙のために型レベルのメソッドを定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Swift, you can even extend a protocol to provide implementations of its requirements or add additional functionality that conforming types can take advantage of.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトでは、あなたはプロトコルを拡張してその要件の実装を提供することやそれの準拠型が利用することができる追加の機能性を加えることさえ可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Swift, you can nest loops and conditional statements inside other loops and conditional statements to create complex control flow structures.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトでは、あなたはループおよび条件文を他のループおよび条件文の中に入れ子にして、複雑な制御の流れの構造を作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Swift, you define a structure or class in a single file, and the external interface to that class or structure is automatically made available for other code to use.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトでは、あなたはある構造体またはクラスをある単一のファイルの中で定義します、そして、そのクラスまたは構造体への外部インタフェースは自動的に他のコードが使うことが可能にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Xcode, for example, the print(_:separator:terminator:) function prints its output in Xcode’s “console” pane.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、Xcodeでは、print(_:separator:terminator:)関数はその出力をXcodeの「コンソール」枠に表示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In a for statement, the increment expression is still evaluated after the continue statement is executed, because the increment expression is evaluated after the execution of the loop’s body.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>for文において、増加式はcontinue文が実行されたあと依然として評価されます、なぜなら増加式がループの本文の実行の後に評価されるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In a class declaration, the static keyword has the same effect as marking the declaration with both the class and final declaration modifiers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラス宣言において、staticキーワードは、宣言をclassとfinal宣言修飾子の両方で印することと同じ効果を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In a dictionary literal, the key and value in each key-value pair are separated by a colon.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>辞書リテラルでは、それぞれの「キーと値」の対の中のキーと値は、コロンで区切られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In a few cases, regular font text is used to describe the right-hand side of a grammar production rule.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２、３の場合には、標準活字のテキストが説明のために文法導出規則の右側で使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In a function call expression, if the argument and parameter have a different type, the compiler tries to make their types match by applying one of the implicit conversions in the following list:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数呼び出し式において、引数とパラメータが異なる型を持つならば、コンパイラはそれらの型を合致させようと試みます、以下のリストにおける暗黙的変換のうちの１つを適用することによって：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In a future version of Swift, #file will have the same value as #fileID instead.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>将来のバージョンのスウィフトでは、#fileは代わりに#fileIDと同じ値を持つでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In a multiline string literal, writing a backslash (\) at the end of a line omits that line break from the string.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複数行文字列リテラルにおいて、バックスラッシュ（\）を行の終わりで書くことはそのラインブレークを文字列から省きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In a mutating method of a value type, you can assign a new instance of that value type to self.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>値型の変更メソッドでは、あなたはselfにその値型の新しいインスタンスを代入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In a nested tuple expression, identifiers at the same level of nesting must be unique.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>入れ子にされたタプル式において、同じ水準の入れ子での識別子それらは特有でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In a nonthrowing function, an enclosing do-catch statement must handle the error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非スロー関数では、取り囲んでいるdo-catch文がエラーを処理しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In a protocol declaration or a protocol member declaration, the Self type refers to the eventual type that conforms to the protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル宣言またはプロトコルメンバー宣言において、Self型は、そのプロトコルに準拠する結果として起こる型を参照します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In a structure, class, or enumeration declaration, the Self type refers to the type introduced by the declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体、クラス、または列挙宣言において、Self型は、その宣言によって導入される型を参照します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In a throwing function, either an enclosing do-catch statement or the caller must handle the error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スロー関数では、取り囲んでいるdo-catch文または呼び出し側のどちらかがエラーを処理しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In a type method, self refers to the current type in which it occurs.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型メソッドでは、selfはそれが現れているところの現在の型に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In addition to comparing against specific values, Swift provides several ways for each case to specify more complex matching patterns.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある特定の値に対して比較することに加えて、スウィフトは、それぞれのケース節のために、より複雑な適合パターンを指定するためのいくつかの方法を用意します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In addition to familiar types, Swift introduces advanced types not found in Objective-C, such as tuples.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>よく知られている型に加えて、スウィフトはObjective-Cで見られない先進の型を導入します、例えばタプルのような。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In addition to generic functions, Swift enables you to define your own generic types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体関数に加えて、スウィフトはあなたに独自の総称体型を定義することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In addition to its list of protocols, a protocol composition can also contain one class type, which you can use to specify a required superclass.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>いくつかのプロトコルからなるそれのリストに加えて、あるプロトコル合成はまた１つのクラス型を含むことができます、それはあなたが必要とされるスーパークラスを指定するのに使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In addition to its type property and type methods, LevelTracker tracks an individual player’s progress through the game.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その型プロパティと型メソッドに加えて、LevelTrackerは個々のプレーヤーのゲームを通しての進捗を追います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In addition to matching a pattern with a value, you can extract part or all of a composite value and bind each part to a constant or variable name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>パターンを値とマッチングすることに加えて、あなたはある複合値の部分または全てを抽出して、各部分を定数や変数の名前に結び付ける（束縛する）ことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In addition to offering various levels of access control, Swift reduces the need to specify explicit access control levels by providing default access levels for typical scenarios.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>アクセス制御のいろいろな水準を提供することに加えて、スウィフトは省略時のアクセス水準を典型的なシナリオのために用意することによって明示的にアクセス制御水準を指定する必要を減らします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In addition to properties, you can use instance variables as a backing store for the values stored in a property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティに加えて、あなたはインスタンス変数をプロパティに格納される値に対する支援外部記憶として使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In addition to simple properties that are stored, properties can have a getter and a setter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>格納される単純なプロパティに加えて、プロパティはゲッター（取得メソッド）とセッター（設定メソッド）を持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In addition to specifying major version numbers like iOS 8 or macOS 10.10, you can specify minor versions numbers like iOS 11.2.6 and macOS 10.13.3.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メジャーなバージョン数をiOS 8やmacOS 10.10のように指定することに加えて、あなたはマイナーバージョン数を、iOS 11.2.6そしてmacOS 10.13.3のように指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In addition to specifying requirements that conforming types must implement, you can extend a protocol to implement some of these requirements or to implement additional functionality that conforming types can take advantage of.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>準拠する型が実装しなければならない要件を指定することに加えて、あなたはあるプロトコルを拡張してそれらの要件のいくつかを実装したり、更なる機能性を実装したりできます、それらは、準拠する型それぞれで利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In addition to stored properties, classes, structures, and enumerations can define computed properties, which don’t actually store a value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>格納プロパティに加えて、クラス、構造体、および列挙は計算プロパティを定義することができます、それは、実際に値を格納しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In addition to the characteristics it inherits, the Bicycle class defines a new stored property, hasBasket, with a default value of false (inferring a type of Bool for the property).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それが継承する特徴に加えて、Bicycleクラスは新しい格納プロパティ、hasBasketを、falseの省略時の値を使って定義します（このプロパティに対してはBoolの型が推論されます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In addition to the operators described in Basic Operators, Swift provides several advanced operators that perform more complex value manipulation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>基本の演算子で記述される演算子に加えて、スウィフトはより複雑な値操作を実行するいくつかの先進の演算子を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In addition to the structured approaches to concurrency described in the previous sections, Swift also supports unstructured concurrency.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>前の節で記述される並行性に対する構造化された取り組みに加えて、スウィフトはまた構造化されない並行性をサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In addition to the wrapped value, a property wrapper can expose additional functionality by defining a projected value—for example, a property wrapper that manages access to a database can expose a flushDatabaseConnection() method on its projected value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのラップされた値に加えて、プロパティラッパーは投影値を定義することによっていっそうの機能性を露出できます — 例えば、データベースへのアクセスを管理するプロパティラッパーは、flushDatabaseConnection()メソッドをそれの投影値上で露出できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In addition to these two simple properties, the HTMLElement class defines a lazy property called asHTML.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの２つの単純なプロパティに加えて、HTMLElementクラスは、asHTMLと呼ばれる遅延プロパティを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In addition to user-defined named types, the Swift standard library defines many commonly used named types, including those that represent arrays, dictionaries, and optional values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ユーザー定義の名前付きの型に加えて、スウィフト標準ライブラリは、配列、辞書、そしてオプショナル値を表すものそれらを含む、多くの一般に使われる名前付きの型を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In addition to verifying your expectations at runtime, assertions and preconditions also become a useful form of documentation within the code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたの期待を実行時で実証するのに加えて、表明と前提条件はまたコード内部での有用な文書化形式となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In addition, Swift provides a do statement to introduce scope, and catch and handle errors, and a defer statement for running cleanup actions just before the current scope exits.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>加えて、スウィフトは、do文をスコープを導入し、それでエラーを捕えて処理するために、そしてdefer文を現在のスコープを脱出する直前にさまざまな片付け活動を実行するために提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In addition, execution of concurrent code is never suspended at any other point.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>加えて、並行性コードの遂行は、他のどんな地点でも決して中断されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In addition, for classes that are defined in the same module, you can override any class member (method, property, initializer, or subscript) that’s visible in a certain access context.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それに加えて、同じモジュールにおいて定義されるクラスに対して、あなたは特定のアクセス前後関係において可視であるあらゆるクラスメンバー（メソッド、プロパティ、イニシャライザ、または添え字）をオーバーライドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In addition, identifiers that begin with two underscores are reserved for the Swift compiler and standard library.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>さらに、２つのアンダースコアで始まる識別子は、スウィフトコンバイラおよび標準ライブラリのために予約されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In addition, subscripts can’t have in-out parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>加えて、添え字はin-outパラメータを持つことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In addition, the catch clause must handle only errors thrown by one of the rethrowing function’s throwing parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>加えて、そのcatch節はスロー関数の持つスローパラメータの１つによってスローされるエラーのみを取り扱わなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In addition, you can define property observers to monitor changes in a property’s value, which you can respond to with custom actions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それに加えて、あなたはプロパティオブザーバーを定義して、あるプロパティの値の変化を監視することができて、あなたはあつらえの動作でそれに応答することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In all other cases, dynamicallyCall(withArguments:) is called.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>全ての他の場合には、dynamicallyCall(withArguments:)が呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In all other cases, the dice roll is a valid move.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>他の全ての場合には、さいころの目は有効な移動となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In all other cases, you must use an initializer expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>すべての他の場合では、あなたはイニシャライザ式を使う必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In all three functions, the types of a and b must be the same.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>３つの関数すべてにおいて、aとbの型は同じでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In an if statement, the conditional must be a Boolean expression—this means that code such as if score { ... } is an error, not an implicit comparison to zero.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>if文において、その条件を表すのはブール式でなければなりません ― これはif score { ... }のようなコードがエラーになることを意味します、暗黙的なゼロとの比較はしないためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In an explicit member expression, if there isn’t a corresponding declaration for the named member, the expression is understood as a call to the type’s subscript(dynamicMember:) subscript, passing information about the member as the argument.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>明示的なメンバ式において、名前付きメンバに対して対応する宣言がないならば、式は型の持つsubscript(dynamicMember:)添え字に対する呼び出しとして理解されます、メンバについての情報を引数として渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In an initializer, constant properties can now only assign a value once.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある初期化において、定数プロパティは今ではただ一度しか値を割り当てることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In an initializer, subscript, or instance method, self refers to the current instance of the type in which it occurs.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>イニシャライザ、添え字、またはインスタンスメソッドでは、selfはそれが現れているところの型の現在のインスタンスに言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In both cases, a write access to the tuple element requires a write access to the entire tuple.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>両方の場合において、タプル要素に対する書き込みアクセスは、タプル全体に対する書き込みアクセスを要求とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In both cases, it’s written as (s1: String, s2: String) -&gt; Bool.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>両方の場合において、それは(s1: String, s2: String) -&gt; Boolのように書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In both cases, program control is then transferred to the condition of the enclosing loop statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>両方の場合において、プログラム制御はそれから囲んでいるループ文の条件へ移されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In both cases, program control is then transferred to the first line of code following the enclosing loop or switch statement, if any.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>両方の場合において、プログラム制御はそれから、もしあれば、それを囲んでいるループまたはswitch文に続くコードの最初の行へ移されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In both cases, the constant someArray is declared as an array of strings.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>両方の場合で、定数のsomeArrayは、文字列の配列として宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In both cases, the constant someDictionary is declared as a dictionary with strings as keys and integers as values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>両方の場合で、定数someDictionaryは、キーとして文字列そして値として整数を持つ辞書として宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In both cases, the letter é is represented as a single Swift Character value that represents an extended grapheme cluster.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>両方の場合で、文字éは、単一のスウィフトのCharacter値として表わされます、それはひとつの拡張書記素クラスタを表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In both cases, the value of the whole expression is an optional value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>両方の場合で、その全体の式の値は、オプショナルの値となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In both cases, the variable optionalInteger is declared to have the type of an optional integer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>両方の場合には、変数optionalIntegerは、オプショナル整数の型を持つと宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In both cases, you add conformance to the standard library’s Equatable protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>両方の場合において、あなたは標準ライブラリのもつEquatableプロトコルへの準拠を加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In both cases, you mark the possible suspension point with await to indicate that execution will pause, if needed, until an asynchronous function has returned.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>両方の場合において、あなたは可能な中断地点をawaitで印することでその遂行が一時停止することを指し示します、必要ならば、非同期関数が返ってしまうまで。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In both cases, you must mark the initializer implementation with the required modifier:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>両方の場合で、あなたはそのイニシャライザ実装をrequired修飾子で印しなければなりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In both of the examples above, the type information is passed up from the leaves of the expression tree to its root.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例の両方とも、型情報は、式ツリーの葉っぱから、その根までさかのぼって渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In certain constructs, operators with a leading &lt; or &gt; may be split into two or more tokens.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>特定の構造物において、先導する&lt;または&gt;をもつ演算子は、２つ以上のトークンに分割されるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In code below, optionalString doesn’t have an explicit type so it’s an ordinary optional.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下のコードにおいて、optionalStringは明示的な型を持ちません、それでそれは普通のオプショナルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In contrast to optionals, which can use the presence or absence of a value to communicate success or failure of a function, error handling allows you to determine the underlying cause of failure, and, if necessary, propagate the error to another part of your program.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルと対比して（それは値の有無を使って、ある関数の成否を伝えることができます）、エラー処理はあなたに根本的な失敗の原因を突き止めること、そして、必要ならば、そのエラーをあなたのプログラムの別の部分に伝えることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In contrast to the willSet observer, the old value of the variable or property is passed to the didSet observer in case you still need access to it.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>willSetオブザーバーと対照的に、変数またはプロパティの古い値が、あなたがまだそれへのアクセスを必要とする場合に備えてdidSetオブザーバーに渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In contrast with switch statements in C and Objective-C, switch statements in Swift don’t fall through the bottom of each case and into the next one by default.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>CおよびObjective-Cのswitch文とは対照的に、スウィフトのswitch文は、なにもしなくても、各ケース節の底を突き抜けて次のものに行ったりしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In contrast with generic types, you don’t specify a generic argument clause when you use a generic function or initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体型と対照的に、あなたが総称体の関数やイニシャライザを使うとき、あなたは総称体引数節を指定しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In contrast, newString is a string—when it’s created from the substring, it has its own storage.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>対照的に、newStringは文字列です — それが下位文字列から作成されるとき、それはそれ独自のストレージを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In contrast, both lines of goodStart end with a line break, so when it’s combined with end the result has three lines, as expected.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>対照的に、goodStartの行は両方とも改行で終わります、それでそれがendと結合される場合その結果は３行になります、予想通りに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In contrast, code that’s part of the actor doesn’t write await when accessing the actor’s properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>対照的に、アクターの一部であるコードは、awaitをそのアクターのもつプロパティにアクセスする時に書きません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In contrast, opaque types preserve the identity of the underlying type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>対照的に、不透明型は基礎をなす型の同一性を保全します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In contrast, passing playerOneScore as the value for both parameters produces a conflict because it tries to perform two write accesses to the same location in memory at the same time.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>対照的に、playerOneScoreをそれらパラメータ両方の値として渡すことは衝突を生み出します、なぜならそれは２つの書き込みアクセスをメモリ中の同じ位置に同じ時間に実行しようと試みるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In contrast, the closure passed to someFunctionWithNonescapingClosure(_:) is a nonescaping closure, which means it can refer to self implicitly.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>対照的に、someFunctionWithNonescapingClosure(_:)に渡されるクロージャは、非脱出クロージャです、そのことは、それがselfを暗黙的に参照できるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In contrast, the constants and variables created with a guard statement are available in the lines of code that follow the guard statement, as described in Early Exit.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>対照的に、guard文で作成された定数と変数は、そのguard文以降のコード行において利用可能です、早期退出において議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In contrast, the two function calls marked “OK” don’t cause a compiler error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>対照的に、「OK」と記される２つの関数呼び出しは、コンパイラエラーを引き起こしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In contrast, there’s only one variable named b—the b in the outer scope—so changes from inside or outside the closure are visible in both places.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>対照的に、bと名前を付けられるただ１つだけの変数があります ― 外側のスコープの中のb ― それでクロージャ内部および外部からの変更は、両方の場所で見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In contrast, two tuples of type (String, Bool) can’t be compared with the &lt; operator because the &lt; operator can’t be applied to Bool values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>対照的に、型(String, Bool)の２つのタプルは&lt;演算子で比較できません、なぜなら&lt;演算子はBool値に適用できるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In contrast, use an unowned reference when the other instance has the same lifetime or a longer lifetime.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>対照的に、非所有参照を他のインスタンスが同じ生涯またはより長い生涯を持つ場合に使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In contrast, value types are easier to reason about because all of the code that interacts with the same value is close together in your source files.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>対照的に、値型について思考するのはより簡単です、なぜなら同じ値に相互作用するコードの全ては、あなたのソースファイルの中で近接しているからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In contrast, when creating a selector for a property’s setter, the property name must be a reference to a variable property only.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>対照的に、プロパティのセッターのためのセレクタを作成するとき、property nameは必ず変数プロパティへの参照でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In contrast, without parentheses, (Int, Int) -&gt; Void is the type of a function that takes two Int parameters and doesn’t return any value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>対して、丸括弧なしで、(Int, Int) -&gt; Voidは、２つのIntパラメータを取り、何ら値を返さない関数の型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In dot syntax, you write the property name immediately after the instance name, separated by a period (.), without any spaces:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ドット構文において、あなたはプロパティ名をインスタンス名の直後に、終止符（.）で区切り、どんな空白もなしで、書きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In each case, a new copy of the existing String value is created, and the new copy is passed or assigned, not the original version.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それぞれの場合において、既存のString値の新しいコピーがつくられます、そしてその新しいコピーが渡されるか代入されます、元々のものではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In each case, the type parameter is replaced with an actual type whenever the function is called.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それぞれの場合において、型パラメータは、その関数が呼ばれるときはいつでも実際の型と取り替えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In each form, the name of the operator can contain only the operator characters defined in Operators.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>各形式において、演算子の名前は演算子で定義される演算子文字だけを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In each form, the opening and closing braces are required.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>各形式で、開始と終了の波括弧は必須です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In either case, if you delegate to another initializer that causes initialization to fail, the entire initialization process fails immediately, and no further initialization code is executed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>どちらの場合においても、あなたが初期化失敗の原因となる別のイニシャライザに委任するならば、全体の初期化プロセスは直ちに失敗します、そしてそれ以上初期化コードが実行されることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In either case, the value of the postfix expression is still of an optional type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>いずれにせよ、接尾辞式の値は、依然としてオプショナル型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In either case, these accesses cause the closure to “capture” self, creating a strong reference cycle.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>いずれにせよ、これらのアクセスは、クロージャが強い参照循環をつくってselfを「捕獲する」ことを引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In essence, it’s the same problem as above—two strong references are keeping each other alive.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>本質において、それは上記と同じ問題です ― ２つの強い参照が、お互いを生かし続けています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In fact, someFunction() won’t compile as written below:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>実際、someFunction()は以下のように書かれるときコンパイルしないでしょう：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In fact, adding concurrency might even make your code harder to debug.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>実際に、並行性を加えることは、あなたのコードをデバッグするのを難しくしさえするかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In fact, all of the basic types in Swift—integers, floating-point numbers, Booleans, strings, arrays and dictionaries—are value types, and are implemented as structures behind the scenes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>実際、スウィフトにおける基本の型の全て ― 整数、浮動小数点数、ブール、文字列、配列および辞書 ― は、値型であり、そして舞台裏では構造体として実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In fact, if the first value is false, the second value won’t even be evaluated, because it can’t possibly make the overall expression equate to true.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>実際には、最初の値がfalseならば、２番目の値は評価されさえしません、なぜならそれがどうやっても式全体をtrueと等しくすることが出来ないためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In fact, in cases where there isn’t a meaningful raw value, you don’t have to provide one.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>実際、意味がある生の値がない状況の場合には、あなたはそれを提供する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In fact, the point (0, 0) could match all four of the cases in this example.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>実際、点(0, 0)は、この例ではケース節の４つ全てに適合することができました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In fact, you’ve been using generics throughout the Language Guide, even if you didn’t realize it.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>実際、たとえあなたがそれを実感しなかったとしても、あなたはこの言語ガイドを通して総称体を使用していました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In its general form, the availability condition takes a list of platform names and versions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それの一般的な形式において、有効性条件はプラットホーム名とバージョンを取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In its initializer, the Hoverboard class sets only its color property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのイニシャライザにおいて、Hoverboardクラスはそれのcolorプロパティのみを設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In its simplest form, a switch statement compares a value against one or more values of the same type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その最も単純な形式では、switch文は、ある値を、同じ型の１つ以上の値に対して比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In its simplest form, a stored property is a constant or variable that’s stored as part of an instance of a particular class or structure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その最も単純な形式で、格納プロパティは、特定のクラスまたは構造体のあるひとつのインスタンスの一部として格納される定数または変数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In its simplest form, an initializer is like an instance method with no parameters, written using the init keyword:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その最も単純な形式では、イニシャライザはパラメータのないインスタンスメソッドのようです、そしてinitキーワードを使用して書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In its simplest form, the if statement has a single if condition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その最も単純な形式において、if文はただ１つだけのif条件を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In library evolution mode, code that interacts with members of nonfrozen structures and enumerations is compiled in a way that allows it to continue working without recompiling even if a future version of the library adds, removes, or reorders some of that type’s members.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ライブラリ進化モードでは、非凍結の構造体および列挙のメンバーと相互作用するコードは、ある方法でコンパイルされます、それは、再コンパイルすることなしにそれに仕事を継続させます、たとえ将来のバージョンのライブラリが追加する、削除する、またはその型のもつメンバーのいくつかを再配置するとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In many simple cases, you can ask Swift to provide synthesized implementations of the equivalence operators for you, as described in Adopting a Protocol Using a Synthesized Implementation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>多くの単純な場合では、あなたはスウィフトに頼むことで、等価演算子の合成された実装をあなたの代わりに提供できます。プロトコルを合成実装を使って採用するで記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In most cases, wrappedValue is a computed value, but it can be a stored value instead.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ほとんどの場合には、wrappedValueは計算される値です、しかしそれは代わりに格納される値であることもできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In most cases, this means that memory management “just works” in Swift, and you don’t need to think about memory management yourself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ほとんどの場合、これは、スウィフトにおいてメモリ管理が「正確に機能する」こと、そしてあなたはあなた自身でメモリ管理について考える必要がないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In most cases, tokens are generated from the characters of a Swift source file by considering the longest possible substring from the input text, within the constraints of the grammar that are specified below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ほとんどの場合、トークンは、スウィフトのソースファイルの文字から、下で指定される文法の制約の範囲内で、その入力テキストからの最も長く取ることのできる下位文字列を考慮することによって生成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In most cases, type parameters have descriptive names, such as Key and Value in Dictionary&lt;Key, Value&gt; and Element in Array&lt;Element&gt;, which tells the reader about the relationship between the type parameter and the generic type or function it’s used in.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ほとんどの場合には、型パラメータは描写的な名前を持ちます、たとえばDictionary&lt;Key, Value&gt;におけるKeyとValueおよびArray&lt;Element&gt;におけるElementなど、それは読み手に型パラメータとそれがその中で使われる総称体型や関数との関係について語ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In most cases, you don’t need to pick a specific size of integer to use in your code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ほとんどの場合、あなたはあなたのコードにおいて使用するのに整数の特定のサイズを選択する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In order for this rule to be satisfied, a designated initializer must make sure that all of its own properties are initialized before it hands off up the chain.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この規則が満たされるために、指定イニシャライザは、それがその連鎖を上って手渡す前に、それ自身のプロパティの全てが初期化されることを確認しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In order to work with them as their native type, you need to check their type, or downcast them to a different type, as described below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらをそれらの生来の型として取り扱うために、下で述べるように、あなたはそれらの型を調べること、またはそれらを異なる型へダウンキャストすることが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In other words, the following two declarations are equivalent:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>言い換えると、以下の２つの宣言は、等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In particular, a protocol can declare that conforming types must implement certain properties, methods, initializers, and subscripts.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>特に、プロトコルは、準拠している型が特定のプロパティ、メソッド、イニシャライザ、そして添え字を実装しなければならないと宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In particular, the raw-value type must conform to the Equatable protocol and one of the following protocols: ExpressibleByIntegerLiteral for integer literals, ExpressibleByFloatLiteral for floating-point literals, ExpressibleByStringLiteral for string literals that contain any number of characters, and ExpressibleByUnicodeScalarLiteral or ExpressibleByExtendedGraphemeClusterLiteral for string literals that contain only a single character.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>特に、生の値型は、Equatableプロトコルおよび次のプロトコルの内の１つに準拠しなければなりません：整数リテラルのためのExpressibleByIntegerLiteral、浮動小数点リテラルのためのExpressibleByFloatLiteral、随意の数の文字を含む文字列リテラルのためのExpressibleByStringLiteral、そしてただ１つの文字だけを含む文字列リテラルのためのExpressibleByUnicodeScalarLiteralまたはExpressibleByExtendedGraphemeClusterLiteral。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In particular, the order you insert items into a Dictionary doesn’t define the order they’re iterated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>特に、あなたがDictionaryへと項目を挿入する順序はそれらが反復される順序を定義しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In practice, most access to the properties of a structure can overlap safely.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>実際には、構造体のプロパティに対するほとんどのアクセスは安全にオーバーラップできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In practice, this means most of the custom data types you define will be structures and enumerations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>実際問題としては、これは、あなたが定義するほとんどのあつらえのデータ型は構造体や列挙になることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In practice, this means that you don’t need to write initializer overrides in many common scenarios, and can inherit your superclass initializers with minimal effort whenever it’s safe to do so.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>実際問題として、これは、あなたが多くの通常の状況ではイニシャライザのオーバーライドを書く必要がなく、そしてそれが安全にそうできる時はいつでも最小の努力であなたのスーパークラスのイニシャライザを継承することができることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In practice, you don’t need to write self in your code very often.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>実際問題として、あなたは頻繁にあなたのコードにselfを書く必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In production builds, the condition inside an assertion isn’t evaluated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロダクションビルドでは、表明内の条件は評価されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In situations where either type would be appropriate, Double is preferred.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>どちらの型でも適切である状況では、Doubleが望ましいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In some cases, this requirement is satisfied by inheriting one or more designated initializers from a superclass, as described in Automatic Initializer Inheritance below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>若干の場合には、この必要条件は、下記の自動的なイニシャライザ継承で記述されるように、あるスーパークラスから１つ以上の指定イニシャライザを継承することによって満たされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In some generic contexts, types that get behavior from conditional conformance to a protocol don’t always use the specialized implementations of that protocol’s requirements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>いくつかの総称体文脈では、あるプロトコルに対する条件準拠由来の挙動を持つ型は、そのプロトコルの要件の特殊化された実装を必ず使うとは限りません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In some situations, you might not want to use closed ranges, which include both endpoints.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じ状況において、あなたは完結範囲を使いたいと思うかもしれません、それは両方の終端を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In systems that use garbage collection, weak pointers are sometimes used to implement a simple caching mechanism because objects with no strong references are deallocated only when memory pressure triggers garbage collection.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ガベージコレクションを使うシステムにおいて、時おり弱いポインタが簡単なキャッシュの仕組みを実装するために使われます、なぜなら強い参照を持たないオブジェクトは、メモリの逼迫がガベージコレクションを引き起こす時のみに割り当て解除されるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In terms of the ARC ownership model, an unowned optional reference and a weak reference can both be used in the same contexts.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ARC所有権モデルの観点では、非所有オプショナル参照と弱い参照は両方とも同じ文脈で使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In that context, Self refers to the eventual type that conforms to the protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その文脈で、Selfはそのプロトコルに準拠する結果として生じる型に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the Apartment example above, it’s appropriate for an apartment to be able to have no tenant at some point in its lifetime, and so a weak reference is an appropriate way to break the reference cycle in this case.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のApartment例において、あるアパートがその生涯のどこかの時点で賃借人がいないことがあるというのは妥当です、なのでこの場合は弱い参照が参照循環を壊す適切な方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the CompassPoint example above, north, south, east and west don’t implicitly equal 0, 1, 2 and 3.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のCompassPoint例で、north、south、eastそしてwestは、暗黙のうちに0、1、2そして3に等しくはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the SmallNumber example above, if you try to set the property to a number that’s too large, the property wrapper adjusts the number before storing it.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のSmallNumber例において、あなたがプロパティをある大きすぎる数へと設定しようとするならば、プロパティラッパーはその数を調節します、それを格納する前に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the nourish(with:) function, if vend(itemNamed:) throws an error that’s one of the cases of the VendingMachineError enumeration, nourish(with:) handles the error by printing a message.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>nourish(with:)関数において、vend(itemNamed:)がVendingMachineError列挙のケース節の１つであるエラーをスローするならば、nourish(with:)はそのエラーをメッセージを出力することによって取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the restoreHealth() method above, a write access to self starts at the beginning of the method and lasts until the method returns.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のrestoreHealth()メソッドにおいて、selfへの書き込みアクセスはメソッドの始まりで開始してメソッドが返るまでの間続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the swapTwoValues(_:_:) example above, the placeholder type T is an example of a type parameter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のswapTwoValues(_:_:)例で、プレースホルダ型Tは型パラメータの一例です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the repeat-while loop above, square += board[square] is always executed immediately after the loop’s while condition confirms that square is still on the board.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のrepeat-whileループにおいて、square += board[square]は常に、このループのwhile条件がsquareはまだ盤上かを確認した直後に実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the welcomeMessage example above, no initial value is provided, and so the type of the welcomeMessage variable is specified with a type annotation rather than being inferred from an initial value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のwelcomeMessageの例では、初期値が提供されません、それでwelcomeMessage変数の型は、最初の値から推論されるのではなく、型注釈で指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the ARC ownership model, a department owns its courses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ARC所有権モデルにおいて、ある学科はそれの課程それらを所有します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the above example, approximateCount is evaluated in a switch statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例で、approximateCountはswitch文において評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the above example, the buyFavoriteSnack(person:vendingMachine:) function is called in a try expression, because it can throw an error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例において、buyFavoriteSnack(person:vendingMachine:)関数はtry式の中で呼び出されます、それがエラーをスローできるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the above example, the raw value of ExampleEnum.a is 0 and the value of ExampleEnum.b is 1.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上記の例で、ExampleEnum.aの値は0です、そしてExampleEnum.bの値は1です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the above example, the raw value of GamePlayMode.cooperative is "cooperative", the raw value of GamePlayMode.individual is "individual", and the raw value of GamePlayMode.competitive is "competitive".</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例において、GamePlayMode.cooperativeの生の値は"cooperative"です、GamePlayMode.individualの生の値は"individual"です、そしてGamePlayMode.competitiveの生の値は"competitive"です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the body of a method</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メソッドの本文において</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the body of the function, the copy is modified.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数の本体において、そのコピーが修正されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the case of the sorted(by:) method, the purpose of the closure is clear from the fact that sorting is taking place, and it’s safe for a reader to assume that the closure is likely to be working with String values, because it’s assisting with the sorting of an array of strings.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>sorted(by:)メソッドの場合、クロージャの目的はソートが行われているという事実から明快です、そして、読者がクロージャはString値を扱っているようだと仮定しても差し支えありません、なぜならそれがいくつかの文字列からなる配列のソートを手伝っているからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the case where it equals .south, print "Watch out for penguins".”</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それが.southに等しい場合には、"Watch out for penguins"を出力する。」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the case where it equals .north, print "Lots of planets have a north".</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それが.northに等しい場合には、"Lots of planets have a north"を出力する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the code above, FutureText appears as part of the type of brokenDrawing because it’s one of the types in the DrawEither generic type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のコードにおいて、FutureTextはbrokenDrawingの型の一部として現れます、なぜならそれはDrawEither総称体型の中の型のうちの１つだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the code above, stepSize is a global variable, and it’s normally accessible from within increment(_:).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のコードにおいて、stepSizeはグローバル変数です、そしてそれは通常はincrement(_:)内部からアクセス可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the code above, both of the parameters to takesTwoFunctions(first:second:) are functions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のコードにおいて、takesTwoFunctions(first:second:)へのパラメータは両方とも関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the code above, concatenating badStart with end produces a two-line string, which isn’t the desired result.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のコードにおいて、badStartをendと連結することは、２行の文字列を生成します、それは望んだ結果ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the code above, instead of calling the closure passed to it as its customerProvider argument, the collectCustomerProviders(_:) function appends the closure to the customerProviders array.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のコードにおいて、それのcustomerProvider引数としてそれに渡されるクロージャを呼び出す代わりに、collectCustomerProviders(_:)関数は、そのクロージャをcustomerProviders配列に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the code above, the for loop creates an array of drawings, and the buildArray(_:) method turns that array into a Line.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のコードにおいて、forループは描画それらからなるある配列を作成します、そしてbuildArray(_:)メソッドはその配列をLineへと変えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the code above, the optional value assumedString is force-unwrapped before assigning its value to implicitString because implicitString has an explicit, non-optional type of String.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のコードにおいて、オプショナル値assumedStringは強制アンラップされます、それの値をimplicitStringに割り当てる前にです、なぜならimplicitStringはある明示的な、非オプショナル型のStringを持つからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the code above, the type of x matches the type implied by its context exactly, the type of y is convertible from SomeClass to SomeClass?, and the type of z is convertible from SomeSubclass to SomeClass.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のコードにおいて、xの型はそれの文脈によってほのめかされる型とぴったり合致します、yの型はSomeClassからSomeClass?へと変換可能です、そしてzの型はSomeSubclassからSomeClassへと変換可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the code below, john has a residence property value of nil:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下記のコードにおいて、johnはnilのresidenceプロパティ値を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the code below, the TwelveOrLess structure ensures that the value it wraps always contains a number less than or equal to 12.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下のコードにおいて、TwelveOrLess構造体は、それがラップする値が常に12より少ないか等しいある数を含むことを保証します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the code example below, the dictionary’s keys are decomposed into a constant called animalName, and the dictionary’s values are decomposed into a constant called legCount.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下のコード例において、辞書のキーはanimalNameと呼ばれる定数へと分解されます、そして辞書の値はlegCountと呼ばれる定数へと分解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the conditional compilation block, the branch for the #if compilation directive must contain at least one expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>条件コンパイルブロックにおいて、#ifコンパイル指令に対する分岐は少なくとも１つの式を含まなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the context of Vector2D, it makes sense to consider “equal” as meaning “both instances have the same x values and y values”, and so this is the logic used by the operator implementation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Vector2Dの文脈では、「同等」を「両方のインスタンスが同じx値とy値を持つ」ことを意味すると考えるのが道理にかなっています、なのでそれが演算子実装によって使われる論理です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the door access example above, it’s useful to add parentheses around the first part of the compound expression to make its intent explicit:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のドア・アクセスの例で、その意図を明確にするために複合式の最初の部分のまわりに丸括弧を加えることは、役に立ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, Ace is explicitly given a raw value of 1, and the rest of the raw values are assigned in order.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例では、Aceは暗黙的に1の生の値を与えられます、そして残りの生の値は順に割り当てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, CompassPoint.south has an implicit raw value of "south", and so on.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例において、CompassPoint.southは暗黙的な生の値の"south"をもちます、等々。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, Planet.mercury has an explicit raw value of 1, Planet.venus has an implicit raw value of 2, and so on.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例において、Planet.mercuryは明示的な生の値の1を持ちます、Planet.venusは暗黙的な生の値の2を持ちます、等々。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, SomeClassOnlyProtocol can only be adopted by class types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例で、SomeClassOnlyProtocolはクラス型によってのみ採用されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, greeting is a string, which means it has a region of memory where the characters that make up the string are stored.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例において、greetingは文字列です、それはその文字列を作り上げる文字が格納されるところのメモリ領域をそれが持つことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, incrementBySeven and incrementByTen are constants, but the closures these constants refer to are still able to increment the runningTotal variables that they have captured.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例で、incrementBySevenとincrementByTenは定数です、しかしこれらの定数が言及するクロージャはそれでもなお、それらが捕獲したrunningTotal変数を増加させることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, index is a constant whose value is automatically set at the start of each iteration of the loop.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例で、indexは、ループの各繰り返しの開始時点でその値が自動的に設定される定数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, let distributes to each identifier pattern in the tuple pattern (x, y).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例で、letは、タプルパターン(x, y)における各識別子パターンに分配されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, possiblePlanet is of type Planet?, or “optional Planet.”</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例で、possiblePlanetは型Planet?、すなわち「オプショナルのPlanet」です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, length is initialized when the new range is created and can’t be changed thereafter, because it’s a constant property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例で、lengthは新しい範囲が作成される時に初期化されます、そしてその後は変更されることが出来ません、なぜならそれが変数プロパティだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, Oscar’s health and energy are passed as the two in-out parameters to balance(_:_:).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例において、Oscarの体力とエネルギーは２つのin-outパラメータとしてbalance(_:_:)に渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, an empty string ("") is a valid, non-optional String.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例において、空の文字列（""）は有効な、オプショナルでないStringです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, calling balance(_:_:) on the elements of a tuple produces a conflict because there are overlapping write accesses to playerInformation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例において、balance(_:_:)をタプルの要素上で呼び出すことは衝突を生み出します、なぜならplayerInformationに対するオーパーラップ書き込みアクセスが存在するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, calling the shareHealth(with:) method for Oscar’s player to share health with Maria’s player doesn’t cause a conflict.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例において、shareHealth(with:)メソッドをOscarのプレイヤーに対して呼びだしてMariaのプレイヤーと体力を共有することは、衝突を引き起こしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, even though the entire multiline string literal is indented, the first and last lines in the string don’t begin with any whitespace.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例において、たとえ複数行リテラル全体が字下げされるとしても、その文字列の最初と最後の行は全く空白で始まりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, it’s guaranteed that number % 10 will always be a valid subscript key for the digitNames dictionary, and so an exclamation point is used to force-unwrap the String value stored in the subscript’s optional return value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例でnumber % 10は常にdigitNames辞書のための有効な添え字キーであることを求められます、なのでその添え字のオプショナルの戻り値に保管したString値を強制アンラップするために感嘆符が使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, it’s the choice of closure that incrementByTen refers to that’s constant, and not the contents of the closure itself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例では、それは「クロージャの選択」です、それがincrementByTenが参照するものであり、それは定数であり、そしてクロージャ自身の内容ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, the Size structure has a default value for both its height and width properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例において、Size構造体は省略時の値をそれのheightとwidthプロパティの両方に対して持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, the Suffix associated type for Stack is also Stack, so the suffix operation on Stack returns another Stack.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例において、StackのためのSuffix関連型もまたStackです、それでStack上のsuffix演算は別のStackを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, the allItemsMatch(_:_:) function correctly reports that all of the items in the two containers match.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例で、allItemsMatch(_:_:)関数は、２つのコンテナの中の項目の全てが一致すると正しく報告します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, the description property correctly reports that the Ace of Spades has a value of 1 or 11.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例で、descriptionプロパティは、スペードのエースが1または11の値を持つことを正しく報告します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, the Key type parameter is constrained to conform to the Hashable protocol and therefore String must also conform to the Hashable protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例で、Key型パラメータは、Hashableプロトコルに準拠することを強制されます、したがってStringもまたHashableプロトコルに準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, the compiler infers that myVariable is an integer because its initial value is an integer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例で、コンパイラはmyVariableが整数であると推測します、その最初の値が整数であるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, the first three decimal codeUnit values (68, 111, 103) represent the characters D, o, and g, whose UTF-8 representation is the same as their ASCII representation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例において、最初の３つの10進のcodeUnit値（68、111、103）は、文字D、o、そしてgを表わします、これらのUTF-８叙述はそれらのASCII叙述と同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, the function call marked “Ambiguous” prints “- 120” and produces a compiler warning on Swift 5.3.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例において、“あいまい（Ambiguous）” と印される関数呼び出しは “- 120” を出力します、そしてコンパイラ警告をSwift 5.3で生成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, the operator is used to determine an initial value for a String variable called colorNameToUse.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例で、この演算子はcolorNameToUseと呼ばれるあるString変数の初期値を確定するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, the use of an implicitly unwrapped optional means that all of the two-phase class initializer requirements are satisfied.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例で、暗黙的にアンラップされるオプショナルの使用は、２段階のクラスイニシャライザの必要とする条件の全てが満たされることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, the value of multiplier is inserted into a string literal as \(multiplier).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例で、multiplierの値は、文字列リテラルに\(multiplier)として差し込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, you can see the left-to-right comparison behavior on the first line.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例において、あなたは左から右への比較挙動を最初の行において見ることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, you place the optional chaining question mark after the parentheses, because the optional value you are chaining on is the buildingIdentifier() method’s return value, and not the buildingIdentifier() method itself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例で、あなたは丸括弧の後にオプショナル連鎖の疑問符を置きます、なぜなら、あなたがその上に連鎖しているオプショナルの値はbuildingIdentifier()メソッドの戻り値であって、buildingIdentifier()メソッドそれ自体ではないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, you write Beverage.allCases to access a collection that contains all of the cases of the Beverage enumeration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例において、あなたはBeverage.allCasesを書いて、Beverage列挙のケース節の全てを含むコレクションにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example below, oneAndTwo is an instance of Pair&lt;String&gt;, which conforms to TitledLoggable because String conforms to TitledLoggable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例において、oneAndTwoはPair&lt;String&gt;のインスタンスです、それはTitledLoggableに準拠します、なぜならStringはTitledLoggableに準拠するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example below, startsWithZero() is available only if Element conforms to both SomeProtocol and Numeric.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例において、startsWithZero()は、ElementがSomeProtocolとNumericの両方に準拠する場合にのみ利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example below, class A is a public class with a file-private method called someMethod().</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下記の例で、クラスAは公開のクラスです、それはsomeMethod()と呼ばれるあるファイル外非公開のメソッドを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example below, the CompassPoint enumeration has an explicit access level of public.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例において、CompassPoint列挙は明示的な公開のアクセス水準を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example below, the VendingMachine class has a vend(itemNamed:) method that throws an appropriate VendingMachineError if the requested item isn’t available, is out of stock, or has a cost that exceeds the current deposited amount:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例において、VendingMachineクラスはvend(itemNamed:)メソッドを持ちます、それは、要求された項目が利用可能でない、在庫切れ、または現在預け入れされた総額を超える価格を持つならば対応するVendingMachineErrorをスローします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example below, the constant twoThousand is of type UInt16, whereas the constant one is of type UInt8.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下記の例で、定数twoThousandは型UInt16ですが、定数oneは型UInt8です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example below, the first Bool value (hasDoorKey) is false, but the second value (knowsOverridePassword) is true.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下記の例で、最初のBool値（hasDoorKey）はfalseです、しかし、第二の値（knowsOverridePassword）はtrueです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example below, the values of firstBits and otherBits each have a bit set to 1 in a location that the other does not.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下記の例で、firstBitsとotherBitsそれぞれの値は、他のものがそうでない場所で、ビットを1に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example below, the values of firstSixBits and lastSixBits both have four middle bits equal to 1.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下記の例で、firstSixBitsとlastSixBitsの値は、1と等しい４つの中間のビットを両方とも持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example below, the values of someBits and moreBits have different bits set to 1.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下記の例で、someBitsとmoreBitsの値は、1に設定される異なるビットを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example below, when c isn’t nil, its value is unwrapped and used to evaluate .property, the value of which is used to evaluate .performAction().</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下記の例で、cがnilでないとき、その値はアンラップされて.propertyを評価するために使われ、その値が.performAction()を評価するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the examples above, ARC is able to track the number of references to the new Person instance you create and to deallocate that Person instance when it’s no longer needed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例で、ARCはあなたがつくる新しいPersonインスタンスへの参照の数を追跡して、そのPersonインスタンスをそれがもはや必要でないとき割り当て解除することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the expression 1 + 2, the + symbol is an infix operator and its two operands are the values 1 and 2.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>式1 + 2において、記号+は接中辞演算子です、そしてその２つの演算数は値1と2です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the extension, you must implement all of the adopted protocol’s requirements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張において、あなたは採用されたプロトコルの要件の全てを実装しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the first case, a type identifier refers to a type alias of a named or compound type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>第一の場合には、型識別子は、名前付きまたは複合の型の型エイリアスに言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the first case, the cluster contains a single scalar; in the second case, it’s a cluster of two scalars:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初の場合では、クラスタは、ただ１つだけのスカラーを含みます；２番目の場合には、それは、２つのスカラーのクラスタ（１つの房、群れ）です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the first example, the expression someTuple is specified to have the tuple type (Double, Double).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初の例で、式someTupleは、タプル型(Double, Double)を持つと指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the first of these two checks, the didSet observer sets currentLevel to a different value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの２つのチェックで最初のものにおいて、didSetオブザーバーは、currentLevelを異なる値に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the first phase, each stored property is assigned an initial value by the class that introduced it.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初の段階では、各格納プロパティは、それを導入したクラスによって、初期値を代入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the following example, for instance, the explicit type annotation (: Float) on the constant eFloat causes the numeric literal 2.71828 to have an inferred type of Float instead of Double.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、以下の例において、定数eFloatでの明示的な型注釈（: Float）は、数値リテラル2.71828をFloatの推論される型を持つようにします、Doubleではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the future, the string might contain multiple slashes, such as MyModule/some/disambiguation/MyFile.swift.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>将来において、その文字列は複数のスラッシュを含むかもしれません、たとえばMyModule/some/disambiguation/MyFile.swiftのように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the implementation of makeOpaqueContainer(item:), the underlying type of the opaque container is [T].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>makeOpaqueContainer(item:)の実装において、不透明コンテナの基礎をなす型は、[T]です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the line of code that says return greeting, the function finishes its execution and returns the current value of greeting.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>return greetingを告げるコード行において、関数はその実行を終えてgreetingの現在の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the members of a class declaration, Self can appear only as follows:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラス宣言のメンバーにおいて、Selfは以下のようにのみ現れることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the middle of an update, after appending the new measurement but before updating max, the temperature logger is in a temporary inconsistent state.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>更新の中途において、新しい測定を追加した後しかしmaxを更新する前に、TemperatureLoggerは一時的な矛盾状態に置かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the previous example, it’s not easy to see that someAddress is never evaluated, because accessing a constant doesn’t have any side effects.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>前の例において、someAddressが決して評価されないというのはわかりやすいとはいえません、なぜならある定数を代入することは、何ら副作用を持たないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the same way that you can use your own types in a for-in loop by adding conformance to the Sequence [https://developer.apple.com/documentation/swift/sequence] protocol, you can use your own types in a for-await-in loop by adding conformance to the AsyncSequence [https://developer.apple.com/documentation/swift/asyncsequence] protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがあなた独自の型をfor-inループにおいてSequence [https://developer.apple.com/documentation/swift/sequence]プロトコルへの準拠を加えることによって使うのと同じ方法で、あなたはあなた独自の型をfor-await-inループにおいて使うことがAsyncSequence [https://developer.apple.com/documentation/swift/asyncsequence]プロトコルへの準拠を加えることによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the scope of a class declaration, writing the static modifier on a member declaration has the same effect as writing the class and final modifiers on that member declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラス宣言のスコープにおいて、static修飾子をメンバー宣言上で書くことは、classとfinal修飾子をそのメンバー宣言上で書くことと同じ効果を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the second case, a type identifier uses dot (.) syntax to refer to named types declared in other modules or nested within other types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>第二の場合には、型識別子は、他のモジュールで宣言される、または他の型の内部で入れ子にされる名前付きの型を参照するためにドット（.）構文を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the second example, the parameter a to the function someFunction is specified to have the type Int.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>第二の例で関数someFunctionのためのパラメータaは、型Intを持つ指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the setter for perimeter, the new value has the implicit name newValue.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>perimeterのためのセッターにおいて、新しい値は、隠された名前newValueを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the two examples below, T is inferred to be Int and String respectively:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の２つの例で、TはそれぞれIntとStringであると推測されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the version of this example that uses contextual where clauses, the implementation of average() and endsWith(_:) are both in the same extension because each method’s generic where clause states the requirements that need to be satisfied to make that method available.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例の文脈where節を使うバージョンでは、average()とendsWith(_:)の実装は両方とも同じ拡張の中にあります、なぜなら各メソッドのもつ総称体where節それらが、そのメソッドを利用可能にするのに満足させる必要がある要件を述べるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In these cases, it’s useful to remove the need to check and unwrap the optional’s value every time it’s accessed, because it can be safely assumed to have a value all of the time.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの場合には、オプショナルの値をそれがアクセスされるたびに確認してアンラップする必要を無くすことは役に立ちます、なぜならそれがいつでも値を持つと安全に仮定されることが出来るためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In these cases, you can omit the value from one side of the range operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの場合、あなたは範囲演算子の１つの側から値を省くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this case, Element is used as a placeholder in three places:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この場合、Elementはプレースホルダとして３つの場所で使われます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this case, T is Int, so the return value is an array of integers and the Item associated type is inferred to be Int.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この場合に、TはIntです、それで戻り値は整数からなるある配列です、そしてItem関連型はIntと推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this case, because the image is shipped with the application, no error will be thrown at runtime, so it’s appropriate to disable error propagation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この場合、画像はアプリケーションとともに出荷されるので、エラーが実行時にスローされることはありません、それでふさわしいのはエラー伝達を抑制することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this case, for example, when you delete a course from department.courses you also need to remove any references to it that other courses might have.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この場合には、例えば、あなたがある課程をdepartment.coursesから削除する場合はあなたはまた他の課程が持つかもしれないそれへのあらゆる参照を取り除く必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this case, if the init(name:) initializer of the superclass were ever called with an empty string as the name, the forced unwrapping operation would result in a runtime error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この場合、スーパークラスのinit(name:)イニシャライザがもしかその名前として空の文字列で呼び出されたならば、強制アンラップ操作は実行時エラーという結果になるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this case, it isn’t possible to retrieve a planet with a position of 11, and so the else branch is executed instead.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この場合、11の位置で惑星を取り出すことは可能ではありません、それでelse分岐が代わりに実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this case, the array literal contains two String values and nothing else.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この場合、配列リテラルは、２つのString値を含んでいて他には何も含みません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this case, the capture list is [unowned self], which means “capture self as an unowned reference rather than a strong reference”.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この場合、捕獲リストは[unowned self]です、それは、「selfを強い参照ではなく非所有参照として捕獲する」ことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this case, the code running elsewhere would read incorrect information because its access to the actor was interleaved in the middle of the call to update(with:) while the data was temporarily invalid.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この場合には、どこか他で動作しているコードは正しくない情報を読み出します、なぜならアクターへのそれのアクセスは、update(with:)への呼び出しの中途に、そのデータが一時的に正しくなかった間に、挟み込まれたからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this case, the expression is written as \(Double(multiplier) * 2.5) when it’s included inside the string literal.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この場合、式は、それが文字列リテラルに含められる時、\(Double(multiplier) * 2.5)と書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this case, the loop contains only one statement, which prints an entry from the five-times table for the current value of index.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この場合では、ループは１つの文だけを含みます、それは、indexの現在の値に対する九九の５の段の項を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this case, the underlying type of the return value varies depending on T: Whatever shape is passed it, repeat(shape:count:) creates and returns an array of that shape.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この場合には、戻り値のその基礎をなす型はTに依存して変動します：どんな形状がそれに渡されても、repeat(shape:count:)はその形状からなるある配列を作成して返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this case, there’s no other code inside restoreHealth() that could have an overlapping access to the properties of a Player instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この場合には、restoreHealth()内部の他のコードで、Playerインスタンスのプロパティに対するオーバーラップするアクセスを持つことができるものはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this data model, a customer may or may not have a credit card, but a credit card will always be associated with a customer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このデータ・モデルにおいて、顧客はクレジットカードを持っているかもしれないし、持っていないかもしれません、しかし、クレジットカードは常にひとりの顧客と結び付けられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this data model, every country must always have a capital city, and every city must always belong to a country.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このデータ・モデルにおいて、あらゆる国に常に主都がなければなりません、そして、あらゆる都市は常に国に属していなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this dictionary, the keys are three-letter International Air Transport Association codes, and the values are airport names:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この辞書では、キーは３文字の国際航空運送協会コードです、そして値は空港名です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this example, (404, "Not Found") is a tuple that describes an HTTP status code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例では、(404, "Not Found")がひとつのタプルです、それはHTTP状態コードを記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this example, firstNumber is a named constant for the value 10, and secondNumber is a named constant for the value 42.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例では、firstNumberは、値10のための名前をつけられた定数です、そして、secondNumberは値42のための名前をつけられた定数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this example, someResolution.width refers to the width property of someResolution, and returns its default initial value of 0.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例では、someResolution.widthはsomeResolutionのwidthプロパティに言及して、その省略時の初期値の0を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this example, PrettyTextRepresentable adds a single requirement to provide a gettable property called prettyTextualDescription that returns a String.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例では、PrettyTextRepresentableは１つの要件を加えて、Stringを返すprettyTextualDescriptionと呼ばれる取得可能なプロパティを提供するようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this example, actualNumber is simply used to print the result of the conversion.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例では、actualNumberは単にその変換の結果を出力するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this example, a Double value of 1.0 is considered to represent “one meter”.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例では、1.0のDouble値は「１メートル」を表すと考慮されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this example, a new instance of TimesTable is created to represent the three-times-table.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例では、TimesTableの新しいインスタンスは、九九の３の段を表すためにつくられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this example, accessing logger.max is a possible suspension point.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例において、logger.maxへのアクセスは、ある可能な中断地点です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this example, all three calls to downloadPhoto(named:) start without waiting for the previous one to complete.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例において、downloadPhoto(named:)への３つの呼び出し全ては、前のものが完了するのを待つことなしに開始します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this example, code execution continues if age &gt;= 0 evaluates to true, that is, if the value of age is nonnegative.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例において、コード実行はage &gt;= 0がtrueに評価されるならば、すなわちageの値が負でないならば継続します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this example, depending on whether you wanted the original total amount or the updated total amount, either $5 or $320 could be the correct answer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例では、あなたが望んだのが元の総支出額か更新後の総支出額かにより、5ドルか320ドルのどちらかが正しい答えとなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this example, each item in the array might be a Movie, or it might be a Song.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例では、配列の各項目はMovieであるかもしれませんし、それはSongであるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this example, initialization begins with a call to a convenience initializer on the subclass.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例では、初期化はサブクラス上での便宜イニシャライザへの呼び出しから始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this example, it checks whether game is actually an instance of SnakesAndLadders behind the scenes, and prints an appropriate message if so.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例では、gameが実際に舞台裏でSnakesAndLaddersのインスタンスであるかどうか調べて、もしそうならば適切なメッセージを出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this example, it simply prints out the value that’s about to be set.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例では、それは単に設定されようとしている値を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this example, it would be preferable to write the sorting closure inline, using closure expression syntax.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例では、クロージャ式構文を使って、ソート・クロージャを行内に書くことがずっと好ましいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this example, the Named protocol has a single requirement for a gettable String property called name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例において、Namedプロトコルは、取得可能なStringプロパティでnameと呼ばれるものに対するただ１つの要件を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this example, the buyFavoriteSnack(person: vendingMachine:) function looks up a given person’s favorite snack and tries to buy it for them by calling the vend(itemNamed:) method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例において、buyFavoriteSnack(person: vendingMachine:)関数は指定された個人のお気に入りのスナックを探してそれを彼らのために仕入れることをvend(itemNamed:)メソッドを呼ぶことによって試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this example, the loadPicture(from:completion:onFailure:) function dispatches its network task into the background, and calls one of the two completion handlers when the network task finishes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例において、loadPicture(from:completion:onFailure:)関数は、それのネットワークタスクをバックグラウンドへとディスパッチします、そして２つの完了ハンドラのうちの１つをネットワークタスクが終了する時に呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this example, the makeASandwich() function will throw an error if no clean dishes are available or if any ingredients are missing.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例において、makeASandwich()関数は、綺麗な皿が利用可能でないならばまたは何の食材も見つからないならばエラーをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this example, the attempt to set the address property of john.residence will fail, because john.residence is currently nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例において、john.residenceのaddressプロパティを設定する試みは失敗します、なぜならjohn.residenceが現在nilだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this example, the attempt to set the address property of john.residence will succeed, because the value of john.residence currently contains a valid Residence instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例において、john.residenceのaddressプロパティを設定しようとする試みは成功します、なぜならjohn.residenceの値は現在は有効なResidenceインスタンスを含むからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this example, the closing &gt; characters aren’t treated as a single token that may then be misinterpreted as a bit shift &gt;&gt; operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例において、閉じ&gt;文字それらは、単一のトークンとして見なされることはなく、それでビットシフト演算子&gt;&gt;と誤解されることはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this example, the maximum number of allowed login attempts is declared as a constant, because the maximum value never changes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例において、許可されるログインの試みの最大数は、最大の値が決して変わらないので、定数として宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this example, the number 5 is correctly identified as a prime number.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例では、数5は正しく素数と確認されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this example, the property wrapper exposes only one piece of information—whether the number was adjusted—so it exposes that Boolean value as its projected value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例では、プロパティラッパーは情報の一片だけを露出します — その数が調節されたかどうか — それでそれはそのブール値をそれの投影値として露出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this example, the superclass for RecipeIngredient is Food, which has a single convenience initializer called init().</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例では、RecipeIngredientのためのスーパークラスはFoodです、それは、init()と呼ばれる１つの便宜イニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this example, the value of friendlyWelcome is changed from "Hello!" to "Bonjour!":</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例では、friendlyWelcomeの値は、"Hello!"から"Bonjour!"に変えられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this example, the variable number is initialized with the value of the closure’s number parameter, so that the value can be modified within the closure body.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例では、変数numberはこのクロージャの持つnumberパラメータの値を使って初期化されます、それでその値はクロージャ本体の内部で修正されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this figure, the left channel has a current level of 9, and the right channel has a current level of 7:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この図には、左のチャンネルに現在9のレベルがあり、右のチャンネルに現在7のレベルがあります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this form, each case block consists of the case keyword followed by one or more enumeration cases, separated by commas.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この形式では、それぞれのケース節ブロックはキーワードcaseとそれに続く１つ以上の、コンマで区切られた、列挙ケース節から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this form, each case block consists of the case keyword, followed by one or more enumeration cases, separated by commas.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この形式では、それぞれのケース節ブロックはキーワードcase、それに続けて、コンマで区切られる１つ以上の列挙ケース節から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this implementation, the input parameters are named left and right to represent the Vector2D instances that will be on the left side and right side of the + operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この実装において、入力パラメータは、leftとrightという名前をつけられ、+演算子の左側と右側にあるVector2Dインスタンスを表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this protocol, Suffix is an associated type, like the Item type in the Container example above.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このプロトコルにおいて、Suffixは関連型です、上のContainer例でのItem型のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this scenario, it’s useful to combine an unowned property on one class with an implicitly unwrapped optional property on the other class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この筋書きにおいて、一方のクラス上の非所有プロパティと他方のクラス上の暗黙的にアンラップされるオプショナルのプロパティを結合することは、役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this situation, the parameter name takes precedence, and it becomes necessary to refer to the property in a more qualified way.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この状況には、パラメータ名が優先されます、そして、より対象を限定するやり方でプロパティに言及することが必要になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this style, more complex code with deep nesting can quickly become unwieldy.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このやり方では、深く入れ子になっているさらに複雑なコードは、すぐに手に負えなくなりえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this version of the game, the first action in the loop is to check for a ladder or a snake.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ゲームのこの改作において、ループでの最初の活動は、はしごまたはヘビについて調べることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In-Out Expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>in-out式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In-Out Parameters</seg>
      </tuv>
      <tuv lang="ja">
        <seg>In-Outパラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In-out expressions are also used when providing a non-pointer argument in a context where a pointer is needed, as described in Implicit Conversion to a Pointer Type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>in-out式はまた、ポインタが必要とされる文脈において非ポインタ引数を提供する時に使われます、ポインタ型への暗黙的変換で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In-out parameters are an alternative way for a function to have an effect outside of the scope of its function body.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>in-outパラメータは、その関数本体のスコープの外で効果を持つようにする関数のための代替の方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In-out parameters are discussed in In-Out Parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>in-outパラメータは、in-outパラメータで議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In-out parameters are discussed in detail in In-Out Parameters, below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>in-outパラメータは詳細に、下で、in-outパラメータにおいて議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In-out parameters are passed as follows:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>in-outパラメータは、以下のように渡されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In-out parameters aren’t the same as returning a value from a function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>in-outパラメータは、関数からある値が返されることと同じではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In-out parameters can’t have default values, and variadic parameters can’t be marked as inout.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>In-outパラメータは省略時の値を持つことができません、そして可変長パラメータはinoutとして印されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Includes a new section on Extended Grapheme Clusters and more information about Unicode Scalar Values and Comparing Strings.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張書記素クラスタに関する新しい節そしてユニコードスカラー値と文字列を比較するについての更なる情報を含めました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Including a default or @unknown default case when switching over a frozen enumeration produces a warning because that code is never executed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>defaultまたは@unknown defaultケース節を、凍結列挙に対してスイッチしている時に含めることは、警告を生成します、なぜならそのコードは決して遂行されないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Indeed, if you are writing a single-target app, you may not need to specify explicit access control levels at all.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>実際に、あなたが単一ターゲットのアプリを書いているならば、明確なアクセス制御水準を指定する必要はまったくありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Indeed, if you delete the typealias Item = Int line from the code above, everything still works, because it’s clear what type should be used for Item.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>本当に、あなたが上のコードから行typealias Item = Intを削除するならば、すべては依然として働きます、なぜなら、どんな型がItemのために使われなければならないかは明白であるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Indeed, if you tried to access the instance, your app would most likely crash.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>実はそれどころか、あなたがそのインスタンスにアクセスしようとするならば、あなたのアプリはたぶんクラッシュするでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Indentation at the start of each quoted line is removed, as long as it matches the indentation of the closing quotation marks.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>各引用された行の始まりでの字下げは、それが終了引用符の字下げと合致する分だけは、取り除かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Inferring Type From Context</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文脈から型を推論する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Inferring parameter and return value types from context</seg>
      </tuv>
      <tuv lang="ja">
        <seg>前後関係からパラメータおよび戻り値の型を推論する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Infix Operator Methods no longer require the @infix attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>接中辞演算子メソッドはもはや@infix属性を必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Infix Expressions</seg>
      </tuv>
      <tuv lang="ja">
        <seg>接中辞式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Infix operators can optionally specify a precedence group.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>接中辞演算子は、任意に優先順位グループを指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Inheritance</seg>
      </tuv>
      <tuv lang="ja">
        <seg>継承</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Inheritance enables one class to inherit the characteristics of another.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>継承は、あるクラスが他のものの特徴を受け継ぐのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Inheritance is a fundamental behavior that differentiates classes from other types in Swift.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>継承は、スウィフトにおいてクラスを他の型と区別する基本的挙動です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Initial values for the properties of the new instance can be passed to the memberwise initializer by name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>新しいインスタンスのプロパティのための初期値は、名前でメンバー関連イニシャライザに渡されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Initial values for the properties of the new instance can be passed to the memberwise initializer by name:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>新しいインスタンスのプロパティのための最初の値は、名前によってメンバー関連イニシャライザに渡されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Initialization</seg>
      </tuv>
      <tuv lang="ja">
        <seg>初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Initialization Parameters</seg>
      </tuv>
      <tuv lang="ja">
        <seg>初期化パラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Initialization failure propagates through initializer delegation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>初期化失敗は、イニシャライザ委任を通じて伝えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Initialization parameters have the same capabilities and syntax as function and method parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>初期化パラメータは、関数およびメソッドのパラメータと同じ能力と構文を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Initializer Declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>イニシャライザ宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Initializer Delegation for Class Types</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラス型のためのイニシャライザ委任</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Initializer Delegation for Value Types</seg>
      </tuv>
      <tuv lang="ja">
        <seg>値型のためのイニシャライザ委任</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Initializer Expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>イニシャライザ式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Initializer Inheritance and Overriding</seg>
      </tuv>
      <tuv lang="ja">
        <seg>イニシャライザの継承およびオーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Initializer Parameters Without Argument Labels</seg>
      </tuv>
      <tuv lang="ja">
        <seg>引数ラベルのないイニシャライザ・パラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Initializer Requirements</seg>
      </tuv>
      <tuv lang="ja">
        <seg>イニシャライザ要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Initializer declarations are declared using the init keyword and have two basic forms.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>イニシャライザ宣言は、キーワードinitを使って宣言されて、２つの基本の書式を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Initializers</seg>
      </tuv>
      <tuv lang="ja">
        <seg>イニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Initializers are described in more detail in Initialization.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>イニシャライザは、更に詳細に初期化で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Initializers are now able to access self and can modify its properties, call its instance methods, and so on.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>イニシャライザは、今ではselfにアクセスすることができます、そしてそれのプロパティを修正すること、それのインスタンスをメソッドを呼び出すこと、などが行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Initializers can call other initializers to perform part of an instance’s initialization.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>イニシャライザは、あるインスタンスの初期化の一部を実行するために他のイニシャライザを呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Initializers can delegate to other initializers in the enumeration, but the initialization process is complete only after an initializer assigns one of the enumeration cases to self.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>イニシャライザは、その列挙の中の他のイニシャライザに委任することができます、しかしその初期化処理はあるイニシャライザが列挙ケース節のうちの１つをselfに代入した後になって初めて終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Initializers in structures and enumerations can call other declared initializers to delegate part or all of the initialization process.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体および列挙のイニシャライザは、初期化プロセスの一部または全てを委任するために他の宣言済みイニシャライザを呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Initializing an Empty String</seg>
      </tuv>
      <tuv lang="ja">
        <seg>空の文字列を初期化する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Initializing from a Raw Value</seg>
      </tuv>
      <tuv lang="ja">
        <seg>生の値から初期化する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Inlinable code can interact with public symbols declared in any module, and it can interact with internal symbols declared in the same module that are marked with the usableFromInline attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>インライン可能コードは、何らかのモジュールにおいて宣言されるpublicシンボルと相互作用できます、そしてそれは同じモジュールにおいて宣言されるinternalシンボルで、usableFromInline属性で印されるものと相互作用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Inlinable code can’t interact with private or fileprivate symbols.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>インライン可能コードは、privateまたはfileprivateシンボルと相互作用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Inserting -9 and 4 into the equation yields:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>-9と4を等式に入れることは、以下を生じます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Inserting 9 and 4 into this equation yields:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>9と4をこの等式に入れることは、以下を生じます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Inserting and Removing</seg>
      </tuv>
      <tuv lang="ja">
        <seg>差し込みと削除</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Inside a closure with no explicit parameter names, the parameters are implicitly named $0, $1, $2, and so on.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>明確なパラメータ名のないクロージャの内部で、パラメータは暗黙のうちに$0、$1、$2、などと名前をつけられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Inside a function, the value of #function is the name of that function, inside a method it’s the name of that method, inside a property getter or setter it’s the name of that property, inside special members like init or subscript it’s the name of that keyword, and at the top level of a file it’s the name of the current module.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数の内側では、#functionの値は、その関数の名前であり、メソッドの内側ではそれはそのメソッドの名前であり、プロパティゲッターやセッターの内側ではそれはそのプロパティの名前であり、initまたはsubscriptのような特別なメンバーの内側ではそれはそのキーワードの名前であり、そしてあるファイルのトップレベルではそれは現在のモジュールの名前です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Inside a nested type declaration, the Self type refers to the type introduced by the innermost type declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>入れ子にされた型宣言の内部で、Self型は、最も内側の型宣言によって導入された型を参照します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Inside a protocol declaration, a type alias can give a shorter and more convenient name to a type that’s used frequently.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル宣言の内部で、型エイリアスはより短くより便利な名前を頻繁に使われる型に提供できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Inside an asynchronous method, the flow of execution is suspended only when you call another asynchronous method—suspension is never implicit or preemptive—which means every possible suspension point is marked with await.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非同期メソッドの内部では、遂行の流れは、あなたが別の非同期メソッドを呼び出す時にのみ中断されます — 中断は決して暗黙的または先制的ではありません — それが意味するのはあらゆる可能な中断地点はawaitで印されるということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Inside the do block, you mark code that can throw an error by writing try in front of it.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>doブロックの内部で、あなたはエラーをスローできるコードを、それの前にtryを書くことによって印します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Inside the catch block, the error is automatically given the name error unless you give it a different name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>catchブロック内部で、エラーは、あなたがそれに別の名前を与えるのでない限り、自動的に名前errorを与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Inside the body of an asynchronous function or method, you mark each of these places where execution can be suspended.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非同期の関数やメソッドの本体の内部で、あなたは遂行が中断されることが可能であるそれら場所のそれぞれに印をつけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Inside the declaration for a member of a type, the Self type refers to that type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある型のメンバーに対する宣言の内部で、Self型は、その型を参照します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Inside the switch, the enumeration case is referred to by the abbreviated form .hearts because the value of self is already known to be a suit.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スイッチの内側では、列挙のケース節は省略された形式.heartsによって参照されます、なぜならselfの値がすでに組み札のひとつ（スペード、クラブ、ハート、ダイヤのどれか）であるということがわかっているからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instance Methods</seg>
      </tuv>
      <tuv lang="ja">
        <seg>インスタンスメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instance methods added with an extension can also modify (or mutate) the instance itself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張を使って加えられるインスタンスメソッドは、また、インスタンスそれ自体を修正（または変更）することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instance methods have exactly the same syntax as functions, as described in Functions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>インスタンスメソッドは、関数と正確に同じ構文を持ちます、関数で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instance methods, as described above, are methods that you call on an instance of a particular type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>インスタンスメソッドは、上で記述されるように、あなたが特定の型のインスタンス上で呼び出すメソッドです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instance properties are properties that belong to an instance of a particular type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>インスタンスプロパティは、ある特定の型のあるひとつのインスタンスに属しているプロパティです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instance subscripts, as described above, are subscripts that you call on an instance of a particular type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>インスタンス添え字は、上で記述されるように、あなたがある特定の型のインスタンス上で呼び出す添え字です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instances of FixedLengthRange have a variable stored property called firstValue and a constant stored property called length.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>FixedLengthRangeのインスタンスはfirstValueと呼ばれる変数格納プロパティとlengthと呼ばれる定数格納プロパティをもちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instances of Hamster can now be used wherever TextRepresentable is the required type:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>TextRepresentableが必要な型であるどこででも、Hamsterのインスタンスが現在使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instances of class types can also implement a deinitializer, which performs any custom cleanup just before an instance of that class is deallocated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラス型のインスタンスはまた、デイニシャライザを実装することができます、それは、そのクラスのインスタンスの割り当て解除がされる直前に、何らかのあつらえのクリーンアップ作業を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instances with a concrete type of Any maintain their original dynamic type and can be cast to that type using one of the type-cast operators—as, as?, or as!.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Anyの具象型をもつインスタンスは、それらの本来の動的型を管理します、そして型キャスト演算子—as、as?、またはas!を使ってその型へとキャストできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instead of generating a random number, it starts with a diceRoll value of 0.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>無作為な数を生成する代わりに、それは0のdiceRoll値から始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instead of making a copy immediately, these collections share the memory where the elements are stored between the original instance and any copies.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるコピーを直接に作る代わりに、それらコレクションは要素が格納されるところのメモリを、元のインスタンスと何らかのコピーの間で共有します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instead of making an explicit call to super.init(), this initializer relies on an implicit call to its superclass’s initializer to complete the process.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>super.init()への明示的な呼び出しをする代わりに、このイニシャライザはそれのスーパークラスの持つイニシャライザへの暗黙的な呼び出しを当てにすることで、その過程を完了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instead of providing a concrete type as the function’s return type, the return value is described in terms of the protocols it supports.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある具象型を関数のもつ戻り型として提供する代わりに、戻り値はそれがサポートするプロトコルそれらの観点から記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instead of returning a new point, this method actually modifies the point on which it’s called.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>新しい点を返す代わりに、このメソッドは、それが呼び出された点を実際に修正します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instead of using an ordinary for-in loop, the example above writes for with await after it.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>普通のfor-inループを使う代わりに、上の例はforをそれの後のawaitと共に書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instead, Rect defines a custom getter and setter for a computed variable called center, to enable you to work with the rectangle’s center as if it were a real stored property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その代わりに、Rectは、centerと呼ばれる計算される変数のためにあつらえのゲッターとセッターを定義して、矩形のcenterをそれがまったく格納プロパティであるかのようにあなたが扱うことができるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instead, a literal is parsed as having infinite precision and Swift’s type inference attempts to infer a type for the literal.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そうではなく、リテラルは無限精度を持つものとして解析されて、スウィフトの型推論はそのリテラルの型を推測することを試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instead, execution continues until the line where photos is defined—at that point, the program needs the results from these asynchronous calls, so you write await to pause execution until all three photos finish downloading.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>代わりに、遂行はphotosが定義されるところの行まで継続します — その時点で、プログラムはそれら非同期呼び出しからの結果を必要とします、なのであなたはawaitを書いて、３枚の写真全てがダウンロードを終了するまで遂行を中断します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instead, it makes more sense to create the DataImporter instance if and when it’s first used.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その代わりに、それが最初に必要とされる時になればDataImporterを作成するほうが筋が通ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instead, make an explicit check against nil with the == or != operators to find out if an optional contains a value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その代わりに、nilに備えて、==または!=演算子を使ってオプショナルが値を持つかどうか確認するために明示的に調べてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instead, the Stack type’s existing type parameter name, Element, is used within the extension to indicate the optional type of the topItem computed property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そうしなくても、Stack型の既存の型パラメーター名、Elementは、拡張の内部でtopItem計算プロパティの元々の型を指し示すために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instead, the addition assignment operator method takes advantage of the existing addition operator method, and uses it to set the left value to be the left value plus the right value:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>代わりに、追加代入演算子メソッドは、既存の加算演算子メソッドを利用して、左の値を右の値を加えた左の値に設定するためにそれを使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instead, the different enumeration cases are values in their own right, with an explicitly defined type of CompassPoint.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その代わりに、異なる列挙ケース節それらは、ある明示的に定義されたCompassPointの型を持つ、自分だけのものである値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instead, the entire switch statement finishes its execution as soon as the first matching switch case is completed, without requiring an explicit break statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その代わりに、最初のマッチしているswitchケース節の部分が完了されるとすぐに、switch文の全体がその実行を終えます、明確なbreak文を必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instead, the loop is executed until a particular condition is satisfied.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その代わりに、このループは特定の条件が満たされるまで実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instead, the protocol’s own access level is used to provide the default access level for each protocol requirement implementation within the extension.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その代わりに、プロトコル自身のアクセス水準が、省略時のアクセス水準を拡張内の各プロトコル要件実施のために提供するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instead, the type parameter list from the original type definition is available within the body of the extension, and the original type parameter names are used to refer to the type parameters from the original definition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そうしなくても、元々の型定義からの型パラメーターリストは、その拡張の本文内で利用可能です、そして元々の型パラメーター名は、元々の定義からの型パラメーターを参照するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instead, these references are defined like any other constant or variable in Swift.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その代わりに、これらの参照は、スウィフトにおけるあらゆる他の定数または変数と同じように定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instead, they provide a getter and an optional setter to retrieve and set other properties and values indirectly.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その代わりに、それらは他のプロパティや値を間接的に取得したり設定したりするためにゲッターと任意のセッターを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instead, they’re called only when the value is set outside of an initialization context.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そうではなく、値が初期化の文脈の外で設定されるときにだけ、それらは呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instead, this example calls UInt16(one) to create a new UInt16 initialized with the value of one, and uses this value in place of the original:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その代わりに、この例はoneの値で初期化される新しいUInt16を作るためにUInt16(one)を呼んで、オリジナルの代わりにこの値を使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instead, use separate available attributes to specify a Swift version availability and one or more platform availabilities.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>代わりに、available属性を使うことで、スウィフトバージョン有効性と１つ以上のプラットホーム有効性を指定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instead, use the append(_:) method, or append a single-item array with the += operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その代わりに、append(_:)メソッドを使ってください、または単一項目の配列を+=演算子を使って加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Integer Bounds</seg>
      </tuv>
      <tuv lang="ja">
        <seg>整数の限界</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Integer Conversion</seg>
      </tuv>
      <tuv lang="ja">
        <seg>整数変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Integer Literals</seg>
      </tuv>
      <tuv lang="ja">
        <seg>整数リテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Integer and Floating-Point Conversion</seg>
      </tuv>
      <tuv lang="ja">
        <seg>整数と浮動小数点の変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Integer literals can be written as:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>整数リテラルは、次のように書かれることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Integer literals can begin with leading zeros (0), but they’re likewise ignored and don’t affect the base or value of the literal.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>整数リテラルは、いくつかのゼロ（0）を先頭に始まることができます、しかしそれらは同様に無視されて、リテラルの基数または値に影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Integers</seg>
      </tuv>
      <tuv lang="ja">
        <seg>整数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Integers are checked for overflow.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>整数は、オーバーフローを確認される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Integers are either signed (positive, zero, or negative) or unsigned (positive or zero).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>整数は、符号つき（正、ゼロ、または負）または符号なし（正またはゼロ）のどちらかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Interface Builder attributes are declaration attributes used by Interface Builder to synchronize with Xcode.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>いくつかのインターフェイスビルダー属性は、Xcodeと同期するためにインターフェイスビルダーによって使用される宣言属性です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Interval Matching</seg>
      </tuv>
      <tuv lang="ja">
        <seg>区間マッチング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It adds a director property on top of the base MediaItem class, with a corresponding initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、対応するイニシャライザを使って、基盤クラスMediaItemの上にdirectorプロパティを加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It also can’t transfer control into a case block whose pattern contains value binding patterns.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それはまた、パターンが値束縛パターンを含むケース節ブロックに制御を移すことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It also defines a computed property called description, which uses the values stored in rank and suit to build a description of the name and value of the card.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それはまた、descriptionと呼ばれる計算プロパティを定義します、それは、rankとsuitに保管される値を使って、カードの名前と説明の値を作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It also defines an array of integers, ready to be converted into strings.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それはまた、文字列に変換される準備ができている整数の配列も定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It also doesn’t change throw statements, compile-time diagnostic statements, or closures that contain a return statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それはまた、throw文、コンパイル時診断文、またはreturn文を含むクロージャを変更しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It also means you can be confident about the type of values you will retrieve from a collection.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それはまた、あなたがコレクションから取り出す値の型をあなたが確信できることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It also offers two methods—distribute(coins:) and receive(coins:)—to handle the distribution and collection of coins.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それはまた、２つのメソッド ― distribute(coins:)とreceive(coins:)— ― を提供して、コインの配布と回収を取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It also provides a method called complete(level:), which is called whenever a player completes a particular level.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それはまたcomplete(level:)と呼ばれるメソッドを提供します、それは、プレーヤーが特定のレベルを完了するときはいつでも呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It also tracks the current level for an individual player.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それはまた、個々のプレーヤーのために現在のレベルを追跡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It appends a colon and a line break, and uses this as the start of its pretty text representation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それはコロンと改行を追加します、そしてそれのきれいなテキスト表示のスタートとして、これを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It assigns the value that was returned to photoNames.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、返された値をphotoNamesに代入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It behaves the same as an unowned reference does under ARC, except that an unowned optional reference can be nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは非所有参照がARCの下でするのと同じに振る舞います、非所有オプショナル参照がnilであることが可能である以外は。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It calculates the last digit of number by using the remainder operator (number % 10), and uses this digit to look up an appropriate string in the digitNames dictionary.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、numberの最後の桁を剰余演算子を使用することによって計算して（number % 10）、この桁をdigitNames辞書で適切な文字列を捜すために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It calls the listPhotos(inGallery:) function and suspends execution while it waits for that function to return.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それはlistPhotos(inGallery:)関数を呼び出します、そしてその関数が戻るのをそれが待つあいだ遂行を中断します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It calls the provided function with the values 3 and 5, and prints the result of 8.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、提供された関数を値3と5を使って呼び出して、結果の8を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It can accept member names using an argument of a type that conforms to the ExpressibleByStringLiteral [https://developer.apple.com/documentation/swift/expressiblebystringliteral] protocol—in most cases, String.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それはメンバー名を、ExpressibleByStringLiteral [https://developer.apple.com/documentation/swift/expressiblebystringliteral]プロトコルに準拠する型 — ほとんどの場合、String — の引数を使って受け入れ可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It can also be useful to define requirements for associated types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関連型のために要件を定義することは、また同様に役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It can also contain another conditional compilation block, or a combination of these expressions and blocks.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それはまた、別の条件コンパイルブロックを、またはこれらの式とブロックからなるある組み合わせを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It can also match a value with a range of values, by checking whether the value is contained within the range, as the following example shows.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それはまた、ある値をある範囲の値と照合することが、その値がその範囲に含まれるかどうかを調べることによって可能です、以下の例が示すように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It can be described as “a tuple of type (Int, String)”.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは型(Int, String)のタプルとして記述されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It can be read as “not a”, as seen in the following example:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、「aでない」のように読まれることができます、下記の例では見られるように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It can be useful to require a type to conform to multiple protocols at the same time.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある型に複数のプロトコルに一時に従うことを要求することは、役に立つことがありえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It can do this with a control transfer statement such as return, break, continue, or throw, or it can call a function or method that doesn’t return, such as fatalError(_:file:line:).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それはこれを制御移動文return、break、continue、またはthrowなどで行えます、またはそれは復帰しない関数やメソッド、例えばfatalError(_:file:line:)を呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It can sometimes be useful to find out whether two constants or variables refer to exactly the same instance of a class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２つの定数または変数が正確にあるクラスの同じインスタンスに言及するかどうかについて、探り出すことは時々役に立つことがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It can’t appear in the body of a defer statement, or in an autoclosure of synchronous function type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、defer文の本体の中で、または同期関数型の自動クロージャの中で現れることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It can’t be called in isolation without an existing instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、単独で既存のインスタンスなしで呼ばれることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It can’t be modified by a subclass.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、サブクラスによって修正されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It can’t call any other initializers of the same class, and if the class has a superclass, it must call one of the superclass’s designated initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは同じクラスの他のどのイニシャライザも呼ぶことができません、そしてそのクラスがスーパークラスを持つならば、それはスーパークラスの指定イニシャライザのうちの１つを呼ばなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It can’t contain three unescaped double quotation marks next to each other.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、お互いは別として３つのエスケープされない二重引用符を含むことが出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It combines the components in that block into a Line.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、そのブロックの中の構成要素それらをひとつのLineへと結合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It compares the new value of totalSteps against the old value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、totalStepsの新しい値をその古い値と比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It consists of a period (.) between the item and the identifier of its member.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、その項目とそれのメンバーの識別子の間のピリオド（.）から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It delegates across to a designated initializer from the same class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、横の同じクラスの指定イニシャライザに向かって委任します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It does this by capturing a reference to runningTotal and amount from the surrounding function and using them within its own function body.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、それを囲んでいる関数からrunningTotalとamountへの参照を捕獲して、それらをそれ自身の関数本文内で使うことによってこれを行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It does this by implementing the optional fixedIncrement property requirement:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、オプショナルのfixedIncrementプロパティ要件を実装することによってこれをします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It doesn’t make sense for volume to be settable, because it would be ambiguous as to which values of width, height, and depth should be used for a particular volume value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>volumeが設定可能であることは意味をなしません、なぜなら特定のvolume値に対してwidth、height、そしてdepthにどの値が使われなければならないかはあいまいだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It doesn’t matter that "zebra" isn’t less than "apple", because the comparison is already determined by the tuples’ first elements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>"zebra"が"apple"より少ないことは問題ではありません、この比較はすでにタプルの最初の要素によって決定されているからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It doesn’t matter what that function’s implementation actually does—it matters only that the function is of the correct type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その関数の実装が実際に何をするかは、重要ではありません ― ただ関数が正しい型であるのが重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It doesn’t take any arguments, and when it’s called, it returns the value of the expression that’s wrapped inside of it.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、全く引数を取りません、そしてそれが呼ばれる時、その内部に包み込まれた式の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It doubles the x and y values of a Vector2D instance, by adding the vector to itself with the addition assignment operator defined earlier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それはVector2Dインスタンスのxとy値を、そのベクトルをそれ自体へと以前に定義される加算代入演算子を使って加えることによって２倍にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It enables you to represent almost any character from any language in a standardized form, and to read and write those characters to and from an external source such as a text file or web page.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、あなたにほとんどどんな文字でもどんな言語のものでも標準化された方式で表わすこと、そしてそれらの文字を、テキスト・ファイルやウェブ・ページのような外部のソースへ書き込んだり、それらから読み込んだりすることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It evaluates an addition or multiplication by evaluating the expression on the left-hand side, evaluating the expression on the right-hand side, and then adding them or multiplying them.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは加算や乗算を、左手側の式を評価し、右手側の式を評価して、それからそれらを加算や乗算することで評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It executes a set of statements only if that condition is true.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、その条件がtrueの場合にだけ、あるひとまとめにした文を実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It explicitly converts the count from Int to Double to be able to do floating-point division.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、明示的に総数をIntからDoubleへ変換して、浮動小数点除算ができるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It has already been initialized with the value contained within the optional, and so you don’t use the ! suffix to access its value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、すでにオプショナルの内部に含まれる値で初期化されています、それであなたはそれの値にアクセスするために!接尾辞を使いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It has one of the following forms:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、以下の書式のうちの１つを持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It has the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It has the following forms:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、以下の各形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It illustrates how the designated initializers in this hierarchy act as “funnel” points for class initialization, simplifying the interrelationships among classes in the chain:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、この階層の中の指定イニシャライザが、どのようにクラス初期化のために「漏斗」地点の働きをして、この連鎖におけるクラス間の相互関係を単純化しているかを図示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It introduces an Int property called quantity (in addition to the name property it inherits from Food) and defines two initializers for creating RecipeIngredient instances:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、quantityと呼ばれるIntプロパティ（加えてそれがFoodから受け継ぐnameプロパティ）を導入して、そしてRecipeIngredientインスタンスをつくるために２つのイニシャライザを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It isn’t appropriate to set threeTimesTable[someIndex] to a new value, and so the subscript for TimesTable is defined as a read-only subscript.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>threeTimesTable[someIndex]を新しい値に設定することは適切ではありません、なのでTimesTableのための添え字は、読み出し専用の添え字として定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It isn’t possible to overload the default assignment operator (=).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>もとからある代入演算子（=）をオーバーロードすることは不可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It isn’t strictly necessary to use the gameLoop label when calling continue gameLoop to jump to the next iteration of the loop.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ループの次の繰り返しへジャンプするためにcontinue gameLoopを呼ぶとき、gameLoopラベルを使用することは厳密には必要ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It isn’t valid to write the following code, because the first case is empty:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初のケース節が空であるので、以下のコードを書くことは、有効ではありません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It iterates over the items in the container to add them up, and divides by the container’s count to compute the average.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、コンテナの中の項目すべてにわたって繰り返していき、それらを合計します、そしてコンテナの総数で除算することで平均を計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It lets you write the code that’s typically executed without wrapping it in an else block, and it lets you keep the code that handles a violated requirement next to the requirement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それはあなたにコードをそれが概ねelseブロックの内にそれを包み込むことなしに実行されるように書かせます、そしてそれはあなたにコードをある違反要件をその要件のすぐそばでに取り扱うようにしておかせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It makes for shorter, clearer initializers and enables you to infer the type of the property from its default value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、より短い、より明白なイニシャライザを作り、あなたにその省略時の値からプロパティの型を推論するのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It may seem an unusual way to represent negative numbers, but it has several advantages.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは負数を表す普通でない方法のようかもしれません、しかしそれはいくつかの利点を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It multiplies a starting value of 1 (that is, 3 to the power of 0) by 3, ten times, using a closed range that starts with 1 and ends with 10.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは開始値の1（すなわち、3の0乗）に3を掛けることを、10回、1から始まり10で終わる完結範囲を使って行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It must be possible to access a count of the items in the container through a count property that returns an Int value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コンテナの中の項目の総数にアクセスすることがInt値を返すcountプロパティを通して可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It must be possible to add a new item to the container with an append(_:) method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>新しい項目をコンテナに加えることがappend(_:)メソッドで可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It must be possible to retrieve each item in the container with a subscript that takes an Int index value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コンテナの中の各項目を取り出すことがIntインデックス値をとる添え字で可能でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It provides a gettable dice property and a play() method in order to conform to the protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、プロトコルに従うために取得可能なdiceプロパティとplay()メソッドを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It reserves the flexibility to return values of multiple types:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは複数の型の値を返す柔軟性を確保します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It resets a numberOfTurns property to zero when the game starts, increments it each time a new turn begins, and prints out the total number of turns once the game has ended.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、ゲームが始まるときnumberOfTurnsプロパティをゼロに再設定します、新しいターンが開始するときそれぞれそれを増加させます、そしてひとたびゲームが終わってしまったならばターンの総数を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It returns true if the expression can be cast to the specified type; otherwise, it returns false.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、式が指定された型へキャストできるならばtrueを返します；そうでなければfalseを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It returns a new number whose bits are set to 1 only if the bits were equal to 1 in both input numbers:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それはある新しい数を返します、それのビットは両方の入力数においてビットが1と等しかった場合にだけ1に設定されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It returns an integer value to indicate the actual number of coins that were provided.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、提供されたコインの実際の数を示す整数値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It returns either the enumeration case matching the raw value or nil if there’s no matching Rank.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、その生の値に合致する列挙ケース節、または合致するRankがないならばnilのどちらかを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It says “I am done with the current loop iteration” without leaving the loop altogether.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、そのループをすっかり止めてしまわずに「私は、現在のループ繰り返しを終えた」と言います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It starts by calculating an appropriate origin point based on a center point and a size value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、center地点とsize値に基づいて適切な原点を計算することによって始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It starts with an initial value of 0.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、初期値の0から始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It states that it adopts the FullyNamed protocol as part of the first line of its definition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、その定義の最初の行の部分でそれがFullyNamedプロトコルを採用すると述べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It then calls (or delegates) to the init(origin:size:) initializer, which stores the new origin and size values in the appropriate properties:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、それからinit(origin:size:)イニシャライザに呼び出し（または委任）をします、それは、新しい原点とサイズ値を適切なプロパティに格納します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It then calls a designated initializer on its superclass to continue the initialization up the chain.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それはそれから、連鎖を上って初期化を続けるために、そのスーパークラス上で指定イニシャライザを呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It then continues to repeat the loop until the condition is false.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それはそれから、条件がfalseになるまでループを繰り返し続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It then declares a variable called cinema and sets it to the current value of hd.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、それからcinemaと呼ばれる変数を宣言して、それをhdの現在の値に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It then executes an appropriate block of code, based on the first pattern that matches successfully.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それはそれから、うまく合う最初のパターンに基づいて、適切なコードのブロックを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It then iterates through the array of board squares, and appends a geometric shape to represent the contents of each square:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、それからボードの正方形の配列の端から端まで繰り返して、ある幾何学形を各正方形の内容を表わすために追加します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It then uses the fallthrough keyword to “fall into” the default case as well.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それはそれからfallthroughキーワードを使って、defaultケース節にもまた「落ちていく」ようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It updates the measurements array first.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それはmeasurements配列を最初に更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It uses an instance property called currentLevel to track the level that a player is currently playing.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それはcurrentLevelと呼ばれるインスタンスプロパティをプレーヤーが現在プレイしているレベルを追跡するために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It uses special values for jack, queen, king, and ace.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、jack、queen、king、そしてaceのために特別な値を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It uses these methods to keep track of the number of turns a game has taken.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、あるゲームがとったターンの数の情報を得続けるためにこれらのメソッドを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It would be much more useful to define a generic Stack structure, that can manage a stack of any type of value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それをもっと役に立つようにするには、総称体Stack構造体を定義することです、それはあらゆる型の値のスタックを管理することができるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Iterating Over a Dictionary</seg>
      </tuv>
      <tuv lang="ja">
        <seg>辞書じゅうを繰り返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Iterating Over a Set</seg>
      </tuv>
      <tuv lang="ja">
        <seg>集合全体を繰り返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Iterating Over an Array</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列じゅうを繰り返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Iterating over Enumeration Cases</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙ケース節の全てにわたって反復する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Its combination of safety and speed make Swift an excellent choice for everything from “Hello, world!” to an entire operating system.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その安全とスピードの連携は、スウィフトを「Hello, world!」からオペレーティングシステム全体までのあらゆることに対する素晴らしい選択とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Its conciseness can lead to hard-to-read code if overused.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その簡潔さは、濫用されるならば、読み辛いコードに至る可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Its keys are of type Int, and its values are of type String.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのキーはInt型です、そしてその値はString型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Its parameters are then implicitly named $ followed by their position: $0, $1, $2, and so on.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのパラメータは、それから暗黙のうちに$の後にそれらの位置が続く名前：$0、$1、$2、などをつけられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Its size is based on a constant called finalSquare, which is used to initialize the array and also to check for a win condition later in the example.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その大きさはfinalSquareと呼ばれる定数に基づきます、そして、それがこの配列を初期化して、さらにこの例の後半で勝利したかどうか調べるために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s a compile-time error to override a method without the override modifier or to use the override modifier on a method that doesn’t override a superclass method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>override宣言修飾子なしでメソッドをオーバーライドするか、スーパークラスメソッドをオーバーライドしないメソッドでoverride宣言修飾子を使用することは、コンパイル時エラーです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s a compile-time error to write a structure or enumeration definition that tries to adopt SomeClassOnlyProtocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>SomeClassOnlyProtocolを採用しようと試みる構造体や列挙定義を書くことは、コンパイル時エラーになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s a safe, fast, and interactive programming language that combines the best in modern language thinking with wisdom from the wider Apple engineering culture and the diverse contributions from its open-source community.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、安全で、高速な、そしてインタラクティブなプログラミング言語であり、現代の言語の最良の思想を、幅広いアップル工学文化由来の知的資産およびそのオープンソース・コミュニティからの多様な貢献と結合するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s a shortcut for evaluating one of two expressions based on whether question is true or false.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、questionが真実であるか間違っているかに基づいて、２つの式のうちの１つを評価することに対する近道です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s a single-player game, but can store information for multiple players on a single device.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それはシングルプレーヤーのゲームです、しかし１つの装置上で複数のプレーヤーのために情報を蓄えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s always better to be specific about the types you expect to work with in your code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>いつでもより望ましいのは、あなたのコードで扱うことをあなたが期待する型について明確にすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s always possible to infer the parameter types and return type when passing a closure to a function or method as an inline closure expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャを関数やメソッドに行内クロージャ式として渡すとき、パラメータ型と戻り型を推論することは常に可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s an industrial-quality programming language that’s as expressive and enjoyable as a scripting language.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、スクリプティング言語と同じくらい表現豊かで楽しい、工業品質のプログラミング言語です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s applied to a class to indicate that the class can’t be subclassed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それはクラスに適用されて、そのクラスがサブクラスを作られることができないのを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s applied to a property, method, or subscript of a class to indicate that a class member can’t be overridden in any subclass.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それはプロパティ、メソッド、またはクラスの添え字に適用されて、そのクラスメンバーがあらゆるサブクラスにおいてオーバーライドされることができないのを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s automatically assigned a default value of nil, meaning “no string yet”, when a new instance of SurveyQuestion is initialized.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、SurveyQuestionの新しいインスタンスは初期化される時に、「まだ無い文字列」を意味する、省略時の値のnilを自動的に代入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s common to call functions that take autoclosures, but it’s not common to implement that kind of function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>自動クロージャを取る関数を呼び出すのは普通です、しかしそのような関数を実装するのは一般的ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s convenient for an inventory tracking system to store UPC barcodes as a tuple of four integers, and QR code barcodes as a string of any length.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>UPCバーコードを４つの整数のタプルとして、そしてQRコード・バーコードを任意の長さの文字列として格納できるのは、在庫追跡システムにとって便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s either an Int, or it’s nothing at all.)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それはひとつのInt、またはそれは全く何も無いかのどちらかです。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s even valid for a subclass member to call a superclass member that has lower access permissions than the subclass member, as long as the call to the superclass’s member takes place within an allowed access level context (that is, within the same source file as the superclass for a file-private member call, or within the same module as the superclass for an internal member call):</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スーパークラスのメンバーへの呼び出しがある許されるアクセス水準文脈内で（すなわち、ファイル外非公開メンバー呼び出しのためのスーパークラスと同じソースファイル内で、または内部メンバー呼び出しのためのスーパークラスと同じモジュール内で）起こる限り、サブクラスメンバーより低いアクセス許可を持つスーパークラスメンバーを呼び出すことは、サブクラスメンバーにとってさえ有効です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s explained in detail below in Capturing Values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、下で詳細に値を捕獲する（キャプチャする）の中で説明されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s good practice to create immutable collections in all cases where the collection doesn’t need to change.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのコレクションを変更する必要がないすべての場合において不変のコレクションを作成することは良い習慣です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s implicitly declared simply by its inclusion in the loop declaration, without the need for a let declaration keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それはループ宣言にひっくるめることによって、let宣言キーワードの必要なしで、簡易に暗黙のうちに宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s important to consider each operator’s precedence and associativity when working out the order in which a compound expression will be calculated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複合の式が計算される順番を解決するとき、各演算子の優先順位と結合性を考慮することは、重要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s more useful, and considerably more flexible, to write a single function that swaps two values of any type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>さらに役に立ち、そしてよりずっと柔軟であるのは、あらゆる型の２つの値を交換できるただ１つの関数を書くことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s not of type Dice, or DiceGame, or Hamster, even if the actual instance behind the scenes is of one of those types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは型Dice、またはDiceGame、またはHamsterではありません、たとえ舞台裏の実際のインスタンスがそれらの型のうちの１つであるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s not valid to mark the definition of someFunction() with the public or internal modifiers, or to use the default setting of internal, because public or internal users of the function might not have appropriate access to the private class used in the function’s return type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>someFunction()の定義がpublicまたはinternalを使って印されること、または省略時設定の内部を使うことは有効ではありません、なぜなら、この関数の公開や内部のユーザーは適切なアクセスを関数の戻り型の中で使われる非公開クラスに対して持たないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s not valid to write a public property with a private type, for example.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例えば、非公開の型で公開のプロパティを書くことは、有効ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s now possible to iterate over the items in the array, and print each item’s textual description:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>現在この配列の項目の上に繰り返して、各項目のもつ説明テキストを出力することが可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s often useful to execute different pieces of code based on certain conditions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>特定の状況に基づいて異なるコード小片を実行することは、しばしば役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s possible that the dice roll may have moved the player beyond square 25, in which case the game is over.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>さいころを振ることが正方形25を越えてプレーヤーを動かす可能性はあり得ます、その場合にはゲームは終了です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s possible to make a drawing with these types by calling their initializers:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある描画を３つの型でそれらのイニシャライザを呼び出すことによって作ることは可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s rare that you need to write type annotations in practice.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが型注釈を書く必要があることは実際問題として、まれです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s said to be half-open because it contains its first value, but not its final value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それが半開と言われるのは、それがその最初の値を含むけれども、その最後の値は含まないためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s set to be interlaced, its name is set to "1080i", and its frame rate is set to 25.0 frames per second.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それはインターレースされるように設定されます、それの名前は"1080i"に設定されます、そしてそれのフレームレートは25.0フレーム毎秒に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s sometimes necessary for a method to modify (or mutate) the instance it belongs to.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メソッドがそれが属しているインスタンスを修正する（または変化させる）ことは、時々必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s sometimes useful to define a class, structure, or enumeration for which initialization can fail.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それに対するイニシャライザが失敗できるクラス、構造体、または列挙を定義することは時として便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s sometimes useful to include parentheses when they’re not strictly needed, to make the intention of a complex expression easier to read.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複雑な式をより簡単に読めるようにするため、丸括弧をそれらが厳密には必要とされないとき含むことは、時々役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s the frameRate property of the underlying VideoMode that’s changed, not the values of the constant references to that VideoMode.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、根底にあるVideoModeのframeRateプロパティです、それは変更可能です、そのVideoModeに対する参照をもつこれら定数の値ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s then incremented by 1 using the overflow addition operator (&amp;+).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、それからオーバフロー加算演算子（&amp;+）を使って1だけ増やされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It’s therefore appropriate to write this initializer as init(_ celsius: Double) so that it can be called by providing an unnamed Double value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>したがって、適切なのはこのイニシャライザをinit(_ celsius: Double)のように書くことであり、それによってそれは名前のないDouble値を提供することで呼び出されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Just before this happens, its deinitializer is called automatically, and its coins are returned to the bank.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これが起こる直前に、そのデイニシャライザは自動的に呼ばれます、そしてそのコインは胴元に返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Just like functions and methods, initializers can throw or rethrow errors.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数やメソッドのように、イニシャライザはエラーをスローまたは再スローできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Just like when you include a value on both sides, the final value isn’t part of the range.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ちょうどあなたが両方の側で１つの値を含める場合のように、最後の値はその範囲の一部分ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Keeping the sign bit the same during this shift means that negative integers remain negative as their value moves closer to zero.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このシフトの間に符号ビットを同じに保つことは、それの値がゼロの近くに動くとき、負整数が負のままであることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Key paths can’t refer to isolated members of an actor.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>キーバスは、あるアクターの隔離されたメンバーそれらを参照できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Key-Path Expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>キーパス式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Key-Path String Expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>キーパス文字列式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Keywords and Punctuation</seg>
      </tuv>
      <tuv lang="ja">
        <seg>キーワードと句読点</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Keywords other than inout, var, and let can be used as parameter names in a function declaration or function call without being escaped with backticks.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>inout、var、そしてlet以外のキーワードは、パラメータ名として関数宣言または関数呼び出しにおいてバッククォートでエスケープされることなく使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Keywords reserved in particular contexts: associativity, convenience, didSet, dynamic, final, get, indirect, infix, lazy, left, mutating, none, nonmutating, optional, override, postfix, precedence, prefix, Protocol, required, right, set, some, Type, unowned, weak, and willSet.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>特定の前後関係において予約されるキーワード：associativity, convenience, didSet, dynamic, final, get, indirect, infix, lazy, left, mutating, none, nonmutating, optional, override, postfix, precedence, prefix, Protocol, required, right, set, some, Type, unowned, weak, そして willSet。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Keywords that begin with a number sign (#): #available, #colorLiteral, #column, #dsohandle, #elseif, #else, #endif, #error, #fileID, #fileLiteral, #filePath, #file, #function, #if, #imageLiteral, #keyPath, #line, #selector, #sourceLocation, and #warning.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>シャープ記号（#）で始まるキーワード：#available, #colorLiteral, #column, #dsohandle, #elseif, #else, #endif, #error, #fileID, #fileLiteral, #filePath, #file, #function, #if, #imageLiteral, #keyPath, #line, #selector, #sourceLocation, そして #warning。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Keywords used in declarations: associatedtype, class, deinit, enum, extension, fileprivate, func, import, init, inout, internal, let, open, operator, private, precedencegroup, protocol, public, rethrows, static, struct, subscript, typealias, and var.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>宣言において使用されるキーワード：associatedtype, class, deinit, enum, extension, fileprivate, func, import, init, inout, internal, let, open, operator, private, precedencegroup, protocol, public, rethrows, static, struct, subscript, typealias, そして var。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Keywords used in expressions and types: Any, as, catch, false, is, nil, rethrows, self, Self, super, throw, throws, true, and try.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>式と型において使用されるキーワード：Any, as, catch, false, is, nil, rethrows, self, Self, super, throw, throws, true, そして try。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Keywords used in patterns: _.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>パターンにおいて使用されるキーワード：_。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Keywords used in statements: break, case, catch, continue, default, defer, do, else, fallthrough, for, guard, if, in, repeat, return, throw, switch, where, and while.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文において使用されるキーワード：break, case, catch, continue, default, defer, do, else, fallthrough, for, guard, if, in, repeat, return, throw, switch, where, そして while。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Labeled</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ラベル付き</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Labeled Statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ラベルをつけられた文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Labeled Statements</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ラベルをつけられた文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Labeled or unlabeled</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ラベル付きまたはラベルなし</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Language Guide</seg>
      </tuv>
      <tuv lang="ja">
        <seg>言語ガイド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Language Reference</seg>
      </tuv>
      <tuv lang="ja">
        <seg>言語リファレンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Large integer literal initialization expressions are inferred to be of the correct integer type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>大きな整数リテラル初期化式は、正しい整数型のものであるように推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lazy Stored Properties</seg>
      </tuv>
      <tuv lang="ja">
        <seg>遅延格納プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lazy properties are also useful when the initial value for a property requires complex or computationally expensive setup that shouldn’t be performed unless or until it’s needed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>遅延プロパティはまた、プロパティのための最初の値が、それが必要でないなら、あるいは必要になるまで、実行されるべきではない複雑なまたはコンピュータ処理的に高くつく準備を必要とするときに役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lazy properties are useful when the initial value for a property is dependent on outside factors whose values aren’t known until after an instance’s initialization is complete.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>遅延プロパティが役に立つのは、プロパティのための最初の値がインスタンスの初期化が終了する後まで値が知られない外部の要因に依存しているときです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Less than (a &lt; b)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>より小さい、未満 (a &lt; b)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Less than or equal to (a &lt;= b)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>より小さいか等しい、以下 (a &lt;= b)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lexical Structure</seg>
      </tuv>
      <tuv lang="ja">
        <seg>語彙の構造</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Like C, Swift has only one ternary operator, the ternary conditional operator (a ? b : c).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Cのように、スウィフトはただ１つの三項演算子、三項条件演算子（a ? b : c）だけをもちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Like C, Swift provides compound assignment operators that combine assignment (=) with another operation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Cのように、スウィフトは複合代入演算子を提供します、それは、代入（=）を別の演算と組み合わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Like C, Swift uses variables to store and refer to values by an identifying name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Cのように、スウィフトはひとつの識別名によっていろいろな値を保管したり引用したりするために、変数を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Like a switch statement, the compiler attempts to infer whether catch clauses are exhaustive.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>switch文のように、コンパイラはcatch節が網羅的であるか推論を試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Like a function declaration, a closure contains statements, and it captures constants and variables from its enclosing scope.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数宣言の様に、クロージャはいくつかの文を含みます、そしてそれは、定数と変数をそれの取り囲むスコープからキャプチャします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Like a function, an initializer can be used as a value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数のように、イニシャライザは値として使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Like a weak reference, an unowned reference doesn’t keep a strong hold on the instance it refers to.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>弱い参照のように、非所有参照は、それが言及するインスタンスに対する強い支配力を保ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Like a weak reference, the type of the property or value must be a class type; unlike a weak reference, the type is non-optional.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>弱い参照のように、プロパティや値の型はクラス型でなければなりません；弱い参照と違って、その型は非オプショナルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Like all types in Swift, these integer types have capitalized names.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトにおける全ての型のように、これらの整数型は頭文字を使った名前を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Like classes and all other named types, enumerations can have methods associated with them.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスや全ての他の名前をつけられた型のように、列挙はそれと結びつけられるメソッドを持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Like classes, actors are reference types, so the comparison of value types and reference types in Classes Are Reference Types applies to actors as well as classes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスのように、アクターは参照型です、なのでクラスは参照型ですにおける値型と参照型の比較がクラスと同様にアクターに適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Like functions, subscripts can take a varying number of parameters and provide default values for their parameters, as discussed in Variadic Parameters and Default Parameter Values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数のように、添え字は可変数のパラメータを取りそしてそれらのパラメータに対して省略時の値を提供できます、可変長パラメータおよび省略時のパラメータ値で議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Like non-optional unowned references, you’re responsible for ensuring that nextCourse always refers to a course that hasn’t been deallocated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非オプショナル非所有参照のように、あなたはnextCourseが常にあるデアロケートされていない課程を参照することを確実にする責任があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Like other types in Swift, their names (such as CompassPoint and Planet) start with a capital letter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトにおける他の型のように、それらの名前（例えばCompassPointおよびPlanet）は、大文字から始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Like strings, each substring has a region of memory where the characters that make up the substring are stored.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列のように、下位文字列それぞれはメモリのある領域を持ち、そこで下位文字列を作り上げる文字が格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Like structures but unlike classes, enumerations are value types; instances of an enumeration are copied when assigned to variables or constants, or when passed as arguments to a function call.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体のように、しかしクラスとは違い、列挙は値型です；列挙のインスタンスは、変数や定数に代入されるとき、または引数として関数呼び出しに渡されるときにコピーされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Like the public access-level modifier, this attribute exposes the declaration as part of the module’s public interface.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>publicアクセス水準修飾子のように、この属性は宣言をモジュールの公開インターフェイスの一部として露出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Like the remove(at:) method, removeLast() returns the removed item:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>removeAtIndex(_:)メソッドのように、remove(at:)は取り除かれた項目を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Like the Logical AND operator above, the Logical OR operator uses short-circuit evaluation to consider its expressions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の論理積演算子のように、論理和演算子はその式を考慮するために短絡評価を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Like the body of an if statement, each case is a separate branch of code execution.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>if文の本文のように、各caseは別々の分岐のコード実行です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Like the subscript examples above, the updateValue(_:forKey:) method sets a value for a key if none exists, or updates the value if that key already exists.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の添え字の例のように、updateValue(_:forKey:)メソッドは、まったく何も存在しないならばあるキーに対して値を設定します、またはキーがすでに存在するならばその値を更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Like when you apply SmallNumber to a property, setting the value of myNumber to 10 is valid.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがSmallNumberに適用する時のように、myNumberの値を10に設定することは有効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Like when you call an asynchronous function or method, writing await indicates a possible suspension point.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが非同期関数やメソッドを呼び出すときのように、awaitを書くことは可能な中断地点を指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Likewise, because Void is a type alias for (), the function type (Void) -&gt; Void is the same as (()) -&gt; ()—a function that takes a single argument that’s an empty tuple.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同様に、Voidが()に対する型エイリアスであることから、関数型(Void) -&gt; Voidは(()) -&gt; () — ただ１つの引数を取りそれが空のタプルである関数、と同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Likewise, because the path from the root node to the second case is “second child” and then “first child”, that case becomes a nested call like buildEither(first: buildEither(second: ... )).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同様に、ルートノードから２番目の事例への経路は “２番目の子” そしてそれゆえ “最初の子” であることから、その事例はある入れ子にされた呼び出しになります、buildEither(first: buildEither(second: ... ))のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Likewise, if any of the structure’s stored properties are file private, the initializer is file private.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同様に、構造体の持つ格納プロパティのいずれかがファイル外非公開ならば、イニシャライザはファイル外非公開です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Likewise, if you don’t specify a type for a floating-point literal, Swift infers that you want to create a Double:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同様に、あなたがある浮動小数点リテラルのために型を指定しないならば、スウィフトはあなたがDoubleをつくりたいと推測します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Likewise, if you made a subclass of Location that didn’t conform to the Named protocol, calling beginConcert(in:) with an instance of that type is also invalid.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同様に、あなたがLocationのサブクラスでNamedプロトコルに準拠しないものを作成したならば、beginConcert(in:)をその型のインスタンスで呼び出すことはまた無効です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Likewise, method and function declarations are written the same way.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>さらにまた、メソッドおよび関数の宣言も同じやり方で書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Likewise, nested branch statements become a single binary tree of calls to the buildEither methods.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同様に、入れ子にされた分岐文それらは、buildEitherメソッドへの呼び出しいくつかからなるある単一の二分木になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Likewise, the willSet clause is optional when you provide a didSet clause.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同様に、あなたがdidSet節を提供するとき、willSet節は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Likewise, the failable initializer for Product checks the name value, and the initializer process fails immediately if name is the empty string.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じように、Productのための失敗できるイニシャライザは、name値を確認して、nameが空の文字列ならば初期化処理は直ちに失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Likewise, type safety prevents you from accidentally passing an optional String to a piece of code that requires a non-optional String.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>さらに、型安全はあなたがうっかりしてオプショナルStringを、非オプショナルStringを要求するコード部分に渡すことを防ぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Likewise, you can use SuperClass &amp; ProtocolA instead of declaring a new protocol that’s a subclass of SuperClass and conforms to ProtocolA.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同様に、あなたはSuperClass &amp; ProtocolAを使うことが、SuperClassのサブクラスでProtocolAに準拠する新しいプロトコルを宣言する代わりに行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Line Control Statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>行制御文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Line breaks in a multiline string literal are normalized to use the line feed character.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複数行文字列リテラルの中のラインブレークは、正規化されて、ラインフィード文字を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Line feed (\n)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ラインフィード「字送り文字」（\n）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Linking Multiple Levels of Chaining</seg>
      </tuv>
      <tuv lang="ja">
        <seg>連鎖の複数の階層を結ぶ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Literal</seg>
      </tuv>
      <tuv lang="ja">
        <seg>リテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Literal Expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>リテラル式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Literal words and punctuation are indicated by boldface constant width text and appear only on the right-hand side of a grammar production rule.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>リテラルの単語と句読点は、太字体の等幅テキストによって示されて、文法導出規則の右側だけに現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Literals</seg>
      </tuv>
      <tuv lang="ja">
        <seg>様々なリテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Local constants and variables are never computed lazily.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ローカルな定数と変数は、決して遅延して計算されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Local variables are variables that are defined within a function, method, or closure context.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ローカル変数は、関数、メソッド、またはクロージャの文脈の範囲内で定義される変数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Logical AND (a &amp;&amp; b)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>論理積（a &amp;&amp; b）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Logical AND Operator</seg>
      </tuv>
      <tuv lang="ja">
        <seg>論理積演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Logical NOT (!a)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>論理否定（!a）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Logical NOT Operator</seg>
      </tuv>
      <tuv lang="ja">
        <seg>論理否定演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Logical OR (a || b)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>論理和（a || b）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Logical OR Operator</seg>
      </tuv>
      <tuv lang="ja">
        <seg>論理和演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Logical Operators</seg>
      </tuv>
      <tuv lang="ja">
        <seg>論理演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Loop Statements</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ループ文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Loop statements allow a block of code to be executed repeatedly, branch statements allow a certain block of code to be executed only when certain conditions are met, and control transfer statements provide a way to alter the order in which code is executed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ループ文はコードの１ブロックが繰り返して実行されるようにします、分岐文はコードの特定のブロックを特定の条件が満たされるときにだけ実行されるようにします、そして制御移動文はコードが実行される順番を変える方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Loop statements allow a block of code to be executed repeatedly, depending on the conditions specified in the loop.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ループ文は、ループにおいて指定される条件に従って、コードの１ブロックを繰り返して実行するようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Make an existing type conform to a protocol</seg>
      </tuv>
      <tuv lang="ja">
        <seg>既存の型をプロトコルに準拠させる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Make another subclass of NamedShape called Circle that takes a radius and a name as arguments to its initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>NamedShapeの別のサブクラス、Circleと呼ばれるものを作ってください、それはそのイニシャライザに対する引数として半径と名前をとるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Making them both asynchronous by writing async before the return arrow lets the rest of the app’s code keep running while this code waits for the picture to be ready.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらを両方ともasyncを戻り矢印の前に書くことによって非同期にすることは、アプリのもつコードの残りに動作を続けさせます、一方でこのコードは画像が利用可能になるのを待ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Marking a class as open explicitly indicates that you’ve considered the impact of code from other modules using that class as a superclass, and that you’ve designed your class’s code accordingly.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるクラスを明示的に開放とすることが指し示すのは、あなたが、そのクラスをスーパークラスとして使っている、他のモジュール由来のコードの影響を考慮に入れるということです、そしてあなたがあなたのクラスのコードをそれに従って設計するということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Marking a structure or enumeration as frozen gives up this flexibility to gain performance: Future versions of the library can make only limited changes to the type, but the compiler can make additional optimizations in code that interacts with the type’s members.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体または列挙を凍結されると印することは、この柔軟性を諦めることで性能を手に入れます：ライブラリの将来のバージョンは、制限された変更だけしか型に対して出来ません、しかしコンパイラは追加的な最適化を、型のもつメンバーと相互作用するコードにすることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Marking the protocol as class-only lets the SnakesAndLadders class later in this chapter declare that its delegate must use a weak reference.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルをクラス専用とすることは、SnakesAndLaddersクラスに後でこの章においてその委任先が弱い参照を使わなければならないことを宣言させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Matched values in a switch case can be bound to temporary constants or variables for use within the case’s body, and complex matching conditions can be expressed with a where clause for each case.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるswitchケース節においてマッチされた値は、そのケース節内の本文で使われるために一時的な定数や変数に結び付けられることができます、そして複雑なマッチ条件が各ケース節に対してwhere節を使って表わされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Matching Enumeration Values with a Switch Statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙値をスイッチ文で照合する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Members of a superclass that have this modifier and don’t have the final modifier can be overridden by subclasses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この修飾子を持つそしてfinal修飾子を持たないスーパークラスのメンバーは、サブクラスによってオーバーライドされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Members of an actor can be marked with the @objc attribute only if they are nonisolated or asynchronous.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>アクターのメンバーそれらが、@objc属性で印されることが可能なのは、それらが隔離されないまたは非同期である場合だけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Memberwise Initializers for Structure Types</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体型のためのメンバー関連イニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Memory Safety</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メモリ安全</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Memory for a new instance of that class is allocated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのクラスの新しいインスタンスに対するメモリが割り当てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Memory is managed automatically.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メモリは、自動的に管理される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Memory safety is the desired guarantee, but exclusive access is a stricter requirement than memory safety—which means some code preserves memory safety, even though it violates exclusive access to memory.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メモリ安全は望まれる保証です、しかし排他アクセスはメモリ安全より厳格な要件です — それが意味するのは、あるコードはたとえそれがメモリに対する排他アクセスを破るとしてもメモリ安全を守るということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Metatype Type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メタタイプ型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Method Requirements</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メソッド要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Methods</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Methods associated with a type rather than an instance of a type must be marked with the static declaration modifier for enumerations and structures, or with either the static or class declaration modifier for classes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある型のインスタンスとではなく、ある型と結び付けられるメソッドは、列挙と構造体ではstatic宣言修飾子で、またクラスではstaticまたはclassどちらかの宣言修飾子で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Methods on a subclass that override the superclass’s implementation are marked with override—overriding a method by accident, without override, is detected by the compiler as an error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるサブクラスのメソッドで、そのスーパークラスの実装をオーバーライド（再定義）するものは、overrideで印を付けられます ― overrideなしで、偶然にメソッドをオーバーライドすることは、コンパイラによってエラーとして検出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Methods on an enumeration or a structure that modify self must be marked with the mutating declaration modifier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙または構造体でのselfを修正するメソッドは、mutating宣言修飾子で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Methods that override a superclass method must be marked with the override declaration modifier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スーパークラスのメソッドをオーバーライドするメソッドは、override宣言修飾子で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Methods with Special Names</seg>
      </tuv>
      <tuv lang="ja">
        <seg>特殊名を持つメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Methods, properties, or subscripts that you add to a class in an extension can also be marked as final within the extension’s definition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがある拡張においてクラスに加えるメソッド、プロパティ、または添え字は、また、拡張の定義内で最終版として印されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Modify the anyCommonElements(_:_:) function to make a function that returns an array of the elements that any two sequences have in common.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>anyCommonElements(_:_:)関数を修正して、何らかの２つのシーケンスが共通に持つ要素それらからなるある配列を返す関数を作ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Modifying Value Types from Within Instance Methods</seg>
      </tuv>
      <tuv lang="ja">
        <seg>値型をインスタンスメソッド内から修正する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Modules and Source Files</seg>
      </tuv>
      <tuv lang="ja">
        <seg>モジュールとソースファイル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>More generally, any unqualified method and property names that you use within the body of a type method will refer to other type-level methods and properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>より一般的に言えば、あなたがある型メソッドの本文内で使うどんな非修飾のメソッドやプロパティ名でも、他の型レベルのメソッドやプロパティに言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Moreover, IntStack specifies that for this implementation of Container, the appropriate Item to use is a type of Int.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>さらに、IntStackは、Containerのこの実施のために、適切なItemとして使用するのはInt型であることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Most code should use the objc attribute instead, to expose only the declarations that are needed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ほとんどのコードは、objc属性を代わりに使って、必要とされる宣言だけを露出するべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Most memory access is instantaneous.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ほとんどのメモリアクセスは即時的です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Most of the time, a type identifier directly refers to a named type with the same name as the identifier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ほとんどの場合、型識別子は、名前付きの型に、その識別子と同じ名前で直接に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Moving those requirements to the extensions’ generic where clauses makes the methods available in the same situations, but requires one extension per requirement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらの要件を拡張のもつ総称体where節に移動することは、メソッドそれらを同じ状況で利用可能にします、しかし要件ごとに１つの拡張を要します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Multiline String Literals</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複数行文字列リテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Multiline comments begin with /* and end with */.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複数行コメントは/*で始まり*/で終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Multiline comments start with a forward-slash followed by an asterisk (/*) and end with an asterisk followed by a forward-slash (*/):</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複数行コメントは、スラッシュに続く星印（/*）で始まり、星印に続くスラッシュ（*/）で終わります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Multiline string literals that you create using extended delimiters have the same indentation requirements as regular multiline string literals.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが拡張区切り記号を使って作成する複数行文字列リテラルは、通常の複数行文字列リテラルと同じ字下げ要件を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Multiple accesses to a location in memory at the same time can produce unpredictable or inconsistent behavior.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メモリの同じ位置への同時での複数のアクセスは、予期されないまたは一貫性のない挙動を生じ得ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Multiple cases can appear on a single line, separated by commas:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複数のケース節は、コンマで区切られて、ただ１つの行に現れることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Multiple extensions on a concrete type can’t add conformance to the same protocol, even if the extensions’ requirements are mutually exclusive.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある具象型上の複数の拡張は、同じプロトコルに対して準拠を加えることはできません、たとえそれら拡張の持つ要件が相互に排他的であるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Multiple optional bindings can now appear in a single if statement as a comma-separated list of assignment expressions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複数のオプショナル束縛は、今では単一のif文においてコンマ区切りの代入式のリストとして現れることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Multiple protocols can be listed, and are separated by commas:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複数のプロトコルが、コンマで区切られて、リストされることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Multiple queries can be chained together, and the entire chain fails gracefully if any link in the chain is nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複数の問い合わせが一緒に鎖で繋げられることができます、そして連鎖の中のどれかの輪がnilならば、その連鎖全体がいさぎよく失敗します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Multiple switch cases that share the same body can be combined by writing several patterns after case, with a comma between each of the patterns.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じ本文を共有する複数のケース節は、caseの後にそれぞれのパターンを、それぞれのパターンの間のコンマとともに書くことによって結合されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Multiplication (*)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>乗算（*）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Mutability of Collections</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コレクションの可変性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Mutating Instance Methods</seg>
      </tuv>
      <tuv lang="ja">
        <seg>変更インスタンスメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Mutating Method Requirements</seg>
      </tuv>
      <tuv lang="ja">
        <seg>変更メソッド要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Mutating methods can assign an entirely new instance to the implicit self property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>変更メソッドは、まったく新しいインスタンスを暗黙のselfプロパティに代入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Mutating methods for enumerations can set the implicit self parameter to be a different case from the same enumeration:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙のための変更メソッドは、暗黙のselfパラメータを同じ列挙からの異なるケース節に設定することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Named types include classes, structures, enumerations, and protocols.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>名前付きの型は、クラス、構造体、列挙、そしてプロトコルを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Naming Constants and Variables</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数と変数に名をつける</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Naming Type Parameters</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型パラメータに名をつける</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Negative floating-point literals are expressed by prepending a minus sign (-) to a floating-point literal, as in -42.5.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>負の浮動小数点数は、浮動小数点リテラルに単項マイナス演算子（-）を前につけることによって表わされます、-42.5のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Negative integers literals are expressed by prepending a minus sign (-) to an integer literal, as in -42.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>負整数リテラルは、負符号（-）をリテラル整数の前に付けることによって表されます、-42のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Negative numbers, however, are stored differently.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>負の数は、しかし異なって格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Neither parameter is marked @escaping, so they’re both nonescaping as a result.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>どちらのものも@escapingと印されません、それでそれらは両方とも非脱出です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Neither type of formatting affects the underlying value of the literal:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>書式整形のどちらの種類も、もととなるリテラルの値に影響を及ぼしません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Nested Functions</seg>
      </tuv>
      <tuv lang="ja">
        <seg>入れ子にされた関数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Nested Types</seg>
      </tuv>
      <tuv lang="ja">
        <seg>入れ子にされた型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Nested Types in Action</seg>
      </tuv>
      <tuv lang="ja">
        <seg>入れ子にされた型の動作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Nested functions are closures that have a name and can capture values from their enclosing function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>入れ子にされた関数は、名前を持ち、それを囲んでいる関数から値を捕獲することができるクロージャです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Nested functions are hidden from the outside world by default, but can still be called and used by their enclosing function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>入れ子にされた関数は、初期状態では外界から隠されます、しかしそれにもかかわらず、それらを囲む関数によって呼び出されて使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Nested functions have access to variables that were declared in the outer function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>入れ子にされた関数は、外側の関数において宣言された変数に、アクセスをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Nested functions, as introduced in Nested Functions, are a convenient means of naming and defining self-contained blocks of code as part of a larger function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>入れ子にされた関数は、入れ子にされた関数の中で紹介されるように、より大きい関数の一部として、いろいろな完全独立のコードの塊を名前をつけて定義する便利な手段です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Nested multiline comments enable you to comment out large blocks of code quickly and easily, even if the code already contains multiline comments.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>入れ子にされた複数行コメントによって、たとえコードがすでに複数行コメントを含むとしても、あなたは速く簡単にコードの大きなブロックをコメントアウトすることが可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Nested types defined within a public type have an automatic access level of internal.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>公開型の内側で定義される入れ子にされた型は、自動的なアクセス水準として内部を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Nesting multiline comments is allowed, but the comment markers must be balanced.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複数行コメントが入れ子にされることは許されます、しかしコメント目印が釣り合っている必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Nevertheless, the return value always has the same underlying type of [T], so it follows the requirement that functions with opaque return types must return values of only a single type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それにもかかわらず、戻り値は常に同じ基礎をなす型の[T]を持ちます、それでそれは、不透明戻り型をもつ関数はもっぱら単一の型の値だけを返さなければならないという要件に従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>New document that describes Swift 1.0, Apple’s new programming language for building iOS and OS X apps.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>iOSおよびOS Xアプリ構築のためのAppleの新しいプログラミング言語、スウィフト 1.0を解説する新しい文書。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>New operators are declared at a global level using the operator keyword, and are marked with the prefix, infix or postfix modifiers:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>新しい演算子はoperatorキーワードを使ってグローバル水準で宣言されます、そしてprefix、infixまたはpostfix修飾子で印されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Next, tenEighty is assigned to a new constant, called alsoTenEighty, and the frame rate of alsoTenEighty is modified:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>次に、tenEightyは、新しい定数、alsoTenEightyと呼ばれるものに代入されます、そしてalsoTenEightyのフレームレートが修正されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Next, the width property of cinema is amended to be the width of the slightly wider 2K standard used for digital cinema projection (2048 pixels wide and 1080 pixels high):</seg>
      </tuv>
      <tuv lang="ja">
        <seg>次に、cinemaのwidthプロパティは、デジタル映画館投影のために使われるわずかにより広い2Kの標準の幅（2048ピクセル幅の広さで1080ピクセルの高さ）になるように改められます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Nil-Coalescing Operator</seg>
      </tuv>
      <tuv lang="ja">
        <seg>nil合体演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>No Implicit Fallthrough</seg>
      </tuv>
      <tuv lang="ja">
        <seg>知らずに突き抜けない（フォールスルーしない）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>No further code from the current iteration of the loop is executed, and no further iterations of the loop are started.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ループの現在の繰り返しからそれ以上のコードは実行されません、そしてループのそれ以上の繰り返しは始まりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>No ladder on the board takes the player straight to square 25, and so it isn’t possible to win the game by moving up a ladder.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>盤上のはしごは、プレーヤーをまっすぐ正方形25に連れて行きません、なので、はしごを上がることでゲームに勝つことは可能ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>No other properties or variables are still referring to the Player instance, and so it’s deallocated in order to free up its memory.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>他のいかなるプロパティまたは変数も、もはやPlayerインスタンスに言及していません、なのでそれは、それのもつメモリを開放するために順次割り当て解除されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Nonassociative operators of the same precedence level can’t appear adjacent to each to other.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じ優先順位レベルを持つ非結合演算子は、互いに隣同士に現れることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>None of these function calls are marked with await because the code doesn’t suspend to wait for the function’s result.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの関数呼び出しのどれひとつとしてawaitで印されません、なぜならコードは関数の結果を待つために中断しないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Nonetheless, because it’s of type TextRepresentable, and anything that’s TextRepresentable is known to have a textualDescription property, it’s safe to access thing.textualDescription each time through the loop.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それでもなお、それがTextRepresentable型であり、そして、TextRepresentableであるもの全てがtextualDescriptionプロパティを持つと知られているので、それがループの各回でthing.textualDescriptionにアクセスするのは安全です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Nonetheless, class B provides an override of someMethod() with an access level of “internal”, which is higher than the original implementation of someMethod():</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それにもかかわらず、クラスBは、「内部」のアクセス水準を持つsomeMethod()のオーバーライドを提供します、それは元々のsomeMethod()の実装よりもより高いです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Nonetheless, it’s useful for a Cuboid to provide a read-only computed property to enable external users to discover its current calculated volume.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それでもなお、Cuboidが外部のユーザーにその現在の計算された体積を見つけられるように読み出し専用の計算プロパティを提供することは、役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Nonetheless, many parts of Swift will be familiar from your experience of developing in C and Objective-C.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>にもかかわらず、スウィフトの多くの部分は、あなたのCとObjective-Cでの開発経験からきっとお馴染みのものでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Nonetheless, the Item alias provides a way to refer to the type of the items in a Container, and to define a type for use with the append(_:) method and subscript, to ensure that the expected behavior of any Container is enforced.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それでもなお、Itemエイリアスは、Containerの中の項目の型に言及するための、そしてappend(_:)メソッドと添え字で使うための型を定義するための、ひとつの方法を提供します、それによってあらゆるContainerが期待される挙動を強制されることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Nonetheless, they’re all classes, and so instances of all three types can be used to initialize an array that stores values of type AnyObject:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それでもなお、それらは全てクラスです、なので、３つの型全てのインスタンスは、型AnyObjectの値を格納するある配列を初期化するために使用できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Nonetheless, you can still make the types explicit if you wish, and doing so is encouraged if it avoids ambiguity for readers of your code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それでもなお、あなたが望むならば、依然としてあなたは型を明確にすることができます、そして、それがあなたのコードの読者のために曖昧さを避けるならば、そうすることは推奨されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Nonetheless, you can use protocols as a fully fledged types in your code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それにもかかわらず、あなたはプロトコルを完全に一人前の型としてあなたのコードにおいて使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Nonreturning functions and methods either cause an irrecoverable error or begin a sequence of work that continues indefinitely.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非復帰関数およびメソッドは、回復不能のエラーを起こすかまたは無期限に続く一連の作業を始めるかのどちらかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Nor can they begin with a number, although numbers may be included elsewhere within the name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そしてそれらは数字から始まることもできません、けれども数字が名前内のどこか他で含まれることはできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Nor can you change a constant into a variable or a variable into a constant.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そして、あなたはある定数を変数に、またはある変数を定数に変更することもできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Normally, a closure captures variables implicitly by using them in the body of the closure, but in this case you need to be explicit.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>通常、クロージャは変数それらのキャプチャを、それらをクロージャの本体の中で使うことによって暗黙的に行います、しかしこの場合にはあなたは明示的にする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Not all possible Int values will find a matching planet, however.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、全ての可能なInt値が、適合する惑星を見つけるというわけでありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Not equal to (a != b)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同等でない (a != b)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Not every type in Swift can be compared with the equal to operator (==).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトの中のすべての型が、同等演算子（==）で比較されることができるというわけでありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Not identical to (!==)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同一でない（!==）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Not only are optionals safer and more expressive than nil pointers in Objective-C, they’re at the heart of many of Swift’s most powerful features.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルはObjective-Cでのnilポインターより安全でさらに表現豊かであるだけでなく、それはスウィフトのたくさんある非常に強力な特徴のうち核心的なものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note</seg>
      </tuv>
      <tuv lang="ja">
        <seg>注意</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note also that you can’t provide both an overriding setter and an overriding property observer for the same property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが同じプロパティに対してオーバーライドしたセッターとオーバーライドしたプロパティオブザーバーの両方を提供することができない点にまた、注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note how the generic version of Stack is essentially the same as the nongeneric version, but with a type parameter called Element instead of an actual type of Int.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Stackの総称体版が、本質的にどれほど非総称体版と同じものであるかに注意してください、しかしElementと呼ばれる型パラメータを実際の型Intの代わりに持つことは除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that tenEighty and alsoTenEighty are declared as constants, rather than variables.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>tenEightyとalsoTenEightyが、変数ではなく、定数として宣言される点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that x and y are an optional of whatever type someThrowingFunction() returns.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>xとyは、たとえどんなものでもsomeThrowingFunction()が返す型のオプショナルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that @objc protocols can be adopted only by classes that inherit from Objective-C classes or other @objc classes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>@objcプロトコルがObjective-Cクラスや他の@objcクラスから継承するクラスによってのみ採用される点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that identical to (represented by three equals signs, or ===) doesn’t mean the same thing as equal to (represented by two equals signs, or ==).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同一である（３つの等号、つまり===によって表されるもの）は同等である（２つの等号、つまり==によって表されるもの）と同じことを意味しないのに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that two levels of optional chaining are at play here.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここで２つの階層のオプショナル連鎖が働いていることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that Swift infers a type of String for the someString constant because it’s initialized with a string literal value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトが型StringをsomeString定数に対して推論することに注意してください、それが文字列リテラル値で初期化されるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that Swift’s use of extended grapheme clusters for Character values means that string concatenation and modification may not always affect a string’s character count.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトのCharacter値に対する拡張書記素クラスタの使用は、文字列の連結と修正が常に文字列の文字数に影響を与えないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that an exclamation point (!) is used to unwrap and access the instances stored inside the john and unit4A optional variables, so that the properties of those instances can be set:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>感嘆符（!）が使われることに注意してください、そうすることでオプショナル変数のjohnとunit4Aに格納されるインスタンスがアンラップされてアクセスされるようになります、それでそれらのインスタンスのプロパティが設定されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that if you define a custom initializer for a value type, you will no longer have access to the default initializer (or the memberwise initializer, if it’s a structure) for that type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがある値型のためにあつらえのイニシャライザを定義するならば、あなたがもはやその型の省略時のイニシャライザに（および、それが構造体の場合には、メンバー関連イニシャライザにも）アクセスをしない点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that if you override a failable superclass initializer with a nonfailable subclass initializer, the only way to delegate up to the superclass initializer is to force-unwrap the result of the failable superclass initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>注意することは、あなたが失敗できるスーパークラス・イニシャライザを、失敗できないサブクラス・イニシャライザでオーバーライドする場合、唯一の方法としてスーパークラスのイニシャライザにまで委任するには、失敗できるスーパークラスイニシャライザの結果を強制アンラップすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that in the example above, you are trying to retrieve the value of the street property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例で、あなたがstreetプロパティの値を取り出そうとしている点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that it isn’t possible to call these initializers without using argument labels.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>引数ラベルを使用することなくこれらのイニシャライザを呼び出すことは可能でない点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that neither deinitializer was called when you set these two variables to nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがこれらの２つの変数をnilに設定したとき、どちらのデイニシャライザも呼ばれなかった点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that no whitespace may appear between the type and the !.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>空白が型と!の間に現れないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that no whitespace may appear between the type and the ?.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>空白が型と?の間に現れないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that not all 21-bit Unicode scalar values are assigned to a character—some scalars are reserved for future assignment or for use in UTF-16 encoding.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>全ての21ビットのユニコードスカラー値がひとつの文字に割り当てられる訳ではないことに注意してください ― いくつかのスカラーは将来の割り当てのためにまたはUTF-16符号化で使うために取っておかれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that the delegate property is defined as an optional DiceGameDelegate, because a delegate isn’t required in order to play the game.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>delegateプロパティが、オプショナルのDiceGameDelegateとして定義される点に注意してください、delegateがゲームをプレイするために必須でないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that the thing constant is of type TextRepresentable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>thing定数が型TextRepresentableであることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that the array contains four items, but 0..&lt;count only counts as far as 3 (the index of the last item in the array), because it’s a half-open range.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この配列が４つの項目を含む点に注意してください、しかし0..&lt;countは3（この配列の最後の項目のインデックス）まで数えるだけです、なぜならそれが半開範囲であるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that the closure’s end curly brace is followed by an empty pair of parentheses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャの閉じ波括弧に、一対の空の丸括弧が続くことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that the declaration of parameters and return type for this inline closure is identical to the declaration from the backward(_:_:) function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>行内クロージャのためのパラメータと戻り型の宣言が、backward(_:_:)関数の宣言と同一であることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that the entire function type is wrapped in the optional, not the method’s return value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メソッドの戻り値ではなく、その関数型の全体がオプショナルの中のラップされることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that the message "John Appleseed is being initialized" is printed at the point that you call the Person class’s initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがPersonクラスのイニシャライザを呼んだ時点で、メッセージ"John Appleseed is being initialized"が出力されるという点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that the message in the HTMLElement deinitializer isn’t printed, which shows that the HTMLElement instance isn’t deallocated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>HTMLElementデイニシャライザにおけるメッセージが出力されないことに注意してください、それは、HTMLElementインスタンスが割り当て解除されないことを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that the names of someInt and anotherInt are prefixed with an ampersand when they’re passed to the swapTwoInts(_:_:) function:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>someIntとanotherIntの名前が、それらがswapTwoInts(_:_:)関数に渡される時に、アンパサンドで接頭辞を付けられるという点に注意してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that the return type of this function is still Int?, because the function returns an optional index number, not an optional value from the array.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この関数の戻り型が以前としてInt?であるという点に注意してください、なぜなら、この関数がオプショナルのインデックス番号（配列からのオプショナルの値でない）を返すからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that the tuple’s members don’t need to be named at the point that the tuple is returned from the function, because their names are already specified as part of the function’s return type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タプルの構成要素が、タプルがその関数から返される時点で名前をつけられる必要がない点に注意してください、なぜなら、それらの名前が関数の戻り型の一部としてすでに指定されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that the type of customerProvider isn’t String but () -&gt; String—a function with no parameters that returns a string.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>注意すべきは、customerProviderの型はStringではなく() -&gt; String — ある文字列を返すパラメータのない関数 — であることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that the type of the someInts variable is inferred to be [Int] from the type of the initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>someInts変数の型が、そのイニシャライザの型から[Int]であると推測される点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that the underlying objects aren’t changed by the casting process.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>根底にあるオブジェクトがキャスト処理によって変更されない点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that this extension doesn’t define a type parameter list.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この拡張は型パラメーターリストを定義しないことに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that this function is distinct from the greet(person:) function shown in an earlier section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この関数が前の節で見せたgreet(person:)関数と別個のものであることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that this is true even though numberOfRooms is a non-optional Int.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>たとえnumberOfRoomsが非オプショナルのIntであるとしても、これが当てはまることに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that you can assign an explicit access level for both a getter and a setter if required.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは明示的なアクセス水準をゲッターとセッターの両方に割り当てることが、必要ならば可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that you can’t call a mutating method on a constant of structure type, because its properties can’t be changed, even if they’re variable properties, as described in Stored Properties of Constant Structure Instances:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが定数の構造体型で変更メソッドを呼ぶことができないということに注意してください、なぜなら、定数構造体インスタンスの格納プロパティで記述されるように、そのプロパティは、たとえそれらが変数プロパティであるとしても変わることができないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that, because Optional is implemented as an enumeration, .none and .some can appear in the same switch as the cases of the enumeration type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>注意することとして、Optionalが列挙として実装されることから、.noneと.someが同じスイッチ文の中に列挙型のケース節として現れることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Nothing else is required of the instance you assign to this property, except that the instance must adopt the RandomNumberGenerator protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのインスタンスがRandomNumberGeneratorプロトコルを採用しなければならないことをのぞいては、あなたがこのプロパティに代入するところのインスタンスに必要とされるものは他に何もありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notice how let can be used in a pattern to assign the value that matched the pattern to a constant.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>どのようにletがパターン内で使われて、パターンに合致した値を定数に割り当てることができるかに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notice how self is used to distinguish the name property from the name argument to the initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>どのようにselfがnameプロパティをイニシャライザのためのname引数と区別するために使われるかに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notice how the sunrise and sunset times are extracted from the ServerResponse value as part of matching the value against the switch cases.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>どのように日の出と日没の時間がServerResponseの値から、その値をスイッチの各条件と比較することの一環として抽出されるかに注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notice that the initializer for the EquilateralTriangle class has three different steps:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>EquilateralTriangleクラスのためのイニシャライザが３つの異なる段階を持つことに注意してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notice the two ways that the hearts case of the enumeration is referred to above: When assigning a value to the hearts constant, the enumeration case Suit.hearts is referred to by its full name because the constant doesn’t have an explicit type specified.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上記で列挙のheartsケース節が参照される２つの方法に注意してください：定数のheartsに値を代入するとき、列挙のケース節Suit.heartsはそのフルネームによって参照されます、なぜならこの定数には明確に指定される型がないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notice the use of the mutating keyword in the declaration of SimpleStructure to mark a method that modifies the structure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>SimpleStructureの宣言におけるmutatingキーワードに注意してください、それはその構造体を修正するメソッドに印を付けるためのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Now that moveNearerToZero refers to the correct function, it can be used to count to zero:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>moveNearerToZeroが正しい関数に言及する今、それはゼロまで数えるために使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Now you can call the function as if it took a String argument instead of a closure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>今やあなたはこの関数を、まるでそれがクロージャではなくString引数を取るかのように呼び出せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Null character (\0)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>null文字（\0）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Numbers can overflow in both the positive and negative direction.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>数は正と負の向きの両方においてオーバフローすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Numeric Literals</seg>
      </tuv>
      <tuv lang="ja">
        <seg>数のリテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Numeric Type Conversion</seg>
      </tuv>
      <tuv lang="ja">
        <seg>数の型変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Numeric literals can contain extra formatting to make them easier to read.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>数のリテラルは、それらをより簡単に読めるように書式を整える追加のものを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Objects and Classes</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オブジェクトとクラス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Omitting Argument Labels</seg>
      </tuv>
      <tuv lang="ja">
        <seg>引数ラベルの省略</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Omitting the return from a getter follows the same rules as omitting return from a function, as described in Functions With an Implicit Return.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>returnをゲッターから省くことは、returnを関数から省くのと同じ規則に従います、暗黙的なreturnをもつ関数で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Omitting the version number indicates that the declaration is currently deprecated, without giving any information about when the deprecation occurred.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>バージョン番号の省略は、宣言が現れた時についてのどんな情報も与えることなく、その宣言が現在は非推奨であることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>On Apple platforms, set a deployment target of at least iOS 15, macOS 12, tvOS 15, or watchOS 8.0.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Appleプラットホームでは、少なくともiOS 15、macOS 12、tvOS 15、またはwatchOS 8.0の開発ターゲットを設定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>On a 32-bit platform, Int is the same size as Int32.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>32ビットのプラットホーム上で、IntはInt32と同じサイズです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>On a 32-bit platform, UInt is the same size as UInt32.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>32ビットのプラットホーム上で、UIntはUInt32と同じサイズです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>On a 64-bit platform, Int is the same size as Int64.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>64ビットのプラットホーム上で、IntはInt64と同じサイズです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>On a 64-bit platform, UInt is the same size as UInt64.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>64ビットのプラットホーム上で、UIntはUInt64と同じサイズです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>On a Mac with Xcode installed, or on an iPad with Swift Playgrounds, you can open this chapter as a playground.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>XcodeがインストールされたMac上で、またはSwift Playgroundsを備えたiPad上で、あなたはこの章をプレイグラウンドとして開くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>On a function declaration, the result builder builds the body of the function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある関数宣言上で、リザルトビルダーはその関数の本文を組み立てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>On a parameter in a function declaration, the result builder builds the body of a closure that’s passed as the corresponding argument.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数宣言のパラメータ上で、リザルトビルダーは、対応する引数として渡されるクロージャの本文を組み立てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>On a variable or subscript declaration that includes a getter, the result builder builds the body of the getter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ゲッターを含んでいる、変数または添え字の宣言上で、リザルトビルダーはゲッターの本文を組み立てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>On each pass, the for-in loop sets the item constant to the next MediaItem in the array.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>各段階で、このfor-inループはitem定数を次のMediaItemに設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>On those occasions, you can write try! before the expression to disable error propagation and wrap the call in a runtime assertion that no error will be thrown.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの場合には、あなたはtry!をその式の前に書くことによって、エラー伝達を抑制して、エラーはスローされないという実行時表明の中にその呼び出しを包み込みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Once directionToHead is declared as a CompassPoint, you can set it to a different CompassPoint value using a shorter dot syntax:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>一旦directionToHeadが、あるCompassPointとして宣言されるならば、あなたはそれをより短いドット構文を使って、異なるCompassPoint値に設定することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Once a constant property is assigned a value, it can’t be further modified.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>いったん定数プロパティが値を割り当てられるならば、それはそれ以上変更されることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Once it completes the sorting process, the sorted(by:) method returns a new array of the same type and size as the old one, with its elements in the correct sorted order.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>一旦それがソート処理を完了するならば、sorted(by:)メソッドは、古いものと同じ型と大きさの新しい配列を返します、そしてその要素は正しく分類された順序を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Once the counter reaches zero, no more counting takes place:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ひとたびcounterがゼロに達するならば、それ以上数えることは起こりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Once the initial state for every stored property has been determined, the second phase begins, and each class is given the opportunity to customize its stored properties further before the new instance is considered ready for use.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>一旦あらゆる格納プロパティのための最初の状態が決定されるならば、第２の段階が始まります、そして各クラスは、新しいインスタンスが使用する準備ができているとみなされる前に、さらにその格納プロパティを好みに合わせて作り変える機会を与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Once the superclass’s designated initializer is finished, the subclass’s designated initializer can perform additional customization (although again, it doesn’t have to).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>一旦スーパークラスの指定イニシャライザが作業をし終えるならば、サブクラスの指定イニシャライザは追加の改良を実行することができます（しかし再び、そうしなければならない訳ではない）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Once the top of the chain is reached, and the final class in the chain has ensured that all of its stored properties have a value, the instance’s memory is considered to be fully initialized, and phase 1 is complete.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>いったん連鎖の最上部に届き、そして連鎖の中の最終的なクラスがその格納プロパティの全てが値を持つことを確実にしたならば、インスタンスのメモリは充分に初期化されるとみなされます、そして、第１段階は完了です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Once you define a type alias, you can use the alias anywhere you might use the original name:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>一旦あなたがある型エイリアスを定義するならば、あなたが本来の名前を使うであろうどこにでも、あなたはそのエイリアスを使用することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Once you specify a type parameter, you can use it to define the type of a function’s parameters (such as the a and b parameters of the swapTwoValues(_:_:) function), or as the function’s return type, or as a type annotation within the body of the function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>一旦あなたが型パラメータを指定するならば、あなたはそれを、関数のパラメータの型を定義するために（例えば、 swapTwoValues(_:_:)関数のaとbパラメータのように）、または関数の戻り型として、あるいは関数の本文内の型注釈として使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Once you’re sure that the optional does contain a value, you can access its underlying value by adding an exclamation point (!) to the end of the optional’s name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>一旦あなたがそのオプショナルが値を含んでいることを確かめたなら、あなたは感嘆符（!）をオプショナルの名前の終わりに加えることによって、それに内在する値にアクセスすることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Once you’ve declared a constant or variable of a certain type, you can’t declare it again with the same name, or change it to store values of a different type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>一旦あなたが特定の型のある定数または変数を宣言してしまったならば、あなたは同じ名前でもう一度それを宣言し直すこと、またはそれを異なる型の値を格納するように変更することは出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>One consequence of this long-term write access is that you can’t access the original variable that was passed as in-out, even if scoping rules and access control would otherwise permit it—any access to the original creates a conflict.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この長期書き込みアクセスの１つの帰結として、あなたはin-outとして渡された元の変数にアクセス出来ません、たとえスコープ規則とアクセス制御がその他の点ではそれを許すとしてもです — 元のものに対するどんなアクセスも衝突を作り出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>One convenience initializer calls another convenience initializer, which in turn calls the single designated initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>１つの便宜イニシャライザは、別の便宜イニシャライザを呼びます、それは、今度は１つだけある指定イニシャライザを呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>One example is the addition assignment operator (+=):</seg>
      </tuv>
      <tuv lang="ja">
        <seg>１つの例は、加算代入演算子（+=）です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>One kilometer is the same as 1,000 meters, so the km computed property multiplies the value by 1_000.00 to convert into a number expressed in meters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>１キロメートルは1,000メートルと同じものですので、km計算プロパティは1_000.00を掛けられて、メートルで表される数に変換されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>One of the most important differences between structures and classes is that structures are always copied when they’re passed around in your code, but classes are passed by reference.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体とクラスの間の１つの最も重要な違いは、それらがあなたのコードにおいてあちこち渡されるとき、構造体は常にコピーされるということです、それに対してクラスは参照によって渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>One of these classes is defined as internal, and the other is defined as private.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらのクラスのうちの１つは内部として定義されます、そして別のものは非公開として定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>One of these two branches is always executed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの２つの分岐のうちの１つは、常に実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>One way is to use do-catch.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>１つの方法は、do-catchを使うことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>One way that a closure can escape is by being stored in a variable that’s defined outside the function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャが脱出できる１つの方法は、関数の外側で定義される変数に格納されることによってです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>One way to fix invalidFlip(_:) is to move the special case for squares into the implementation of FlippedShape, which lets this function always return a FlippedShape value:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>invalidFlip(_:)を修正する１つの方法は、正方形の特別な事例をFlippedShapeの実装へと移動することです、それはこの関数に常にFlippedShape値を返させます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>One way to provide the sorting closure is to write a normal function of the correct type, and to pass it in as an argument to the sorted(by:) method:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ソート・クロージャを提供する１つの方法は、通常の関数を正しい型で記述することです、そしてそれを１つの引数としてsorted(by:)メソッドに渡すことになります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>One way to solve this conflict is to make an explicit copy of stepSize:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この衝突を解決する１つの方法は、明示的にstepSizeのコピーを作ることです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>One-Sided Ranges</seg>
      </tuv>
      <tuv lang="ja">
        <seg>片側範囲</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>One-sided ranges can be used in other contexts, not just in subscripts.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>片側範囲は、添え字とは違い、他の文脈で使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Only the compound assignment operators can be overloaded.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複合代入演算子だけが、オーバーロードされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Only throwing functions can propagate errors.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スロー関数だけがエラーを伝えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Opaque Type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>不透明型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Opaque Types</seg>
      </tuv>
      <tuv lang="ja">
        <seg>不透明型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Opaque types appear as the return type of a function or subscript, or the type of a property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>不透明型は、関数または添え字の戻り型、またはあるプロパティの型として現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Opaque types can’t appear as part of a tuple type or a generic type, such as the element type of an array or the wrapped type of an optional.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>不透明型は、タプル型または総称体型の一部として現れることができません、たとえば配列の要素型、またはオプショナルのラップ型などの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Opaque types have the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>不透明型は以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Open access applies only to classes and class members, and it differs from public access by allowing code outside the module to subclass and override, as discussed below in Subclassing.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>解放アクセスは、クラスとクラスメンバにのみ適用されます、そしてそれは公開アクセスとは、モジュールの外側のコードにサブクラス作成およびオーバーライドをさせることによって異なります、下のサブクラスをつくるで議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Open access is the highest (least restrictive) access level and private access is the lowest (most restrictive) access level.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>開放アクセスは最も高い（制限の最も少ない）アクセス水準であり、非公開アクセスは最も低い（制限の最も多い）アクセス水準です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Operator associativity defines how operators of the same precedence are grouped together—either grouped from the left, or grouped from the right.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>演算子結合性は、同じ優先順位の演算子がまとめられる方法を定義します ― 左からまとめられるか右からまとめられるかのどちらか。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Operator precedence gives some operators higher priority than others; these operators are applied first.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>演算子優先順位は、ある演算子に他のものよりも高い優先権を与えます；これらの演算子は最初に適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Operator Declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>演算子宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Operator Methods</seg>
      </tuv>
      <tuv lang="ja">
        <seg>演算子メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Operator functions for Compound Assignment Operators no longer use the @assignment attribute when defining the function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複合代入演算子のための演算子関数は、もはや関数を定義する時に@assignment属性を使いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Operators</seg>
      </tuv>
      <tuv lang="ja">
        <seg>演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Operators are unary, binary, or ternary:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>演算子には、単項、二項、または三項があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Operators from those precedence groups can’t be used next to each other without grouping parentheses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらの優先順位グループ由来の演算子は、グループ化括弧なしで互いにすぐ隣に使われることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Operators that are left-associative group left-to-right.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>左結合である演算子は、左から右へとグループにまとめられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Operators that are right-associative group right-to-left, and operators that are specified with an associativity of none don’t associate at all.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>右結合の演算子は右から左にグループにされます、そしてnoneの関係性を指定される演算子は全く結合しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Optional Binding</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルを束縛する（定数・変数と結び付ける）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Optional Chaining</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル連鎖</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Optional Chaining as an Alternative to Forced Unwrapping</seg>
      </tuv>
      <tuv lang="ja">
        <seg>強制アンラップに代わるものとしてのオプショナル連鎖</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Optional Pattern</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルパターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Optional Property Types</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルプロパティ型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Optional Protocol Requirements</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルのプロトコル要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Optional Tuple Return Types</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルタプルの戻り型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Optional Type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Optional binding can be used with if and while statements to check for a value inside an optional, and to extract that value into a constant or variable, as part of a single action.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル束縛は、ifやwhile文と一緒に使用して、オプショナルの内部の値を確認すること、そしてその値を定数または変数に抽出することを、一回の動作で可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Optional chaining in Swift is similar to messaging nil in Objective-C, but in a way that works for any type, and that can be checked for success or failure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトにおけるオプショナル連鎖は、どんな型のためにでも働きそして成功か失敗を確認されることができるというようなことを除いて、Objective-Cにおけるnilにメッセージを送ることに似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Optional chaining provides an alternative way to access the value of numberOfRooms.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル連鎖は、numberOfRoomsの値にアクセスする代わりの方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Optional patterns consist of an identifier pattern followed immediately by a question mark and appear in the same places as enumeration case patterns.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルパターンは、１つの識別子パターンに直接に１つの疑問符が続くものから成ります、そして列挙ケース節パターンと同じ場所に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Optional requirements are available so that you can write code that interoperates with Objective-C.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル要件が利用可能なことから、あなたはObjective-Cと相互運用するコードを書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Optional requirements are prefixed by the optional modifier as part of the protocol’s definition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルの要件は、そのプロトコル定義においてoptional修飾子を前に置かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Optional syntactic categories and literals are marked by a trailing subscript, opt.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>任意である統語論のカテゴリーとリテラルは後に続く下つき文字、optによって印されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Optional-Chaining Expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル連鎖式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Optional-chaining expressions must appear within a postfix expression, and they cause the postfix expression to be evaluated in a special way.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル連鎖式は、接尾辞式の中に現れなければなりません、そしてそれはその接尾辞式を特別なやり方で評価されるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Optionals</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Optionals are used to represent the absence of a value, but when an operation fails, it’s often useful to understand what caused the failure, so that your code can respond accordingly.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルは、ある値の欠如を表すために使われます、しかしある操作が失敗する時、何がその失敗をもたらしたのか理解するのはしばしば役に立ちます、それであなたのコードはそれに適切に応答することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Optionals can be checked with an if statement to see if a value exists, and can be conditionally unwrapped with optional binding to access the optional’s value if it does exist.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルは、値が存在しているかどうか見るために、if文を使って調べられることが出来ます、そしてオプショナルの持つ値にそれが存在するならばアクセスするために、オプショナル束縛を使って条件に応じてアンラップされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Optionals ensure that nil values are handled explicitly.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルが、nil値が明確に取り扱われるのを確実にする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Optionals of any type can be set to nil, not just object types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>すべての型のオプショナルが、nilに設定されることができます、単にオブジェクト型だけでなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Optionals say either “there is a value, and it equals x” or “there isn’t a value at all”.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルであるものは、「ひとつの値がある、そしてそれはxに等しい」または「まったく値がない」のどちらかを伝えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Other Swift functions can’t be converted to the C calling convention.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>他のスウィフト関数は、C呼出規約に変換されることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Other named types can only inherit from or conform to a list of protocols.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>他の名前付きの型は、プロトコルのリストから継承し準拠することだけができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Other products are labeled with 2D barcodes in QR code format, which can use any ISO 8859-1 character and can encode a string up to 2,953 characters long:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>別の製品はQRコード形式の二次元バーコードでラベルをつけられます、それはどんなISO 8859-1の文字でも使うことができて、2,953文字までの長さの文字列をコード化することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Other units require some conversion to be expressed as a value measured in meters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>他の単位は、メートルで計られる値として表されるためにいくらかの変換を必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Other valid versions of this function could return values of different types when flipping multiple instances of the same shape.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この関数の他の有効なバージョンそれらは、異なる型の値を返すことが、同じ形状の複数のインスタンスを裏返す時にありえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Otherwise, nourish(with:) propagates the error to its call site.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そうでなければ、nourish(with:)はそのエラーをそれの呼出地点へと伝達します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Otherwise, a runtime error is raised.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そうでなければ、実行時エラーが引き起こされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Otherwise, it evaluates the second expression and returns its value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そうでなければ、それは第二の式を評価して、その値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Otherwise, no message is printed, and code execution continues after the if statement’s closing brace.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そうでなければ、メッセージは出力されません、そしてコードの実行はif文の閉じ波括弧の後に続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Otherwise, the species property’s value is set, and initialization succeeds:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そうでなければ、speciesプロパティの値は設定されて、初期化は成功します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Otherwise, the closure expression is escaping.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それ以外では、クロージャ式は脱出です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Otherwise, the error can propagate out of the containing scope, which means the error must be handled by an enclosing catch clause or the containing function must be declared with throws.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そうでなければ、エラーはそれを収容しているスコープの外に伝えられることができます、それが意味するのは、エラーは周りを囲んでいるcatch節によって取り扱われなければならない、またはそれを収容している関数はthrowsで宣言されなければならないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Otherwise, the initializer has an access level of internal.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そうでなければ、イニシャライザは内部のアクセス水準を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Otherwise, the nested function is an escaping function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それ以外では、入れ子にされた関数は脱出関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Otherwise, the new value is stored without calling the superclass’s getter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そうでなければ、新しい値はスーパークラスのもつゲッターを呼び出すことなく格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Otherwise, the optional value is unwrapped and assigned to the constant after let, which makes the unwrapped value available inside the block of code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そうでなければ、そのオプショナルの値は包装を取られて（アンラップされて）、letの後の定数に代入されます、そしてそれはコードのブロックの内側で利用できる包装を取られた値（アンラップ値）になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Otherwise, the optional value is unwrapped, and everything after the ? acts on the unwrapped value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そうでなければ、オプショナルの値は包装を取られます（アンラップされます）、そして?の後のすべてのものは包装を取られた値（アンラップ値）に作用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Otherwise, the program doesn’t perform assignment or execute the statements, and it’s finished executing the for-in statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そうでなければ、プログラムは代入を実行しませんし、文を実行しません、そしてそれはfor-in文の実行を終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Otherwise, the result is an optional containing the value that the function returned.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そうでなければ、結果は関数が返した値を含んでいるオプショナルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Otherwise, the square’s value is 0, and it’s a “free” square, represented by ○.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>一方、正方形の値は0ならば、それは「自由」な正方形であって、○によって表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Otherwise, the subscript returns nil:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そうでなければ、添え字はnilを返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Otherwise, the value of x and y is the value that the function returned.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そうでなければ、xとyの値はこの関数が返す値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Otherwise, the value of the optional-try expression is nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そうでなければ、オプショナルtry式の値はnilです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Otherwise, when set to false or omitted, operators in the precedence group follows the same optional chaining rules as operators that don’t perform assignment.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そうせずに、falseに設定するか省略する場合は、その優先順位グループの演算子は代入を実行しない演算子と同じオプショナル連鎖規則に従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Our goals for Swift are ambitious.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトのための私達のゴールは、野心的です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Outside the context in which they appear in the grammar, they can be used as identifiers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そこにおいてそれらが文法の中に現れる文脈外では、それらは識別子として使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Overflow Operators</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オーバフロー演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Overflow addition (&amp;+)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オーバフロー加算（&amp;+）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Overflow also occurs for signed integers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オーバフローはまた、符号つき整数に対しても起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Overflow behavior is trapped and reported as an error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オーバフロー挙動は、エラーとして捕まえられて報告されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Overflow multiplication (&amp;*)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オーバフロー乗算（&amp;*）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Overflow subtraction (&amp;-)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オーバフロー減算（&amp;-）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Overlapping accesses appear primarily in code that uses in-out parameters in functions and methods or mutating methods of a structure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オーバーラップするアクセスは、関数およびメソッドにおいてまたは構造体の変更メソッドにおいてin-outパラメータを使うコードに主に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Overridden Requirements Aren’t Used in Some Generic Contexts</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オーバーライドされた要件はいくつかの総称体文脈では使われません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Overridden properties, methods, subscripts, and designated initializers must be marked with the override declaration modifier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティ、メソッド、添え字、そして指定イニシャライザのオーバーライドは、override宣言修飾子で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Overriding</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Overriding Methods</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メソッドのオーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Overriding Properties</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティのオーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Overriding Property Getters and Setters</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティゲッターとセッターのオーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Overriding Property Observers</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティオブザーバーのオーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Overriding a Failable Initializer</seg>
      </tuv>
      <tuv lang="ja">
        <seg>失敗できるイニシャライザのオーバーライド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Overriding by accident can cause unexpected behavior, and any overrides without the override keyword are diagnosed as an error when your code is compiled.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>誤って偶然にオーバーライドすることは予想外の挙動を引き起こすことがありえます、なので、あなたのコードがコンパイルされるとき、overrideキーワードのないどんなオーバーライドもエラーとして診断されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Overriding properties is described in Overriding.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティのオーバーライドは、オーバーライドにおいて記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Overusing autoclosures can make your code hard to understand.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>自動クロージャの使いすぎは、あなたのコードを理解しにくくする可能性があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Parameter</seg>
      </tuv>
      <tuv lang="ja">
        <seg>パラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Parameter Names</seg>
      </tuv>
      <tuv lang="ja">
        <seg>パラメータ名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Parameter Names and Argument Labels</seg>
      </tuv>
      <tuv lang="ja">
        <seg>パラメータ名と引数ラベル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Parameters can be ignored, take a variable number of values, and provide default values using the following forms:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>パラメータは、無視されること、可変の数の値をとること、そして以下の形式を使って省略時の値を提供することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Parameters can provide default values to simplify function calls and can be passed as in-out parameters, which modify a passed variable once the function has completed its execution.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>パラメータは、関数呼び出しを単純化するために初期値を提供することができます、そしてひとたび関数がその実行を完了し終えれば渡された変数を修正するin-outパラメータとして渡されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Parameters that don’t have default values are usually more important to the function’s meaning—writing them first makes it easier to recognize that the same function is being called, regardless of whether any default parameters are omitted.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>省略時の値を持たないパラメータは、関数の意味するところにとって通常より重要です—それらを最初に書くことは、何らかの省略時のパラメータが省かれているかどうかに関係なく、同じ関数が呼び出されているのをよりわかり易くします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Parameters that were skipped during the scanning process don’t have an argument passed to them—for example, they can use a default parameter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>走査処理の間に飛ばされたパラメータそれらは、それらに渡される引数を持ちません — 例えば、それらはある省略時パラメータを使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Parentheses around the condition or loop variable are optional.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>条件またはループ変数のまわりの丸括弧は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Parenthesized Expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>括弧に入れられた式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Part of the functionality of the DataManager class is the ability to import data from a file.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>DataManagerクラスの機能性の一部は、データをファイルからインポートする能力です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Passing birthdayPerson to the beginConcert(in:) function is invalid because Person isn’t a subclass of Location.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>birthdayPersonをbeginConcert(in:)関数に渡すことは無効です、なぜならPersonはLocationのサブクラスではないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Patterns</seg>
      </tuv>
      <tuv lang="ja">
        <seg>パターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Performing Set Operations</seg>
      </tuv>
      <tuv lang="ja">
        <seg>集合演算の実行</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Phase 1</seg>
      </tuv>
      <tuv lang="ja">
        <seg>第１段階</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Phase 2</seg>
      </tuv>
      <tuv lang="ja">
        <seg>第２段階</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Place parameters that don’t have default values at the beginning of a function’s parameter list, before the parameters that have default values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>省略時の値を持たないパラメータを関数のもつパラメータリストの始まりに、省略時の値を持つパラメータの前に、置いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Place the capture list before a closure’s parameter list and return type if they’re provided:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらが提供されるならばクロージャのパラメータ・リストと戻り型の前に、捕獲リストを置いてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Platform condition</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プラットホーム条件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Playground literals in plain text outside of Xcode are represented using a special literal syntax.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Xcodeの外部のプレーンテキストの中のプレイグラウンドリテラルは、特別なリテラル構文を使って表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Playgrounds allow you to edit the code listings and see the result immediately.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プレイグラウンドは、あなたがコードリストを編集してすぐにその結果を見られるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Pointers</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ポインター</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Popping a value from the stack removes and returns the top value, "cuatro":</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このスタックから値をボップすることは、一番上の値、"cuatro"を削除して、返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Positive numbers are stored in exactly the same way as for unsigned integers, counting upwards from 0.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>正の数は符号なし整数と正確に同じ方法で格納されて、0から上方へ数えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Postfix Expressions</seg>
      </tuv>
      <tuv lang="ja">
        <seg>接尾辞式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Postfix Self Expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>接尾辞self式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Postfix expressions, like prefix and infix expressions, let you build up more complex expressions using postfixes such as function calls and member access.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>接尾辞式は、接頭辞や接中辞の式に似て、関数呼び出しやメンバー・アクセスのような接尾辞を使うことで、あなたにより複雑な式を組み立てさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Postfix operators are nonassociative.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>接尾辞演算子は非結合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Precedence Group Declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>優先順位グループ定義</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Precedence and Associativity</seg>
      </tuv>
      <tuv lang="ja">
        <seg>優先順位と結合性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Precedence for Custom Infix Operators</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あつらえの接中辞演算子の優先順位</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Precedence groups related to each other using lower group names and higher group names must fit into a single relational hierarchy, but they don’t have to form a linear hierarchy.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下方グループ名と上方グループ名を使って互いに関係のある優先順位グループは、単一の関係階層へはめ込まなければなりません、しかしそれらは線形階層を形作る必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Prefix Expressions</seg>
      </tuv>
      <tuv lang="ja">
        <seg>接頭辞式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Prefix and Postfix Operators</seg>
      </tuv>
      <tuv lang="ja">
        <seg>接頭辞と接尾辞演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Prefix and Suffix Equality</seg>
      </tuv>
      <tuv lang="ja">
        <seg>接頭辞と接尾辞等式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Prefix and infix expressions let you apply operators to smaller expressions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>接頭辞と接中辞式は、あなたに演算子をより小さい式に適用させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Prefix operators are nonassociative.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>接頭辞演算子は非結合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Prefix operators declarations don’t specify a precedence level.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>接頭辞演算子宣言は、優先順位レベルを指定しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Prefix operators take one argument, the expression that follows them.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>接頭辞演算子は、１つの引数（それらの後に続く式）をとります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Preventing Overrides</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オーバーライドを防ぐ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Preventing multiple tasks from interacting with the same instance simultaneously prevents problems like the following sequence of events:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複数のタスクが同じインスタンスと同時に相互作用するのを防ぐことは、以下の一連の出来事のような問題を防ぎます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Primary Expressions</seg>
      </tuv>
      <tuv lang="ja">
        <seg>基本式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Primary expressions are conceptually the simplest kind of expression, and they provide a way to access values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>基本式は、概念的に最も単純な種類の式で、それらはアクセス手段をさまざまな値に提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Printing Constants and Variables</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数と変数を出力する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Printing the description of each item in the array shows that their default states have been set as expected.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列の各項目の説明を出力することは、予想されるようにそれらの省略時の状態が設定されたことを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Private Members in Extensions</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張の中の非公開メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Private members declared in the type’s declaration can be accessed from extensions, and private members declared in one extension can be accessed from other extensions and from the type’s declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型の持つ宣言において宣言される非公開メンバは拡張からアクセスできます、そして一方の拡張において宣言される非公開メンバは他方の拡張からそしてその型のもつ宣言からアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Program execution continues at the point immediately following the function or method call.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プログラム実行は、関数またはメソッド呼び出しに直ちに続いている地点に続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Program execution continues to the next case even if the patterns of the case label don’t match the value of the switch statement’s control expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>たとえケース節ラベルのパターンがswitch文のもつ制御式の値にマッチしないとしても、プログラム実行は次のケース節に続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Program execution doesn’t continue or “fall through” to the next case or default case.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プログラム実行は続きません、あるいは、次のケース節または省略時のケース節に「抜け落ちる」ことはありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Projecting a Value From a Property Wrapper</seg>
      </tuv>
      <tuv lang="ja">
        <seg>値をプロパティラッパーから投影する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Propagating Errors Using Throwing Functions</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スロー関数を使ってエラーを伝える</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Propagation of Initialization Failure</seg>
      </tuv>
      <tuv lang="ja">
        <seg>初期化失敗の伝播</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Properties</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Properties can only be accessed, and methods can only be called, once the class instance is known to be valid at the end of the first phase.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>一旦クラスインスタンスが第１段階の終わりに有効であるということを知られる場合にのみ、プロパティはアクセスされることができ、そしてメソッドは呼ばれることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Properties of a actor instance can be accessed using dot (.) syntax, as described in Accessing Properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>アクターインスタンスのプロパティはドット（.）構文でアクセスされることができます、プロパティにアクセスするで記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Properties of a structure instance can be accessed using dot (.) syntax, as described in Accessing Properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスインスタンスのプロパティはドット（.）構文でアクセスされることができます、プロパティにアクセスするで記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Properties of optional type are automatically initialized with a value of nil, indicating that the property is deliberately intended to have “no value yet” during initialization.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルの型のプロパティは、nilの値で自動的に初期化されて、そのプロパティは初期化の時には「まだ無い値」を故意に持つつもりであることを示しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Properties, methods, and initializers of an existing type can’t be overridden in an extension of that type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>既存の型のプロパティ、メソッド、そしてイニシャライザは、その型の拡張においてオーバーライドされることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Property Observers</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティオブザーバー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Property Requirements</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティ要件</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Property Wrappers</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティラッパー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Property observers are called every time a property’s value is set, even if the new value is the same as the property’s current value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティオブザーバーは、あるプロパティの値が設定されるたびに、たとえ新しい値がそのプロパティの現在の値と同じものであるとしても、呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Property observers aren’t called when ARC sets a weak reference to nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティオブザーバーは、ARCが弱い参照をnilに設定するとき呼び出されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Property observers can be added to any property, regardless of whether it was originally defined as a stored or computed property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティオブザーバーは、どんなプロパティにでも加えられることができます、それが格納または計算プロパティとして元々定義されたかどうかは関係ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Property observers can be added to stored properties you define yourself, and also to properties that a subclass inherits from its superclass.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティオブザーバーは、あなたがあなた自身で定義する格納プロパティに、そのうえにサブクラスがそのスーパークラスから継承するプロパティにも加えられることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Property observers observe and respond to changes in a property’s value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティオブザーバーは、あるプロパティの値の変化を観察して、応答します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Property requirements are always declared as variable properties, prefixed with the var keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティ要件は常に変数プロパティとして宣言されます、それでvarキーワードを前に置かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocol Associated Type Declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル関連型宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocol Composition</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル合成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocol Composition Type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル合成型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocol Conformance</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル準拠</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocol Conformance Must Not Be Redundant</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル準拠は冗長であってはいけません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocol Declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocol Extensions</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル拡張</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocol Inheritance</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル継承</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocol Initializer Declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルイニシャライザ宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocol Method Declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルメソッド宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocol Property Declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルプロパティ宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocol Subscript Declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル添え字宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocol Syntax</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocol casts are no longer limited to @objc protocols.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルのキャストは、もはや@objcプロトコルに制限されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocol composition types have the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル合成型は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocol composition types may be used only when specifying a type in type annotations, in generic parameter clauses, and in generic where clauses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル合成型は、型注釈において、総称体パラメータ節において、そして総称体where節において型を指定する場合にのみ使われるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocol compositions behave as if you defined a temporary local protocol that has the combined requirements of all protocols in the composition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル合成は、あなたが全てのプロトコルの要件を結合したものをその合成物の中に持っている一時的なローカルプロトコルを定義したかのように振る舞います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocol compositions don’t define any new protocol types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル合成は、何ら新しいプロトコル型を定義しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocol compositions have the form SomeProtocol &amp; AnotherProtocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル合成は、形式SomeProtocol &amp; AnotherProtocolを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocol declarations are declared at global scope using the protocol keyword and have the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル宣言は、グローバルなスコープでキーワードprotocolを使って宣言されて、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocol declarations can’t contain class, structure, enumeration, or other protocol declarations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル宣言は、クラス、構造体、列挙、または他のプロトコル宣言を含むことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocol declarations can’t include opaque types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル宣言は、不透明型を含むことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocol extensions can add implementations to conforming types but can’t make a protocol extend or inherit from another protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル拡張は、実装を加えることによって型に準拠が可能です、しかしあるプロトコルを別のプロトコルから拡張したり継承したりはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocol inheritance is always specified in the protocol declaration itself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル継承は、常にプロトコル宣言それ自体の中で指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocol initializer declarations have the same form as initializer declarations, except they don’t include the initializer’s body.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルイニシャライザ宣言は、それらがイニシャライザ本文を含めないことを除いて、イニシャライザ宣言と同じ形式を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocol method declarations have the same form as function declarations, with two exceptions: They don’t include a function body, and you can’t provide any default parameter values as part of the function declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルメソッド宣言は、２つの例外を除いて、関数宣言と同じ形式を持ちます：それらは関数本体を含むことができません、そして、あなたは関数宣言の一部として省略時のパラメータ値をまったく提供することができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocol property declarations have a special form of a variable declaration:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルプロパティ宣言は、変数宣言の特別な形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocol requirements with default implementations provided by extensions are distinct from optional protocol requirements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張によって提供される省略時の実装を持つプロトコル要件は、オプショナルプロトコル要件とは異なったものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocol subscript declarations have a special form of a subscript declaration:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル添え字宣言は、添え字宣言の特別な形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocol types can inherit from any number of other protocols.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル型は、いくらかの他のプロトコルから継承することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocols</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocols and Extensions</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルと拡張</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocols are named types, and thus they can appear in all the same places in your code as other named types, as discussed in Protocols as Types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルは名前をつけられた型です、したがってそれらはあなたのコードにおいて他の名前をつけられた型と同じ場所の全てにおいて現れることができます、型としてのプロトコルで議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocols as Types</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型としてのプロトコル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocols can also declare special kinds of type aliases, called associated types, that can specify relationships among the various declarations of the protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルはまた、特別な種類の型エイリアス、そのプロトコルのいろいろな宣言の間での関係を指定することができる関連型と呼ばれるものを宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocols can be extended to provide method, initializer, subscript, and computed property implementations to conforming types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルは拡張されることによって、準拠している型にメソッド、イニシャライザ、添え字、そして計算プロパティの実装を提供できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocols can be restricted to a certain context, as can global constants, variables, and functions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルは特定の前後関係に制限されることができます、グローバルな定数、変数、そして関数も同じようにされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocols can define failable initializer requirements for conforming types, as defined in Failable Initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルは、失敗できるイニシャライザで記述されるように、準拠している型に対して失敗できるイニシャライザ要件を定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocols can require specific initializers to be implemented by conforming types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルは、準拠型によって特定のイニシャライザが実装されるように要求することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocols can require specific instance methods and type methods to be implemented by conforming types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルは、準拠型によって特定のインスタンスメソッドと型メソッドが実装されるように要求することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocols declare associated types using the associatedtype keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルは、関連型をキーワードassociatedtypeを使って宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocols declare that conforming types must implement a method by including a protocol method declaration in the body of the protocol declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルが宣言するのは、準拠している型は、プロトコル宣言の本文中のプロトコルメソッド宣言を含めることによって、あるメソッドを実装する必要があるということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocols declare that conforming types must implement a property by including a protocol property declaration in the body of the protocol declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルは、準拠している型がそのプロトコル宣言の本文の中のプロトコルプロパティ宣言を含めることによってプロパティを実装しなければならないことを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocols declare that conforming types must implement a subscript by including a protocol subscript declaration in the body of the protocol declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルは、準拠している型がそのプロトコル宣言の本文の中のプロトコル添え字宣言を含めることによって添え字を実装しなければならないと宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocols declare that conforming types must implement an initializer by including a protocol initializer declaration in the body of the protocol declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルは、準拠している型がそのプロトコル宣言の本文の中のプロトコルイニシャライザ宣言を含めることによってイニシャライザを実装しなければならないと宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocols don’t actually implement any functionality themselves.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルは、実際に少しの機能性も実装しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Protocols that are marked with the objc attribute can’t inherit from protocols that aren’t marked with this attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>objc属性で印されるプロトコルは、この属性で印されないプロトコルから継承できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Provide new initializers</seg>
      </tuv>
      <tuv lang="ja">
        <seg>新しいイニシャライザを提供する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Providing Default Implementations</seg>
      </tuv>
      <tuv lang="ja">
        <seg>省略時の実装を提供する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Providing a value when you create a constant or variable lets the compiler infer its type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが定数または変数をつくる時に値を提供することは、コンパイラにその型を推論させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Providing error handling when values get too large or too small gives you much more flexibility when coding for boundary value conditions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>値があまりに大きいかあまりに小さくなる時にエラー処理を提供することは、境界値条件のためのコードを書くとき、あなたにずっと多くの柔軟性を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Providing more detail limits which symbols are imported—you can specify a specific submodule or a specific declaration within a module or submodule.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>より詳細な記述を提供することは、どのシンボルがインポートされるかを制限します ― あなたは、あるモジュールまたはサブモジュール内で、特定のサブモジュールまたは特定の宣言を指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Put another way, protoFlip(_:) makes a much looser API contract with its caller than flip(_:) makes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>言い換えれば、protoFlip(_:)は、それの呼び出し側とずっとゆるいAPI契約をします、flip(_:)がするよりも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Querying and Setting Type Properties</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型プロパティを問い合わせて、設定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Range Operators</seg>
      </tuv>
      <tuv lang="ja">
        <seg>範囲演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Rather than a copy, a reference to the same existing instance is used.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コピーではなく、既存の同じインスタンスに対する参照が使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Rather than moving the player immediately, the loop uses a switch statement to consider the result of the move and to determine whether the move is allowed:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>直ちにプレーヤーを動かすのではなく、ループはswitch文を使うことで、移動の結果を考慮して、移動が許可されるかどうか判断します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Rather than placing an exclamation point after the optional’s name when you use it, you place an exclamation point after the optional’s type when you declare it.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがそれを使う時にそのオプショナルのもつ名前の後に感嘆符を置くよりも、あなたがそれを宣言する時にそのオプショナルのもつ型の後に感嘆符を書きたいとあなたは思うでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Rather than returning an existing value, the getter actually calculates and returns a new Point to represent the center of the square.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>既存の値を返すのではなく、このゲッターは正方形の中心を表すために実際に計算して新しいPointを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Rather, it reports a compile-time error that case "a": doesn’t contain any executable statements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そうではなく、それはcase "a":が実行可能な文を何も含まないという、コンパイル時エラーを報告します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Rather, their role is to ensure that self is fully and correctly initialized by the time that initialization ends.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>というより、それの役割は、初期化が終わるまでにselfが完全にそして正確に初期化されることを確実にすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Raw Values</seg>
      </tuv>
      <tuv lang="ja">
        <seg>生の値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Raw Values and Associated Values</seg>
      </tuv>
      <tuv lang="ja">
        <seg>生の値と関連値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Raw values are not the same as associated values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>生の値は、関連値と同じものでない点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Raw values are set to prepopulated values when you first define the enumeration in your code, like the three ASCII codes above.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>生の値は、上の３つのASCIIコードの様に、あなたがあなたのコードにおいて最初に列挙を定義するとき、あらかじめ入れられた値に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Raw values can be strings, characters, or any of the integer or floating-point number types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>生の値は、文字列、文字、または何らかの整数や浮動小数点数型であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Read-Only Computed Properties</seg>
      </tuv>
      <tuv lang="ja">
        <seg>読み出し専用の計算プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Readability is always preferred over brevity; use parentheses where they help to make your intentions clear.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>読みやすさは、常に簡潔さよりも好まれます；それらがあなたの意図を明確にする助けとなるところに丸括弧を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Reading the total amount during the process of adding an item gives you incorrect information.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある項目を追加する処理の間に総支出額を読み出すことは、あなたに正しくない情報を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Recursive Enumerations</seg>
      </tuv>
      <tuv lang="ja">
        <seg>再帰列挙</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Reference counting allows more than one reference to a class instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>参照カウントは、あるクラスインスタンスに対する１つ以上の参照を許します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Reference counting applies only to instances of classes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>参照カウントが唯一適用されるのは、クラスのインスタンスに対してです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Referring to Nested Types</seg>
      </tuv>
      <tuv lang="ja">
        <seg>入れ子にされた型を参照する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Remainder Operator</seg>
      </tuv>
      <tuv lang="ja">
        <seg>剰余演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Remainder and multiplication both associate with the expression to their left.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>剰余と乗算は、両方とも式をそれらの左と結びつけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Remove the day parameter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>dayパラメータを取り除いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Removed a duplicate description of the valid set of operator characters from Custom Operators.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>有効な演算子の一式の重複する説明をあつらえの演算子から取り除きました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Removed a note to the contrary.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これに反する注意書きを取り除きました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Removed discussion of C-style for loops, the ++ prefix and postfix operators, and the -- prefix and postfix operators.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>C形式forループ、++接頭辞および接尾辞演算子、そして--接頭辞および接尾辞演算子の議論を削除した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Removed discussion of variable function arguments and the special syntax for curried functions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>変数関数引数とカリー化関数のための特別な構文の議論を削除した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Removed the Dynamic Type Expression section from the Expressions chapter, now that type(of:) is a Swift standard library function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>「動的型式」の節を式の章から削除した、今ではtype(of:)はスウィフト標準ライブラリ関数であるので。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Removed the discussion of explicitly using let in function parameters from the Function Declaration section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>明示的にletを関数パラメータにおいて使用することの解説を節関数宣言から削除した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Removed the discussion of the Boolean protocol from the Statements chapter, now that the protocol has been removed from the Swift standard library.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Booleanプロトコルの解説を文の章から削除した、今ではこのプロトコルはスウィフト標準ライブラリから削除されてしまったので。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Removed the overflow division (&amp;/) and overflow remainder (&amp;%) operators from Overflow Operators.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オーバフロー除算（&amp;/）とオーバフロー剰余（&amp;%）演算子をオーバフロー演算子から削除しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Repeat-While</seg>
      </tuv>
      <tuv lang="ja">
        <seg>終わりに評価</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Repeat-While Statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>repeat-while文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Replace the _ with a variable name, and keep track of which kind of number was the largest.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>_を変数名で置き換えてください、そしてどの種類の数が最も大きかったか経過を追ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Representing and Throwing Errors</seg>
      </tuv>
      <tuv lang="ja">
        <seg>エラーの表現とスロー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Required Initializers</seg>
      </tuv>
      <tuv lang="ja">
        <seg>必須イニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Requiring exhaustiveness ensures that enumeration cases aren’t accidentally omitted.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>網羅性を要求することは、列挙ケース節のどれかがうっかり書き落とされないことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Resolving Explicit Redundancy</seg>
      </tuv>
      <tuv lang="ja">
        <seg>明示的な冗長性を解決する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Resolving Implicit Redundancy</seg>
      </tuv>
      <tuv lang="ja">
        <seg>暗黙的な冗長性を解決する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Resolving Strong Reference Cycles Between Class Instances</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスインスタンス間の強い参照循環の解消</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Resolving Strong Reference Cycles for Closures</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャのための強い参照循環の解消</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Restrictions for Nonescaping Closures</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非脱出クロージャに対する規制</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Result Builders</seg>
      </tuv>
      <tuv lang="ja">
        <seg>リザルトビルダー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Result Transformations</seg>
      </tuv>
      <tuv lang="ja">
        <seg>結果（リザルト）変換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Result-Building Methods</seg>
      </tuv>
      <tuv lang="ja">
        <seg>リザルトビルド（結果組立）メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Rethrowing Functions and Methods</seg>
      </tuv>
      <tuv lang="ja">
        <seg>再スローを行う関数とメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Rethrowing functions and methods must have at least one throwing function parameter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>再スロー関数とメソッドは、少なくとも１つのスロー関数パラメーターを持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Retrieve a value from the array by using subscript syntax, passing the index of the value you want to retrieve within square brackets immediately after the name of the array:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字構文を使うことで、ひとつの値をこの配列から取り出してください、あなたが取り出したい値の添え字（インデックス、指数）を、配列の名前の直後の角括弧内に入れて渡してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Return Statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>復帰文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Return values can be ignored, but a function that says it will return a value must always do so.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>戻り値は無視されることができます、しかし値を返すつもりだと言う関数は、常にそうしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Returning nil or an empty collection</seg>
      </tuv>
      <tuv lang="ja">
        <seg>nilまたは空のコレクションを返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Returning an Opaque Type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>不透明型を返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Returning an opaque type looks very similar to using a protocol type as the return type of a function, but these two kinds of return type differ in whether they preserve type identity.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>不透明型を返すことは、プロトコル型を関数の戻り型として使うことと大変よく似て見えます、しかしこれら２つの種類の戻り型は、それらが型同一性を保全するかどうかにおいて異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Returning the partially completed work</seg>
      </tuv>
      <tuv lang="ja">
        <seg>部分的に完了した作業を返す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Revision History</seg>
      </tuv>
      <tuv lang="ja">
        <seg>改訂履歴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Rewrite the closure to return zero for all odd numbers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このクロージャを、全ての奇数に対してゼロを返すように書き直してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Rewrote the Inheritance chapter to remove its introductory coverage of initializer overrides.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>章継承を書き直して、それの前置きのイニシャライザのオーバーライドを扱った部分を取り除きました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Rule 1</seg>
      </tuv>
      <tuv lang="ja">
        <seg>規則１</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Rule 2</seg>
      </tuv>
      <tuv lang="ja">
        <seg>規則２</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Rule 3</seg>
      </tuv>
      <tuv lang="ja">
        <seg>規則３</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Safety check 1</seg>
      </tuv>
      <tuv lang="ja">
        <seg>安全点検１</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Safety check 2</seg>
      </tuv>
      <tuv lang="ja">
        <seg>安全点検２</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Safety check 3</seg>
      </tuv>
      <tuv lang="ja">
        <seg>安全点検３</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Safety check 4</seg>
      </tuv>
      <tuv lang="ja">
        <seg>安全点検４</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Scalar values that have been assigned to a character typically also have a name, such as LATIN SMALL LETTER A and FRONT-FACING BABY CHICK in the examples above.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある文字に割り当てられるスカラー値は、たいてい名前を持っています、例えば以前の例でのLATIN SMALL LETTER AとFRONT-FACING BABY CHICKなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Second, even if dataSource does exist, there’s no guarantee that it implements increment(forCount:), because it’s an optional requirement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>第２に、たとえdataSourceが存在するとしても、それがincrement(forCount:)を実装する保証はありません、それがオプショナルの要件であるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Second, the two’s complement representation also lets you shift the bits of negative numbers to the left and right like positive numbers, and still end up doubling them for every shift you make to the left, or halving them for every shift you make to the right.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>第２に、２の補数表現はまた、あなたに負数のビットを左や右に正の数のようにシフトさせます、そして依然としてあなたが左へとするシフトは全てそれを２倍にすることで、またあなたが右へとするシフトは全てそれを半分にすることで終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>See Precedence and Associativity for an explanation of how these characteristics affect an infix operator’s interaction with other infix operators.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>優先順位と結合性をどのようにそれらの特徴が接中辞演算子の他の接中辞演算子との相互作用に影響を及ぼすかの解説として見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>See Special Characters in String Literals.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>更なる情報として、文字列リテラル内の特別な文字を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>See Overflow Operators.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オーバフロー演算子を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>See also Function Declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>また、関数宣言を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>See also Initializer Declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>また、イニシャライザ宣言を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>See also Protocol Associated Type Declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>また、プロトコル関連型宣言を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>See also Subscript Declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>また、添え字宣言を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>See also Type Alias Declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>また、型エイリアス宣言を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>See also Variable Declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>また、変数の宣言を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Selector Expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>セレクタ式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Self Expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>self式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Self Type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Self型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Semicolons</seg>
      </tuv>
      <tuv lang="ja">
        <seg>セミコロン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Separate each requirement in the list with a comma.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>リストの中の各要件をコンマで区切ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Set b and set c are disjoint with one another, because they share no elements in common.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>集合bと集合cは、他のものと互いに素です（交わりを持たない）、なぜならそれらが共通の要素を共有しないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Set a is a superset of set b, because a contains all elements in b.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>集合aは集合bの上位集合です、なぜならaがbのすべての要素を含むからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Set Membership and Equality</seg>
      </tuv>
      <tuv lang="ja">
        <seg>集合の帰属と等価性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Set Type Syntax</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Set型構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Sets</seg>
      </tuv>
      <tuv lang="ja">
        <seg>集合</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Sets are unordered collections of unique values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>集合は、順番をつけられないそれぞれが異なった値のコレクションです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Setting Initial Values for Stored Properties</seg>
      </tuv>
      <tuv lang="ja">
        <seg>初期値を格納プロパティに設定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Setting Initial Values for Wrapped Properties</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ラップされたプロパティに初期値を設定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Setting a Default Property Value with a Closure or Function</seg>
      </tuv>
      <tuv lang="ja">
        <seg>省略時のプロパティ値をクロージャまたは関数を使って設定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Setting the center property calls the setter for center, which modifies the x and y values of the stored origin property, and moves the square to its new position.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>centerプロパティを設定することは、centerのためのセッターを呼び出します、そしてそれは、格納されたoriginプロパティのxとy値を修正して、正方形をその新しい位置へと動かします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Setting the value of properties that the subclass declares.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>サブクラスが宣言するプロパティの値を設定する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Several methods that have special names enable syntactic sugar for function call syntax.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>特殊名を持つ幾つかのメソッドは、関数呼び出し構文に対して構文糖を可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Several of the switch statement’s cases bind their matched value to a constant of the specified type to enable its value to be printed:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>switch文のケース節のいくつかは、それらが適合した値を指定された型のある定数に結び付け、その値を出力できるようにします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Shifting Behavior for Signed Integers</seg>
      </tuv>
      <tuv lang="ja">
        <seg>符号つき整数のためのシフト挙動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Shifting Behavior for Unsigned Integers</seg>
      </tuv>
      <tuv lang="ja">
        <seg>符号なし整数のためのシフト挙動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Shifting an integer’s bits to the left by one position doubles its value, whereas shifting it to the right by one position halves its value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>整数のビットを位置１つだけ左へ移すことはその値を２倍にします、一方それを位置１つだけ右へ移すことはその値を半分にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Shorthand Argument Names</seg>
      </tuv>
      <tuv lang="ja">
        <seg>短縮形引数名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Shorthand Getter Declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>略記ゲッター宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Shorthand Setter Declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>短縮形セッター宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Shorthand argument names</seg>
      </tuv>
      <tuv lang="ja">
        <seg>短縮形引数名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Signed integers use their first bit (known as the sign bit) to indicate whether the integer is positive or negative.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>符号つき整数は、それらの最初のビット（符号ビットとして知られるもの）を使って、その整数が正であるか負であるかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similar to an if statement, you can add multiple conditional branches to test for different compilation conditions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>if文と同様に、あなたは複数の条件分岐を加えて、異なるコンパイル条件に対してテストすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, ###"Line1\###nLine2"### also breaks the line.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同様に、###"Line1\###nLine2"###もまた行を改めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, 0xFp-2 represents 15 x 2-2, which evaluates to 3.75.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じように、0xFp-2は15 × 2-2を表します、それは3.75に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, 1.25e-2 represents 1.25 x 10-2, which evaluates to 0.0125.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じように、1.25e-2は1.25 × 10-2を表します、それは0.0125に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, item is Song checks whether the item is a Song instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じように、item is Songはその項目がSongインスタンスであるか調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, a method marked with the nonobjc attribute can’t satisfy a protocol requirement for a method marked with the objc attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同様に、nonobjc属性で印されるメソッドは、objc属性で印されるメソッドに対するプロトコル要件を満たすことは出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, a stack allows items to be removed only from the end of the collection (known as popping a value off the stack).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じように、スタックは項目をコレクションの終わりからだけ取り除かれることが許されます（値をスタックからポップするとして知られます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, a subclass failable initializer can delegate up to a superclass failable initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じように、サブクラスの失敗できるイニシャライザは、スーパークラスの失敗できるイニシャライザにさかのぼって委任することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, a subscript can’t be more public than either its index type or return type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じように、添え字はそのインデックス型や戻り型よりも公開であることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, every Apartment instance has a unit property of type String and has an optional tenant property that’s initially nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じように、あらゆるApartmentインスタンスは、型Stringのunitプロパティを持って、初期時にはnilであるオプショナルのtenantプロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, if you have multiple nested loops, it can be useful to be explicit about which loop the continue statement should affect.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じように、あなたが複数の入れ子にされたループを持つならば、continue文が影響を及ぼさなければならないループはどれかについて明確にすることは役に立つでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, if you implement a didSet observer, it’s passed a constant parameter containing the old property value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じように、あなたがdidSetオブザーバーを実装するならば、それは古いプロパティ値を含んでいる定数パラメータを渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, if you try to create a CartItem instance with an empty name value, the superclass Product initializer causes initialization to fail:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同様に、あなたがCartItemインスタンスを空のname値で作成することを試みるならば、スーパークラスのProductイニシャライザは初期化が失敗する原因となります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, if you try to retrieve an Int? value through optional chaining, an Int? is always returned, no matter how many levels of chaining are used.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じように、あなたがオプショナル連鎖を通してInt?値を取り出そうと試すならば、Int?が常に返されます、どんなに多くの連鎖階層が使われようともです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, it can be convenient to define utility classes and structures purely for use within the context of a more complex type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じように、あくまでもより複雑な型の文脈内で使用するだけの有用なクラスや構造体を定義することは、便利でありえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, its second case matches all lowercase English consonants.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じように、その第二のケース節は、小文字の英語の子音すべてにマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, the SnakesAndLadders game class can be extended to adopt and conform to the TextRepresentable protocol:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じように、SnakesAndLaddersゲーム・クラスは、拡張されることで、TextRepresentableプロトコルを採用して準拠することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, the green component is obtained by performing a bitwise AND between the numbers 0xCC6699 and 0x00FF00, which gives an output value of 0x006600.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じように、緑の構成要素は数0xCC6699と0x00FF00との間のビット単位の論理積を実行することによって得られます、それは、0x006600の出力値を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, the second case, case (0, let y), matches any point with an x value of 0 and assigns the point’s y value to the temporary constant y.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じように、第二のケース節、case (0, let y)は、0のx値をもつどんなポイントにでも適合して、そのポイントのy値を一時的な定数yに代入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, the ternary conditional operator (a ? b : c) can’t be overloaded.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じように三項条件演算子（a ? b : c)は、オーバーロードされることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, there are 3.28084 feet in a meter, and so the ft computed property divides the underlying Double value by 3.28084, to convert it from feet to meters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じように、１メートルは3.28084フィートあります、なのでft計算プロパティは、もとのDouble値を3.28084で割って、それをフィートからメートルに変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, type methods on structures and enumerations can access type properties by using the type property’s name without a type name prefix.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じように、構造体と列挙の型メソッドは、型名前接頭辞なしで型プロパティの名前を使用することによって型プロパティにアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, use the hasSuffix(_:) method to count the number of scenes that take place in or around Capulet’s mansion and Friar Lawrence’s cell:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じように、hasSuffix(_:)メソッドを、キャビュレットの邸宅と修道士ローレンスの独居房の中または周囲で起こる場面の数を数えるために使用してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, you can create a dictionary to store values of any specified type, and there are no limitations on what that type can be.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じように、あなたはどんな指定された型の値それらでも保管する辞書を作成することができます、そしてその型が何であることができるか制限がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, you can omit part of a type when the full type can be inferred from context.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じように、前後関係から完全に型が推論されることができるとき、あなたはある型の一部を省略することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, you can try to set a new value through a subscript with optional chaining:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じように、あなたはオプショナル連鎖を使う添え字を通して、新しい値の設定を試みることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, you remove an item from the array with the remove(at:) method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じように、あなたはremove(at:)メソッドを使って配列から項目を取り除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Simple Values</seg>
      </tuv>
      <tuv lang="ja">
        <seg>単純な値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Simple statements are the most common and consist of either an expression or a declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>単純な文は、もっとも普通のもので、ひとつの式もしくはひとつの宣言から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Single line comments begin with // and continue until a line feed (U+000A) or carriage return (U+000D).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>一行コメントは//で始まります、そして行送り（U+000A）または復帰（U+000D）まで続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Single quotation mark (\')</seg>
      </tuv>
      <tuv lang="ja">
        <seg>一重引用符（\'０</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Single statement closures implicitly return the value of their only statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ひとつだけの文のクロージャは、暗黙のうちにそのただ１つの文の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Single-expression closures can implicitly return the result of their single expression by omitting the return keyword from their declaration, as in this version of the previous example:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>単一の式のクロージャは、前の例のこの改作のように、returnキーワードをそれらの宣言から省略することによって、暗黙的にそれのただ１つの式の結果を返すことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Some declaration attributes accept arguments that specify more information about the attribute and how it applies to a particular declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>若干の宣言属性は、属性に関するより多くの情報とそれが特定の宣言に適用される方法を指定する引数を受け入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Some operations aren’t guaranteed to always complete execution or produce a useful output.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>いくつかの操作は、常に実行を完了することや役に立つ出力を生成することを保証されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Some products are labeled with 1D barcodes in UPC format, which uses the numbers 0 to 9.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある製品はUPC形式の一次元バーコードでラベルをつけられます、それは0から9までの数字を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Some squares are then set to have more specific values for the snakes and ladders.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>いくつかの正方形は、それからヘビとはしごのためのより独特な値を持つように設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Some users might want fewer tick marks in their UI.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>幾人かのユーザは、より少ない目盛りを彼らのUIに望むかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Something similar happens when an unsigned integer is allowed to overflow in the negative direction.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>符号なし整数が負の向きにおいてオーバフローを認められるときに同じようなことが起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Sometimes it’s clear from a program’s structure that an optional will always have a value, after that value is first set.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>時々、プログラムの構造から、あるオプショナルが必ず値を持つことが、その値が最初に設定される結果として、はっきりしていることがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Sometimes you know a throwing function or method won’t, in fact, throw an error at runtime.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>時にはあなたはあるスロー関数またはメソッドが、実際のところ、実行時にエラーをスローすることがないのを知っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Special Characters in String Literals</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列リテラル内の特別な文字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Special Kinds of Methods</seg>
      </tuv>
      <tuv lang="ja">
        <seg>特別な種類のメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Special Kinds of Parameters</seg>
      </tuv>
      <tuv lang="ja">
        <seg>特別な種類のパラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Special characters can be included in string literals of both the single-line and multiline forms using the following escape sequences:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>特殊文字は、単一行および複数行形式の両方の文字列リテラルの中に以下のエスケープシーケンスを使って含められます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Special characters in a string delimited by extended delimiters appear in the resulting string as normal characters rather than as special characters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張区切り記号によって区切られた文字列は、結果文字列において普通の文字として現れます、特殊文字としてではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Specifically, a conflict occurs if you have two accesses that meet all of the following conditions:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>とりわけ、あなたが２つのアクセスを持ち以下の条件のすべてに出会う場合に、ある衝突が起こります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Specifically, an enumeration case without any associated values satisfies a protocol requirement for a get-only type variable of type Self, and an enumeration case with associated values satisfies a protocol requirement for a function that returns Self whose parameters and their argument labels match the case’s associated values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>とりわけ、どんな関連値を持たない列挙ケース節は、型Selfのある取得専用の型変数に対するプロトコル要件を満たします、そして関連値を持つ列挙ケース節は、Selfを返すある関数に対するプロトコル要件を満たします、それは、それのもつパラメータそれらとそれらの引数ラベルがケース節のもつ関連値それらと合致するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Specifically, if a failable initializer delegates to an initializer that fails and returns nil, then the initializer that delegated also fails and implicitly returns nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>具体的には、失敗できるイニシャライザが、ある失敗してnilを返すイニシャライザへ委任するならば、その時その委任した側のイニシャライザもまた失敗して暗黙的にnilを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Specifically, if the implied type is an optional you can use a value of the non-optional type, and if the implied type is a class type you can use a value of one of its subclasses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>具体的には、その暗黙的型がオプショナルであるとしてもあなたは非オプショナル型の値を使用できます、そしてその暗黙的型がクラス型であるならばあなたはそれのサブクラスの１つの値を使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Specifically, it can prove that overlapping access to properties of a structure is safe if the following conditions apply:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>とりわけ、関数のプロパティに対するオーバーラップアクセスが安全であることは、以下の条件が当てはまるならば立証できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Specifically, it declares a name property of type String, and an init name initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>特に、それは型Stringのnameプロパティ、そしてinit nameイニシャライザを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Specifically, it expresses whether the number is negative, zero, or positive.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>具体的には、それはその数が負、ゼロ、または正かを表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Specifically, it must ensure that only items of the right type are added to the container, and it must be clear about the type of the items returned by its subscript.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>具体的には、それは正しい型の項目だけがコンテナに加えられることを確実にしなければなりません、そして、それはそれの添え字によって返される項目の型についてはっきりわかっていなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Specifically, the property observer chooses a gear that’s the new currentSpeed value divided by 10, rounded down to the nearest integer, plus 1.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>具体的には、プロパティオブザーバーは、新しいcurrentSpeed値を10で割って、最も近い整数に丸めて、1を加えたギアを選びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Specifically, the result of an optional chaining call is of the same type as the expected return value, but wrapped in an optional.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>具体的には、オプショナル連鎖の呼び出しの結果は、期待される戻り値と同じ型ですが、オプショナルの中にラップされています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Specifically, you can use a key path expression whose root type is SomeType and whose path produces a value of type Value, instead of a function or closure of type (SomeType) -&gt; Value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>とりわけ、あなたはそれのルート型がSomeTypeでそれのパスが型Valueの値を生み出すキーパス式を、型(SomeType) -&gt; Valueの関数またはクロージャの代わりに使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Specifying Argument Labels</seg>
      </tuv>
      <tuv lang="ja">
        <seg>引数ラベルを指定する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Specifying Cleanup Actions</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クリーンアップ動作の指定</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Square 3 contains the bottom of a ladder that moves you up to square 11.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>正方形３は、正方形11まであなたを動かすはしごの底を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Squares with a ladder base have a positive number to move you up the board, whereas squares with a snake head have a negative number to move you back down the board.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>はしごの接地面がある正方形は、あなたを盤の上方に動かすために正の番号を持ちます、一方でヘビの頭のある正方形は、あなたを逆に盤の下に動かすために負の数を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Statements</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Static string literals can’t use features like string interpolation or concatenation, but they can use the multiline string literal syntax.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>静的文字列リテラルは、文字列補間や連結のような機能を使えません、しかしそれらは複数行文字列リテラル構文を使えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Stopping execution as soon as an invalid state is detected also helps limit the damage caused by that invalid state.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>無効な状態が検知されるやいなや実行を停止することはまた、その無効な状態によって起こされる被害を抑えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Stored Properties</seg>
      </tuv>
      <tuv lang="ja">
        <seg>格納プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Stored Properties and Instance Variables</seg>
      </tuv>
      <tuv lang="ja">
        <seg>格納プロパティとインスタンス変数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Stored Properties of Constant Structure Instances</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数構造体インスタンスの格納プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Stored Variable Observers and Property Observers</seg>
      </tuv>
      <tuv lang="ja">
        <seg>格納された変数オブザーバーとプロパティオブザーバー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Stored Variables and Stored Variable Properties</seg>
      </tuv>
      <tuv lang="ja">
        <seg>格納変数と格納変数プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Stored and computed properties are usually associated with instances of a particular type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>格納されるもしくは計算されるプロパティは、通常は特定の型のインスタンスに結び付けられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Stored properties are constants or variables that are bundled up and stored as part of the structure or class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>格納プロパティは、構造体またはクラスの一部としてまとめられて格納される定数または変数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Stored properties are provided only by classes and structures.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>格納プロパティは、クラスと構造体だけで提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Stored properties can be either variable stored properties (introduced by the var keyword) or constant stored properties (introduced by the let keyword).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>格納プロパティは、変数格納プロパティ（varキーワードによって導入される）か定数格納プロパティ（letキーワードによって導入される）であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Stored properties can’t be left in an indeterminate state.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>格納プロパティは、不確定な状態のままにされることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Stored properties store constant and variable values as part of an instance, whereas computed properties calculate (rather than store) a value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>格納プロパティは、あるインスタンスの一部として定数と変数の値を格納します、一方で、計算プロパティは、値を（たくわえておくのではなく）計算します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Stored properties that you define</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが定義する格納プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Stored properties that you inherit</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが継承する格納プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Stored type properties are lazily initialized on their first access.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>格納型プロパティは、それらの最初のアクセスにおいて遅延して初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Stored type properties can be variables or constants.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>格納プロパティは、変数または定数であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Stored variables, like stored properties, provide storage for a value of a certain type and allow that value to be set and retrieved.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>格納変数は、格納プロパティの様に、保管場所を特定の型のひとつの値のために用意して、その値の設定と取得を可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Strictly speaking, initializers don’t return a value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>厳密にいえば、イニシャライザは値を返しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Strictly speaking, this version of the greet(person:) function does still return a value, even though no return value is defined.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>厳密に言って、たとえ戻り値が定義されないとしても、このバージョンのgreet(person:)関数は、まだ値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Strictly speaking, you can write a custom class that conforms to CounterDataSource without implementing either protocol requirement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>厳密に言って、あなたはCounterDataSourceに準拠する特注のクラスを書くことが両方のプロトコル要件を満たすことなく可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>String Indices</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列インデックス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>String Interpolation</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列補間</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>String Literals</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列リテラル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>String Mutability</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列の可変性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>String and Character Equality</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列と文字の同等性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>String and character comparisons in Swift aren’t locale-sensitive.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列および文字の比較はスウィフトではロケールに影響されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>String and character equality is checked with the “equal to” operator (==) and the “not equal to” operator (!=), as described in Comparison Operators:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列と文字の同等性は、「同等」演算子（==）および「不等」演算子（!=）で調べられます、これは比較演算子で記述されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>String literals can include the following special characters:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列リテラルは、以下の特別な文字を含むことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>String literals can’t contain an unescaped double quotation mark ("), an unescaped backslash (\), a carriage return, or a line feed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列リテラルは、エスケープされない二重引用符（"）、エスケープされないバックスラッシュ（\）、キャリッジリターン、またはラインフィードを含むことが出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>String literals created using extended delimiters can also be multiline string literals.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張区切り文字を使って作成される文字列リテラルは、また複数行文字列リテラルであることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>String literals that are concatenated by the + operator are concatenated at compile time.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>+演算子によって連結される文字列リテラルは、コンパイル時に連結されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Strings Are Value Types</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列は値型です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Strings and Characters</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列と文字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Strong Reference Cycles Between Class Instances</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスインスタンス間の強い参照循環</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Strong Reference Cycles for Closures</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャのための強い参照循環</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Structure Declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Structure and Class Instances</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体とクラスのインスタンス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Structure and enumeration methods that modify self or its properties must mark the instance method as mutating, just like mutating methods from an original implementation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>selfまたはそのプロパティを修正する構造および列挙メソッドは、ちょうど最初の実施からの変更メソッドのように、そのインスタンスメソッドにmutatingとして印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Structure declarations are declared using the struct keyword and have the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体宣言は、キーワードstructを使って宣言されて、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Structure declarations can’t contain deinitializer or protocol declarations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造宣言は、デイニシャライザまたはプロトコル宣言を含むことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Structure types automatically receive a memberwise initializer if they don’t define any of their own custom initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体型は、それが独自のあつらえのイニシャライザを何ら定義しないならば、自動的にメンバー関連イニシャライザを受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Structure types can adopt any number of protocols, but can’t inherit from classes, enumerations, or other structures.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体型は、随意の数のプロトコルに準拠することができます、しかしクラス、列挙、または他の構造体から継承することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Structure, enumeration, and class types can have any number of initializers, but the rules and associated behavior for class initializers are different.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体、列挙、そしてクラス型は、随意の数のイニシャライザを持つことができます、しかし、クラスイニシャライザのための規則および関連する挙動は異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Structures and Classes</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体とクラス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Structures and Enumerations Are Value Types</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体と列挙は値型です</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Structures and classes both use initializer syntax for new instances.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体とクラスは両方とも、新しいインスタンスのためにイニシャライザ構文を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Structures and classes have a similar definition syntax.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体とクラスは、類似した定義構文を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Structures and classes in Swift have many things in common.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトでの構造体とクラスは、多くのものを共通して持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Structures and enumerations are value types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体と列挙は、値型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Structures and enumerations are value types, not reference types, and aren’t stored and passed by reference.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造と列挙は値型であって、参照型ではありません、そして参照によって格納されたり渡されたりしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Structures and enumerations don’t allow shared mutability, as discussed in Structures and Enumerations Are Value Types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体と列挙は、共有された可変性を許可しません、構造体と列挙は値型ですで記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Structures and enumerations that conform to the protocol declare the method with the static keyword, and classes that conform to the protocol declare the method with either the static or class keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのプロトコルに準拠する構造体と列挙は、staticキーワードでメソッドを宣言します、そしてそのプロトコルに準拠するクラスは、staticまたはclassキーワードのどちらかでメソッドを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Structures and enumerations that conform to the protocol declare the property with the static keyword, and classes that conform to the protocol declare the property with either the static or class keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのプロトコルに準拠する構造体と列挙は、staticキーワードでプロパティを宣言します、そしてそのプロトコルに準拠するクラスは、staticまたはclassキーワードのどちらかでプロパティを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Structures and enumerations that conform to the protocol declare the subscript with the static keyword, and classes that conform to the protocol declare the subscript with either the static or class keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのプロトコルに準拠する構造体と列挙は、staticキーワードで添え字を宣言します、そしてそのプロトコルに準拠するクラスは、staticまたはclassキーワードのどちらかで添え字を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Structures are value types; instances of a structure are copied when assigned to variables or constants, or when passed as arguments to a function call.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体は、値型です；構造体のインスタンスは、変数や定数に代入される時、または引数として関数呼び出しに渡される時にコピーされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Structures support many of the same behaviors as classes, including methods and initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体は、クラスと同じ挙動の多くを、メソッドとイニシャライザも含めてサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Structures that have only stored properties that conform to the Equatable protocol</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Equatableプロトコルに準拠する格納プロパティだけを持つ構造体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Structures that have only stored properties that conform to the Hashable protocol</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Hashableプロトコルに準拠する格納プロパティだけを持つ構造体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Subclasses can modify inherited variable properties during initialization, but can’t modify inherited constant properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>サブクラスは、初期化の間に継承された変数プロパティを修正することできます、しかし継承された定数プロパティを変更することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Subclasses can themselves be subclassed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>サブクラスは、それ自身サブクラスを作られることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Subclasses can use a superclass expression in their implementation of members, subscripting, and initializers to make use of the implementation in their superclass.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>サブクラスは、そのメンバー、添え字、そしてイニシャライザの実装においてスーパークラス式を使うことで、それらのスーバークラス内の実装を活用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Subclasses include their superclass name after their class name, separated by a colon.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>サブクラスそれらは、それらのクラス名の後に、コロンで区切られた、それらのスーパークラス名を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Subclassing</seg>
      </tuv>
      <tuv lang="ja">
        <seg>サブクラスをつくる</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Subscript Declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Subscript Expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Subscript Options</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字オプション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Subscript Syntax</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字の構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Subscript Usage</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字の使用法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Subscript declarations are declared using the subscript keyword and have the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字宣言は、キーワードsubscriptを使って宣言されて、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Subscript declarations can appear only in the context of a class, structure, enumeration, extension, or protocol declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字宣言は、クラス、構造体、列挙、拡張、またはプロトコル宣言の文脈においてだけ、現れることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Subscript declarations only declare the minimum getter and setter implementation requirements for types that conform to the protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字宣言は、プロトコルに準拠する型のための最小限のゲッターとセッター実装要件を宣言するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Subscript parameters follow the same rules as function parameters, with two exceptions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字パラメータは、関数パラメータと同じ規則に従います、２つの例外で。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Subscripts</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Subscripts are typically used as a shortcut for accessing the member elements in a collection, list, or sequence.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字は、一般的に、コレクション、リスト、またはシーケンスの中のメンバー要素にアクセスするための近道として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Subscripts aren’t limited to a single dimension, and you can define subscripts with multiple input parameters to suit your custom type’s needs.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字は１つの次元に制限されません、なのであなたは複数の入力パラメータをもつ添え字を定義して、あなたのあつらえの型の必要を満たすことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Subscripts can also return a value of any type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字はまた、任意の型の値を返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Subscripts can be generic, and they can include generic where clauses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字は総称体であることができます、そしてそれらは総称体where節を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Subscripts can take any number of input parameters, and these input parameters can be of any type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字は、任意の数の入力パラメータをとることができます、そしてこれらの入力パラメータはどんな型でもかまいません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Subscripts enable you to query instances of a type by writing one or more values in square brackets after the instance name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字は、あなたにそのインスタンス名の後で角括弧の中に１つ以上の値を書くことによって、ある型のインスタンスに問い合わせることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Substrings</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下位文字列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Substrings in Swift have most of the same methods as strings, which means you can work with substrings the same way you work with strings.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトでの下位文字列は、文字列とほとんど同じメソッドを持ちます、それはあなたが下位文字列を、文字列を扱うのと同じ方法で扱えることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Subtracting 1 from this binary number with the overflow operator gives a binary value of 01111111, which toggles the sign bit and gives positive 127, the maximum positive value that an Int8 can hold.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この２進数からオーバフロー演算子を使って1を減ずることは、２進数の01111111を与えます、それは符号ビットを切り替えて正の127、Int8が持つことができる最大限の正の値、を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Subtraction (-)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>減算（-）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Such properties are known as type properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのようなプロパティは、型プロパティとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Summary of the Grammar</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文法の概要</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Superclass Expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スーパークラス式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Superclass deinitializers are always called, even if a subclass doesn’t provide its own deinitializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スーパークラスのデイニシャライザは、たとえサブクラスがそれ自身のデイニシャライザを提供しないとしても、常に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Superclass deinitializers are inherited by their subclasses, and the superclass deinitializer is called automatically at the end of a subclass deinitializer implementation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スーパークラスのデイニシャライザは、それらのサブクラスそれらによって継承されます、そして、スーパークラスのデイニシャライザはサブクラスのデイニシャライザ実施の終わりに自動的に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Superclass initializers are inherited in certain circumstances, but only when it’s safe and appropriate to do so.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スーパークラスのイニシャライザはある特定の状況において継承されます、しかしそれが安全にそして適切にそうできる時だけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Suspending and resuming code in your program lets it continue to make progress on short-term operations like updating its UI while continuing to work on long-running operations like fetching data over the network or parsing files.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コードをあなたのプログラムにおいて中断および再開することは、それに、データをネットワーク越しに取ってくるまたはファイルを構文解析するといった長く続く演算に取り組み続けている間に、それのUIを更新するといった短期間の演算の進捗を継続させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift allows this memory-safe code if the compiler can prove that the nonexclusive access to memory is still safe.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、メモリへの非排他アクセスが依然として安全であるとコンパイラが立証できるならば、このメモリ安全コードを許可します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift also handles all memory management involved in disposing of variables when they’re no longer needed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトはまた、それがもはや必要とされないとき変数を処分することに関わるすべての記憶管理を取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift also introduces optional types, which handle the absence of a value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトはまたオプショナルの型を導入します、それは値の欠如を取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift also makes extensive use of variables whose values can’t be changed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトはまた、それの値が変更されることができない変数を広範囲に利用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift also makes sure that multiple accesses to the same area of memory don’t conflict, by requiring code that modifies a location in memory to have exclusive access to that memory.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトはまた、同じメモリ領域に対する複数のアクセスが衝突しないことを、メモリ中の位置を修正するコードにそのメモリに対する排他的アクセスを持つよう要求することによって確保します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift also provides unsafe unowned references for cases where you need to disable runtime safety checks—for example, for performance reasons.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトはまたunsafe非所有参照を、あなたが実行時安全確認を無効にする必要がある場合のために提供します — 例えば、性能上の理由のために。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift also provides a for-in loop that makes it easy to iterate over arrays, dictionaries, ranges, strings, and other sequences.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトはまた、for-inループを提供します、それは、配列、辞書、範囲、文字列、およびその他のシーケンス（連続したもの）の全体にわたって繰り返し処理するのを簡単にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift also provides an unsigned integer type, UInt, which has the same size as the current platform’s native word size:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトはまた、符号なし整数型、UIntを提供します、そしてそれは、現在のプラットホーム固有のワードサイズと同じ大きさを持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift also provides powerful versions of the three primary collection types, Array, Set, and Dictionary, as described in Collection Types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトはまた、３つの主要なコレクション型、Array、Set、そしてDictionaryの強力なバージョンを提供します、それは「コレクション型」で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift also provides range operators that aren’t found in C, such as a..&lt;b and a...b, as a shortcut for expressing a range of values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトはまた、Cでは見られない範囲演算子、例えばa..&lt;bとa...bを、値の範囲を表す近道として提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift also provides two identity operators (=== and !==), which you use to test whether two object references both refer to the same object instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトはまた、２つの同一性演算子を提供します（===と!==）、それはあなたが２つのオブジェクト参照が両方とも同じオブジェクト・インスタンスに言及するかどうかについて調べるために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift always chooses Double (rather than Float) when inferring the type of floating-point numbers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>浮動小数点数の型を推論するとき、スウィフトは常にDoubleを選びます（Floatではなく）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift automatically deallocates your instances when they’re no longer needed, to free up resources.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは自動的に、それらがもはや必要とされない場合はあなたのインスタンスを割り当て解除して、資源を自由に使えるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift automatically propagates errors out of their current scope until they’re handled by a catch clause.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは自動的に、エラーをそれの現在のスコープの外に、それがcatch節によって取り扱われるまで伝えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift automatically provides shorthand argument names to inline closures, which can be used to refer to the values of the closure’s arguments by the names $0, $1, $2, and so on.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは行内クロージャに自動的に短縮形引数名を提供します、そしてそれは、名前$0、$1、$2、などにでクロージャの引数の値に言及するために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift can automatically provide the protocol conformance for Equatable, Hashable, and Comparable in many simple cases.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、自動的にプロトコル準拠をEquatable、Hashable、そしてComparableに対して提供することが多くの単純な場合において可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift can infer associated types, which lets you use an opaque return value in places where a protocol type can’t be used as a return value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは関連型を推論できます、それはあなたに不透明戻り値を、プロトコル型が戻り値として使われることができないところあちこちで使用させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift can therefore infer that Element is the appropriate type to use as the Item for this particular container.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、したがってElementが、この特定のコンテナのためのItemとして使うのに適当な型であると推測することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift classes don’t inherit from a universal base class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトのクラスそれらは、ひとつの共通の基盤クラスから継承はしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift code is compiled and optimized to get the most out of modern hardware.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトコードは、モダンなハードウェアを最大限活用するようにコンパイルおよび最適化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift combines powerful type inference and pattern matching with a modern, lightweight syntax, allowing complex ideas to be expressed in a clear and concise manner.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、強力な型インターフェイスおよびパターンマッチングをモダンで、軽量な構文と結び付けて、複雑なアイデアが明瞭で簡潔な流儀で表されるようにしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift concurrency uses a cooperative cancellation model.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフト並行性は、協調取り消しモデルを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift defines a Never type, which indicates that a function or method doesn’t return to its caller.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトはNever型を定義します、それはある関数またはメソッドがそれの呼び出し側に帰らないことを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift defines away large classes of common programming errors by adopting modern programming patterns:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、よくあるプログラミング過失のうちの主要な種類を、以下のモダンなプログラミングパターンを採用することによって遠ざけます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift defines numerous precedence groups to go along with the operators provided by the standard library.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、標準ライブラリによって提供される演算子と一緒にやっていくために、多数の優先順位グループを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift defines two kinds of initializers for class types to help ensure all stored properties receive an initial value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、クラス型のために２種類のイニシャライザを定義して、全ての格納プロパティが初期値を受け取ることを確実にするのを手伝います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift enumeration cases don’t have an integer value set by default, unlike languages like C and Objective-C.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフト列挙は、CおよびObjective-Cのような言語と違い、初期状態で設定される整数値を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift enumerations are particularly well suited to modeling a group of related error conditions, with associated values allowing for additional information about the nature of an error to be communicated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフト列挙は、あるエラーの性質についての追加情報が通信されるのを想定した関連値を含め、関係のあるエラー状況のグループを作るのにうってつけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift exposes a collection of all the cases as an allCases property of the enumeration type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、ケース節すべてからなるコレクションを、列挙型のallCasesプロパティとして公開します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift gives you a warning if you use an optional value where a value of type Any is expected.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、あなたがオプショナル値を型Anyが期待されるところで使うならば警告を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift gives you the freedom to define your own custom infix, prefix, postfix, and assignment operators, with custom precedence and associativity values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、あなたに、特注の優先順位と結合性値で、あなた自身のあつらえの接中辞、接頭辞、接尾辞、そして代入演算子を定義する自由を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift guarantees that only code inside an actor can access the actor’s local state.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、あるアクター内部のコードだけが、そのアクターのもつローカル状態にアクセス可能であることを保証します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift handles all of the memory management of capturing for you.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、キャプチャ（その瞬間の保存）の記憶管理の全てを、あなたのために取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift handles the memory management of instances through automatic reference counting (ARC), as described in Automatic Reference Counting.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、自動参照カウントで記述されるように、インスタンスのメモリ管理を自動参照カウント（ARC）を通して取り扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift has a basic Boolean type, called Bool.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、ひとつの基本的なブール型を持ちます、それはBoolと呼ばれるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift has been years in the making, and it continues to evolve with new features and capabilities.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトはその作成に幾年かを費やしています、そしてそれは新しい特徴と能力で発展し続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift has built-in support for checking API availability, which ensures that you don’t accidentally use APIs that are unavailable on a given deployment target.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、API有効性確認のための組み込みのサポートを持ちます、それはあなたが特定の開発対象で有効でないAPIをうっかり使うことがないのを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift has built-in support for writing asynchronous and parallel code in a structured way.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、非同期のそして並列なコードをある構造化された方法で書くための組込みのサポートを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift has five control transfer statements:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、５つの制御移動文を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift has five control transfer statements: a break statement, a continue statement, a fallthrough statement, a return statement, and a throw statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、５つの制御移動文を持ちます：break文、continue文、fallthrough文、return文、そしてthrow文。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift has three branch statements: an if statement, a guard statement, and a switch statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、３つの分岐文を持ちます：if文、guard文、そしてswitch文。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift has three compiler control statements: a conditional compilation block a line control statement, and a compile-time diagnostic statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、３つのコンパイラ制御文：条件コンパイルブロック、行制御文、そしてコンパイル時診断文を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift has three loop statements: a for-in statement, a while statement, and a repeat-while statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、３つのループ文を持ちます：for-in文、while文、そしてrepeat-while文。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift helps to ensure your overrides are correct by checking that the override definition has a matching superclass definition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、あなたの無効化が正しいものであることを、その無効化定義がスーパークラス定義に合致するのを確認することによって確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift includes several range operators, which are shortcuts for expressing a range of values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、いくつかの範囲演算子を含みます、それらは値の範囲を表す近道です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift is a type-safe language, which means the language helps you to be clear about the types of values your code can work with.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは型安全な言語です、それが意味するのは、この言語があなたを助けて、あなたのコードが扱うことができる値の型について明確であるようにすることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift is a type-safe language.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、型安全な言語です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift is a fantastic way to write software, whether it’s for phones, desktops, servers, or anything else that runs code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトはソフトウェアを記述する素晴らしい方法です、コードを実行するのが電話、デスクトップ、サーバー、または何か他のものであろうともです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift is a new programming language for iOS, macOS, watchOS, and tvOS app development.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、iOS、macOS、watchOS、そしてtvOSアプリ開発のための新しいプログラミング言語です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift is a type-safe language, and doesn’t allow (for example) a variable of type String and a variable of type Double to swap values with each other.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは型安全な言語です、それで（例えば）型Stringの変数と型Doubleの変数にお互いに値を交換させることをしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift is friendly to new programmers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、新規プログラマーに好意的です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift lets you express your intent in a way that enables some compile-time checking—for example, you can use actors to safely access mutable state.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、あなたにあなたの意図をある方法、何らかのコンバイル時での検査を可能にするもので表現させます — 例えば、あなたはアクターを使用して、可変な状態に安全にアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift makes it easy to provide tailored implementations of these operators and to determine exactly what their behavior should be for each type you create.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、それら演算子の注文仕立ての実装を提供することについて、そしてそれらの挙動があなたがつくる各型のために正確にどういったものでなければならないかについて決定することを簡単にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift marks redundant protocol conformances as an error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、冗長なプロトコル準拠をエラーであると印します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift now has a Nil-Coalescing Operator (a ?? b), which unwraps an optional’s value if it exists, or returns a default value if the optional is nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは今やnil合体演算子（a ?? b）をもちます、それはあるオプショナルの値を、もしそれが存在するならばアンラップします、またはそのオプショナルがnilならばある省略時の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift now has a native Set collection type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは今では持って生まれたSetコレクション型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift now includes the as? and as! failable downcast operators.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは今では失敗できるダウンキャスト演算子as?とas!を含めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift picks which implementation of log() to call by consulting only the minimum requirements that Pair needs to conform to Loggable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、log()の実装のどれを呼び出すかの選択を、PairがLoggableに準拠するために必要とする最小限の要件のみを考慮することで行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift produces a warning if the default case matches any enumeration case that’s known at compiler time.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは警告を生成します、もしそのdefaultケース節がコンパイル時に既知である何らかの列挙ケース節に合致するならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift provides a default initializer for any structure or class that provides default values for all of its properties and doesn’t provide at least one initializer itself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、それのもつプロパティの全てに省略時の値を与えて、ともかく１つのイニシャライザもそれ自身では提供しないあらゆる構造体またはクラスのために、省略時のイニシャライザを用意します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift provides a synthesized implementation of Comparable for enumerations that don’t have a raw value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、Comparableの合成実装を生の値を持たない列挙に提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift provides a synthesized implementation of Equatable for the following kinds of custom types:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、Equatableの合成実装を以下の種類のあつらえの型に提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift provides a synthesized implementation of Hashable for the following kinds of custom types:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、Hashableの合成実装を以下の種類のあつらえの型に提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift provides a variety of control flow statements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、さまざまな制御の流れ文を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift provides an additional integer type, Int, which has the same size as the current platform’s native word size:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは追加の整数型、Intを提供します、そしてそれは、現在のプラットホーム固有のワードサイズと同じ大きさを持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift provides an elegant solution to this problem, known as a closure capture list.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトはこの問題の洗練された解答、クロージャ捕獲リストとして知られるものを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift provides first-class support for throwing, catching, propagating, and manipulating recoverable errors at runtime.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、回復可能なエラーのスロー、キャッチ、伝達、そして取り扱いに対してファーストクラスのサポートを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift provides five different access levels for entities within your code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、５つの異なるアクセス水準をあなたのコード内の実在に対して用意します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift provides five levels of access control: open, public, internal, file private, and private.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、５つの水準のアクセス制御を提供します：公開、内部、そして非公開。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift provides its own versions of all fundamental C and Objective-C types, including Int for integers, Double and Float for floating-point values, Bool for Boolean values, and String for textual data.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、全ての基本的なCおよびObjective-C型に関してそれ自身のバージョンを提供します、それには、整数のためのInt、浮動小数点値のためのDoubleとFloat、ブール値のためのBool、そして、文字情報データのためのStringを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift provides several different ways to access Unicode representations of strings.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、文字列のUnicode表現にアクセスするためにいくつかの異なる方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift provides signed and unsigned integers in 8, 16, 32, and 64 bit forms.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、８、16、32、そして64ビット形式で、符号つきおよび符号なし整数を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift provides the following Interface Builder attributes: IBAction, IBSegueAction, IBOutlet, IBDesignable, and IBInspectable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、以下のインターフェイスビルダー属性を提供します：IBAction、IBSegueAction、IBOutlet、IBDesignable、そしてIBInspectable。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift provides three arithmetic overflow operators that opt in to the overflow behavior for integer calculations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、整数計算のためにオーバフロー挙動を選択する３つの算術オーバフロー演算子を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift provides three primary collection types, known as arrays, sets, and dictionaries, for storing collections of values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは３つの主要なコレクション型を提供します、それらは配列、集合、そして辞書として知られ、値の集まり（コレクション）をしまっておくためのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift provides three ways to compare textual values: string and character equality, prefix equality, and suffix equality.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、テキスト関連の値を比較する３つの方法を提供します：文字列および文字の等式、接頭辞等式、そして接尾辞等式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift provides two Boolean constant values, true and false:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは２つのブールの定数値、trueとfalseを提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift provides two forms of syntactic sugar for initialization of a property wrapper.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、２つの形式の糖衣構文をプロパティラッパーの初期化に対して提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift provides two kinds of while loops:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは２種類のwhileループを提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift provides two signed floating-point number types:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、２つの符号つき浮動小数点数型を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift provides two special types for working with nonspecific types:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、２つの特別な型を「不特定」の型を扱うために提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift provides two ways to add conditional branches to your code: the if statement and the switch statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは条件分岐をあなたのコードに加える２つの方法：if文とswitch文を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift provides two ways to resolve strong reference cycles when you work with properties of class type: weak references and unowned references.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがクラス型のプロパティを扱うとき、スウィフトは強い参照循環を解消する２つの道を提供します：弱い参照と非所有参照。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift reports an error at compile time if you try to use an API that isn’t available.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、あなたが有効でないAPIを使おうと試みるならば、コンパイル時にエラーを報告します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift requires you to write self.someProperty or self.someMethod() (rather than just someProperty or someMethod()) whenever you refer to a member of self within a closure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトはあなたにself.somePropertyまたはself.someMethod()（ただ単にsomePropertyまたはsomeMethod()ではなく）を書くことを、あなたがクロージャ内でselfのメンバーに言及するときはいつでも、要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift strings are represented by the String type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトの文字列はString型によって表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift supports all of the bitwise operators found in C, as described below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、下記のように、Cで見つけられるビット単位演算子の全てをサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift supports the following comparison operators:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、以下の比較演算子をサポートします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift supports the four standard arithmetic operators for all number types:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、４つの標準の算術演算子を数の型すべてに対してサポートします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift supports the operators you may already know from languages like C, and improves several capabilities to eliminate common coding errors.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、あなたがCのような言語から既に知っているかもしれない演算子をサポートします、そしていくつかの能力を向上させることで一般的なコード記述エラーを排除します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift supports the three standard logical operators found in C-based languages:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、Cに基づく言語で見られる３つの標準の論理演算子をサポートします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift transforms that declarative description of a drawing into a series of calls to the methods on DrawingBuilder to build up the value that’s passed as the function argument.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、ある描画の宣言的な記述をDrawingBuilder上のメソッドへの一連の呼び出しに変換することで、関数引数として渡される値を作り上げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift transforms the if-else block into calls to the buildEither(first:) and buildEither(second:) methods.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、if-elseブロックをbuildEither(first:)とbuildEither(second:)メソッドへの呼び出しへと変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift treats the assignment like a wrappedValue argument and uses the initializer that accepts the arguments you include.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、その代入をwrappedValue引数のように扱います、そしてあなたが含める引数を受け入れるイニシャライザを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift unifies these concepts into a single property declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、これらの概念をだだ１つのプロパティ宣言に統一します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift uses Automatic Reference Counting (ARC) to track and manage your app’s memory usage.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、あなたのアプリのメモリ使用を追跡して管理するために、自動参照カウント（ARC）を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift uses capture lists to break these strong reference cycles.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、これらの強い参照循環を壊すために捕獲リストを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift uses string interpolation to include the name of a constant or variable as a placeholder in a longer string, and to prompt Swift to replace it with the current value of that constant or variable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは、定数または変数の名前をより長い文字列の中にプレースホルダーとして含めるために、そしてそれをその定数または変数の現在の値と取り替えることをスウィフトに促すために、文字列補間を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift uses type inference extensively, allowing you to omit the type or part of the type of many variables and expressions in your code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトは広く型推論を使います、そして、あなたのコードにおいて多くの変数および式の型または型の一部をあなたが省略できるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift’s Array type already provides an append(_:) method, a count property, and a subscript with an Int index to retrieve its elements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトのArray型は、すでにappend(_:)メソッド、countプロパティ、そしてその要素を取り出すためにIntインデックスを使う添え字を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift’s Array type also provides an initializer for creating an array of a certain size with all of its values set to the same default value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトのArray型はまた、その値の全てが提供された同じ初期値に設定される、特定の大きさの配列をつくるためにイニシャライザを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift’s Array type is bridged to Foundation’s NSArray class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトのArray型はFoundationのNSArrayクラスにブリッジ（橋渡し）されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift’s Array type now has full value semantics.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトのArray型は現在は完全な値意味論を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift’s Dictionary type doesn’t have a defined ordering.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトのDictionary型は、決まった順序を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift’s Dictionary type implements its key-value subscripting as a subscript that takes and returns an optional type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトのDictionary型は、それの「キーと値」に関する添え字を、オプショナル型を受け取り返す添え字として実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift’s Dictionary type is bridged to Foundation’s NSDictionary class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトのDictionary型は、FoundationのNSDictionaryクラスにブリッジ（橋渡し）します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift’s Int type has an initializer which tries to convert a String value into an Int value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトのInt型はあるイニシャライザを持ちます、それはString値をInt値に変換することを試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift’s Set type doesn’t have a defined ordering.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトのSet型は、決まった順序を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift’s Set type is bridged to Foundation’s NSSet class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトのSet型は、FoundationのNSSetクラスにブリッジ（橋渡し）されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift’s String and Character types provide a fast, Unicode-compliant way to work with text in your code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトのStringおよびCharacter型は、あなたのコードにおいてテキストを処理するために、ある高速な、Unicodeに対応したやり方を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift’s String type is a value type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトのString型は、値型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift’s String type is bridged with Foundation’s NSString class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトのString型は、FoundationのNSStringクラスを使って橋渡しをされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift’s nil isn’t the same as nil in Objective-C.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトのnilは、Objective-Cでのnilと同じものではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift’s switch statement is considerably more powerful than its counterpart in many C-like languages.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトのswitch文は、多くのCに似た言語において相当する物よりずっと強力です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift’s String and Character types are fully Unicode-compliant, as described in this section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトのStringとCharacter型は、この節で記述されるように、完全にUnicodeに対応しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift’s String type defines its string-specific implementation of the greater-than operator (&gt;) as a method that has two parameters of type String, and returns a value of type Bool.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトのString型は、それの文字列特有の実装の「大なり」演算子（&gt;）をメソッドとして定義します、それは型Stringの２つのパラメータを持ち、型Boolの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift’s access control model is based on the concept of modules and source files.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトのアクセス制御モデルは、モジュールとソースファイルの概念に基づきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift’s approach prevents a situation in which a simple initializer from a superclass is inherited by a more specialized subclass and is used to create a new instance of the subclass that isn’t fully or correctly initialized.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトの取り組み方は、スーパークラスのもつ単純なイニシャライザがより特殊化されたサブクラスによって継承されて、充分にまたは正しく初期化されない状態の、サブクラスの新しいインスタンスをつくるのに使われる状況を防ぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift’s array, set, and dictionary types are implemented as generic collections.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトの配列、集合、そして辞書型は、総称体のコレクションとして実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift’s closure expressions have a clean, clear style, with optimizations that encourage brief, clutter-free syntax in common scenarios.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトのクロージャ式は、最適化された、きれいな、明白なスタイルを持ちます、それは、通常さまざまに予想される状況において、簡潔な、混乱のない構文を助長します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift’s compiler performs four helpful safety-checks to make sure that two-phase initialization is completed without error:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトのコンパイラは、２段階初期化がエラーなしで完了されることを確認するために４つの役に立つ安全点検を実行します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift’s copy-by-default String behavior ensures that when a function or method passes you a String value, it’s clear that you own that exact String value, regardless of where it came from.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトの省略時コピーのString挙動は、関数またはメソッドがあなたにString値を渡すとき、それが来たところに関係なく、あなたがその正確な写しのString値を所有することが明白なのを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift’s initialization flow is more flexible in that it lets you set custom initial values, and can cope with types for which 0 or nil isn’t a valid default value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それがあなたに好みに合わせた初期値を設定させて、0またはnilが有効な省略時の値でない型に対処することができるという点で、スウィフトの初期化の流れはより柔軟です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift’s native String type no longer has an uppercaseString or lowercaseString property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトの生粋のString型はもはやuppercaseStringまたはlowercaseStringプロパティを持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift’s operator precedences and associativity rules are simpler and more predictable than those found in C and Objective-C.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトの演算子優先順位と結合性規則は、CとObjective-Cで見つけられるそれらより単純でより予測できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift’s optionals let you indicate the absence of a value for any type at all, without the need for special constants.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトのオプショナルは、あなたに特別な定数の必要なしにあらゆる全ての型の値の欠如を示させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift’s standard library provides a method called sorted(by:), which sorts an array of values of a known type, based on the output of a sorting closure that you provide.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトの標準ライブラリはsorted(by:)と呼ばれるメソッドを提供します、それは、ある既知の型の値からなる配列の分類を、あなたが提供するあるソート（分類）を行うクロージャの出力に基づき行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift’s two-phase initialization process is similar to initialization in Objective-C.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトの２段階初期化プロセスは、Objective-Cでの初期化に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift’s type checker is able to deduce that Movie and Song have a common superclass of MediaItem, and so it infers a type of [MediaItem] for the library array:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトの型チェッカーはMovieとSongが共通のスーパークラスMediaItemを持つと推論することができます、なのでそれはlibrary配列に対して[MediaItem]型を推論します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift’s type safety prevents non-Boolean values from being substituted for Bool.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトの型安全は、非ブール値がBoolの代用にされるのを妨げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Swift’s unified function syntax is flexible enough to express anything from a simple C-style function with no parameter names to a complex Objective-C-style method with names and argument labels for each parameter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトの統合された関数構文は、十分な柔軟性があり、パラメータ名を持たない単純なCスタイルの関数から、各パラメータに対して名前および引数ラベルをもつ複雑なObjective-Cスタイルのメソッドまで、何でも表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Switch</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スイッチ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Switch Case Attributes</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スイッチケース節属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Switch Statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スイッチ文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Switch Statements Must Be Exhaustive</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スイッチ文は徹底的でなければなりません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Switches support any kind of data and a wide variety of comparison operations—they aren’t limited to integers and tests for equality.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スイッチ（条件分岐）は、あらゆる種類のデータおよび多種多様な比較操作をサポートします ― それは、整数および同等性に対する検査に限られていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Switching Over Future Enumeration Cases</seg>
      </tuv>
      <tuv lang="ja">
        <seg>未来列挙ケース節に対してスイッチする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Switching over a nonfrozen enumeration requires extra consideration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非凍結列挙に対してスイッチすることは、余分な考慮を必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Syntactic categories are indicated by italic text and appear on both sides of a grammar production rule.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>統語論のカテゴリーは、イタリックのテキストによって示されて、文法導出規則の両側に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Syntactically, a variadic parameter consists of a base type name followed immediately by three dots (...), as in Int....</seg>
      </tuv>
      <tuv lang="ja">
        <seg>統語的には、可変長パラメータは、Int...のように、基となる型名に直ちに３つの点（...）が続くものから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Syntactically, every primary expression is also a postfix expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>統語論的に、あらゆる基本式は、また、接尾辞式です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Syntax for Designated and Convenience Initializers</seg>
      </tuv>
      <tuv lang="ja">
        <seg>指定および便宜イニシャライザのための構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Taken together, these constraints mean that the value passed for the indices parameter is a sequence of integers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総合すると、これらの制約が意味するのは、indicesパラメータに対して渡される値は整数からなるシーケンスであるということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Task Cancellation</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タスク取り消し</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Tasks and Task Groups</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タスクとタスクグループ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Tasks are arranged in a hierarchy.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タスクは、ある階層の中にきちんと並べられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Terminology</seg>
      </tuv>
      <tuv lang="ja">
        <seg>用語</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Ternary Conditional Operator</seg>
      </tuv>
      <tuv lang="ja">
        <seg>三項条件演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Thanks to Swift’s type inference, you don’t actually need to declare a concrete Item of Int as part of the definition of IntStack.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトの型推論のおかげで、あなたは実際にはIntである具体的なItemをIntStackの定義の一部として宣言する必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Thanks to Swift’s type inference, you don’t have to write the type of the array if you’re initializing it with an array literal containing values of the same type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトの型推論のおかげで、あなたが同じ型の値を含んでいる配列リテラルでそれを初期化しているのならば、あなたは配列の型を書く必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That branch must transfer control to exit the code block in which the guard statement appears.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その分岐は、制御を移して、guard文が現れているコードブロックを脱出する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That code also runs until the next suspension point, marked by await, or until it completes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのコードはまた、awaitによって印される次の中断地点まで、またはそれが完了するまで動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That function’s caller can then catch the error and respond appropriately.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その関数の呼び出し側はそのときそのエラーをキャッチして（捕まえて）適切に応答することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That is, every possible value of the type being considered must be matched by one of the switch cases.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>すなわち、考察されている型のすべてのあり得る値が、switchケース節のうちの１つと適合しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That is, it must provide a way to make itself uniquely representable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>すなわち、それはそれ自身を特有に表わすことを可能にする方法を提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That is, the code in the first defer statement executes last, the code in the second defer statement executes second to last, and so on.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>すなわち、最初のdefer文のコードが最後に実行され、２番目のdefer文のコードが最後から２番目に実行され、等々。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That is, the entire switch statement completes its execution as soon as the first matching case is completed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>すなわち、最初の適合するケース節が完了されるとすぐに、switch文の全体がその実行を完了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That is, the type must conform to one of the following Swift standard library protocols: ExpressibleByIntegerLiteral for integer literals, ExpressibleByFloatLiteral for floating-point literals, ExpressibleByStringLiteral for string literals, ExpressibleByBooleanLiteral for Boolean literals, ExpressibleByUnicodeScalarLiteral for string literals that contain only a single Unicode scalar, and ExpressibleByExtendedGraphemeClusterLiteral for string literals that contain only a single extended grapheme cluster.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>すなわち、その型は以下のスウィフト標準ライブラリのプロトコルの１つに準拠しなければなりません：整数リテラルに対してExpressibleByIntegerLiteral、浮動小数点リテラルに対してExpressibleByFloatLiteral、文字列リテラルに対してExpressibleByStringLiteral、ブールのリテラルに対してExpressibleByBooleanLiteral、ただ１つのユニコードスカラーだけを含む文字列リテラルに対してExpressibleByUnicodeScalarLiteral、そしてただ１つの拡張書記素クラスタだけを含む文字列リテラルに対してExpressibleByExtendedGraphemeClusterLiteral。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That is, the type of x in var x: Int = 0 is inferred by first checking the type of 0 and then passing this type information up to the root (the variable x).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>すなわち、var x: Int = 0の中のxの型は、最初に0の型を調べて、それからこの型情報を根（変数x）までさかのぼって渡すことによって推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That means it can’t use any methods or properties that are defined by the underlying type of the generator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは意味するのは、それが生成子の基礎をなす型によって定義されるどんなメソッドまたはプロパティも使用できないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That said, a nonthrowing method can override a throwing method, and a nonthrowing method can satisfy a protocol requirement for a throwing method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>とは言え、非スローメソッドはスローメソッドをオーバーライドできます、そして非スローメソッドはスローメソッドのプロトコル要件を満たすことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That said, a rethrowing method can override a throwing method, and a rethrowing method can satisfy a protocol requirement for a throwing method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>とは言え、再スローメソッドはスローメソッドをオーバーライドできます、そして再スローメソッドはスローメソッド用のプロトコル要件を満たすことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That said, because protocols don’t implement their members, most protocol members are declarations only.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>とは言え、プロトコルがそれらのメンバーを実装しないので、大部分のプロトコル・メンバーは宣言だけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That said, if a constant is initialized with a class object, the object itself can change, but the binding between the constant name and the object it refers to can’t.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そうは言っても、定数がクラスオブジェクトで初期化されるならば、そのオブジェクト自体は変わることができます、しかし、定数名とそれが言及するオブジェクトの間の束縛はそうすることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That said, if a subclass initializes all of its stored properties with default values and doesn’t define any initializers of its own, it inherits all of the superclass’s initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>とは言え、サブクラスがそれの格納プロパティのすべてを省略時の値で初期化して、それ自身のイニシャライザを全く定義しないならば、それはそのスーパークラスのイニシャライザのすべてを継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That said, if no initializer expression is present, the variable declaration must include an explicit type annotation (: type).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>とは言え、イニシャライザ式が存在しないならば、変数の宣言は明確な型注釈（: type）を含まなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That said, if the type you’re extending is defined in another module, an initializer declaration must delegate to an initializer already defined in that module to ensure members of that type are properly initialized.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>とは言え、 あなたが拡張している型が別のモジュールにおいて定義されるならば、イニシャライザ宣言はそのモジュールですでに定義されるイニシャライザに委任して、その型のメンバーが正しく初期化されることを確実にしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That said, if you assign a value to a variable or property within its own didSet observer clause, that new value that you assign will replace the one that was just set and passed to the willSet observer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>とは言え、あなたがdidSetオブザーバー節自身の内部である値を変数またはプロパティに代入するならば、あなたが代入するその新しい値は、ちょうど設定されたばかりのwillSetオブザーバーに渡されたものを置き換えることになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That said, if you provide a setter clause, you must also provide a getter clause.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>とは言え、 あなたがセッター節を提供するならば、あなたはまたゲッター節も提供しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That said, if you want execution to continue from one case to the next, explicitly include a fallthrough statement, which simply consists of the fallthrough keyword, in the case from which you want execution to continue.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それでもやはり、あなたが実行に１つのケース節から次のものまで続いて欲しいならば、あなたが実行に続いて欲しいケース節で明示的にfallthrough文を含めてください、それは、単にキーワードfallthroughから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That said, it can’t contain any cases that are also marked with the indirect modifier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>とは言うものの、それはindirect修飾子でさらに印されるどんなケース節も含むことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That said, the following changes are available only to code that uses Swift 5.6 or later:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>とはいえ、以下の変更はSwift 5.6以降を使用するコードでのみ利用可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That said, the initialization processes must end with a call to a designated initializer that ultimately initializes the class’s properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>とは言え、 初期化プロセスは、最終的にそのクラスのプロパティを初期化する指定イニシャライザに対する呼び出しで終わらなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That said, you can mark these protocol member declarations with the optional declaration modifier to specify that their implementation by a conforming type is optional.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>とは言え、 あなたはこれらのプロトコルメンバー宣言をoptional宣言修飾子を使って印して、ある準拠型にとってそれらの実装が随意であると指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That said, you can overload a function based on whether a function parameter can throw an error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>とは言え、あなたは関数を、ある関数パラメーターがエラーをスローできるかどうかに基づいてオーバーロードすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That said, you can use parentheses to be explicit about the scope of the operator’s application.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>とは言うものの、あなたは丸括弧を使って演算子の作用域について明確にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That violates the rule that escaping closures can’t capture a mutable reference to self for structures.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、脱出クロージャはselfへの可変参照を構造体についてはキャプチャできないという規則に違反します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Task.sleep(nanoseconds:) [https://developer.apple.com/documentation/swift/task/3862701-sleep] method is useful when writing simple code to learn how concurrency works.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Task.sleep(nanoseconds:) [https://developer.apple.com/documentation/swift/task/3862701-sleep]メソッドは、単純なコードを書くことでどのように並行性が働くかを学ぶのに役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The """ that ends the literal determines the indentation: Every nonblank line in the literal must begin with exactly the same indentation that appears before the closing """; there’s no conversion between tabs and spaces.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>リテラルの終わりの"""はその字下げを決定します：リテラルの中のあらゆる空でない行は、閉じている"""の前に現れるのと正確に同じ字下げで始まらなければなりません；タブと空白の間の変換はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The (404, "Not Found") tuple groups together an Int and a String to give the HTTP status code two separate values: a number and a human-readable description.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この(404, "Not Found")タプルはIntとStringをひとつにまとめて、HTTP状態コードに２つの別々の値：数と人間の読める説明を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The @optional, @lazy, @final, and @required attributes are now the optional, lazy, final, and required Declaration Modifiers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>@optional、@lazy、@final、そして@required属性は今やoptional、lazy、final、そしてrequired宣言修飾子です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The @prefix and @postfix attributes for Prefix and Postfix Operators have been replaced by prefix and postfix declaration modifiers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>@prefixと@postfix属性は接頭辞および接尾辞演算子に対して、prefixとpostfix宣言修飾子によって置き換えられました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Address class also provides a method called buildingIdentifier(), which has a return type of String?.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Addressクラスはまた、buildingIdentifier()と呼ばれるメソッドを提供します、それは、String?の戻り型を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Any type can contain values from all other types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Any型は、全ての他の型からの値を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Any type represents values of any type, including optional types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Any型は、オプショナル型を含む、何らかの型の値を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The AnyObject protocol is similar to the Any type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>AnyObjectプロトコルは、Any型に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The AudioChannel structure also defines a stored instance property called currentLevel, which represents the channel’s current audio level on a scale of 0 to 10.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>AudioChannel構造体はまた、currentLevelと呼ばれる格納インスタンスプロパティを定義します、それは、0から10までの目盛りでチャンネルの現在の音声レベルを表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The AudioChannel structure defines two stored type properties to support its functionality.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>AudioChannel構造体は、その機能性を支えるために２つの格納型プロパティを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The AutomaticallyNamedDocument overrides its superclass’s failable init?(name:) initializer with a nonfailable init(name:) initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>AutomaticallyNamedDocumentは、それのスーパークラスの失敗できるinit?(name:)イニシャライザを、失敗できないinit(name:)イニシャライザでオーバーライドします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Bicycle subclass defines a custom designated initializer, init().</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Bicycleサブクラスはあつらえの指定イニシャライザ、init()を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The BlackjackCard structure itself has two properties—rank and suit.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>BlackjackCard構造体は、２つのプロパティ ― rankとsuitを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Circle class implements the area property requirement as a computed property, based on a stored radius property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Circleクラスはareaプロパティ要件を、格納radiusプロパティに基づいて計算プロパティとして、満たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Circle, Country and Animal classes don’t have a shared base class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Circle、CountryとAnimalクラスには、共有の基盤クラスがありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Container protocol defines three required capabilities that any container must provide:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Containerプロトコルは、あらゆるコンテナ（容れ物）が提供しなければならない３つの必須の能力を定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Counter class also declares a variable property, count, to keep track of the current counter value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Counterクラスはまた、変数プロパティ、countを宣言して、現在のカウンターの値の情報を得続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Counter class defines three instance methods:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Counterクラスは、３つのインスタンスメソッドを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Counter class stores its current value in a variable property called count.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Counterクラスは、その現在の値をcountと呼ばれる変数プロパティに保管します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Counter class, defined below, has an optional dataSource property of type CounterDataSource?:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下で定義される、Counterクラスは、型CounterDataSource?のオプショナルのdataSourceプロパティを持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The CounterDataSource protocol defines an optional method requirement called increment(forCount:) and an optional property requirement called fixedIncrement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>CounterDataSourceプロトコルは、incrementForCount(_:)と呼ばれるオプショナルのメソッド要件とfixedIncrementと呼ばれるオプショナルのプロパティ要件を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Customer and CreditCard example shows a situation where one property that’s allowed to be nil and another property that can’t be nil have the potential to cause a strong reference cycle.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>CustomerとCreditCardの例は、nilであることを許されるあるプロパティとnilであることができないもう１つのプロパティが強い参照循環を引き起こす可能性をもつ状況を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Customer instance now has a strong reference to the CreditCard instance, and the CreditCard instance has an unowned reference to the Customer instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Customerインスタンスは現在CreditCardインスタンスへの強い参照を持ちます、そして、CreditCardインスタンスはCustomerインスタンスへの非所有参照を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The DataManager class has a stored property called data, which is initialized with a new, empty array of String values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>DataManagerクラスはdataと呼ばれる格納プロパティを持ちます、それは、String値の、新規の、空の配列で初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Dice class from above can be extended to adopt and conform to TextRepresentable:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のDiceクラスは、拡張されることで、TextRepresentableを採用して準拠することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The DiceGame protocol is a protocol that can be adopted by any game that involves dice.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>DiceGameプロトコルは、さいころが関わるどんなゲームによってでも採用されることができるプロトコルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The DiceGameDelegate protocol can be adopted to track the progress of a DiceGame.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>DiceGameDelegateプロトコルが採用されることで、DiceGameの進捗を追いかけることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Drawable protocol defines the requirement for something that can be drawn, like a line or shape: The type must implement a draw() method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Drawableプロトコルは、描画されることが可能な何らかのもの、ある行または形状などに対する要件を定義します：その型はdraw()メソッドを実装しなければいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The DrawingBuilder structure defines three methods that implement parts of the result builder syntax.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>DrawingBuilderは３つのメソッドを定義します、それらはリザルトビルダー構文の各部分を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Food class also provides a convenience initializer, init(), with no arguments.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Foodクラスはまた、引数のない便宜イニシャライザ、init()を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The FullyNamed protocol requires a conforming type to provide a fully qualified name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>FullyNamedプロトコルは、完全修飾名を提供するある準拠型を要件とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The HTMLElement class defines a name property, which indicates the name of the element, such as "h1" for a heading element, "p" for a paragraph element, or "br" for a line break element.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>HTMLElementクラスはnameプロパティを定義します、それは、要素の名前を示します、例えばヘッダ要素の"h1"、段落要素のための"p"、またはあるいは、改行のための"br"要素など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The HTMLElement class provides a single initializer, which takes a name argument and (if desired) a text argument to initialize a new element.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>HTMLElementクラスは１つのイニシャライザを提供します、それは、name引数と（希望する場合には）text引数をとって新しい要素を初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The IntStack type implements all three of the Container protocol’s requirements, and in each case wraps part of the IntStack type’s existing functionality to satisfy these requirements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>IntStack型は、Containerプロトコルの要件の３つすべてを実装します、そしてそれぞれの場合において、これらの要件を満たすためにIntStack型がもつ既存の機能性の一部をラップしています（内部で利用して外側を包む）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The IntStack type shown above can only be used with Int values, however.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、上で示されるIntStack型は、Int値で使われることができるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Item for C1 must be the same as the Item for C2 (written as C1.Item == C2.Item).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>C1のためのItemは、C2のためのItemと同じものでなければなりません（C1.Item == C2.Itemのように書かれます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Item for C1 must conform to the Equatable protocol (written as C1.Item: Equatable).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>C1のためのItemは、Equatableプロトコルに準拠しなければなりません（C1.Item: Equatableのように書かれます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The LevelTracker structure is used with the Player class, shown below, to track and update the progress of an individual player:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>LevelTracker構造体はPlayerクラスとともに使用され、下で示されるように、個々のプレーヤーの進捗を追跡して更新します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The LevelTracker structure keeps track of the highest level that any player has unlocked.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>LevelTracker構造体は、プレーヤーのだれかが鍵を開けた最も高いレベルの情報を得続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The LevelTracker structure uses type properties and methods to keep track of which levels of the game have been unlocked.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>LevelTracker構造体は、そのゲームのどのレベルが鍵を開けられているかを追跡し続けるために型プロパティとメソッドを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Matrix subscript’s getter and setter both contain an assertion to check that the subscript’s row and column values are valid.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Matrix添え字のゲッターとセッターは両方とも、添え字のもつrowとcolumn値が有効なことを確認するためにひとつの表明を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The NSCopying attribute behaves in a way similar to the Objective-C copy property attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>NSCopying属性は、Objective-Cのcopyプロパティ属性に似たやり方でふるまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The NSString length property is now mapped onto Swift’s native String type as utf16Count, not utf16count.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>NSStringのlengthプロパティは現在ではスウィフトの生粋のString型とutf16Countとして対応づけられます、utf16countではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Pair structure conforms to Loggable and TitledLoggable whenever its generic type conforms to Loggable or TitledLoggable, respectively.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Pair構造体は、LoggableおよびTitledLoggableに準拠します、それの総称体型がそれぞれLoggableまたはTitledLoggableに準拠する時はいつでも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Person and Apartment example shows a situation where two properties, both of which are allowed to be nil, have the potential to cause a strong reference cycle.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>PersonとApartmentの例は、２つのプロパティ、両方ともnilであることを許されるものが強い参照循環を引き起こす可能性をもつ状況を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Person class has an initializer that sets the instance’s name property and prints a message to indicate that initialization is underway.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Personクラスは、インスタンスのnameプロパティを設定して、初期化が進行中であることを示すためにメッセージを出力するイニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Person class is defined in the same way as before:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Personクラスは、前の通りに定義されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Person instance now has a strong reference to the Apartment instance, and the Apartment instance has a strong reference to the Person instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Personインスタンスは現在Apartmentインスタンスへの強い参照を持ちます、そして、ApartmentインスタンスはPersonインスタンスへの強い参照を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Person instance still has a strong reference to the Apartment instance, but the Apartment instance now has a weak reference to the Person instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Personインスタンスは依然としてApartmentインスタンスへの強い参照を持ちます、しかし、Apartmentインスタンスは現在はPersonインスタンスへの弱い参照を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Player class creates a new instance of LevelTracker to track that player’s progress.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Playerクラスは、そのプレーヤーの進捗を追うためにLevelTrackerの新しいインスタンスをつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Player class defines a win(coins:) method, which retrieves a certain number of coins from the bank and adds them to the player’s purse.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Playerクラスはwin(coins:)メソッドを定義します、それは、胴元からコインの特定の数を取り戻して、それらをプレーヤーの財布に加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Player class describes a player in the game.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Playerクラスは、ゲームにおけるプレーヤーを記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Point structure above defines a mutating moveBy(x:y:) method, which moves a Point instance by a certain amount.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のPoint構造体は変更moveBy(x:y:)メソッドを定義します、それは、Pointインスタンスを特定の量だけ動かします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The RandomNumberGenerator protocol doesn’t make any assumptions about how each random number will be generated—it simply requires the generator to provide a standard way to generate a new random number.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>RandomNumberGeneratorプロトコルは、乱数それぞれが生成される方法について、全く仮定しません ― それは単に生成器に新しい乱数を生み出す標準の方法を提供することを要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Rank enumeration describes the thirteen possible playing card ranks, together with a raw Int value to represent their face value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Rank列挙は、13のあり得るトランプカードの等級を、それらの額面を表す生のInt値と共に記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The RecipeIngredient class has a single designated initializer, init(name: String, quantity: Int), which can be used to populate all of the properties of a new RecipeIngredient instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>RecipeIngredientクラスは、１つの指定イニシャライザ、init(name: String, quantity: Int)を持ちます、それは、新しいRecipeIngredientインスタンスのプロパティの全てに何か入れるために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Rect structure also provides a computed property called center.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Rect構造体はまた、center（中心）と呼ばれる計算プロパティを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Residence class is more complex than before.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Residenceクラスは、前より複雑です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Resolution structure definition and the VideoMode class definition only describe what a Resolution or VideoMode will look like.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Resolution構造体定義とVideoModeクラス定義は、ResolutionまたはVideoModeがどのようなものかについて記述するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Room class used for the rooms array is a simple class with one property called name, and an initializer to set that property to a suitable room name:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>rooms配列のために使用されるRoomクラスは、nameと呼ばれる１つのプロパティ、そしてそのプロパティを適切な部屋名に設定するイニシャライザをもつ単純なクラスです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Self type isn’t a specific type, but rather lets you conveniently refer to the current type without repeating or knowing that type’s name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Self型は、特定の型ではありません、しかしいくぶんあなたに便利に現在の型を参照させます、その型の名前を繰り返すことまたは知ることなしに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Self type refers to the same type as the type(of:) [https://developer.apple.com/documentation/swift/2885064-type] function in the Swift standard library.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Self型は、スウィフト標準ライブラリの中のtype(of:) [https://developer.apple.com/documentation/swift/2885064-type]関数と同じ型を参照します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Size structure automatically receives an init(width:height:) memberwise initializer, which you can use to initialize a new Size instance:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Size構造体は自動的にメンバー関連イニシャライザinit(width:height:)を受け取ります、それは、あなたが新しいSizeインスタンスを初期化するために使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The SnakesAndLadders class can be extended to adopt and conform to PrettyTextRepresentable:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>SnakesAndLaddersクラスは、拡張されることでPrettyTextRepresentableを採用して準拠するようにできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The StepCounter class declares a totalSteps property of type Int.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>StepCounterクラスは、型IntのtotalStepsプロパティを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Suit enumeration describes the four common playing card suits, together with a raw Character value to represent their symbol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Suit列挙は、トランプの４つの通常のスート（組み札）を、それらの記号を表す生のCharacter値と共に記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The TowardsZeroSource class implements the optional increment(forCount:) method from the CounterDataSource protocol and uses the count argument value to work out which direction to count in.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>TowardsZeroSourceクラスは、CounterDataSourceプロトコルからのオプショナルのincrement(forCount:)メソッドを実装して、どの方向に数えるべきか解決するためにcount引数値を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The TrackedString structure and the value property don’t provide an explicit access-level modifier, and so they both receive the default access level of internal.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>TrackedString構造体とvalueプロパティは明確なアクセス水準修飾子を提供しません、なので、それらは両方とも省略時のアクセス水準である内部を受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The TrackedString structure defines a stored string property called value, with an initial value of "" (an empty string).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>TrackedString構造体は、valueと呼ばれる格納文字列プロパティを、""（空の文字列）の初期値で定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Vehicle base class also defines a method called makeNoise.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Vehicleクラスはまた、makeNoiseと呼ばれるメソッドを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Vehicle class defines common characteristics for an arbitrary vehicle, but isn’t much use in itself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Vehicleクラスは、任意の乗物のためのありふれた特徴を定義します、しかしそれ自体では余り役に立ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Vehicle class provides a default value for its only stored property, and doesn’t provide any custom initializers itself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Vehicleクラスは、それの格納プロパティのためにのみ省略時の値を提供します、そしてそれ自身では何らあつらえのイニシャライザを提供しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The _height and _width properties store an instance of the property wrapper, TwelveOrLess.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>_heightと_widthプロパティは、プロパティラッパー、TwelveOrLessのインスタンスを格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The addTwoInts(_:_:) function has the same type as the mathFunction variable, and so this assignment is allowed by Swift’s type-checker.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>addTwoInts(_:_:)関数はmathFunction変数と同じ型を持ちます、なので、この代入はスウィフトの型チェッカーによって認められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The addition and multiplication cases have associated values that are also arithmetic expressions—these associated values make it possible to nest expressions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>additionとmultiplicationケース節は、それもまた算術式である関連値を持ちます—これらの関連値がそれを入れ子式可能なものにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The airports dictionary is declared as a variable (with the var introducer), and not a constant (with the let introducer), because more airports are added to the dictionary in the examples below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>airports辞書は、変数として（var導入子を使って）宣言されます、定数（let導入子を使って）ではなく、なぜならより多くの空港が下記の例でこの辞書に加えられるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The airports dictionary is declared as having a type of [String: String], which means “a Dictionary whose keys are of type String, and whose values are also of type String”.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>airports辞書は、[String: String]の型を持つとして宣言されます、それは「キーが型Stringであり、値もまた型StringであるDictionary」を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The airports dictionary is initialized with a dictionary literal containing two key-value pairs.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>airports辞書は、２つの「キーと値」の対を含んでいるひとつの辞書リテラルで初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The allEqual() method returns true only if all the elements in the collection are equal.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>allEqual()メソッドがtrueを返すのは、そのコレクションの中の要素すべてが同等である場合のみです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The allItemsMatch(_:_:) function starts by checking that both containers contain the same number of items.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>allItemsMatch(_:_:)関数は、両方のコンテナが同じ数の項目を含むことを確認することによって始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The arch(arm) platform condition doesn’t return true for ARM 64 devices.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>arch(arm)プラットホーム条件は、ARM 64機器に対してtrueを返しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The as! operator performs a forced cast of the expression to the specified type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>as!演算子は式の指定された型への強制的なキャストを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The as! version of the downcast operator forces the downcast to the protocol type and triggers a runtime error if the downcast doesn’t succeed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>as!版のダウンキャスト演算子は、そのプロトコル型へのダウンキャストを強制して、ダウンキャストが成功しなかったならば実行時エラーの引き金を引きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The as operator performs a cast when it’s known at compile time that the cast always succeeds, such as upcasting or bridging.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>as演算子は、コンパイル時にそのキャストが常に成功することを知られているキャストを実行します、例えばアップキャストやブリッジなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The as pattern matches a value if the type of that value at runtime is the same as the type specified in the right-hand side of the as pattern—or a subclass of that type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>asパターンは、ある値にマッチします、もしその値の実行時での型がasパターンの右側で指定される型 ― または、それの型のサブクラス ― と同じものであるならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The as? operator performs a conditional cast of the expression to the specified type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>as?演算子は式の指定された型への条件付きキャストを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The as? version of the downcast operator returns an optional value of the protocol’s type, and this value is nil if the instance doesn’t conform to that protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>as?版のダウンキャスト演算子は、そのプロトコルの型のオプショナルの値を返します、そしてインスタンスがそのプロトコルに準拠しないならばその値はnilです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The asHTML property is declared as a lazy property, because it’s only needed if and when the element actually needs to be rendered as a string value for some HTML output target.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>asHTMLプロパティは遅延プロパティとして宣言されます、なぜなら、要素が何らかのHTML出力対象のために実際に文字列値として解釈される必要がもしもあるときのみそれが必要なだけだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The asHTML property is named and used somewhat like an instance method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>asHTMLプロパティは、いくぶんインスタンスメソッドのように名前をつけられて、使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The async keyword is part of the function’s type, and synchronous functions are subtypes of asynchronous functions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>asyncキーワードは関数の型の一部です、そして同期関数は非同期関数の下位型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The available attribute always appears with a list of two or more comma-separated attribute arguments.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>available属性は、常に２つ以上のコンマで区切られた属性引数とともに現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The balance(_:_:) function above modifies its two parameters to divide the total value evenly between them.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のbalance(_:_:)関数は、それの２つのパラメータを修正して、それらの間でその合計値を均等に分割するようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The beginConcert(in:) function takes a parameter of type Location &amp; Named, which means “any type that’s a subclass of Location and that conforms to the Named protocol.” In this case, City satisfies both requirements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>beginConcert(in:)関数は、型Location &amp; Namedのパラメータを１つとります、それは「Locationのサブクラスであり、Namedプロトコルに準拠する何らかの型」を意味します。この場合では、Cityは両方の要件を満たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The block argument indicates an Objective-C compatible block reference.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>block引数は、Objective-C互換ブロック参照を指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The boardColors array is initialized with a closure to set up its color values:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>boardColors配列は、その色値を設定するために、クロージャで初期化されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The break gameLoop statement transfers control to the first line of code outside of the while loop, which ends the game.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>break gameLoop文は、制御をwhileループの外側のコードの最初の行へ移します、そしてゲームを終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The break statement ends execution of an entire control flow statement immediately.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>break文は、ある制御の流れに関する文まるまる全体の実行を直ちに終えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The buildBlock(_:) method is required; the other methods—which enable additional functionality in the DSL—are optional.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>buildBlock(_:)メソッドは必須とされます；他のメソッド — それは追加の機能性をDSLにおいて可能にします — は随意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The c argument indicates a C function reference.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>c引数は、C関数参照を指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The capitalCity property can be used and accessed like a non-optional value once initialization is complete, while still avoiding a strong reference cycle.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>capitalCityプロパティは、一旦初期化が完了すれば、非オプショナルの値のように使用およびアクセスされることが可能です、その一方で依然として強い参照循環を防ぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The case above has two patterns: (let distance, 0) matches points on the x-axis and (0, let distance) matches points on the y-axis.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のcaseは、２つのパターンを持ちます：(let distance, 0)はx軸上の点にマッチします、そして(0, let distance)はy軸上の点にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The catch clauses don’t have to handle every possible error that the code in the do clause can throw.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>catch節は、do節の中のコードがスロー可能なすべての起こりうるエラーを取り扱う必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The center property is then set to a new value of (15, 15), which moves the square up and to the right, to the new position shown by the dark green square in the diagram below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>centerプロパティは、それから新しい値(15, 15)に設定されます、それは、正方形を上にそして右に、下記の図において暗い緑の正方形によって示される新しい位置へと動かします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The continue statement tells a loop to stop what it’s doing and start again at the beginning of the next iteration through the loop.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>continue文は、あるループにそれがしていることを止めて、そのループの次の繰り返しの始めのところで再び始めるように言います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The continue, break, and fallthrough statements are described below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>continue、break、そしてfallthrough文は、以下で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The convention attribute always appears with one of the following arguments:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>convention属性は常に以下の引数の１つと共に現れます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The currentLevel property has a didSet property observer to check the value of currentLevel whenever it’s set.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>currentLevelプロパティはdidSetプロパティオブザーバーを持ち、currentLevelの値をそれが設定されるときはいつでも調べるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The deprecated argument indicates the first version of the specified platform or language in which the declaration was deprecated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>deprecated引数は、そこにおいてその宣言が非推奨とされたところの、指定されたプラットホームまたは言語の最初のバージョンを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The didSet clause is optional when you provide a willSet clause.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがwillSet節を提供するとき、didSet節は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The didSet observer is called after the value of totalSteps is updated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>didSetオブザーバーは、totalStepsの値が更新された後に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The distribute(coins:) method checks that there are enough coins in the bank before distributing them.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>distribute(coins:)メソッドは、十分なコインがそれらを配布する前に胴元にあることを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The do statement is used to introduce a new scope and can optionally contain one or more catch clauses, which contain patterns that match against defined error conditions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>do文は、ある新しいスコープを導入するために使われます、そして随意に１つ以上のcatch節を含むことができ、それは定義されたエラー条件にマッチするパターンを複数含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The eat(item:) function lists the vending machine errors to catch, and its error text corresponds to the items in that list.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>eat(item:)関数は、自動販売機エラーそれらをリストしてキャッチします、そしてそれのエラーテキストをそのリストの中の項目と結び付けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The else clause of a guard statement is required, and must either call a function with the Never return type or transfer program control outside the guard statement’s enclosing scope using one of the following statements:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>guard文のelse節は必ず必要です、そしてNever戻り型を持つ関数を呼び出すか、プログラム制御をguard文の囲むスコープの外側に以下の文のうちの１つを使って移すか、どちらかをする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The fallthrough keyword doesn’t check the case conditions for the switch case that it causes execution to fall into.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>fallthroughキーワードは、それが実行を落としていく先のswitchケース節のためのケース節条件を調べません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The favoriteGenres set is declared as a variable (with the var introducer) and not a constant (with the let introducer) because items are added and removed in the examples below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>favoriteGenres集合は、定数（let導入子を使って）ではなく変数として（var導入子を使って）宣言されます、項目が下の例で加えられたり取り除かれたりするためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The favoriteGenres variable is declared as “a set of String values”, written as Set&lt;String&gt;.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>favoriteGenres変数は、Set&lt;String&gt;のように書かれ、「String値の集合」として宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The findIndex(of:in:) function now compiles successfully and can be used with any type that’s Equatable, such as Double or String:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>findIndex(of:in:)関数は、今やうまくコンパイルして、Equatableであるどんな型とでも使われることができます、例えばDoubleやStringなど：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The findIndex(ofString:in:) function can be used to find a string value in an array of strings:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>findIndex(ofString:in:)関数は、文字列の配列の中をある文字列値がないか捜すために使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The for-in loop is described in For-In Loops.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>for-inループはfor-inループで記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The gameDidStart(_:) method also accesses the dice property of the passed game parameter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>gameDidStart(_:)メソッドはまた、渡されたgameパラメータのdiceプロパティにアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The generator property is of type RandomNumberGenerator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>generatorプロパティは、型RandomNumberGeneratorのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The hasPrefix(_:) and hasSuffix(_:) methods perform a character-by-character canonical equivalence comparison between the extended grapheme clusters in each string, as described in String and Character Equality.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>hasPrefix(_:)とhasSuffix(_:)は、各文字列の拡張書記素クラスタ間で文字ごとの正準等価比較を実行します、そのことは文字列と文字の同等性で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The height and width properties get their initial values from the definition of TwelveOrLess, which sets TwelveOrLess.number to zero.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>heightとwidthプロパティは、それらの初期値をTwelveOrLessの定義から取得します、それはTwelveOrLess.numberをゼロに設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The if statement can provide an alternative set of statements, known as an else clause, for situations when the if condition is false.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>if文は、代替のひとそろいの文、else節として知られるものをif条件がfalseの場合の状況のために提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The in keyword can also be omitted, because the closure expression is made up entirely of its body:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>inキーワードもまた、クロージャ式がもっぱらその本文から成り立つので、省略されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The increment() method first tries to retrieve an increment amount by looking for an implementation of the increment(forCount:) method on its data source.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>increment()メソッドは、最初にそれのデータ・ソース上でincrement(forCount:)メソッドの実装を捜すことによって増加量を取り出そうと試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The increment() method in the example above could have been written like this:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例におけるincrement()メソッドは、このように記述されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The incrementer() function doesn’t have any parameters, and yet it refers to runningTotal and amount from within its function body.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>incrementer()関数には全くパラメータがありません、それなのに、それはその関数本文内からrunningTotalとamountに言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The init() initializer for Bicycle starts by calling super.init(), which calls the default initializer for the Bicycle class’s superclass, Vehicle.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Bicycleのためのinit()イニシャライザは、super.init()を呼ぶことによって始まります、それは、Bicycleクラスのスーパークラス、Vehicleのための省略時のイニシャライザを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The init(center:size:) initializer could have assigned the new values of origin and size to the appropriate properties itself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>init(center:size:)イニシャライザは、それ自体でoriginとsizeの新しい値を適切なプロパティに代入することができました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The init(name: String) convenience initializer provided by RecipeIngredient takes the same parameters as the init(name: String) designated initializer from Food.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>RecipeIngredientによって提供される便宜イニシャライザinit(name: String)は、Foodからの指定イニシャライザinit(name: String)と同じパラメータを取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The init(name: String) initializer from the Food class is provided as a designated initializer, because it ensures that all stored properties of a new Food instance are fully initialized.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>init(name: String)イニシャライザは、このFoodクラス由来で、指定イニシャライザとして提供されます、なぜならそれは新しいFoodインスタンスのすべての格納プロパティが完全に初期化されるのを確実にするからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The introduced argument indicates the first version of the specified platform or language in which the declaration was introduced.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>introduced引数は、そこにおいてその宣言が導入されたところの、指定されたプラットホームまたは言語の最初のバージョンを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The is operator checks at runtime whether the expression can be cast to the specified type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>is演算子は実行時に式が指定された型へとキャスト可能かどうかを調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The is operator returns true if an instance conforms to a protocol and returns false if it doesn’t.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>is演算子は、あるインスタンスがプロトコルに準拠するならばtrueを返して、それがそうしないならばfalseを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The is pattern matches a value if the type of that value at runtime is the same as the type specified in the right-hand side of the is pattern—or a subclass of that type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>isパターンは、ある値にマッチします、もしその値の実行時での型がisパターンの右側で指定される型 ― またはそれの型のサブクラス ― と同じものであるならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The john variable now has a strong reference to the new Person instance, and the unit4A variable has a strong reference to the new Apartment instance:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>john変数は現在新しいPersonインスタンスへの強い参照を持ちます、そしてunit4A変数は新しいApartmentインスタンスへの強い参照を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The listPhotos(inGallery:) function in the previous section asynchronously returns the whole array at once, after all of the array’s elements are ready.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>前の節でのlistPhotos(inGallery:)関数は、配列の持つ要素の全てが準備できた後に、配列全体を非同期に一度に返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The makeGreeting(for:) function takes a name parameter and uses it to draw a personalized greeting.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>makeGreeting(for:)関数は、nameパラメータを取り、そしてそれを使って各個人向け挨拶を引き出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The makeIncrementer(forIncrement:) function defines an integer variable called runningTotal, to store the current running total of the incrementer that will be returned.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>makeIncrementer(forIncrement:)関数は、返されるincrementerの現時点での合計を格納するために、runningTotalと呼ばれる整数変数を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The makeIncrementer(forIncrement:) function has a single Int parameter with an argument label of forIncrement, and a parameter name of amount.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>makeIncrementer(forIncrement:)関数は、forIncrementの引数ラベル、そしてamountのパラメータ名を持つ、ただ１つのIntパラメータを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The makeIterator() method is called on the collection expression to obtain a value of an iterator type—that is, a type that conforms to the IteratorProtocol [https://developer.apple.com/documentation/swift/iteratorprotocol] protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>makeIterator()メソッドがcollection（コレクション）式の上で呼ばれて、イテレータ型 ― すなわち、IteratorProtocol [https://developer.apple.com/documentation/swift/iteratorprotocol]プロトコルに準拠する型、に属する１つの値を取得します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The makeTrapezoid() function in this example declares its return type as some Shape; as a result, the function returns a value of some given type that conforms to the Shape protocol, without specifying any particular concrete type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例でのmakeTrapezoid()関数は、それの戻り型をsome Shapeとして宣言します；その結果、関数は、Shapeプロトコルに準拠するある与えられた型の値を返します、何らかの特定の具象型を指定することなしに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The map(_:) method calls the closure expression once for each item in the array.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>map(_:)メソッドは、配列の中の各項目に対して一度だけクロージャ式を呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The message argument provides a textual message that the compiler displays when emitting a warning or error about the use of a deprecated or obsoleted declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>message引数は、あるテキストメッセージを提供します、それはコンパイラが非推奨または廃止された宣言の使用についての警告またはエラーを発するときに表示するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The minMax(array:) function above returns a tuple containing two Int values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のminMax(array:)関数は、２つのInt値を含んでいるタプルを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The minMax(array:) function returns a tuple containing two Int values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>minMax(array:)関数は、２つのInt値を含んでいる１つのタプルを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The number property of the CreditCard class is defined with a type of UInt64 rather than Int, to ensure that the number property’s capacity is large enough to store a 16-digit card number on both 32-bit and 64-bit systems.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>CreditCardクラスのnumberプロパティは、UInt64の型で定義されます、Intではなく、それによってnumberプロパティの容量が32bitと64bitシステムの両方で16桁のカード番号を格納するのに十分に大きいことを保証します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The number variable is then divided by 10.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>number変数は、それから10で割られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The objc attribute is also implicitly added in the following cases:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>objc属性はまた、以下の場合において暗黙的に加えられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The objc attribute optionally accepts a single attribute argument, which consists of an identifier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>objc属性は、任意にただ１つだけ属性引数を受け入れます、それはひとつの識別子から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The objc attribute tells the compiler that a declaration is available to use in Objective-C code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>objc属性は、コンパイラにある宣言がObjective-Cコードにおいて使われることが可能であるのを伝えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The objects array can now be iterated, and each object in the array can be checked to see if it conforms to the HasArea protocol:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>objects配列は、今や繰り返されることができます、そして配列の各オブジェクトはそれがHasAreaプロトコルに従うかどうかを確認されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The objects array is initialized with an array literal containing a Circle instance with a radius of 2 units; a Country instance initialized with the surface area of the United Kingdom in square kilometers; and an Animal instance with four legs.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>objects配列は、単位２の半径をもつCircleインスタンスを含んでいる配列リテラル；平方キロメートルでの英国の面積で初期化されるCountryインスタンス；そして、４本脚のAnimalインスタンス；を含んでいる配列リテラルで初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The obsoleted argument indicates the first version of the specified platform or language in which the declaration was obsoleted.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>obsoleted引数は、そこにおいてその宣言が廃止とされたところの、指定されたプラットホームまたは言語の最初のバージョンを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The override keyword also prompts the Swift compiler to check that your overriding class’s superclass (or one of its parents) has a declaration that matches the one you provided for the override.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>overrideキーワードはまた、あなたのオーバーライドしているクラスのスーパークラス（またはその親のうちの１つ）が、そのオーバーライドのためにあなたが提供するものと合致する宣言を持っていることを確認するように、スウィフトのコンパイラを促します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The paragraph variable above is defined as an optional HTMLElement, so that it can be set to nil below to demonstrate the presence of a strong reference cycle.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上記のparagraph変数は、オプショナルのHTMLElementとして定義されます、それでそれは下で強い参照循環の存在を例示するためにnilに設定されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The prettyTextualDescription property can now be used to print a pretty text description of any SnakesAndLadders instance:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このprettyTextualDescriptionプロパティは、現在あらゆるSnakesAndLaddersインスタンスのきれいなテキスト解説を出力するために使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The print(_:separator:terminator:) function doesn’t have a label for its first argument, and its other arguments are optional because they have a default value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>print(_:separator:terminator:)関数は、それの最初の引数に対してラベルを持ちません、そしてそれの他の引数は任意です、それらが省略時の値を持つからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The print(_:separator:terminator:) function is a global function that prints one or more values to an appropriate output.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>print(_:separator:terminator:)関数は、ひとつ以上の値を適切な出力先に出力するグローバルな関数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The printNumberOfRooms() method on the Residence class prints the current value of numberOfRooms.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Residenceクラス上のprintNumberOfRooms()メソッドは、numberOfRoomsの現在の値を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The receive(coins:) method simply adds the received number of coins back into the bank’s coin store.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>receive(coins:)メソッドは、単純に受け取ったコインの数を胴元のコインの蓄えに戻すよう加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The renamed argument provides a textual message that indicates the new name for a declaration that’s been renamed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>renamed引数は、あるテキストメッセージを提供します、それは改名された宣言に対する新しい名前を指し示すものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The repeat-while loop in Swift is analogous to a do-while loop in other languages.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトのrepeat-whileループは、他の言語のdo-whileループと類似したものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The repetitions(task:) method takes a single argument of type () -&gt; Void, which indicates a function that has no parameters and doesn’t return a value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>repetitions(task:)メソッドは型() -&gt; Voidの引数をひとつだけとります、それは、パラメータを持たず、値を返さない関数であることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The self expression is an explicit reference to the current type or instance of the type in which it occurs.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>self式は、それがその中に現れているところの現在の型や型のインスタンスへの明確な参照です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The self expression is used to specify scope when accessing members, providing disambiguation when there’s another variable of the same name in scope, such as a function parameter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>self式は、メンバーにアクセスする時にスコープを指定するために使われて、関数パラメータなど、同じ名前の別の変数がスコープ内にある場合に一義化を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The serve(customer:) function in the listing above takes an explicit closure that returns a customer’s name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上で記載されるserve(customer:)関数は、次の顧客の名前を返す、ある明示的なクロージャを取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The shoppingList array is declared as a variable (with the var introducer) and not a constant (with the let introducer) because more items are added to the shopping list in the examples below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>shoppingList配列は、変数として（var導入子を使って）宣言されます、定数（let導入子を使って）ではなく、なぜならより多くの項目が下記の例で購入品目リストに加えられるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The shoppingList variable is declared as “an array of string values”, written as [String].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>shoppingList変数は、「String値の配列」として宣言され、[String]のように書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The someFunctionWithEscapingClosure(_:) function takes a closure as its argument and adds it to an array that’s declared outside the function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>someFunctionWithEscapingClosure(_:)関数は、クロージャをそれの引数として取ります、そしてそれを関数の外側で宣言される配列に加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The sorted(by:) method accepts a closure that takes two arguments of the same type as the array’s contents, and returns a Bool value to say whether the first value should appear before or after the second value once the values are sorted.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>sorted(by:)メソッドは、配列の内容物と同じ型の２つの引数をとり、そしてひとたび値が分類されるならば最初の値が第２の値の前か後のどちらに現れなければならないのかを伝えるBool値を返すクロージャを受け取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The sorted(by:) method is being called on an array of strings, so its argument must be a function of type (String, String) -&gt; Bool.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このsorted(by:)メソッドは文字列の配列上で呼ばれています、それでそれの引数は型(String, String) -&gt; Boolの関数でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The square variable’s center property is then accessed through dot syntax (square.center), which causes the getter for center to be called, to retrieve the current property value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>square変数のcenterプロパティは、それからドット構文（square.center）を通してアクセスされます、それによってcenterのためのゲッターが呼び出されて、現在のプロパティ値を取り出すことになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The startsWith(_:) method first makes sure that the container has at least one item, and then it checks whether the first item in the container matches the given item.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>startsWith(_:)メソッドはまず、コンテナが少なくとも１つの項目を持つことを確かめます、それからそれはそのコンテナの最初の項目が与えられた項目と合致するかどうか調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The subscript(dynamicMember:) subscript enables syntactic sugar for member lookup, as described in dynamicMemberLookup.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>subscript(dynamicMember:)添え字は、メンバー検索に対する構文糖を可能にします、dynamicMemberLookupで記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The swapTwoInts(_:_:) function is useful, but it can only be used with Int values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>swapTwoInts(_:_:)関数は役に立ちます、しかし、それはInt値で使われることができるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The swapTwoInts(_:_:) function simply swaps the value of b into a, and the value of a into b.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>swapTwoInts(_:_:)関数は、単にbの値をaの中に、そしてaの値をbの中へと入れ替えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The swapTwoInts(_:_:) function swaps the original value of b into a, and the original value of a into b.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>swapTwoInts(_:_:)関数は、bの元々の値をaの中へ、そしてaの元々の値をbの中へと交換します、そして、最初の値のにb。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The swapTwoInts example above doesn’t define a return type or return a value, but it still modifies the values of someInt and anotherInt.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のswapTwoInts例は、戻り型を定義しないし、また値を返しません、しかしそれでもそれはsomeIntとanotherIntの値を修正します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The swapTwoValues(_:_:) function and the Stack type can work with any type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>swapTwoValues(_:_:)関数とStack型は、どんな型でも扱うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The swapTwoValues(_:_:) function can now be called in the same way as swapTwoInts, except that it can be passed two values of any type, as long as both of those values are of the same type as each other.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>swapTwoValues(_:_:)関数は現在swapTwoIntsと同じやり方で呼ばれることができます、しかしそれがあらゆる型の２つの値を渡されることが、それらの値の両方が互いに同じ型である限り可能であるのを除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The swapTwoValues(_:_:) function defined above is inspired by a generic function called swap, which is part of the Swift standard library, and is automatically made available for you to use in your apps.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上で定義されるswapTwoValues(_:_:)関数はswapと呼ばれる総称体関数に着想を得たものです、それは、スウィフト標準ライブラリの一部であって、あなたのアプリにおいて自動的にあなたが使うことが可能にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The swift argument indicates a Swift function reference.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>swift引数はあるスウィフト関数参照を指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The switch statement determines whether the point is at the origin (0, 0), on the red x-axis, on the green y-axis, inside the blue 4-by-4 box centered on the origin, or outside of the box.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このswitch文は、そのポイントがあるのは、原点(0, 0)、赤のx-軸上、緑のy-軸上、原点を中心とした青の４×４の四角の内側、または四角の外側かどうかを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The switch statement determines whether the point is on the green diagonal line where x == y, on the purple diagonal line where x == -y, or neither.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このswitch文は、そのポイントが、x == yであるところの緑の斜線上、あるいはx == -yであるところの紫の斜線上にあるかどうかを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The switch statement determines whether the point is on the red x-axis, on the green y-axis, or elsewhere (on neither axis).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このswitch文は、この地点が、赤のx-軸上、緑のy-軸上、または他のどこか（どちらの軸上でもない）かを決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The switch statement’s first case matches all five lowercase vowels in the English language.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>switch文の最初のケース節は、英語における５つの小文字の母音字すべてにマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The switch statement’s first case matches the first letter of the English alphabet, a, and its second case matches the last letter, z.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>switch文の最初のケース節は、英語アルファペットの最初の文字、aにマッチします、そしてそれの２番目のケース節は最後の文字、zにマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The targetEnvironment() platform condition returns true when code is being compiled for the specified environment; otherwise, it returns false.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>targetEnvironment()プラットホーム条件は、指定された環境に対してコードがコンパイルされている場合はtrueを返します；そうでなければ、それはfalseを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The things array contains two Int values, two Double values, a String value, a tuple of type (Double, Double), the movie “Ghostbusters”, and a closure expression that takes a String value and returns another String value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>things配列は、２つのInt値、２つのDouble値、１つのString値、型(Double, Double)のタプル、映画「ゴーストバスターズ」、そしてString値をとって別のString値を返す１つのクロージャ式を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The throws keyword is part of a function’s type, and nonthrowing functions are subtypes of throwing functions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>throwsキーワードは関数の型の一部です、そしてスローを行わない関数はスロー関数の下位型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The toggle() method is marked with the mutating keyword as part of the Togglable protocol definition, to indicate that the method is expected to mutate the state of a conforming instance when it’s called:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>toggle()メソッドは、Togglableプロトコル定義の一部としてmutatingキーワードで印されます、それによってそのメソッドが、それが呼ばれるとき準拠インスタンスの状態を変化させることを予期されるようにします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The topItem computed property can now be used with any Stack instance to access and query its top item without removing it.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>topItem計算プロパティは、今やあらゆるStackインスタンスで、それの一番上の項目にそれを取り除くことなくアクセスおよび問い合わせるために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The topItem property returns an optional value of type Element.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>topItemプロパティは型Elementのオプショナルの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The try? expression doesn’t introduce an extra level of optionality to expressions that already return optionals.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>try?式は、既にオプショナルを返す式に、余分な水準の随意性を導入しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The unavailable argument indicates that the declaration isn’t available on the specified platform.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>unavailable引数は、その宣言が指定されたプラットホーム上で利用可能でないことを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The update(with:) method is already running on the actor, so it doesn’t mark its access to properties like max with await.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>update(with:)メソッドは既にアクター上で動作しています、なのでそれはmaxのようなプロパティへのそれのアクセスをawaitで印しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The updateValue(_:forKey:) method returns an optional value of the dictionary’s value type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>updateValue(_:forKey:)メソッドは、その辞書の値型のオプショナルの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The userDefinedColorName variable is defined as an optional String, with a default value of nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>userDefinedColorName変数は、省略時の値のnilを持つ、あるオプショナルのStringとして定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The value properties for the first three UnicodeScalar values (68, 111, 103) once again represent the characters D, o, and g.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初の３つのUnicodeScalar値（68、111、103）のためのvalueプロパティは、またふたたび文字D、o、そしてgを表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The value property of the fifth and final UnicodeScalar, 128054, is a decimal equivalent of the hexadecimal value 1F436, which represents the Unicode scalar U+1F436 for the DOG FACE character.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>５番目で最後のUnicodeScalarのvalueプロパティ、128054は、16進の値1F436の10進の等価物です、そしてそれは、DOG FACE文字のためのユニコード・スカラーU+1F436を表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The welcomeMessage variable can now be set to any string value without error:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>welcomeMessage変数は、現在エラーなしでどんな文字列値にでも設定されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The while loop’s condition is while square != finalSquare, to reflect that you must land exactly on square 25.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>whileループの条件は、あなたが正確に正方形25に到着しなければならないことを反映する、while square != finalSquareです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The willSet and didSet observers for totalSteps are called whenever the property is assigned a new value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>totalStepsのためのwillSetとdidSetオブザーバーは、プロパティが新しい値を代入されるときはいつでも呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The willSet and didSet observers of superclass properties are called when a property is set in a subclass initializer, after the superclass initializer has been called.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スーパークラスプロパティのwillSetとdidSetオブザーバーは、スーパークラスイニシャライザが呼び出され終わった後、あるプロパティがサプクラスのイニシャライザにおいて設定される時に呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The willSet and didSet observers provide a way to observe (and to respond appropriately) when the value of a variable or property is being set.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>willSetとdidSetオブザーバーは、変数またはプロパティの値が設定されている時に監視する（そして適切に応答する）方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The wiseWords constant contains two escaped double quotation marks.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数のwiseWordsは、２つのエスケープされた二重引用符文字を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Car class also overrides the description property it inherits from Vehicle, to provide a custom description that includes the current gear:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Carクラスはまた、それがVehicleから継承するdescriptionプロパティをオーバーライドして、現在のギアーを示すあつらえの説明を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Comparable protocol’s default implementation of &lt;=, &gt;, and &gt;= provides the remaining comparison operators.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Comparableプロトコルのもつ&lt;=、&gt;、そして&gt;=の省略時の実装は、残りの比較演算子を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Text structure wraps a string to make it part of a drawing.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Text構造体は、文字列をラップしてそれを描画の一部とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The apartment property is optional, because a person may not always have an apartment.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>人は必ずしもアパートを持つわけではないので、apartmentプロパティはオプショナルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The makeIncrementer function defines a nested function called incrementer, which performs the actual incrementing.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>makeIncrementer関数はincrementerと呼ばれる入れ子にされた関数を定義します、それは、実際に増やすことを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The switch case matches the current value of point only if the where clause’s condition evaluates to true for that value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このswitchケース節は、pointの現在の値に、where節の条件がtrueに評価する場合にのみ適合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The fixedIncrement property is also an optional requirement, so its value is an optional Int value, even though fixedIncrement is defined as a non-optional Int property as part of the CounterDataSource protocol definition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>fixedIncrementプロパティもまたオプショナルの要件です、なのでその値はオプショナルのInt値です、たとえfixedIncrementが非オプショナルのIntプロパティであるとCounterDataSourceプロトコル定義の部分では定義されるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The AllCaps structure wraps and modifies another drawing, converting any text in the drawing to uppercase.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>AllCaps構造体は、別の描画をラップおよび修正して、あらゆるテキストをその描画においてアッパーケースに変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The description property uses optional binding to check whether there’s a second value to display, and if so, inserts additional description detail for that second value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>descriptionプロパティは、オプショナル束縛を使って、表示する第２の値があるかどうか調べます、そしてもしそうなら、追加の記述詳細をその第２の値に関して差し込みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Country initializer can therefore pass self as one of the parameters for the City initializer when the Country initializer is setting its own capitalCity property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Countryイニシャライザはしたがって、selfをCityイニシャライザのパラメータの１つとして渡すことが、Countryイニシャライザが自身のcapitalCityプロパティを設定しているときに可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The default case adds some extra text to the end of the description, and the switch statement is complete.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>defaultケース節はこの解説（description）の終わりに追加の若干のテキストを加えます、そしてswitch文は終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The async-let syntax described in the previous section creates a child task for you.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>前の節で記述されるasync-let構文は、子タスクをあなたの代わりに作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The continue gameLoop statement ends the current while loop iteration and begins the next iteration of the loop.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>continue gameLoop文は、現在のwhileループ繰り返しを終えて、ループの次の繰り返しを開始します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The name property is automatically given a default value of nil, or “no name value”, because it’s of an optional type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>nameプロパティは省略時の値のnil、つまり「name値なし」を自動的に与えられます、なぜならそれがオプショナル型であるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The COMBINING ACUTE ACCENT scalar is graphically applied to the scalar that precedes it, turning an e into an é when it’s rendered by a Unicode-aware text-rendering system.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>COMBINING ACUTE ACCENTスカラーは、それの前のスカラーに追加筆記され、eを、それがユニコードに通じたテキスト描画システムによって表わされる時に、éにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The BlackjackCard structure contains two nested enumeration types called Suit and Rank.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>BlackjackCard構造体は、SuitとRankと呼ばれる２つの入れ子にされた列挙型を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Celsius structure implements two custom initializers called init(fromFahrenheit:) and init(fromKelvin:), which initialize a new instance of the structure with a value from a different temperature scale:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Celsius構造体は、init(fromFahrenheit:)とinit(fromKelvin:)と呼ばれる２つのあつらえのイニシャライザを実装します、それは、その構造体の新しいインスタンスを異なる温度尺度の値を使って初期化します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Container protocol needs to specify that any value passed to the append(_:) method must have the same type as the container’s element type, and that the value returned by the container’s subscript will be of the same type as the container’s element type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Containerプロトコルは、append(_:)メソッドに渡されるあらゆる値がそのコンテナの要素の型と同じ型を持たなければならないこと、そしてコンテナの添え字によって返される値がコンテナの要素型と同じ型のものになることを指定する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Fahrenheit structure has one stored property, temperature, which is of type Double:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Fahrenheit構造体は、１つの格納プロパティ、temperatureを持ちます、それはDouble型です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Food class introduces a single String property called name and provides two initializers for creating Food instances:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Foodクラスは、nameと呼ばれる１つのStringプロパティを導入して、２つのイニシャライザをFoodインスタンスをつくるために提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Point example shown above could have been written in the following way instead:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上で示されるPointの例は、その代わりに以下のようにして書かれることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The TemperatureLogger actor has properties that other code outside the actor can access, and restricts the max property so only code inside the actor can update the maximum value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>TemperatureLoggerアクターはプロパティいくつかを持ちます、それらはそのアクターの外側の他のコードがアクセスできます、そしてmaxプロパティを制限します、それでアクター内部のコードだけが最大値を更新することが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The anotherGreeting(for:) function returns the same greeting message, using the return keyword like a longer function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>anotherGreeting(for:)関数は、同じ挨拶メッセージを返します、もっと長い関数のようにreturnキーワードを使って。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The break statement can be used inside a switch or loop statement when you want to terminate the execution of the switch or loop statement earlier than would otherwise be the case.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>break文は、これを使わなかった場合よりも早くswitchまたはループ文の実行をあなたが終了したい時に、switchやループ文の内側で使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The buildBlock(_:) method adds support for writing a series of lines in a block of code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>buildBlock(_:)メソッドは、あるコードのブロックの中の一連の行を記述することに対するサポートを加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The dollarSign, blackHeart, and sparklingHeart constants demonstrate the Unicode scalar format:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>dollarSign、blackHeart、そしてsparklingHeart定数は、Unicodeスカラーの書式を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The dynamicCallable attribute’s methods specify only the type used to hold the array of arguments.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>dynamicCallable属性のもつメソッドは、引数それらからなる配列を保持するために使われる型だけを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The grid array for this Matrix instance is effectively a flattened version of the matrix, as read from top left to bottom right:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このMatrixインスタンスのためのgrid配列は、実際にはこのMatrix 行列の、左上から右下へと読まれる、平らにされた改変板です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The let keyword is only used for constant properties, to indicate that their values can’t be changed once they’re set as part of instance initialization.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>letキーワードは定数プロパティのためにだけ使われます、そして一旦それがインスタンス初期化の一部として設定されるならば、その値が変わることができないことを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The lowerThan precedence group attribute may only be used to refer to precedence groups declared outside of the current module.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>lowerThan優先順位グループ属性は、現在のモジュールの外側で宣言される優先順位グループを参照するのに使われるだけでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The nonobjc attribute tells the compiler to make the declaration unavailable in Objective-C code, even though it’s possible to represent it in Objective-C.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>nonobjc属性は、コンパイラにその宣言がObjective-Cコードにおいて利用不可にされることを伝えます、たとえそれがObjective-Cにおいて表現可能であってもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The optional modifier can be applied only to members that are marked with the objc attribute, and only to members of protocols that are marked with the objc attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>optional修飾子は、objc属性で印されるメンバにだけ、そしてobjc属性で印されるプロトコルのメンバにだけ適用されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The possibleIntegerValue variable has an implicit initial value of nil by virtue of being an optional type, and so the optional binding will succeed only if possibleIntegerValue was set to an actual value by one of the switch statement’s first four cases.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>possibleIntegerValue変数は、オプショナル型であることの長所によって暗黙的な初期値のnilを持ちます、そのためpossibleIntegerValueがswitch文の最初の４つのケース節の内の１つによって実際の値に設定された場合にのみこのオプショナル束縛は成功します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The throws keyword is part of a function’s type, and nonthrowing functions are subtypes of throwing functions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>throwsキーワードは関数の型の一部です、そしてスローを行わない関数はスロー関数の下位型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The @escaping attribute is described above in Escaping Closures.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>@escaping属性は、上の脱出クロージャで解説されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The AutomaticCar class represents a car with an automatic gearbox, which automatically selects an appropriate gear to use based on the current speed:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>AutomaticCarクラスはオートマチック・ギアボックスをもつ車を表します、それは、現在の速度に基づいて自動的に使用するのに適切なギアを選びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The AutomaticallyNamedDocument subclass overrides both of the designated initializers introduced by Document.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>AutomaticallyNamedDocumentサブクラスは、Documentで導入される指定イニシャライザを両方ともオーバーライドします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Bank class manages a made-up currency, which can never have more than 10,000 coins in circulation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Bankクラスは、ある架空の通貨を管理します、そしてそれは、流通する10,000個以上のコインを決して持つことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Car class introduces a new stored property called gear, with a default integer value of 1.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Carクラスは、gearと呼ばれる、1の省略時の値を持つ、新しい格納プロパティを導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The CartItem class models an item in an online shopping cart.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>CartItemクラスは、あるオンライン買物かごの中のひとつの項目をモデル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Container structure is generic, and the where clauses in the example below specify what type constraints have to be satisfied to make these new methods available on a container.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Container構造体は総称体です、そして下の例の中のwhere節は、どんな型制約がそれら新しいメソッドをあるコンテナ上で利用可能にするためには満たされなければならないかを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Counter class also defines a method called increment, which increments the count property every time the method is called.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Counterクラスはまた、incrementと呼ばれるメソッドを定義します、それは、メソッドが呼ばれるたびにcountプロパティを増加させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Line structure represents a single-line drawing, and it serves the top-level container for most drawings.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Line構造体は、ある単一行の描画を表します、そしてそれはほとんどの描画に対するトップレベルコンテナとして利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Matrix structure’s subscript takes two integer parameters:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Matrix構造体の添え字は、２つの整数パラメータをとります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Person class also has a deinitializer that prints a message when an instance of the class is deallocated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Personクラスはまた、クラスのインスタンスが割り当て解除されるとき、メッセージを出力するデイニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Player class also implements a deinitializer, which is called just before a Player instance is deallocated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Playerクラスはまた、デイニシャライザを実装します、それはPlayerインスタンスが割り当て解除される直前に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The RecipeIngredient class models an ingredient in a cooking recipe.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>RecipeIngredientクラスは、料理のレシピの材料をモデル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The ShoppingListItem class models a recipe ingredient as it appears in a shopping list.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ShoppingListItemクラスは、それが購入品目リストに現れるように、レシピの材料をモデル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Values structure defines two properties to represent this:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Values構造体は、これを表すために２つのプロパティを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The a in the inner scope is initialized with the value of the a in the outer scope when the closure is created, but their values aren’t connected in any special way.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>内側のスコープの中のaは、クロージャが作成される時に外側のスコープの中のaの値で初期化されます、しかしそれらの値は何ら特別な方法で結びつけられません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The arch(i386) platform condition returns true when code is compiled for the 32–bit iOS simulator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>arch(i386)プラットホーム条件は、コードが32ビットiOSシミュレーターに対してコンパイルされるときtrueを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The as! operator returns a value of the specified type, not an optional type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>as!演算子は指定された型の値を返します、オプショナル型ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The as? operator returns an optional of the specified type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>as?演算子は、指定された型のオプショナルを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The draw(_:) and caps(_:) functions both take a single closure as their argument, which is marked with the @DrawingBuilder attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>draw(_:)とcaps(_:)関数は、両方ともある単一のクロージャをそれらの引数として取ります、それは@DrawingBuilder属性で印されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>fallthroughキーワードは、Cの標準のswitch文の挙動でのように、単に次のケース節（またはdefaultケース節）ブロックの中の文へ、コード実行を直接に移すことを引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The game parameter has a type of DiceGame, not SnakesAndLadders, and so gameDidStart(_:) can access and use only methods and properties that are implemented as part of the DiceGame protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>gameパラメータは、型DiceGameを持ちます、SnakesAndLaddersではありません、なので、gameDidStart(_:)はDiceGameプロトコルの一部として実施されるメソッドとプロパティだけにアクセスして使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The increment() method uses optional chaining to try to call increment(forCount:), and passes the current count value as the method’s single argument.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>increment()メソッドは、オプショナル連鎖を使ってincrement(forCount:)を呼ぶことを試みます、そしてメソッドのもつただ１つの引数として現在のcount値を渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The is pattern appears only in switch statement case labels.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>isパターンは、switch文のケース節ラベルだけで見かけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The is pattern behaves like the is operator in that they both perform a type cast but discard the returned type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>isパターンは、それらが両方とも型キャストを実行するが返された型を捨てるという点において、is演算子のようにふるまいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The makeIterator() function provides access to a container’s iterator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>makeIterator()関数は、コンテナの持つイテレータに対するアクセスを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The mutating keyword is only used by structures and enumerations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>mutatingキーワードは、構造体と列挙によって使われるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The objcMembers attribute is a convenience for libraries that make heavy use of the introspection facilities of the Objective-C runtime.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>objcMembers属性は、Objective-Cランタイムの自己観察便宜の重度の使用を生じさせるライブラリにとって好都合です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The separator and terminator parameter have default values, so you can omit them when you call this function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>separatorとterminatorパラメータは省略時の値を持ちます、それであなたはそれらを省略することが、この関数をあなたが呼び出す時に可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The someContainer argument is of type C1, and the anotherContainer argument is of type C2.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>someContainer引数は型C1です、そしてanotherContainer引数は型C2です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The square variable is initialized with an origin point of (0, 0), and a width and height of 10.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>square変数は、(0, 0)の原点、そして10の幅と高さで初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The stepForward(_:) function returns a value one more than its input value, and the stepBackward(_:) function returns a value one less than its input value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>stepForward(_:)関数は、その入力された値より１大きい値を返します、そしてstepBackward(_:)関数はその入力された値より１小さい値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The suffix(_:) method returns a given number of elements from the end of the container, storing them in an instance of the Suffix type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>suffix(_:)メソッドは、コンテナの終わりから指定の数の要素を、それらをSuffix型のインスタンスの中に格納して、返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The switch statement determines which branch should be selected.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>switch文は、どの分岐が選ばれるべきか決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The while loop has a statement label called gameLoop to indicate that it’s the main game loop for the Snakes and Ladders game.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>whileループは、gameLoopと呼ばれる文ラベルを持ち、それが「ヘビとはしご」ゲームのための主なゲーム・ループであることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The init() initializer provides a default placeholder name for a new food by delegating across to the Food class’s init(name: String) with a name value of [Unnamed]:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>init()イニシャライザは、Foodクラスのinit(name: String)に[Unnamed]のname値を使って横に委任することで、省略時のプレースホルダ名を新しい食物のために用意します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Address class type for this property is defined below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このプロパティのためのAddressクラス型は、下で定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Aged protocol has a single requirement for a gettable Int property called age.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Agedプロトコルは、取得可能なIntプロパティでageと呼ばれるものに対するただ１つの要件を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Animal structure also defines a failable initializer with a single parameter called species.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Animal構造体はまた、speciesと呼ばれるただ１つのパラメータを持つ、失敗できるイニシャライザを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Country class implements the area requirement directly as a stored property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Countryクラスは、area要件を格納プロパティとして直接に満たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Equatable protocol provides a default implementation of !=.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Equatableプロトコルは、!=の省略時の実装を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Tandem subclass also adds a new stored property called currentNumberOfPassengers, with a default value of 0.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Tandemサブクラスはまた、currentNumberOfPassengersと呼ばれる新しい格納プロパティを、0の省略時の値を使って追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The TemperatureLogger actor keeps track of a list of temperatures and a maximum temperature, and it updates the maximum temperature when you record a new measurement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>TemperatureLoggerアクターは温度それらのリストと最大温度を追跡し続けます、そしてそれは最大温度をあなたが新しい測定を記録する時に更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The buildEither(first:) and buildEither(second:) methods add support for if-else.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>buildEither(first:)とbuildEither(second:)メソッドは、if-elseに対するサポートを加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The chooseStepFunction(backward:) function returns the stepForward(_:) function or the stepBackward(_:) function based on a Boolean parameter called backward:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>chooseStepFunction(backward:)はstepForward(_:)関数あるいはstepBackward(_:)関数を、backwardと呼ばれるブールのパラメータに基づいて返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The didSet observer doesn’t provide a custom parameter name for the old value, and the default name of oldValue is used instead.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>didSetオブザーバーはあつらえのパラメータ名を古い値のために用意しません、そして省略時の名前のoldValueがその代わりに使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The didSet observer is called immediately after the new value is set.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>didSetオブザーバーは、新しい値が設定された直後に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The endIndex property is the position after the last character in a String.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>endIndexプロパティは、あるStringの最後の文字の後の位置を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The findIndex(ofString:in:) function returns an optional Int value, which will be the index of the first matching string in the array if it’s found, or nil if the string can’t be found:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>findIndex(ofString:in:)関数は、オプショナルのInt値を返します、それは、それが見つけられるならば配列での最初の合致している文字列のインデックスです、または文字列が見つけられることができないならばnilです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The mutating keyword is added to its definition to enable it to modify its properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>mutatingキーワードがその定義に加えられ、それにそのプロパティを修正するのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The objectWithArea constant is known to be of type HasArea, and so its area property can be accessed and printed in a type-safe way.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数のobjectWithAreaは、型HasAreaであるということを知られています、なので、そのareaプロパティは型安全な方法でアクセスされて出力されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The return statement is described in Functions, and the throw statement is described in Propagating Errors Using Throwing Functions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>return文は関数において、そしてthrow文はスロー関数を使ってエラーを伝えるにおいて記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The switch statement is better suited to more complex conditions with multiple possible permutations and is useful in situations where pattern matching can help select an appropriate code branch to execute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>switch文は、複数の可能な起こりうる組み合わせを伴うさらに複雑な状況によりよく適します、そして、パターンマッチングが適切なコード分岐を選択して実行する助けとなり得る状況において役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Dictionary type uses an optional subscript type to model the fact that not every key will have a value, and to give a way to delete a value for a key by assigning a nil value for that key.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Dictionary型は、すべてのキーに値があるというわけでないという事実をモデル化するために、そしてあるキーに対する値を削除する方法をそのキーに対してnilの値を代入することで提供するために、オプショナルの添え字型を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The * argument is required and specifies that on any other platform, the body of the code block guarded by the availability condition executes on the minimum deployment target specified by your target.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>*引数は必須であらゆる他のプラットホーム上を指定します、有効性条件によって保護されたコード・ブロックの本文はあなたのターゲットによって指定される最小の開発ターゲット上で実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Car class’s version of description then adds some extra text onto the end of this description to provide information about the current gear.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Carクラス版のdescriptionは、それからこの説明の最後に現在のギアーについての情報を提供するために追加のテキストを加えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Food class doesn’t have a superclass, and so the init(name: String) initializer doesn’t need to call super.init() to complete its initialization.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Foodクラスには、スーパークラスがありません、なので、init(name: String)イニシャライザはその初期化を完了するためにsuper.init()を呼ぶ必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The advance(to:) method returns a Boolean value to indicate whether or not it was actually able to set currentLevel.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>advance(to:)メソッドは、それが実際にcurrentLevelを設定することができたかどうか示すためにブールの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The asHTML property is of type () -&gt; String, or “a function that takes no parameters, and returns a String value”.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>asHTMLプロパティは型() -&gt; Stringです、あるいは「パラメータをとらなくて、String値を返す関数」。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The currentSpeed property’s value is used by a read-only computed String property called description to create a description of the vehicle.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>currentSpeedプロパティの値は、descriptionと呼ばれる読み込み専用の計算Stringプロパティによってその乗り物の解説を作成するために使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The fullName property uses the prefix value if it exists, and prepends it to the beginning of name to create a full name for the starship.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>fullNameプロパティは、prefix値を、それが存在するならば使います、そしてそれをnameの始めに付けて、その宇宙船の完全な名前をつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The is and as patterns have the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>isとasパターンは以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The numberOfWheels property is used by a computed property called description to create a String description of the vehicle’s characteristics:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>numberOfWheelsプロパティはdescriptionと呼ばれる計算プロパティによって使用されて、この乗り物の特徴のあるStringの解説を作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The shareHealth(with:) method below takes another Player instance as an in-out parameter, creating the possibility of overlapping accesses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下のshareHealth(with:)メソッドは、別のPlayerインスタンスをin-outパラメータとして取り、オーバーラップアクセスの可能性を作り出しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Snakes and Ladders game board setup takes place within the class’s init() initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ヘビとはしごゲーム盤設定は、このクラスのinit()イニシャライザ内で行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The assignment operator (a = b) initializes or updates the value of a with the value of b:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>代入演算子（a = b)）は、aの値をbの値で初期化または更新します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The assignment operator sets a new value for a given expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>代入演算子は、指定された式に対してある新しい値を設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The assignment of a precedence group specifies the precedence of an operator when used in an operation that includes optional chaining.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>優先順位グループのassignmentは、オプショナル連鎖を含む演算において使われる時ある演算子の優先順位を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The associativity of an operator specifies how a sequence of operators with the same precedence level are grouped together in the absence of grouping parentheses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>演算子の結合性は、グループ括弧がない場合に同じ優先順位レベルを持つひと連なりの演算子がどのようにまとめられるかを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The bitwise AND operator (&amp;) combines the bits of two numbers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ビット単位の論理積演算子（&amp;）は、２つの数のビットを結合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The bitwise NOT operator (~) inverts all bits in a number:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ビット単位の論理否定演算子（~）は、ある数の中の全てのビットを逆にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The bitwise OR operator (|) compares the bits of two numbers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ビット単位の論理和演算子（|）は、２つの数のビットを比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The bitwise XOR operator, or “exclusive OR operator” (^), compares the bits of two numbers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ビット単位の排他的論理和（XOR）演算子、あるいは「排他的論理和演算子」（^）は、２つの数のビットを比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The bitwise left shift operator (&lt;&lt;) and bitwise right shift operator (&gt;&gt;) move all bits in a number to the left or the right by a certain number of places, according to the rules defined below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ビット単位の左シフト演算子（&lt;&lt;）とビット単位の右シフト演算子（&gt;&gt;）は、下で定義される規則に従ってある数の中の全てのビットを左または右に特定の桁数だけ移動します（シフト：移す、ずらす）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The closed range operator (a...b) defines a range that runs from a to b, and includes the values a and b.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>完結範囲演算子（a...b）は、aからbまで続く範囲を定義します、それはaとbの値を含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The compilation condition can include the true and false Boolean literals, an identifier used with the -D command line flag, or any of the platform conditions listed in the table below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>compilation conditionは、trueとfalseのブールのリテラル、-Dコマンドラインフラグと共に使われる識別子、もしくは以下の表で列記されるプラットホーム条件を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The condition is evaluated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>条件が評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The constraint is a class type, protocol type, protocol composition type, or Any.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>constraint（制約）は、クラス型、プロトコル型、プロトコル合成型、またはAnyです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The constraint specifies that a type parameter inherits from a specific class or conforms to a protocol or protocol composition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>制約は、型パラメータが特定のクラスから継承する、もしくはあるプロトコルまたはプロトコル合成に準拠することを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The control expression of the switch statement is evaluated and then compared with the patterns specified in each case.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>switch文の制御式は、評価されて、それからそれぞれのケース節（case）で指定されるパターンと比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The fixity of an operator specifies the relative position of an operator to its operands.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>演算子の定着性は、その演算子の演算数に対する相対位置を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The function name can be any expression whose value is of a function type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数名は、それの値が関数型のものであるどんな式でも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The generic argument list is a comma-separated list of type arguments.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体引数リストは、型引数のコンマで区切られたリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The generic parameter list is a comma-separated list of generic parameters, each of which has the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体パラメータリストは、コンマで区切られた総称体パラメータのリストです、そしてそのそれぞれは以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The half-open range operator (a..&lt;b) defines a range that runs from a to b, but doesn’t include b.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>半開範囲演算子（a..&lt;b）は、aからbまで続く範囲を定義します、しかしbの値を含みません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The lexical structure of Swift describes what sequence of characters form valid tokens of the language.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトの語彙の構造は、どんな文字の連なりがこの言語の公式のトークン（個々の語、最少単位の語）を作り上げるかについて述べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The logical AND operator (a &amp;&amp; b) creates logical expressions where both values must be true for the overall expression to also be true.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>論理積演算子（a &amp;&amp; b）は、論理式をつくります、そこにおいて全体的な式もまたtrueになるためには、両方の値がtrueでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The logical NOT operator (!a) inverts a Boolean value so that true becomes false, and false becomes true.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>論理否定演算子（!a）は１つのブール値を逆にします、それでtrueはfalseに、falseはtrueになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The logical OR operator (a || b) is an infix operator made from two adjacent pipe characters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>論理和演算子（a || b）は、２つの隣接したパイプ文字から作られる接中辞演算子です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The lower group names and higher group names lists specify the new precedence group’s relation to existing precedence groups.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下方グループ名および上方グループ名リストは、新しい優先順位グループのもつ関係を既存の優先順位グループに対して指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The message consists of a string literal.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>messageは、文字列リテラルから成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The method name and property name must be a reference to a method or a property that’s available in the Objective-C runtime.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>method nameとproperty nameは、あるメソッドおよびプロパティへの参照で、それはObjective-Cランタイムにおいて利用可能なものでなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The method name can contain parentheses for grouping, as well the as operator to disambiguate between methods that share a name but have different type signatures.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>method nameは、グループにまとめるための丸括弧、その上に、名前を共有するが異なる型シグネチャを持つメソッド間の違いを明確にするためにas演算子を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The new name consists of a string literal.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>新しい名前は文字列リテラルからなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The nil-coalescing operator (a ?? b) unwraps an optional a if it contains a value, or returns a default value b if a is nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>nil合体演算子（a ?? b）は、それが値を持つならばオプショナルのaをアンラップします、またはaがnilならば省略時の値のbを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The parameter type is comma-separated list of types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>parameter typeはコンマ区切りの型のリストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The parameters have the same form as the parameters in a function declaration, as described in Function Declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>パラメータは、関数宣言で記述されるように、関数宣言でのパラメータと同じ形式を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The parameters in closure expression syntax can be in-out parameters, but they can’t have a default value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャ式構文中のparametersはin-outパラメータであることができます、しかしそれらは省略時の値を持つことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The parameters specify one or more indexes used to access elements of the corresponding type in a subscript expression (for example, the i in the expression object[i]).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>パラメータは、対応する型の要素にアクセスするために添え字式において使用する一種類以上のインデックスを指定します（例えば、式object[i]におけるiなど）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The path can contain multiple property names, separated by periods, to refer to a property of a property’s value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>pathは、ピリオドで区切った複数のプロパティ名を含むことで、あるプロパティの持つ値に属するプロパティを参照できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The path can include subscripts using brackets, as long as the subscript’s parameter type conforms to the Hashable protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>pathは角括弧を使う添え字を含むことができます、その添え字の持つパラメータ型がHashableプロトコルに準拠する限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The path can refer to self to create the identity key path (\.self).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>pathは、selfを参照することで、同一性キーパス（\.self）を作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The path can use optional chaining and forced unwrapping.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>pathは、オプショナル連鎖と強制アンラップを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The path consists of property names, subscripts, optional-chaining expressions, and forced unwrapping expressions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>pathは、プロパティ名、添え字、「オプショナル連鎖」式、そして強制アンラップ式からなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The projected value for a wrapped property is a second value that a property wrapper can use to expose additional functionality.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるラップされたプロパティに対する投影値は、２番目の値です、それはプロパティラッパーが使用することで追加的機能性を露出できるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The property name must be a reference to a property that’s available in the Objective-C runtime.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>property nameは、Objective-Cランタイムにおいて利用可能であるプロパティへの参照でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The remainder operator (a % b) works out how many multiples of b will fit inside a and returns the value that’s left over (known as the remainder).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>剰余演算子（a % b）は、どのくらい多くのbの倍数がaの内部に収まるかを計算して、残された値（余りとして知られるもの）を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The requirements in a generic where clause specify that a type parameter inherits from a class or conforms to a protocol or protocol composition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体where節の中の要件が指定するのは、型パラメータがクラスから継承するかまたはプロトコルやプロトコル合成に準拠するということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The setter name and enclosing parentheses are optional.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>セッター名と囲んでいる括弧は、任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The setter name and enclosing parentheses in the willSet and didSet clauses are optional.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>willSetとdidSet節の中のセッター名と囲んでいる丸括弧は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The setter name and enclosing parentheses is optional.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>セッター名、そして囲んでいる丸括弧は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The statements inside a code block include declarations, expressions, and other kinds of statements and are executed in order of their appearance in source code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コード・ブロックの内側の文は、宣言、式、そして他の種類の文を含みます、そしてソース・コードにおいてそれらの現れる順に実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The ternary conditional operator evaluates to one of two given values based on the value of a condition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>三項条件演算子は、ある条件の値に基づいて、２つの与えられた値のうちの１つへと評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The ternary conditional operator is a special operator with three parts, which takes the form question ? answer1 : answer2.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>三項条件演算子は３つの部分をもつ特別な演算子です、それは形式question ? answer1 : answer2をとります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type name can be omitted in contexts where type inference can determine the implied type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>type nameは、型推論が暗黙の型を判定できるところの文脈では省略できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type name is the name of a concrete type, including any generic parameters, such as String, [Int], or Set&lt;Int&gt;.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>type nameは、ある具象型の名前で、何らかの総称体パラメータを含みます、例えばString、[Int]、またはSet&lt;Int&gt;など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The unary plus operator (+) simply returns the value it operates on, without any change:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>単項プラス演算子（+）は、それが作用する値を、どんな変更もせずに、ただ単純に返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The version number consists of one to three positive integers, separated by periods.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>バージョン番号は、ビリオドで区切られた、１つから３つの正の整数から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The file path changes the value of #file, #fileID, and #filePath, and is a string literal.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>filename（ファイル名）は、#file、#fileID、そして#filePathの値を変更します、そしてひとつの文字列リテラルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The superclass appears first after the class name and colon, followed by any adopted protocols.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スーパークラスがまずクラス名とコロンの後に現れ、続いて随意の採用プロトコルが続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type annotation is optional when the type can be inferred from the initializer expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型注釈は、その型が初期化式から推論されることができる場合は随意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The existing type can be a named type or a compound type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>既存の型は、名前付きの型または複合の型でありえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The protocol member declarations are discussed in detail below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルメンバー宣言は、詳細に下で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The wrapped value of the property is the value that the getter and setter for this property expose.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのプロパティのラップされた値は、このプロパティに対するゲッターとセッターが露出する値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The return type specifies the type of the element being accessed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>戻り型は、アクセスされている要素の型を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The line number changes the value of #line, and is any integer literal greater than zero.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>line number（行番号）は、#lineの値を変更します、そして0より大きい何らかの整数リテラルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Basics</seg>
      </tuv>
      <tuv lang="ja">
        <seg>基本</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The CSS color value #CC6699 is written as 0xCC6699 in Swift’s hexadecimal number representation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>CSS色値#CC6699は、スウィフトの16進数表現では0xCC6699のように書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Problem That Generics Solve</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体が解決する問題</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Problem That Opaque Types Solve</seg>
      </tuv>
      <tuv lang="ja">
        <seg>不透明型が解決する問題</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Sorted Method</seg>
      </tuv>
      <tuv lang="ja">
        <seg>分類メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Swift code you compile to make an executable can contain at most one of the following approaches to mark the top-level entry point, regardless of how the code is organized into files and modules: the main attribute, the NSApplicationMain attribute, the UIApplicationMain attribute, a main.swift file, or a file that contains top-level executable code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがコンパイルして実行可能にするスウィフトコードは、トップレベルエントリポイントを印するために次の進入口のうち最大で１つを含むことができます、どのコードがファイルおよびモジュールに組織化されるかに関係になく：main属性、NSApplicationMain属性、UIApplicationMain属性、main.swiftファイル、またはトップレベル実行コードを含むファイル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Swift code you compile to make an executable can contain at most one top-level entry point, as discussed in Top-Level Code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがコンパイルして実行可能にするSwiftコードは、最大で１つのトップレベルエントリポイントを持つことができます、トップレベル・コードで記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Swift language defines the postfix ! as syntactic sugar for the named type Optional&lt;Wrapped&gt;, which is defined in the Swift standard library, with the additional behavior that it’s automatically unwrapped when it’s accessed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフト言語は、接尾辞!を糖衣構文としてスウィフト標準ライブラリで定義される名前付きの型Optional&lt;Wrapped&gt;に対して定義します、それはそれがアクセスされるとき自動的にアンラップされるという追加の挙動を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Swift language defines the postfix ? as syntactic sugar for the named type Optional&lt;Wrapped&gt;, which is defined in the Swift standard library.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフト言語は、接尾辞?を糖衣構文として名前付きの型Optional&lt;Wrapped&gt;に対して定義します、それは、スウィフト標準ライブラリで定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Swift language is relatively small, because many common types, functions, and operators that appear virtually everywhere in Swift code are actually defined in the Swift standard library.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフト言語は比較的小さいです、スウィフトのコードのほとんど至る所で見かける多くの通常の型、関数、そして演算子がスウィフト標準ライブラリで実際には定義されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Swift language provides the following syntactic sugar for the Swift standard library Array&lt;Element&gt; type:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフト言語は、スウィフト標準ライブラリのArray&lt;Element&gt;型のために以下の糖衣構文を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Swift language provides the following syntactic sugar for the Swift standard library Dictionary&lt;Key, Value&gt; type:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフト言語は、以下の糖衣構文をスウィフト標準ライブラリDictionary&lt;Key, Value&gt;型に提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Swift logical operators &amp;&amp; and || are left-associative, meaning that compound expressions with multiple logical operators evaluate the leftmost subexpression first.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトの論理演算子&amp;&amp;と||は、左結合です、複数の論理演算子を持つ複合式が最も左の下位の式を最初に評価することを意味しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Swift standard library also defines a Float type, which represents a 32-bit floating-point number.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフト標準ライブラリはまたFloat型も定義します、それは、32ビットの浮動小数点数を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Swift standard library also defines types for various sizes of signed and unsigned integers, as described in Integers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>整数で記述されるように、スウィフト標準ライブラリはまた、さまざまな大きさの符号つきおよび符号なし整数のために、いろいろな型を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Swift standard library defines a number of operators for your use, many of which are discussed in Basic Operators and Advanced Operators.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフト標準ライブラリは、いくつかの演算子をあなたが使うために定義します、その多くは基本の演算子と先進の演算子で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Swift standard library defines a protocol called Equatable, which requires any conforming type to implement the equal to operator (==) and the not equal to operator (!=) to compare any two values of that type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフト標準ライブラリは、Equatableと呼ばれるプロトコルを定義します、それは、それに準拠している全ての型に対してその型のあらゆる２つの値を比較するために同等演算子（==）と不等演算子（!=）を実装することを要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Swift standard library includes tuple comparison operators for tuples with fewer than seven elements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフト標準ライブラリは、いくらかのタプル比較演算子を、７要素より少数でのタプルに対して含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The above example uses a defer statement to ensure that the open(_:) function has a corresponding call to close(_:).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例は、defer文を使って、open(_:)関数がそれと対応するclose(_:)への呼び出しを持つことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The access control level of a type also affects the default access level of that type’s members (its properties, methods, initializers, and subscripts).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある型のアクセス制御水準はまた、その型のメンバー（それのプロパティ、メソッド、イニシャライザ、そして添え字）の省略時のアクセス水準に影響を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The access level for a function type is calculated as the most restrictive access level of the function’s parameter types and return type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数型のためのアクセス水準は、その関数のパラメータ型と戻り型での最も制限の多いアクセス水準と同じに算出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The access level for a generic type or generic function is the minimum of the access level of the generic type or function itself and the access level of any type constraints on its type parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体型または総称体関数のためのアクセス水準は、総称体型または関数自身のアクセス水準およびその型パラメータ上のあらゆる型制約のアクセス水準の最少のものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The access level for a tuple type is the most restrictive access level of all types used in that tuple.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タプル型のためのアクセス水準は、そのタプルで使われる全ての型での最も制限的なアクセス水準です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The access level of a nested type is the same as its containing type, unless the containing type is public.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>入れ子にされた型のアクセス水準は、それの容れ物である型と同じです、容れ物である型が公開である場合を除いて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The access level of each requirement within a protocol definition is automatically set to the same access level as the protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル定義内の各要件のアクセス水準は、自動的にプロトコルと同じアクセス水準に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The actual type to use for that associated type isn’t specified until the protocol is adopted.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その関連型のために使われる実際の型は、プロトコルが採用されるまでは指定されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The actual type to use in place of T is determined each time the swapTwoValues(_:_:) function is called.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Tの代わりに実際に使われる型は、swapTwoValues(_:_:)関数が呼ばれるたびに決定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The addition operator is also supported for String concatenation:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>加算演算子は、また、String連結に対してもサポートされます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The additional capabilities that classes support come at the cost of increased complexity.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスがサポートする追加の能力は、複雑さの増加という犠牲を伴います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The additional scheduling flexibility from parallel or asynchronous code also comes with a cost of increased complexity.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>並列または非同期のコードによって加味されたスケジュール的柔軟性はまた、複雑さの増加という犠牲を伴います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The appropriate choice of weak or unowned depends on the relationships between the different parts of your code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>弱いまたは非所有の適切な選択は、あなたのコードの異なる部分間の関係に依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The appropriate floating-point type to use depends on the nature and range of values you need to work with in your code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>使うのに適切な浮動小数点型は、あなたのコードにおいて扱わなければならない値の種別と幅に依ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The appropriate form to use depends on the scope at which the variable is declared and the kind of variable you intend to declare.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>使用するのに適切な形式は、その変数が宣言されるスコープとあなたが宣言するつもりである変数の種類に依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The argument for the canImport() platform condition is the name of a module that may not be present on all platforms.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>canImport()プラットホーム条件に対する引数は、全てのプラットホームには含まれないかもしれないあるモジュールの名前です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The argument is automatically converted to a closure, because the customerProvider parameter’s type is marked with the @autoclosure attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>引数は、自動的にクロージャに変換されます、なぜならcustomerProviderパラメータの型は@autoclosure属性で印されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The argument label is used when calling the function; each argument is written in the function call with its argument label before it.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>引数ラベルは、関数を呼び出すときに使われます；各引数は、関数呼び出しにおいてそれの前のそれの引数ラベルとともに書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The argument label makes it unambiguous which arguments are passed to the variadic parameter and which arguments are passed to the parameters that come after the variadic parameter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>引数ラベルは、可変長パラメータに渡される引数はどれか、そして可変長パラメータの後に来るパラメータに渡される引数はどれかを明白にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The argument to the objc attribute can also change the runtime name for that declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>objc属性に対する引数はまた、その宣言に対するランタイム名を変更できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The argument value passed to this parameter specifies how much runningTotal should be incremented by each time the returned incrementer function is called.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このパラメータに渡された引き数の値は、返されたインクリメンタ関数（漸増器関数）が呼ばれるたびに、どのくらいrunningTotalが増やされなければならないかについて指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The arguments to the initializer are passed like a function call when you create an instance of the class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>イニシャライザに対する引数は、あなたがクラスのインスタンスをつくるときに関数呼び出しのように渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The arithmetic addition operator is a binary operator because it operates on two targets and it’s an infix operator because it appears between those two targets.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>算術加算演算子は、それが２つの目標に作用するので二項演算子です、そして、それがそれらの２つの目標の間に現れるので接中辞演算子です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The array [16, 58, 510] is used to create the new array ["OneSix", "FiveEight", "FiveOneZero"]:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列[16, 58, 510]は、新しい配列["OneSix", "FiveEight", "FiveOneZero"]をつくるために使われます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The array is declared outside the scope of the function, which means the closures in the array can be executed after the function returns.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この配列は関数のスコープの外側で宣言されます、それは配列の中のクロージャが関数が戻った後で実行されることができるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The assignment is part of the optional chaining, which means none of the code on the right-hand side of the = operator is evaluated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この代入はオプショナル連鎖の一部です、それが意味するのは、=演算子の右手側で評価されるコードは何もないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The assignment operator (=) doesn’t return a value, to prevent it from being mistakenly used when the equal to operator (==) is intended.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>代入演算子（=）は値を返しません、同等演算子（==）が意図される時にそれが誤って使われるのを防ぐためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The assignment operator doesn’t return any value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>代入演算子は、少しの値も返しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The audio channels described above are represented by instances of the AudioChannel structure:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上で記述される音声のチャンネルは、AudioChannel構造体のインスタンスによって表されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The author of a property wrapper type is responsible for determining the meaning of its projected value and defining the interface that the projected value exposes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティラッパー型の作者は、その投影値の意味の決定にそして投影値を露出するインターフェイスの定義に責任があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The availability condition above specifies that in iOS, the body of the if statement executes only in iOS 10 and later; in macOS, only in macOS 10.12 and later.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の有効性条件が指定するのは、iOS上では、ifの本文はiOS 10以降でのみ；macOS上では、macOS 10.12以降でのみ実行することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The availability condition takes a comma-separated list of platform names and versions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>有効性条件は、プラットホーム名とバージョンのコンマ区切りのリストを取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The backticks aren’t considered part of the identifier; `x` and x have the same meaning.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>バッククォートは、識別子の一部とみなされません；`x`とxは、同じ意味を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The barcode example in Associated Values shows how cases of an enumeration can declare that they store associated values of different types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関連値におけるバーコード例は、それらが異なる型の関連値を格納することを、ある列挙のケース節それらがどのように宣言可能かを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The base class in the hierarchy is called Food, which is a simple class to encapsulate the name of a foodstuff.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この階層構造における基盤クラスはFoodと呼ばれています、それは、食品の名前をカプセル化する単純なクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The basic characteristic of an ASCII art shape is a draw() function that returns the string representation of that shape, which you can use as the requirement for the Shape protocol:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるASCIIアート形状の基本的な特徴は、その形状の文字列表現を返すdraw()関数です、それはあなたが要件としてShapeプロトコルに対して使用できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The basic form imports the entire module; it consists of the import keyword followed by a module name:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>基本の形式は、そのモジュール全体をインポートします；それは、importキーワードとそれに続くモジュール名から成ります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The basic syntax for type constraints on a generic function is shown below (although the syntax is the same for generic types):</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体関数に関する型制約のための基本の構文は、下で示されます（とはいえ構文は総称体型と同じものです）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The behavior of x as! T is the same as the behavior of (x as? T)!.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>x as! Tの挙動は、(x as? T)!の挙動と同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The behavior you see in your code is always as if a copy took place immediately.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがあなたのコードで見るこの挙動は、常にまるである１つのコピーが直ちに生じたかのようです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The bit-shifting behavior for unsigned integers is as follows:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>符号なし整数のためのビットシフト挙動は、次の通りです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The bitwise AND operator combines them to make the number 00111100, which is equal to an unsigned decimal value of 60:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ビット単位の論理積演算子は、それらを結合して、数00111100をつくります、それは、符号なしの10進数の60と等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The bitwise NOT operator is a prefix operator, and appears immediately before the value it operates on, without any white space:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ビット単位の論理否定演算子は、接頭辞演算子で、少しの空白なしで、それが作用する値の直前に現れまます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The bitwise NOT operator is then used to create a new constant called invertedBits, which is equal to initialBits, but with all of the bits inverted.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ビット単位の論理否定演算子は、それからinvertedBitsと呼ばれる新しい定数をつくるために使われます、それは、initialBitsと等しいです、しかし全てのビットは逆にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The bitwise OR operator combines them to make the number 11111110, which equals an unsigned decimal of 254:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ビット単位の論理和演算子は、それらを結合して、数11111110を作ります、それは、符号なしの10進数の254と等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The bitwise XOR operator sets both of these bits to 1 in its output value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ビット単位の排他的論理和演算子は、これらのビットの両方ともその出力値において1に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The board has 25 squares, and the aim is to land on or beyond square 25.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この盤には25の正方形があります、そして目ざすのは正方形25の上に乗るまたは越える事です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The body of a class contains zero or more declarations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスの本文は、０個以上の宣言を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The body of a protocol contains zero or more protocol member declarations, which describe the conformance requirements that any type adopting the protocol must fulfill.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルの本文は０以上のプロトコルメンバー宣言を含みます、それは、プロトコルを採用しているすべての型が満たさなければならない準拠要件を記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The body of a structure contains zero or more declarations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造の本文は、０以上の宣言を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The body of an actor contains zero or more declarations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>アクターの本文は、０個以上の宣言を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The body of an enumeration declared using either form contains zero or more values—called enumeration cases—and any number of declarations, including computed properties, instance methods, type methods, initializers, type aliases, and even other enumeration, structure, class, and actor declarations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>どちらの形式を使って宣言される列挙宣言の本文でも、０以上の値 ― 列挙ケース節と呼ばれるもの ― および任意の数の宣言から成っていて、計算プロパティ、インスタンスメソッド、型メソッド、イニシャライザ、型エイリアス、そして他の列挙、構造体、クラス、およびアクター宣言さえも含められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The body of an extension declaration contains zero or more declarations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張宣言の本文は、０個以上の宣言を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The body of each case must contain at least one executable statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それぞれのケース節の本文は、少なくとも１つの実行可能な文を含んでいることが必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The body of the greet(person:) function starts by defining a new String constant called greeting and setting it to a simple greeting message.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>greet(person:)関数の本文は、greetingと呼ばれる新しいString定数を定義してそれを単純な挨拶メッセージに設定することによって始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The body of the minMax(array:) function starts by setting two working variables called currentMin and currentMax to the value of the first integer in the array.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>minMax(array:)の本文は、currentMinとcurrentMaxと呼ばれる２つの作業用の変数を配列の最初の整数に設定することによって始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The body of the swapTwoValues(_:_:) function is identical to the body of the swapTwoInts(_:_:) function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>swapTwoValues(_:_:)関数の本文は、swapTwoInts(_:_:)関数の本文と同一です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The brackets tell Swift that T is a placeholder type name within the swapTwoValues(_:_:) function definition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この括弧は、TがswapTwoValues(_:_:)関数定義内のプレースホルダ型名であるとスウィフトに教えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The call in the following example doesn’t compile because there isn’t an implementation of dynamicallyCall(withArguments:) that takes KeyValuePairs&lt;String, String&gt;.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例における呼び出しはコンパイルしません、なぜならdynamicallyCall(withArguments:)の実装でKeyValuePairs&lt;String, String&gt;をとるものがないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The call to increment(forCount:) happens only if increment(forCount:) exists—that is, if it isn’t nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>increment(forCount:)への呼び出しは、increment(forCount:)が存在する場合にのみ起こります ― すなわち、それがnilでない場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The call to the digitNames dictionary’s subscript is followed by an exclamation point (!), because dictionary subscripts return an optional value to indicate that the dictionary lookup can fail if the key doesn’t exist.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>digitNames辞書への呼び出しの添え字の後に感嘆符（!）が続きます、なぜなら、キーが存在しない場合は辞書検索が失敗し得ることを意味するために、辞書添え字がオプショナルの値を返すからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The call to the someFunctionWithEscapingClosure function in the example above is an error because it’s inside a mutating method, so self is mutable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>someFunctionWithEscapingClosure関数への呼び出しは上の例においてエラーです、なぜならそれがある可変メソッドの内部にあるためです、それでselfは可変です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The call-as-function methods and the methods from the dynamicCallable attribute make different trade-offs between how much information you encode into the type system and how much dynamic behavior is possible at runtime.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>call-as-functionメソッドとdynamicCallable属性からのメソッドは、どのくらいの情報をあなたが型システムにエンコードするかそしてどのくらい動的挙動が実行時に可能かの間で、異なる取り引きを行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The calling code can use any type that conforms to the Comparable protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>呼び出しているコードは、Comparableプロトコルに準拠するあらゆる型を使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The capabilities described above for computing and observing properties are also available to global variables and local variables.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>計算するそして監視するプロパティに対して上で記述される可能なことは、また、グローバル変数とローカル変数に対して利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The case values of an enumeration are actual values, not just another way of writing their raw values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある列挙に属するケース節の値は実際の値です、単にそれらの生の値を別のやり方で書くことではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The cases of an enumeration can satisfy protocol requirements for type members.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙のケース節は、型メンバーに対するプロトコル要件を満たすことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The chapter’s example of Overriding Property Getters and Setters has been rewritten to show how to override a description property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この章のプロパティゲッターとセッターのオーバーライドの例は書き直されて、descriptionプロパティをオーバーライドする方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The characters are visually similar, but don’t have the same linguistic meaning:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの文字は視覚的には同じ形です、しかし同じ言語的意味を持ちません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The class also defines a deinitializer, which prints a message to show when an HTMLElement instance is deallocated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスもデイニシャライザを定義します、それは、HTMLElementインスタンスが割り当て解除される場合に示すメッセージを出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The class instance isn’t fully valid until the first phase ends.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>第１段階が終わるまで、クラスインスタンスは充分に有効ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The class is assumed to take a nontrivial amount of time to initialize.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（このクラスは、瑣末でない量の時間が初期化にかかると仮定されます。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The closed range operator has an alternative form for ranges that continue as far as possible in one direction—for example, a range that includes all the elements of an array from index 2 to the end of the array.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>完結範囲演算子は、一方向に可能な限り続く範囲 — 例えば、インデックス２から配列の最後までの配列のすべての要素を含む範囲、などに対する代替の形式を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The closed range operator is useful when iterating over a range in which you want all of the values to be used, such as with a for-in loop:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>完結範囲演算子は、あなたがその値の全てが使われることを望む、ある範囲全体に渡って繰り返すときに役に立ちます、例えばfor-inループで：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The closure can be used to create a string representation of any integer greater than zero.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このクロージャは、ゼロより大きいあらゆる整数の文字列表現を作るために使われることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The closure can then refer to and modify the values of those constants and variables from within its body, even if the original scope that defined the constants and variables no longer exists.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャはそれから、その本文内からそれらの定数と変数の値に言及することや修正することができます、たとえその定数と変数を定義した本来のスコープがもはや存在しないとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The closure expression also specifies a return type of String, to indicate the type that will be stored in the mapped output array.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャ式はまた、Stringの戻り型を指定します、それによってマップされた出力配列の中に格納されることになる型を指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The closure expression builds a string called output each time it’s called.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャ式は、それが呼ばれるたびに、outputと呼ばれる文字列をつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The closure expression examples below illustrate these optimizations by refining a single example of the sorted(by:) method over several iterations, each of which expresses the same functionality in a more succinct way.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下のクロージャ式の例は、これらの最適化を１つの例のsorted(by:)メソッドの改良をいくどか繰り返していくことで解説します、そして、そのそれぞれは同じ機能性をより簡潔な方法で表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The closure expression examples below use the sorted(by:) method to sort an array of String values in reverse alphabetical order.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下のクロージャ式の例は、sorted(by:)メソッドを使用してString値からなる配列を逆アルファベット順に分類します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The closure expressions passed to myFunction in code above are examples of this kind of immediate use.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のコードにおいてmyFunctionに渡されるクロージャ式は、この種の直接的な利用の例です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The closure in the example above calculates and sets the appropriate color for each square on the board in a temporary array called temporaryBoard, and returns this temporary array as the closure’s return value once its setup is complete.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例でのクロージャはtemporaryBoardと呼ばれる一時的な配列の中の板上の各正方形に対して適切な色を計算して設定します、そしてひとたびその準備が完了されるならば、この一時的な配列をクロージャの戻り値として返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The closure is called once for each item in the array, and returns an alternative mapped value (possibly of some other type) for that item.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャは、配列の中の各項目に対して一度だけ呼ばれて、その項目のための代わりの対応付けされた（おそらく何か他の型の）値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The code above calls the continue keyword whenever it matches a vowel or a space, causing the current iteration of the loop to end immediately and to jump straight to the start of the next iteration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のコードは、それが母音または空白と合致するたびにcontinueキーワードを呼んで、ループの現在の繰り返しを直ちに終わって、次の繰り返しのスタートへまっすぐポンと飛ぶようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The code above creates a department and its three courses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のコードは、ある学科とそれの３つの課程を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The code above creates a dictionary of mappings between the integer digits and English-language versions of their names.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のコードは、整数桁とそれらの名前の英語版の間で対応付けをする辞書を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The code above creates a new Counter instance; sets its data source to be a new ThreeSource instance; and calls the counter’s increment() method four times.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のコードは、新しいCounterインスタンスをつくり；それのデータ・ソースを新しいThreeSourceインスタンスであるように設定します；そして、counterのincrement()メソッドを４回呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The code above succeeds when john.residence has a non-nil value and will set roomCount to an Int value containing the appropriate number of rooms.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>john.residenceが非nil値を持って、roomCountを部屋の適当な数を含んでいるInt値に設定するとき、上のコードは成功します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The code above uses the ternary conditional operator and forced unwrapping (a!) to access the value wrapped inside a when a isn’t nil, and to return b otherwise.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のコードは、三項条件演算子と強制アンラップ（a!）を使って、aがnilでないならばa内部にラップされた値にアクセスします、それ以外ではbを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The code below adds a projectedValue property to the SmallNumber structure to keep track of whether the property wrapper adjusted the new value for the property before storing that new value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下のコードは、projectedValueプロパティをSmallNumber構造体に加えることで、プロパティラッパーがプロパティに対する新しい値を、その新しい値を格納する前に調節したかどうかを追跡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The code below defines a few types for drawing on a single line using stars and text.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下のコードは、単一の行上で星とテキストを使って描画するためにいくつかの型を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The code below shows four examples of these special characters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下のコードは、これらの特殊文字の４つの例を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The code below shows how a closure delays evaluation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下のコードは、どのようにクロージャが評価を遅らすかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The code below shows that the same error appears for overlapping write accesses to the properties of a structure that’s stored in a global variable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下のコードは、グローバル変数に格納される構造体に属するプロパティに対するオーバーラップする書き込みアクセスに、同じエラーが起こることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The code below shows the ArithmeticExpression recursive enumeration being created for (5 + 4) * 2:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下のコードは、(5 + 4) * 2に対して作成されている再帰列挙ArithmeticExpressionを示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The code in a closure has access to things like variables and functions that were available in the scope where the closure was created, even if the closure is in a different scope when it’s executed—you saw an example of this already with nested functions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるクロージャの中のコードは、そのクロージャが作成されたところのスコープ内で利用可能だった変数や関数といったものにアクセスをします、たとえそのクロージャが実行されるときに異なるスコープの中にあってもです ― あなたはこの例を入れ子にされた関数で既に見ました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The code in the examples above sets the initial value for the wrapped property by giving number an initial value in the definition of TwelveOrLess.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例におけるコードは、ラップされたプロパティに初期値を設定することを、numberを初期値に与えることによって、TwelveOrLessの定義の中で、行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The code in the following example refers to the projected value of the wrapper around height and width as $height and $width:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>次の例におけるコードは、heightとwidthを囲んでいるラッパーの投影値を、$heightと$widthとして参照します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The code inside makeTrapezoid() can return any type it needs to, as long as that type conforms to the Shape protocol, like the calling code does for a generic function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>makeTrapezoid()内部のコードは、それが必要とするどんな型でも返すことが、その型がShapeプロトコルに準拠する限りは可能です、呼び出しているコードが総称体関数に対してするように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The code inside that initializer sets the initial wrapped value and the initial maximum value, using the default values of zero and 12.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのイニシャライザの内側のコードは、初期ラップ値と初期最大値を設定します、ゼロと12の省略時の値を使って。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The code inside the function is written in a general way so it can handle whatever type the caller provides.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数の内側のコードは、ある一般化された方法で記述されます、それでそれは呼び出し側が提供するどんな型でも取り扱うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The code inside the module could build up the same shape in a variety of ways, and other code outside the module that uses the shape shouldn’t have to account for the implementation details about the list of transformations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>モジュール内のコードは、同じ形状をさまざまな方法で作り上げることができました、そしてその形状を使うモジュール外のその他のコードは、ずらっとある変形それらについての実装詳細に関知する必要はないはずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The code is executed regardless of whether the function throws an error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのコードは、関数がエラーをスローするかどうかに関係なく実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The code snippets below define four model classes for use in several subsequent examples, including examples of multilevel optional chaining.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下のコード切れっぱしは、複数階層のオプショナル連鎖の例を含む以降のいくつかの例のために、４つのモデル・クラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The code starts running from the first line and runs up to the first await.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コードは、最初の行から動作を開始します、そして最初のawaitに至るまで動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The code that calls max(_:_:) chooses the values for x and y, and the type of those values determines the concrete type of T.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>max(_:_:)を呼び出すコードは、xとyに対して値を選びます、そしてそれらの値の型はTの具象型を決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The code that calls the function needs to be written in a general way, like the implementation of a generic function, so that it can work with any Shape value that’s returned by makeTrapezoid().</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数を呼び出すコードは、ある一般的な方法で書かれることを必要とします、総称体関数の実装のように、それでそれは、makeTrapezoid()によって返されるあらゆるShapeと仕事できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The code that uses the result builder can include ordinary Swift syntax, like if and for, to handle conditional or repeated pieces of data.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>リザルトビルダーを使うコードは、通常のスウィフト構文、たとえばifおよびforなどを含むことで、条件付きでまたは繰り返してデータの断片を取り扱えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The code within a default case is executed only if no other cases match the control expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>他のいかなるケース節も制御式にマッチしない場合だけ、省略時のケース節内のコードは実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The code you provide is run any time the value changes outside of an initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが提供したコードは、その値がイニシャライザの外側で変化する時はいつでも実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The code you write as an implicit return value needs to return some value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが暗黙的戻り値として書くコードは、何らかの値を返す必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The colon in the declaration means “…of type…,” so the code above can be read as:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>宣言でのコロンは「…の型の…」を意味します、それで上のコードは次のように読まれることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The column number in which it begins.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それが始まるコラム番号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The compiler also detects methods with override that don’t actually override any method in the superclass.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コンパイラはまた、実際にはスーパークラスにおけるメソッドを少しもオーバーライドしないoverrideをもつメソッドも検出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The compiler assumes that preconditions are always true, and it optimizes your code accordingly.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コンパイラは、その前提条件が常にtrueであるとみなします、そしてそれはあなたのコードをそれを受けて最適化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The compiler can prove that memory safety is preserved because the two stored properties don’t interact in any way.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コンパイラはメモリ安全が守られることを立証できます、なぜなら２つの格納プロパティはどんな方法でも相互作用しないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The compiler displays the new name when emitting an error about the use of a renamed declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コンパイラは、ある改名された宣言の使用についてのエラーを発するときにその新しい名前を表示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The compiler implicitly adds the objc attribute to subclasses of any class defined in Objective-C.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コンパイラは、Objective-Cにおいて定義されたあらゆるクラスのサブクラスに暗黙的にobjc属性を加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The compiler is allowed to replace calls to an inlinable symbol with a copy of the symbol’s implementation at the call site.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コンパイラは、インライン可能シンボルへの呼び出しを、呼び出し場所でのそのシンボルの持つ実装のコピーで置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The compiler is optimized for performance and the language is optimized for development, without compromising on either.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コンパイラはパフォーマンスのために最適化され言語は開発のために最適化されます、どちらについても妥協することなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The compiler makes this possible using techniques like looking up information at runtime and adding a layer of indirection.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コンパイラは、これを、実行時に情報を検索することそして間接参照のレイヤーを加えることのような技術いくつかを使って可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The compiler synthesizes an identifier for the projected value by prefixing the name of the wrapped property with a dollar sign ($)—for example, the projected value for someProperty is $someProperty.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コンパイラは、ある識別子を投影値に対して合成します、ラップされたプロパティの名前にドル記号（$）で接頭辞をつけることによって — 例えば、somePropertyに対する投影値は$somePropertyです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The compiler synthesizes identifiers that begin with a dollar sign ($) for properties that have a property wrapper projection.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コンパイラは、ドル記号（$）で始まる識別子を、プロパティラッパー投影を持つプロパティに対して合成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The compiler synthesizes storage for the instance of the wrapper type by prefixing the name of the wrapped property with an underscore (_)—for example, the wrapper for someProperty is stored as _someProperty.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コンパイラは、ラッパー型のインスタンスのためにストレージを合成します、ラップされたプロパティの名前にアンダースコア（_）で接頭辞をつけることによって — 例えば、somePropertyに対するラッパーは、_somePropertyとして格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The compiler uses availability information in the SDK to verify that all of the APIs used in your code are available on the deployment target specified by your project.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コンパイラは、SDKの中の有効性情報を使って、あなたのコードの中で使用されるAPIの全てがあなたのプロジェクトで指定される開発対象で有効であることを確かめます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The compiler uses the information from the availability condition when it verifies that the APIs in that block of code are available.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コンパイラは、有効性条件からの情報を、それがそのブロックの中のAPIが利用可能であることを確かめる時に使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The compound assignment operators don’t return a value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複合代入演算子は、値を返しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The computed numberOfRooms property simply returns the value of the count property from the rooms array.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>計算numberOfRoomsプロパティは、単にrooms配列からcountプロパティの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The computed type property examples above are for read-only computed type properties, but you can also define read-write computed type properties with the same syntax as for computed instance properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の計算型プロパティの例は、読み出し専用の計算型プロパティのためのものです、しかしあなたはまた、計算インスタンスプロパティについては同じ構文をつかって読み書き両用の計算型プロパティを定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The concept of a stack is used by the UINavigationController class to model the view controllers in its navigation hierarchy.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スタックの概念は、UINavigationControllerクラスで使用されて、そのナビゲーション階層においてビュー・コントローラをモデル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The concept of optionals doesn’t exist in C or Objective-C.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルの概念は、CまたはObjective-Cの中に存在しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The concurrency model in Swift is built on top of threads, but you don’t interact with them directly.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトにおける並行性モデルはスレッドそれらの最上部に構築されます、しかしあなたはそれらと直接に相互作用しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The condition can also be an optional binding declaration, as discussed in Optional Binding.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>条件はまた、オプショナル束縛で議論される、オプショナル束縛宣言であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The condition can also be an optional binding declaration, as discussed in Optional Binding.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>条件はまた、オプショナル束縛で議論される、オプショナル束縛宣言であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The condition of a loop can be at the end instead, ensuring that the loop is run at least once.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ループの条件は終わりに置くことができます、その場合にはループが少なくとも一回は実行されることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The conditional form, as?, returns an optional value of the type you are trying to downcast to.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>条件（仮定）形式as?は、あなたがダウンキャストしようとしている型のオプショナルの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The constraint on Item is a generic where clause, which is discussed in Associated Types with a Generic Where Clause below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Itemでの制約は総称体whereです、それは下のwhere節を持つ関連型において議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The contents of a Dictionary are inherently unordered, and iterating over them doesn’t guarantee the order in which they will be retrieved.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Dictionaryの内容は本質的に順序付けされません、そしてそれらに繰り返すことはそれらが取り出される順番を保証しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The contents of a String can be accessed in various ways, including as a collection of Character values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるStringの内容は、いくつかのやり方でアクセスされることができます、それにはCharacter値からなるひとつのコレクションとしてを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The contents of this expression are also considered when performing type inference on the surrounding expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この式の内容はまた、型推論を実行する時に周囲の式上にあると見なされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The context and function name should make it clear that evaluation is being deferred.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文脈と関数名は、評価が猶予されていることを明確にしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The context in which a type conforms to a particular protocol is the minimum of the type’s access level and the protocol’s access level.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある型が特定のプロトコルに準拠するところの前後関係は、その型のアクセス水準とプロトコルのアクセス水準の最も低いものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The convenience initializer must call one of the two designated initializers, because it can only call another initializer from the same class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>便宜イニシャライザは、２つの指定イニシャライザのうちの１つを呼ぶに違いありません、なぜなら、それが同じクラスから別のイニシャライザを呼ぶことができるだけだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The corresponding argument must have no label in function or method calls.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>対応する引数には、関数またはメソッドの呼び出しにおいてラベルがあってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The corresponding argument must use the given argument label in function or method calls.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>対応する引数は、この引数ラベルを関数またはメソッドの呼び出しにおいて使わなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The corresponding implementation for Vector2D instances performs this operation on both the x and y properties:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Vector2Dインスタンスのための対応する実装は、xとyプロパティ両方の上でこの操作を実行します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The corresponding section in Strings and Characters has been removed, and various code examples have been updated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列と文字の中の関連する節は削除されました、そしてさまざまなコード例が更新されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The count of the characters returned by the count property isn’t always the same as the length property of an NSString that contains the same characters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>countプロパティによって返される文字の総数は、同じ文字を含むNSStringのlengthプロパティと常に同じではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The current while loop execution then ends, and the loop’s condition is checked to see if the loop should be executed again.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>現在のwhileループ実行はそれから終了します、そしてループが再び実行されなければならないかどうか見るためにループの条件が調べられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The current center position of a Rect can always be determined from its origin and size, and so you don’t need to store the center point as an explicit Point value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Rectの現在の中心位置は常にそのoriginとsizeから決定されることができます、なのであなたは中心点をわざわざPoint値として格納する必要ばありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The current login attempt counter is declared as a variable, because this value must be incremented after each failed login attempt.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>現在のログイン試行の計数は、この値が失敗したログインの試みそれぞれの後で増加する必要があるので、変数として宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The current loop execution then ends.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>現在のループ実行はそれで終わりです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The decimal fraction consists of a decimal point (.) followed by a sequence of decimal digits.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>小数部は、小数点（.）に続く一連の10進の桁から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The declaration for number in the example above marks the variable as private, which ensures number is used only in the implementation of TwelveOrLess.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>numberに対する宣言は上の例において、変数をprivateとして印します、それはnumberがTwelveOrLessの実装においてのみ使われることを保証します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The declaration has the IBAction, IBSegueAction, IBOutlet, IBDesignable, IBInspectable, NSManaged, or GKInspectable attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その宣言は、IBAction、IBSegueAction、IBOutlet、IBDesignable、IBInspectable、NSManaged、またはGKInspectableを持つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The declaration is an override in a subclass, and the superclass’s declaration has the objc attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その宣言は、サブクラスの中のオーバーライドである、そしてそのサブクラスの宣言がobjc属性を持つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The declaration must have the internal access-level modifier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>宣言は、internalアクセス水準修飾子を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The declaration of SimpleClass doesn’t need any of its methods marked as mutating because methods on a class can always modify the class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>SimpleClassの宣言はそのメソッドのどれも変化させるとして印される必要はありません、なぜならあるクラスに属するメソッドは常にそのクラスを修正できるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The declaration of a result builder type doesn’t actually have to include any protocol conformance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>リザルトビルダー型の宣言は、実際はどんなプロトコル準拠も含む必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The declaration of the dynamicallyCall(withArguments:) method must have a single parameter that conforms to the ExpressibleByArrayLiteral [https://developer.apple.com/documentation/swift/expressiblebyarrayliteral] protocol—like [Int] in the example above.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>dynamicallyCall(withArguments:)メソッドの宣言は、ExpressibleByArrayLiteral [https://developer.apple.com/documentation/swift/expressiblebyarrayliteral]プロトコルに準拠する単一のパラメータを持たなければいけません — 上の例の[Int]のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The declaration of the dynamicallyCall(withKeywordArguments:) method must have a single parameter that conforms to the ExpressibleByDictionaryLiteral [https://developer.apple.com/documentation/swift/expressiblebydictionaryliteral] protocol, and the return type can be any type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>dynamicallyCall(withKeywordArguments:)メソッドの宣言は、ある単一のパラメータを持たなければなりません、それはExpressibleByDictionaryLiteral [https://developer.apple.com/documentation/swift/expressiblebydictionaryliteral]プロトコルに準拠するものです、そして戻り型はどんな型でも構いません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The declaration satisfies a requirement from a protocol that has the objc attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その宣言は、objc属性を持つあるプロトコルからの要件を満たす。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The declaration that the available attribute applies to is ignored if the attribute specifies a platform or language version that doesn’t match the current target.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>available属性を適用される宣言は、その属性が現在の対象と合致しないプラットホームまたは言語バージョンを指定するならば無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The deeply nested parentheses after AllCaps are hard to read.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>AllCapsの後ろで深く入れ子にされた丸括弧は読みやすいとは言えません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The default access level of internal already matches this requirement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>省略時のアクセス水準である内部は、既にこの要件に合致しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The default inferred type of a string literal is String.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>初期状態で推論されるリテラル文字列の型は、Stringです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The default initializer (when available) is always a designated initializer for a class, and can be used to create a new Vehicle instance with a numberOfWheels of 0:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>省略時のイニシャライザは（利用可能な場合は）、常にクラスのための指定イニシャライザです、そして0のnumberOfWheelsをもつ新しいVehicleインスタンスを作成するために使用されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The default initializer simply creates a new instance with all of its properties set to their default values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>省略時のイニシャライザは、単に新しいインスタンスを、そのプロパティの全てをそれらの省略時の値に設定することで作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The default memberwise initializer for a structure type is considered private if any of the structure’s stored properties are private.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体型のための省略時のメンバー関連イニシャライザは、その構造体の格納プロパティのいずれかが非公開ならば、非公開であるとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The default types are Int for integer literals, Double for floating-point literals, String for string literals, and Bool for Boolean literals.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>省略時の型は、整数リテラルのためのInt、浮動小数点リテラルのためのDouble、文字列リテラルのためのString、そしてブールのリテラルのためのBoolです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The default value also makes it easier for you to take advantage of default initializers and initializer inheritance, as described later in this chapter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>省略時の値はまた、あなたが省略時のイニシャライザとイニシャライザ継承を活用することをより簡単にします、そのことはこの章の後で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The deferred statements may not contain any code that would transfer control out of the statements, such as a break or a return statement, or by throwing an error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>延期される文は、制御をその文の外に、例えばbreakやreturn文、またはエラーをスローすることによって移すいかなるコードも含んではいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The definition describes what the function does, what it expects to receive, and what it returns when it’s done.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定義は、関数が何をするか、それが何を受け取るのを予想するか、そしてそれが実行し終わったとき、それが何を返すかを記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The definition makes it easy for the function to be called unambiguously from elsewhere in your code:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定義は、関数があなたのコードのどこか他の場所から誤解の余地なく呼び出されることを簡単にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The definition of SmallNumber includes three initializers—init(), init(wrappedValue:), and init(wrappedValue:maximum:)—which the examples below use to set the wrapped value and the maximum value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>SmallNumberの定義は３つのイニシャライザを含みます — init()、init(wrappedValue:)、そしてinit(wrappedValue:maximum:) — それらは、下の例がラップ値と最大値を設定するのに使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The definition of typealias Item = Int turns the abstract type of Item into a concrete type of Int for this implementation of the Container protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定義typealias Item = Intは、抽象型Itemを具象型Intへと、Containerプロトコルのこの実装のために転向します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The definition of this convenience initializer makes RecipeIngredient instances quicker and more convenient to create, and avoids code duplication when creating several single-quantity RecipeIngredient instances.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この便宜イニシャライザの定義は、RecipeIngredientインスタンスを素早くより便利に作成されるようにします、そして数量１のRecipeIngredientインスタンスをいくつか作成する時にコードの繰り返しを防止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The deinitializer doesn’t take any parameters and is written without parentheses:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>デイニシャライザは、まったくパラメータを取りません、したがって丸括弧なしで書かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The description of the static methods uses three types as placeholders.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これら静的メソッドの説明は、３つの型をプレースホルダとして使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The designated initializer hands off to a superclass initializer to perform the same task for its own stored properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>指定イニシャライザは、そのスーパークラスのイニシャライザに、それ自身の格納プロパティに対して同じ作業を実行するように任せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The designated initializer makes sure that all of the subclass’s properties have a value, as per safety check 1.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>指定イニシャライザは、安全検査１のように、サブクラスのプロパティの全てが値を持つことを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The designated initializer of a class must initialize all of the class’s declared properties and it must do so before calling any of its superclass’s designated initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるクラスの指定イニシャライザは、そのクラスのもつ宣言されたプロパティのすべてを初期化しなければ成りません、そしてそれは何であれそれのスーパークラスの指定イニシャライザを呼ぶ前にそうしなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The dice is rolled at the start of each loop.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>さいころは、各ループの始まりで振られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The difference between a read and write access is usually obvious: a write access changes the location in memory, but a read access doesn’t.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>読み出しと書き込みアクセスの間の違いは、通常は明白です：書き込みアクセスはメモリ中の位置を変更します、しかし読み出しアクセスはそうしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The difference between assertions and preconditions is in when they’re checked: Assertions are checked only in debug builds, but preconditions are checked in both debug and production builds.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>表明と前提条件の間の違いは、それらが調べられる時にあります：表明はデバッグビルドにおいてのみ調べられます、しかし前提条件はデバッグおよび製品（プロダクション）ビルドの両方において調べられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The difference between instantaneous access and long-term access is that it’s possible for other code to run after a long-term access starts but before it ends, which is called overlap.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>即時アクセスと長期アクセスの違いは、ある長期アクセスが開始した後しかしそれが終わる前に他のコードに実行が可能であることです、それはオーバーラップと呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The difference between open and public access is described below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>開放と公開アクセスの間の違いは下で解説されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The difference between strings and substrings is that, as a performance optimization, a substring can reuse part of the memory that’s used to store the original string, or part of the memory that’s used to store another substring.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列と下位文字列の違いは、性能最適化として、下位文字列はオリジナルの文字列を格納するために使われるメモリについての、または別の下位文字列を格納するために使われるメモリの一部についての再利用ができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The difference is that when you use an unowned optional reference, you’re responsible for making sure it always refers to a valid object or is set to nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>違いは、あなたが非所有オプショナル参照を使う場合、あなたはそれが有効なオブジェクトを常に参照するまたはnilに設定されるのを確実にする責任があることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The duration of a memory access is either instantaneous or long-term.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メモリアクセスの期間は、即時か長期のどちらかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The dynamic shared object (DSO) handle in use where it appears.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それが現れる用法での動的共有オブジェクト（DSO）ハンドル。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The elements of a tuple can be referred to either by name or by number.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるタプルの要素それらは、名前または番号で言及されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The elements of an array can be accessed through subscripting by specifying a valid index value in square brackets: someArray[0] refers to the element at index 0, "Alex".</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列の要素は、角括弧の中に有効なインデックス値を指定することによる添え字指定を通してアクセスされることができます：someArray[0]]は、インデックス0での要素、"Alex"に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The else clause of an if statement can contain another if statement to test more than one condition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>if文のelse節は、複数の条件をテストするために別のif文を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The end result is the same, but the default value ties the property’s initialization more closely to its declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最終的な結果は同じものです、しかし省略時の値は、プロパティの初期化をより密接にその宣言に結び付けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The end result of calling this alternative version of the method will be exactly the same as for calling the earlier version.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メソッドのこの代替版を呼ぶ最終結果は、以前の版を呼ぶことと正確に同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The end result was two completely separate instances that contained the same numeric values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最終的な結果は２つの完全に別々のインスタンスです、そしてそれらは同じ数値を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The entire definition of the greeting(for:) function is the greeting message that it returns, which means it can use this shorter form.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>greeting(for:)関数の全体の定義は、それが返す挨拶メッセージです、それは、それがこの省略形を使用できるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The entire expression c?.property.performAction() has a value of an optional type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>式c?.property.performAction()の全体がオプショナル型の値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The entries in the capture list are initialized when the closure is created.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>キャプチャリストの中の登録項目は、クロージャが作成されるときに初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The enumeration below is a refinement of the earlier CompassPoint enumeration, with string raw values to represent each direction’s name:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の列挙は、前のCompassPoint列挙の改良版で、各方位の名前を表す文字列の生の値を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The enumeration below is a refinement of the earlier Planet enumeration, with integer raw values to represent each planet’s order from the sun:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の列挙は、以前のPlanet列挙の改良で、太陽からの各惑星の順番を表す整数の生の値をもちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The enumeration cases north, south, east, and west therefore also have an access level of public:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この列挙のケース節north、south、east、そしてwestはしたがってまた公開のアクセス水準を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The enumeration type is pattern-matched against the enumeration case patterns in the case blocks of the switch statement, as described in Enumeration Case Pattern.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙型は、switch文のケース節ブロックにおいて、列挙ケース節パターンに対してパターンのマッチされます、列挙ケース節パターンで記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The enumeration’s toggle implementation is marked as mutating, to match the Togglable protocol’s requirements:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙のtoggle実装は、Togglableプロトコルの要件に適合するように、mutatingとして印されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The error is then caught by the general catch clause.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>エラーは、それから一般的なcatch節によってキャッチされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The error on the last line of the example occurs for several reasons.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例の最後の行でのエラーは、いくつかの理由で発生します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The error that’s thrown continues to propagate until it’s handled by a catch clause of a do statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スローされたエラーは、それがdo文のcatch節によって処理されるまで伝達を続けていきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The escaped special characters \0 (null character), \\ (backslash), \t (horizontal tab), \n (line feed), \r (carriage return), \" (double quotation mark) and \' (single quotation mark)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>エスケープされた特殊文字の\0（ヌル文字）、\\（バックスラッシュ）、\t（水平タブ）、\n（ラインフィード）、\r（キャリッジリターン）、\"（二重引用符）と\'（一重引用符）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The exact meaning of “subscript” depends on the context in which it’s used.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>「添え字」の正確な意味は、それが使われる前後関係に依存します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example above also defines a new class called VideoMode, to describe a specific video mode for video display.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例は、また、ビデオ・ディスプレイのために特定のビデオ・モードを記述するために、VideoModeと呼ばれる新しいクラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example above and the example below have the same behavior.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例と下の例は同じ挙動を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example above calculates the value of one number to the power of another (in this case, 3 to the power of 10).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例は、ある数を他のもので乗算した値を計算します（この場合、3の10乗）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example above checks whether the temperature is less than or equal to 32 degrees Fahrenheit (the freezing point of water).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例は、温度が華氏32度（水の氷点）以下かどうか確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example above counts how many cases there are, and the example below uses a for-in loop to iterate over all the cases.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例は、どのくらい多くのケース節があるか数えます、そして下の例は、for-inループを使って全てのケース節にわたって反復します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example above creates a Stack instance to store String values, and pushes three strings onto the stack.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例は、StackインスタンスをつくってString値を格納します、そしてスタック上へ３つの文字列をプッシュします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example above creates a new Matrix instance with two rows and two columns.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例は、２つの行と２つの列で新しいMatrixインスタンスをつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example above creates a new Rect variable called square.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例は、squareと呼ばれる新しいRect変数をつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example above defines a dictionary called testScores, which contains two key-value pairs that map a String key to an array of Int values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例はtestScoresと呼ばれる辞書型を定義します、それは、２つの「キーと値」対を含んでいて、それはStringキーをInt値を持つ配列と関連づけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example above defines a new prefix operator called +++.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例は、+++と呼ばれる新しい接頭辞演算子を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example above defines a new structure called Resolution, to describe a pixel-based display resolution.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例は、ピクセルに基づくディスプレイ解像度を記述するために、Resolutionと呼ばれる新しい構造体を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example above defines a variable called numberOfLegs and initializes it with a dictionary literal containing three key-value pairs.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例は、numberOfLegsと呼ばれる変数を定義して、３つの「キーと値」の対を含んでいる辞書リテラルでそれを初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example above determines whether a positive or negative step is needed to move a variable called currentValue progressively closer to zero.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例は、currentValueと呼ばれる変数を次第にゼロにより近く動かすために正と負の一歩のどちらが必要とされるかを確定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example above implements an == operator to check whether two Vector2D instances have equivalent values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例は、ある==演算子を実装して、２つのVector2Dインスタンスが同等な値を持つかどうかを調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example above implements the unary minus operator (-a) for Vector2D instances.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例は、Vector2Dインスタンスのための単項マイナス演算子（-a）を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example above in Accessing Properties Through Optional Chaining attempts to set an address value for john.residence, even though the residence property is nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル連鎖を通してプロパティにアクセスするでの前の例は、あるaddress値をjohn.residenceに対して設定することを試みます、たとえresidenceプロパティがnilであるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example above is shorthand for the code below:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例は、下のコードの短縮形です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example above shows that calling alsoIncrementByTen is the same as calling incrementByTen.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例は、alsoIncrementByTenを呼び出すことはincrementByTenを呼び出す事と同じであるのを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example above shows that the original values of someInt and anotherInt are modified by the swapTwoInts(_:_:) function, even though they were originally defined outside of the function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例は、someIntとanotherIntの本来の値が、たとえそれらが元々は関数の外側で定義されたとしても、swapTwoInts(_:_:)関数によって修正されることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example above shows what happens if it’s called with an input value of "Anna", and an input value of "Brian".</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例は、それが"Anna"の入力値、そして"Brian"の入力値で呼ばれるならば、何が起こるかについて示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example above uses a very simple approach to dice rolling.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例は、さいころ振りに対する非常に単純なアプローチを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example above uses the default initializer for the ShoppingListItem class to create a new instance of the class with initializer syntax, written as ShoppingListItem(), and assigns this new instance to a variable called item.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例は、ShoppingListItemクラスのための省略時のイニシャライザを使って、このクラスの新しいインスタンスを作成します、ShoppingListItem()のように書かれる、イニシャライザ構文の所です、そしてこの新しいインスタンスをitemと呼ばれる変数に代入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example also creates an Array instance initialized with an array literal containing the same three strings as the stack.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例はまた、このスタックと同じ３つの文字列を含む配列リテラルで初期化されるArrayインスタンスをつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example also defines a wishHappyBirthday(to:) function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例はまた、wishHappyBirthday(to:)関数を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example also defines two supporting structures called Size and Point, both of which provide default values of 0.0 for all of their properties:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例はまた、SizeとPointと呼ばれる２つの支援の構造体を定義します、その両方はそれらのプロパティの全てに0.0の省略時の値を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below adds a new mutating method called square to Swift’s Int type, which squares the original value:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、squareと呼ばれる新しい変更メソッドをスウィフトのInt型に加えます、それは、もとの値を二乗します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below calculates the arithmetic mean (also known as the average) for a list of numbers of any length:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、どんな長さの数のリストに対しても、算術平均（また平均としても知られるもの）を計算します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below calls the Address class’s buildingIdentifier() method through optional chaining.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、オプショナル連鎖を通してAddressクラスのbuildingIdentifier()メソッドを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below categorizes an (x, y) point on the following graph:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、続くグラフ上でポイント(x, y)を分類します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below creates a dictionary to store the names of international airports.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、国際空港の名前を格納するための辞書を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below creates a set called favoriteGenres to store String values:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例は、favoriteGenresと呼ばれる集合をString値を格納するために作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below creates an array called shoppingList to store String values:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、String値を格納するshoppingListと呼ばれる配列をつくります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below defines a SkillLevel enumeration with cases for beginners, intermediates, and experts.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、SkillLevel列挙を、初心者（beginners）、中級者（intermediates）、そして熟練者（experts）に対する事例（ケース節）で定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below defines a Vector3D structure for a three-dimensional position vector (x, y, z), similar to the Vector2D structure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、Vector3D構造体を３次元の位置ベクトル(x, y, z)に対して定義する、Vector2D構造体に似たものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below defines a base class called Vehicle.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、Vehicleと呼ばれる基盤クラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below defines a class called Document.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、Documentと呼ばれるクラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below defines a custom Rect structure to represent a geometric rectangle.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、幾何学の長方形を表すためにあつらえのRect構造体を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below defines a function called minMax(array:), which finds the smallest and largest numbers in an array of Int values:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例はminMax(array:)と呼ばれる関数を定義します、それは、あるInt値の配列の中で最小および最大の数を見つけます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below defines a generic function called allItemsMatch, which checks to see if two Container instances contain the same items in the same order.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例はallItemsMatchと呼ばれる総称体関数を定義します、それは、２つのContainerインスタンスが同じ順序で同じ項目を含むかどうか見るために調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below defines a global function called someFunction(), without providing a specific access-level modifier for the function itself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、その関数自身に特定のアクセス水準修飾子を提供することなく、someFunction()と呼ばれるグローバル関数を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below defines a new class called StepCounter, which tracks the total number of steps that a person takes while walking.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、StepCounterと呼ばれる新しいクラスを定義します、それは、ある人が歩いている間にとる総歩数を追跡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below defines a new structure called Fahrenheit to store temperatures expressed in the Fahrenheit scale.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、Fahrenheitと呼ばれる新しい構造体を定義して、華氏尺度で表される温度を格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below defines a protocol called Togglable, which defines a single instance method requirement called toggle.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、Togglableと呼ばれるプロトコルを定義します、それは、toggleと呼ばれる１つのインスタンスメソッド要件を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below defines a structure called Animal, with a constant String property called species.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例は、Animalと呼ばれるある構造体を、speciesと呼ばれる定数Stringプロパティを使って定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below defines a structure called BlackjackCard, which models a playing card as used in the game of Blackjack.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下記の例はBlackjackCardと呼ばれる構造体を定義します、それは、「ブラックジャック」ゲームにおいて使われるときの遊戯カード、トランプカードをモデル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below defines a structure called Chessboard, which models a board for the game of chess.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例はChessboardと呼ばれる構造体を定義します、それは、「チェス」ゲーム用の盤をモデル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below defines a structure called FixedLengthRange, which describes a range of integers whose range length can’t be changed after it’s created:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例はFixedLengthRangeと呼ばれる構造体を定義します、それは、それが作成された後に範囲長が変更されることが出来ない、整数からなるある範囲を記述します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below defines a structure called LevelTracker, which tracks a player’s progress through the different levels or stages of a game.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例はLevelTrackerと呼ばれる構造体を定義します、それは、プレイヤーの進み具合をゲームの異なるレベルまたはステージを通して追跡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below defines a structure called Size with two properties called width and height.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、widthとheightと呼ばれる２つのプロパティをもつSizeと呼ばれる構造体を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below defines a structure called TrackedString, which keeps track of the number of times a string property is modified:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例はTrackedStringと呼ばれる構造体を定義します、それは、ある文字列プロパティが修正される回数を追跡します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below defines a subclass of Product called CartItem.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、CartItemと呼ばれるProductのサブクラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below defines an enumeration called OnOffSwitch.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、OnOffSwitchと呼ばれる列挙を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below defines an enumeration called TemperatureUnit, with three possible states (kelvin, celsius, and fahrenheit).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例は、３つの可能な状態（kelvin、celsius、そしてfahrenheit）を持つ、TemperatureUnitと呼ばれる列挙を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below defines two classes, Country and City, each of which stores an instance of the other class as a property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は２つのクラス、CountryとCityを定義します、そして、そのそれぞれは他のクラスのインスタンスをプロパティとして格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below defines two protocols for use with dice-based board games:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、さいころに基づく様々なボードゲームで使うために、２つのプロトコルを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below defines two variables, movieCount and songCount, which count the number of Movie and Song instances in the library array:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は２つの変数、movieCountとsongCountを定義します、それは、MovieとSongインスタンスの数をlibrary配列において数えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below exposes the getter for the enabled property of the ExampleClass to Objective-C code as isEnabled rather than just as the name of the property itself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例は、ExampleClassのenabledプロパティのためのゲッターをObjective-Cコードに、ただプロパティそれ自身の名前ではなくisEnabledとして露出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below extends the Container protocol from the previous examples to add a startsWith(_:) method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、以前の例のContainerプロトコルを拡張して、startsWith(_:)メソッドを追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below extends the generic Stack structure from the previous examples to add an isTop(_:) method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、以前の例の総称体Stack構造体を拡張して、isTop(_:)メソッドを加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below implements an addition assignment operator method for Vector2D instances:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、Vector2Dインスタンスのために追加代入演算子メソッドを実装します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below is identical to the Person and Apartment example from above, with one important difference.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、上記のPersonとApartment例に同一ですが、１つの重要な違いがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below iterates over each MediaItem in library, and prints an appropriate description for each item.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、上にlibraryの中の各々のMediaItemすべてに繰り返して、各項目の適切な説明を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below iterates over the items in the things array and queries the type of each item with a switch statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、things配列の中の項目のすべてに渡って繰り返して、switch文を使って各項目の型について問い合わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below shows a closure expression version of the backward(_:_:) function from above:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下記の例は、上のbackward(_:_:)関数のクロージャ式版を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below shows a computed property that’s defined by the superclass and overridden by its subclasses to add an observer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、ある計算プロパティを示します、それはスーパークラスによって定義されます、そしてそれのサブクラスそれらによってオーバーライドされて、あるオブザーバを加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below shows a simplified version of the Swift standard library’s generic dictionary type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、スウィフト標準ライブラリの総称体辞書型の簡略版を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below shows a version of the TrackedString structure in which the structure is defined with an explicit access level of public.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例は、TrackedString構造体のある改作を示します、そこにおいてこの構造体は公開の明示的なアクセス水準を使って定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below shows an init? failable initializer that produces an optional instance of a structure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、ある構造体のオプショナルインスタンスを生成する、失敗できるイニシャライザinit?を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below shows how to implement the arithmetic addition operator (+) for a custom structure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、あつらえの構造体のために算術加算演算子（+）を実装する方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below shows how you can create a strong reference cycle when using a closure that references self.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、selfに参照をつけるクロージャを使うとき、あなたがどのように強い参照循環をつくることができるかについて示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below shows how you define and call a type subscript:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、どのようにあなたが型添え字を定義して呼び出すかを示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below shows the equivalent version of function calls that do and don’t use trailing closure syntax:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、後付クロージャ構文を使用および使用しない同等版の関数呼び出しを示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below shows the syntax for stored and computed type properties:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例は、格納型プロパティおよび計算型プロパティのための構文を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below takes an (x, y) point, expressed as a simple tuple of type (Int, Int), and categorizes it on the graph that follows the example.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、ポイント(x, y)、型(Int, Int)の単純なタプルとして表されるもの、をとって、その例に続くグラフ上でそれを分類します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below takes an (x, y) point, expressed as a tuple of type (Int, Int), and categorizes it on the graph that follows:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下記の例は、ポイント(x, y)をとって、型(Int, Int)のタプルとして表し、それをあとに続くグラフに分類します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below tries to access the street property of the address property of the residence property of john.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、johnのresidenceプロパティのaddressプロパティのstreetプロパティにアクセスしようとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below tries to retrieve the name of the first room in the rooms array of the john.residence property using the subscript defined on the Residence class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、Residenceクラス上で定義される添え字を使って、john.residenceプロパティのrooms配列での最初の部屋の名前を取り出そうとします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below uses fallthrough to create a textual description of a number.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、fallthroughをある数の文章での説明をつくるために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below uses a lazy stored property to avoid unnecessary initialization of a complex class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、ある複雑なクラスの必要でない初期化を避けるために遅延格納プロパティを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below uses the initializer to try to convert a String into an Int:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、このイニシャライザを使用してStringをIntに変えることを試みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example below uses the nil-coalescing operator to choose between a default color name and an optional user-defined color name:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例は、nil合体演算子を、省略時の色の名前とオプショナルの利用者定義の色の名前とで選択するために使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example can be read as:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、次のように解釈されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example creates an array called things, which can store values of type Any:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例はthingsと呼ばれる配列をつくります、それは、Any型の値を格納することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example defines a Vector2D structure for a two-dimensional position vector (x, y), followed by a definition of an operator method to add together instances of the Vector2D structure:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例は、２次元の位置ベクトル(x, y)のためのVector2D構造体を定義します。そして、Vector2D構造体のインスタンスそれらを１つに加えるための演算子メソッドの定義が続きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example requires two supporting structures called Size and Point, both of which provide default values of 0.0 for all of their properties:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、SizeとPointと呼ばれる２つの補助する構造体を必要とします、その両方はそれらのプロパティすべてに0.0の省略時の値を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example shown above demonstrates a custom implementation of a binary infix operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上で示される例は、二項接中辞演算子のあつらえの実装を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example shows how the == operator isn’t available—it depends on specific type information that isn’t preserved by using a protocol type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、どのように==演算子が利用可能でないか示します — それは具体的な型情報に依存します、それはプロトコル型を使うことでは保全されないものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example starts by trying to downcast the current item as a Movie.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>例は、現在のitemをMovieとしてダウンキャストすることを試みることによって始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example then creates a new Person instance called birthdayPerson and passes this new instance to the wishHappyBirthday(to:) function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、それからbirthdayPersonと呼ばれる新しいPersonインスタンスをつくって、この新しいインスタンスをwishHappyBirthday(to:)関数に渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example uses optional chaining to set the first item in the "Dave" array to 91; to increment the first item in the "Bev" array by 1; and to try to set the first item in an array for a key of "Brian".</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、オプショナル連鎖を使って"Dave"配列の最初の項目を91に設定します；それから"Bev"配列の最初の項目を1だけ増加します；そしてそれから"Brian"のキーに対応する配列の最初の項目を設定することを試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The examples above show how to use safe unowned references.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例は、どのようにsafe非所有参照を使うかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The examples above use a for-in loop to iterate ranges, arrays, dictionaries, and strings.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例は、for-inループを使って、範囲、配列、辞書、そして文字列を繰り返し処理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The examples below consider an array of strings representing the scene locations from the first two acts of Shakespeare’s Romeo and Juliet:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の例は、シェークスピアのロミオとジュリエットの最初の２幕から、場面場所を表している文字列の配列を考えてみます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The examples for weak and unowned references above cover two of the more common scenarios in which it’s necessary to break a strong reference cycle.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の弱いおよび非所有参照のための例は、強い参照循環を壊すために不可欠なよくある筋書きのうちの２つを扱います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The examples in the previous section show how the cases of an enumeration are a defined (and typed) value in their own right.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>前の節での例は、列挙のケース節がどのように自分だけで定義された（そして型付けされた）値であるかについて示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The examples that follow use two stored type properties as part of a structure that models an audio level meter for a number of audio channels.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あとに続く例は、いくつかのオーディオ・チャンネル用のオーディオ・レベルをモデル化する構造体の一部として、２つの格納型プロパティを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The exclamation point effectively says, “I know that this optional definitely has a value; please use it.” This is known as forced unwrapping of the optional’s value:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>感嘆符は、実際上こう言っています、「私はこのオプショナルが間違いなくひとつの値を持つことを知っています；どうぞそれを使ってください」。これは、そのオプショナルの所有する値の強制アンラップとして知られます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The exponent consists of an upper- or lowercase e prefix followed by a sequence of decimal digits that indicates what power of 10 the value preceding the e is multiplied by.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>指数は、大文字または小文字の接頭辞e、それに続けてeの前の値が10の何乗を掛けられるかを示す一連の10進の桁から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The exponent consists of an upper- or lowercase p prefix followed by a sequence of decimal digits that indicates what power of 2 the value preceding the p is multiplied by.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>指数は、大文字または小文字のp接頭辞、それに続けてpの前の値が２の何乗を掛けられるかを示す一連の10進の桁から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The expression a += 2 is shorthand for a = a + 2.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>式a += 2は、a = a + 2の簡略な表現です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The expression a is always of an optional type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>aの式は常にオプショナル型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The expression b must match the type that’s stored inside a.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>bの式はaの中に格納される型に合致しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The expression is evaluated when the closure is created, and the value is captured with the specified strength.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その式は、クロージャが作成される時に評価されます、そしてその値は、指定された強さでキャプチャされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The expression represented by the expression pattern is compared with the value of an input expression using the Swift standard library ~= operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>式パターンによって表される式は、入力された式の値とスウィフト標準ライブラリ~=演算子を使って比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The expressions you write inside parentheses within an interpolated string can’t contain an unescaped backslash (\), a carriage return, or a line feed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>補間文字列においてあなたが丸括弧内に記述する式は、エスケープされないバックスラッシュ（\）、キャリッジリターン、またはラインフィードを含むことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The fact that asHTML is a lazy property means that you can refer to self within the default closure, because the lazy property will not be accessed until after initialization has been completed and self is known to exist.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>asHTMLが遅延プロパティだという事実は、あなたが省略時のクロージャ内でselfに言及することができることを意味します、なぜなら、遅延プロパティは、初期化が完了されてしまってselfが存在することを知られる後までアクセスされることはないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The fact that it’s queried through an optional chain means that the call to numberOfRooms will always return an Int? instead of an Int.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それがオプショナル連鎖によって問い合わせられるという事実は、numberOfRoomsへの呼び出しが常にInt?を返すことを意味します、Intではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The fact that structures and enumerations can define methods in Swift is a major difference from C and Objective-C.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体と列挙がスウィフトにおいてはメソッドを定義することができるという事実は、CやObjective-Cとの重大な違いです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The failable initializer for CartItem starts by validating that it has received a quantity value of 1 or more.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>CartItemのための失敗できるイニシャライザは、それが1以上のquantity値を受け取ったことを検証することによって始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The fallback logic to use “World” when name is nil has to be done inline using the ?? operator, which would be difficult with anything more complex.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>nameがnilの時に“World” を使う代替論理は、??演算子を使用してインラインにされる必要があり、それはより複雑なものでは難しいでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The fifth and sixth codeUnit values (55357 and 56374) are a UTF-16 surrogate pair representation of the DOG FACE character.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>５番目と６番目のcodeUnit値（55357と56374）は、DOG FACE文字のUTF-16代用対叙述です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The figure below illustrates how two of these audio channels can be combined to model a stereo audio level meter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の図は、これらの音声のチャンネルのうちの２つがステレオ音声のレベル・メーターをモデル化するために結合されることができる方法を図示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The figure below shows a more complex class hierarchy for four classes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の図は、４つのクラスのためのより複雑なクラス階層を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The figure below shows the initializer chain for the Food class:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の図は、Foodクラスのためのイニシャライザ連鎖を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The figure below shows the initializer chain for the RecipeIngredient class:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の図は、RecipeIngredientクラスのためのイニシャライザ連鎖を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The figure below shows the overall initializer chain for all three classes:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の図は、３つのクラス全てのために全体的なイニシャライザ連鎖を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The figure below shows these relationships:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の図は、それらの関係を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The final else clause is optional, however, and can be excluded if the set of conditions doesn’t need to be complete.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、最後のelse節は任意です、そして条件の集合が完全である必要がないならば、除外されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The final else clause remains, and it prints a response for any temperatures that are neither too warm nor too cold.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最後のelse節は同じままです、そしてそれはあまり暖かくもなくあまり寒くもないすべての気温に対しての応答を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The final case, case let (x, y), declares a tuple of two placeholder constants that can match any value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最後のケース節、case let (x, y)は、どんな値にでも適合することができるプレースホルダ定数を２つもつタプルを宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The final class in this model is called Address.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このモデルの中の最後のクラスは、Addressと呼ばれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The final code snippet above shows that the deinitializers for the Customer instance and CreditCard instance both print their “deinitialized” messages after the john variable is set to nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の最後のコード断片は、CustomerインスタンスとCreditCardインスタンスのためのデイニシャライザが両方ともそれらの「デイニシャライズされた」メッセージを、john変数がnilに設定された後に出力することを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The final snippet creates a constant array called library, which contains two Movie instances and three Song instances.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最終的な断片はlibraryと呼ばれる定数の配列をつくります、それは、２つのMovieインスタンスと３つのSongインスタンスを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first Rect initializer, init(), is functionally the same as the default initializer that the structure would have received if it didn’t have its own custom initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初のRectイニシャライザ、init()は、構造体が独自のあつらえのイニシャライザを持たない場合に受け取る省略時のイニシャライザと機能的に同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first and second requirements are defined in the function’s type parameter list, and the third and fourth requirements are defined in the function’s generic where clause.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初と２番目の要件は関数のもつ型パラメータリストにおいて定義されます、そして３番目と４番目の要件は関数のもつ総称体where節において定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first case, case (let x, 0), matches any point with a y value of 0 and assigns the point’s x value to the temporary constant x.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初のケース節、case (let x, 0)は、0のy値をもつどんなポイントにでも適合して、そのポイントのx値を一時的な定数xに代入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first closure expression is unlabeled; any additional closure expressions are preceded by their argument labels.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初のクロージャ式は、ラベルをつけられません；あらゆる追加的なクロージャ式は、それらの引数ラベルを前に置かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first closure is a completion handler that displays a picture after a successful download.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初のクロージャはある完了ハンドラです、それはあるピクチャを成功したダウンロードの後に表示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first example’s use of the ternary conditional operator means that rowHeight can be set to the correct value on a single line of code, which is more concise than the code used in the second example.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初の例の三項条件演算子の使用は、rowHeightがただ１行のコードで正しい値に設定されることができるのを意味します、それは２番目の例において使われるコードより簡潔です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first form allows code to be executed only when a condition is true and has the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初の形式は、条件が真である時にだけコードが実行されるようにし、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first form emits the error message as a fatal error and terminates the compilation process.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初の形式は、error message（エラーメッセージ）を致命的エラーとして発して、コンパイル処理を終わらせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first form evaluates to the value of the expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初の形式は、式の値に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first form is used to access a member of the superclass.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初の形式は、スーパークラスのメンバーにアクセスするために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first form of a line control statement changes the values of the #line, #file, #fileID, and #filePath literal expressions, beginning with the line of code following the line control statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初の形式の行制御文は、#line、#file、#fileID、そして#filePathリテラル式の値を変更して、行制御文の後に続くコードの行で始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first function, printAndCount(string:), prints a string, and then returns its character count as an Int.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初の関数、printAndCount(string:)は、ある文字列を出力して、それからその文字数をIntとして返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first initializer has a single initialization parameter with an argument label of fromFahrenheit and a parameter name of fahrenheit.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初のイニシャライザは、fromFahrenheitの引数ラベルとfahrenheitのパラメータ名を使うただ１つの初期化パラメータを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first is a type function called unlock(_:), which updates the value of highestUnlockedLevel whenever a new level is unlocked.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>第一は、unlock(_:)と呼ばれる型関数です、それは、新しいレベルが錠を開けられるときはいつでも、highestUnlockedLevelの値を更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first item in the array has an index of 0, not 1.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列での最初の項目が、1ではなく、0のインデックスを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first item in the array represents the top left square on the board and the last item in the array represents the bottom right square on the board.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列の最初の項目は盤上の一番左上の正方形を表わします、そして配列の最後の項目は盤上の一番右下の正方形を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first kind of pattern is used for destructuring values in simple variable, constant, and optional bindings.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初の種類のパターンは、単純な変数、定数、およびオプショナル束縛での非構成の値に使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first letter of the case name is capitalized.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ケース節の最初の文字は大文字で書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first pair has a key of "YYZ" and a value of "Toronto Pearson".</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初の組みは、"YYZ"のキーと"Toronto Pearson"の値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first parameter is called mathFunction, and is of type (Int, Int) -&gt; Int.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初のパラメータはmathFunctionと呼ばれていて、型(Int, Int) -&gt; Intです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first parameter that comes after a variadic parameter must have an argument label.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある可変長パラメータの後にくる最初のパラメータは、引数ラベルを持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first situation is when you explicitly conform to the same protocol multiple times, but with different requirements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>第一の状況は、あなたが明示的に同じプロトコルに対しての複数回の準拠を、しかし異なる要件を使って行う時です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first snippet defines a new base class called MediaItem.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初の断片は、MediaItemと呼ばれる新しい基盤クラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first subclass, Movie, encapsulates additional information about a movie or film.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初のサブクラスMovieは、映画またはフィルムに関する追加の情報をカプセル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first two calls succeed, because the testScores dictionary contains keys for "Dave" and "Bev".</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初の２つの呼び出しは成功します、なぜなら、testScores辞書は"Dave"と"Bev"のキーを含んでいるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first two properties, buildingName and buildingNumber, are alternative ways to identify a particular building as part of an address.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初の２つのプロパティ、buildingNameとbuildingNumberは、アドレスの一部として特定の建物を同定するそれぞれ代替の方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first type parameter, T, has a type constraint that requires T to be a subclass of SomeClass.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初の型パラメータTは、TにSomeClassのサブクラスであることを要求する型制約を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first, resolution, is initialized with a new Resolution structure instance, which infers a property type of Resolution.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>一番目、resolutionは、新しいResolution構造体インスタンスで初期化されます、そしてそれは、Resolutionのプロパティ型を暗に意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first, thresholdLevel, defines the maximum threshold value an audio level can take.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その一番目、thresholdLevelは、音声レベルがとることができる最大の限界値を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The fixity of the operator is specified by marking the operator declaration with the infix, prefix, or postfix declaration modifier before the operator keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>演算子の定着性は、演算子定義をoperatorキーワードの前にinfix、prefix、またはpostfix宣言修飾子を使って印することによって指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following if statements are equivalent:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下のif文は同等です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following approaches are equivalent:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の各取り組みは同等です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following are examples of literals:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下はリテラルの例です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following characters are considered whitespace: space (U+0020), line feed (U+000A), carriage return (U+000D), horizontal tab (U+0009), vertical tab (U+000B), form feed (U+000C) and null (U+0000).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の文字は、空白とみなされます：空白（U+0020）、行送り（U+000A）、復帰（U+000D）、水平タブ（U+0009）、垂直タブ（U+000B）、改ページ（U+000C）およびヌル（U+0000）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following closure expressions are equivalent:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下のクロージャ式は、等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following code accesses different values and properties of a dictionary of arrays by using key-path expressions that combine these components.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下のコードは、いくつかの配列からなる辞書に属する異なる値およびプロパティに、それらの構成要素を組み合わせるキーパス式を使うことでアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following code uses \.someProperty instead of \SomeClass.someProperty:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下のコードは、\.somePropertyを\SomeClass.somePropertyの代わりに使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following code uses the variable index in both a key-path expression and in a closure to access the third element of the greetings array.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下のコードは、変数indexをキーパス式の中でそしてクロージャの中での両方で使うことで、greetings配列の３番目の要素にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following declarations are equivalent:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の宣言は同等です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following example adds a new instance method called repetitions to the Int type:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例は、repetitionsと呼ばれる新しいインスタンスメソッドをInt型に加えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following example defines a Matrix structure, which represents a two-dimensional matrix of Double values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例はMatrix構造体を定義します、それはDouble値からなる２次元行列を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following example defines a class called SurveyQuestion, with an optional String property called response:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例は、responseと呼ばれるオプショナルのStringプロパティで、SurveyQuestionと呼ばれるクラスを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following example defines a custom Rect structure to represent a geometric rectangle.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例は、あつらえのRect構造体を定義して、幾何学的な長方形を表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following example defines a new class called AutomaticCar, which is a subclass of Car.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例はAutomaticCarと呼ばれる新しいクラスを定義します、それは、Carのサブクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following example defines a new class called Car, which is a subclass of Vehicle.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例は、Carと呼ばれる新しいクラスを定義します、それは、Vehicleのサブクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following example defines a new custom infix operator called +-, which belongs to the precedence group AdditionPrecedence:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例は、+-と呼ばれる新しいあつらえの接中辞演算子を定義します、それは優先順位グループAdditionPrecedenceに属します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following example defines a new subclass of Vehicle called Train, which overrides the makeNoise() method that Train inherits from Vehicle:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例は、Trainと呼ばれるVehicleの新しいサブクラスを定義します、それは、TrainがVehicleから受け継ぐmakeNoise()メソッドをオーバーライドします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following example defines a protocol with a single instance method requirement:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例は、１つのインスタンスメソッド要件で、プロトコルを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following example defines a structure called Celsius, which stores temperatures expressed in degrees Celsius.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例は、Celsiusと呼ばれる構造体を定義します、それは、摂氏度数で表される温度を格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following example defines a structure called Color, with three constant properties called red, green, and blue.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例はColorと呼ばれる構造体を定義します、それはred、green、そしてblueと呼ばれる３つの定数プロパティを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following example defines a subclass called Bicycle, with a superclass of Vehicle:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例は、Vehicleのスーパークラスを持つ、Bicycleと呼ばれるサブクラスを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following example defines an integer-counting class called Counter, which uses an external data source to provide its increment amount.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例はCounterと呼ばれる整数計数クラスを定義します、それは、その増加量を提供するために外部のデータ・ソースを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following example defines two classes, Customer and CreditCard, which model a bank customer and a possible credit card for that customer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例は２つのクラス、CustomerとCreditCardを定義します、それは、銀行顧客とその顧客のために可能なクレジットカードをモデル化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following example explicitly declares the conditional conformance of Array to Loggable to avoid a conflict when declaring its conditional conformance to both TitledLoggable and the new MarkedLoggable protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例は、Loggableに対してのArrayの条件準拠を明示的に宣言して、TitledLoggableと新しいMarkedLoggableプロトコルの両方に対してのそれの条件準拠を宣言する時に衝突を回避します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following example extends the generic Stack type to add a read-only computed property called topItem, which returns the top item on the stack without popping it from the stack:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例は総称体Stack型を拡張して、topItemと呼ばれる読み出し専用の計算プロパティを加えます、それは、スタックの一番上の項目をスタックからそれをポップすることなく返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following example removes all vowels and spaces from a lowercase string to create a cryptic puzzle phrase:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例は、秘密の謎の語句をつくるために、小文字の文字列から全ての母音と空白を削除します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following example replaces "Chocolate Spread", "Cheese", and "Butter" with "Bananas" and "Apples":</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例は、"Chocolate Spread"、"Cheese"、そして"Butter"を、"Bananas"および"Apples"と取り替えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following example reports a compile-time error:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例は、コンパイル時エラーを報告します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following example shows a string literal and a string delimited by extended delimiters that create equivalent string values:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例は、文字列リテラルそして同等の文字列値を作成する拡張区切り記号によって区切られる文字列を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following example shows designated initializers, convenience initializers, and automatic initializer inheritance in action.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例は、指定イニシャライザ、便宜イニシャライザ、そして自動的なイニシャライザ継承の動作を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following example shows the behavior of the example above without using optional chaining.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例は、オプショナル連鎖を使うことなく上の例の挙動を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following example shows the difference in behavior between an optional string and an implicitly unwrapped optional string when accessing their wrapped value as an explicit String:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例は、オプショナルの文字列と、暗黙的にアンラップされるオプショナルの文字列の間での、それらのラップされた値に明示的なStringとしてアクセスする場合での挙動の違いを示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following example switches on a Character value and determines whether it represents a number symbol in one of four languages.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例は、あるCharacter値に基づいて切り替えて、それが数字シンボルを４つの言語のうちの１つで表わすかどうかを明らかにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following example switches over all three existing cases of the standard library’s Mirror.AncestorRepresentation [https://developer.apple.com/documentation/swift/mirror/ancestorrepresentation] enumeration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例は、標準ライブラリのもつMirror.AncestorRepresentation [https://developer.apple.com/documentation/swift/mirror/ancestorrepresentation]列挙の３つの既存のケース節すべてに対してスイッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following example uses the break and continue statements with a labeled while loop for an adapted version of the Snakes and Ladders game that you saw earlier in this chapter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の例は、breakとcontinue文をラベルが付いたwhileループと一緒に、あなたがこの章で以前に見た「ヘビとはしご」ゲームの改作板のために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following extension makes Array instances conform to the TextRepresentable protocol whenever they store elements of a type that conforms to TextRepresentable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の拡張は、ArrayインスタンスをTextRepresentableプロトコルに準拠させます、それがTextRepresentableに準拠する型の要素を格納する時は必ずです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following form declares a computed variable or computed property:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の形式は、計算変数または計算プロパティを宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following form declares a new infix operator:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の形式は、新しい接中辞演算子を宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following form declares a new postfix operator:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の形式は、新しい接尾辞演算子を宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following form declares a new prefix operator:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の形式は、新しい接頭辞演算子を宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following form declares a stored variable or stored variable property:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の形式は、格納変数または格納変数プロパティを宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following form declares an enumeration type that contains enumeration cases of any type:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の形式は、随意の型の列挙ケース節を含む列挙型を宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following form declares an enumeration type that contains enumeration cases of the same basic type:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の形式は、同じ基本の型をもつ列挙ケース節それらを含む列挙型を宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following form declares initializers for structures, enumerations, and designated initializers of classes:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の形式は、構造体、列挙のイニシャライザ、そしてクラスの指定イニシャライザを宣言します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following function calls are equivalent:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の関数呼び出しは、等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following keywords are reserved and can’t be used as identifiers, unless they’re escaped with backticks, as described above in Identifiers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の識別子で記述されるように、以下のキーワードは予約済で、それらがバッククォートでエスケープされない限り、識別子として使われることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following requirements are placed on the function’s two type parameters:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の要件は、この関数の持つ２つの型パラメータ上に置かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following statement isn’t valid:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の文は、有効ではありません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following syntactic transformations are applied recursively to turn code that uses result-builder syntax into code that calls the static methods of the result builder type:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の構文的変換は、再帰的に適用されることで、リザルトビルダー構文を使うコードを、リザルトビルダー型の静的メソッドを呼び出すコードに転換します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following tokens are reserved as punctuation and can’t be used as custom operators: (, ), {, }, [, ], ., ,, :, ;, =, @, #, &amp; (as a prefix operator), -&gt;, `, ?, and ! (as a postfix operator).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下のトークンは、句読点として予約されます、そしてあつらえの演算子として使われることができません：(, ), {, }, [, ], ., ,, :, ;, =, @, #, &amp;（接頭辞演算子として）, -&gt;, `, ?, そして!（接尾辞演算子として）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following two function calls are equivalent:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の２つの関数呼び出しは、同等です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The forced form, as!, attempts the downcast and force-unwraps the result as a single compound action.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>強制形式as!は、一回の複合動作として、ダウンキャストとその結果の強制アンラップを試みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The four function calls marked “Error” in the example above cause compiler errors.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例において「Error」と記される４つの関数呼び出しは、コンパイラエラーを引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The fourth codeUnit value (8252) is a decimal equivalent of the hexadecimal value 203C, which represents the Unicode scalar U+203C for the DOUBLE EXCLAMATION MARK character.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>４番目のcodeUnit値（8252）は、16進数の値203Cです、それは、DOUBLE EXCLAMATION MARK文字に対するユニコード・スカラーU+203Cを表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The fourth codeUnit value (8252) is again a decimal equivalent of the hexadecimal value 203C, which represents the Unicode scalar U+203C for the DOUBLE EXCLAMATION MARK character.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>４番目のcodeUnit値（8252）は、ふたたび16進数値203Cの10進の等価物です、それは、DOUBLE EXCLAMATION MARK文字に対するユニコード・スカラーU+203Cを表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The function call is understood to be a call to one of the specially named methods on that instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数呼び出しは、そのインスタンス上での特殊名メソッドの１つへの呼び出しであると理解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The function definition still needs parentheses after the function’s name, even though it doesn’t take any parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>たとえそれが全くパラメータをとらないとしても、関数定義は依然として関数の名前の後に丸括弧を必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The function in the example below is called greet(person:), because that’s what it does—it takes a person’s name as input and returns a greeting for that person.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下記の例の関数は、それがすることから、greet(person:)と呼ばれます ― それは、入力としてある人の名前をとって、その人のために挨拶を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The function it returns has no parameters, and returns an Int value each time it’s called.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それが返す関数は、パラメータを持たず、それが呼ばれるたびにInt値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The function name is also followed by an empty pair of parentheses when the function is called.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その関数が呼ばれるとき、関数名の後にまた空の丸括弧の対が続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The function performs this swap by storing the value of a in a temporary constant called temporaryA, assigning the value of b to a, and then assigning temporaryA to b.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数はこの交換を、aの値をtemporaryAと呼ばれる一時的な定数の中に格納して、bの値をaに代入して、それからtemporaryAをbに代入することによって実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The function prints “Function was called” before returning a value, which lets you see whether the right-hand side of the = operator was evaluated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この関数は、値を返す前に「Function was called（関数は呼び出された）」を出力します、それはあなたに=演算子の右手側が評価されたかどうかを確かめさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The function returns a Boolean value of true if all items match and a value of false if they don’t.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この関数は全ての項目が合致するならばブール値のtrueを、それらがそうしないならばfalseの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The function returns a tailored greeting in each case.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数は、それぞれの状況に合った挨拶を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The function returns after it starts the operation, but the closure isn’t called until the operation is completed—the closure needs to escape, to be called later.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数は、それが演算を開始した後に戻ります、しかしクロージャはその演算が完了されるまで呼び出されません—このクロージャは脱出すること、後で呼び出されること、を必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The function then considers the value of integerToDescribe using a switch statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数は、それからswitch文を使ってintegerToDescribeの値を考慮します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The function then iterates over the remaining values in the array and checks each value to see if it’s smaller or larger than the values of currentMin and currentMax respectively.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この関数はそれから、配列の残りの値すべてに渡って繰り返します、そして各値をそれがcurrentMinおよびcurrentMaxの値より小さいかより大きいかそれぞれについて調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The function value carries no context and uses the C calling convention.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数値は、コンテキストを持ち運びません、そしてC呼出規約を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The function value is represented as a reference to the block object, which is an id-compatible Objective-C object that embeds its invocation function within the object.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この関数値はそのブロックオブジェクトへの参照として表現されます、それはid互換Objective-Cオブジェクトで、それの呼出関数がそのオブジェクト内部に埋め込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The functions in the following code both return a value of some type that conforms to the Shape protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下のコードでの関数は両方とも、Shapeプロトコルに準拠する何らかの型の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The function’s return type is a tuple type composed from two of the custom classes defined above in Custom Types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この関数の戻り型は、上のあつらえの型で定義されるあつらえのクラスのうちの２つから作られるタプル型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The game board is represented by an array of Int values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ゲーム盤は、Int値の配列によって表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The game board is the same as before.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ゲーム盤は、前と同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The generic where clause in the example above requires Item to conform to a protocol, but you can also write a generic where clauses that require Item to be a specific type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例の総称体where節は、Itemに要求してあるプロトコルに準拠させます、しかしあなたはまたItemに特定の型であることを要求する総称体where節を書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The generic where clause on Iterator requires that the iterator must traverse over elements of the same item type as the container’s items, regardless of the iterator’s type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この総称体where節がIterator上で要求するのは、そのイテレータがコンテナのもつ要素と同じ項目型の要素に対して見ていくことです、そのイテレータの持つ型に関係なく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The generic where clause requires that the iterator for the sequence must traverse over elements of type Int.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この総称体where節が要求するのは、このシーケンスのためのイテレータが型Intの要素について見ていかなければなければならないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The generic where clause for a nested declaration can still refer to the type parameters of the enclosing declaration; however, the requirements from that where clause apply only to the declaration where it’s written.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>入れ子にされた宣言に対する総称体where節は、囲んでいる宣言の型パラメータを依然として参照できます；しかしながら、そのwhere節からの要件は、それが書かれているところの宣言に対してのみ適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The generic parameter Indices in angle brackets has to be a type that conforms to the Sequence protocol from the standard library.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>山括弧の中の総称体パラメータIndicesは、それは標準ライブラリからのSequenceプロトコルに準拠する型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The generic version of the function uses a placeholder type name (called T, in this case) instead of an actual type name (such as Int, String, or Double).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この関数の総称体版は、プレースホルダ型名（この場合、Tと呼ばれるもの）を実際の型名（例えばInt、String、またはDouble）の代わりに使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The getter and setter for height and width wrap access to the wrappedValue property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>heightとwidthに対するゲッターとセッターは、wrappedValueプロパティへのアクセスをラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The getter and setter requirements can be satisfied by a conforming type in a variety of ways.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ゲッターとセッター要件は、準拠している型によっていろいろなやり方で満たされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The getter is used to read the value, and the setter is used to write the value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ゲッターが値を読むために使われます、そしてセッターが値を書くために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The given expression is evaluated when the function is called.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>与えられた式は、関数が呼び出される時に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The global and local variables you have encountered in previous chapters have all been stored variables.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが前の章において遭遇したグローバルおよびローカル変数は、すべて格納変数でした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The grammar described here is intended to help you understand the language in more detail, rather than to allow you to directly implement a parser or compiler.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここで記述される文法は、あなたが更に詳細に言語を理解するのを手伝うつもりのもので、あなたに直ちにパーサーまたはコンパイラを実装させるようにするものではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The grammar production above is equivalent to the following two productions, where the alternatives are spelled out explicitly:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の文法導出は以下の２つの導出に等しいです、そこでは代替物がそれぞれ分けて書かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The half-open range operator also has a one-sided form that’s written with only its final value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>半開範囲演算子もまた、それの最後の値のみで記述される、片側形式を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The hexadecimal fraction consists of a decimal point followed by a sequence of hexadecimal digits.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>16進の小数部は、小数点に続く一連の16進の桁から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The hypothetical function above has two type parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の仮定の関数は、２つの型パラメータを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The identifier specifies the name to be exposed to Objective-C for the entity that the objc attribute applies to.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この識別子は、Objective-Cへと暴露される名前をobjc属性を適用される存在に対して指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The identity key path refers to a whole instance, so you can use it to access and change all of the data stored in a variable in a single step.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同一性キーパスはインスタンス全体を参照します、それであなたはそれを使って、ただ一段階で変数の中に格納されたデータの全てにアクセスおよび変更できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The illustration below depicts three sets—a, b and c—with overlapping regions representing elements shared among sets.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の図は３つの集合—a、b、そしてc—を集合間で共有される要素を表している重なり合う領域とともに描写します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The illustration below depicts two sets—a and b—with the results of various set operations represented by the shaded regions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以下の図は、２つの集合—aとb—を網掛けの領域で表される様々な集合演算の結果とともに描写します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The illustration below shows the push and pop behavior for a stack:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下のイラストは、あるスタックのプッシュおよびポップ挙動を示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The illustration below shows the results of 11111111 &lt;&lt; 1 (which is 11111111 shifted to the left by 1 place), and 11111111 &gt;&gt; 1 (which is 11111111 shifted to the right by 1 place).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下のイラストは、11111111 &lt;&lt; 1（それは、1桁だけ左へシフトされる11111111です）、そして11111111 &gt;&gt; 1（それは、1桁だけ右へシフトされる11111111です）の結果を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The immediate issue is that the Shape doesn’t include an == operator as part of its protocol requirements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>当面の問題は、Shapeがそれのプロトコル要件として==演算子を含まないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The implementation of gameDidStart(_:) shown above uses the game parameter to print some introductory information about the game that’s about to be played.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上で示されるgameDidStart(_:)の実装は、gameパラメータを使って、プレイされようとしているゲームに関する若干の紹介の情報を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The implementation of max(_:_:) uses only functionality that all Comparable types share.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>max(_:_:)の実装は、全てのComparable型が共有する機能性だけを使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The implementation of the vend(itemNamed:) method uses guard statements to exit the method early and throw appropriate errors if any of the requirements for purchasing a snack aren’t met.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>vend(itemNamed:)メソッドの実装はguard文を使って、購入スナックに必要な何かが満たされないならば早めにそのメソッドを終了して対応するエラーをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The imported module must be compiled with testing enabled.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>インポートされたモジュールは、テストすることを可能にされてコンパイルされなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The individual cases of an enumeration automatically receive the same access level as the enumeration they belong to.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある列挙の個々のケース節は、自動的にそれらが属している列挙と同じアクセス水準を与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The information about Accessing Properties Through Optional Chaining has been updated accordingly, and the examples of checking for method call success in Calling Methods Through Optional Chaining have been expanded to show how to check for property setting success.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル連鎖を通してプロパティにアクセスするについての情報はそれを受けて更新されました、そしてオプショナル連鎖を通してメソッドを呼び出すの中のメソッド呼び出しがうまくいったかを確認する例は拡張されて、プロパティの設定がうまくいったかを確認する方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The inherited version of init() functions in exactly the same way as the Food version, except that it delegates to the RecipeIngredient version of init(name: String) rather than the Food version.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>init()の継承された改変板は、Food版と同じ正確に方法で機能しますが、それがFood板ではなくRecipeIngredient版のinit(name: String)に委任することを除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The init! Failable Initializer</seg>
      </tuv>
      <tuv lang="ja">
        <seg>init!失敗できるイニシャライザ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The initialization of airports could have been written in a shorter form instead:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>airportsの初期化は、代わりにより短い形式で書かれることもできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The initialization of shoppingList could have been written in a shorter form instead:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>shoppingListの初期化は、前の代わりにより短い形式に書かれることもできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The initialization of favoriteGenres could have been written in a shorter form instead:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>favoriteGenresの初期化は、代わりに次のような短い形式で書かれることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The initializer expression can’t be present in a protocol declaration, but in all other contexts, the initializer expression is optional.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>イニシャライザ式はプロトコル宣言に含まれることはできません、しかし全ての他の文脈ではそうではありません、イニシャライザ式は任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The initializer expression is optional in the context of a class or structure declaration, but required elsewhere.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>イニシャライザ式は、クラスまたは構造体宣言の文脈では任意です、しかしその他では必須です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The initializer call Celsius(37.0) is clear in its intent without the need for an argument label.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>イニシャライザ呼び出しCelsius(37.0)は、引数ラベルを必要としなくともその意図は明快です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The initializer can then fail if the provided parameters don’t match an appropriate enumeration case.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このイニシャライザは、提供されたパラメータが適切な列挙ケース節に適合しないならばその時に失敗できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The initializer for City is called from within the initializer for Country.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Cityのためのイニシャライザは、Countryのためにイニシャライザの内部から呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The initializer then calls the structure’s automatic memberwise initializer init(origin:size:), which stores the new origin and size values in the appropriate properties:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>イニシャライザはそれから、構造体の自動的なメンバー関連イニシャライザinit(origin:size:)を呼びます、それは、新しい原点とサイズ値を適切なプロパティに保管します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The initializer uses the wrapped value that’s specified here, and it uses the default maximum value of 12.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>イニシャライザは、ここで指定されるラップ値を使います、そしてそれは省略時の最大値限の12を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The instance of SmallNumber that wraps height is created by calling SmallNumber(wrappedValue: 1), which uses the default maximum value of 12.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>heightをラップするSmallNumberのインスタンスは、SmallNumber(wrappedValue: 1)を呼び出すことによって作成されます、それは省略時の最大値の12を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The instance of SmallNumber that wraps height is created by calling SmallNumber(wrappedValue: 2, maximum: 5), and the instance that wraps width is created by calling SmallNumber(wrappedValue: 3, maximum: 4).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>heightをラップするSmallNumberインスタンスは、SmallNumber(wrappedValue: 2, maximum: 5)を呼び出すことによって作成されます、widthをラップするインスタンスは、SmallNumber(wrappedValue: 3, maximum: 4)を呼び出すことによって作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The instance that wraps width is created by calling SmallNumber(wrappedValue: 2, maximum: 9).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>widthをラップするインスタンスは、SmallNumber(wrappedValue: 2, maximum: 9)を呼び出すことによって作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The instances can then refer to each other without creating a strong reference cycle.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>インスタンスは、そのあと強い参照循環をつくることなくお互いに言及することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The instances of SmallNumber that wrap height and width are created by calling SmallNumber().</seg>
      </tuv>
      <tuv lang="ja">
        <seg>heightとwidthをラップするSmallNumberのインスタンスは、SmallNumber()を呼び出すことによって作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The instances of SmallNumber that wrap height and width are created by calling SmallNumber(wrappedValue: 1).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>heightとwidthをラップするSmallNumberのインスタンスは、SmallNumber(wrappedValue: 1)を呼び出すことによって作成されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The instance’s asHTML property holds a strong reference to its closure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このインスタンスのasHTMLプロパティは、それのクロージャに対する強い参照を保持します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The integers start at zero and count up by one for each item; if you enumerate over a whole array, these integers match the items’ indices.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その整数はゼロから始めて各項目に対して１ずつ数えていきます；あなたが配列全体をすべて列挙するならば、それらの整数はそれら項目のもつインデックスと一致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The interpolated expression can contain a string literal, but can’t contain an unescaped backslash, a carriage return, or a line feed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>差し込まれた式は、文字列リテラルを含むことができます、しかしエスケープされないバックスラッシュ、キャリッジリターン、またはラインフィードを含むことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The intro and intermediate courses both have a suggested next course stored in their nextCourse property, which maintains an unowned optional reference to the course a student should take after completing this one.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>入門と中級の課程の両方とも、それらのnextCourseプロパティの中に格納される提案される次の課程を持ちます、それは生徒がそれを修了した後に取るべき課程への非所有オプショナル参照を保守します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The invocation function uses the C calling convention.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この呼出関数はC呼出規約を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The items in someContainer can be checked with the not equal operator (!=) to see if they’re different from each other.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>someContainerの中の項目は、それらがお互いと異なるかどうか見るために不等演算子（!=）を使って確認されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The items stored in library are still Movie and Song instances behind the scenes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>libraryに格納される項目は、依然として舞台裏ではMovieとSongインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The key type of a dictionary must conform to the Swift standard library Hashable protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある辞書のキーの型は、スウィフト標準ライブラリHashableプロトコルに準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The key-value pairs are written as a list, separated by commas, surrounded by a pair of square brackets:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>「キーと値」の対はリストとして書かれます、それはコンマで区切られ、一対の角括弧に囲まれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The largest valid index in an array is count - 1 because arrays are indexed from zero—however, when count is 0 (meaning the array is empty), there are no valid indexes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある配列の中の最も大きい有効なインデックスはcount - 1です、なぜなら配列はゼロからインデックスをつけられるからです — しかしながら、countが0である時（配列がからであるのを意味しています）、有効なインデックスは全然ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The last defer statement in source code order executes first.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ソースコード順序での最後のdefer文は最初に実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The last argument, *, is required and specifies that on any other platform, the body of the if executes on the minimum deployment target specified by your target.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最後の引数*は、必要で、あらゆる他のプラットホーム上を指定します、ifの本文は、あなたの対象で指定される、最小の開発対象で実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The last expression in the array can be followed by an optional comma.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列の最後の式の後に、１つの任意のコンマが続くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The last expression in the dictionary can be followed by an optional comma.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>辞書の最後の式の後に、１つの任意のコンマが続くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The last four codeUnit values (240, 159, 144, 182) are a four-byte UTF-8 representation of the DOG FACE character.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最後の４つのcodeUnit値（240、159、144、182）は、DOG FACE文字の４バイトUTF-８叙述です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The last part of the example above shows that Self refers to the runtime type Subclass of the value of z, not the compile-time type Superclass of the variable itself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例の最後の部分は、Selfがzの値のランタイム型Subclassを参照することを示します、変数それ自体のコンパイル時型Superclassではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The length of an NSString is based on the number of 16-bit code units within the string’s UTF-16 representation and not the number of Unicode extended grapheme clusters within the string.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるNSStringの長さは、その文字列のUTF-16表現内の16ビットコード単位の数に基づきます、その文字列内のユニコード拡張書記素クラスタの数ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The less specific return type information from protoFlip(_:) means that many operations that depend on type information aren’t available on the returned value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>protoFlip(_:)からの具体性のより少ない戻り型情報は、型情報に依存する多くの演算が、その返された値の上で利用可能でないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The letter é can be represented as the single Unicode scalar é (LATIN SMALL LETTER E WITH ACUTE, or U+00E9).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字éは、単一のユニコード・スカラーé（LATIN SMALL LETTER E WITH ACUTE、またはU+00E9）として表わされることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The line break after the """ that begins the multiline string literal isn’t part of the string.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複数行文字列リテラルを開始する"""の後のラインブレークは、その文字列の一部ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The line break before the """ that ends the literal is also not part of the string.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>リテラルの終わりの"""の前のキャリッジリターンまたはラインフィードもまた、その文字列の一部ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The line number on which it appears.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それが現れる行番号。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The lines that define sortedNames and name are regular, synchronous code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>sortedNamesとnameを定義する行は、普通の、同期コードです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The listing below does the same assignment, but it uses a function to create the address.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下でのコード出力は、同じ代入を行います、しかしそれはある関数を使ってアドレスを作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The literal value 3 can be added directly to the literal value 0.14159, because number literals don’t have an explicit type in and of themselves.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>リテラル値3は、直接にリテラル値0.14159に加えられることができます、なぜなら数リテラルがそれら自身において明確な型を持たないためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The literal value of 3 has no explicit type in and of itself, and so an appropriate output type of Double is inferred from the presence of a floating-point literal as part of the addition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>リテラル値3は明確な型をそれ自体は持ちません、それで適切な出力のDouble型は、加算部分の浮動小数点リテラルの存在から推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The location in memory refers to what is being accessed—for example, a variable, constant, or property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メモリ中の位置はアクセスされているのは何かを参照します — 例えば、変数、定数、またはプロパティ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The logical NOT operator is a prefix operator, and appears immediately before the value it operates on, without any white space.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>論理否定演算子は接頭辞演算子です、そして全く空白なしで、それが作用する値の直前に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The loop then ends, and control returns to the while condition to decide whether another turn is required.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ループはそれから終わります、そして制御はもう１つの回が必要かどうか決めるためにwhile条件に戻ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The loop’s condition (while square &lt; finalSquare) is the same as before, but this time it’s not evaluated until the end of the first run through the loop.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ループの条件（while square &lt; finalSquare）は前と同じものです、しかし今回それは最初のループ通り抜けの終わりまで評価されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The main difference is that during phase 1, Objective-C assigns zero or null values (such as 0 or nil) to every property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>主な違いは、段階１の間に、Objective-Cがゼロまたは無効な値（例えば0またはnil）をあらゆるプロパティに代入するということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The main difference is that optional chaining fails gracefully when the optional is nil, whereas forced unwrapping triggers a runtime error when the optional is nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>大きな違いは、オプショナル連鎖はそのオプショナルがnilであるとき潔く失敗します、だけれども強制アンラップはそのオプショナルがnilであるとき実行時エラーの引き金となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The main exception to this rule occurs when a parameter name for an instance method has the same name as a property of that instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この規則に対する主な例外は、インスタンスメソッドのパラメータ名がそのインスタンスのプロパティと同じ名前を持つ時に起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The matches succeeds if the ~= operator returns true.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>~=演算子がtrueを返すならば、マッチは成功します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The members of a module access the top-level declarations of that module.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>モジュールのメンバーは、そのモジュールのトップレベルの宣言にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The members of a named type are named as part of the type’s declaration or extension.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>名前付きの型に属するメンバーは、型の宣言または拡張の一部として命名されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The members of a tuple are implicitly named using integers in the order they appear, starting from zero.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タプルのメンバーは、整数を使って、それらが現れる順序で、ゼロから始めて、暗黙のうちに名前をつけられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The memberwise initializer is a shorthand way to initialize the member properties of new structure instances.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メンバー関連イニシャライザは、新しい構造体インスタンスのメンバープロパティを初期化するための略記方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The memory for these stored properties is now initialized.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの格納プロパティに対するメモリは、今や初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The memory isn’t yet initialized.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのメモリは、まだ初期化されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The metatype of a class, structure, or enumeration type is the name of that type followed by .Type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるクラス、構造体、または列挙型のメタタイプは、その型の名前に.Typeが続くものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The metatype of a protocol type—not the concrete type that conforms to the protocol at runtime—is the name of that protocol followed by .Protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるプロトコル型 ― 実行時にそのプロトコルに準拠する具象型ではない ― のメタタイプは、そのプロトコルの名前に.Protocolが続くものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The method can also assign a completely new instance to its implicit self property, and this new instance will replace the existing one when the method ends.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このメソッドはまた、完全に新しいインスタンスをその暗黙のselfプロパティに代入することができます、そして、そのメソッドが終了するとき、この新しいインスタンスは既存のものを置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The method can then mutate (that is, change) its properties from within the method, and any changes that it makes are written back to the original structure when the method ends.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このメソッドはそれからそれのプロパティをメソッド内部から変化させること（すなわち変更）ができます、そして、そのメソッドが終了するとき、それが行ったどんな変更も本来の構造体へ書き込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The method returns a new Vector2D instance, whose x and y properties are initialized with the sum of the x and y properties from the two Vector2D instances that are added together.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メソッドは、新しいVector2Dインスタンスを返します、それはxとyプロパティが一緒に加えられる２つのVector2Dインスタンスからのxとyプロパティの合計で初期化されるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The middle line has more indentation than the closing quotation marks, so it starts with that extra four-space indentation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>真ん中の行は終了引用符よりもっと字下げされます、なのでそれは追加の４つの空白の字下げで始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The minimum value that a UInt8 can hold is zero, or 00000000 in binary.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>UInt8が持つことができる最小限の値は、０、または２進数では00000000です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The minimum value that an Int8 can hold is -128, or 10000000 in binary.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Int8が持つことができる最小限の数は、-128、または２進数での10000000です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The module’s public interface consists of operations like joining and flipping a shape, and those operations return another Shape value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>モジュールのもつパブリックインターフェイスは、形の結合および裏返しのような演算からなります、そしてそれらの演算は別のShape値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The mutating method needs write access to self for the duration of the method, and the in-out parameter needs write access to teammate for the same duration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>変更メソッドは、selfに対する書き込みアクセスをメソッドの期間中に必要とします、そしてin-outパラメータはteammateに対する書き込みアクセスを同じ期間に必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The name of a call-as-function method is callAsFunction(), or another name that begins with callAsFunction( and adds labeled or unlabeled arguments—for example, callAsFunction(_:_:) and callAsFunction(something:) are also valid call-as-function method names.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>call-as-functionメソッドの名前はcallAsFunction()、またはcallAsFunction(で始まりそしてラベル付きまたはラベル無し引数を加える別の名前です — 例えばcallAsFunction(_:_:)およびcallAsFunction(something:)は同様に有効なcall-as-functionメソッド名です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The name of a class</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるクラスの名前</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The name of a protocol</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるプロトコルの名前</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The name of each case must be unique.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>各ケース節の名前は、固有でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The name of the declaration in which it appears.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それが現れる宣言の名前。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The name of the file and module in which it appears.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それが現れるファイルとモジュールの名前。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The name of the projected value is the same as the wrapped value, except it begins with a dollar sign ($).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>投影値の名前は、ラップ値と同じです、それがドル記号（$）で始まることを除いては。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The nearest thing in Objective-C is the ability to return nil from a method that would otherwise return an object, with nil meaning “the absence of a valid object.” However, this only works for objects—it doesn’t work for structures, basic C types, or enumeration values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Objective-Cにおいて最も近いものは、オブジェクトを返すメソッドからそうできない場合にnilを返す能力です、そのときnilは「有効なオブジェクトの欠如」を意味しています。しかし、それは単にオブジェクトのためだけに働きます ― それは構造体、基本的なC型、または列挙値のために働きません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The nested incrementer() function captures two values, runningTotal and amount, from its surrounding context.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>入れ子にされたincrementer()関数は、それを取り囲む前後関係から２つの値、runningTotalとamountを捕獲します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The nested enumeration can now be used with any Int value:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>入れ子にされた列挙は今やあらゆるInt値で使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The new Bicycle class automatically gains all of the characteristics of Vehicle, such as its currentSpeed and description properties and its makeNoise() method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この新しいBicycleクラスは、自動的にVehicleのすべての特徴を獲得します、例えばそれのcurrentSpeedおよびdescriptionプロパティやそれのmakeNoise()メソッドなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The new for loop iterates over the sequence and appends each partial result to that array.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>新しいforループは、そのシーケンスのすべてにわたって反復します、そして部分的結果それぞれをその配列に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The new array’s type is inferred from the type of the two arrays you add together:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>新しい配列の型は、あなたが一緒に加える２つの配列の型から推論されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The new type can then be used wherever its access level permits.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その新しい型はそれから、そのアクセス水準が許すところどこででも使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The new value is passed to the willSet observer as a constant, and therefore it can’t be changed in the implementation of the willSet clause.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>新しい値は、定数としてwillSetオブザーバーに渡されます、したがって、それはwillSet節の実装の中で変更されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The next await marks the call to the downloadPhoto(named:) function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>次のawaitは、downloadPhoto(named:)関数への呼び出しを印します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The next code snippet defines three variables of type Person?, which are used to set up multiple references to a new Person instance in subsequent code snippets.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>次のコード断片は、型Person?の３つの変数を定義します、それは、以降のコード断片の中のある１つの新しいPersonインスタンスへの複数の参照を準備するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The next example creates a subclass of Bicycle for a two-seater bicycle known as a “tandem”:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>次の例は、「タンデム」として知られる２座席自転車のために、Bicycleのサブクラスを作成します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The next example defines a subclass of Document called AutomaticallyNamedDocument.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>次の例は、AutomaticallyNamedDocumentとよばれるDocumentのサブクラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The next example defines a subclass of Vehicle called Bicycle:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>次の例は、Bicycleと呼ばれるVehicleのサブクラスを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The next example defines two simple functions called stepForward(_:) and stepBackward(_:).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>次の例は、stepForward(_:)とstepBackward(_:)と呼ばれる２つの単純な関数を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The next several code snippets demonstrate how optional chaining differs from forced unwrapping and enables you to check for success.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>次のいくつかのコード切れっぱしは、どのようにオプショナル連鎖が強制アンラップと異なるか、そして成功をどのようにあなたが確認できるかを例示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The next snippet defines two subclasses of MediaItem.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>次の断片は、MediaItemの２つのサブクラスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The next subscript index to the right refers to the element at that index in the array that’s nested one level in.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>次の右の添え字インデックスは、１段階内側の入れ子にされた配列の中のそのインデックスでの要素に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The next three decimal codeUnit values (226, 128, 188) are a three-byte UTF-8 representation of the DOUBLE EXCLAMATION MARK character.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>次の３つの10進のcodeUnit値（226、128、188）は、DOUBLE EXCLAMATION MARK文字の３バイトUTF-8叙述です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The nil-coalescing operator is shorthand for the code below:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>nil合体演算子は、以下のコードに対する簡略形です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The nil-coalescing operator provides a more elegant way to encapsulate this conditional checking and unwrapping in a concise and readable form.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>nil合体演算子は、この条件検査およびアンラップを簡潔で判読しやすい形式にカプセル化するより洗練された方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The notation used to describe the formal grammar of the Swift programming language follows a few conventions:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトプログラミング言語の形式文法を記述するために使用される表記法は、２、３の規則に従います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The observers aren’t called when the variable or property is first initialized.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オブザーバーは、変数またはプロパティが最初に初期化されるときには呼ばれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The only difference is the type of the values that they accept (Int, String, and Double).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>唯一の違いは、それらが受け入れる値の型（Int、String、そしてDouble）です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The only exception is for required initializers (as defined in Required Initializers).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>唯一の例外は、必須イニシャライザに対してです（必須イニシャライザで定義されるように）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The only remaining strong reference to the Apartment instance is from the unit4A variable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Apartmentインスタンスへの唯一の残っている強い参照は、unit4A変数からです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The operator method is defined as a type method on Vector2D, with a method name that matches the operator to be overloaded (+).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この演算子メソッドは、Vector2D上で型メソッドとして定義され、オーバーロードされる演算子と一致するメソッド名を持ちます（+）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The operator returns a new number whose bits are set to 1 if the bits are equal to 1 in either input number:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この演算子は、どちらかの入力数においてビットが1と等しいならばビットが1に設定される、ある新しい数を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The operator returns a new number whose bits are set to 1 where the input bits are different and are set to 0 where the input bits are the same:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この演算子は、入力ビットそれらが異なっている所で1に設定され、入力ビットそれらが同じである所で0に設定される、ある新しい数を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The optimized behavior is known as call by reference; it satisfies all of the requirements of the copy-in copy-out model while removing the overhead of copying.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この最適化挙動は、参照呼び出しとして知られます；それはコピーイン・コピーアウトモデルの要件の全てを満足させる一方でコピーすることのオーバーヘッド（間接的経費）を取り除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The optional Int is accessed through optional binding to unwrap the integer and assign the non-optional value to the roomCount constant.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルのIntは、オプショナル束縛を通してアクセスされることで、整数をアンラップして取り出して、その非オプショナル値をroomCount定数へ割り当てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The optional version number consists of one to three positive integers, separated by periods.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>随意のバージョン番号は、ビリオドで区切られた、１つから３つの正の整数から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The optional chaining question mark always follows immediately after the part of the expression that’s optional.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル連鎖の疑問符は、常にオプショナルである式部分の直後に続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The optional chaining question mark in this subscript call is placed immediately after john.residence, before the subscript brackets, because john.residence is the optional value on which optional chaining is being attempted.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この添え字呼び出しでのオプショナル連鎖の疑問符は、john.residenceの直後、添え字の角括弧の前に置かれます、なぜなら、john.residenceがオプショナル連鎖が試みられているオプショナルの値であるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The optional lets you track whether there’s currently a player in the game.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルは、プレーヤーが現在ゲーム中かどうかあなたに追跡させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The optional pattern provides a convenient way to iterate over an array of optional values in a for-in statement, executing the body of the loop only for non-nil elements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルパターンは、for-in文においてオプショナルの値がはいった配列の全体にわたって、ループの本文を非nilの要素のみに実行して、繰り返すための便利な方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The optional that wraps the class doesn’t use reference counting, so you don’t need to maintain a strong reference to the optional.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスをラップするオプショナルは、参照カウントを使用しません、それであなたはオプショナルへの強い参照を保守する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The order in which modifiers are specified when defining Custom Operators has changed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あつらえの演算子を定義する時に修飾子が指定される順番は変更されました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The order of arguments in a function call must match the order of parameters in the function’s declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数呼び出しにおける引数の順序は、関数の宣言におけるパラメータの順番と一致しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The original array isn’t modified by the sorted(by:) method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>元の配列は、sorted(by:)メソッドによって修正されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The other branches can be empty.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>他の分岐は、空であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The other difference between a generic function and a nongeneric function is that the generic function’s name (swapTwoValues(_:_:)) is followed by the placeholder type name (T) inside angle brackets (&lt;T&gt;).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体関数と非総称体関数の間の他の違いは、総称体関数の名前（swapTwoValues(_:_:)）は、後ろにプレースホルダ型名（T）が山形括弧内部（&lt;T&gt;）で続くということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The other variation of the while loop, known as the repeat-while loop, performs a single pass through the loop block first, before considering the loop’s condition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>whileループのもう一方の変種、repeat-whileループとして知られるものは、ループの条件を考慮する前に、最初に一度だけループ・ブロックの通り抜けを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The output constant (twoThousandAndOne) is inferred to be of type UInt16, because it’s the sum of two UInt16 values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>出力された定数（twoThousandAndOne）は、型UInt16であると推測されます、それが２つのUInt16値の合計であるので。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The output of the compound expression doesn’t change, but the overall intention is clearer to the reader.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複合式の出力は変わりません、しかし全体的な意図は読者にとってより明らかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The override of the description property starts by calling super.description, which returns the Vehicle class’s description property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>descriptionプロパティのオーバーライドは、super.descriptionを呼び出すことで始まります、それはVehicleクラスのdescriptionプロパティを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The parameter is skipped.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>パラメータは飛ばされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The parameter name is used in the implementation of the function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>パラメータ名は、関数の実装内において使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The parameter’s Key [https://developer.apple.com/documentation/swift/expressiblebydictionaryliteral/2294108-key] must be ExpressibleByStringLiteral [https://developer.apple.com/documentation/swift/expressiblebystringliteral].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>パラメータのKey [https://developer.apple.com/documentation/swift/expressiblebydictionaryliteral/2294108-key]は、ExpressibleByStringLiteral [https://developer.apple.com/documentation/swift/expressiblebystringliteral]でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The parentheses around a tuple pattern that contains a single element have no effect.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ただ１つだけの要素を含むタプルパターンのまわりの丸括弧には、効果がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The parentheses make it clear that the first two values are considered as part of a separate possible state in the overall logic.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>丸括弧は、最初の２つの値が全体的な論理の中で１つの隔てられたあり得る状態の部分として考慮されることを明白にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The path to the file in which it appears.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それが現れるファイルへのパス。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The pattern matches values of that single element’s type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>パターンは、そのただ１つの要素の型の値にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The patterns can be written over multiple lines if the list is long.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらのパターンは、そのリストが長いならば、複数行にわたって書かれることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The phrase if !allowedEntry can be read as “if not allowed entry.” The subsequent line is only executed if “not allowed entry” is true; that is, if allowedEntry is false.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>語句if !allowedEntryは、「許されたエントリでないならば」と読まれることができます。続く行は「許されたエントリでない」が真である場合；すなわち、allowedEntryがfalseである場合に実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The phrase “of type String” means “can store any String value.” Think of it as meaning “the type of thing” (or “the kind of thing”) that can be stored.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>フレーズ「型Stringの」は、「どんなString値でも格納することができる」ことを意味します。それを、格納されることができる「物の型」（または「物の種類」）の意味と思ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The placeholder type name doesn’t say anything about what T must be, but it does say that both a and b must be of the same type T, whatever T represents.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プレースホルダ型名はTが何でなければならないかについて何も言いません、しかし、aとbの両方ともが同じ型Tでなければならないと述べます、Tが表わすものが何であれ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The player has now left the game.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プレーヤーは、現在ゲームから離れました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The player moves forward by diceRoll squares, and the game logic checks for any snakes and ladders.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プレーヤーはdiceRoll分の正方形を前進します、そして、ゲーム論理はあらゆるヘビとはしごについて調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The player’s purse now contains 2,100 coins, and the bank has only 7,900 coins left.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プレーヤーの財布は現在2,100個のコインを含みます、そして、胴元は7,900個のコインだけが残っています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The player’s starting square is “square zero”, which is just off the bottom-left corner of the board.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プレーヤーの出発する正方形は「正方形ゼロ」です、それは、盤の左下の角からちょっと離れています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The point (0, 0) would match case (0, 0) first, and so all other matching cases would be ignored.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>点(0, 0)は最初のcase (0, 0)に合います、それで他の適合するケース節すべては無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The possible suspension points in your code marked with await indicate that the current piece of code might pause execution while waiting for the asynchronous function or method to return.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたのコードの中のawaitで印されるそれら可能な中断地点が指し示すのは、コードの現在の断片が遂行を非同期の関数やメソッドが返るのを待っている間に一時停止するかもしれない、ということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The postfix ? operator makes an optional-chaining expression from an expression without changing the expression’s value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>接尾辞?演算子は、オプショナル連鎖式をある式から、その式の値を変更することなく作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The precedence of an operator specifies how tightly the operator binds to its operands, in the absence of grouping parentheses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある演算子の優先順位は、どのくらいきつくその演算子をそれの演算数に束縛するかを、グループ化の丸括弧がないところで指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The present section describes which characters can be used to define custom operators.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>いま目の前の節は、どの文字があつらえの演算子を定義するために使われることができるかを記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The previous example shows how to retrieve the value of a property of optional type through optional chaining.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>前の例は、オプショナル連鎖を通してオプショナルの型のプロパティの値を取り出す方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The previous example uses KeyValuePairs [https://developer.apple.com/documentation/swift/keyvaluepairs] as the parameter type so that callers can include duplicate parameter labels—a and b appear multiple times in the call to repeat.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>前の例は、KeyValuePairs [https://developer.apple.com/documentation/swift/keyvaluepairs]をパラメータ型として使います、それで呼び出し側は重複するパラメータラベルを含むことができます — aとbは複数回repeatの呼び出しにおいて現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The primary use of implicitly unwrapped optionals in Swift is during class initialization, as described in Unowned References and Implicitly Unwrapped Optional Properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトでの暗黙的にアンラップされるオプショナルの主要な利用法は、所有参照と暗黙的にアンラップされるオプショナルのプロパティで記述されるように、クラス初期化の間にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The principle of finding the index of a value in an array isn’t useful only for strings, however.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、配列の中の値のインデックスを見つける原理は、文字列のためにだけ役立つわけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The problem lies with the equality check, “if value == valueToFind”.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>問題は、同等性検査if value == valueToFindに横たわります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The process is repeated until number is equal to 0, at which point the output string is returned by the closure, and is added to the output array by the map(_:) method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この処理はnumberが0に等しくなるまで繰り返されます、その時点でoutput文字列がクロージャによって返されて、そしてmap(_:)メソッドによって出力配列に加えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The process of defining your own implementations of the == and != operators is described in Equivalence Operators.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>==および!=演算子のあなた独自の実装を定義する過程は、等価演算子で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The process of initializing a structure’s declared properties is described in Initialization.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある構造体のもつ宣言されたプロパティを初期化する過程は、初期化で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The process of initializing an actor’s declared properties is described in Initialization.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるアクターのもつ宣言されたプロパティを初期化する過程は、初期化で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The program begins executing a loop by calling the next() method on the iterator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プログラムは、そのイテレータ上でnext()メソッドを呼ぶことによってループの実行を始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The program executes the statements, and execution continues to step 2.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プログラムが文を実行します、そして実行はステップ２に続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The program executes the statements, and execution returns to step 1.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プログラムは文を実行します、そして実行はステップ１に戻ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The projected value has the same access control level as the original wrapped property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>投影値は、元のラップされたプロパティと同じアクセス制御水準を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The properties of a frozen structure can’t have property observers, and expressions that provide the initial value for stored instance properties must follow the same restrictions as inlinable functions, as discussed in inlinable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>凍結構造体のプロパティは、ブロパティオブザーバを持つことが出来ません、そして格納インスタンスプロパティに初期値を提供する式は、インライン可能関数と同じ制約に従わなければなりません、inlinableで記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The property wrapper still provides all of the initial values, like the earlier example that used TwelveOrLess in SmallRectangle.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティラッパーは、依然として初期値のすべてを提供します、SmallRectangleでのTwelveOrLessを使った前の例のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The protocol also specifies whether each property must be gettable or gettable and settable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルはまた、各プロパティが取得可能または取得可能かつまた設定可能でなければならないかどうか指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The protocol can then be adopted by a class, structure, or enumeration to provide an actual implementation of those requirements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのプロトコルは、それから、クラス、構造体、または列挙によって採用されることで、それらの要件の実際の実装を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The protocol doesn’t define what Item is—that information is left for any conforming type to provide.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このプロトコルは、Itemが何であるかを定義しません ― その情報は、何であれそれに準拠する型が提供するようにそのままにされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The protocol doesn’t specify anything else about the nature of the conforming type—it only specifies that the type must be able to provide a full name for itself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このプロトコルは、その準拠型の性質について何ら指定しません ― それはただその型がそれ自身のフルネームを提供できなければならないことだけを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The protocol doesn’t specify whether the property should be a stored property or a computed property—it only specifies the required property name and type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルは、そのプロパティが格納プロパティまたは計算プロパティでなければならないかどうかは指定しません ― それは、必要なプロパティ名と型を指定するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The protocol name is provided after the type name, separated by a colon, and an implementation of all requirements of the protocol is provided within the extension’s curly braces.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル名は、型名の後にコロンで区切られて提供されます、そして、プロトコルの全ての要件の実装は、拡張の波括弧内で提供されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The protocol only specifies the three bits of functionality that any type must provide in order to be considered a Container.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルは、どんな型でもContainerとみなされるためには提供しなければならない小さな３つの機能性を指定するだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The protocol states that any FullyNamed type must have a gettable instance property called fullName, which is of type String.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このプロトコルは、あらゆるFullyNamed型はfullNameと呼ばれる、String型である、取得可能なインスタンスプロパティを持たなければならないことを述べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The question mark indicates that the value it contains is optional, meaning that it might contain some Int value, or it might contain no value at all.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>疑問符はそれが含む値がオプショナルであることを示します、そしてそれが何かのInt値を含むかもしれない、あるいはそれがまったく値を含まないかもしれないことを意味しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The range of numbers that can be stored in an integer constant or variable is different for each numeric type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>整数の定数または変数に格納されることができる数の範囲は、それぞれの数の型で異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The raw value for a particular enumeration case is always the same.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>特定の列挙ケース節のための生の値は、常に同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The raw value initializer is a failable initializer, because not every raw value will return an enumeration case.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>生の値のイニシャライザは、失敗できるイニシャライザです、なぜなら、すべての生の値が列挙ケース節を返すわけではないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The read access ends before the write access starts, so there isn’t a conflict.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>読み出しアクセスは書き込みアクセスが始まる前に終わります、それでそれらは衝突しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The read and write accesses refer to the same memory and they overlap, producing a conflict.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>読み出しと書き込みアクセスは同じメモリを参照してそれらはオーバーラッブして、衝突を生み出しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The red component is obtained by performing a bitwise AND between the numbers 0xCC6699 and 0xFF0000.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>赤の構成要素は、数0xCC6699と0xFF0000との間のビット単位の論理積を実行することによって得られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The reference is called a “strong” reference because it keeps a firm hold on that instance, and doesn’t allow it to be deallocated for as long as that strong reference remains.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この参照が「強い」参照と呼ばれるのはそれがそのインスタンスに対する堅い支配力を保つからです、そしてその強い参照が残る限りは、そのインスタンスがメモリ割り当て解除されるのを許しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The relationship between Customer and CreditCard is slightly different from the relationship between Apartment and Person seen in the weak reference example above.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>CustomerとCreditCardの関係は、上の弱い参照の例で見られるApartmentとPersonの関係と少しばかり異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The remainder is treated the same way and may be split again.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>剰余は、同じ方法で扱われて、そして再び分割されるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The remainder operator (%) is also known as a modulo operator in other languages.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>剰余演算子（%）は、また、他の言語ではモジュロ演算子として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The remaining arguments can appear in any order and specify additional information about the declaration’s life cycle, including important milestones.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>残りの引数は、随意の順序で現れることができて、追加的な情報を宣言の寿命について、重要なマイルストーンを含めて指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The remaining bits (known as the value bits) store the actual value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>残っているビット（値ビットとして知られるもの）は、実際の値を格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The requirement to always return a single type doesn’t prevent you from using generics in an opaque return type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>常に単一の型を返すという要件は、あなたが総称体を不透明戻り型において使う妨げになりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The response to a survey question can’t be known until it’s asked, and so the response property is declared with a type of String?, or “optional String”.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>意識調査への回答は、それが尋ねられるまでは知られることができません、なのでresponseプロパティはString?の型、すなわち「オプショナルのString」を使って宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The rest of this chapter uses the term concurrency to refer to this common combination of asynchronous and parallel code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この章の残りは、非同期および並列コードのこの普通の組み合わせに言及するのに用語、並行性を用います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The restriction against overlapping access to properties of a structure isn’t always necessary to preserve memory safety.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体のプロパティに対するオーバーラップするアクセスを禁じる制限は、メモリ安全を守るために必ずしも必要ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The result is a sequence of diceRoll values that’s always 1, 2, 3, 4, 5, 6, 1, 2 and so on.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>結果は一連のdiceRoll値で、それは常に1、2、3、4、5、6、1、2など、となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The result is a specialized version of that generic type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>結果は、その総称体型の特殊化版です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The result is exactly the same as if you place an exclamation point after a normal optional that doesn’t contain a value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その結果は、あなたが値を含まない通常のオプショナルの後に感嘆符を置いた場合と正確に同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The result of item as? Movie is of type Movie?, or “optional Movie”.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>item as? Movieの結果は、Movie?型、すなわち「オプショナルのMovie」です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The result of flipping a triangle is a value of type Shape, and the protoFlip(_:) function takes an argument of some type that conforms to the Shape protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>三角形を裏返すことの結果は、型Shapeの値です、そしてprotoFlip(_:)関数はShapeプロトコルに準拠する型の引数を取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The result of the i == 1 comparison is of type Bool, and so this second example passes the type-check.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>i == 1の比較の結果は型Boolです、それでこの第二の例は型チェックを通ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The result-building methods are as follows:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>リザルビルドメソッドは、以下があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The return type can be any type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>戻りの型は任意の型であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The return type can include types that are part of the function’s generic type parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>戻り型は、関数のもつ総称体型パラメータの一部である型を定義含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The return type of makeIncrementer is () -&gt; Int.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>makeIncrementerの戻り型は、() -&gt; Intです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The return value of john.residence?.address?.street is therefore also String?, even though two levels of optional chaining are applied in addition to the underlying optional type of the property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>john.residence?.address?.streetの戻り値は、したがってまた、String?です、その下のプロパティのオプショナル型に加えて２つのオプショナル連鎖の階層が適用されるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The return value of a function can be ignored when it’s called:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数の戻り値は、それが呼ばれるとき無視されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The returned array value is stored in boardColors and can be queried with the squareIsBlackAt(row:column:) utility function:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>返された配列値は、boardColorsに格納されて、便利な支援関数のsquareIsBlackAt(row:column:)で問い合わされることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The revised version of the code returns an instance of Square or an instance of FlippedShape, depending on what shape is passed in.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この改訂版のコードは、SquareのインスタンスまたはFlippedShapeのインスタンスを返します、どの形状が渡されるかに依存して。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The role of printMathResult(_:_:_:) is to print the result of a call to a math function of an appropriate type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>printMathResult(_:_:_:)の役割は、適切な型の数学関数に対する呼び出しの結果を出力することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The row height should be 50 points taller than the content height if the row has a header, and 20 points taller if the row doesn’t have a header:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列の高さは、列にヘッダがあるならば内容の高さより50ポイント高く、列にヘッダがないならば20ポイント高くなければなりません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The rules for combining numeric constants and variables are different from the rules for numeric literals.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>数の定数や変数を結合することに対する規則は、数のリテラルに対する規則と異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The rules for how initializer delegation works, and for what forms of delegation are allowed, are different for value types and class types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>どのようにイニシャライザ委任が働くか、そしてどんな委任の形式が許されるかの規則は、値型とクラス型で異なります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The rules of the game are as follows:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ゲームの規則は、次の通りです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The rules only affect how you write the implementation of the class’s initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの規則は、あなたがクラスのイニシャライザの実装を書く方法に影響を及ぼすだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The same behavior applies to enumerations:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じ挙動は、列挙にもあてはまります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The same is true for method parameters, because methods are just functions that are associated with a type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じことはメソッドパラメータにもあてはまります、なぜならメソッドは、あるひとつの型に結び付けられた単なる関数だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The same is true if you attempt to set a property through optional chaining.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じことは、あなたがプロパティをオプショナル連鎖を通して設定しようと試みる場合にも当てはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The same isn’t true for classes, which are reference types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じことはクラスにはあてはまりません、それは参照型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The same method is applied when calculating the remainder for a negative value of a:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じメソッドが、負の値のaのための余りを計算するとき適用されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The same value can appear in an array multiple times at different positions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>同じ値は、ひとつの配列の中で複数回異なる位置で現れることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The scope of a labeled statement is the entire statement following the statement label.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ラベルをつけられた文のスコープは、文ラベルに続いている文全体です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The scope of each case can’t be empty.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それぞれのケース節のスコープは、空であることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The second Rect initializer, init(origin:size:), is functionally the same as the memberwise initializer that the structure would have received if it didn’t have its own custom initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>二番目のRectイニシャライザ、init(origin:size:)は、構造体が独自のあつらえのイニシャライザを持たない場合に受け取る省略時のメンバー関連イニシャライザと機能的に同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The second and third parameters are called a and b, and are both of type Int.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２番目と３番目のパラメータはaとbと呼ばれます、そして両方ともInt型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The second block is then closed, followed by the first block:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>第二のブロックはそれから閉じられます、そして最初のブロックが続きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The second class in the hierarchy is a subclass of Food called RecipeIngredient.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この階層構造における第二のクラスは、RecipeIngredientと呼ばれるFoodのサブクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The second closure is an error handler that displays an error to the user.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２番目のクロージャは、エラーハンドラです、それはエラーをユーザに対して表示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The second form emits the warning message as a nonfatal warning and allows compilation to proceed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２番目の形式は、warning message（警告メッセージ）を致命的でない警告として発して、コンパイルの続行を許します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The second form evaluates to the value of the type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>第二の形式は、型の値に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The second form is used to access the superclass’s subscript implementation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>第２の形式は、スーパークラスの添え字実装にアクセスするために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The second form of a line control statement, #sourceLocation(), resets the source code location back to the default line numbering and file path.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>行制御文の２番目の形式、#sourceLocation()はソースコード位置を再設定して、初期状態の行番号振りとファイルパスに戻します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The second form of an if statement provides an additional else clause (introduced by the else keyword) and is used for executing one part of code when the condition is true and another part of code when the same condition is false.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>if文の２番目の形式は、追加のelse節（代わりの節）を提供します（elseキーワードで導入されます）、そして条件が真である場合はあるコード部分を、そして同じ条件が偽である場合は別のコード部分を実行するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The second function, printWithoutCounting(string:), calls the first function, but ignores its return value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>第二の関数、printWithoutCounting(string:)は、最初の関数を呼びます、しかしその戻り値を無視します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The second initializer has a single initialization parameter with an argument label of fromKelvin and a parameter name of kelvin.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>第二のイニシャライザは、fromKelvinの引数ラベルとkelvinのパラメータ名を使うただ１つの初期化パラメータを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The second is a convenience type function called isUnlocked(_:), which returns true if a particular level number is already unlocked.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>第二は、isUnlocked(_:)と呼ばれる便利な型関数です、それは、特定のレベル番号がすでに錠を開けられるならば、trueを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The second kind of pattern is used for full pattern matching, where the values you’re trying to match against may not be there at runtime.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>2番目の種類のパターンは、完全なパターンマッチングのために使われます、そこにおいてあなたがマッチを試みている対象である値は実行時にそこにないかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The second pair has a key of "DUB" and a value of "Dublin".</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２番目の組みは、"DUB"のキーと"Dublin"の値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The second situation is when you implicitly inherit from the same protocol multiple times.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>第二の状況は、あなたが暗黙的に同じプロトコルから複数回継承する時です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The second subclass, Song, adds an artist property and initializer on top of the base class:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>第二のサブクラスSongは、基盤クラスの上にartistプロパティとイニシャライザを加えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The second type parameter, U, has a type constraint that requires U to conform to the protocol SomeProtocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２番目の型パラメータUは、UにプロトコルSomeProtocolに準拠することを要求する型制約を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The second type property is a variable stored property called maxInputLevelForAllChannels.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>第二の型プロパティは、maxInputLevelForAllChannelsと呼ばれる変数格納プロパティです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The self Property</seg>
      </tuv>
      <tuv lang="ja">
        <seg>selfプロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The sequence being iterated over is a range of numbers from 1 to 5, inclusive, as indicated by the use of the closed range operator (...).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それに対して繰り返しを行われている連続物（シーケンス）は、完結範囲演算子（...）の使用によって示されるように、1から5までを含める数からなる範囲です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The sequence method is declared with the warn_unqualified_access attribute to help reduce confusion when attempting to use one or the other from within a Sequence extension.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>シーケンスメソッドは、warn_unqualified_access属性で宣言されることで、一方または他方を使うことをあるSequence拡張内から試みる時に混乱を減らすのを助けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The server either responds with the requested information, or it responds with a description of what went wrong.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのサーバーは要請された情報で応答するか、またはそれは何がうまくいかなかったかの説明で応答するかのどちらかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The setter clause is optional, and when only a getter is needed, you can omit both clauses and simply return the requested value directly, as described in Read-Only Computed Properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>セッター節は任意です、そして、ゲッターだけが必要なとき、あなたは両方の節を省略することができます、そして読み出し専用の計算プロパティで記述されるように、単に直接に要請された値を返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The setter clause is optional, and when only a getter is needed, you can omit both clauses and simply return the requested value directly.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>セッター節は任意です、そしてゲッターだけが必要なとき、あなたは両方の節を省略して、単に直接要請された値を返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The setter ensures that new values are less than or equal to 12, and the getter returns the stored value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>セッターは、新しい値が12より少ないかまたは等しいことを保証します、そしてゲッターは格納された値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The setter in TwelveOrLess treats 10 as a valid value so storing the number 10 in rectangle.height proceeds as written.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>TwelveOrLessの中のセッターは、10を有効な値として扱うので、数10をrectangle.heightの中に格納することは、書き出されたとおりに起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The shifting behavior is more complex for signed integers than for unsigned integers, because of the way signed integers are represented in binary.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>シフト挙動は、符号つき整数では符号なし整数よりももっと複雑です、なぜなら、符号つき整数が２進数において表される方法のためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The shorthand syntax for available attributes concisely expresses availability for multiple platforms.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>available属性のための略記構文は、複数のプラットホームに対する有効性を簡潔に表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The sign bit is 0 (meaning “positive”), and the seven value bits are just the number 4, written in binary notation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>符号ビットは0です（「正」を意味します）、そして７つの値ビットはちょうど、２進数表記法で書かれる数4です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The sign of b is ignored for negative values of b.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>bの符号は、負の値のbのために無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The sign of a numeric value can be toggled using a prefixed -, known as the unary minus operator:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>数の値の符号は、単項マイナス演算子として知られる、接頭辞-を使うことによって切り換えられることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The simplest entry in a parameter list has the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>パラメータ・リストの中の最も単純な項目は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The simplest form of initializer syntax uses the type name of the class or structure followed by empty parentheses, such as Resolution() or VideoMode().</seg>
      </tuv>
      <tuv lang="ja">
        <seg>イニシャライザ構文の最も単純な形式は、クラスまたは構造体の型名を使用して、それに空の丸括弧を続けます、例えばResolution()またはVideoMode()のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The single type parameter for findIndex(of:in:) is written as T: Equatable, which means “any type T that conforms to the Equatable protocol.”</seg>
      </tuv>
      <tuv lang="ja">
        <seg>findIndex(of:in:)のただ１つの型パラメータは、T: Equatableとして書かれます、それは、「何らかの型TでEquatableプロトコルに準拠するもの」を意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The sorting closure needs to return true if the first value should appear before the second value, and false otherwise.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このソートを行うクロージャは、最初の値が第２の値の前に現れるべきならばtrueを、そうでないならばfalseを返す必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The specialized version of the generic Dictionary type, Dictionary&lt;String, Int&gt; is formed by replacing the generic parameters Key: Hashable and Value with the concrete type arguments String and Int.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体Dictionary型の特殊化版、Dictionary&lt;String, Int&gt;は、総称体パラメータKey: HashableおよびValueを具象型引数StringおよびIntと置き換えて作り上げられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The specific implications of this guiding principle for different aspects of the language are covered in detail below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この言語の異なる面に対する、この原理指針の特定の影響は、詳細に下で扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The specific kinds of Swift code that use long-term accesses are discussed in the sections below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>特定の種類のスウィフトコードでそれら長期アクセスを使うものは、下の節で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The specified string becomes the value of #filePath, and the last path component of the string is used by the value of #fileID.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>指定された文字列は、#filePathの値になります、そして文字列の最後のパス構成要素は#fileIDの値によって使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The stack now holds four values, with the most recent one at the top.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スタックは現在は４つの値を持ちます、最も最近のものは一番上にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The standard library provides pointer and buffer types that you can use if you need to interact with pointers directly—see Manual Memory Management [https://developer.apple.com/documentation/swift/swift_standard_library/manual_memory_management].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>標準ライブラリは、ポインタとバッファ型を提供します、それはあなたが直接にポインタと相互作用する必要があるならばあなたが使用できます — 手動メモリ管理 [https://developer.apple.com/documentation/swift/swift_standard_library/manual_memory_management]を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The start of the closure’s body is introduced by the in keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャのもつ本文の始まりは、inキーワードで紹介されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The statement if let somePlanet = Planet(rawValue: 11) creates an optional Planet, and sets somePlanet to the value of that optional Planet if it can be retrieved.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文if let somePlanet = Planet(rawValue: 11)は、オプショナルのPlanetを作成して、それが取り出されることができるならば、somePlanetをそのオプショナルのPlanetのもつ値に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The statements in the defer statement can’t transfer program control outside of the defer statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>defer文の中の文は、プログラムの制御をdefer文の外側に移すことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The statements within the defer statement are executed no matter how program control is transferred.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>defer文内の文は、どのようにプログラム制御が移されようと関係なく実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The statements’ conditions and cases are mapped onto the leaf nodes of a binary tree, and the statement becomes a nested call to the buildEither methods following the path to that leaf node from the root node.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その文のもつ条件と事例は、ある二分木のリーフノードそれらへとマップされます、そして文はbuildEitherメソッドそれらへのある入れ子にされた呼び出しになり、ルートノードからそのリーフノードへの経路をなぞっています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The static method is a member of one of the types whose values the operator takes as an argument—for example, an operator that multiplies a Double by an Int is implemented as a static method on either the Double or Int structure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この静的メソッドは、その演算子が引数としてとる値の型のうちの１つに属するあるメンバーです、例えばDoubleにIntを掛ける演算子は静的メソッドとしてDoubleまたはInt 構造体のどちらかで実装されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The stored or computed nature of an inherited property isn’t known by a subclass—it only knows that the inherited property has a certain name and type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>継承されたプロパティの格納または計算の種別は、サブクラスには知られません ― それは、継承されたプロパティが特定の名前と型を持つということを知っているだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The string "123" can be converted into the numeric value 123, but the string "hello, world" doesn’t have an obvious numeric value to convert to.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列"123"は数の値123に変えられることができます、しかし文字列"hello, world"には変えるための明らかな数の値がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The string begins on the first line after the opening quotation marks (""") and ends on the line before the closing quotation marks, which means that neither of the strings below start or end with a line break:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列は、開始引用符（"""）の後の最初の行で始まって終了引用符の前の行で終わります、それが意味するのは下の文字列のどちらも改行で始まったり終わったりしないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The string retrieved from the digitNames dictionary is added to the front of output, effectively building a string version of the number in reverse.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>digitNames辞書から取り出される文字列はoutputの前方に加えられて、うまい具合に数の文字列版を逆の順序で造ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The string value of #file depends on the language version, to enable migration from the old #filePath behavior to the new #fileID behavior.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>#fileの文字列値は、言語バージョンに依存して、古い#filePath挙動から新しい#fileID挙動への移行が可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The string value of a #fileID expression has the form module/file, where file is the name of the file in which the expression appears and module is the name of the module that this file is part of.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>#fileID式の文字列値は、形式module/fileを持ちます、そこでfileはそれにおいて拡張が現れるファイルの名前です、そしてmoduleはこのファイルがそれの一部であるところのモジュールの名前です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The string value of a #filePath expression is the full file-system path to the file in which the expression appears.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>#filePath式の文字列値は、それにおいて式が現れるファイルへの完全なファイルシステムパスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The string-sorting closure from the Closure Expression Syntax section above can be written outside of the sorted(by:) method’s parentheses as a trailing closure:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のクロージャ式構文の節の文字列を分類するクロージャは、後付クロージャとしてsorted(by:)関数の括弧の外側に書かれることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The strong reference cycle prevents the Person and Apartment instances from ever being deallocated, causing a memory leak in your app.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>強い参照循環はPersonとApartmentインスタンスがともかく割り当て解除されるのを妨げます。そして、あなたのアプリのメモリリークを引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The strong references between the Person instance and the Apartment instance remain and can’t be broken.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>PersonインスタンスとApartmentインスタンスの間の強い参照は、残っていて、壊されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The strong references from the two variables (john and unit4A) and the links between the two instances are created as before:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２つの変数（johnとunit4A）からの強い参照と２つのインスタンスの繋がりは、前の通り作成されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The structure also defines a stored integer property called numberOfEdits, which is used to track the number of times that value is modified.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この構造体はまた、numberOfEditsと呼ばれる格納整数プロパティを定義します、それは、valueが修正される回数を追跡するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The structure defines a single initializer, init, with no parameters, which initializes the stored temperature with a value of 32.0 (the freezing point of water in degrees Fahrenheit).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この構造体は、パラメータのないただ１つのイニシャライザ、initを定義します、それは格納された温度を値32.0（華氏度数での水の氷点）で初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The structure is either not captured by any closures, or it’s captured only by nonescaping closures.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その構造体はどんなクロージャによってもキャプチャされない、またはそれは非脱出クロージャによってのみキャプチャされる。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The structure is the value of a local variable, not a global variable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その構造体はローカル変数の値である、グローバル変数ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The structure of the repeat-while loop is better suited to this game than the while loop in the previous example.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>repeat-whileループの構造は、前の例でのwhileループよりも更に良くこのゲームに適しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The structure’s members (including the numberOfEdits property) therefore have an internal access level by default.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体のメンバー（numberOfEditsプロパティを含む）は、したがって特に何もしなければ内部のアクセス水準を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The subclass in this figure has two designated initializers and one convenience initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この図の中のサブクラスは、２つの指定イニシャライザと１つの便宜イニシャライザを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The subclass inherits characteristics from the existing class, which you can then refine.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>サブクラスは既存のクラスから特徴を受け継ぎます、あなたはそのとき改良することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The subclass object isn’t deallocated until all deinitializers in its inheritance chain have finished executing.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>サブクラスオブジェクトは、その継承連鎖の中の全てのデイニシャライザが実行を終えるまで、割り当て解除されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The subclass’s implementation of that initializer must also be marked with the required modifier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このイニシャライザのサブクラスでの実装はまた、required修飾子で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The subclass’s implementation of that initializer must also be marked with the required declaration modifier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのイニシャライザのサブクラスの実装もまた、required宣言修飾子で印されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The subscript can accept a parameter that’s either a key path or a member name; if you implement both subscripts, the subscript that takes key path argument is used.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字は、あるパラメータを受け入れます、それはキーパスまたはメンバ名のどちらかです；あなたが両方の添え字を実装するならば、キーパス引数をとる添え字が使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The subscript on Container returns Item, which means that the type of twelve is also inferred to be Int.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Container上での添え字は、 Itemを返します、それはtwelveの型もまたIntに推論されることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The subscript returns an optional value of the dictionary’s value type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字は辞書のもつ値型のオプショナルの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The subscript takes a single parameter, indices, which is an instance of that Indices type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この添え字は、ただ１つだけのパラメータ、indicesをとります、それはIndices型のインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The subscript’s return type can be any type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字のもつ戻り型は、どんな型でも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The superclass doesn’t itself have a further superclass, and so rule 1 doesn’t apply.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このスーパークラスにはそれ自身には更にスーパークラスをもちません、なので規則１は適用されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The superclass’s designated initializer makes sure that all of the superclass properties have a value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スーパークラスの指定イニシャライザは、スーパークラスのプロパティの全てが値を持つことを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The superclass’s designated initializer now has an opportunity to customize the instance further (although it doesn’t have to).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スーパークラスの指定イニシャライザは、現在、さらにインスタンスを好みに合わせて作り返る機会があります（しかしながら、それはそうしなければならない訳ではない）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The switch cycles between three different power states (off, low and high) every time its next() method is called.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この切替えは、３つの異なる出力状態（off、lowとhigh）の間を、それのnext()メソッドが呼ばれるたびに循環します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The syntax and standard library have been designed based on the guiding principle that the obvious way to write your code should also perform the best.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構文と標準ライブラリは、明確なやり方であなたのコードを書くことが常に最良を成すべきだという指針に基づいて設計されています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The syntax for creating instances is very similar for both structures and classes:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>インスタンスをつくるための構文は、構造体とクラスの両方で非常に類似しています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The syntax for protocol inheritance is similar to the syntax for class inheritance, but with the option to list multiple inherited protocols, separated by commas:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル継承のための構文は、クラス継承のための構文に似ています、しかし複数の継承されたプロトコルをコンマで区切って列記する選択肢を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The syntax for string creation and manipulation is lightweight and readable, with a string literal syntax that’s similar to C. String concatenation is as simple as combining two strings with the + operator, and string mutability is managed by choosing between a constant or a variable, just like any other value in Swift.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列の作成と操作のための構文は、軽量で、読みやすく、Cに類似した文字列リテラル構文をもちます。文字列の連結は、２つの文字列を+演算子を使って繋ぎ合わせるくらい単純です、そして、文字列が変更可能かどうかは、スウィフトの他あらゆる値と同じように、定数または変数のどちらかを選ぶことによって管理されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The syntax used in the examples above marks the enumeration as conforming to the CaseIterable [https://developer.apple.com/documentation/swift/caseiterable] protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例において使われる構文は、列挙をCaseIterable [https://developer.apple.com/documentation/swift/caseiterable]プロトコルに準拠するように印します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The synthesized storage for the wrapper has an access control level of private.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ラッパーのために合成されたストレージは、privateのアクセス制御水準を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The temporary array is passed as the argument in the buildArray(_:) call.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>一時的配列は、引数としてbuildArray(_:)呼び出しにおいて渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The tenant property is optional because an apartment may not always have a tenant.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>アパートには常に賃借人がいるわけではないので、tenant（テナント、賃借人）プロパティはオプショナルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The ternary conditional operator is shorthand for the code below:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>三項条件演算子は、下のコードの短縮形です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The ternary conditional operator provides an efficient shorthand for deciding which of two expressions to consider.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>三項条件演算子は、２つの式のどちらを考慮するべきか決定することについての効果的な短縮形を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The third Rect initializer, init(center:size:), is slightly more complex.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>第３のRectイニシャライザ、init(center:size:)は、わずかにより複雑です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The third and final class in the hierarchy is a subclass of RecipeIngredient called ShoppingListItem.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この階層構造の中の３番目の最後のクラスは、ShoppingListItemと呼ばれるRecipeIngredientのサブクラスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The third and fourth requirements combine to mean that the items in anotherContainer can also be checked with the != operator, because they’re exactly the same type as the items in someContainer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>３番目と４番目の要件は組み合わされて、anotherContainerの中の項目が!=演算子を使って確認されることが同様に可能なことを意味します、なぜなら、それらはsomeContainerの中の項目と同じ正確に型であるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The third call fails, because the testScores dictionary doesn’t contain a key for "Brian".</seg>
      </tuv>
      <tuv lang="ja">
        <seg>３番目の呼び出しは失敗します、なぜなら、testScores辞書は"Brian"のキーを含んでいないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The third form is used to access an initializer of the superclass.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>第３の形式は、スーパークラスのイニシャライザにアクセスするために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The third property, street, is used to name the street for that address:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>第３のプロパティ、streetは、そのアドレスの通りのために使われます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The three switch cases declare placeholder constants x and y, which temporarily take on one or both tuple values from anotherPoint.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>３つのswitchケース節はプレースホルダ定数xとyを宣言します、それは、一時的にanotherPointから１つまたは両方のタプル値を引き受けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The three switch cases declare placeholder constants x and y, which temporarily take on the two tuple values from yetAnotherPoint.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>３つのswitchケース節はプレースホルダ定数xとyとを宣言します、それは、一時的に２つタプル値をyetAnotherPointから引き受けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The three code snippets below define a hierarchy of classes and an array containing instances of those classes, for use in an example of type casting.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下の３つのコードの断片は、型キャストの例で使うために、あるクラス階層とそれらのクラスのインスタンスを含んでいる配列を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The tokens =, -&gt;, //, /*, */, ., the prefix operators &lt;, &amp;, and ?, the infix operator ?, and the postfix operators &gt;, !, and ? are reserved.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>トークン=、-&gt;、//、/*、*/、.、接頭辞演算子&lt;、&amp;、および?、そして接中辞演算子?、そして接尾辞演算子&gt;、!、および?は予約されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The top item in the stack is popped.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スタックでの一番上の項目がポンと取り出され（ポップされ）ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The top-level code in a Swift source file consists of zero or more statements, declarations, and expressions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるスウィフトソースコードにおけるトップレベル・コードは、０個以上の文、宣言、そして式から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The trailing closure is passed as the argument for the parameter that it matches.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>後付クロージャは、それが合致するパラメータに対して引数として渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The trailing closures are understood as arguments to the function, added after the last parenthesized argument.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>後付クロージャそれらは、関数に対する引数それらとして理解されます、そして、丸括弧に入れられた最後の引数の後に加えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The transformation process doesn’t change declarations in the code, which lets you use temporary constants and variables to build up expressions piece by piece.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>変換処理は、コードの中の宣言を変更しません、それはあなたに一時的な定数と変数を使用して式それらを一つ一つ組み立てさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The two containers to be checked don’t have to be the same type of container (although they can be), but they do have to hold the same type of items.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>調べられる２つのコンテナは、同じ型のコンテナである必要はありません（とは言えそうでもよい）、しかしそれらは同じ型の項目を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The two write accesses refer to the same memory and they overlap, producing a conflict.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２つの書き込みアクセスは同じメモリを参照してそれらはオーバーラッブして、衝突を生み出しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type Expression is a placeholder for the type of the result builder’s input, Component is a placeholder for the type of a partial result, and FinalResult is a placeholder for the type of the result that the result builder produces.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型Expressionはリザルトビルダーのもつ入力の型に対するプレースホルダです、Componentは部分結果の型に対するプレースホルダです、そしてFinalResultはリザルトビルダーが産み出す結果の型に対するプレースホルダです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type Optional&lt;Wrapped&gt; is an enumeration with two cases, none and some(Wrapped), which are used to represent values that may or may not be present.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型Optional&lt;Wrapped&gt;は、noneとsome(Wrapped)、２つのケース節をもつ列挙です、それは、存在しているかもしれないししていないかもしれない値を表わすために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type alias can provide concrete types for some or all of the generic parameters of the existing type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型エイリアスは、既存の型の総称体パラメータの一部またはすべてに具象型を提供できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type annotation (: type) is optional in a constant declaration when the type of the constant name can be inferred, as described in Type Inference.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数名の型が推論されることができるとき、型推論で記述されるように、型注釈（: type）は定数宣言において任意です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type arguments are instead inferred from the type of the arguments passed to the function or initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型引数は、その代わりに関数またはイニシャライザに渡される引数の型から推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type check operator returns true if the instance is of that subclass type and false if it’s not.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型確認演算子はそのインスタンスがそのサブクラス型ならばtrueを、それがそうでないならばfalseを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type method can be used as an infix operator between existing Vector2D instances:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この型メソッドは既存のVector2Dインスタンスの間で接中辞演算子として使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type must implement a subscript(dynamicMember:) subscript.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この型は、subscript(dynamicMember:)添え字を実装しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type must implement either a dynamicallyCall(withArguments:) method, a dynamicallyCall(withKeywordArguments:) method, or both.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その型は、dynamicallyCall(withArguments:)、dynamicallyCall(withKeywordArguments:)メソッドのどちらか、または両方を実装しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type must provide a main type function that doesn’t take any arguments and returns Void.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型は、あるmain型関数を提供しなければなりません、それはどんな引数もとりません、そしてVoidを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type of directionToHead is already known, and so you can drop the type when setting its value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>directionToHeadの型はすでに知られています、それでその値を設定するとき、あなたは型を省くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type of directionToHead is inferred when it’s initialized with one of the possible values of CompassPoint.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>directionToHeadの型は、それがCompassPointの可能な値のうちの１つで初期化されるとき、推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type of newValue is the same as the return value of the subscript.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>newValueの型は、添え字の戻り値と同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type of twelve is inferred to be Int, which illustrates the fact that type inference works with opaque types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>twelveの型は、Intであると推論されます、それは型推論が不透明型を扱うという事実を例示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type of a Swift array is written in full as Array&lt;Element&gt;, where Element is the type of values the array is allowed to store.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフト配列の型は、完全にはArray&lt;Element&gt;のように書かれます、そこにおいてElementはその配列が格納するのを許される値の型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type of a Swift dictionary is written in full as Dictionary&lt;Key, Value&gt;, where Key is the type of value that can be used as a dictionary key, and Value is the type of value that the dictionary stores for those keys.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトの辞書型は、完全にはDictionary&lt;Key, Value&gt;のように書かれます、ここでKeyは辞書キーとして使われることができる値の型です、そしてValueは辞書がそれらのキーに対してたくわえる値の型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type of a Swift set is written as Set&lt;Element&gt;, where Element is the type that the set is allowed to store.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるスウィフト集合の型は、Set&lt;Element&gt;のように書かれます、そこにおいてElementはその集合が格納することを許される型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type of both of these functions is (Int, Int) -&gt; Int.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの関数の型は両方とも、(Int, Int) -&gt; Intです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type of each parameter must be included—it can’t be inferred.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>各パラメータの型は、含められなければなりません ― それは、推論されることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type of the letters variable is inferred to be Set&lt;Character&gt;, from the type of the initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>letters変数の型は、そのイニシャライザの型から、Set&lt;Character&gt;と推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type of the celebrator parameter is Named &amp; Aged, which means “any type that conforms to both the Named and Aged protocols.” It doesn’t matter which specific type is passed to the function, as long as it conforms to both of the required protocols.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>celebratorパラメータの型はNamed &amp; Agedです、それは「NamedとAgedプロトコルの両方に準拠する何らかの型」を意味します。どのような具体的な型が関数へ渡されるかは問題ではありません、それが必須プロトコルの両方に準拠する限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type of the numberOfLegs dictionary is inferred to be [String: Int].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>numberOfLegs辞書の型は、[String: Int]であると推測されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type of the library array is inferred by initializing it with the contents of an array literal.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>library配列の型は、ある配列リテラルの内容でそれを初期化することから推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type of the array is inferred to be [ShoppingListItem].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列の型は、[ShoppingListItem]であると推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type of the parameter to the setter is the same as the return type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>セッターに対するパラメータの型は、return type（戻り型）と同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type of the property must conform to the NSCopying protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティの型は、NSCopyingプロトコルに準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type of the shorthand argument names is inferred from the expected function type, and the highest numbered shorthand argument you use determines the number of arguments that the closure takes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>短縮形引数名の型は、期待される関数型から推論されます、そしてあなたが使用する最も高い番号のついた短縮形引数は、クロージャがとる引数の数を決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type of the variable or property must be an optional class type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この変数またはプロパティの型はまた、オプショナルクラス型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type of these values is specified in the raw-value type and must represent an integer, floating-point number, string, or single character.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの値の型は、生の値型において指定されて、整数、浮動小数点数、文字列または単一の文字を表さなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type of this function is () -&gt; Void, or “a function that has no parameters, and returns Void.”</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この関数の型は() -&gt; Voidです、あるいは「パラメータを持たず、Voidを返す関数」。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type of this property is String?.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このプロパティの型は、String?です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The types of orangesAreOrange and turnipsAreDelicious have been inferred as Bool from the fact that they were initialized with Boolean literal values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>orangesAreOrangeとturnipsAreDeliciousの型は、それらがブールのリテラル値で初期化されたという事実から、Boolとして推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The types used for any raw values or associated values in an enumeration definition must have an access level at least as high as the enumeration’s access level.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙定義の中のあらゆる生の値または関連値のために使われる型は、少なくとも列挙のアクセス水準と同じの高さのアクセス水準を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The unary minus operator (-) is prepended directly before the value it operates on, without any white space.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>単項マイナス演算子（-）は、それが作用する値の前に、全く空白なしで、直接に先頭に追加されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The unary minus operator is a prefix operator, and so this method has to be qualified with the prefix modifier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この単項マイナス演算子は、接頭辞演算子です、なのでこのメソッドはprefix修飾子で修飾されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The underlying instance remains the same; it’s simply treated and accessed as an instance of the type to which it has been cast.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>根底にあるインスタンスは、同じもののままです；それは単に、それがキャストされた型のインスタンスとして扱われ、アクセスされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The underlying type of an optional value is Optional, which is an enumeration in the Swift standard library.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるオプショナル値の基礎をなす型は、Optionalです、それはSwift標準ライブラリにおけるある列挙です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The underscore character (_) used in place of a loop variable causes the individual values to be ignored and doesn’t provide access to the current value during each iteration of the loop.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ループ変数の代わりに使われるアンダースコア文字（_）は、その個別の値を無視されるようにして、ループの各繰り返しのときにその現在の値へのアクセスを提供しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The unused expression isn’t evaluated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>使っていない式は、評価されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The unwrapped value of a forced-value expression can be modified, either by mutating the value itself, or by assigning to one of the value’s members.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>強制された値式のアンラップされた値は、値それ自体を変化させることによって、またはその値のメンバーの１つに代入することによってのどちらでも、修正されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The unwrapped value of an optional-chaining expression can be modified, either by mutating the value itself, or by assigning to one of the value’s members.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル連鎖のアンラップされた値は、その値自体を変化させることによって、またはその値のメンバーの１つに値に代入することによってのどちらでも修正されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The use of a two-phase initialization process makes initialization safe, while still giving complete flexibility to each class in a class hierarchy.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２段階初期化処理の使用は初期化を安全にします、その一方でさらに、クラス階層において各クラスに完全な柔軟性を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The use of argument labels can allow a function to be called in an expressive, sentence-like manner, while still providing a function body that’s readable and clear in intent.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>引数ラベルの使用は、関数が、表現が豊かな、文章のようなやり方で呼び出されることを可能にします、その一方で、依然として読みやすくて意図が明白な関数本文を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The use of the required modifier ensures that you provide an explicit or inherited implementation of the initializer requirement on all subclasses of the conforming class, such that they also conform to the protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>required修飾子の使用は、あなたがある明確なもしくは継承されたイニシャライザ要件の実装を準拠クラスの全てのサブクラス上で、それらもまたそのプロトコルに準拠するように、提供することを確かなものにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The use of trailing closure syntax in the example above neatly encapsulates the closure’s functionality immediately after the function that closure supports, without needing to wrap the entire closure within the map(_:) method’s outer parentheses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例での後付クロージャ構文の使用は、クロージャの機能性をクロージャが手助けする関数の直後に手際よく要約していて、クロージャ全体をmap(_:)メソッドの持つ外側の丸括弧の内部に包む必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The value of john.residence currently contains a valid Residence instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>john.residenceの値は、現在は有効なResidenceインスタンスを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The value of multiplier is also part of a larger expression later in the string.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>multiplierの値は、また、文字列の後半のより大きな式の一部でもあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The value of opaqueJoinedTriangles in this example is the same as joinedTriangles in the generics example in the The Problem That Opaque Types Solve section earlier in this chapter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例でのopaqueJoinedTrianglesの値は、この章の前の不透明型が解決する問題節の総称体の例でのjoinedTrianglesと同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The value of a must not be greater than b.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>aの値はbより大きくてはいけません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The value of invertedBits is 11110000, which is equal to an unsigned decimal value of 240.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>invertedBitsの値は11110000です、それは、符号なし10進の値の240と等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The value of index is set to the first number in the range (1), and the statements inside the loop are executed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>indexの値は、この範囲の最初の数（1）に設定されます、そしてループの内側の文が実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The value of a try expression is the value of the expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>try式の値は、expressionの値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The value of a constant can’t be changed once it’s set, whereas a variable can be set to a different value in the future.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数の値は、一旦それが設定されるならば変わることができません、一方で変数は将来異なる値に設定されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The value of a constant doesn’t need to be known at compile time, but you must assign it a value exactly once.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数の値はコンパイル時に知られている必要はありません、しかしあなたはそれに値を厳密に一度だけ代入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The value of a dictionary literal has type [Key: Value], where Key is the type of its key expressions and Value is the type of its value expressions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>辞書リテラルの値は、型[Key: Value]を持ちます、そこで、Keyはそのキーの式の型です、そして、Valueはその値の式の型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The value of a forced-try expression is the value of the expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>強制try式の値は、expressionの値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The value of a selector expression is an instance of the Selector type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>セレクタ式の値は、Selector型のインスタンスです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The value of an await expression is the value of the expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>await式の値は、expressionの値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The value of an array literal has type [T], where T is the type of the expressions inside it.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列リテラルの値は型[T]を持ちます、そこで、Tはそれの内部の式の型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The value of an expression can be inserted into a string literal by placing the expression in parentheses after a backslash (\).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>式の値は、バックスラッシュ（\）の後の丸括弧の中にその式を置くことによってリテラル文字列に差し込まれることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The value of any condition in a guard statement must be of type Bool or a type bridged to Bool.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>guard文の中のあらゆる条件の値は、Bool型またはBoolにブリッジされる型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The value of any condition in an if statement must be of type Bool or a type bridged to Bool.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>if文の中のあらゆる条件の値は、Bool型またはBoolにブリッジされる型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The value of the condition must be of type Bool or a type bridged to Bool.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>conditionの値は、Bool型またはBoolにブリッジされる型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The value of the control expression can even be matched to the value of a case in an enumeration and checked for inclusion in a specified range of values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>制御式の値は、列挙でのケース節の値にさえマッチすることや、指定された範囲の値に包含されるかについて調べさえすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The value of the expression is set to the value obtained by evaluating the value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>式の値は、値を評価することによって得られる値に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The value of the expression must have a type that conforms to the Error protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>expression（式）の値は、Errorプロトコルに準拠する型を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The value of these properties can’t be set, and so it isn’t appropriate to provide a willSet or didSet implementation as part of an override.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらのプロパティの値は設定されることができません、なのでオーバーライドの一部としてwillSetまたはdidSetの実装を提供することは適切ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The value that remains within the bounds of the UInt8 after the overflow addition is 00000000, or zero.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オーバフロー加算の後でUInt8の領域内に残る値は、00000000、またはゼロです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The value used in a subscript can be a named value or a literal.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字の中で使われる値は、名前付きの値またはあるリテラルであることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The values defined in an enumeration (such as north, south, east, and west) are its enumeration cases.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙で定義される値（例えばnorth、south、east、そしてwest）は、それの列挙ケース節です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The values of finalSquare, board, square, and diceRoll are initialized in the same way as before:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>finalSquare、board、square、そしてdiceRollの値は、前と同じように初期化されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The values of finalSquare, board, square, and diceRoll are initialized in exactly the same way as with a while loop.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>finalSquare、board、square、そしてdiceRollの値は、正確にwhileループと同じやり方で初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The values of a dictionary can be accessed through subscripting by specifying the corresponding key in square brackets: someDictionary["Alex"] refers to the value associated with the key "Alex".</seg>
      </tuv>
      <tuv lang="ja">
        <seg>辞書の値は、角括弧の中に対応するキーを指定することによる添え字指定を通してアクセスされることができます：someDictionary["Alex"]はキー"Alex"と結び付けられた値に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The values of expressions your code can branch on are very flexible.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたのコードが分岐することができる式の値は、非常に柔軟です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The values of the conditions specified in a branch statement control how the program branches and, therefore, what block of code is executed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>分岐文において指定される条件の値は、プログラムがどのように分岐するか、したがって、コードのどのブロックが実行されるかについて制御します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The values of these properties are of the appropriate-sized number type (such as UInt8 in the example above) and can therefore be used in expressions alongside other values of the same type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらのプロパティの値は、適切なサイズの数の型（例えば上の例でのUInt8）であり、したがって、式の中で同じ型の他の値と並べて使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The values passed to a variadic parameter are made available within the function’s body as an array of the appropriate type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>可変長パラメータに渡される値は、適切な型の配列として、関数の本文内で利用可能にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The values that operators affect are operands.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>演算子が影響を及ぼす値は、演算数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The values within a tuple can be of any type and don’t have to be of the same type as each other.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タプルの内部の値は、どんな型でもかまいません、そして互いに同じ型である必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The variable unsignedOverflow is initialized with the maximum value a UInt8 can hold (255, or 11111111 in binary).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>変数unsignedOverflowは、UInt8が持つことができる最大限の値で初期化されます（255、または２進数での11111111）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The various aspects of your code that can have access control applied to them (properties, types, functions, and so on) are referred to as “entities” in the sections below, for brevity.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらに適用可能なアクセス制御を持つあなたのコードのさまざまな面（プロパティ、型、関数、その他）は、簡潔さのために、下記の節において「実在」として言及されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The version for compiler() is the compiler version, regardless of the Swift version setting passed to the compiler.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>compiler()に対するバージョンはコンパイラバージョンです、コンパイラに渡されたSwiftバージョン設定に関係なく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The version for swift() is the language version currently being compiled.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>swift()に対するバージョンは、現在コンパイルされている言語バージョンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The version number for the swift() and compiler() platform conditions consists of a major number, optional minor number, optional patch number, and so on, with a dot (.) separating each part of the version number.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>swift()およびcompiler()プラットホーム条件のためのバージョン番号は、メジャー番号、随意のマイナー番号、随意のパッチ番号、その他と、バージョン番号の各部を区切っているドット（.）から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The version of serve(customer:) below performs the same operation but, instead of taking an explicit closure, it takes an autoclosure by marking its parameter’s type with the @autoclosure attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>下のバージョンのserve(customer:)は同じ演算を実行します、しかし明示的なクロージャを取るのではなく、それは自動クロージャを、それのパラメータの型を@autoclosure属性で記することによって取ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The video mode is assigned a copy of the HD resolution of 1920 by 1080 from before.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ビデオ・モードは、以前にHD解像度1920×1080のコピーを代入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The whitespace around an operator is used to determine whether an operator is used as a prefix operator, a postfix operator, or an infix operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>演算子のまわりの空白は、演算子が接頭辞演算子、接尾辞演算子、または接中辞演算子として使われるかどうかを決定するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The whitespace before the closing quotation marks (""") tells Swift what whitespace to ignore before all of the other lines.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>終了引用符（"""）の前の空白文字は、他の行すべての前でどの空白文字を無視するかスウィフトに教えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The wrapper defines and manages any underlying storage needed by its wrapped value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ラッパーは、それのラップされた値によって必要とされるあらゆる基礎をなすストレージを定義および管理します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The wrapper must define a wrappedValue instance property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ラッパーは、あるwrappedValueインスタンスプロパティを定義しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The wrapper prevents the value of those properties from being larger than 12, and it sets the projected value to true, to record the fact that it adjusted their values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ラッパーは、それらプロパティの値が12より大きくなることを防ぎます、そしてそれは投影値をtrueに設定します、それがそれらの値を調節したという事実を記録するために。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The write access for an in-out parameter starts after all of the non-in-out parameters have been evaluated and lasts for the entire duration of that function call.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるin-outパラメータに対する書き込みアクセスは、すべての非in-outパラメータが評価された後に始まって、その関数呼び出しの全期間持続します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The zeros in 0xFF0000 effectively “mask” the second and third bytes of 0xCC6699, causing the 6699 to be ignored and leaving 0xCC0000 as the result.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>0xFF0000のゼロは、0xCC6699の２番目と３番目のバイトを効果的に「マスク」します（隠して消します）、そして6699が無視されるようになって、結果として0xCC0000が残ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Their durations overlap.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらの期間が重なる（オーバーラップする）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Their primary role is to ensure that new instances of a type are correctly initialized before they’re used for the first time.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらの主要な役割は、ある型の新しいインスタンスが、それらが初めて使われる前に正しく初期化されることを保証することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Their return value is of type Double, and can be used within mathematical calculations wherever a Double is accepted:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらの戻り値はDouble型です、そして数学計算内のDoubleが受け入れられるあらゆるところで使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Their syntax is similar to both instance method syntax and computed property syntax.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらの構文は、インスタンスメソッド構文と計算プロパティ構文に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Their type is inferred only at the point that they’re evaluated by the compiler.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらの型は、それらがコンパイラによって評価される時点においてのみ、推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Then, declare a new variable called currentLoginAttempt, and give it an initial value of 0.”</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その後で、currentLoginAttemptと呼ばれる新しい変数を宣言して、それに0の初期値を与える。」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There are two levels of optional chaining in use here, to chain through the residence and address properties, both of which are of optional type:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここで使用されるオプショナル連鎖の２つの階層があります、そしてresidenceとaddressプロパティを通り抜けて繋げます、その両方ともオプショナル型です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There are a number of ways this task can fail, including the file not existing at the specified path, the file not having read permissions, or the file not being encoded in a compatible format.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この作業が失敗するたくさんの道筋があります、そのファイルが指定したパスで存在しない、ファイルが読み出し権限を持っていない、またはファイルが互換性のある形式で符号化されていないことを含めて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There are currently three values on the stack.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>現在は３つの値がこのスタックにはあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There are four type-casting operators: the is operator, the as operator, the as? operator, and the as! operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>４つの型キャスト演算子、is演算子、as演算子、as?演算子、そしてas!演算子があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There are four ways to handle errors in Swift.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>４つの方法がエラーを取り扱うためにスウィフトにはあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There are no further superclasses to initialize, and so no further delegation is needed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>初期化するための更なるスーパークラスはありません、なので、更なる委任は必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There are now three strong references to this single Person instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>現在この１つのPersonインスタンスへの３つの強い参照があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There are several special forms that allow closures to be written more concisely:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャをより簡潔に書かれるようにする特別ないくつかの形式があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There are several types of control flow statements in Swift, including loop statements, branch statements, and control transfer statements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>いくつかの種類の制御の流れ文が、スウィフトにあります、それはループ文、分岐文、そして制御移動文を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There are several ways to handle errors.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>いくつかの方法がエラーを取り扱うためにはあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There are three basic forms of an operator declaration, one for each fixity.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>演算子宣言の基本の書式は、各定着性に対して１つずつ、３つあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There are three characteristics of memory access to consider in the context of conflicting access: whether the access is a read or a write, the duration of the access, and the location in memory being accessed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>アクセス衝突の文脈において考慮すべき３つのメモリアクセスの特徴があります：アクセスが読み出しか書き込みか、アクセスの期間、そしてメモリの中のアクセスされる位置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There are three ways to create an instance of a previously declared structure:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以前に宣言された構造体のインスタンスを作成するには３つの方法があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There are two basic forms of an if statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>if文の２つの基本の書式があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There are two cases in which a type identifier doesn’t refer to a type with the same name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある型識別子がある型に同じ名前で言及しない２つの場合があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There are two compound types: function types and tuple types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２つの複合の型：関数型とタプル型があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There are two different things named a, the variable in the surrounding scope and the constant in the closure’s scope, but only one variable named b.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>aと名前をつけられる２つの異なるものがあります、周囲のスコープにおける変数とクロージャのスコープにおける定数、しかしbと名前をつけられる変数はただひとつのものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There are two kinds of attributes in Swift—those that apply to declarations and those that apply to types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトには２種類の属性があります — 宣言に適用されるもの、そして型に適用されるもの。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There are two kinds of top-level code: top-level declarations and executable top-level code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２つの種類のトップレベルコードがあります：トップレベル宣言と実行可能トップレベルコード。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There are two type-casting patterns, the is pattern and the as pattern.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２つの型キャスト・パターン、isパターンとasパターンがあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There are two ways to create an instance of a previously declared actor:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以前に宣言されたアクターのインスタンスをつくるには２つの方法があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There are two ways to create an instance of a previously declared class:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>以前に宣言されたクラスのインスタンスをつくるには２つの方法があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There are two ways to implement the == operator: You can implement it yourself, or for many types, you can ask Swift to synthesize an implementation for you.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>==演算子を実装する２つの方法があります：あなたはそれをあなた自身で実装できます、または多くの型に対して、あなたはスウィフトにある実装をあなたかの代わりに実装するよう頼めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There can only ever be one Bank in the game, and so the Bank is implemented as a class with type properties and methods to store and manage its current state:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>１つのBankだけがゲームにおいて存在することができます、なのでBankは型プロパティと型メソッドをもつクラスとして実装されて、その現在の状態を格納および管理します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There must not be whitespace between the comparison operator and the version number.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>比較演算子とバージョン番号の間に空白があってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There will only ever be one copy of these properties, no matter how many instances of that type you create.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらのプロパティのコピーはただ１つだけ存在することになります、あなたが作るその型のインスタンスがいくらあろうとも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Thereafter, the game instantiator has the option to set the property to a suitable delegate.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その後は、このゲームのイニシャライザは、このプロパティを適当な委任先に設定する選択肢を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Therefore, RecipeIngredient automatically inherits all of its superclass’s convenience initializers too.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>したがって、RecipeIngredientは自動的にそのスーパークラスの便宜イニシャライザの全てもまた継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Therefore, ARC automatically sets a weak reference to nil when the instance that it refers to is deallocated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>したがって、ARCは自動的に、弱い参照をそれが言及するインスタンスが割り当て解除されるときnilに設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Therefore, it’s safe to check for a snake or a ladder as the first action in the loop.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>したがって、ループでの最初の活動として、ヘビまたははしごについて調べるのは差し支えありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Therefore, it’s sometimes useful to be explicit about which loop or conditional statement you want a break statement to terminate.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>したがって、あなたがbreak文に終了して欲しいループまたは条件文はどれかについて明白にすることは、しばしば役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Therefore, the names and types of an initializer’s parameters play a particularly important role in identifying which initializer should be called.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>したがって、イニシャライザのパラメータの名前と型は、どのイニシャライザが呼ばれなければならないか識別することにおいて特に重要な役割を演じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Therefore, the overall access level of the compound tuple type is private (the minimum access level of the tuple’s constituent types).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>したがって、この複合タプル型の全体としてのアクセス水準は非公開です（このタプルの構成要素の型の内の最小のアクセス水準）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Therefore, when you break the strong references held by the john and unit4A variables, the reference counts don’t drop to zero, and the instances aren’t deallocated by ARC:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>したがって、あなたがjohnとunit4A変数によって保持される強い参照を壊すとき、参照総数はゼロに落ちません、なのでインスタンスはARCによって割り当て解除されません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Therefore, you can set it to an instance of any type that adopts the RandomNumberGenerator protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>したがって、あなたはそれをRandomNumberGeneratorプロトコルを採用するあらゆる型のインスタンスに設定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Therefore, you can simply pass in the greater-than operator, and Swift will infer that you want to use its string-specific implementation:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>したがって、あなたはただ単に「大なり」演算子を渡すことができます、そしてスウィフトはあなたがその文字列特有の実装を使いたいのだと推測します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Therefore, you don’t need to specify a custom access level.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>したがって、あなたはあつらえのアクセス水準を指定する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Therefore, you must write the override modifier before the subclass’s initializer definition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>したがって、あなたはoverride修飾子をそのサブクラスのイニシャライザ定義の前に書かなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Therefore, your subclass is not (strictly speaking) providing an override of the superclass initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それゆえに、あなたのサブクラスはスーパークラスのイニシャライザのオーバーライドを（厳密に言えば）提供していません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Therefore:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>したがって：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There’s a write access to oscar during the method call because oscar is the value of self in a mutating method, and there’s a write access to maria for the same duration because maria was passed as an in-out parameter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>oscarへの書き込みアクセスがメソッド呼び出しの間にあります、なぜならoscarは変更メソッドの中のselfの値であるからです、そしてmariaへの書き込みアクセスが同じ期間にあります、なぜならmariaがin-outパラメータとして渡されたからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There’s actually an even shorter way to write the closure expression above.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>さらにより短い方法が上のクロージャ式を書くために実際にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There’s also a new @noescape parameter declaration attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>また新しい@noescapeパラメーター宣言属性もあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There’s an even simpler way to include values in strings: Write the value in parentheses, and write a backslash (\) before the parentheses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>いろいろな値を文字列の中に含めるさらに単純な方法があります：その値を丸括弧の中に書いてください、そして丸括弧の前にバックスラッシュ（\）を書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There’s no requirement for classes to subclass any standard root class, so you can include or omit a superclass as needed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>何らかの標準となるルートクラスのサブクラスであることは、クラスにとって必要条件ではありません、そのためあなたは必要に応じてスーパークラスを含めたり省略したりすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There’s nothing stopping you from having a tuple of type (Int, Int, Int), or (String, Bool), or indeed any other permutation you require.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが(Int, Int, Int)の型のタプル、または(String, Bool)、またはあなたが実際に必要とするあらゆる他の順列を持つのを止めるものは何もありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There’s one caveat to the rules above.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>１つのただし書きが、上の規則にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These attribute arguments are enclosed in parentheses, and their format is defined by the attribute they belong to.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの属性引数は丸括弧に囲まれます、そして、それらの形式はそれらが属している属性によって定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These declarations can include both stored and computed properties, instance methods, type methods, initializers, a single deinitializer, subscripts, type aliases, and even other class, structure, actor, and enumeration declarations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの宣言は、格納または計算プロパティの双方、インスタンスメソッド、型メソッド、イニシャライザ、１つだけのデイニシャライザ、添え字、型エイリアス、そして他のクラス、構造体、アクター、および列挙宣言さえも含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These declarations can include both stored and computed properties, instance methods, type methods, initializers, a single deinitializer, subscripts, type aliases, and even other class, structure, and enumeration declarations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの宣言は、格納または計算プロパティの双方、インスタンスメソッド、型メソッド、イニシャライザ、１つだけのデイニシャライザ、添え字、型エイリアス、そして他のクラス、構造体、および列挙宣言さえも含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These declarations can include both stored and computed properties, type properties, instance methods, type methods, initializers, subscripts, type aliases, and even other structure, class, actor, and enumeration declarations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの宣言は、格納または計算プロパティの双方、型プロパティ、インスタンスメソッド、型メソッド、イニシャライザ、添え字、型エイリアス、そして他の構造体、クラス、アクター、および列挙宣言さえも含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These declarations can include computed properties, computed type properties, instance methods, type methods, initializers, subscript declarations, and even class, structure, and enumeration declarations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの宣言は、計算プロパティ、計算型プロパティ、インスタンスメソッド、型メソッド、イニシャライザ、添え字宣言、そしてクラス、構造体、そして列挙宣言さえも含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These access levels are relative to the source file in which an entity is defined, and also relative to the module that source file belongs to.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらのアクセス水準は、ある実在が定義されているソースファイルと関連しています、そのうえに、ソースファイルが属しているモジュールとも関連しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These actions are described in the following sections.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの行いは、以下の節で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These are custom classes, structures, and enumerations that can work with any type, in a similar way to Array and Dictionary.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらは、ArrayとDictionaryに類似した方法で、あらゆる型で扱うことができる特注のクラス、構造体、そして列挙があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These are followed by a check digit to verify that the code has been scanned correctly:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの後にコードが正しくスキャンされたことを確認するための１つの「チェック」桁が続きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These are known as constants, and are much more powerful than constants in C. Constants are used throughout Swift to make code safer and clearer in intent when you work with values that don’t need to change.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらは定数として知られています、そしてCにおける定数よりずっと強力です。定数は、変わる必要がない値をあなたが扱う時、コードをより安全により明白にする意図でスウィフトを通して使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These are known as designated initializers and convenience initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらは、指定イニシャライザと便宜イニシャライザとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These are used as the two input values for the provided math function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらは提供された数学関数のための２つの入力値として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These arguments begin with one of the following platform or language names:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの引数は、以下のプラットホームまたは言語名の１つで始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These attributes are conceptually the same as their Objective-C counterparts.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの属性は、概念的にそれらのObjective-Cでの対応物と同じものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These changes are allowed on nonfrozen types, but they break ABI compatibility for frozen types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの変更は、非凍結型の上では許可されます、しかしそれらは凍結型に対するABI互換性を破壊します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These classes expand upon the Person and Residence model from above by adding a Room and Address class, with associated properties, methods, and subscripts.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらのクラスは、関連するプロパティ、メソッド、そして添え字とともにRoomとAddressクラスを加えることによって、上記のPersonとResidenceモデルを拡張します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These computed properties express that a Double value should be considered as a certain unit of length.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの計算プロパティは、Double値が長さの特定の単位とみなされなければならないことを表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These constants (or variables) can then be referenced in a corresponding where clause and throughout the rest of the code within the scope of the case.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの定数（または変数）は、それから対応するwhere節の中で、そしてそのケース節のスコープ内のその他のコードのいたるところで参照されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These constants are used as part of a where clause, to create a dynamic filter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの定数は、where節の一部として動的なフィルタを作成するために使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These function calls don’t violate the restriction because external isn’t one of the parameters of takesTwoFunctions(first:second:).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの関数呼び出しは制約に違反しません、なぜならexternalはtakesTwoFunctions(first:second:)のパラメータの１つだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These functions and methods are known as asynchronous functions and asynchronous methods.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの関数とメソッドは、非同期関数と非同期メソッドとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These functions and methods are known as rethrowing functions and rethrowing methods.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの関数とメソッドは、再スロー関数と再スローメソッドとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These functions and methods are known as throwing functions and throwing methods.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの関数とメソッドはスロー関数およびスローメソッドとして知られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These functions each take two Int values, and return an Int value, which is the result of performing an appropriate mathematical operation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの関数は、各々２つのInt値をとって、１つのInt値を返します、そしてそれは、適切な数値演算の実行の結果です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These include while loops to perform a task multiple times; if, guard, and switch statements to execute different branches of code based on certain conditions; and statements such as break and continue to transfer the flow of execution to another point in your code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらは、ある作業を複数回実行するwhileループ；特定の条件に基づいてコードの異なる分岐を実行するif、guard、およびswitch文；そして実行の流れをあなたのコードの別の地点に移す、breakおよびcontinueのような文を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These include all of the bitwise and bit shifting operators you will be familiar with from C and Objective-C.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらは、あなたがCとObjective-Cからお馴染みの、ビット単位およびビットシフト演算子の全てを含んでいます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These include enumeration case patterns, optional patterns, expression patterns, and type-casting patterns.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらは、列挙ケース節パターン、オプショナルパターン、式パターン、および型キャストパターンを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These include the UTF-8 encoding form (which encodes a string as 8-bit code units), the UTF-16 encoding form (which encodes a string as 16-bit code units), and the UTF-32 encoding form (which encodes a string as 32-bit code units).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらは、UTF-８符号化方式（それは、８ビット符号単位として文字列を符号化します）、UTF-16符号化方式（それは、16ビット符号単位として文字列を符号化します）、そしてUTF-32符号化方式（それは、32ビット符号単位として文字列を符号化します）を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These include wildcard patterns, identifier patterns, and any value binding or tuple patterns containing them.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらはワイルドカード・パターン、識別子パターン、そしてそれらを含むあらゆる値束縛やタプルパターンを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These initialization options are represented by three custom initializers that are part of the Rect structure’s definition:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの初期化オプションは、Rect構造体の定義の一部である３つのあつらえのイニシャライザによって表されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These initializers can be used to create new Rect instances:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらのイニシャライザが、新しいRect例をつくるために使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These integers follow a naming convention similar to C, in that an 8-bit unsigned integer is of type UInt8, and a 32-bit signed integer is of type Int32.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの整数は、８ビットの符号なし整数が型UInt8である、そして32ビットの符号つき整数が型Int32であるという点で、Cに似ている命名規則に従います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These keywords are described in the sections below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらのキーワードは、以下の節で解説されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These kinds of closures or functions typically create a temporary value of the same type as the property, tailor that value to represent the desired initial state, and then return that temporary value to be used as the property’s default value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの種類のクロージャまたは関数は、概してプロパティと同じ型の一時的な値をつくって、望み通りの初期状態を表すようにその値を仕立てて、それからその一時的な値がプロパティの省略時の値として使われるように返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These kinds of loops are best used when the number of iterations isn’t known before the first iteration begins.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの種類のループが最も使われるのは、繰り返しの回数が最初の繰り返しが始まる前にはわからないときです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These kinds of methods are called type methods.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの種類のメソッドは、型メソッドと呼ばれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These kinds of optionals are defined as implicitly unwrapped optionals.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの種類のオプショナルは、暗黙的にアンラップされるオプショナルとして定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These kinds of properties are called type properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの種類のプロパティは、型プロパティと呼ばれています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These methods are marked as mutating, because they need to modify (or mutate) the structure’s items array.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらのメソッドはmutatingとして印されます、なぜなら、それらが構造体のitems配列を修正する（または変化させる）必要があるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These methods are written as part of the protocol’s definition in exactly the same way as for normal instance and type methods, but without curly braces or a method body.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらのメソッドは、プロトコルの定義の一部として普通のインスタンスおよび型メソッドと正確に同じ方法で書かれます、しかし波括弧またはメソッド本文はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These names are valid identifiers within the scope of the closure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの名前は、クロージャのスコープ内で有効な識別子です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These operators all begin with an ampersand (&amp;):</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの演算子は、全てアンパサンド（&amp;）で始まります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These operators are now used only with String values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの演算子は今ではString値でのみ使用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These operators can be used and adopted in your code like any of the predefined operators, and you can even extend existing types to support the custom operators you define.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの演算子は、あらかじめ定義された演算子のどれとも同じように、使用されることができ、あなたのコードにおいて取り入れられることができます、そして、あなたはあなたが定義するカスタム演算子をサポートするように既存の型を拡張することさえ可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These operators can contain additional dots.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの演算子は、さらなるドットを含むことが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These operators have the same associativity and precedence as the logical operators that are used to combine ordinary Boolean expressions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの演算子は、普通のブール式を組み合わせるのに使われる論理演算子と同じ結合性と優先順位を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These optimizations include:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの最適化は、以下を含みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These options are described later in this chapter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらの選択肢は、この章の後刻に記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These overrides ensure that an AutomaticallyNamedDocument instance has an initial name value of "[Untitled]" if the instance is initialized without a name, or if an empty string is passed to the init(name:) initializer:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらのオーバーライドは、AutomaticallyNamedDocumentインスタンスが、そのインスタンスが名前なしで初期化されるならば、または空の文字列がinit(name:)イニシャライザに渡されるならば、初期name値の"[Untitled]"を持つことを確実にします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These pairings are written within a pair of square braces, separated by commas.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの組合せは、一対の角括弧内に書かれて、コンマで区切られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These properties are read-only computed properties, and so they’re expressed without the get keyword, for brevity.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらのプロパティは、読み出し専用の計算プロパティです、それでそれらは簡潔さのために、getキーワードなしで表わされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These properties store a value between 0.0 and 1.0 to indicate the amount of red, green, and blue in the color.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらのプロパティは、0.0と1.0の間の値を格納して、その色における赤、緑、および青の量を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These requirements define two different ways for data sources to provide an appropriate increment amount for a Counter instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの要件は、データ・ソースのためにCounterインスタンスに適切な増加量を用意する２つの異なる方法を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These requirements don’t have to be implemented by types that conform to the protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらの要件は、そのプロトコルに準拠する型によって実装される必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These requirements enable the allItemsMatch(_:_:) function to compare the two containers, even if they’re of a different container type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの要件は、allItemsMatch(_:_:)関数に２つのコンテナを比較するのを可能にします、たとえそれらが異なるコンテナ型であるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These requirements mean:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの要件が意味するのは：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These responsibilities are described in Class Inheritance and Initialization below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの責任は、下記のクラス継承と初期化で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These rules apply even if your subclass adds further convenience initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの規則は、たとえあなたのサブクラスが更なる便宜イニシャライザを加えるとしてもあてはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These rules are illustrated in the figure below:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの規則は、下の図で説明されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These rules don’t affect how users of your classes create instances of each class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの規則は、あなたのクラスのユーザーが各クラスのインスタンスを作成する方法に影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These situations are discussed in the sections below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの状況は、以下の節で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These statements are indicated by the else keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらの文は、elseキーワードによって指し示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These three capabilities match the requirements of the Container protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの３つの能力は、Containerプロトコルの要件に合致します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These three methods have been incorporated into the game logic within the play() method above, and are called when a new game starts, a new turn begins, or the game ends.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの３つのメソッドは、上のplay()メソッド内のゲーム論理に組み込まれています、そして、新しいゲームが始まるとき、新しいターンを開始するとき、あるいはこのゲームが終わるとき、呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These tokens can’t be overloaded, nor can they be used as custom operators.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらのトークンは、オーバーロードされることができませんし、それらはあつらえの演算子として使われることもできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These two classes each store an instance of the other class as a property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの２つのクラスは、それぞれ他のクラスのインスタンスをプロパティとして格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These two operators provide a simple and expressive way to check the type of a value or cast a value to a different type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの２つの演算子は、値の型を調べたり、値を異なる型にキャストする（配役する、投げ込む）ための単純で表現豊かな方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These two properties are inferred to be of type Int by setting them to an initial integer value of 0.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの２つのプロパティは、それらを最初の整数値0に設定することによって型Intであると推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These two statements call the subscript’s setter to set a value of 1.5 in the top right position of the matrix (where row is 0 and column is 1), and 3.2 in the bottom left position (where row is 1 and column is 0):</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの２つの文は、添え字のセッターを呼び出して、この行列の右上位置（rowが0でcolumnが1のところ）に1.5の値を、そして左下位置（rowが1でcolumnが0のところ）に3.2を設定します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These type parameters act as placeholders that are replaced by actual concrete type arguments when an instance of a generic type is created or a generic function or initializer is called.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの型パラメータは、総称体型のインスタンスがつくられる、あるいは、総称体の関数やイニシャライザが呼ばれるとき、実際の具象型引数と取り替えられるプレースホルダの働きをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These types are specified in the associated value types tuple, immediately following the name of the case.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの型は、ケース節の名前の直後に、それら関連値型のタプルを使って指定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These types aren’t the same as () -&gt; ()—a function that takes no arguments.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの型は、() -&gt; () — 引数を取らない関数、と同じではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These valid tokens form the lowest-level building blocks of the language and are used to describe the rest of the language in subsequent chapters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの公式のトークンは、言語の最も基本的な建物ブロックを形成して、以降の章において言語の残りの部分を記述するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These values are a high-surrogate value of U+D83D (decimal value 55357) and a low-surrogate value of U+DC36 (decimal value 56374).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの値は、前半代用値のU+D83D（10進の値55357）と後半代用値のU+DC36（10進の値56374）です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These values are labeled min and max so that they can be accessed by name when querying the function’s return value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらの値は、minおよびmaxとラベルをつけられます、なのでそれらはこの関数の戻り値について問い合わせるときに名前によってアクセスされることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These values are represented as optionals.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このような値は、オプショナルであるとして表現されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These variations on function syntax are discussed below in Function Argument Labels and Parameter Names and Default Parameter Values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数構文上のこれらの差異は、関数の引数ラベルとパラメータ名と省略時のパラメータ値の下で議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>They access the same location in memory.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらがメモリ中の同じ位置にアクセスする。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>They adopt many features traditionally supported only by classes, such as computed properties to provide additional information about the enumeration’s current value, and instance methods to provide functionality related to the values the enumeration represents.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらはクラスによってのみ伝統的に支えられる多くの特徴を採用します、例えば列挙の現在の値に関する追加の情報を提供する計算プロパティ、そして、列挙が表す値に関連した機能性を提供するインスタンスメソッドなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>They aren’t called while a class is setting its own properties, before the superclass initializer has been called.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらは、スーパークラスイニシャライザが呼び出され終わる前、あるクラスがそれ自身のプロパティを設定している間には呼び出されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>They can be used as expressions on their own, and they can be combined with other tokens to make prefix expressions, infix expressions, and postfix expressions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらはそれら自身で式として使われることができます、そしてそれらは接頭辞式、接中辞式、そして接尾辞式を作るために別のトークンと組み合わされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>They can’t be added together directly, because they’re not of the same type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらは直接にひとつに加算されることができません、それらが同じ型でないためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>They can’t be adopted by structures or enumerations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは構造体や列挙によって採用されることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>They continue to be a Circle, a Country and an Animal.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらは、Circle、Country、そしてAnimalであり続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>They could prefer one mark every 5 minutes instead.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>彼らは、代わりに5分毎に１つの印を選ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>They have the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらは以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>They must always explicitly declare their adoption of the protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらは、常に明示的にそのプロトコルについてそれらが採用することを宣言しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>They must always have a number (or hexadecimal number) on both sides of the decimal point.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらは、常に小数点の両側で数（または16進の数）を持たなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>They must have a set value before first use.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは最初に使用される前に値を設定される必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>They support the functionality of those instances, either by providing ways to access and modify instance properties, or by providing functionality related to the instance’s purpose.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは、そういったもののインスタンスの機能性を、インスタンスプロパティにアクセスしたり修正したりする方法を提供することで、またはインスタンスの目的と関連がある機能性を提供することでのどちらかで支えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>They themselves don’t describe a specific resolution or video mode.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらはそれら自体で、特定の解像度またはビデオ・モードを記述しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>They’re prefix if they precede their target (such as -a) and postfix operators if they follow their target (such as b!).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらは、それがその目標に先行するならば接頭辞（例えば-a）、それがその目標の後に続くならば接尾辞演算子です（例えばb!）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>They’re both optional, after all.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>結局、それらは両方ともオプショナルです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>They’re guaranteed to be initialized only once, even when accessed by multiple threads simultaneously, and they don’t need to be marked with the lazy modifier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらは、ただ一度だけ初期化されることを保証されます、複数のスレッドによって同時にアクセスされる場合でさえもです、そしてそれらはlazy修飾子で印されることを必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>They’re not suited to the creation of complex data structures.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらは、複雑なデータ構造物の作成には適していません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>They’re often used in low-level programming, such as graphics programming and device driver creation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらが、低階層のプログラミング、例えばグラフィックス・プログラミングやデバイスドライバー作成において、しばしば使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>They’re stored by subtracting their absolute value from 2 to the power of n, where n is the number of value bits.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらは、2のn乗からそれらの絶対値を減ずることによって格納されます、そこで、nは値ビットの数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Think of it as meaning “they associate with the expression to their left,” or “they associate with the expression to their right.”</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それは「それらは、式をそれらの左と結びつける」あるいは「それらは、式をそれらの右と結びつける」を意味すると考えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Think of this as adding implicit parentheses around these parts of the expression, starting from their left:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これを、これらの式部分のまわりに、暗黙の括弧をそれらの左から開始して加えることと考えてみてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This switch statement doesn’t have a default case.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このswitch文にはdefaultケース節がない点に注意してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This Player instance is stored in an optional Player variable called playerOne.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このPlayerインスタンスは、playerOneと呼ばれるオプショナルのPlayer変数に格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This default case doesn’t need to perform any action, and so it’s written with a single break statement as its body.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このdefaultケース節はいかなる動作も実行する必要がありません、なのでそれはその本文としてbreak文ひとつだけを書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This action ensures that signed integers have the same sign after they’re shifted to the right, and is known as an arithmetic shift.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この動作は、符号つき整数が、それが右へシフトされた後に同じサインを持つことを確実にします、そして算術シフトとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This additional information is called an associated value, and it varies each time you use that case as a value in your code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この追加的情報は、関連値と呼ばれます、そしてそれは、あなたがそのケース節をある値としてあなたのコードにおいて使うたびに変化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This aids code consistency and interoperability.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、コードの整合性と相互運用性を支援します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This allows you to define behavior on protocols themselves, rather than in each type’s individual conformance or in a global function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これはあなたに、それぞれの型の個々の準拠においてまたはグローバル関数においてではなく、プロトコルそれ自体に振る舞いを定義することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This also means that if you assign a closure to two different constants or variables, both of those constants or variables refer to the same closure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これはまた、あなたがクロージャを２つの異なる定数または変数に代入するならば、それらの定数または変数の両方とも同じクロージャに言及することを意味するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This approach assumes that the method’s caller knows there’s a special value to test against and remembers to check for it.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このアプローチは、メソッドの呼び出し側が試験するべき特別な値があるのを知っていて、それについて調べるのを忘れないでいると仮定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This approach avoids accidental fallthrough from one case to another and makes for safer code that’s clearer in its intent.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この取り組み方は、１つのケース節から他のものへの思いがけない抜け落ちを防止してより安全なコード、その意図するところがより明白であること、に寄与します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This approach avoids confusion about how the value is accessed in different contexts and simplifies the property’s declaration into a single, definitive statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この取り組み方は、値が異なる文脈においてアクセスされる方法についての混乱を避け、プロパティの宣言をただ１つの、決定的な文に単純化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This approach has an important drawback: Although the download is asynchronous and lets other work happen while it progresses, only one call to downloadPhoto(named:) runs at a time.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この取り組みはある重要な欠点があります：ダウンロードが非同期でありそれが進捗する間に他の仕事が起こるに任せるとはいえ、ただ１つのdownloadPhoto(named:)への呼び出しだけが一度に動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This approach is different from string mutation in Objective-C and Cocoa, where you choose between two classes (NSString and NSMutableString) to indicate whether a string can be mutated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この取り組みは、Objective-Cとココアでの文字列変化と異なります、そこでは、あなたは文字列が変化することができるかどうか示すために、２つのクラス（NSStringとNSMutableString）のどちらかを選びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This approach is known as a logical shift.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このやり方は、論理シフトとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This approach to defining a JoinedShape&lt;T: Shape, U: Shape&gt; structure that joins two shapes together vertically, like the code below shows, results in types like JoinedShape&lt;FlippedShape&lt;Triangle&gt;, Triangle&gt; from joining a flipped triangle with another triangle.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２つの形状を一緒に垂直につなぐJoinedShape&lt;T: Shape, U: Shape&gt;構造体を定義するこの取り組みは、下のコードが示すように、裏返した三角を別の三角とつなぐことからJoinedShape&lt;FlippedShape&lt;Triangle&gt;, Triangle&gt;のような型という結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This argument can’t be used when specifying Swift version availability.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この引数は、スウィフトバージョン有効性を指定する時に使われることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This assumption is demonstrated by the use of count (rather than self.count) inside the three instance methods for Counter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この仮定は、Counterのための３つのインスタンスメソッド内部での（self.countではなく）countの使用によって示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This attribute can’t be applied to declarations that are nested inside functions or to fileprivate or private declarations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性は、関数の内部に入れ子にされる宣言に、またはfileprivateやprivate宣言に適用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This attribute causes the property’s setter to be synthesized with a copy of the property’s value—returned by the copyWithZone(_:) method—instead of the value of the property itself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性は、プロパティのセッターがそのプロパティの値のコピー ― copyWithZone(_:)メソッドによって返されるもの ― を使って合成されるようにします、プロパティそれ自体の値ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This attribute is allowed only when compiling in library evolution mode.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性は、ライブラリ進化モードでコンパイルしている場合にのみ許可されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This attribute is inferred for any class that inherits from NSManagedObject.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性は、NSManagedObjectから継承されるあらゆるクラスに対して伴われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This avoids implicitly conforming to the parent protocol twice with different requirements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、その親プロトコルに対する異なる要件での二重の暗黙的準拠を回避します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This base class declares a stored property called numberOfWheels, with a default Int value of 0.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この基盤クラスはnumberOfWheelsと呼ばれる格納プロパティを、省略時の値としてInt値0を使って、宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This base class defines a stored property called currentSpeed, with a default value of 0.0 (inferring a property type of Double).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この基盤クラスは、currentSpeedと呼ばれる格納プロパティを定義します、それは0.0の省略時の値を持ちます（Doubleの型のプロパティと推論されます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This behavior can be used to match and ignore one or more cases in a switch statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この挙動は、switch文の１つ以上のケース節を適合してから無視することのために使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This behavior gives extra safety when you work with numbers that are too large or too small.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この挙動は、あまりに大きいかあまりに小さい数をあなたが扱うとき、追加の安全を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This behavior has the following rules:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この挙動は以下の規則を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This behavior is communicated by a getter and setter in the same way as for computed properties:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この挙動は、計算プロパティに関してと同様に、ゲッターとセッターによって伝えられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This behavior is different from other types, where a public type definition implies an access level of internal for the type’s members.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この挙動は他の型とは異なります、そこにおいて、公開型定義は、その型のメンバーに対して内部アクセス水準を暗黙的に意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This behavior is due to structures being value types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この挙動は、この構造体が値型であるためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This behavior is known as copy-in copy-out or call by value result.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この挙動は、コピーイン・コピーアウトまたは結果値による呼び出しとして知られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This behavior is known as value binding, because the values are bound to temporary constants or variables within the case’s body.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この挙動は値束縛として知られています、なぜなら値がそのケース節の本文内の一時的な定数または変数に束縛（バインド）されるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This behavior is referred to as longest match or maximal munch.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この挙動は、最長マッチまたは欲張り捕獲と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This behavior means you can use extensions in the same way to organize your code, whether or not your types have private entities.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この挙動は、あなたの型が非公開な実在を持つかどうかにかかわらず、あなたが拡張を同じ方法で使ってあなたのコードを編成できるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This behavior prevents the reference from becoming part of a strong reference cycle.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この挙動は、参照が強い参照循環の一部になるのを妨げます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This behavior removes the need for the array bounds check seen in the while loop version of the game described earlier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この挙動は、前に記述されたwhileループ版のゲームで見られた配列の境界検査の必要を取り除きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This book describes Swift 5.6, the default version of Swift that’s included in Xcode 13.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この本はSwift 5.6、Xcode 13に含まれるスウィフトの初期状態のバージョン、を記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This calculation yields the final answer of 17.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この計算は、最終的な答えの17を生みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This call to the insert(_:at:) method inserts a new item with a value of "Maple Syrup" at the very beginning of the shopping list, indicated by an index of 0.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>insert(_:at:)メソッドへのこの呼び出しは、"Maple Syrup"の値をもつ新しい項目を、0のインデックスによって指し示される、買い物リストのまさしくその開始位置で差し入れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This can be read as:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、次のように解釈されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This can happen if two class instances hold a strong reference to each other, such that each instance keeps the other alive.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２つのクラスインスタンスが強い参照にお互いを守らせるならば、これは起こることができます、各インスタンスが他を生かしておくようなものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This capture might occur because the closure’s body accesses a property of the instance, such as self.someProperty, or because the closure calls a method on the instance, such as self.someMethod().</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この捕獲は、例えばself.somePropertyのようにクロージャの本文がインスタンスのプロパティにアクセスするために、または例えばself.someMethod()のようにクロージャがインスタンスのメソッドを呼ぶために起こるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This chapter describes parameters and arguments for generic types, functions, and initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この章は、総称体の型、関数、そしてイニシャライザに対するパラメータと引数を記載します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This chapter describes the common operators in Swift.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この章は、スウィフトの通常の演算子を記載します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This chapter describes those situations and shows how you enable ARC to manage all of your app’s memory.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この章は、それらの状況を記載して、あなたがどのようにARCにあなたのアプリのメモリの全てを管理させるかについて示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This chapter discusses the types defined in the Swift language itself and describes the type inference behavior of Swift.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この章は、スウィフト言語それ自身によって定義される型を議論して、スウィフトの型推論挙動を記載します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This chapter now focuses more on the addition of new functionality in a subclass, and the modification of existing functionality with overrides.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この章は、今やサブクラスにおける追加された新しい機能性、そしてオーバーライドを使った既存の機能性の変更にもっと焦点を当てられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This character can be represented as a single code unit in UTF-16.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この文字は、UTF-16において単一の符号単位で表わされることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This check ensures that your overriding definition is correct.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この調査は、あなたのオーバーライドの定義が正しいことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This class has four variable stored properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このクラスは、４つの変数の格納プロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This class has three optional properties of type String?.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このクラスは、型String?の３つのオプショナルのプロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This class implements a pseudorandom number generator algorithm known as a linear congruential generator:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このクラスは、線形合同法生成器として知られている擬似乱数生成器アルゴリズムを実装します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This class implements the fullName property requirement as a computed read-only property for a starship.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このクラスは、fullNameプロパティ要件をある宇宙船のための読み出し専用の計算プロパティとして実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This class might be used with input data from a pedometer or other step counter to keep track of a person’s exercise during their daily routine.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このクラスは、万歩計または他の歩数計からの入力データとともに、ある個人の日課の運動の経過を追うために使われるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This class models a document that can be initialized with a name property that’s either a nonempty string value or nil, but can’t be an empty string:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このクラスはある書類をモデル化します、それは空でない文字列かnilのどちらかであるnameプロパティで初期化されることができます、しかし空の文字列であることはできません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This class provides basic functionality for any kind of item that appears in a digital media library.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このクラスは、基本の機能性をデジタル・メディア図書館に現れるあらゆる種類の項目のために用意します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This code can be read as:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このコードは、次のように解釈されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This code defines Compontent and Expression as type aliases, to make it easier to match the examples below to the list of methods above.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このコードは、CompontentとExpressionを型エイリアスとして定義します、そうして下の例それらを上のメソッドそれらのリストにより合うようにしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This code pauses execution again until that function returns, giving other concurrent code an opportunity to run.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このコードは、その関数が返るまで再び遂行を一時停止します、他の並行性コードに動作する機会を与えて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This code uses optional chaining in a key path to access a property of an optional string:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このコードは、オプショナル連鎖をキーパスの中で使うことで、あるオプショナル文字列に属するプロパティにアクセスします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This code uses the key path expression \OuterStructure.outer.someValue to access the someValue property of the OuterStructure type’s outer property:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このコードは、キーパス式\OuterStructure.outer.someValueを使って、someValueプロパティにアクセスします、そのプロパティはOuterStructure型の持つouterプロパティに属しています：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This code works, but it’s a little awkward.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このコードは働きます、しかしそれは少々ぎこちないものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This color is then decomposed into its red (CC), green (66), and blue (99) components by the bitwise AND operator (&amp;) and the bitwise right shift operator (&gt;&gt;).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この色はそれから、ビット単位の論理積演算子（&amp;）とビット単位の右シフト演算子（&gt;&gt;）によって、それの赤（CC）、緑（66）、そして青（99）の構成要素に分解されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This combination results in a compile-time error that the declaration has been renamed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この連携は、宣言が改名されてしまっているというコンパイル時エラーという結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This computed property considers the rank of the card and initializes a new Values instance with appropriate values based on its rank.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この計算プロパティは、カードの等級を考慮して、その等級に基づいた適切な値で新しいValuesインスタンスを初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This condition tests whether it’s possible to import the module, but doesn’t actually import it.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この条件は、そのモジュールがインポート可能であるかどうかをテストします、しかし実際にそれをインポートはしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This confirms that initialization has taken place.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、初期化が起こったことを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This constraint ensures that each element of the sequence is equatable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この制約はシーケンスの各要素が同等比較可能であることを保証します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This constraint prevents a situation in which additional essential setup provided in a more complex initializer is accidentally circumvented by someone using one of the automatic initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この制約は、あるより複雑なイニシャライザにおいて提供される追加の重要な準備が、自動的なイニシャライザのうちの１つを使う何かによって図らずも回避される状況を防ぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This continues up the class inheritance chain until the top of the chain is reached.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、クラス継承連鎖を上って、その連鎖の最上部に着くまで続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This convenience initializer assumes a quantity of 1 for any RecipeIngredient instance that’s created without an explicit quantity.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この便宜イニシャライザは、はっきりした量なしで作成されるあらゆるRecipeIngredientインスタンスに対して数量1を仮定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This convenience initializer can’t yet modify any properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この便宜イニシャライザは、まだどのプロパティも修正することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This convenience initializer simply delegates across to the class’s designated initializer, passing in a quantity value of 1.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この便宜イニシャライザはそのクラスの指定イニシャライザに、単純にquantityに値1を渡して横に委任します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This convention lets framework authors mark part of an API that clients must not interact with or depend on, even though some limitation requires the declaration to be public.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この慣例は、フレームワーク作者にあるAPIの一部を印させます、それはクライアントがそれと相互作用すべきでないまたはそれに依存すべきでないものです、たとえ何らかの限界がその宣言にパブリックであることを要求しても。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This could cause your program to crash if FutureText isn’t available at runtime, even in the case where that type is explicitly not being used.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、あなたのプログラムをクラッシュさせる可能性があります、もしFutureTextが実行時に有効でないならば、はっきりその型が使われない場合でさえ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This creates a new instance of the class or structure, with any properties initialized to their default values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、クラスまたは構造体の新しいインスタンスをつくり、どんなプロパティでもそれらの省略時の値に初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This creates work that can be carried out in parallel.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、並列に実施されることができる仕事を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This creates work that is carried out sequentially.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、逐次的に実施される仕事を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This data source is defined by the CounterDataSource protocol, which has two optional requirements:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このデータ・ソースはCounterDataSourceプロトコルによって定義されます、それは、２つのオプショナルの要件を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This default case is indicated by the default keyword, and must always appear last.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>defaultケース節は、キーワードdefaultによって示されて、常に最後に現れなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This definition doesn’t provide any actual Int or String values—it just defines the type of associated values that Barcode constants and variables can store when they’re equal to Barcode.upc or Barcode.qrCode.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この定義は、何ら実際のIntまたはString値を提供しません ― それは、ただ単に関連値の型を定義します、それは、Barcode定数と変数がBarcode.upcもしくはBarcode.qrCodeに等しいときに格納できる型です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This definition indicates that a getter-setter block can consist of a getter clause followed by an optional setter clause, enclosed in braces, or a setter clause followed by a getter clause, enclosed in braces.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この定義は、１つのゲッターセッター・ブロックが、１つのゲッター節とそれに続く任意の１つのセッター節、それを波括弧でくくったもの、または、１つのゲッター節に１つのセッター節を続けて波括弧でくくったものから成ることができることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This definition of multiple subscripts is known as subscript overloading.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この複数の添え字の定義は、添え字オーバーロードとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This design pattern is implemented by defining a protocol that encapsulates the delegated responsibilities, such that a conforming type (known as a delegate) is guaranteed to provide the functionality that has been delegated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このデザイン・パターンは、委任された責務をカプセル化するプロトコルを定義することによって実装されます、例えば、委任プロトコルに拠準する型が（代表、委任先として知られるものが）その委任されている機能性を提供する責任を負わされるといったこと。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This designated initializer matches a designated initializer from the superclass of Bicycle, and so the Bicycle version of this initializer is marked with the override modifier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この指定イニシャライザはBicycleのスーパークラスでのある指定イニシャライザと一致します、なのでこのイニシャライザのBicycle改変板はoverride修飾子で印されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This dictionary literal contains two String: String pairs.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この辞書リテラルは、String: Stringの組みを２つ含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This distinction isn’t visible when the captured variable’s type has reference semantics.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この相違は、キャプチャされた変数の型が参照意味論を持つ場合には見られません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This doesn’t, however, cause the observer to be called again.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、しかし、このオブザーバーが再び呼び出されるようにしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This empty protocol indicates that a type can be used for error handling.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この空のプロトコルは、ある型がエラー処理のために使われることができるのを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This enables TrackedString to modify the numberOfEdits property internally, but to present the property as a read-only property when it’s used outside the structure’s definition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これがTrackedStringに可能にするのは、numberOfEditsプロパティを内部のように修正すること、しかしそのプロパティをそれが構造体の定義の外側で使われる時は読み出し専用プロパティとして提供することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This enables printMathResult(_:_:_:) to hand off some of its functionality to the caller of the function in a type-safe way.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、printMathResult(_:_:_:)にその機能性の一部をその関数の呼び出し手に、ある型安全な方法で、手渡すことを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This enables both properties to be accessed directly (without optional unwrapping) once initialization is complete, while still avoiding a reference cycle.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、一旦初期化が終了しているならば、両方のプロパティが直接にアクセスされるのを（オプショナルをアンラップすることなく）可能にします、その一方で、依然として参照循環を避けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This enables structures and enumerations to adopt the protocol and satisfy that method requirement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、構造体と列挙に、そのプロトコルを採用してメソッド要件を満たすのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This enables you to be notified when the value of an inherited property changes, regardless of how that property was originally implemented.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これはあなたに、そのプロパティが元々どのように実装されるかに関係なく、継承されたプロパティの値が変わるとき通知されることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This enables you to catch and fix errors as early as possible in the development process.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、あなたに開発過程においてエラーをできるだけ早く捕えて修復するのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This enables you to check for a successful downcast.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、あなたに成功したダウンキャストについて調べるのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This enables you to check for their existence within the closure’s body.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これはあなたに、クロージャの本文内でそれらの存在について調べることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This enables you to check whether or not an update took place.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これはあなたに、更新が起こったかどうか、確認することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This enables you to create protocols that can only be adopted within a certain access context.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、あなたに特定のアクセス文脈内で採用されることだけができるプロトコルを作成するのを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This enables you to define a subclass for which initialization can’t fail, even though initialization of the superclass is allowed to fail.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これはあなたに、それに対しての初期化が失敗することが出来ないサブクラスを定義することを可能にします、たとえスーパークラスの初期化が失敗することが許されるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This enables you to drill down into subproperties within complex models of interrelated types, and to check whether it’s possible to access properties, methods, and subscripts on those subproperties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これはあなたに、相互に関係づけられた型である複雑なモデルの内部の下位情報に掘り下げていくこと、そしてそれらの下位情報上でプロパティ、メソッド、そして添え字にアクセスすることが可能であるかどうか確認することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This enables you to extend other types to accept your own custom types as initializer parameters, or to provide additional initialization options that were not included as part of the type’s original implementation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、あなたに別の型を拡張してあなた独自のあつらえの型をイニシャライザパラメータとして受け入れるようにすること、またはその型の最初の実装の一部として含まれなかった追加の初期化選択肢を提供することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This enables you to leave some aspects of a function’s implementation for the function’s caller to provide when the function is called.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これはあなたに、ある関数の実装のいくつかの側面をその関数の呼び出し側のために、その関数が呼ばれるとき提供する目的で、取っておくことを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This enables you to see whether instances of Person and Apartment are being deallocated as expected.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、あなたに期待されるようにPersonとApartmentのインスタンスが割り当て解除されているかどうか知ることを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This enables you to use an if statement to check whether it was possible to call the printNumberOfRooms() method, even though the method doesn’t itself define a return value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これはあなたにif文をprintNumberOfRooms()メソッドを呼び出すことが可能か調べるために使うことを可能にします、たとえそのメソッドがそれ自身では戻り値を定義しないとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This encoding for negative numbers is known as a two’s complement representation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この負数のための符号化は、２の補数表現として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This ensures that a CreditCard instance always has a customer instance associated with it when the CreditCard instance is created.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、CreditCardインスタンスがつくられるとき、CreditCardインスタンスが常にそれと結びつけられるCustomerインスタンスを持つことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This ensures that all of the protocol’s requirements will be visible on any type that adopts the protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、プロトコルを採用するあらゆる型上で、プロトコルのもつ要件の全てが見えることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This ensures that class instances don’t take up space in memory when they’re no longer needed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、クラスインスタンスが、それらがもはや必要でない時に、メモリ上で場所を取らないことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This ensures that the numberOfWheels inherited property is initialized by Vehicle before Bicycle has the opportunity to modify the property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは継承されたプロパティnumberOfWheelsが、Bicycleがそのプロパティを変更する機会を得る前に、Vehicleによってイニシャライズされることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This ensures that the indices in the sequence are the same type as the indices used for a container.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、このシーケンスのインデックスがコンテナに対して使われるインデックスと同じ型であるのを保証することになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This ensures that, no matter which part of the compound case matched, the code in the body of the case can always access a value for the bindings and that the value always has the same type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、たとえ複合ケース節のどの部分がマッチしたとしても、ケース節の本文のコードが常に束縛のための値にアクセスできること、そしてその値が常に同じ型を持つことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This enumeration can store three kinds of arithmetic expressions: a plain number, the addition of two expressions, and the multiplication of two expressions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この列挙は、３種類の算術式：普通の数字、２つの式の加算、そして２つの式の乗算を格納することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This enumeration toggles between two states, indicated by the enumeration cases on and off.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この列挙は、列挙のケース節onとoffで示される、２つの状態の間で切替えをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This enumeration, called Kind, expresses the kind of number that a particular integer represents.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この列挙は、Kindと呼ばれ、特定の整数を表わす数の種類を表わします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This exactly matches the method type needed by the sorted(by:) method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、sorted(by:)メソッドによって必要とされるメソッド型に正確に適合します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example adds a new nested enumeration to Int.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、新しい入れ子にされた列挙をIntに加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example adds an average() method to Container when the items are integers, and it adds an endsWith(_:) method when the items are equatable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、average()メソッドをContainerへとその項目が整数である場合は加えます、そしてそれはendsWith(_:)メソッドを項目が同等評価可能である場合は加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example adds an average() method to containers whose Item type is Double.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、average()メソッドを、Item型がDoubleであるコンテナに追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example adds an integer subscript to Swift’s built-in Int type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、整数添え字をスウィフトの組み込みのInt型に加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example adds five computed instance properties to Swift’s built-in Double type, to provide basic support for working with distance units:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、５つの計算インスタンスプロパティをスウィフトの組み込みのDouble型に加えて、距離単位を扱うための基本的な支持を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example adds together the vectors (3.0, 1.0) and (2.0, 4.0) to make the vector (5.0, 5.0), as illustrated below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、下で図示されるように、ベクトル(3.0, 1.0)と(2.0, 4.0)を加えて一緒にして、ベクトル(5.0, 5.0)を作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example also adds a new computed instance property to Int, called kind, which returns the appropriate Kind enumeration case for that integer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例はまた、新しい計算インスタンスプロパティをIntに加えます、それは、kindと呼ばれ、その整数に対する適切なKind列挙ケース節を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example also demonstrates a challenge you may encounter when fixing conflicting access to memory: There are sometimes multiple ways to fix the conflict that produce different answers, and it’s not always obvious which answer is correct.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例はまた、メモリアクセスの衝突を直す場合にあなたが直面するある困難を実演します；時として複数の方法が衝突を修正するために存在してそれらは異なる答えを生み出します、そしてどの答えが正しいか必ずしも明確ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example also shows how reference types can be harder to reason about.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例はまた、どれくらい参照型について思考するのが困難になりうるかを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example checks numberSymbol to determine whether it’s a Latin, Arabic, Chinese, or Thai symbol for the numbers 1 to 4.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、numberSymbolを、それが1から4のラテン、アラビア語、中国語、またはタイ語であるかどうか明らかにするために調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example considers two Bool values and only allows access if both values are true:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、２つのBool値を考慮して、両方の値がtrueの場合にのみアクセスを許します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example creates a new variable called productBarcode and assigns it a value of Barcode.upc with an associated tuple value of (8, 85909, 51226, 3).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、productBarcodeと呼ばれる新しい変数をつくって、それにあるひとつのBarcode.upcの値を関連したタプル値(8, 85909, 51226, 3)とともに代入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example creates an array of TextRepresentable things:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、TextRepresentableなものの配列をつくります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example creates an empty dictionary of type [Int: String] to store human-readable names of integer values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、型[Int: String]の空の辞書を、整数値の人間の読み込み可能な名前を格納するために作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example declares a constant called hd and sets it to a Resolution instance initialized with the width and height of full HD video (1920 pixels wide by 1080 pixels high).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、hdと呼ばれる定数を宣言して、それをフルHDビデオの幅と高さ（1920ピクセル幅の広さで1080ピクセルの高さ）で初期化されるResolutionインスタンスに対して設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example declares a new String variable called description and assigns it an initial value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、descriptionと呼ばれる新しいString変数を宣言して、それに最初の値を代入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example declares a new constant called tenEighty and sets it to refer to a new instance of the VideoMode class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、tenEightyと呼ばれる新しい定数を宣言して、それをVideoModeクラスの新しいインスタンスに言及するように設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example defines a class called ShoppingListItem, which encapsulates the name, quantity, and purchase state of an item in a shopping list:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例はShoppingListItemと呼ばれるクラスを定義します、それは、ある購入品目リストにおける名前、量、そしてある項目の購入状態といったものをカプセル化します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example defines a class called HTMLElement, which provides a simple model for an individual element within an HTML document:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例はHTMLElementと呼ばれるクラスを定義します、それは、HTML文書内個々の要素に対する単純なモデルを用意します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example defines a function called printMathResult(_:_:_:), which has three parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例はprintMathResult(_:_:_:)と呼ばれる関数を定義します、それは３つのパラメータを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example defines a hierarchy of three classes called Food, RecipeIngredient, and ShoppingListItem, and demonstrates how their initializers interact.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、Food、RecipeIngredient、そしてShoppingListItemと呼ばれる３つのクラスの階層を定義して、それらのイニシャライザが相互に作用する方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example defines a new class called Dice, which represents an n-sided dice for use in a board game.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例はDiceと呼ばれる新しいクラスを定義します、それは、ボードゲームで使うのためにn面のさいころを表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example defines a new protocol, PrettyTextRepresentable, which inherits from TextRepresentable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、ある新しいプロトコル、PrettyTextRepresentableを定義します、それは、TextRepresentableから継承を受けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example defines a new structure called Cuboid, which represents a 3D rectangular box with width, height, and depth properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例はCuboidと呼ばれる新しい構造体を定義します、それは、width、height、そしてdepthプロパティで3D矩形の箱を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example defines a protocol called HasArea, with a single property requirement of a gettable Double property called area:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、areaと呼ばれる取得可能なDoubleプロパティである１つだけのプロパティ要件をもつ、HasAreaと呼ばれるプロトコルを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example defines a structure called Person, which represents a specific named person.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、Personと呼ばれる構造体を定義します、それは、特定の名前の人物を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example defines an enumeration for a three-state switch.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、３つの状態を切り替えるために、ある列挙を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example defines another subclass of Vehicle, called Hoverboard.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、もう１つVehicleのサブクラスを定義します、それはHoverboardと呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example defines three structures for working with geometric shapes:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、幾何学形を扱うために３つの構造体を定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example defines two classes called DataImporter and DataManager, neither of which is shown in full:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、DataImporterとDataManagerと呼ばれる２つのクラスを定義します、そのどちらも全部は示されません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example defines two classes called Person and Apartment, which model a block of apartments and its residents:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例はPersonとApartmentと呼ばれる２つのクラスを定義します、それは、アパートの１区画とその居住者をモデル化します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example defines two new types, Bank and Player, for a simple game.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、２つの新しい型BankとPlayerを、単純なゲームのために定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example defines two simple mathematical functions called addTwoInts and multiplyTwoInts.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、addTwoIntsとmultiplyTwoIntsと呼ばれる２つの単純な数学的な関数を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example highlights the way that an opaque return type is like the reverse of a generic type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、不透明型が総称体型のまるで逆であるやり方に光を当てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example identifies Uranus from its raw value of 7:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、その生の値の7からUranus（天王星）を特定します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example initializes a UInt8 integer with the binary value 00001111, which has its first four bits set to 0, and its second four bits set to 1.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、UInt8整数を２進数の値00001111で初期化します、それは、その最初の４つのビットを0に設定して、次の４つのビットを1に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example is sorting an array of String values, and so the sorting closure needs to be a function of type (String, String) -&gt; Bool.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例はString値の配列を分類しています、なのでソート・クロージャは型(String, String) -&gt; Boolの関数である必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example iterates through all items in the library array.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、library配列の中の全ての項目の端が端まで繰り返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example plays a simple game of Snakes and Ladders (also known as Chutes and Ladders):</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、単純なゲームの「ヘビとはしご」（また、「荷すべらしとはしご」として知られます）で遊びます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example prints the first few entries in a five-times table:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、九九の５の段の表の最初のいくつかの項を出力します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example provides a type annotation for a variable called welcomeMessage, to indicate that the variable can store String values:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、welcomeMessageと呼ばれる変数に対して、その変数はString値を格納できることを示すために型注釈を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example sets a constant called incrementByTen to refer to an incrementer function that adds 10 to its runningTotal variable each time it’s called.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、incrementByTenと呼ばれる定数を、それが呼ばれるたびに10をそのrunningTotal変数に加えるあるインクリメンタ関数に言及するように設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example starts with a simple class called Person, which defines a stored constant property called name:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、Personと呼ばれる単純なクラスから始めます、それは、nameと呼ばれる格納定数プロパティを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example uses a UInt32 constant called pink to store a Cascading Style Sheets color value for the color pink.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、ピンク色のカスケーディング・スタイル・シートの色値を保存するために、pinkと呼ばれるUInt32定数を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example uses a for-in loop to iterate over the items in an array:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、for-inループを使って、ある配列の中の項目すべてにわたって繰り返していきます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example uses a switch statement to consider a single lowercase character called someCharacter:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例はswitch文を１つの小文字の文字、someCharacterと呼ばれるものについて考察するために使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example uses a subscript in a key path to access the second element of an array:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、キーパス式において添え字を使って、配列の２番目の要素にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example uses multiple &amp;&amp; and || operators to create a longer compound expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、より長く複雑な式をつくるために複数の&amp;&amp;と||演算子を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example uses number intervals to provide a natural-language count for numbers of any size:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、自然言語の数え方をどんな大きさの数にも用意するために、数の区間を使います：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example uses optional binding to try to access a planet with a raw value of 11.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例は、11の生の値で惑星にアクセスすることを試みるためにオプショナル束縛を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This example’s willSet observer uses a custom parameter name of newTotalSteps for the upcoming new value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例のwillSetオブザーバーは、来るべき新しい値のためにあつらえのパラメータ名newTotalStepsを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This exception ensures that an older compiler doesn’t attempt to parse syntax introduced in a newer version of Swift.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この例外は、古いコンパイラがより新しいバージョンのスウィフトで導入される構文の解析を試みないことを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This expression calculates the value of Double(multiplier) * 2.5 and inserts the result (7.5) into the string.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この式は、Double(multiplier) * 2.5の値を計算して、結果（7.5）を文字列に差し込みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This expression is evaluated the first time you read the property’s value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この式は、あなたがプロパティのもつ値を読み出す最初の時に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This extension adopts the new protocol in exactly the same way as if Dice had provided it in its original implementation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この拡張は、まるでDiceがその最初の実装においてそれを提供したかのように、正確に同じふうに新しいプロトコルを採用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This extension states that it adopts the PrettyTextRepresentable protocol and provides an implementation of the prettyTextualDescription property for the SnakesAndLadders type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この拡張が述べるのは、それがPrettyTextRepresentableプロトコルを採用してprettyTextualDescriptionプロパティの実装をSnakesAndLadders型に提供することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This extension to the Container protocol adds a subscript that takes a sequence of indices and returns an array containing the items at each given index.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このContainerプロトコルに対する拡張は、ある添え字を追加します、それはインデックスのシーケンスをとって、与えられたインデックスそれぞれでの項目を含んでいる配列を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This failure might be triggered by invalid initialization parameter values, the absence of a required external resource, or some other condition that prevents initialization from succeeding.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この失敗は、無効な初期化パラメータ、必須の外部リソースの欠如、または初期化がうまくいくのを妨げる何か他の状況によって引き起こされるかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This feature enables you to hide the implementation details of your code, and to specify a preferred interface through which that code can be accessed and used.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この特徴によってあなたは、あなたのコードの実施詳細を隠すこと、そしてそれを通してそのコードがアクセスされ使用されることができる好ましいインタフェースを指定することが可能になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This feature is represented by a structure called Values, which is nested within the Rank enumeration:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この特徴はValuesと呼ばれる構造体で表されます、それは、Rank列挙の内部で入れ子にされます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This feature prevents the assignment operator (=) from being used by accident when the equal to operator (==) is actually intended.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この特徴は、実際には同等演算子（==）が意図されるときに、偶然に代入演算子（=）が使われるのを防止します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This form of the operator will always return an optional value, and the value will be nil if the downcast was not possible.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>演算子のこの形式は、常にオプショナルの値を返します、そしてダウンキャストが可能でなかったならばその値はnilです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This form of the operator will trigger a runtime error if you try to downcast to an incorrect class type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>演算子のこの形式は、あなたが適切でないクラス型へのダウンキャストをためすならば、実行時エラーを引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This function doesn’t compile as written above.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この関数は、上記のように書かれるとしてもコンパイルしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This function evaluates a plain number by simply returning the associated value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この関数は、普通の数字を単に関連値を返すことによって評価します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This function makes use of in-out parameters to swap the values of a and b, as described in In-Out Parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この関数は、値aとbを交換するためにin-outパラメータの利用を行います、In-Outパラメータで記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This function simply adds amount to runningTotal, and returns the result.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この関数は、単にamountをrunningTotalに加えて、結果を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This function takes a person’s name and whether they have already been greeted as input, and returns an appropriate greeting for that person:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この関数は、人物の名前と彼らがすでに挨拶されたかどうかを入力として取って、ふさわしい挨拶をその人物に対して返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This function takes two arguments called someContainer and anotherContainer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この関数は、someContainerとanotherContainerと呼ばれる２つの引数をとります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This function, printIntegerKinds(_:), takes an input array of Int values and iterates over those values in turn.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この関数、printIntegerKinds(_:)は、Int値の配列の入力を取り、それらの値に最初から終わりまで順番に繰り返していきます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This functionality is provided by the DataImporter class, which is assumed to take a nontrivial amount of time to initialize.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この機能性はDataImporterクラスによって提供されます、それは、初期化するために瑣末でない量の時間がかかると仮定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This future type can be referred to as Element anywhere within the structure’s definition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この将来の型は、構造体の定義の範囲内のどこででも「Element」として参照されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This future warning informs you that the library author added a new case to the enumeration that doesn’t have a corresponding switch case.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この未来警告は、対応するスイッチケース節を持たない列挙にライブラリ作者がある新しいケース節を加えたことをあなたに告知します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This generic subscript is constrained as follows:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この総称体添え字は、以下のように制約されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This gives a reverse alphabetical sort, with "Barry" being placed before "Alex", and so on.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、"Barry"が"Alex"の前に置かれるなどの、逆アルファベット順の分類を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This greeting is then passed back out of the function using the return keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この挨拶は、それからreturnキーワードを使用して逆に関数の外に渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This guarantee is known as actor isolation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この保証は、アクター隔離（アクターアイソレーション）として知られます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This helps you remember that it’s possible to capture self by accident.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、偶然にselfを捕らえることは可能であるのをあなたが忘れないことを手助けします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This illustrates that the overall call to the sorted(by:) method has remained the same.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、sorted(by:)メソッドへの呼び出し全体が、同じもののままだったことを図解します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This implementation of HTMLElement is identical to the previous implementation, apart from the addition of a capture list within the asHTML closure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>HTMLElementのこの実装は、asHTMLクロージャ内の捕獲リストの追加は別として、前の実装と同一です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This implementation uses two triangles and a square, but the function could be rewritten to draw a trapezoid in a variety of other ways without changing its return type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この実装は、２つの三角形とある四角形を使います、しかし関数は、台形をさまざまな他の方法で描画するよう書き直されることがそれの戻り型を変更することなしにできました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This implicit return syntax is considered only when the expression’s type and the function’s return type aren’t Void and aren’t an enumeration like Never that doesn’t have any cases.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この暗黙的な戻り構文は、式のもつ型と関数のもつ戻り型がVoidでないそして何らケース節を持たないNeverのような列挙ではない場合にのみ考慮されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This includes String, as shown here, as well as collection types such as Array, Dictionary, and Set.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、ここで示すようにStringを、それだけでなくArray、Dictionary、そしてSetといったコレクション型も含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This includes String, as shown here, as well as collection types such as Array, Dictionary, and Set.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、ここで示すようにStringを、それだけでなくArray、Dictionary、そしてSetといったコレクション型も含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This includes a protocol with an associated type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、関連型を使うプロトコルを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This includes the ability to extend types for which you don’t have access to the original source code (known as retroactive modeling).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、あなたが元々のソース・コードにアクセスをしないで型を拡張する能力を含みます（遡及モデリングとして知られます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This initializer can be used to create a new Food instance with a specific name:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このイニシャライザが、ある特定の名前を使って新しいFoodインスタンスをつくるために使われることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This initializer checks if the species value passed to the initializer is an empty string.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このイニシャライザは、イニシャライザに渡されるspecies値が空の文字列かどうか検査します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This initializer has a parameter called generator, which is also of type RandomNumberGenerator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このイニシャライザは、generatorと呼ばれるパラメータを持ちます、それもまた、型RandomNumberGeneratorです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This initializer has an empty body, represented by an empty pair of curly braces {}.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このイニシャライザは、一対の空の波括弧{}によって表される空の本文を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This initializer is described in more detail in Creating an Array with a Default Value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このイニシャライザは、更に詳細に配列を１つの初期値で作成するで記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This initializer is therefore inherited by RecipeIngredient.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このイニシャライザは、したがって、RecipeIngredientによって継承されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This initializer simply assigns the origin and size argument values to the appropriate stored properties:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このイニシャライザは、単に引数値originとsizeを適切な格納プロパティに代入します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This initializer starts by assigning the passed quantity argument to the quantity property, which is the only new property introduced by RecipeIngredient.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このイニシャライザは、渡されたquantity引数をquantityプロパティに代入することによって始めます、それは、RecipeIngredientによって導入される唯一の新しいプロパティです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is a constant value of 10 for all AudioChannel instances.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、定数値で、全てのAudioChannelインスタンスのために10です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is a stored property with willSet and didSet observers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、willSetとdidSetオブザーバーを持つ格納プロパティです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is also a comment</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（これもコメントです）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is also called yielding the thread because, behind the scenes, Swift suspends the execution of your code on the current thread and runs some other code on that thread instead.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これはまた、スレッドの譲渡とも呼ばれます、なぜなら、シーンそれらの背後で、スウィフトはあなたのコードの遂行を現在のスレッド上で中断して、何らかの他のコードをそのスレッド上で代わりに実行するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is because functions and closures are reference types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、関数とクロージャが参照型であるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is because of the copy-in copy-out memory model for in-out parameters: The value is always written back to the property at the end of the function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、in-outパラメータのための「コピーイン、コピーアウト」メモリーモデルが理由です：値は常に、その関数の終わりでプロパティへと書き込まれて戻されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is because the type itself doesn’t have an initializer that can assign a value to a stored type property at initialization time.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、型それ自身には初期化時に値を格納型プロパティに代入することができるイニシャライザがないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is called a chained implicit member expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、連鎖暗黙的メンバー式と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is equivalent to a decimal value of 15.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、10進の値の15に等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is in contrast to ordinary, synchronous functions and methods, which either run to completion, throw an error, or never return.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、普通の同期関数およびメソッドとは対照的です、それは完了するまで実行する、エラーをスローする、または決して復帰しないのどれかです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is indicated by passing a value of 3 to the structure’s initializer as the value to use for the instance’s multiplier parameter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、値3をこの構造体のinitializerにインスタンスのmultiplierパラメータのために使う値として渡すことによって示されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is indicated by setting the optional playerOne variable to nil, meaning “no Player instance.” At the point that this happens, the playerOne variable’s reference to the Player instance is broken.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これはオプショナルのplayerOne変数に、「Playerインスタンスがない」ことを意味する、nilを設定することによって示されます。これが起こる時点で、playerOne変数のもつPlayerインスタンスへの参照は壊れています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is known as closing over those constants and variables.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、そのような定数や変数をすっかりクローズする（閉じ込める）こととして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is known as overloading the existing operators.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>既存の演算子のオーバーロードとしてこれは知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is known as overriding.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、オーバーライドとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is known as short-circuit evaluation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは短絡評価として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is known as short-circuit evaluation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは短絡評価として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is known as a strong reference cycle.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、強い参照循環として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is like writing try when calling a throwing function, to mark the possible change to the program’s flow if there’s an error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、エラーがある場合のプログラムの流れに対する可能な変更を印するために、tryをスロー関数の呼び出しの時に書くことに似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is necessary in order for it to be able to access the director or artist property of a Movie or Song for use in the description.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、それがその説明で使う目的でMovieまたはSongのもつdirectorまたはartistプロパティにアクセス可能になるために必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is often done by assigning a literal value (or literal) to the constant or variable at the point that you declare it.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、リテラル値（またはリテラル）を定数または変数に、あなたがそれを宣言する時点で代入することによって、しばしば行われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is particularly true when you work with functions or methods that take functions as one or more of their arguments.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>１つ以上のそれの引数として関数をとる関数またはメソッドをあなたが扱うとき、これは特に当てはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is represented by the player’s coinsInPurse property:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、プレーヤーのcoinsInPurseプロパティによって表されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is simply an empty tuple, which is written as ().</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは単に空のタプルです、それは()のように書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is the end of the first multiline comment.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（最初の複数行コメントの終わり。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is the same as 0xCC, which has a decimal value of 204.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは0xCCと同じものです、それは、10進の値の204を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is the second, nested multiline comment.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（第二の入れ子の複数行コメント。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is the standard calling convention for function values in Swift.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、スウィフトにおける関数値のための標準的な呼出規約です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is the start of the first multiline comment.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（最初の複数行コメントの始まり。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is true even for constant stored properties, as described in Assigning Constant Properties During Initialization.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>初期化の間に定数プロパティを割り当てるで記述されるように、これは定数格納プロパティにさえあてはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is true even if the new value is the same as the current value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、たとえ新しい値が現在の値と同じものであるとしても当てはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is true even if you are overriding an automatically provided default initializer, as described in Default Initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、省略時のイニシャライザで記述されるように、あなたが自動的に提供される省略時のイニシャライザをオーバーライドしている場合にさえもあてはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is true even though increment(forCount:) is defined as returning a non-optional Int value in the definition of CounterDataSource.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>たとえincrement(forCount:)がCounterDataSourceの定義の中で非オプショナルのInt値を返すように定義されるとしても、これは当てはまります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is true even though type method requirements are prefixed with the class or static keyword when implemented by a class:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>たとえ型メソッド要件がクラスによって実装されるときclassまたはstaticキーワードを前に置かれるとしても、これは当てはまります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is very similar to placing an exclamation point (!) after an optional value to force the unwrapping of its value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、その値を強制アンラップするためにオプショナルの値の後に感嘆符（!）を置くことに非常に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is why increment(forCount:) is also written with a question mark after its name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これが、increment(forCount:)もまたその名前の後に疑問符を書かれる理由です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is why the m computed property returns self—the expression 1.m is considered to calculate a Double value of 1.0.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これがm計算プロパティがselfを返す理由です ― 式1.mは、1.0のDouble値を計算するものと考えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This keeps track of the maximum input value that has been received by any AudioChannel instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、あらゆるAudioChannelインスタンスによって受け取られた最大入力値の情報を得続けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This key-value type matches the type of the airports variable declaration (a dictionary with only String keys, and only String values), and so the assignment of the dictionary literal is permitted as a way to initialize the airports dictionary with two initial items.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この「キーと値」型は、airports変数の宣言の型（Stringのキーのみ、そしてStringの値のみをもつ辞書）に合致します、なのでこの辞書リテラルを代入することは、２つの最初の項目でairports辞書を初期化する方法として許されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This keyword indicates that the definition of the closure’s parameters and return type has finished, and the body of the closure is about to begin.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このキーワードはクロージャのパラメータと戻り型の定義が終わったことを示します、そして、クロージャの本文はまさに開始しようとしています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This kind of function call expression has the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この種類の関数呼び出し式は、以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This kind of function is known as a nested function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この種類の関数は、入れ子にされた関数として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This kind of range is called a one-sided range because the operator has a value on only one side.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この種類の範囲は、片側範囲と呼ばれます、なぜならこの演算子は一方の側でのみ値を持つからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This kind of subscript is called a type subscript.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この種の添え字は、型添え字と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This lets you call the throwing function inside a do-catch statement and handle errors in the catch clause by throwing a different error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、あなたにスロー関数をdo-catch文の内部で呼び出させ、そのcatch節において異なるエラーをスローすることによって、エラーを取り扱わせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This list is transformed into a tree by applying operator precedence.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このリストは、演算子優先順位を適用することによって、ツリー（木構造）に変えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This makes for highly readable code when working with explicitly typed enumeration values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、明示的に型指定された列挙値を扱う場合に、非常に可読性の高いコードにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This makes it easy to create custom string values for display, storage, and printing.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、表示、保存、そして出力するために個々の注文に応じた文字列値をつくることを簡単にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This makes the switch statement safer and easier to use than the one in C and avoids executing more than one switch case by mistake.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、switch文をCのものよりも安全で使いやすくして、誤って複数のswitchケース節を実行することを防ぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This matches the single requirement of the FullyNamed protocol, and means that Person has correctly conformed to the protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、FullyNamedプロトコルの唯一の要件に適合します、したがってそのPersonが正しくそのプロトコルに従ったことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This matches the type of the shoppingList variable’s declaration (an array that can only contain String values), and so the assignment of the array literal is permitted as a way to initialize shoppingList with two initial items.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これはshoppingList変数の宣言（String値を含むことだけができる配列）の型に合致します、それでこの配列リテラルの代入は、２つの最初の項目でshoppingListを初期化するためのやり方として認められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means code between potential suspension points can safely update state that requires temporarily breaking invariants, provided that it completes the update before the next potential suspension point.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これが意味するのは、潜在的中断地点の間のコードは、安全に状態を更新可能であるということです、それがその更新を次の潜在的中断地点の前に完了するという条件で。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means code like protoFlip(protoFlip(smallTriange)) that applies multiple transformations is invalid because the flipped shape isn’t a valid argument to protoFlip(_:).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、複数の変換を適用するprotoFlip(protoFlip(smallTriange))のようなコードが無効であることを意味します、なぜなら裏返された形状はprotoFlip(_:)への有効な引数ではないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means it’s possible to have precedence groups with undefined relative precedence.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これが意味するのは、未定義の関係優先順位による優先順位グループを持つことは可能だということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means that 4.75 becomes 4, and -3.9 becomes -3.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、4.75が4に、そして-3.9が-3になることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means that SomeInternalClass and someInternalConstant can be written without an explicit access-level modifier, and will still have an access level of internal:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、SomeInternalClassとsomeInternalConstantが明示的なアクセス水準修飾子なしで書かれることができ、それでもまだ内部のアクセス水準を持つことを意味します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means that a % b and a % -b always give the same answer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、a % bとa % -bが常に同じ答えを与えることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means that a defer statement can be used, for example, to perform manual resource management such as closing file descriptors, and to perform actions that need to happen even if an error is thrown.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これはdefer文が、例えば、ファイル記述子を閉じることなどの手動リソース管理を実行するために、そしてたとえエラーがスローされるとしても起こることが必要な動作を実行するために使われることができるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means that a change to the value of a in the outer scope doesn’t affect the value of a in the inner scope, nor does a change to a inside the closure affect the value of a outside the closure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これが意味するのは、外側のスコープのaの値に対する変更は内側のスコープのaの値に影響を及ぼさない、そしてまたクロージャ内部のaに対する変更はクロージャ外部のaに影響を及ぼさないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means that a function can return another function as its value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、ある関数が別の関数をその値として返すことができるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means that all of the information needed to infer an omitted type or part of a type in an expression must be accessible from type-checking the expression or one of its subexpressions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、ある式における省略される型や型の一部分を推論するために必要とされる情報のすべては、型を調べているその式またはそれの下位式の１つからアクセス可能でなければならないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means that any structure and enumeration instances you create—and any value types they have as properties—are always copied when they’re passed around in your code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、あなたがつくるあらゆる構造体や列挙のインスタンス ― そして、それらがプロパティとして持つあらゆる値型 ― は、あなたのコードの中であちこち渡される時に常にコピーされることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means that classes have additional responsibilities for ensuring that all stored properties they inherit are assigned a suitable value during initialization.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、クラスが、それが継承する全ての格納プロパティが初期化の間に適切な値を代入されることを確実にすることに対する追加の責任を持つことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means that code that would otherwise run immediately after the call is never executed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これが意味するのは、そうでなければ呼び出しの直後に動作するコードは、決して実行されないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means that different characters—and different representations of the same character—can require different amounts of memory to store.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは異なる文字—さらに同じ文字の異なる表現—が、格納するために異なる量のメモリを必要とすることがあるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means that in the example above, array3D[0] refers to [[1, 2], [3, 4]], array3D[0][1] refers to [3, 4], and array3D[0][1][1] refers to the value 4.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、上の例で、array3D[0]は[[1, 2], [3, 4]]に言及し、array3D[0][1]は[3, 4]に言及し、そしてarray3D[0][1][1]は値４に言及することを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means that it returns a function, rather than a simple value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、それが関数を返すことを意味します、単純なひとつの値ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means that the Country initializer can start to reference and pass around the implicit self property as soon as the name property is set.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これはCountryイニシャライザが、nameプロパティが設定されるとすぐに、暗黙のselfプロパティに基づいて参照したり渡したりを可能であるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means that the capitalCity property has a default value of nil, like any other optional, but can be accessed without the need to unwrap its value as described in Implicitly Unwrapped Optionals.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、capitalCityプロパティが、オプショナルの他のものの様に、nilの省略時の値を持つが、アンラップする必要なしでその値にアクセスされることができることを意味します、暗黙的にアンラップされるオプショナルで記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means that the (String, String) and Bool types don’t need to be written as part of the closure expression’s definition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、(String, String)およびBool型が、クロージャ式の定義の一部として書かれる必要がないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means that the letter "B" is “greater than” the letter "A", and the string "Tom" is greater than the string "Tim".</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは文字"B"は文字"A"「より大きい」こと、そして文字列"Tom"は文字列"Tim"よりも大きいことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means that the value is allowed to outlive the lifetime of the call.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、その値が呼び出しのライフタイムより長生きするのを許されることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means that they return a value of (), or an empty tuple.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、それらが値()、または空のタプルを返すことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means that when you break the strong reference held by the john variable by setting it to nil, there are no more strong references to the Person instance:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、あなたがjohn変数によって保持される強い参照を、それをnilに設定することによって壊すとき、Personインスタンスへの強い参照がもうそれ以上ないことを意味します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means that you can change (or mutate) the collection after it’s created by adding, removing, or changing items in the collection.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、あなたがコレクションを変更する（または変化させる）ことが、それが作成された後にそのコレクション中の項目を追加、削除、または変更することによって可能なのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means that you can extend Array to conform to the Container protocol simply by declaring that Array adopts the protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、あなたがArrayを拡張してContainerプロトコルに準拠することが、Arrayがそのプロトコルを採用すると宣言することによって可能であることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means that you can use self to disambiguate between type properties and type method parameters, just as you do for instance properties and instance method parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これはあなたが型プロパティと型メソッドパラメータの間で曖昧さをなくすためにselfを使うことができることを意味します、ちょうどあなたがインスタンスプロパティとインスタンスメソッドパラメータでするように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means that you can’t access any other property values from within your closure, even if those properties have default values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、たとえそれらのプロパティには省略時の値があるとしても、あなたがあなたのクロージャ内から他のどのプロパティ値にもアクセスすることができないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means that you can’t accidentally access methods or properties that the class implements in addition to its protocol conformance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、クラスがそれのプロトコル準拠にさらに加えて実装するメソッドやプロパティにあなたが偶然にアクセスすることができないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means that you can’t change the value of a parameter by mistake.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、あなたが誤ってパラメータの値を変えることができないことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means that you can’t insert a value of the wrong type into a collection by mistake.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、あなたが間違った型の値を誤ってあるコレクションの中に入れることが不可能なことを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means there are two write accesses to playerInformation with durations that overlap, causing a conflict.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、２つの書き込みアクセスがplayerInformationに対してオーバーラップする期間に存在して、衝突を起こしていることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means you always get great performance when working with strings as value types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、値型として文字列を扱うとき、あなたは常に非常に大きいパフォーマンスを得ることを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means you can use as many assertions as you want during your development process, without impacting performance in production.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これが意味するのは、あなたは多くの表明をあなたが望むだけあなたの開発過程の間に使用できる、製品での性能に影響を与えることなしに、ということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means you can use constants to name a value that you determine once but use in many places.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、あなたが一度だけ決定するが多くの場所で使用する値に対して名前をつけるために定数を利用できるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means, if you have a large project that’s divided into multiple frameworks, you can migrate your code from Swift 4 to Swift 5.6 one framework at a time.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、あなたが複数のフレームワークへと分割される巨大なプロジェクトを持つならば、あなたはあなたのコードをSwift 4からSwift 5.6へと一度に１フレームワークずつ移行できるのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means, if you import Foundation, you can access those NSString methods on String without casting.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これが意味するのは、あなたがFoundationをインポートするならば、あなたはそれらNSStringメソッドにString上でキャストなしでアクセスできるという事です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This memory holds information about the type of the instance, together with the values of any stored properties associated with that instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このメモリは、インスタンスの型に関する情報を、そのインスタンスと結びつけられるあらゆる格納プロパティの値と共に持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This method also shows one of the reasons why actors allow only one task at a time to interact with their mutable state: Some updates to an actor’s state temporarily break invariants.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このメソッドはまた、なぜアクターそれらは一度にただ１つのタスクだけにそれらの可変状態との相互作用を許可するのかの理由の１つを示します：いくつかの更新をアクターのもつ状態に対してすることは一時的に不変式を壊します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This method calls the generator’s random() method to create a new random number between 0.0 and 1.0, and uses this random number to create a dice roll value within the correct range.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このメソッドは、0.0と1.0の間で新しい乱数をつくるgeneratorのrandom()メソッドを呼んで、この乱数を正しい範囲内でさいころを振った値をつくるために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This method checks the properties of the address and returns buildingName if it has a value, or buildingNumber concatenated with street if both have values, or nil otherwise.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このメソッドは、アドレスのプロパティを調べて、それが値を持つならばbuildingNameを、または両方とも値を持つならばbuildingNumberに繋げてstreetを、またはそれ以外ではnilを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This method does nothing, but waits at least the given number of nanoseconds before it returns.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このメソッドは何もしません、しかし少なくとも与えられたナノ秒数をそれが返る前に待ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This method doesn’t actually do anything for a base Vehicle instance, but will be customized by subclasses of Vehicle later on:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このメソッドは実際に何かを基盤Vehicleインスタンスのために行うわけではありません、しかし後でVehicleのサブクラスによって目的に合わせて作り変えられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This method doesn’t specify a return type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このメソッドは、戻り型を指定しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This method removes the item at the specified index and returns the removed item (although you can ignore the returned value if you don’t need it):</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このメソッドは、指定されたインデックスでの項目を取り除いて、取り除かれた項目を返します（けれども、あなたがそれを必要としないならば、返された値を無視することができます）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This method removes the key-value pair if it exists and returns the removed value, or returns nil if no value existed:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このメソッドは、それが存在するならば「キーと値」の対を削除して、削除された値を返します、または値が存在しないならばnilを返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This method returns a value of type String?.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このメソッドは、型String?の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This method unlocks the next level for all players and updates the player’s progress to move them to the next level.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このメソッドは、全てのプレーヤーたちのために次のレベルの錠をあけて、プレーヤーの進捗をかれらを次のレベルへ移動するために更新します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This might be a description of itself, or a text version of its current state:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、それ自身の説明、またはテキスト版のそれの現在の状態であるかもしれません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This might be because a DataImporter instance needs to open a file and read its contents into memory when the DataImporter instance is initialized.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、DataImporterインスタンスが初期化されるとき、DataImporterインスタンスがファイルを開いてメモリーにその内容を読む必要があるからでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This modification tracking is implemented with a didSet property observer on the value property, which increments numberOfEdits every time the value property is set to a new value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この修正追跡は、didSetプロパティオブザーバーとしてvalueプロパティ上で実行されます、それは、numberOfEditsをvalueプロパティが新しい値に設定されるたびに増加させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This new isTop(_:) method first checks that the stack isn’t empty, and then compares the given item against the stack’s topmost item.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この新しいisTop(_:)メソッドは、まずスタックが空でないことを確認します、それから与えられた項目をスタックの持つ最も上の項目と比較します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This new startsWith(_:) method can be used with any type that conforms to the Container protocol, including the stacks and arrays used above, as long as the container’s items are equatable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この新しいstartsWith(_:)メソッドはContainerプロトコルに準拠するあらゆる型で使われることができます、上で使われるスタックと配列を含めて、コンテナの持つ項目が同等評価可能である限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This new default can still be overridden within the extension for individual type members.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この新しい省略時設定はさらに、個々の型メンバーのために拡張内でオーバーライドされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This new initializer starts by calculating an appropriate origin point based on the provided center point and size value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この新しいイニシャライザは、提供されたcenter点とsize値に基づいて適切な起源点を計算することによって始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This next code snippet defines an optional Customer variable called john, which will be used to store a reference to a specific customer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>次のコード断片は、johnと呼ばれる、オプショナルのCustomer変数を定義します。それは、特定の顧客への参照を格納するために使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This next code snippet defines two variables of optional type called john and unit4A, which will be set to a specific Apartment and Person instance below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この次のコード断片はjohnとunit4Aと呼ばれるオプショナルの型の２つの変数を定義します、それは、特定のApartmentとPersonインスタンスに以降で設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This next example shows a class called DiceGameTracker, which adopts the DiceGameDelegate protocol:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この次の例はDiceGameTrackerと呼ばれるクラスを示します、それは、DiceGameDelegateプロトコルを採用します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This number is then shifted 16 places to the right (&gt;&gt; 16).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この数は、それから右に16桁シフトされます（&gt;&gt; 16）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This observer performs two checks:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このオブザーバーは、２つのチェックをします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This operator adds together the x values of two vectors, and subtracts the y value of the second vector from the first.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この演算子は、２つのベクトルのx値を一緒に加えて、第二のベクトルのy値を最初のものから減じます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This operator doesn’t have an existing meaning in Swift, and so it’s given its own custom meaning below in the specific context of working with Vector2D instances.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この演算子は、スウィフトにおいて既存の意味を持ちません、なので、それはVector2Dインスタンスを扱う特定の文脈の下で、独自のあつらえの意味を与えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This opt-in approach prevents hidden conversion errors and helps make type conversion intentions explicit in your code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このオプトインの（個々に決めていく）取り組み方は、隠された変換エラーを防いで、あなたのコードにおいて型変換の意図を明確にするのを助けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This optional binding is written “if let movie = item as? Movie”, which can be read as:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このオプショナル束縛は「if let movie = item as? Movie」のように書かれます、それは、次のように解釈されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This optional value contains the old value for that key if one existed before the update, or nil if no value existed:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このオプショナルの値は、それが更新の前に存在するならばそのキーに対する古い値を、値が存在しないならばnilを含みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This output value is then shifted eight places to the right, giving a value of 0x66, which has a decimal value of 102.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この出力値は、それから８桁右にシフトされて、0x66の値を与えます、それは10進の値の102を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This part of the book describes the formal grammar of the Swift programming language.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>本のこの部分は、スウィフトプログラミング言語の形式文法を記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This performance optimization means you don’t have to pay the performance cost of copying memory until you modify either the string or substring.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この性能最適化が意味するのは、あなたがメモリをコピーする性能経費を、あなたが文字列か下位文字列のどちらかを修正するまでは払う必要がないことです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This placeholder is replaced with the actual value of multiplier when the string interpolation is evaluated to create an actual string.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このプレースホルダーは、文字列補間が実際の文字列を作成するために評価されるとき、multiplierの実際の値と取り替えられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This procedure is known as switching on the value that’s being considered.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この手順は、考察されている値での切り替え（スイッチング）として知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This process continues until the end of the range is reached.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この過程は、範囲の終わりに達するまで続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This process involves setting an initial value for each stored property on that instance and performing any other setup or initialization that’s required before the new instance is ready for use.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この過程は、そのインスタンスの格納プロパティそれぞれに初期値を設定すること、および新しいインスタンスの使用準備が整う前に必要とされる他のあらゆる設定や初期化を行うことを含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This process is described in Resolving Strong Reference Cycles Between Class Instances.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この過程は、クラスインスタンス間の強い参照循環の解消で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This process is described in Modifying Value Types from Within Instance Methods.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この過程は、値型をインスタンスメソッド内から修正するで記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This process is described in Working with Characters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このやり方は文字を扱うで記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This process satisfies safety check 1 from Two-Phase Initialization above.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この過程は、上記の２段階初期化の安全点検１を満たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This process transforms it into the tree (2 + (3 * 5)).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この処理は、それをツリー(2 + (3 * 5))に変えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This process, known as initializer delegation, avoids duplicating code across multiple initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この処理、イニシャライザ委任として知られるものは、複数のイニシャライザにまたがってコードを繰り返し複製することを避けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This property is of type String.UTF16View, which is a collection of unsigned 16-bit (UInt16) values, one for each 16-bit code unit in the string’s UTF-16 representation:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このプロパティは型String.UTF16Viewです、そしてそれは、符号なし16ビット（UInt16）の値の集まりで、そのひとつがその文字列のUTF-16叙述における各16ビット符号単位です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This property is of type String.UTF8View, which is a collection of unsigned 8-bit (UInt8) values, one for each byte in the string’s UTF-8 representation:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このプロパティは型String.UTF8Viewです、そしてそれは、符号なし８ビット（UInt8）の値の集まりで、それぞれがその文字列のUTF-８叙述における各バイトです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This property is of type UnicodeScalarView, which is a collection of values of type UnicodeScalar.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このプロパティは型UnicodeScalarViewです、そしてそれは、UnicodeScalar型の値の集まりです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This property references a closure that combines name and text into an HTML string fragment.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このプロパティは、nameとtextをHTML文字列断片に結合するクロージャに参照をつけます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This protocol doesn’t specify how the items in the container should be stored or what type they’re allowed to be.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このプロトコルは、コンテナの中の項目が格納されなければならない方法やそれらが許される型が何であるかを指定しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This protocol, RandomNumberGenerator, requires any conforming type to have an instance method called random, which returns a Double value whenever it’s called.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このプロトコル、RandomNumberGeneratorは、あらゆる準拠型にrandomと呼ばれるインスタンスメソッドを持つことを要求します、それは、それが呼ばれた時はいつでもあるDouble値を返すものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This provides a syntactically convenient way to defer the evaluation of an expression without needing to write an explicit closure when you call the function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、あなたがその関数を呼び出す時に明示的なクロージャを書く必要なしに、ある式の評価を延期する統語的に便利な方法を提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This provision ensures that the switch statement is exhaustive.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この条項は、switch文が網羅的であることを確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This public-facing interface is the application programming interface (or API) for the framework.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この公開向けインタフェースは、フレームワークのためのアプリケーション・プログラミング・インタフェース（またはAPI）です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This pushes its binary representation just over the size that a UInt8 can hold, causing it to overflow beyond its bounds, as shown in the diagram below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、そのバイナリの表現をちょうどUInt8が持つことができる大きさ以上に押し広げて、それを、下の図で示すように、その境界を越えてあふれさせます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This relationship has the potential to create a strong reference cycle.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この関係は、強い参照循環をつくる可能性を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This requests the sixth entry in the three-times-table, which returns a value of 18, or 3 times 6.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは九九の３の段において６番目の部分を要請します、それは値18、つまり3掛ける6を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This requirement ensures that the public-facing API for a type is something you opt in to publishing, and avoids presenting the internal workings of a type as public API by mistake.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この要件は、ある型のための公開向けAPIがあなたが公開するように選ぶ何かであることを確実にして、ある型の内部の働きを誤って公開のAPIとして公表することを避けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This requirement is enforced by a type constraint on the key type for Dictionary, which specifies that the key type must conform to the Hashable protocol, a special protocol defined in the Swift standard library.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この要件は、Dictionaryのためのキー型に関する型制約によって強制されます、それは、キー型がスウィフト標準ライブラリで定義される特別なプロトコル、Hashableプロトコルに準拠しなければならないことを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This requirement is expressed through a combination of type constraints and a generic where clause:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この要件は、型制約と総称体where節の組合せによって表されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This restriction helps Swift perform more of its checks for conflicting access to memory at compile time instead of at runtime.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この規制は、スウィフトが実行時ではなくコンパイル時にメモリへのアクセスの衝突についてより多くのそれの検査を実行する助けとなります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This restriction is demonstrated in the example below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この制限は、下の例において実演されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This restriction protects the implementation details of the TrackedString edit-tracking functionality, while still providing convenient access to an aspect of that functionality.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この制限は、TrackedString編集追跡機能性の実装詳細を保護します、その一方でその機能性の一面への便利なアクセスを依然として提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This rule also applies to type aliases for associated types used to satisfy protocol conformances.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この規則はまた、プロトコル準拠を満たすために使われる関連型のための型エイリアスにも適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This rule applies to stored properties as well as computed properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この規則は、格納プロパティに、それだけでなく計算プロパティにも適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This rule pertains even though type property requirements can be prefixed with the class or static keyword when implemented by a class:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>たとえ型プロパティ要件がクラスによって実装されるときclassまたはstaticキーワードを前に置かれるとしても、この規則は当てはまります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This satisfies rules 2 and 3 from above.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、上記の規則２と３を満たします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This scenario is best resolved with a weak reference.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この筋書きは、弱い参照で最も良く解消されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This scenario is best resolved with an unowned reference.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この筋書きは、非所有参照で最も良く解消されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This section shows you how to set up such a relationship.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この節は、あなたにそのような関係を設定する方法を教えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This section shows you how to write a generic collection type called Stack.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この節は、あなたにStackと呼ばれる総称体コレクション型を書く方法を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This simplified syntax lets you omit an optional pattern.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この簡略化された構文は、あなたにあるオプショナルパターンを省略させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This sort of operator usually takes arguments of type Self, matching whatever concrete type adopts the protocol, but adding a Self requirement to the protocol doesn’t allow for the type erasure that happens when you use the protocol as a type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この種の演算子は通常は、どんな具象型がそのプロトコルを採用しても合う、型Selfの引数を取ります、しかしSelf要件をプロトコルに加えることは型消去を想定しません、それはあなたがプロトコルをひとつの型として使う場合に予期せず起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This square is represented by the light green square in the diagram below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この正方形は、下の図において明るい緑の正方形で表されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This statement consists of the defer keyword and the statements to be executed later.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この文は、deferキーワードと後で実行される文から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This statement lets you do any necessary cleanup that should be performed regardless of how execution leaves the current block of code—whether it leaves because an error was thrown or because of a statement such as return or break.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この文は、あなたに何らかの不可欠なクリーンアップを行わせます、それはどうやって実行が現在のコードブロックから離れるか ― それがエラーがスローされたためにまたはreturnまたはbreakのような文を理由に離れるかどうかに関係なく実行されるべきものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This strong reference cycle occurs because closures, like classes, are reference types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この強い参照循環は、クロージャが、クラスの様に参照型であるために起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This structure also has a read-only computed property called volume, which calculates and returns the current volume of the cuboid.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この構造体はまた、volumeと呼ばれる読み出し専用の計算プロパティを持ちます、それは、現在の立方体の体積を計算して、返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This structure encapsulates the fact that most cards have one value, but the Ace card has two values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この構造体は、大部分のカードが１つの値を持つという事実をカプセル化します、しかし「エース」カードは２つの値を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This structure has two stored properties called width and height.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この構造体は、２つの格納プロパティ、widthとheightと呼ばれるものを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This structure uses an Array property called items to store the values in the stack.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この構造体は、itemsと呼ばれるArrayプロパティを使って値をスタックに格納します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This subscript [n] returns the decimal digit n places in from the right of the number:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この添え字[n]は、右の数からの10進桁n位置を返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This subscript setting attempt also fails, because residence is currently nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この添え字設定の試みはまた失敗します、なぜならresidenceが現在nilだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This syntactic convenience lets you omit braces around a function’s parameter by writing a normal expression instead of an explicit closure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この統語上の便宜は、明示的なクロージャの代わりに通常の関数を書くことによって、あなたに関数のパラメータのまわりの波括弧を省略させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This syntax is the most general way to use a property wrapper.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この構文は、プロバティラッパーを使う最も一般的な方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This tag contains the optional text value if it exists, or no text content if text doesn’t exist.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このタグは、それが存在するならばオプショナルのtext値を、あるいはtextが存在しないならば、無いテキスト内容を含みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This tells Swift to execute the closure immediately.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、スウィフトにこのクロージャを直ちに実行するように言います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This tells Swift to “chain” on the optional residence property and to retrieve the value of numberOfRooms if residence exists.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これはスウィフトに、オプショナルのresidenceプロパティの上に「繋げて」、そしてresidenceが存在するならばnumberOfRoomsの値を取り出すように言います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This time around, the Apartment type’s tenant property is declared as a weak reference:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>今度は、Apartment型のtenantプロパティは、弱い参照として宣言されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This time around, the game has an extra rule:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このたびは、このゲームは特別な規則を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This time, however, the associated values are extracted as part of the switch statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>今度は、しかし、関連値がスイッチ文の一部として抽出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This time, the Residence class defines a variable property called rooms, which is initialized with an empty array of type [Room]:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>今度は、Residenceクラスはroomsと呼ばれる変数プロパティを定義します、それは、型[Room]の空の配列で初期化されます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This time, the capture of self by the closure is an unowned reference, and doesn’t keep a strong hold on the HTMLElement instance it has captured.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>今度は、クロージャによるselfの捕獲は非所有参照であって、それが捕獲しているHTMLElementインスタンスに対する強い支配力を保ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This time, the sign bit is 1 (meaning “negative”), and the seven value bits have a binary value of 124 (which is 128 - 4):</seg>
      </tuv>
      <tuv lang="ja">
        <seg>今度は、符号ビットは1です（「負」を意味します）、そして、７つの値ビットは２進数の値の124を持ちます（それは、128 - 4です）：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This time, the type parameter Element is used as the type of the append(_:) method’s item parameter and the return type of the subscript.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>今度は、型パラメータElementが、append(_:)メソッドのitemパラメータの型および添え字の戻り型として使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This tour gives you enough information to start writing code in Swift by showing you how to accomplish a variety of programming tasks.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このツアーはあなたにスウィフトでコードを書き始めるのに十分な情報を、どうやって様々なプログラミング作業を達成するかをあなたに示すことによって提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This transformation happens before the transformation into a call to buildEither(first:), buildEither(second:), or buildOptional(_:).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この変換は、buildEither(first:)、buildEither(second:)、またはbuildOptional(_:)への呼び出しへの変換の前に起こります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This transformation is always first.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この変換は、常に１番目です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This transformation is always last.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この変換は、常に最後です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This type parameter is written within a pair of angle brackets (&lt;Element&gt;) immediately after the structure’s name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この型パラメータは、構造体の名前の直後に一対の山形括弧の内部で（&lt;Element&gt;）書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This value is stored in a type property called highestUnlockedLevel.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この値は、highestUnlockedLevelと呼ばれる型プロパティに格納されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This variable has an initial value of nil, by virtue of being optional:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルであるおかげで、この変数はnilの初期値を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This variable is initialized with a value of 0.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この変数は、値0で初期化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This version is adapted to use a Dice instance for its dice-rolls; to adopt the DiceGame protocol; and to notify a DiceGameDelegate about its progress:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この版は改変され、それにより、それのさいころ振りにDiceインスタンスを使用します；DiceGameプロトコルを採用します；そして、その進歩についてDiceGameDelegateに通知します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This version of Residence also provides a method called printNumberOfRooms, which simply prints the number of rooms in the residence.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Residenceのこの版もprintNumberOfRoomsと呼ばれるメソッドを提供します、それは、単にその住居の部屋数を出力します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This version of protoFlip(_:) has the same body as flip(_:), and it always returns a value of the same type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このバージョンのprotoFlip(_:)は、flip(_:)と同じ本文を持ちます、そしてそれは常に同じ型の値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This version of the Shape class is missing something important: an initializer to set up the class when an instance is created.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Shapeクラスのこの版は、重要なあるもの：インスタンスが作られるときにクラスを設定準備するイニシャライザ（初期化子）、が欠けています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This version of the game is wrapped up as a class called SnakesAndLadders, which adopts the DiceGame protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ゲームのこの改作は、SnakesAndLaddersと呼ばれるクラスで包まれます、それは、DiceGameプロトコルを採用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This version of the game uses a while loop and a switch statement to implement the game’s logic.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ゲームのこの改変板は、このゲームの論理を実装するためにwhileループとswitch文を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This version of the mutating moveBy(x:y:) method creates a new structure whose x and y values are set to the target location.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>変更moveBy(x:y:)メソッドのこの改作は、それの持つxとyの値が目標場所に設定される、新しい構造体を作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This violates the requirement to return values of only one type and makes invalidFlip(_:) invalid code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これは、ただ１つの型だけの値を返すという要件に違反します、そしてinvalidFlip(_:)を無効なコードにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This wouldn’t be the case if you had written the initializer as part of the value type’s original implementation, as described in Initializer Delegation for Value Types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>値型のためのイニシャライザ委任で記述されるように、あなたがイニシャライザをその値型の最初の実装の一部として書いたならば、それはこの場合にはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Those roles are reversed for a function with an opaque return type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらの役割は、不透明戻り型をもつある関数に対しては逆にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Those two values are compared, and the result of that comparison determines the overall result of the tuple comparison.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのような２つの値が比較されます、するとその比較の結果がタプル比較の結果全体を決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Throw Statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>throw文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Throwing Functions and Methods</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スローを行う関数とメソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Throwing an error lets you indicate that something unexpected happened and the normal flow of execution can’t continue.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>エラーのスローがあなたに示すのは、何か予期せぬことが起こった、そして通常の実行の流れは続けることができないということです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Throwing an error like CancellationError</seg>
      </tuv>
      <tuv lang="ja">
        <seg>CancellationErrorに似たエラーをスローする</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Throwing and rethrowing functions are described in Throwing Functions and Methods and Rethrowing Functions and Methods.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スローおよび再スロー関数は、スロー関数とメソッドと再スロー関数とメソッドにおいて記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Throwing and rethrowing functions can transfer program control to an appropriate catch block, even when they’re nonreturning.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スローおよび再スロー関数は、制御を適切なcatchブロックに移すことができます、それらが非復帰である場合でさえも。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Throwing initializers can propagate errors in the same way as throwing functions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スローするイニシャライザは、スローする関数と同じ方法でエラーを伝達できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Throwing, catching, and propagating errors is covered in greater detail in Error Handling.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>エラーのスロー、キャッチ、そして伝達は、詳細にエラー処理において扱われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To access a value using a key path, pass the key path to the subscript(keyPath:) subscript, which is available on all types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>キーパスを使ってある値にアクセスするには、そのキーパスをsubscript(keyPath:)添え字に渡してください、それは全ての型で利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To access an index farther away from the given index, you can use the index(_:offsetBy:) method instead of calling one of these methods multiple times.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>与えられたインデックスからもっと遠く離れたインデックスにアクセスするには、あなたはこれらのメソッドのうちの１つを複数回呼び出すことの代わりにindex(_:offsetBy:)メソッドを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To accomplish this, Swift enables you to define nested types, whereby you nest supporting enumerations, classes, and structures within the definition of the type they support.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これを達成するために、スウィフトはあなたに入れ子にされた型を定義するのを可能にします、それによってあなたは、補助の列挙、クラス、そして構造体をそれらが支援をする型の定義の範囲内で入れ子にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To accomplish this, you define one input parameter—a String value called person—and a return type of String, which will contain a greeting for that person:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これを達成するために、あなたは１つの入力パラメータ ― personと呼ばれるString値 ― そしてその人のための挨拶を含むことになる、Stringの戻り型を定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To achieve these aims, you can mark a loop statement or conditional statement with a statement label.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの狙いを達成するために、あなたはループ文または条件文に文ラベルで印をつけることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To achieve this, an extra rule is used when signed integers are shifted to the right: When you shift signed integers to the right, apply the same rules as for unsigned integers, but fill any empty bits on the left with the sign bit, rather than with a zero.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これを達成するために、符号つき整数が右へシフトされるとき、特別な規則が使われます：あなたが符号つき整数を右にシフトする時は、符号なし整数と同じ規則を適用してください、しかし、その左のあらゆる空のビットを、ゼロではなく符号ビットで満たしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To achieve this, the Container protocol declares an associated type called Item, written as associatedtype Item.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これを達成するために、ContainerプロトコルはItemと呼ばれる関連型を宣言します、それはassociatedtype Itemのように書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To achieve this, the array’s size, and an initial cell value of 0.0, are passed to an array initializer that creates and initializes a new array of the correct size.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これを達成するために、この配列の大きさ、そして0.0の初期セル値は、正しいサイズの新しい配列をつくって初期化する配列イニシャライザに渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To add protocol conformance, you write the protocol names the same way as you write them for a class or structure:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル準拠を加えるには、あなたはそれらプロトコル名を、あなたがそれらをクラスや構造体に対して書くのと同じ方法で記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To add support for writing for loops in the special drawing syntax, add a buildArray(_:) method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>forループを書くサポートをこの特別な描画構文に加えるには、buildArray(_:)メソッドを加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To adopt the future behavior, replace #file with #fileID or #filePath as appropriate.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>将来の挙動を採用するには、#fileを#fileIDまたは#filePathで適切に置き換えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To align the values and statements, the unary plus operator (+i) is explicitly used with the unary minus operator (-i) and numbers lower than 10 are padded with zeros.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>値と文を整列するために、単項プラス演算子（+i）が明示的に単項マイナス演算子（-i)とともに使われます、そして10より低い数はゼロを詰められます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To assist with these assertions, Matrix includes a convenience method called indexIsValid(row:column:), which checks whether the requested row and column are inside the bounds of the matrix:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの表明を手伝うために、MatrixはindexIsValid(row:column:)と呼ばれるある便利なメソッドを含みます、それは要請されたrowとcolumnが行列の境界の内側にあるかどうか確認します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To avoid undefined behavior, ensure that your code never persists the pointer after the function call ends.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>未定義挙動を防ぐために、あなたのコードがその関数呼び出しが終わった後に決してそのポインタに固執しないことを確実にしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To calculate 9 % 4, you first work out how many 4s will fit inside 9:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>9 % 4を計算するために、あなたは最初にどれくらい多くの4が9の中に収まるかを考え出します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To call an asynchronous function and let it run in parallel with code around it, write async in front of let when you define a constant, and then write await each time you use the constant.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非同期関数を呼び出してそしてそれをそのまわりのコードと並列に動作させるには、あなたが定数を定義する時にasyncをletの前に書いてください、それからあなたがその定数を使うたびごとにawaitを書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To check for cancellation, either call Task.checkCancellation() [https://developer.apple.com/documentation/swift/task/3814826-checkcancellation], which throws CancellationError if the task has been canceled, or check the value of Task.isCancelled [https://developer.apple.com/documentation/swift/task/3814832-iscancelled] and handle the cancellation in your own code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>取り消しを検査するには、Task.checkCancellation() [https://developer.apple.com/documentation/swift/task/3814826-checkcancellation]を呼び出すか、それはCancellationErrorをそのタスクが取り消されたならばスローします、またはTask.isCancelled [https://developer.apple.com/documentation/swift/task/3814832-iscancelled]の値を調べて取り消しをあなた独自のコードにおいて取り扱うか、どちらかをしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To check the values of enumeration cases, use a switch statement, as shown in Matching Enumeration Values with a Switch Statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙ケース節の値を調べるために、列挙値をスイッチ文で照合するで示されるように、switch文を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To check whether a set contains a particular item, use the contains(_:) method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある集合が特定の項目を含むかどうか調べるために、contains(_:)メソッドを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To check whether a string has a particular string prefix or suffix, call the string’s hasPrefix(_:) and hasSuffix(_:) methods, both of which take a single argument of type String and return a Boolean value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある文字列が特定の文字列接頭辞または接尾辞を持つかどうか調べるために、文字列のhasPrefix(_:)とhasSuffix(_:)メソッドを呼んでください、それらの両方ともただ１つのString型の引数をとって、ブールの値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To compare tuples with seven or more elements, you must implement the comparison operators yourself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>７つまたはそれより多い要素のタプルを比較するには、あなたは比較演算子をあなた自身で実装しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To conform to this version of Container, the container’s Item type has to conform to the Equatable protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このバージョンのContainerに準拠するには、コンテナのもつItem型はEquatableプロトコルに準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To convert one specific number type to another, you initialize a new number of the desired type with the existing value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>１つの特定の数の型を他のものに変換するために、あなたは望む型の新しい数を既存の値で初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To cope with initialization conditions that can fail, define one or more failable initializers as part of a class, structure, or enumeration definition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>失敗の可能性がある初期化状況にうまく対処するために、１つ以上の失敗可能なイニシャライザをクラス、構造体、または列挙定義の一部として定義してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To cope with this requirement, you declare the capitalCity property of Country as an implicitly unwrapped optional property, indicated by the exclamation point at the end of its type annotation (City!).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この必要条件に対処するために、あなたはCountryのcapitalCityプロパティを、暗黙的にアンラップされるオプショナルのプロパティとして、その型注釈の終わりに感嘆符で示して宣言します（City!）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To cope with this scenario, the code checks that square is less than the board array’s count property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この事態に対処するために、コードは、squareがboard配列のcountプロパティより少ないことを確認します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To cope with this, the example above uses optional binding to check whether the optional Movie actually contains a value (that is, to find out whether the downcast succeeded.)</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これに対処するために、上の例は、オプショナル束縛を使って、オプショナルのMovieが実際に値を含むかどうか調べます（すなわち、ダウンキャストが成功したかどうか探り出します）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To create a property called items, which is initialized with an empty array of values of type Element</seg>
      </tuv>
      <tuv lang="ja">
        <seg>itemsと呼ばれるプロパティをつくる所で、それは、型Elementの値が入る空の配列で初期化されます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To create an empty String value as the starting point for building a longer string, either assign an empty string literal to a variable, or initialize a new String instance with initializer syntax:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>より長い文字列をつくるための出発点として空のString値を作成するために、変数に空のリテラル文字列を代入するか、イニシャライザ構文で新しいStringインスタンスを初期化してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To create an empty array or dictionary, use the initializer syntax.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>空の配列または辞書を作成するために、初期化構文を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To create an unstructured task that runs on the current actor, call the Task.init(priority:operation:) [https://developer.apple.com/documentation/swift/task/3856790-init] initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>現在のアクター上で動作するある非構造化タスクを作成するために、Task.init(priority:operation:) [https://developer.apple.com/documentation/swift/task/3856790-init]イニシャライザを呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To create an unstructured task that’s not part of the current actor, known more specifically as a detached task, call the Task.detached(priority:operation:) [https://developer.apple.com/documentation/swift/task/3856786-detached] class method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>現在のアクターの一部でない非構造化タスク、より具体的に分離されたタスクとして知られるもの、を作成するには、Task.detached(priority:operation:) [https://developer.apple.com/documentation/swift/task/3856786-detached]クラスメソッドを呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To declare a class or static method requirement in a protocol declaration, mark the method declaration with the static declaration modifier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスまたは静的メソッド要件をあるプロトコル宣言において宣言するために、そのメソッド宣言をstatic宣言修飾子で印してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To declare a constant type property, mark the declaration with the static declaration modifier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数型プロパティを宣言するために、宣言にstatic宣言修飾子で印をつけてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To declare a failable initializer that produces an implicitly unwrapped optional instance, append an exclamation point instead (init!).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>暗黙的にアンラップされるオプショナルインスタンスを生成する失敗できるイニシャライザを宣言するために、代わりに感嘆符を加えてください（init!）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To declare a failable initializer that produces an optional instance, append a question mark to the init keyword in the initializer declaration (init?).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルインスタンスを生成する失敗できるイニシャライザを宣言するために、イニシャライザ宣言において疑問符をinitキーワードに加えてください（init?）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To declare a static subscript requirement in a protocol declaration, mark the subscript declaration with the static declaration modifier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>静的添え字要件をプロトコル宣言において宣言するには、その添え字宣言をstatic宣言修飾子で印してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To declare a subscript that’s exposed by the type, rather than by instances of the type, mark the subscript declaration with the static declaration modifier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型によって、その型のインスタンスによってではなく、露出される添え字を宣言するには、添え字宣言をstatic宣言修飾子で印してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To declare a type property requirement in a protocol declaration, mark the property declaration with the static keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある型プロパティ要件をプロトコル宣言の中で宣言するには、そのプロパティ宣言をstaticキーワードで印してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To declare a type variable property, mark the declaration with the static declaration modifier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型変数プロパティを宣言するために、宣言にstatic宣言修飾子で印をつけてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To declare convenience initializers for a class, mark the initializer declaration with the convenience declaration modifier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるクラスの便宜イニシャライザを宣言するために、そのイニシャライザ宣言をconvenience宣言修飾子を使って印してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To define a property wrapper, you make a structure, enumeration, or class that defines a wrappedValue property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティラッパーを定義するには、あなたはあるwrappedValueプロパティを定義する構造体、列挙、またはクラスを作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To define a result builder, you write the @resultBuilder attribute on a type declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>リザルトビルダーを定義するには、あなたは@resultBuilder属性を型宣言上で書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To define these requirements, the Container protocol needs a way to refer to the type of the elements that a container will hold, without knowing what that type is for a specific container.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの要件を定義するために、Containerプロトコルは、あるコンテナが保持することになる要素の型を参照する方法を必要とします、その型がどんなコンテナのためのものか知ることなしにです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To determine the answer for a % b, the % operator calculates the following equation and returns remainder as its output:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>a % bに対する答えを決定するために、%演算子は以下の等式を計算します、そしてその出力として余りを返します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To discover the specific type of a constant or variable that’s known only to be of type Any or AnyObject, you can use an is or as pattern in a switch statement’s cases.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型AnyまたはAnyObjectのものであることだけが知られている定数や変数の具体的な型を見つけるために、あなたはisまたはasパターンをswitch文のケース節の中で使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To distinguish between methods or initializers whose names differ only by the names of their arguments, include the argument names in parentheses, with each argument name followed by a colon (:).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>名前がそれらの引数の名前でだけ異なるものであるメソッド間またはイニシャライザ間で識別を行うために、丸括弧の中に引数名を、各引数名にコロン（:）を続けることで含めて下さい。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To distinguish between overloaded methods, use a type annotation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オーバーロードされたメソッド間で識別を行うには、型注釈を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To do that, you need to create an instance of the structure or class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それをするために、あなたは構造体またはクラスのインスタンスをつくる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To do this, it needs to access each item as a true Movie or Song, and not just as a MediaItem.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これをするために、それは、ただMediaItemとしてではなく、本当のMovieまたはSongとして各項目にアクセスする必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To do this, you make parts of your code conditional.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これをするために、あなたは、あなたのコードの一部を条件つきにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To draw a Line, the structure calls draw() on each of the line’s components, and then concatenates the resulting strings into a single string.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Lineを描画するために、構造体はdraw()をその行のもつ構成要素のそれぞれで呼び出します、そしてそれから結果文字列それらを単一の文字列へと連結します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To ease migration of code from versions of Swift prior to 5.3—which performed this matching from right to left—the compiler checks both the left-to-right and right-to-left orderings.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>5.3より前のスウィフトのバージョンからのコードの移行を簡単にするために — それはこの合致を右から左に実行しました — コンパイラは左から右と右から左順の両方を調べます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To enable indirection for a particular enumeration case, mark it with the indirect declaration modifier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある特定の列挙ケース節に対して間接参照を可能にするには、それをindirect宣言修飾子で印してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To enable indirection for all the cases of an enumeration that have an associated value, mark the entire enumeration with the indirect modifier—this is convenient when the enumeration contains many cases that would each need to be marked with the indirect modifier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある列挙の中のすべてのケース節、それらは関連値を持っている、に対して間接参照を可能にするには、その列挙全体をindirect修飾子で印してください—これはその列挙がそのそれぞれがindirect修飾子で印される必要がある多くのケース節を含んでいる時に適します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To enable it in Xcode, set the “Build Libraries for Distribution” build setting (BUILD_LIBRARY_FOR_DISTRIBUTION) to Yes, as described in Xcode Help [https://help.apple.com/xcode/mac/current/#/dev04b3a04ba].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それをXcodeで可能にするには、“Build Libraries for Distribution” ビルド設定（BUILD_LIBRARY_FOR_DISTRIBUTION）を Yes に設定してください、Xcode Help [https://help.apple.com/xcode/mac/current/#/dev04b3a04ba]で記述されるとおりに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To enable library evolution mode on the command line, pass the -enable-library-evolution option to the Swift compiler.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ライブラリ進化モードをコマンドライン上で可能にするには、-enable-library-evolutionオプションをスウィフトコンパイラに渡してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To enable this, Swift provides two identity operators:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これを可能にするために、スウィフトは２つの同一性演算子を提供します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To ensure conversion between numeric types maintains the value exactly, use the init(exactly:) initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>数値型の間の変換がその値を正確に維持するのを保証するために、init(exactly:)イニシャライザを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To ensure that an error is handled, use a catch clause with a pattern that matches all errors, such as a wildcard pattern (_).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>エラーが処理されることが保証されるように、あるひとつのcatch節をどんなエラーにもマッチするパターンとともに使ってください、例えばワイルドカードパターン（_）など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To evaluate the value of a subscript expression, the subscript getter for the expression’s type is called with the index expressions passed as the subscript parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字式の値を評価するために、この式のもつ型のための添え字ゲッターが、添え字パラメータとして渡されるインデックス式を使って呼び出されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To explicitly fall through at the end of a particular switch case, use the fallthrough keyword, as described in Fallthrough.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある特定のswitchケース節の終わりで明示的に抜け落ちるには、フォールスルーで記述されるように、fallthroughキーワードを使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To express this fact, you write a type constraint of Equatable as part of the type parameter’s definition when you define the function:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この事実を表すために、あなたはEquatableの型制約を型パラメータの定義の一部として、あなたが関数を定義する時に書きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To find out the number of items in a set, check its read-only count property:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>集合の中の項目数を知るために、それの読み出し専用のcountプロパティを調べてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To find out the number of items in an array, check its read-only count property:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある配列の中の項目の数を知るために、その読み出し専用のcountプロパティを調べてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To handle an empty array safely, write the minMax(array:) function with an optional tuple return type and return a value of nil when the array is empty:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>空の配列を安全に取り扱うために、minMax(array:)関数をオプショナルタプルの戻り型を使って書いて、配列が空の時にnilの値を返してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To help manage the currentLevel property, LevelTracker defines an instance method called advance(to:).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>currentLevelプロパティを管理するのを手伝うために、LevelTrackerはadvance(to:)と呼ばれるインスタンスメソッドを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To identify these places in your code, write the try keyword—or the try? or try! variation—before a piece of code that calls a function, method, or initializer that can throw an error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの場所をあなたのコードの中で識別するには、tryキーワードを ― またはその変種try?またはtry!を ― エラーをスローできる関数、メソッド、またはイニシャライザを呼び出すコードの前の場所に書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To illustrate this behavior, the following example defines two protocols and a generic type that conditionally conforms to both protocols.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この挙動を図解するために、以下の例は２つのプロトコルおよび両方のプロトコルに条件付きで準拠する１つの総称体型を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To implement the +++ operator, you add a type method called +++ to Vector2D as follows:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>+++演算子を実装するには、あなたは+++と呼ばれる型メソッドを次のようにVector2Dに加えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To include the text """ in a multiline string, escape at least one of the quotation marks.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>テキスト"""を複数行文字列の中に含めるには、少なくとも１つの引用符記号の１つをエスケープしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To include the trailing closures in the arguments, the compiler examines the function’s parameters from left to right as follows:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>後付クロージャを引数それらの中に含めるために、コンパイラは関数のもつパラメータを左から右へと調査します、次のように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To indicate that a function or method is asynchronous, you write the async keyword in its declaration after its parameters, similar to how you use throws to mark a throwing function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある関数またはメソッドが非同期であることを指し示すために、あなたはasyncキーワードをそれの宣言の中でそれのパラメータの後に書きます、あなたがthrowsを使ってスロー関数を印する方法と同じように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To indicate that a function, method, or initializer can throw an error, you write the throws keyword in the function’s declaration after its parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>エラーをスローすることのできる関数、メソッド、またはイニシャライザを指し示すために、あなたはthrowsキーワードを関数の定義においてそれのパラメータの後に書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To indicate that a subclass has a superclass, write the subclass name before the superclass name, separated by a colon:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるサブクラスがあるスーパークラスを持つことを表わすには、サブクラスの名前をスーパークラスの名前の前に、コロンで区切って書きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To insert a single character into a string at a specified index, use the insert(_:at:) method, and to insert the contents of another string at a specified index, use the insert(contentsOf:at:) method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある単一の文字をある文字列中へ特定のインデックスで差し込むには、insert(_:at:)メソッドを使ってください、そして別の文字列の内容を特定のインデックスで差し込むには、insert(contentsOf:at:)メソッドを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To insert an item into the array at a specified index, call the array’s insert(_:at:) method:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある項目を配列の中へ指定されたインデックスで差し入れるために、配列のinsert(_:at:)メソッドを呼んでください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To iterate over the keys or values of a dictionary in a specific order, use the sorted() method on its keys or values property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>辞書のキーまたは値に特定の順序で繰り返していくために、sorted()メソッドをkeysまたはvaluesプロパティ上で使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To iterate over the values of a set in a specific order, use the sorted() method, which returns the set’s elements as an array sorted using the &lt; operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>集合の中の値に特定の順番で繰り返すには、sorted()メソッドを使ってください、それは集合の要素を&lt;演算子を使って格納される配列として返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To learn how functions can return other functions, see Function Types as Return Types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数が他の関数を返すことができる方法を学ぶために、戻り型としての関数型を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To learn how to define new, custom operators, see Custom Operators and Operator Declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>新しい、あつらえの演算子を定義する方法を学ぶために、あつらえの演算子と演算子宣言を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To learn how to overload existing operators, see Operator Methods.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>既存の演算子にオーバーロードする方法を学ぶために、演算子メソッドを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To make a switch with a single case that matches both "a" and "A", combine the two values into a compound case, separating the values with commas.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ただ１つだけのケース節を持つあるswitchが"a"と"A"の両方にマッチするようにするには、２つの値をひとつの複合ケース節へと、コンマで値を隔てて結合してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To make a multiline string literal that begins or ends with a line feed, write a blank line as its first or last line.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ラインフィードで始まるまたは終わる複数行文字列リテラルを作るには、空の行をそれの最初または最後の行に書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To make a multiline string literal that begins or ends with a line feed, write a blank line as the first or last line.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ラインフィードで始まるまたは終わる複数行文字列リテラルを作るには、空の行を最初または最後の行として記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To make it more useful, you need to refine it to describe more specific kinds of vehicles.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それをより役に立つようにするために、あなたはそれを改良してより具体的な乗物の種類を記述する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To make sure that instances don’t disappear while they’re still needed, ARC tracks how many properties, constants, and variables are currently referring to each class instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それがまだ必要な間にインスタンスが消えないことを確実にするために、ARCは、どれくらいのプロパティ、定数、および変数が目下のところ各クラスインスタンスに言及しているかを追跡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To make the body of this function shorter, you can combine the message creation and the return statement into one line:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この関数の本文をより短くするために、あなたはメッセージ作成と返しの文を１行に結合することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To make this possible, whenever you assign a class instance to a property, constant, or variable, that property, constant, or variable makes a strong reference to the instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これを可能にするために、あなたがクラスインスタンスをプロパティ、定数、または変数に代入するときはいつでも、そのプロパティ、定数、または変数はそのインスタンスへの強い参照を作ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To model this restriction, the failable initializer triggers an initialization failure if an empty string is found.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この制約条件をモデル化するために、失敗できるイニシャライザは空の文字列が見つけられるならば初期化失敗を引き起こします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To nest a type within another type, write its definition within the outer braces of the type it supports.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある型を別の型の内部で入れ子にするために、その定義をそれが支援する型の外側の波括弧の範囲内で書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To opt in to overflow behavior, use Swift’s second set of arithmetic operators that overflow by default, such as the overflow addition operator (&amp;+).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オーバフロー挙動を選ぶために、初期状態でオーバフローするスウィフトの算術演算子の第二集合を使ってください、例えばオーバフロー加算演算子（&amp;+）など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To override a characteristic that would otherwise be inherited, you prefix your overriding definition with the override keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そうしなければ継承される特徴をオーバーライドするために、あなたは、あなたのオーバーライド定義の前にoverrideキーワードを置きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To parse a #fileID expression, read the module name as the text before the first slash (/) and the filename as the text after the last slash.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>#fileID式を構文解析するには、モジュール名を最初のスラッシュ（/）の前のテキストと、そしてファイル名を最後のスラッシュの後のテキストと解釈してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To prevent strong reference cycles, delegates are declared as weak references.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>強い参照循環を防ぐために、委任先は弱い参照として宣言されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To print a value without a line break after it, pass an empty string as the terminator—for example, print(someValue, terminator: "").</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある値をそれの後に改行なしで出力するには、空の文字列を終端子（ターミネータ）として渡してください ― 例えば、print(someValue, terminator: "")。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To project a value from a property wrapper, define a projectedValue instance property on the wrapper type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある値をプロパティラッパーから投影をするには、projectedValueインスタンスプロパティをそのラッパー型上で定義してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To propagate cancellation manually, call Task.cancel() [https://developer.apple.com/documentation/swift/task/3851218-cancel].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>取り消しを手動で伝播するには、Task.cancel() [https://developer.apple.com/documentation/swift/task/3851218-cancel]を呼び出してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To put it another way:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>言い換えれば：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To receive a synthesized implementation of ==, declare conformance to Equatable in the file that contains the original declaration, without implementing an == operator yourself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>==の合成実装を受け取るには、Equatableへの準拠を本来の宣言を含んでいるファイルにおいて宣言してください、==演算子をあなた自身で実装することなしに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To receive a synthesized implementation of hash(into:), declare conformance to Hashable in the file that contains the original declaration, without implementing a hash(into:) method yourself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>hash(into:)の合成実装を受け取るには、Hashableへの準拠を本来の宣言を含むファイルにおいて宣言してください、hash(into:)メソッドをあなた自身で実装することなしに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To receive a synthesized implementation of &lt;, declare conformance to Comparable in the file that contains the original enumeration declaration, without implementing a &lt; operator yourself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>&lt;の合成実装を受け取るには、Comparableへの準拠を本来の列挙宣言を含むファイルにおいて宣言してください、&lt;演算子をあなた自身で実装することなしに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To reference the case of an enumeration type, use dot (.) syntax, as in EnumerationType.enumerationCase.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙型のケース節に言及するために、EnumerationType.enumerationCaseのように、ドット（.）構文を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To reflect the fact that optional chaining can be called on a nil value, the result of an optional chaining call is always an optional value, even if the property, method, or subscript you are querying returns a non-optional value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル連鎖はnil値上で呼ばれることができるという事実を反映するために、オプショナル連鎖呼び出しの結果は、たとえあなたが問い合わせているプロパティ、メソッド、または添え字が非オプショナルの値を返すとしても、常にオプショナルの値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To remove a single character from a string at a specified index, use the remove(at:) method, and to remove a substring at a specified range, use the removeSubrange(_:) method:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある単一の文字をある文字列から特定のインデックスで削除するには、remove(at:)メソッドを使ってください、そして部分文字列を特定の範囲で削除するには、removeSubrange(_:)メソッドを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To represent this fact, ShoppingListItem introduces a Boolean property called purchased, with a default value of false.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この事実を表すために、ShoppingListItemは、falseの省略時の値で、purchasedと呼ばれるブールのプロパティを導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To represent this game board, the Chessboard structure has a single property called boardColors, which is an array of 64 Bool values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このゲーム板を表すために、Chessboard構造体はboardColorsと呼ばれる１つのプロパティだけを持ちます、それは64個のBool値の配列です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To represent this, board[03] is equal to +08, which is equivalent to an integer value of 8 (the difference between 3 and 11).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これを表すために、board[03]は+08と等しいです、そしてそれは、整数値の８（3と11の差）に等しいです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To represent this, the Customer class has an optional card property, but the CreditCard class has an unowned (and non-optional) customer property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これを表すために、Customerクラスはオプショナルのcardプロパティを持ちます、しかし、CreditCardクラスは非所有（そして非オプショナル）のcustomerプロパティを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To represent this, the Country class has a capitalCity property, and the City class has a country property:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これを表すために、CountryクラスはcapitalCityプロパティを持ちます、そして、Cityクラスはcountryプロパティを持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To require that subclasses implement a superclass’s initializer, mark the superclass’s initializer with the required declaration modifier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるスーパークラスの持つイニシャライザをそのサブクラスそれらが実装することを要求するために、そのスーパークラスのイニシャライザをrequired宣言修飾子で印してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To restrict the adoption of a protocol to class types only, include the AnyObject protocol in the inherited protocols list after the colon.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるプロトコルの採用をクラス型のみに制約するには、AnyObjectプロトコルを継承されたプロトコルのリストの中にコロンの後で加えてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To retrieve a count of the Character values in a string, use the count property of the string:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある文字列の中のCharacter値の総数を取り出すために、その文字列のcountプロパティを使ってください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To see an example of how to create and implement a new operator, see Custom Operators.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>新しい演算子の作成と実装の方法の例を見るには、あつらえの演算子を参照してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To see an example of how to use a do statement with several catch clauses, see Handling Errors.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>do文を複数のcatch節とともに使う方法の例を見るために、エラーを処理するを見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To see examples of initializers in various type declarations, see Initialization.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>いろいろな型宣言におけるイニシャライザの例を見るために、初期化を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To set its value, the subscript setter is called in the same way.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その値を設定するために、添え字セッターが同様に呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To set up the interdependency between the two classes, the initializer for City takes a Country instance, and stores this instance in its country property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２つのクラスの間で相互依存を設定するために、Cityのためのイニシャライザは、Countryインスタンスをとって、このインスタンスをそれのcountryプロパティに保管します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To simplify the relationships between designated and convenience initializers, Swift applies the following three rules for delegation calls between initializers:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>指定と便宜イニシャライザの間の関係を単純化するために、スウィフトは以下の３つの規則をイニシャライザ間の委任呼び出しに対して適用します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To solve this problem, implement a buildLimitedAvailability(_:) method to erase type information.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この問題を解決するには、buildLimitedAvailability(_:)メソッドを実装して型情報を消去してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To specify an in-out parameter, prefix the parameter type with the inout keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>in-outパラメータを指定するために、inoutキーワードをそのパラメータ型の前に置いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To specify that the push(_:) method has a single parameter called item, which must be of type Element</seg>
      </tuv>
      <tuv lang="ja">
        <seg>push(_:)メソッドが１つのパラメータ、itemと呼ばれるものを持つことを指定する所で、それは、型Elementでなければなりません</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To specify that the value returned by the pop() method will be a value of type Element</seg>
      </tuv>
      <tuv lang="ja">
        <seg>pop()メソッドによって返される値が型Elementの値であることを示す所で</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To support recursion, the compiler must insert a layer of indirection.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>再帰をサポートするために、コンパイラは間接参照の階層を差し入れる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To support setting an initial value or other customization, the property wrapper needs to add an initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>初期値の設定または他のカスタマイゼーションをサポートするには、プロパティラッパーはイニシャライザの追加を必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To understand the concurrent nature of the example above, here’s one possible order of execution:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上の例の並行の本質を理解するために、ここに遂行の１つの起こりうる順番があります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To use a function, you “call” that function with its name and pass it input values (known as arguments) that match the types of the function’s parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある関数を使うためには、あなたはその関数をそれの名前を使って「呼び出し」、それにその関数のパラメータの型に適合する入力値（引数として知られます）を渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To use a nested type outside of its definition context, prefix its name with the name of the type it’s nested within:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>入れ子にされた型をその定義の文脈外で使うために、その名前にそれが入れ子にされている型の名前で接頭辞を付けてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To use a reserved word as an identifier, put a backtick (`) before and after it.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>識別子として予約語を使用するために、それの前後にバッククォート（`）を置いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To use it in the ternary conditional (? :) operator, it must have whitespace around both sides.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それを三項条件（? :）において使うためには、それは両側に空白を持ってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To use optional chaining, use a question mark in place of the exclamation point:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル連鎖を使用するために、感嘆符の代わりに疑問符を使ってください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To use string interpolation inside a string that uses extended delimiters, match the number of number signs after the backslash to the number of number signs at the beginning and end of the string.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列補間を拡張区切り記号を使う文字列内部で使うには、バックスラッシュの後のシャープ記号の数をその文字列の始まりと終わりでのシャープ記号の数と合わせてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To use the ? as the optional-chaining operator, it must not have whitespace on the left.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>?をオプショナル連鎖演算子として使うには、それは左側に空白を持ってはなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To win, you must land exactly on square 25.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>勝つために、あなたはぴったり正方形25に到着しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To work out the exact evaluation order to use, you also need to consider their associativity.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>使用する的確な評価順序を解き明かすには、あなたはまたそれらの結合性を考慮する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Top-Level Code</seg>
      </tuv>
      <tuv lang="ja">
        <seg>トップレベル・コード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Top-level declarations consist of only declarations, and are allowed in all Swift source files.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>トップレベル宣言は、宣言それらからのみ構成されます、そしてスウィフトソースファイルにおいて許可されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Tradition suggests that the first program in a new language should print the words “Hello, world!” on the screen.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>伝統は、新しい言語において最初のプログラムが画面上に語句「Hello, world!」を出力しなければならないことを示唆します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Trailing Closure</seg>
      </tuv>
      <tuv lang="ja">
        <seg>後付クロージャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Trailing Closures</seg>
      </tuv>
      <tuv lang="ja">
        <seg>後付クロージャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Trailing closure syntax</seg>
      </tuv>
      <tuv lang="ja">
        <seg>後付クロージャ構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Trailing closures are most useful when the closure is sufficiently long that it isn’t possible to write it inline on a single line.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャがそれをただ１つの行の行内に書くことが可能でないほど長いとき、後付クロージャは最も役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Treat identifiers that begin with an underscore as internal, even if their declaration has the public access-level modifier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるアンダースコアで始まる識別子を内部として扱ってください、たとえそれらの宣言がpublicアクセス水準修飾子を持つとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Try Operator</seg>
      </tuv>
      <tuv lang="ja">
        <seg>try演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Try removing the conversion to String from the last line.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最後の行からStringへの転換を取り除いてみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Try removing the default case.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>何れにも当てはまらない場合の部分（default: の部分）を取り除いてみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Trying to change the value of a function parameter from within the body of that function results in a compile-time error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その関数の本文内部から関数パラメータの値を変えようとすることは、コンパイル時エラーに終わります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Trying to set an Int16 constant or variable to a number outside of this range causes an error:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Int16定数または変数をこの範囲の外側の数に設定する試みは、エラーを引き起こします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Trying to use ! to access a nonexistent optional value triggers a runtime error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>存在しないオプショナルの値にアクセスするために!を使うことを試みることは、実行時エラーの引き金となります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Tuple Expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タプル式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Tuple Pattern</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タプルパターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Tuple Type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タプル型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Tuple Types</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タプル型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Tuple patterns match values of corresponding tuple types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タプルパターンは、対応するタプル型の値にマッチします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Tuple types don’t have a standalone definition in the way that classes, structures, enumerations, and functions do.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タプル型には、クラス、構造体、列挙、そして関数が行う方法での、独立した定義がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Tuples</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タプル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Tuples are compared from left to right, one value at a time, until the comparison finds two values that aren’t equal.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タプルは、左から右へと、一度に１つの値を、比較が等しくない２つの値を見つけるまで、比較されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Tuples are particularly useful as the return values of functions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タプルは、特に関数の戻り値として便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Tuples are useful for simple groups of related values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タプルは、関連した値の単純なグループに対して便利です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Tuples can also be used as parameter types and return types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タプルもまた、パラメータ型および戻り型として使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Tuples can be compared with a given operator only if the operator can be applied to each value in the respective tuples.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タプルは、与えられた演算子で比較されることが、その演算子がそれぞれのタプルの中の値それぞれに適用可能である場合にのみ可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Tuples enable you to create and pass around groupings of values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タプルは、あなたに値のグループをつくってあちこち渡すことを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Two String values (or two Character values) are considered equal if their extended grapheme clusters are canonically equivalent.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２つのString値（または２つのCharacter）は、それらの拡張書記素クラスタそれらが正準等価ならば、等しいとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Two extension declarations attempt to add conditional conformance to the Serializable protocol, one for for arrays with Int elements, and one for arrays with String elements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２つの拡張宣言は、Serializableプロトコルへの条件準拠を加えることを試みます、Int要素を持つ配列のために１つ、そしてString要素を持つ配列のために１つ。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Two flipped shapes returned by this function might have completely different types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この関数によって返される２つの裏返された形状が、完全に異なる型を持つかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Two-Phase Initialization</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２段階初期化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Two-phase initialization prevents property values from being accessed before they’re initialized, and prevents property values from being set to a different value by another initializer unexpectedly.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２段階初期化は、プロパティ値が初期化される前にアクセスされるのを妨げます、それによってプロパティ値が思いもよらず別のイニシャライザによって異なる値に設定されるのを防ぎます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type Alias Declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型エイリアス宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type Aliases</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型エイリアス</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type Annotation</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型注釈</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type Annotations</seg>
      </tuv>
      <tuv lang="ja">
        <seg>さまざまな型注釈</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type Attributes</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型属性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type Casting</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型キャスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type Casting for Any and AnyObject</seg>
      </tuv>
      <tuv lang="ja">
        <seg>AnyおよびAnyObjectに対する型キャスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type Constraint Syntax</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型制約構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type Constraints</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型制約</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type Constraints in Action</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型制約の動作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type Identifier</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型識別子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type Inference</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型推論</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type Inheritance Clause</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型継承節</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type Methods</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型メソッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type Parameters</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型パラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type Properties</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type Property Syntax</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型プロパティ構文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type Safety and Type Inference</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型安全と型推論</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type Subscript Declarations</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型添え字宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type Subscripts</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型添え字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type Variable Properties</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型変数プロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type alias declarations are declared using the typealias keyword and have the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型エイリアス宣言は、キーワードtypealiasを使って宣言されます、そして以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type aliases are useful when you want to refer to an existing type by a name that’s contextually more appropriate, such as when working with data of a specific size from an external source:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型エイリアスは、あなたがより文脈上適切な名前で既存の型に言及したいとき役に立ちます、たとえば外部ソースからの特定の大きさのデータを扱う時など：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type aliases don’t create new types; they simply allow a name to refer to an existing type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型エイリアスは、新しい型を作成しません；それらは、単にある名前が既存の型に言及できるようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type annotations begin with a colon (:) and end with a type, as the following examples show:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型注釈は、以下の例が示すように、コロン（:）で始まりひとつの型で終わります：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type annotations can contain an optional list of type attributes before the type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型注釈は、型の前に任意の型属性のリストを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type casting enables you to check and interpret the type of a class instance at runtime.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型キャストは、あなたにクラスインスタンスの型を実行時に調べて解釈することを可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type casting in Swift is implemented with the is and as operators.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトでの型キャストは、isとas演算子を使って実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type casts that can fail at runtime now use the as? or as! operator, and type casts that are guaranteed not to fail use the as operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>実行時に失敗できる型キャストは、今ではas?またはas!演算子を使います、そして失敗しないことを保証される型キャストはas演算子を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type constraints specify that a type parameter must inherit from a specific class, or conform to a particular protocol or protocol composition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型制約は、型パラメータが特定のクラスから継承しなければならない、もしくはある特定のプロトコルまたはプロトコル合成に準拠しなければならないことを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type constraints, as described in Type Constraints, enable you to define requirements on the type parameters associated with a generic function, subscript, or type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型制約は、「型制約」で記述されるように、総称体の関数、添え字、または型と関連した型パラメータに要件を定義することをあなたに可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type inference enables a compiler to deduce the type of a particular expression automatically when it compiles your code, simply by examining the values you provide.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型推論は、コンパイラに自動的に特定の式の型を演繹することを、それがあなたのコードをコンパイルする時に、単純にあなたが提供する値を調べることによって、可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type inference helps make Swift code more concise and readable when it initializes constants or variables with other values whose type is already known.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型推論は、スウィフトのコードを、それが定数または変数を型がすでに知られている他の値で初期化するとき、より簡潔で読みやすくするのを助けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type inference in Swift operates at the level of a single expression or statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトの型推論は、単一の式や文の水準で働きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type inference is particularly useful when you declare a constant or variable with an initial value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが最初の値で定数または変数を宣言するとき、型推論は特に役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type methods and properties now use the static keyword as a declaration modifier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メソッドとプロパティは今ではstaticキーワードを宣言修飾子として使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type methods are called with dot syntax, like instance methods.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型メソッドは、インスタンスメソッドの様に、ドット構文で呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type methods are similar to class methods in Objective-C.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型メソッドは、Objective-Cにおけるクラスメソッドに似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type parameters specify and name a placeholder type, and are written immediately after the function’s name, between a pair of matching angle brackets (such as &lt;T&gt;).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型パラメータは、プレースホルダ型を指定して命名します、そして関数の名前の直後に一対の山形括弧の間で書かれます（例えば&lt;T&gt;）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type properties are discussed in Type Properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型プロパティは、型プロパティで議論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type properties are discussed in Type Properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型プロパティは、型プロパティで記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type properties are queried and set with dot syntax, just like instance properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型プロパティは、インスタンスプロパティのように、ドット構文で問い合わせられ設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type properties are useful for defining values that are universal to all instances of a particular type, such as a constant property that all instances can use (like a static constant in C), or a variable property that stores a value that’s global to all instances of that type (like a static variable in C).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型プロパティは、特定の型の全てのインスタンスに共通なさまざまな値を定義することに役立ちます、例えば、全てのインスタンスが使うことができる定数プロパティ（Cでの静的定数のように）、またはその型の全てのインスタンスにグローバルである値を格納する変数プロパティ（Cでの静的変数のように）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type safety helps you catch and fix errors as early as possible in the development process.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型安全は、あなたが開発プロセスにおいて可能な限り早期にエラーを捕まえて修復するのを助けます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type-Casting Operators</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型キャスト演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type-Casting Patterns</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型キャスト・パターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type-checking helps you avoid errors when you’re working with different types of values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型をチェックすることは、あなたが異なる種類の値を扱っているとき、あなたがエラーを避ける手助けをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Types</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Types can be nested to as many levels as are required.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型は、必要とされるだけ多くの階層に入れ子にされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Types declared with the dynamicMemberLookup attribute include members that are looked up at runtime, as described in Attributes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>dynamicMemberLookup属性とともに宣言される型は、実行時に捜されるメンバーを含みます、属性で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Types don’t automatically adopt a protocol just by satisfying its requirements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型は、単にその要件を満たすことだけによっては自動的にあるプロトコルを採用しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Types like structures, tuples, and enumerations are made up of individual constituent values, such as the properties of a structure or the elements of a tuple.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体、タプル、そして列挙のようないくつかの型は、例えば構造体のプロパティやタプルの要素などのような個々の構成要素から作り上げられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Typically you don’t need to perform manual cleanup when your instances are deallocated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>概して、あなたのインスタンスが割り当て解除されるとき、あなたが手動で掃除をする必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Typically, you use the if statement to evaluate simple conditions with only a few possible outcomes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>一般的に、あなたはif文をほんの２、３の起こりうる結果だけを持つ単純な状況を評価するために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>U+000D followed by U+000A</seg>
      </tuv>
      <tuv lang="ja">
        <seg>U+000D に続けて U+000A</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>U+00A8, U+00AA, U+00AD, U+00AF, U+00B2–U+00B5, or U+00B7–U+00BA</seg>
      </tuv>
      <tuv lang="ja">
        <seg>U+00A8, U+00AA, U+00AD, U+00AF, U+00B2–U+00B5, または U+00B7–U+00BA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>U+00B6, U+00BB, U+00BF, U+00D7, or U+00F7</seg>
      </tuv>
      <tuv lang="ja">
        <seg>U+00B6, U+00BB, U+00BF, U+00D7, または U+00F7</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>U+00BC–U+00BE, U+00C0–U+00D6, U+00D8–U+00F6, or U+00F8–U+00FF</seg>
      </tuv>
      <tuv lang="ja">
        <seg>U+00BC–U+00BE, U+00C0–U+00D6, U+00D8–U+00F6, または U+00F8–U+00FF</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>U+0100–U+02FF, U+0370–U+167F, U+1681–U+180D, or U+180F–U+1DBF</seg>
      </tuv>
      <tuv lang="ja">
        <seg>U+0100–U+02FF, U+0370–U+167F, U+1681–U+180D, または U+180F–U+1DBF</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>U+0300–U+036F, U+1DC0–U+1DFF, U+20D0–U+20FF, or U+FE20–U+FE2F</seg>
      </tuv>
      <tuv lang="ja">
        <seg>U+0300–U+036F, U+1DC0–U+1DFF, U+20D0–U+20FF, または U+FE20–U+FE2F</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>U+10000–U+1FFFD, U+20000–U+2FFFD, U+30000–U+3FFFD, or U+40000–U+4FFFD</seg>
      </tuv>
      <tuv lang="ja">
        <seg>U+10000–U+1FFFD, U+20000–U+2FFFD, U+30000–U+3FFFD, または U+40000–U+4FFFD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>U+200B–U+200D, U+202A–U+202E, U+203F–U+2040, U+2054, or U+2060–U+206F</seg>
      </tuv>
      <tuv lang="ja">
        <seg>U+200B–U+200D, U+202A–U+202E, U+203F–U+2040, U+2054, または U+2060–U+206F</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>U+2070–U+20CF, U+2100–U+218F, U+2460–U+24FF, or U+2776–U+2793</seg>
      </tuv>
      <tuv lang="ja">
        <seg>U+2070–U+20CF, U+2100–U+218F, U+2460–U+24FF, または U+2776–U+2793</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>U+3004–U+3007, U+3021–U+302F, U+3031–U+303F, or U+3040–U+D7FF</seg>
      </tuv>
      <tuv lang="ja">
        <seg>U+3004–U+3007, U+3021–U+302F, U+3031–U+303F, または U+3040–U+D7FF</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>U+50000–U+5FFFD, U+60000–U+6FFFD, U+70000–U+7FFFD, or U+80000–U+8FFFD</seg>
      </tuv>
      <tuv lang="ja">
        <seg>U+50000–U+5FFFD, U+60000–U+6FFFD, U+70000–U+7FFFD, または U+80000–U+8FFFD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>U+90000–U+9FFFD, U+A0000–U+AFFFD, U+B0000–U+BFFFD, or U+C0000–U+CFFFD</seg>
      </tuv>
      <tuv lang="ja">
        <seg>U+90000–U+9FFFD, U+A0000–U+AFFFD, U+B0000–U+BFFFD, または U+C0000–U+CFFFD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>U+D0000–U+DFFFD or U+E0000–U+EFFFD</seg>
      </tuv>
      <tuv lang="ja">
        <seg>U+D0000–U+DFFFD または U+E0000–U+EFFFD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>U+F900–U+FD3D, U+FD40–U+FDCF, U+FDF0–U+FE1F, or U+FE30–U+FE44</seg>
      </tuv>
      <tuv lang="ja">
        <seg>U+F900–U+FD3D, U+FD40–U+FDCF, U+FDF0–U+FE1F, または U+FE30–U+FE44</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>UInt</seg>
      </tuv>
      <tuv lang="ja">
        <seg>符号なし整数（Unsigned Integer）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>UTF-16 Representation</seg>
      </tuv>
      <tuv lang="ja">
        <seg>UTF-16表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>UTF-8 Representation</seg>
      </tuv>
      <tuv lang="ja">
        <seg>UTF-8表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unary prefix operators appear immediately before their target (such as !b), and unary postfix operators appear immediately after their target (such as c!).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>単項接頭辞演算子はそれらの目標の直前に現れます（例えば!bのように）、そして単項接尾辞演算子はそれらの目標の直後に現れます（例えばc!のように）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unary Minus Operator</seg>
      </tuv>
      <tuv lang="ja">
        <seg>単項マイナス演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unary Plus Operator</seg>
      </tuv>
      <tuv lang="ja">
        <seg>単項プラス演算子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unary operators operate on a single target.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>単項演算子は、１つの目標に作用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Underscores (_) are allowed between digits for readability, but they’re ignored and therefore don’t affect the value of the literal.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>アンダースコア（_）は、可読性のために桁の間で認められます、しかしそれらは無視されて、それゆえにリテラルの値に影響を及ぼしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Understanding Conflicting Access to Memory</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メモリへのアクセスの衝突を理解する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unfortunately, linking these two instances creates a strong reference cycle between them.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>残念なことに、これらの２つのインスタンスを結ぶことは、それらの間で強い参照循環をつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unfortunately, the HTMLElement class, as written above, creates a strong reference cycle between an HTMLElement instance and the closure used for its default asHTML value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>残念なことに、このHTMLElementクラスは、上で書かれるように、HTMLElementインスタンスとその省略時のasHTML値のために使われるクロージャとの間に強い参照循環をつくります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unicode</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ユニコード</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unicode Representations of Strings</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列のユニコード表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unicode Scalar Representation</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ユニコード・スカラー表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unicode Scalar Values</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ユニコードスカラー値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unicode scalar (\u{n}), where n is a hexadecimal number that has one to eight digits</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ユニコード・スカラー（\u{n}）、ここでnは16進数で１から８桁を持ちます</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unicode scalars for regional indicator symbols can be combined in pairs to make a single Character value, such as this combination of REGIONAL INDICATOR SYMBOL LETTER U (U+1F1FA) and REGIONAL INDICATOR SYMBOL LETTER S (U+1F1F8):</seg>
      </tuv>
      <tuv lang="ja">
        <seg>地域標識記号のためのユニコード・スカラーは、単一のCharacter値を作るために２つ一組で組み合わされることが出来ます、例えばREGIONAL INDICATOR SYMBOL LETTER U（U+1F1FA）とREGIONAL INDICATOR SYMBOL LETTER S（U+1F1F8）の組み合わせのように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlabeled</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ラベルなし</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unless otherwise specified, the default access level is internal, as described in Default Access Levels.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>特に明記しない限り、省略時のアクセス水準で記述されるように、省略時のアクセス水準は内部です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unless otherwise specified, the default inferred type of a floating-point literal is the Swift standard library type Double, which represents a 64-bit floating-point number.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>特に明記しない限り、初期状態で推論されるリテラル浮動小数点の型は、スウィフト標準ライブラリ型Doubleです、それは、64ビットの浮動小数点数を表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unless otherwise specified, the default inferred type of an integer literal is the Swift standard library type Int.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>特に明記しない限り、初期状態で推論されるリテラル整数の型は、スウィフト標準ライブラリ型Intです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unless the value of integerToDescribe is in the list of known prime numbers, it isn’t matched by the first switch case at all.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>integerToDescribeの値が知っている素数のリストの中にある場合を除いて、それは最初のswitchケース節に適合することはまったくありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unless you need to work with a specific size of integer, always use Int for integer values in your code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが整数の特定のサイズを扱う必要がない限り、常に、あなたのコードの整数値のためにIntを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike public, the compiler doesn’t allow declarations marked with usableFromInline to be referenced by name in code outside the module, even though the declaration’s symbol is exported.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>publicとは違い、コンパイラはusableFromInlineで印される宣言に名前によってモジュール外部のコードにおいて参照されるのを許しません、宣言のシンボルがエクスポートされるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike flip(_:), the value that protoFlip(_:) returns isn’t required to always have the same type—it just has to conform to the Shape protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>flip(_:)とは違い、protoFlip(_:)が返す値は、常に同じ型を持つように要求されません — それは単にShapeプロトコルに準拠しなければならないだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike Any, which is defined by the language, AnyObject is defined by the Swift standard library.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>言語によって定義されるAnyとは違い、AnyObjectはSwift標準ライブラリによって定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike Boolean conditions, you can’t combine availability conditions using logical operators such as &amp;&amp; and ||.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ブール条件と違って、あなたは論理演算子例えば&amp;&amp;や||などを使って有効性条件を連結することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike C, Swift allows multiple switch cases to consider the same value or values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Cと違って、スウィフトは複数のswitchケース節に、同じ値または複数の値について考慮させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike Objective-C initializers, Swift initializers don’t return a value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Objective-Cのイニシャライザと違って、スウィフトのイニシャライザは値を返しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike a switch statement in C, this switch statement doesn’t match both "a" and "A".</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Cでのswitch文と違って、このswitch文は"a"と"A"の両方に合うものを見つけるわけではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike a default initializer, the structure receives a memberwise initializer even if it has stored properties that don’t have default values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>省略時のイニシャライザと違って、構造体はメンバー関連イニシャライザを受け取ります、たとえそれが省略時の値を持たない格納プロパティを持つとしても。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike a single-line string literal, a multiline string literal can contain unescaped double quotation marks ("), carriage returns, and line feeds.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>単一行の文字列リテラルと違い、複数行の文字列リテラルはエスケープされていない二重引用符（"）、キャリッジリターン、そしてラインフィードを含むことが出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike a subscript, however, the updateValue(_:forKey:) method returns the old value after performing an update.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、添え字とは違い、updateValue(_:forKey:)メソッドは更新を実行した後に古い値を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike a variable, the value of a constant can’t be changed after it’s set.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>変数とは異なり、それが設定された後で定数の値は変更できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike a weak reference, an unowned reference is expected to always have a value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>弱い参照とは違い、非所有参照は常に値を持つと期待されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike a weak reference, however, an unowned reference is used when the other instance has the same lifetime or a longer lifetime.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、弱い参照とは違い、非所有参照は他のインスタンスが同じ生涯またはより長い生涯を持つ場合に使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike an if statement, a guard statement always has an else clause—the code inside the else clause is executed if the condition isn’t true.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>if文と違って、guard文は常にelse節を持ちます—else節の内部のコードはその条件が真でないならば実行されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike arithmetic operators in C, arithmetic operators in Swift don’t overflow by default.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Cでの算術演算子と違って、スウィフトの算術演算子は、初期状態ではオーバフローしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike arrays, sets don’t have an equivalent shorthand form.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列とは違い、集合は相当する短縮形を持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike classes and structures, enumeration types don’t have an implicitly provided default initializer; all initializers must be declared explicitly.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスや構造体と違って、列挙型には、暗黙のうちに提供される省略時のイニシャライザがありません；全てのイニシャライザは、明確に宣言されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike classes, actors allow only one task to access their mutable state at a time, which makes it safe for code in multiple tasks to interact with the same instance of an actor.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスと異なり、アクターそれらは一度にただ１つのタスクにだけそれらの可変状態へのアクセスを許可します、それはコードにとって複数タスクにおいてあるアクターの同じインスタンスと相互作用することを安全なものにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike exception handling in many languages—including Objective-C—error handling in Swift doesn’t involve unwinding the call stack, a process that can be computationally expensive.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>多くの言語 ― Objective-Cを含めて ― での例外処理と違い、スウィフトにおけるエラー処理はコールスタック、計算的に高くつく可能性がある処理、の巻き戻し（アンワインド）を必要としません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike instance methods, subscripts can be read-write or read-only.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>インスタンスメソッドと違って、添え字は読み書き用であるか読み出し専用であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike items in an array, items in a dictionary don’t have a specified order.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列の中の項目と違って、辞書の中の項目には、指定された順番がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike lazy stored properties, global constants and variables don’t need to be marked with the lazy modifier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>遅延格納プロパティと違って、グローバルな定数と変数はlazy修飾子で印付けされる必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike many other languages, Swift doesn’t require you to write a semicolon (;) after each statement in your code, although you can do so if you wish.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>多くの他の言語とは異なり、スウィフトはあなたにあなたのコードにおいて各文の後にセミコロン（;）を書くことを要求しません、けれどもあなたが望むならば、あなたはそうできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike multiline comments in C, multiline comments in Swift can be nested inside other multiline comments.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Cでの複数行コメントと違って、スウィフトの複数行コメントは他の複数行コメント内部に入れ子にされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike other programming languages, Swift doesn’t require you to create separate interface and implementation files for custom structures and classes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>他のプログラミング言語と違って、スウィフトはあなたにあつらえの構造体およびクラスのために別々のインタフェースおよび実装ファイルを作成することを要求しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike returning a value whose type is a protocol type, opaque types preserve type identity—the compiler has access to the type information, but clients of the module don’t.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それの型があるプロトコル型である値を返すのとは違い、不透明型は型同一性を保全します — コンパイラは型情報にアクセスします、しかしモジュールのクライアントはしません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike stored instance properties, you must always give stored type properties a default value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>格納インスタンスプロパティと違って、あなたは格納型プロパティに省略時の値を常に与えなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike stored named values and stored variable properties, the value of a computed named value or a computed property isn’t stored in memory.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>格納される名前を付けられた値および格納変数プロパティと違って、計算される名前を付けられた値または計算プロパティの値は、メモリに格納されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike structures and enumerations, classes have two kinds of initializers: designated initializers and convenience initializers, as described in Initialization.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体や列挙と違って、クラスは２種類のイニシャライザを持ちます：指定イニシャライザと便宜イニシャライザ、初期化で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike structures, class instances don’t receive a default memberwise initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体と違って、クラスインスタンスは、自動生成のメンバー関連イニシャライザを授けられません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike subclasses in Objective-C, Swift subclasses don’t inherit their superclass initializers by default.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Objective-Cでのサブクラスとは異なり、スウィフトのサブクラスは、特に何もしなくてもそれらのスーパークラスのイニシャライザを継承します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike tasks that are part of a task group, an unstructured task doesn’t have a parent task.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるタスクグループの一部であるタスクそれらとは違って、非構造化タスクは親タスクを持ちません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike that example, SmallNumber also supports writing those initial values as part of declaring the property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その例とは違い、SmallNumberは、それら初期値を書き込むこともプロパティの宣言の一部としてサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike the arithmetic operators in C and Objective-C, the Swift arithmetic operators don’t allow values to overflow by default.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>CとObjective-Cの算術演算子と違って、スウィフトの算術演算子は、値がオーバフローするのを初期状態では許しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike the assignment operator in C and Objective-C, the assignment operator in Swift doesn’t itself return a value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>CとObjective-Cの代入演算子と違って、スウィフトの代入演算子は、それ自身で値を返しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike the cases in the first form, each case has an underlying value, called a raw value, of the same basic type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初の形式でのケース節と違って、それぞれのケース節は、同じ基本の型の、もととなる値、生の値と呼ばれるものを持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike the condition of an if statement, the compilation condition is evaluated at compile time.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>if文の条件とは違い、compilation condition（コンパイル条件）はコンパイル時に評価されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike the error conditions discussed in Error Handling above, assertions and preconditions aren’t used for recoverable or expected errors.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のエラー処理で議論されるエラー条件とは違い、表明と前提条件は回復できるまたは予想されたエラーに対して使われません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike value types, reference types are not copied when they’re assigned to a variable or constant, or when they’re passed to a function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>値型とは異なり、参照型は、それが変数や定数に代入される時に、あるいはそれが関数に渡される時に、コピーされません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unowned Optional References</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非所有オプショナル参照</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unowned References</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非所有参照</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unowned References and Implicitly Unwrapped Optional Properties</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非所有参照と暗黙的にアンラップされるオプショナルのプロパティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unstructured Concurrency</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造化されない並行性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Upcasting lets you use an expression as an instance of its type’s supertype, without using an intermediate variable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>アップキャストは、あなたにある式をそれのスーパータイプのインスタンスとして使用させます、中間生成物の変数の使用なしに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated Closures Are Reference Types to clarify the capturing rules for variables.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャは参照型ですを新しくして、変数に対するキャプチャ規則を明瞭にしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated Defining a Capture List to clarify the syntax for weak and unowned references in closure capture lists.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>捕獲リストの定義を新しくして、クロージャ捕獲リスト内の弱いおよび非所有参照に対する構文を明瞭にしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated Operators to explicitly mention examples of supported characters for custom operators, such as those in the Mathematical Operators, Miscellaneous Symbols, and Dingbats Unicode blocks.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>演算子を更新して、あつらえの演算子のためにサポートされる文字の例にはっきりと言及するようにしました、例えばMathematical Operators、Miscellaneous Symbols、そしてDingbatsユニコードブロックにおけるそれら。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated Protocol Declaration to clarify protocol declaration scope and members.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル宣言を新しくして、プロトコル宣言スコープおよびメンバーを明瞭にしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated Range Operators to note that a half-open range with the same start and end index will be empty.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>範囲演算子を新しくして、同じ開始および終止インデックスを持つ半開範囲が空になることを記しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated Value Overflow to clarify the overflow behavior of signed and unsigned integers</seg>
      </tuv>
      <tuv lang="ja">
        <seg>値オーバフローを新しくして、符号つき及び符号なし整数のオーバフロー挙動を明瞭にしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated a note in the Property Observers section to clarify the behavior of willSet and didSet observers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>節プロパティオブザーバーをwillSetとdidSetオブザーバーの挙動を理解しやすくするために更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated a note in the Type Properties section to mention that stored type properties are lazily initialized.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型プロパティ節の注を更新して、格納型プロパティが遅延して初期化されることに言及した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated and expanded the Comparing Strings section to reflect and demonstrate that string and character comparison and prefix / suffix comparison are now based on Unicode canonical equivalence of extended grapheme clusters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>節文字列を比較するを更新および拡張して、文字列および文字比較と接頭辞／接尾辞比較が今では拡張書記クラスタのユニコード正準等価に基づかれることを反映し例示しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated attribute arguments to use a colon in the Attributes chapter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>属性引数をコロンを使うように章属性において更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated discussion throughout to use macOS instead of OS X, Error instead of ErrorProtocol, and protocol names such as ExpressibleByStringLiteral instead of StringLiteralConvertible.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>解説を隅から隅まで更新してmacOSをOS Xの代わりに、ErrorをErrorProtocolの代わりに、ExpressibleByStringLiteralのようなプロトコル名をStringLiteralConvertibleの代わりに使うようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated figures in the Weak References section to show the deallocation process more clearly.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>弱い参照節の図を更新して、デアロケーション過程をより明瞭に見せるようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated for Swift 1.1.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Swift 1.1にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated for Swift 1.2.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Swift 1.2にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated for Swift 2.0.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Swift 2.0にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated for Swift 2.1.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Swift 2.1にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated for Swift 2.2.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Swift 2.2にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated for Swift 3.0.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Swift 3.0にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated for Swift 3.0.1.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Swift 3.0.1にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated for Swift 3.1.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Swift 3.1にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated for Swift 4.0.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Swift 4.0にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated for Swift 4.0.3.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Swift 4.0.3にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated for Swift 4.1.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Swift 4.1にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated for Swift 4.2.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Swift 4.2にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated for Swift 5.0.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Swift 5.0にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated for Swift 5.1.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Swift 5.1にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated for Swift 5.2.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Swift 5.2にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated for Swift 5.3.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Swift 5.3にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated for Swift 5.4.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Swift 5.4にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated for Swift 5.5.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Swift 5.5にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated for Swift 5.6.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Swift 5.6にふさわしく更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated information about initializers that return nil before the instance is fully initialized in the Failable Initializers section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>インスタンスが完全に初期化される前にnilを返すイニシャライザについての情報を失敗できるイニシャライザ節において更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Accessing Properties Through Optional Chaining section to clarify how assignment through optional chaining behaves.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナル連鎖を通してプロパティにアクセスする節を更新して、オプショナル連鎖を通した割り当てがどのように振る舞うかを明確にした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Accessing and Modifying a Dictionary section to note that Dictionary now has a Boolean isEmpty property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>辞書へのアクセスと修正の節を更新してDictionaryが今やブールのisEmptyプロパティを持つことを記しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Accessing and Modifying an Array section to note that you can no longer append a single item to an array with the += operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>節配列へのアクセスと変更を更新して、あなたがもはや単一の項目を+=演算子を使って配列に加えることが出来ないことを注記しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Attributes chapter to note that the @IBAction, @IBOutlet, and @NSManaged attributes imply the @objc attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>属性の章を更新して、@IBAction、@IBOutlet、そして@NSManaged属性が@objc属性を暗示することを注記した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Break Statement section with information about labeled break statements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>節ブレーク文をラベルをつけられたブレーク文についての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Capturing Values section to clarify how variables and constants are captured in closures.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>値を捕獲する節を更新してどのように変数と定数がクロージャにキャプチャされるかをわかりやすくした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Concatenating Strings and Characters section to reflect the fact that String and Character values can no longer be combined with the addition operator (+) or addition assignment operator (+=).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列と文字の連結節をStringとCharacter値はもはや加算演算子（+）または加算代入演算子（+=）を使って結合されることができないという事実を反映するために更新しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Declaration Attributes and Conditional Compilation Block sections with information about tvOS.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>宣言属性と条件コンパイルブロック節をtvOSについての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Declaration Attributes section to describe when you can apply the @objc attribute to classes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>宣言属性節を更新してあなたが@objc属性をクラスへ適用できる場合を記述した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Declaration Attributes section with information about the @available and @warn_unused_result attributes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>節宣言属性を@availableと@warn_unused_result属性についての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Enumeration Case Pattern section, now that an enumeration case pattern can match an optional value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙ケース節パターンの節を更新しました、今では列挙ケース節パターンはオプショナル値にマッチできるので。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Escaping Closures section, now that closures can refer to self implicitly in more scenarios.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>脱出クロージャの節を更新しました、今ではクロージャは暗黙的にselfを参照することがより多くの筋書きにおいて可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Explicit Member Expression section with information about using #if around chained method calls and other postfix expressions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>明示的メンバー式の節を#ifを連鎖メソッド呼び出しおよび他の接尾辞式のまわりで使うことについての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Expressions chapter to separate the discussion of parenthesized expressions and tuple expressions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>式の章を更新して、括弧で囲まれた式とタプル式の解説を分離した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Handling Errors Using Do-Catch and Do Statement sections, now that a catch clause can match against multiple errors.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>do-catchを使ってエラーを処理するおよびDo文の節を更新しました、今ではcatch節は複数のエラーに対して組み合わせ可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Identifiers section with information about identifiers that start with an underscore.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>識別子の節をアンダースコアで始まる識別子についての情報で更新しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Implicit Member Expression section, now that implicit member expressions can be chained together.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>暗黙のメンバー式の節を更新しました、今では暗黙のメンバ式は１つに連結されることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Implicitly Unwrapped Optionals section to make it clearer that an implicitly unwrapped optional value can be used as either an optional or non-optional value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>暗黙的にアンラップされるオプショナルの節を更新した、暗黙的にアンラップされるオプショナル値がオプショナルまたは非オプショナル値のどちらとしても使用できることをより明確にするため。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Initializer Inheritance and Overriding section to note that overrides of a designated initializer must now be marked with the override modifier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>節イニシャライザの継承とオーバーライドを更新して、指定イニシャライザのオーバーライドは今やoverride修飾子で印付けされなければならないことを注記しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Key-Path Expression section, now that key paths support subscript components.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>キーパス式の節を更新した、今ではキーパスは添え字を構成要素としてサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Memberwise Initializers for Structure Types section, now that memberwise initializers support omitting parameters for properties that have a default value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体型のためのメンバー関連イニシャライザの節を更新しました、今ではメンバー関連イニシャライザは、省略時の値を持つプロパティに対してパラメータを省略することをサポートするので。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Memory Safety chapter to mention atomic operations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メモリ安全の章を更新して、不可分操作（アトミックオペレーション）に軽く触れました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Operators section with discussion of custom operators that contain a dot.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>演算子節をドットを含むカスタム演算子の議論で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Property Observers section, now that lazy properties can have observers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティオブザーバの節を更新しました、今では遅延プロパティはオブザーバを持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Protocol Declaration section, now that members of an enumeration can satisfy protocol requirements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>フロトコル宣言の節を更新しました、今では列挙のメンバーはプロトコル要件を満たすことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Repeat-While section with information about the repeat-while loop.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>節この間繰り返すをrepeat-whileループについての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Representing and Throwing Errors section, now that all types can conform to the ErrorType protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>エラーの表現とスロー節を更新した、現在ではすべての型がErrorTypeプロトコルに準拠できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Required Initializers section to note that the required modifier is now written before every subclass implementation of a required initializer, and that the requirements for required initializers can now be satisfied by automatically inherited initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>節必須イニシャライザを更新して、required修飾子が今やすべてのサブクラス実装の必須イニシャライザの前に書かれること、そして必須イニシャライザのための必要条件は今や自動的に継承されるイニシャライザで満たされることが出来るのを注記しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Self Type section, now that Self can be used to refer to the type introduced by the current class, structure, or enumeration declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Self型の節を加えました、今ではSelfは現在のクラス、構造体、または列挙宣言によって導入される型を参照するために使われることができるので。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Self Type section, now that the Self can be used in more contexts.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Self型の節を更新した、今ではSelfはより多くの文脈で使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Special Characters in String Literals section with a more precise definition of Unicode scalars.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>節文字列リテラル内の特別な文字をユニコードスカラーのより精密な定義づけで更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Stored Variable Observers and Property Observers section to describe when the getter is called before the observer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>格納された変数オブザーバーとプロパティオブザーバーの節を更新して、オブザーバの前にゲッターが呼び出されるのはいつかを記述しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the String Interpolation and String Literals sections now that string interpolations can contain string literals.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列補間と文字列リテラル節を更新した、今では文字列補間は文字列リテラルを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the String Literals section to note that Unicode scalars inside string literals are now written as \u{n}, where n is a hexadecimal number between 0 and 10FFFF, the range of Unicode’s codespace.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列リテラルの節を更新して文字列内部のユニコード・スカラーが今や\u{n}のように書かれることを記しました、ここでnは０から10FFFまでの16進数、ユニコードの符号空間です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Strings and Characters chapter to reflect the fact that Swift’s Character type now represents a single Unicode extended grapheme cluster.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列と文字の章を、スウィフトのCharacter型が今や単一のユニコード拡張書記素クラスタを表わすという事実を反映するために更新しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Strings and Characters chapter, now that String no longer conforms to the CollectionType protocol from the Swift standard library.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>節文字列と文字を更新した、現在ではStringはもはやスウィフト標準ライブラリ由来のCollectionTypeプロトコルに準拠しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Subscript Options section, now that subscripts support parameters with default values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字オプションの節を更新した、今では添え字は省略時の値をもつパラメータをサポートします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Type Annotations section to note that multiple related variables can be defined on a single line with one type annotation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型注釈の節を更新して複数の関連する変数が１行だけで１つの型注釈で定義されることが出来ることを記しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Type Attributes section with information about the @convention attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>節型属性を@convention属性についての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Type Properties section with information about stored and computed type properties for classes, structures, and enumerations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>節型プロパティをクラス、構造体、そして列挙のための格納および計算型プロパティについての情報で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Variadic Parameters and Function Declaration sections, now that a function can have multiple variadic parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>可変長パラメータと関数宣言の節を更新しました、現在では関数は複数の可変長パラメータを持つことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Variadic Parameters section, now that variadic parameters can be declared in any position in a function’s parameter list.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>可変長パラメータ節を更新した、現在では可変長パラメータは関数のパラメータリストの中のあらゆる位置で宣言されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the Operators reference to describe the revised rules.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>改められた規則を記述するために演算子リファレンスを更新しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the definition of Unicode scalars in string literals.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列リテラルの中のユニコードスカラーの定義を新しくしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the discussion about default parameters in the Default Parameter Values section, now that they can’t be reordered in function calls.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>省略時のパラメータについての議論を省略時のパラメータ値の節で更新した、今ではそれらは関数呼び出しにおいて再配列されることが出来ないので。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the discussion in Functions that Never Return to use the new Never type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>決して返らない関数での議論を更新して新しいNever型を使うようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the discussion in the Escaping Closures section, now that closures are nonescaping by default.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャを脱出するの節において議論を更新した、今ではクロージャは初期状態で非脱出です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the discussion in the Function Type section to note that argument labels aren’t allowed when writing a function type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数型節での議論を更新して、引数ラベルは関数型を書いている時に許可されないことを注記した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the discussion in the Function Type section, now that Swift distinguishes between functions that take multiple parameters and functions that take a single parameter of a tuple type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数型の節での議論を更新した、今ではスウィフトは複数のパラメータを取る関数とただ１つのタプル型のパラメータを取る関数の間の区別をするので。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the discussion in the Generic Where Clauses section of the Generics chapter and in the Generic Parameters and Arguments chapter, now that generic where clauses are written at the end of a declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体where節の節で総称体の章において、そして総称体パラメータと引数の章においてその議論を更新した、今では総称体where節は宣言の最後に書かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the discussion in the In-Out Parameters section to note that only nonescaping closures can capture in-out parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>in-outパラメータの節において解説を更新して、非脱出クロージャのみがin-outパラメータをキャプチャできることを注記した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the discussion in the Optional Binding section of the The Basics chapter and the While Statement section of the Statements chapter, now that if, while, and guard statements use a comma-separated list of conditions without where clauses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルを束縛するの節を基本の章で、そしてwhile文の節を文の章でその議論を更新した、今ではif、while、そしてguard文はコンマで区切られた条件リストをwhere節なしで使うからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the discussion in the Protocol Composition section of the Protocols chapter, and in the Protocol Composition Type section of the Types chapter, now that protocol composition types can contain a superclass requirement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>議論をプロトコル合成の節でプロトコルの章において、そしてプロトコル合成型の節で型の章において更新した、今ではプロトコル合成型はスーパークラス要件を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the discussion in the Dynamic Type Expression section to use the new type(of:) syntax for dynamic type expressions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>「動的型式」の節において議論を更新して、 新しいtype(of:)構文を動的型式に使うようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the discussion of inout in the Function Declaration section to note that it appears in front of a parameter’s type instead of in front of a parameter’s name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>inoutの議論を関数宣言の節において更新して、それが現れるのはパラメータの持つ型の前で、パラメータの名前の前でないことを注記した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the discussion of Swift language version numbers in the Conditional Compilation Block section, now that an optional patch number is allowed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフト言語バージョン番号の議論を条件比較ブロックの節において更新した、今では随意のパッチ番号が許可されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the discussion of associated types to use the associatedtype keyword in the Associated Types and Protocol Associated Type Declaration sections.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関連型の議論をassociatedtypeキーワードを使うように関連型とプロトコル関連型宣言の節で更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the discussion of function types in the Function Type section now that function argument labels are no longer part of a function’s type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数型の解説を節関数型において更新した、今では関数引数ラベルはもはや関数の型の一部ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the discussion of function types in the Function Type section to note that parentheses around the parameter types are required.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数型の解説を節関数型において更新して、パラメータ型の周りの丸括弧は必要とされることを注記した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the discussion of functions in the Functions chapter and the Function Declaration section to note that all parameters get an argument label by default.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数の解説を関数の章と関数宣言の節において更新して、すべてのパラメータが引数ラベルを初期状態で受け取ることを注記した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the discussion of line control statements to use the #sourceLocation(file:line:) syntax in the Line Control Statement section.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>行制御文の解説を#sourceLocation(file:line:)構文を使うように行制御文の節において更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the discussion of operators in the Advanced Operators chapter, now that you implement them as type methods instead of as global functions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>演算子の議論を先進の演算子の章において更新した、今ではあなたはそれらをグローバル関数としてではなく型メソッドとして実装するからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the discussion of optional protocol requirements in the Optional Protocol Requirements section to clarify that they’re used only in code that interoperates with Objective-C.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルプロトコル要件の解説を節オプショナルのプロトコル要件において更新して、それらがObjective-Cと相互運用するコードにおいてのみ使用されることを明確にした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the discussion of protocol composition types in the Protocol Composition section of the Protocols chapter and in the Protocol Composition Type section of the Types chapter to use the new Protocol1 &amp; Protocol2 syntax.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル合成型の議論をプロトコル合成の節でプロトコルの章において、そしてプロトコル合成型の節で型の章において更新して、新しいProtocol1 &amp; Protocol2構文を使うようにした。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the discussion of protocol extensions in Extension Declaration now that final isn’t allowed in them.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル拡張の議論を拡張宣言において更新した、今ではfinalはそれらにおいて許可されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the discussion of the @NSManaged attribute in the Declaration Attributes section, now that the attribute can be applied to certain instance methods.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>@NSManaged属性の議論を宣言属性節において更新した、現在ではこの属性は特定のインスタンスメソッドに適用されることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the discussion of the @noescape and @autoclosure attributes in the Escaping Closures and Autoclosures sections and the Attributes chapter now that they’re type attributes, rather than declaration attributes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>@noescapeと@autoclosure属性の議論を脱出クロージャと自動クロージャの節および属性の章で更新した、今ではそれらは型属性です、宣言属性ではなくて。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the discussion of the @objc attribute in the Declaration Attributes section to note that enumerations and enumeration cases can use this attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>@objc属性についての議論を宣言属性において更新して、列挙と列挙ケースがこの属性を使用できることを注記した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the discussion of the objc attribute in Declaration Attributes, now that this attribute is inferred in fewer places.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>objc属性の議論を宣言属性において更新した、現在この属性はいくつかの場所で推論されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the discussion of weak and unowned references in the Automatic Reference Counting chapter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>弱いそして非所有参照の議論を自動参照カウントの章において更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the entire book to refer to ..&lt; as the Half-Open Range Operator (rather than the “half-closed range operator”).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>..&lt;を半開範囲演算子と言うように本全体を更新しました（「半完結範囲演算子」ではなしに）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the example in Type Casting for Any and AnyObject to show how to check for and cast to a function type within a switch statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>AnyおよびAnyObjectに対する型キャストでの例を更新して、switch文内のある関数型について調べてキャストする方法を示しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the information about Memberwise Initializers for Structure Types to clarify that the memberwise structure initializer is made available even if a structure’s stored properties don’t have default values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体型のためのメンバー関連イニシャライザについての情報が更新されて、メンバー関連の構造体初期化子が、ある構造体の持つ格納プロパティが省略時の値を持たなくてさえも、利用可能にされることをわかりやすくされました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the information about Mutability of Collections and Arrays to reflect the new approach.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>新しい取り組み方を反映するために、コレクションの可変性および配列についての情報が更新されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the rules for constant and constant property declaration and initialization.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数と定数プロパティの宣言と初期化についての規則を新しくしました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated the visual styling of figures throughout.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>図の視覚的形式をすっかり更新した。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updated to ..&lt; rather than .. for the Half-Open Range Operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>半開範囲演算子に対して..ではなく..&lt;に更新しました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Updating the budget is a two-step process: First you add the items’ names and prices, and then you change the total amount to reflect the items currently on the list.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>予算案の更新は２段階の処理です：最初にあなたはその項目の名前と値段を加えます、それからあなたは総支出額を変更してそれら項目の現在をリスト上に反映します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Upper- or lowercase letter A through Z</seg>
      </tuv>
      <tuv lang="ja">
        <seg>大文字または小文字のAからZ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use ..&lt; to make a range that omits its upper value, and use ... to make a range that includes both values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>..&lt;をその上側の値を除く範囲を作るために使ってください、そして...を両方の値を含む範囲を作るために使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use Any and AnyObject only when you explicitly need the behavior and capabilities they provide.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが明白にそれらが提供する挙動と能力を必要とする時にだけ、AnyとAnyObjectを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use UInt only when you specifically need an unsigned integer type with the same size as the platform’s native word size.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが特にプラットホーム固有のワードサイズと同じ大きさで符号なし整数型を必要とする時にだけUIntを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use \() to include a floating-point calculation in a string and to include someone’s name in a greeting.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>\()を、浮動小数点計算を文字列に含めるために、そして誰かの名前をある挨拶に含めるために使ってみてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use class followed by the class’s name to create a class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるクラスを作成するためにclassを使ってその後にそのクラスの名前を続けてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use defer to write a block of code that’s executed after all other code in the function, just before the function returns.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>deferを使って関数の中の全ての他のコードの後で、その関数が返る直前に実行されるひとかたまりのコードを書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use deinit to create a deinitializer if you need to perform some cleanup before the object is deallocated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オブジェクトが割り当て解除される前にあなたがいくらかの掃除をする必要があるならば、デイニシャライザをつくるために、deinitを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use enum to create an enumeration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙をつくるために、enumを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use extension to add functionality to an existing type, such as new methods and computed properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>機能性、例えば新しいメソッドや計算プロパティなどを、既存の型に加えるために、extensionを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use fileprivate(set), private(set), and internal(set) to change the access level of this synthesized setter in exactly the same way as for an explicit setter in a computed property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>fileprivate(set)、private(set)、そしてinternal(set)を使って、計算プロパティにおける明示的なセッターと正確に同じ方法で、この総合されたセッターのアクセス水準を変更してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use func to declare a function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>funcを使うことで、あるひとつの関数を宣言してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use iOS, macOS, watchOS, and tvOS for the platform names, and include the corresponding version numbers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プラットホーム名としてiOS、macOS、watchOS、そしてtvOSを、付随するバージョン番号を含めて使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use if and switch to make conditionals, and use for-in, while, and repeat-while to make loops.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>条件文を作るためにifとswitchを使ってください、そしてループを作るためにfor-in、while、そしてrepeat-whileを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use let to make a constant and var to make a variable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>letを使って定数を作りvarを使って変数を作ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use protocol to declare a protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるプロトコルを宣言するために、protocolを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use struct to create a structure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>構造体を作成するために、structを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use throw to throw an error and throws to mark a function that can throw an error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるエラーをスローする（投げかける）ためにthrowを、そしてエラーをスローできる関数に印をつけるためにthrowsを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use where right before the body to specify a list of requirements—for example, to require the type to implement a protocol, to require two types to be the same, or to require a class to have a particular superclass.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>本文のまさに前に、必要なことのリストを指定するためにwhereを使ってください ― 例えば、型があるプロトコルを実装することを要求するために、２つの型が同じものであることを要求するために、またはあるクラスがある特定のスーパークラスを持つことを要求するために。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use while to repeat a block of code until a condition changes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>whileを使って、コードのひとかたまり（ブロック）を、ある条件が変化するまで繰り返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use -&gt; to separate the parameter names and types from the function’s return type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>-&gt;を使って、パラメーター名とその関数の返す型とを隔ててください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use in to separate the arguments and return type from the body.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>inを使って、引数および返す型を本文から切り離してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use init to create one.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そうしたものをつくるために、initを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use a class-only protocol when the behavior defined by that protocol’s requirements assumes or requires that a conforming type has reference semantics rather than value semantics.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラス専用プロトコルを、そのプロトコルの要件によって定義される挙動が想定されるまたは必要とされる時、準拠する型が値意味論ではなく参照意味論を持つ時に、使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use a line control statement to change the source code location used by Swift for diagnostic and debugging purposes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>行制御文を使ってスウィフトによって使われるソースコード位置を診断上のそしてデバッグの目的で変更してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use a new key of the appropriate type as the subscript index, and assign a new value of the appropriate type:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字インデックスとして適切な型の新しいキーを使ってください、そして適切な型の新しい値を割り当ててください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use a precondition whenever a condition has the potential to be false, but must definitely be true for your code to continue execution.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある条件が偽である可能性をもつ、しかしdefinitelyがあなたのコードの実行の継続のためにtrueでなければならない時はいつでも前提条件を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use a single break statement if you don’t intend to execute any code in the body of a matched case.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがマッチされたケース節の本文において何らコードを実行するつもりでないならば、ただ１つbreak文を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use a string literal as an initial value for a constant or variable:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列リテラルを定数または変数の初期値として使ってください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use a tuple to make a compound value—for example, to return multiple values from a function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある混成の値を作るために、タプル（一組にしたもの）を使ってください ― 例えば、関数から複数の値を返すために。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use a weak reference when the other instance has a shorter lifetime—that is, when the other instance can be deallocated first.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>弱い参照を他のインスタンスがより短い生涯を持つ場合に使ってください — すなわち、他のインスタンスが最初にでアロケートされることが可能である時。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use a wildcard pattern when you don’t care about the values being matched against.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがマッチされている値を気にかけない場合に、ワイルドカード・パターンを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use an initializer expression to construct an instance of a type from that type’s metatype value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>イニシャライザ式を使って、ある型のインスタンスをその型のメタタイプ値から組み立ててください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use an unowned reference only when you are sure that the reference always refers to an instance that hasn’t been deallocated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非所有参照を、その参照が常にデアロケートされていないインスタンスに言及するとあなたが確信する時にだけ使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use comments to include nonexecutable text in your code, as a note or reminder to yourself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなた自身への注意事項または覚え書きとして、実行可能でないテキストをあなたのコードに含めるために、コメントを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use dot syntax to access the properties and methods of the instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのインスタンスのプロパティおよびメソッドにアクセスするためにドット構文を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use file-private access to hide the implementation details of a specific piece of functionality when those details are used within an entire file.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それら詳細があるファイル全体の内部で使われる時に、機能性のある特定部分のそれら実装詳細を隠すために、ファイル外非公開アクセスを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use optional chaining to conditionally perform an operation on an implicitly unwrapped optional expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある暗黙的にアンラップされるオプショナルの式に関して演算を条件付きで実行するために、オプショナル連鎖を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use other integer types only when they’re specifically needed for the task at hand, because of explicitly sized data from an external source, or for performance, memory usage, or other necessary optimization.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>外部ソース由来の明確に大きさを設定されたデータのために、またはパフォーマンス、メモリ使用、または他の必要な最適化のためになど、目下の作業に特に必要とされる時にだけ、他の整数を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use private access to hide the implementation details of a specific piece of functionality when those details are used only within a single declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それら詳細がある単一の宣言内部でのみ使われる時に、機能性のある特定部分のそれら実装詳細を隠すために、非公開アクセスを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use statement labels with break and continue statements to be explicit about how you want to change control flow in a loop statement or a switch statement, as discussed in Break Statement and Continue Statement below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>breakとcontinue文で文ラベルを使って、あなたがループ文またはswitch文においてどのように制御の流れを変えたいかについて明示してください、下記のブレーク文と継続文で議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use the Int type for all general-purpose integer constants and variables in your code, even if they’re known to be nonnegative.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Int型を全ての一般的な目的のための整数の定数と変数に対してあなたのコードにおいて使ってください、たとえそれらが負数でないことが知られているとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use the indices property to access all of the indices of individual characters in a string.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>indicesプロパティを使って、ある文字列中の個々の文字のインデックスの全てにアクセスしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use the init?(rawValue:) initializer to make an instance of an enumeration from a raw value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>init?(rawValue:)イニシャライザを使用して、生の値から列挙のインスタンスを作ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use the intersection(_:) method to create a new set with only the values common to both sets.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>intersection(_:)メソッドを使って両方の集合に共通した値だけを持つ新しい集合を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use the isDisjoint(with:) method to determine whether two sets have no values in common.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>isDisjoint(with:)メソッドを使って２つの集合が共通の値を全く持たないかどうか判定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use the isStrictSubset(of:) or isStrictSuperset(of:) methods to determine whether a set is a subset or superset, but not equal to, a specified set.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>isStrictSubset(of:)またはisStrictSuperset(of:)メソッドを使ってある集合がある指定した集合の下位集合または上位集合、しかし等しくはない、かどうか決定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use the isSubset(of:) method to determine whether all of the values of a set are contained in the specified set.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>isSubset(of:)メソッドを使ってある集合のすべての値が指定した集合の値の中に含まれるかどうか決定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use the isSuperset(of:) method to determine whether a set contains all of the values in a specified set.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>isSuperset(of:)メソッドを使ってある集合がある指定した集合の値のすべてを含むかどうか決定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use the startIndex property to access the position of the first Character of a String.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるStringの最初のCharacterの位置にアクセスするためにstartIndexプロパティを使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use the subtracting(_:) method to create a new set with values not in the specified set.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>subtracting(_:)メソッドを使って指定した集合にない値を持つ新しい集合を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use the symmetricDifference(_:) method to create a new set with values in either set, but not both.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>symmetricDifference(_:)メソッドを使ってどちらかの集合にある、しかし両方にではない値を持つ新しい集合を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use the union(_:) method to create a new set with all of the values in both sets.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>union(_:)メソッドを使って両方の集合のすべての値を持つ新しい集合を作成してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use the String type’s append(_:) method to append a single Character value onto the end of a string.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>String型のappend(_:)メソッドを単一のCharacter値を文字列の終わりに加えるために使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use the stride(from:to:by:) function to skip the unwanted marks.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>stride(from:to:by:)関数を使って、不必要な印を飛ばしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use the rawValue property to access the raw value of an enumeration case.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>rawValueプロパティを使用して、列挙ケース節の生の値にアクセスしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use the type check operator (is) to check whether an instance is of a certain subclass type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>型確認演算子（is）を使用して、あるインスタンスが特定のサブクラス型であるかどうか調べてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use the Boolean isEmpty property as a shortcut for checking whether the count property is equal to 0:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ブールのisEmptyプロパティをcountプロパティが0と等しいかどうかを調べる近道として使ってください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use the classes defined above to create a new Person instance, and try to access its numberOfRooms property as before:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>上のクラス定義を使って、新しいPersonインスタンスをつくって、前のようにそのnumberOfRoomsプロパティにアクセスすることを試みてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use the conditional form of the type cast operator (as?) when you aren’t sure if the downcast will succeed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがダウンキャストが成功するかどうかよくわからない場合には、条件形式の型キャスト演算子（as?）を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use the forced form of the type cast operator (as!) only when you are sure that the downcast will always succeed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがダウンキャストが常に成功すると確信する場合には、強制形式の型キャスト演算子（as!）を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use the half-open range operator (..&lt;) to include the lower bound but not the upper bound.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>半開範囲演算子（..&lt;）を使って、下方の境界を含めて、しかし上方の境界を含めないようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use the ternary conditional operator with care, however.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかし、注意して三項条件演算子を使用してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use the “is equal” operator (==) to determine whether two sets contain all of the same values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>「同等」演算子（==）を使って２つの集合がすべて同じ値を含むかどうか決定してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use these operators to check whether two constants or variables refer to the same single instance:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２つの定数または変数が同じ１つのインスタンスに言及するかどうか調べるためにこれらの演算子を使用してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use this approach if you need to add a potential failure state to an existing initialization process that doesn’t otherwise fail.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが、起こりうる失敗状況を、その場合にも失敗しない既存の初期化プロセスに加える必要がある場合に、このやり方を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use this attribute to help discourage ambiguity between functions with the same name that are accessible from the same scope.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性を使って、関数とその同じスコープからアクセス可能な同じ名前との間の曖昧さを防止するのに役立ててください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use this form of an access-level modifier when you want to specify an access level for the setter of a variable or subscript that’s less than or equal to the access level of the variable or subscript itself, as discussed in Getters and Setters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>アクセス水準修飾子のこの形式は、あなたが変数または添え字のセッターにその変数または添え字それ自身のアクセス水準よりもより少ないか等しいアクセス水準を指定することを望むときに使ってください、ゲッターとセッターで議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use this form to access a type as a value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>値として型にアクセスするために、この形式を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use three double quotation marks (""") for strings that take up multiple lines.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>複数行にわたる文字列のために３つの二重引用符（"""）を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use variables only for storing values that need to be able to change.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>変更できる必要がある値を保存するためにだけ、変数を使ってください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Using &amp; instead of an explicit function like withUnsafePointer(to:) can help make calls to low-level C functions more readable, especially when the function takes several pointer arguments.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>&amp;をwithUnsafePointer(to:)のような明示的な関数の代わりに使うことは、低レベルC関数への呼び出しをより読みやすくする助けとなりえます、とりわけ関数がいくつかのポインタ引数を取る場合には。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Using try? lets you write concise error handling code when you want to handle all errors in the same way.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>try?を使うことで、あなたに簡潔なエラー処理コードを書くことを可能にするのは、あなたがすべてのエラーを同じやり方で取り扱いたい時です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Using ARC in Swift is very similar to the approach described in Transitioning to ARC Release Notes [https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html] for using ARC with Objective-C.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトでのARCの使用は、Objective-CでARCを使うためのTransitioning to ARC Release Notes [https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html]で記述される取り組みに非常に似ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Using Function Types</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数型を使う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Using a guard statement for requirements improves the readability of your code, compared to doing the same check with an if statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>guard文を必要条件に対して使うことは、あなたのコードの可読性を同じ検査確認をif文を使って実行するのと比べて向上します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Using a Protocol in Its Associated Type’s Constraints</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるプロトコルをそれの関連型のもつ制約において使用する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Using a generic where clause lets you add a new requirement to the extension, so that the extension adds the isTop(_:) method only when the items in the stack are equatable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体where節を使うことは、あなたに新しい要件をその拡張に追加させます、それで拡張はisTop(_:)メソッドをスタックの中の項目が同等評価可能なものである時のみ加えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Using a protocol as a type is sometimes called an existential type, which comes from the phrase “there exists a type T such that T conforms to the protocol”.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルを型として使うことは、ときどき存在型と呼ばれます、それは語句 “そこに型Tが存在する、そのようなTはそのプロトコルに準拠する” から来ています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Using a protocol type as the return type for a function gives you the flexibility to return any type that conforms to the protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル型を戻り型として関数に使うことは、あなたに、そのプロトコルに準拠するどんな型でも返す柔軟性を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Using assertions and preconditions isn’t a substitute for designing your code in such a way that invalid conditions are unlikely to arise.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>表明と前提条件を使用することは、無効な条件が思いもよらず起こるようなあなたのコードの設計に対する代役ではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Using explicitly sized types in these situations helps to catch any accidental value overflows and implicitly documents the nature of the data being used.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これらの状況において明示的に大きさを設定された型を使うことは、偶発的な何らかの値のオーバフローを捕えることや、使われているデータの性質を暗黙的に記録することの手助けになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Using optionals is similar to using nil with pointers in Objective-C, but they work for any type, not just classes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルの使用は、Objective-Cのポインターでnilを使うことに似ています、しかしそれは、ただクラスだけでなく、どんな型のためにでも働きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Using the ! operator to unwrap an optional that has a value of nil results in a runtime error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>!演算子を使ってnilの値を持つあるオプショナルをアンラップすることは、実行時エラーの結果になります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Using the gameLoop label makes it clear which control statement should be terminated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>gameLoopラベルを使用することは、どの制御文が終了されなければならないかを明確にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Using the default integer type in everyday situations means that integer constants and variables are immediately interoperable in your code and will match the inferred type for integer literal values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>日々の状況において初期状態として整数型を使うことは、整数の定数と変数があなたのコードにおいて直接に情報交換が可能で、いろいろな整数のリテラル値に対して推論される型と調和することを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Using the opaque type some Container as a return type expresses the desired API contract—the function returns a container, but declines to specify the container’s type:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>不透明型some Containerを戻り型として使うことは、望まれるAPI契約を表現します — 関数はあるコンテナ（容れ物）を返します、しかしコンテナのもつ型を指定することを辞退します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Using this attribute is equivalent to calling the NSApplicationMain(_:_:) function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性を使用することは、NSApplicationMain(_:_:)関数を呼ぶことに相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Using this attribute is equivalent to calling the UIApplicationMain function and passing this class’s name as the name of the delegate class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この属性を使用することは、UIApplicationMain関数を呼んで、このクラスの名前を委任先クラスの名前として渡すことに相当します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Using this synthesized implementation means you don’t have to write repetitive boilerplate code to implement the protocol requirements yourself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この合成実装を使うことは、あなたが繰り返しの常用文コードを書いてプロトコル要件をあなた自身で実装する必要はないのを意味します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Valid arguments</seg>
      </tuv>
      <tuv lang="ja">
        <seg>有効な引数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Value</seg>
      </tuv>
      <tuv lang="ja">
        <seg>値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Value Bindings</seg>
      </tuv>
      <tuv lang="ja">
        <seg>値束縛</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Value Overflow</seg>
      </tuv>
      <tuv lang="ja">
        <seg>値オーバフロー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Value types (structures and enumerations) don’t support inheritance, and so their initializer delegation process is relatively simple, because they can only delegate to another initializer that they provide themselves.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>値型（構造体と列挙）は、継承をサポートしません、なので、それらのイニシャライザ委任プロセスは比較的単純です、なぜなら、それらがそれら自身で提供する別のイニシャライザに委任できるだけだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Value types are described in Structures and Enumerations Are Value Types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>値型は「構造体と列挙は値型です」で記述されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Value-Binding Pattern</seg>
      </tuv>
      <tuv lang="ja">
        <seg>値束縛パターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Value-binding patterns that bind a matched value to the name of a constant begin with the let keyword; those that bind to the name of variable begin with the var keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>マッチした値を定数の名前に束縛する値束縛パターンは、letキーワードで始まります；変数の名前と縛りつけるものは、varキーワードで始まります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Values are captured in key paths using value semantics.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>様々な値は、キーパスの中に値意味論を使ってキャプチャされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Values are never implicitly converted to another type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>なんらかの値が暗黙のうちに別の型に変換されることは決してありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Values in switch cases can be checked for their inclusion in an interval.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>switchケース節における値は、ある区間におけるそれの包含について調べられることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Values in the matrix can be set by passing row and column values into the subscript, separated by a comma:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>行列の中の値は、コンマで区切った行と列の値を添え字に渡すことによって設定されることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Variable Declaration</seg>
      </tuv>
      <tuv lang="ja">
        <seg>変数の宣言</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Variable declarations have several forms that declare different kinds of named, mutable values, including stored and computed variables and properties, stored variable and property observers, and static variable properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>変数宣言はいくつかの形式を持ちます、それらは、格納および計算の変数およびプロパティ、格納である変数およびプロパティのオブザーバー、そして静的変数プロパティを含む、異なる種類の名前をつけられた可変の値を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Variables and constants declared in the scope of a do statement can be accessed only within that scope.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>do文のスコープ内で宣言される変数と定数は、そのスコープ内でのみアクセスされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Variables are always initialized before use.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>変数は、常に使用前に初期化される。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Variadic Parameters</seg>
      </tuv>
      <tuv lang="ja">
        <seg>可変長パラメータ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Variadic parameters are allowed, subject to the same rules as for normal methods.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>可変長パラメータは、許され、普通のメソッドと同じ規則の支配下にあります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Variadic parameters can be used if you name the variadic parameter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが可変長パラメータに名前をつけるならば、可変長パラメータが使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Version Compatibility</seg>
      </tuv>
      <tuv lang="ja">
        <seg>バージョン互換性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We can’t wait to see what you create with it.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>私達は、あなたがそれで何をつくるか知るのが待ち切れません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Weak References</seg>
      </tuv>
      <tuv lang="ja">
        <seg>弱い参照</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Weak and Unowned References</seg>
      </tuv>
      <tuv lang="ja">
        <seg>弱いおよび非所有参照</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Weak and unowned references enable one instance in a reference cycle to refer to the other instance without keeping a strong hold on it.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>弱いおよび非所有参照は、ある参照循環の中の１つのインスタンスに、他のインスタンスに言及することをそれに対する強い支配力を持つことなく可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Weak references are always of an optional type, and automatically become nil when the instance they reference is deallocated.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>弱い参照は常にオプショナルの型です、そしてそれが参照をつけるインスタンスが割り当て解除されるとき、自動的にnilになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Welcome to Swift</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトにようこそ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What about the second and third blocks?</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２番目と３番目のブロックはどうですか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What changes do you need to make to SimpleClass and SimpleStructure so that they still conform to the protocol?</seg>
      </tuv>
      <tuv lang="ja">
        <seg>どんな変更をあなたはSimpleClassとSimpleStructureにする必要があるでしょうか、それらが依然としてそのプロトコルに準拠するためには？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What error do you get?</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、どんなエラーを得ますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What greeting do you get?</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、どんな挨拶を得ますか？</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What kind of error do you need to throw so that the error is handled by the first catch block?</seg>
      </tuv>
      <tuv lang="ja">
        <seg>エラーが最初のcatchブロックによって取り扱われるためには、どんな種類のエラーをあなたはスローする必要があるでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When cinema was given the current value of hd, the values stored in hd were copied into the new cinema instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>cinemaがhdの現在の値を与えられたとき、hdに格納される値は新しいcinemaインスタンスにコピーされました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When log() is called on the instance that’s passed to doSomething(_:), the customized title is omitted from the logged string.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>log()がdoSomething(_:)に渡されるインスタンス上で呼び出される時、カスタマイズされたタイトルはログ文字列から省かれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When printMathResult(_:_:_:) is called, it’s passed the addTwoInts(_:_:) function, and the integer values 3 and 5.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>printMathResult(_:_:_:)が呼ばれるとき、それは、addTwoInts(_:_:)関数、そして整数値3と5を渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When rememberedDirection is assigned the value of currentDirection, it’s actually set to a copy of that value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>rememberedDirectionがcurrentDirectionの値を代入されるとき、それは実際にはその値のコピーに設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When index is modified, the key-path expression still references the third element, while the closure uses the new index.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>indexが修正される時、キーパス式は依然として３番目の要素に参照を付けます、一方でクロージャは新しいインデックスを使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When residence is nil, as in the example above, this optional Int will also be nil, to reflect the fact that it was not possible to access numberOfRooms.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>residenceがnilのとき、上の例の場合のように、このオプショナルのIntはまたnilになり、numberOfRoomsにアクセスすることは可能でなかったという事実を反映します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When a break statement is followed by the name of a statement label, it ends program execution of the loop, if statement, or switch statement named by that label.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>break文に文ラベルの名前が続くとき、それはそのラベルによって指定されるループ、if文、またはswitch文のプログラム実行を終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When a break statement isn’t followed by the name of a statement label, it ends program execution of the switch statement or the innermost enclosing loop statement in which it occurs.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>break文に文ラベルの名前が続かないとき、それはswitch文またはそれが現れているところの最も内側のそれを囲んでいるループ文のプログラム実行を終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When a continue statement is followed by the name of a statement label, it ends program execution of the current iteration of the loop statement named by that label.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>continue文に文ラベルの名前が続くとき、それは、そのラベルによって指名されるループ文の現在の繰り返しのプログラム実行を終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When a continue statement isn’t followed by the name of a statement label, it ends program execution of the current iteration of the innermost enclosing loop statement in which it occurs.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>continue文に文ラベルの名前が続かないとき、それは、それが現れるところの一番内側のそれを囲んでいるループ文の現在の繰り返しのプログラム実行を終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When a return statement is followed by an expression, the value of the expression is returned to the calling function or method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>return文の後に式が続くとき、式の値は関数またはメソッドを呼んでいるところに返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When a return statement isn’t followed by an expression, it can be used only to return from a function or method that doesn’t return a value (that is, when the return type of the function or method is Void or ()).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>return文の後に式が続かないとき、それは値を返さない関数またはメソッド（すなわち、戻り型がVoidまたは()である関数またはメソッド）から返るためにだけ使われることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When a Unicode string is written to a text file or some other storage, the Unicode scalars in that string are encoded in one of several Unicode-defined encoding forms.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるUnicode文字列がテキスト・ファイルまたは何か他の記憶装置に書かれるとき、その文字列内のユニコード・スカラーはいくつかのUnicode定義の符号化方式のうちの１つで符号化されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When a channel’s audio level is 0, none of the lights for that channel are lit.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>チャンネルの音声のレベルが0であるとき、そのチャンネルのための光のどれも点灯されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When a class implements an initializer to satisfy a protocol’s initializer requirement, the initializer must be marked with the required declaration modifier if the class isn’t already marked with the final declaration modifier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるクラスがプロトコルのイニシャライザ要件を満たすためにイニシャライザを実装するとき、そのイニシャライザはrequired宣言修飾子を使って印される必要が、そのクラスが既にfinal宣言修飾子を使って印されていないならば、あります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When a closure is the only argument to a function, you can omit the parentheses entirely.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ひとつのクロージャが関数の唯一の引数である時、あなたは丸括弧をすっかり省くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When a closure’s type is already known, such as the callback for a delegate, you can omit the type of its parameters, its return type, or both.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クロージャの型がすでに知られているとき、例えば委任先のためのコールバックなどでは、あなたはそのパラメータの型、その戻り型、あるいは両方を省略することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When a concrete type conditionally conforms to a protocol, that type implicitly conforms to any parent protocols with the same requirements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>具象型があるプロトコルに条件準拠するとき、その型は同じ要件を持つあらゆる親プロトコルに暗黙的に準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When a constant declaration occurs in the context of a class or structure declaration, it’s considered a constant property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数宣言がクラスまたは構造体宣言の文脈において起こるとき、それは定数プロパティとみなされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When a constant declaration occurs in the context of a function or method, it can be initialized later, as long as it’s guaranteed to have a value set before the first time its value is read.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数宣言が関数またはメソッドの文脈において現れるとき、それは後で初期化されることができます、それがある値をその値が読み出される最初の時の前に設定されてしまっているよう保証する限りは。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When a constant is declared at global scope, it must be initialized with a value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数がグローバルなスコープで宣言されるとき、それはひとつの値で初期化されなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When a declaration is obsoleted, it’s removed from the specified platform or language and can no longer be used.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある宣言が廃止された場合は、それは指定されたプラットホームまたは言語から取り除かれます、そしてもはや使用されることはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When a function encounters an error condition, it throws an error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある関数がエラー状態に遭遇するとき、それはあるエラーをスローします（投げます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When a function throws an error, it changes the flow of your program, so it’s important that you can quickly identify places in your code that can throw errors.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある関数がエラーをスローするとき、それはあなたのプログラムの流れを変えます、そのため重要なのは、あなたがすばやくあなたのコードの中のエラーをスローできる場所を識別することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When a library’s authors mark an enumeration as nonfrozen, they reserve the right to add new enumeration cases, and any code that interacts with that enumeration must be able to handle those future cases without being recompiled.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるライブラリの作者たちがある列挙を非凍結として印する時、彼らは新しい列挙ケース節を加える権利を有します、そしてその列挙と相互作用する何らかのコードは、それらの未来ケース節を再コンパイルされることなしに取り扱いできる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When a member has the same name as a keyword, references to that member don’t need to be escaped with backticks, except when there’s ambiguity between referring to the member and using the keyword—for example, self, Type, and Protocol have special meaning in an explicit member expression, so they must be escaped with backticks in that context.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるメンバがあるキーワードと同じ名前を持つ時、そのメンバへの参照はバッククォートでエスケープされる必要はありません、そのメンバへの参照とキーワードの使用の間に曖昧さがある場合を除いては—例えば、self、Type、そしてProtocolは、特別な意味をある明示的なメンバ式の中で持ちます、それでそれらはバッククォートでエスケープされることがその文脈においては必要です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When a protocol composition type contains type aliases, it’s possible for the same protocol to appear more than once in the definitions—duplicates are ignored.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるプロトコル合成型が型エイリアスを含む場合、同じプロトコルが複数回定義の中に現れることが可能です — 重複は無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When a protocol type inherits from other protocols, the set of requirements from those other protocols are aggregated together, and any type that inherits from the current protocol must conform to all of those requirements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル型が他のプロトコルから継承するとき、それらの他のプロトコルからの要件ひとそろいは一緒にまとめられます、そして、現在のプロトコルから継承するどんな型でもそれらの要件の全てに準拠しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When a protocol type inherits from other protocols, the set of requirements from those other protocols are aggregated, and any type that inherits from the current protocol must conform to all those requirements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるプロトコル型が他のプロトコルから継承するとき、それらの他のプロトコルからの要件一式は、ひとまとめにされます、そして現在のプロトコルから継承するどんな型でも、それらの要件の全てに従わなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When a single else clause is present, an if statement has the following form:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ただ１つだけのelse節が含まれている時は、if文は以下の形式を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When a trailing closure is matched to a parameter whose type structurally resembles a function type, but isn’t a function, the closure is wrapped as needed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>後付クロージャが、それの型が構造的に関数型と似ている、しかし関数でないパラメータと組み合わされる場合、クロージャは必要に応じてラップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When a tuple pattern is used as the pattern in a for-in statement or in a variable or constant declaration, it can contain only wildcard patterns, identifier patterns, optional patterns, or other tuple patterns that contain those.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>タプルパターンがfor-in文においてまたは変数や定数宣言においてパターンとして使われるとき、それはワイルドカード・パターン、識別子パターン、オプショナルパターン、またはそれらを含む他のタプルパターンだけを含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When a type alias is declared with generic parameters, the constraints on those parameters must match exactly the constraints on the existing type’s generic parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある型エイリアスが総称体パラメータで宣言されるとき、それらのパラメータ上の制約は厳密に既存の型の持つ総称体パラメータ上の制約に一致しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When a variable declaration of this form is declared at global scope or the local scope of a function, it’s referred to as a computed variable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この形式の変数の宣言がグローバルなスコープまたは関数のローカルなスコープで宣言されるとき、それは計算変数と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When a variable declaration of this form is declared at global scope or the local scope of a function, it’s referred to as a stored variable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この形式の変数の宣言がグローバルなスコープまたは関数のローカルなスコープで宣言されるとき、それは格納変数と呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When a variable declaration of this form is declared at global scope or the local scope of a function, the observers are referred to as stored variable observers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この形式の変数の宣言がグローバルなスコープまたは関数のローカルスコープで宣言されるとき、オブザーバーは格納変数オブザーバーと呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When accessing the elements in a multidimensional array, the left-most subscript index refers to the element at that index in the outermost array.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>多次元配列の要素にアクセスするとき、最も左の添え字インデックスは、最も外側の配列の中のそのインデックスでの要素に言及します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When alternative productions are too long to read easily, they’re broken into multiple grammar production rules on new lines.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>代替の導出が簡単に読むにはあまりに長いとき、それらが新しい行で複数部分の文法導出規則へとばらされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When an element of a tuple type has a name, that name is part of the type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるタプル型の要素が名前を持つ場合、その名前は型の一部です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When an error is thrown, some surrounding piece of code must be responsible for handling the error—for example, by correcting the problem, trying an alternative approach, or informing the user of the failure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるエラーがスローされるとき、なかには周囲のコード部分がエラーを処理することに対して責任を持たなければならないこともあります ― 例えば、問題を訂正すること、代わりの取り組みを試みること、または失敗をユーザに知らせることによって。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When an instance of a value type is marked as a constant, so are all of its properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>値型のインスタンスが定数として印される時は、そのプロパティの全てがそうです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When calling an asynchronous method, execution suspends until that method returns.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非同期メソッドを呼び出す時、遂行はそのメソッドが戻るまで中断されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When considered in isolation, the nested incrementer() function might seem unusual:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>切り離して考えたとき、入れ子にされたincrementer()関数は普通でないものに見えるかもしれません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When creating a selector for a property’s getter, the property name can be a reference to a variable or constant property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロパティのゲッターのためのセレクタを作成するとき、property nameは変数または定数プロパティへの参照であることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When defining a class, the name of the superclass must appear first in the list of type identifiers, followed by any number of protocols the class must conform to.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>クラスを定義するとき、スーパークラスの名前は型識別子のリストにおいて最初に現れなければなりません、そしてそのクラスが準拠しなければならないいくらかのプロトコルが続きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When defining a protocol, it’s sometimes useful to declare one or more associated types as part of the protocol’s definition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルを定義するとき、時々役に立つのは、プロトコルの定義の一部として１つ以上の関連型を宣言することです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When implicitly converting an array to an unsafe pointer, Swift ensures that the array’s storage is contiguous by converting or copying the array as needed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列からアンセーフポインタへの暗黙的変換の場合、スウィフトは、配列のもつストレージが隣接することを配列を必要に応じて変換または複製することによって確実にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When it isn’t appropriate to provide a case for every enumeration case, you can provide a default case to cover any cases that aren’t addressed explicitly:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>すべての列挙ケース節にcaseを提供することが妥当でないとき、あなたは明確に指定されないあらゆる場合を扱うためにdefaultケース節を提供することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When it’s declared in the context of a class or structure declaration, it’s referred to as a stored variable property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それがクラスまたは構造体宣言の文脈において宣言されるとき、それは格納変数プロパティと呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When it’s declared in the context of a class or structure declaration, the observers are referred to as property observers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それがクラスまたは構造体宣言の文脈において宣言されるとき、オブザーバーはプロパティオブザーバーと呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When it’s declared in the context of a class, structure, or extension declaration, it’s referred to as a computed property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それがクラス、構造体、または拡張宣言の文脈において宣言されるとき、それは計算プロパティと呼ばれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When one class inherits from another, the inheriting class is known as a subclass, and the class it inherits from is known as its superclass.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるクラスが他のものから継承するとき、継承を受けているクラスはサブクラスとして知られています、そして、そこからそれが譲り受ける原点のクラスは、それのスーパークラスとして知られています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When set to true, an operator in the corresponding precedence group uses the same grouping rules during optional chaining as the assignment operators from the standard library.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>trueに設定する場合、対応する優先順位グループの演算子は標準ライブラリ由来のassignment（割り当て）演算子と同じグループ化規則をオプショナル連鎖の間に使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When specifying the type annotation for a literal value, the annotation’s type must be a type that can be instantiated from that literal value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あるリテラル値に型注釈を指定するとき、その注釈の型は、そのリテラル値からインスタンス化されることができる型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When strings are used for raw values, the implicit value for each case is the text of that case’s name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字列が生の値のために使われる時、各ケース節のための暗黙的な値は、そのケース節の名前のテキストです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When switching over a nonfrozen enumeration value, you always need to include a default case, even if every case of the enumeration already has a corresponding switch case.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>非凍結列挙値に対してスイッチしている時、あなたは常にdefaultケース節を含む必要があります、たとえ列挙のあらゆるケース節が既に対応するスイッチケース節を持つとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When that case is matched by the switch statement, the break statement inside the case ends the switch statement’s execution immediately.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのケース節がswitch文によってマッチされるとき、ケース節の内側のbreak文は直ちにswitch文の実行を終えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When the log() method is called on oneAndTwo directly, the specialized version containing the title string is used.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>log()メソッドがoneAndTwoにおいて直接に呼び出される時、タイトル文字列を含んでいる特殊化版が使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When the audio level is 10, all of the lights for that channel are lit.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>音声のレベルが10であるとき、そのチャンネルのための光の全ては点灯されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When the compiler isn’t in library evolution mode, all structures and enumerations are implicitly frozen, and this attribute is ignored.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>コンパイラがライブラリ進化モードではない場合、全ての構造体と列挙は暗黙的に凍結されます、そしてこの属性は無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When the enumeration type can be inferred from context, you can omit it (the dot is still required), as described in Enumeration Syntax and Implicit Member Expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>列挙型が前後関係から推論されることができるとき、列挙構文と暗黙のメンバー式で記述されるように、あなたはそれを省略することができます（ドットは依然必要です）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When the expression on the left-hand side of an infix operator is marked with try, try?, or try!, that operator applies to the whole infix expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある接中辞演算子の左手側での式がtry、try?、またはtry!で印される場合、その演算子は接中辞式全体に適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When the expression on the left-hand side of an infix operator is marked with the await operator, that operator applies to the whole infix expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある接中辞演算子の左手側での式がawait演算子で印される場合、その演算子は接中辞式全体に適用されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When the function is called, the value of the argument is copied.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数が呼ばれる時、その引数の値はコピー（複製）をつくられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When the function returns, the copy’s value is assigned to the original argument.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数が戻る時、コピーの値はそのオリジナルの（元の）引数に代入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When the match succeeds, the value 42 is bound (assigned) to the constant name someValue.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>マッチが成功するとき、値42は、定数の名前のsomeValueに縛りつけられます（代入されます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When the pattern on the left-hand side of a variable or constant declaration is an identifier pattern, the identifier pattern is implicitly a subpattern of a value-binding pattern.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>変数や定数宣言の左側のパターンが識別子パターンであるとき、その識別子パターンは暗黙のうちに値束縛パターンの下位パターンです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When the second function is called, the message is still printed by the first function, but the returned value isn’t used.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>第二の関数が呼ばれるとき、メッセージは最初の関数によって依然として出力されます、しかし返された値は使われません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When this detailed form is used, only the imported symbol (and not the module that declares it) is made available in the current scope.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この詳細な書式が使われるとき、インポートされたシンボルだけが（そしてそれを宣言するモジュールでなく）、現在のスコープにおいて利用可能にされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When this simply isn’t feasible (for example, when the control expression’s type is Int), you can include a default case to satisfy the requirement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これが単に実行可能でないとき（たとえば、制御式のもつ型がIntであるとき）、あなたはこの必要条件を満たすために省略時のケース節を含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When two operators compete with each other for their operands, such as in the expression 2 + 3 * 5, the operator with the higher relative precedence binds more tightly to its operands.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>２つの演算子がそれらの演算数に対して互いと比較される時、例えば式2 + 3 * 5などで、より高い関係優先順位を持つ演算子はよりきつくそれの演算数に束縛されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When used as the default value of a function or method parameter, the special literal’s value is determined when the default value expression is evaluated at the call site.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数およびメソッドのパラメータの省略時の値として使われる時、特殊リテラルの値は、省略時値式が呼び出し現場で評価される場合は決定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When used inside a switch statement, break causes the switch statement to end its execution immediately and to transfer control to the code after the switch statement’s closing brace (}).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>switch文の中に使われるとき、breakによってswitch文が直ちにその実行を終えて、switch文の閉じ波括弧（}）の後のコードへ制御を移します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When used inside a loop statement, break ends the loop’s execution immediately and transfers control to the code after the loop’s closing brace (}).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ループ文の内側で使われるとき、breakは直ちにループの実行を終えて、ループの閉じ波括弧（}）の後のコードへ制御を移します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When working with optional values, you can write ? before operations like methods, properties, and subscripting.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルの値を扱うとき、あなたはメソッド、プロパティ、そして添え字指定のような演算の前に?を書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you access a projected value from code that’s part of the type, like a property getter or an instance method, you can omit self. before the property name, just like accessing other properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがある投影値に、プロパティゲッターやインスタンスメソッドのようなその型の一部であるコードからアクセスする場合、あなたはself.をプロパティ名の前で省略できます、ちょうど他のプロパティにアクセスするように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you access a property or method of an actor, you use await to mark the potential suspension point—for example:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがアクターのプロパティまたはメソッドにアクセスする時、あなたはawaitを使うことで潜在的な中断地点を印します — 例えば：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you access a subscript on an optional value through optional chaining, you place the question mark before the subscript’s brackets, not after.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがオプショナル連鎖を通してオプショナルの値の上で添え字にアクセスするとき、あなたは添え字の角括弧の前に疑問符を置きます、後ろではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you apply a wrapper to a property and you don’t specify an initial value, Swift uses the init() initializer to set up the wrapper.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがラッパーをプロパティに適用するそしてあなたが初期値を指定しないならば、スウィフトはinit()イニシャライザを使ってラッパーを準備します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you apply a wrapper to a property, the compiler synthesizes code that provides storage for the wrapper and code that provides access to the property through the wrapper.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがあるラッパーをプロパティに適用する場合、コンパイラは、そのラッパーに対するストレージを提供するコードそしてそのラッパーに通してプロパティへのアクセスを提供するコードを合成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you apply this attribute to a type, you create a custom attribute with the same name as the type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがこの属性をある型に適用する場合、あなたはあるあつらえの属性をその型と同じ名前で作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you assign a closure to a property, you are assigning a reference to that closure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがクロージャをプロパティに代入するとき、あなたは参照をそのクロージャに代入しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you assign a default value to a stored property, or set its initial value within an initializer, the value of that property is set directly, without calling any property observers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがある格納プロパティに省略時の値を代入する、またはその初期値をイニシャライザの内部で設定するとき、そのプロパティの値は、どんなプロパティオブザーバーも呼び出すことなく、直接に設定されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you call a function that can throw an error, you prepend the try keyword to the expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがエラーをスローできる関数を呼ぶとき、あなたはtryキーワードをその式の前に追加します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you call a memberwise initializer, you can omit values for any properties that have default values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがメンバー関連イニシャライザを呼び出す場合、あなたは省略時の値を持つあらゆるプロパティに対して値を省略できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you call an overloaded generic function or initializer, the compiler uses these constraints to resolve which overloaded function or initializer to invoke.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがオーバーロードされた総称体関数またはイニシャライザを呼ぶとき、コンパイラはこれらの制約を使って、呼び出すことになるオーバーロードされた関数またはイニシャライザはどれか決定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you call this function to load a picture, you provide two closures.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがこの関数を呼び出してあるピクチャをロードする時、あなたは２つのクロージャを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you call those functions, you use the special syntax that DrawingBuilder defines.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがそれらの関数を呼び出す場合、あなたはDrawingBuilderが定義する特別な構文を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you declare a call-as-function method, you specify the number of arguments, and each argument’s type and label.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがcall-as-functionメソッドを宣言する場合、あなたは引数の数、そして各引数のもつ型およびラベルを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you declare a function that takes a closure as one of its parameters, you can write @escaping before the parameter’s type to indicate that the closure is allowed to escape.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがある関数、それのパラメータの１つとしてクロージャをとるものを宣言する時、あなたは@escapingをパラメータの型の前に書くことによって、そのクロージャが脱出を許可されるのを指し示すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you declare a generic type, function, subscript, or initializer, you specify the type parameters that the generic type, function, or initializer can work with.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがある総称体型、添え字、関数、またはイニシャライザを宣言するとき、あなたはその総称体型、関数、またはイニシャライザが扱うことができる型パラメータを指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you define a function, you can optionally define one or more named, typed values that the function takes as input, known as parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがある関数を定義するとき、あなたは随意にその関数が入力としてとる、１つ以上の名前をつけられ型付けされた値、パラメータとして知られるものを定義できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you define a protocol extension, you can specify constraints that conforming types must satisfy before the methods and properties of the extension are available.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがプロトコル拡張を定義するとき、あなたは準拠している型がその拡張のメソッドやプロパティが利用可能になる前に満たさなければならない制約を指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you define your own custom structures and classes, it’s your responsibility to decide what qualifies as two instances being equal.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが独自のあつらえのクラスと構造体を定義するとき、２つのインスタンスが等しくなる基準は何かを決めるのはあなたの責任です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you define your own structures, classes, and enumerations, it can be useful to provide your own implementations of the standard Swift operators for these custom types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがあなた自身の構造体、クラス、そして列挙を定義するとき、標準のスウィフト演算子のあなた自身の実施をそれらあつらえの型のために提供することは役に立つことがありえます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you develop a framework, mark the public-facing interface to that framework as open or public so that it can be viewed and accessed by other modules, such as an app that imports the framework.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがフレームワークを開発する場合、そのフレームワークを開放または公開するために公開向けインタフェースとして印してください、それで、他のモジュール、例えばそのフレームワークをインポートするアプリによってそれが見られてアクセスされることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you do so, you must mark the overridden subscript declaration with the override declaration modifier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがそうするとき、あなたはオーバーライドされる添え字宣言をoverride宣言修飾子で印しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you don’t, Swift automatically assigns the values for you.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがそうしない時は、スウィフトはあなたの代わりに自動的に値を割り当てます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you extend a generic type, you don’t provide a type parameter list as part of the extension’s definition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがある総称体型を拡張する時、あなたは型パラメーターリストを拡張の定義の一部として提供しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you get a substring from a string—for example, using a subscript or a method like prefix(_:)—the result is an instance of Substring [https://developer.apple.com/documentation/swift/substring], not another string.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがある文字列から下位文字列を得る場合 — 例えば、添え字またはprefix(_:)のようなメソッドを使って — その結果はSubstring [https://developer.apple.com/documentation/swift/substring]のインスタンスとなります、別の文字列ではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you include property wrapper arguments, you can also specify an initial value using assignment.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがプロパティラッパー引数を含める場合、あなたはまた代入を使って初期値を指定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you make a copy of stepSize before calling increment(_:), it’s clear that the value of copyOfStepSize is incremented by the current step size.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがstepSizeのコピーをincrement(_:)を呼び出す前に作る場合、それはcopyOfStepSizeの値が現在の段階量だけ漸増されることを明確にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you mark a member declaration with the dynamic modifier, access to that member is always dynamically dispatched using the Objective-C runtime.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがメンバー宣言をdynamic修飾子で印する時は、そのメンバーへのアクセスは、常に動的にObjective-Cランタイムを使用してディスパッチされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you provide a method, property, or subscript override for a subclass, it’s sometimes useful to use the existing superclass implementation as part of your override.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがサブクラスのためにメソッド、プロパティ、または添え字のオーバーライドを提供する時、既存のスーパークラスの実装をあなたのオーバーライドの一部として使うことは時々役に立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you specify an initial value for the property, Swift uses the init(wrappedValue:) initializer to set up the wrapper.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが初期値をプロパティに対して指定する場合、スウィフトはinit(wrappedValue:)イニシャライザを使ってラッパーを準備します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you use Any as a concrete type for an instance, you need to cast the instance to a known type before you can access its properties or methods.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがAnyを具象型としてインスタンスに対して使う場合、あなたはそのインスタンスを既知の型へとキャストすることを、あなたがそれのプロパティまたはメソッドにアクセスする前に必要とします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you use Xcode 13 to build Swift 4 and Swift 4.2 code, most Swift 5.6 functionality is available.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがXcode 13を使ってSwift 4とSwift 4.2コードをビルドする場合、ほとんどのSwift 5.6機能性が利用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you use a key-path string expression within a class, you can refer to a property of that class by writing just the property name, without the class name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがキーパス文字列式をあるクラス内で使う時、あなたはそのクラスのプロパティを参照することが、クラス名なしで単にそのプロパティ名を書くことによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you use a method or property in an optional requirement, its type automatically becomes an optional.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがオプショナルの要件の中のメソッドやプロパティを使うとき、それの型は自動的にオプショナルになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you use a property wrapper, you write the management code once when you define the wrapper, and then reuse that management code by applying it to multiple properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがプロパティラッパーを使う場合、あなたは管理コードを一度だけあなたがラッパーを定義する時に書きます、そしてそれからその管理コードを、それを複数のプロパティに適用することによって再利用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you use an implicitly unwrapped optional value, Swift first tries to use it as an ordinary optional value; if it can’t be used as an optional, Swift force-unwraps the value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがある暗黙的にアンラップされるオプショナル値を使う場合、Swiftはまずそれを普通のオプショナル値として使おうと試みます；それがオプショナルとして使用できないならば、Swiftは値を強制アンラップします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you use subscript syntax, the index you specify needs to be valid.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが添え字構文を使う時、あなたが指定するインデックスは有効である必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you use the trailing closure syntax, you don’t write the argument label for the first closure as part of the function call.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが後付クロージャ構文を使うとき、あなたは、その最初のクロージャに対して関数呼び出しの一部として引数ラベルを書きません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you work with values whose type is a protocol type, methods outside the protocol definition aren’t available.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その型があるプロトコル型である値をあなたが扱うとき、そのプロトコル定義の外部のメソッドは利用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you write = 1 on a property with a wrapper, that’s translated into a call to the init(wrappedValue:) initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが= 1をラッパーをもつプロパティ上で記述する場合、それはinit(wrappedValue:)イニシャライザへの呼び出しに変換されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you write a simple single-target app, the code in your app is typically self-contained within the app and doesn’t need to be made available outside of the app’s module.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが単純な単一ターゲットアプリを書いている場合、あなたのアプリのコードは概してそのアプリの内部に自身で持っていて、そしてそのアプリのモジュールの外側で利用可能にされることは必要ありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you write a subclass initializer that matches a superclass designated initializer, you are effectively providing an override of that designated initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがスーパークラスの指定イニシャライザと一致するあるサブクラス・イニシャライザを書く時、あなたは事実上その指定イニシャライザのオーバーライドを提供しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you write an app with a unit test target, the code in your app needs to be made available to that module in order to be tested.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがユニットテストターゲットを使ってアプリを書く場合、あなたのアプリのコードはテストされるためにそのモジュールに対して利用可能にされる必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you write arguments in parentheses after the custom attribute, Swift uses the initializer that accepts those arguments to set up the wrapper.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが引数を丸括弧の中であつらえの属性の後に書く場合、スウィフトはそれらの引数を受け入れるイニシャライザを使ってそのラッパーを準備します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you write or extend a type to conform to a protocol, you must ensure that the type’s implementation of each protocol requirement has at least the same access level as the type’s conformance to that protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがある型をプロトコルに準拠するように書く、または拡張する時は、あなたはその型のもつ各プロトコル要件の実装が少なくともそのプロトコルに対するその型の準拠と同じアクセス水準を持つことを確かにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you write the name of a generic superclass class after the colon, you must include the full name of that generic class, including its generic parameter clause.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがコロンの後に総称体スーパークラスの名前を書く時、あなたはその総称体クラスの名前全体を、それの総称体パラメーター節を含めて書く必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When your source code includes a line break inside of a multiline string literal, that line break also appears in the string’s value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたのソースコードがある複数行文字列リテラルの内部に改行を含む場合、その改行はまたその文字列の持つ値の中に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you’re ready to store the result for a longer time, you convert the substring to an instance of String.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが結果を長期間にわたって格納しようとする場合、あなたは下位文字列をStringのインスタンスへと変換します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you’re working with enumerations that store integer or string raw values, you don’t have to explicitly assign a raw value for each case.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが整数や文字列の生の値を格納する列挙を使って作業している時、あなたは各ケース節に生の値を明示的に割り当てる必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Whenever a new Chessboard instance is created, the closure is executed, and the default value of boardColors is calculated and returned.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>新しいChessboardインスタンスがつくられるときはいつでも、このクロージャは実行されます、そしてboardColorsの省略時の値が計算されて、返されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Whenever a new instance of the type that the property belongs to is initialized, the closure or function is called, and its return value is assigned as the property’s default value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのプロパティが属している型の新しいインスタンスが初期化されるときはいつでも、そのクロージャまたは関数が呼ばれます、そしてその戻り値はプロパティの省略時の値として代入されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Whenever an object in the array conforms to the HasArea protocol, the optional value returned by the as? operator is unwrapped with optional binding into a constant called objectWithArea.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>配列のオブジェクトがHasAreaプロトコルに準拠するときはいつでも、as?演算子によって返されるオプショナルの値は、オプショナル束縛によってobjectWithAreaと呼ばれる定数へとアンラップされます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Whenever possible, transformations are coalesced.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>可能な時はいつでも、変換それらは合体させられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Whenever this return value equals 7, the dice roll has become too large and is reset to a value of 1.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この戻り値が7に等しいときはいつでも、そのさいころの目は大きくなり過ぎているので、値1へ設定し直されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Whenever you assign a function or a closure to a constant or a variable, you are actually setting that constant or variable to be a reference to the function or closure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが関数やクロージャを定数または変数に代入するときはいつでも、あなたは実際はその定数または変数が関数やクロージャへの参照であると設定しています。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Whenever you define a new structure or class, you define a new Swift type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが新しいクラスまたは構造体を定義するときはいつでも、あなたはある新しいスウィフト型を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Whenever you set the currentSpeed property of an AutomaticCar instance, the property’s didSet observer sets the instance’s gear property to an appropriate choice of gear for the new speed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがAutomaticCarインスタンスのcurrentSpeedプロパティを設定したときはいつでも、そのプロパティのdidSetオブザーバーは、そのインスタンスのgearプロパティを新しい速度のために適切な選択に設定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Where this is appropriate, you access the superclass version of a method, property, or subscript by using the super prefix:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>これがふさわしい所で、あなたはsuper接頭辞を使用することによってスーパークラス版のメソッド、プロパティ、または添え字にアクセスします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Where you believe this is the case, you can try to downcast to the subclass type with a type cast operator (as? or as!).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがこの場合であると思う所で、あなたはサブクラス型へのダウンキャストを試みることが型キャスト演算子（as?またはas!）を使ってできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Wherever you use tenEighty, you also have to think about the code that uses alsoTenEighty, and vice versa.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがtenEightyを使うどこであれ、あなたはまたalsoTenEightyを使うコードについて頭を働かせなければなりません、そして逆もまた同様に。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>While</seg>
      </tuv>
      <tuv lang="ja">
        <seg>最初に評価</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>While Loops</seg>
      </tuv>
      <tuv lang="ja">
        <seg>whileループ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>While Statement</seg>
      </tuv>
      <tuv lang="ja">
        <seg>while文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>While it’s most common for a subscript to take a single parameter, you can also define a subscript with multiple parameters if it’s appropriate for your type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>添え字がただ１つのパラメータをとることが最も普通であるけれども、あなたはまた、それがあなたの型に適切ならば、複数のパラメータをもつ添え字を定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>While the asynchronous code is running, the caller waits for that code to finish before moving on to run the next line of code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある非同期コードが動作している間、呼び出し側は、コードの次の行を実行するために移動する前に、そのコードが終了するのを待ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>While this code’s execution is suspended, some other concurrent code in the same program runs.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このコードの遂行が中断される間、何らかの他の並行性コードは同じプログラムの中で動作します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>While you’re adding items to the budget, it’s in a temporary, invalid state because the total amount hasn’t been updated to reflect the newly added items.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが項目を予算案に加えている間、それは一時的な、無効な状態にあります、なぜなら総支出額は新しく追加された項目を反映するよう更新されていないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Whitespace and Comments</seg>
      </tuv>
      <tuv lang="ja">
        <seg>空白とコメント</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Whitespace has two uses: to separate tokens in the source file and to distinguish between prefix, postfix, and infix operators (see Operators), but is otherwise ignored.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>空白には、２つの用途があります：ソース・ファイルの中のトークンを切り離すため、そして接頭辞、接尾辞、および接中辞演算子の間の区別をするため（演算子を見てください）、しかしそれ以外では無視されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Wildcard Expression</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ワイルドカード式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Wildcard Pattern</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ワイルドカード・パターン</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>With a conditional statement, you can use a statement label with the break statement to end the execution of the labeled statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>条件文では、あなたは文ラベルをbreak文とともに使うことで、ラベルをつけられた文の実行を終えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>With a few exceptions, a function of any calling convention can be used when a function any other calling convention is needed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>2、3の例外がありますが、何らかの呼出規約の関数は、何らかの他の呼出規約の関数が必要とされる場合に使用可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>With a loop statement, you can use a statement label with the break or continue statement to end or continue the execution of the labeled statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ループ文では、あなたは文ラベルをbreakまたはcontinue文とともに使うことで、ラベルをつけられた文の実行を終えたり継続したりすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>With an optional tuple type, the entire tuple is optional, not just each individual value within the tuple.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルタプル型では、タプル全体がオプショナルです、単にタプルの内部の個々の値それぞれではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>With the exception of the implicit unwrapping behavior, the following two declarations are equivalent:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>暗黙的にアンラップされる挙動を除けば、以下の２つの宣言は等しいです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>With those settings, the following code prints all three messages:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらの設定で、以下のコードは３つのメッセージすべてを出力します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Within a function, don’t access a value that was passed as an in-out argument, even if the original value is available in the current scope.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数内部で、in-out引数として渡された値にアクセスしないでください、たとえその元の値が現在のスコープにおいて利用可能であるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Within the body of a type method, the implicit self property refers to the type itself, rather than an instance of that type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある型メソッドの本文内で、暗黙のselfプロパティはその型自身に言及します、その型のインスタンスではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Within the method, both self and teammate refer to the same location in memory—as shown in the figure below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>メソッド内部で、selfおよびteammateの両方がメモリ中の同じ位置を参照します — 下の図で示すように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Without the self prefix, Swift would assume that both uses of x referred to the method parameter called x.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>self接頭辞なしでは、スウィフトは両方のxの使用がxと呼ばれるメソッドパラメータに言及したものと仮定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Without the extension to explicitly declare conditional conformance to Loggable, the other Array extensions would implicitly create these declarations, resulting in an error:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張がLoggableへの条件準拠を明示的に宣言することなしには、他のArray拡張は、結果としてエラーになるこれら宣言を暗黙的に作成するでしょう。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Without this conversion in place, the addition would not be allowed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>適切なこの変換なしでは、この加算は許されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Without this requirement, Dictionary couldn’t tell whether it should insert or replace a value for a particular key, nor would it be able to find a value for a given key that’s already in the dictionary.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この要件なしでは、Dictionaryはそれが特定のキーのために値を差し込んだり取り替えたりするべきかどうか伝えることができませんし、それはすでに辞書の中にある指定されたキーに対する値を見つけることもできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Without this type alias, the sum function would have to refer to the associated type as T.Iterator.Element instead of T.Element.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>この型エイリアスな時では、sum関数は関連値をT.Iterator.Elementのように参照しなければならないでしょう、T.Elementではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Working back down from the top of the chain, each designated initializer in the chain has the option to customize the instance further.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>連鎖の最上部から逆に階層を下って、連鎖の中の各指定イニシャライザは、さらにインスタンスを好みに合わせて作り変える選択肢を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Working with Characters</seg>
      </tuv>
      <tuv lang="ja">
        <seg>文字を扱う</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Wrap the name in parentheses and escape it with a backslash before the opening parenthesis:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>丸括弧にその名前を包んで、始めの括弧の前のバックスラッシュでそれをエスケープします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Wrapper types like JoinedShape and FlippedShape don’t matter to the module’s users, and they shouldn’t be visible.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>JoinedShapeとFlippedShapeのようなラッパー型は、モジュールのユーザにとって重要ではありません、そしてそれらは可視でないべきです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Write a custom argument label before the parameter name, or write _ to use no argument label.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あつらえの引数ラベルはパラメータ名の前に書いてください、または引数ラベルなしで使うためには_を書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Write a function that compares two Rank values by comparing their raw values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらの生の値を比較することによって２つのRankの値を比較する関数を記述してください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Write a function that returns an array containing a full deck of cards, with one card of each combination of rank and suit.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ランク（順位）とスート（記号）の各組合せのカード１枚を持つ、カードの完全なデック（一組）を含んでいる配列を返す関数を書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Write a name inside angle brackets to make a generic function or type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>総称体である関数や型を作るためには、その名前を山形括弧の中に書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Write a question mark (?) after the type of a value to mark the value as optional.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある値がオプショナルであると印するために、その値の型の後に疑問符（?）を書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Write a type annotation by placing a colon after the constant or variable name, followed by a space, followed by the name of the type to use.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>定数か変数の名前のあとにコロンを置いて、１つの空白に続き、使用する型の名前を続けることによって型注釈を書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Write an extension for the Double type that adds an absoluteValue property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Double型のために拡張をひとつ書いてください、それはabsoluteValueプロパティを加えるものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Write an optional binding for an if statement as follows:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オプショナルの束縛をif文のために次のように書いてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Write an underscore (_) for an argument with no name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>名前のない引数に対しては１つのアンダースコア（_）を書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Write the required modifier before the definition of a class initializer to indicate that every subclass of the class must implement that initializer:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>required修飾子をクラス・イニシャライザの定義の前に書いて、そのクラスの全てのサブクラスがそのイニシャライザを実装しなければならないことを示してください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Write these constraints after the name of the protocol you’re adopting by writing a generic where clause.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>それらの制約を、あなたが総称体where節を書くことによって採用しているプロトコルの名前の後に書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Write variadic parameters by inserting three period characters (...) after the parameter’s type name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そのパラメータの型名の後に３つのピリオド文字（...）を書き入れることによって、可変長パラメータを書いてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Write your code using the model given by copy-in copy-out, without depending on the call-by-reference optimization, so that it behaves correctly with or without the optimization.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたのコードをコピーイン・コピーアウトによって与えられるモデルを使って書いてください、参照呼び出し最適化に依存することなしに、そうすることでそれは最適化があってもなくても正しく振舞います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Writing &lt;T: Equatable&gt; is the same as writing &lt;T&gt; ... where T: Equatable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>&lt;T: Equatable&gt;と書くことは、&lt;T&gt; ... where T: Equatableと書くことと同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Writing someStructure.$someNumber accesses the wrapper’s projected value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>someStructure.$someNumberと書くことは、ラッパーのもつ投影値にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Writing Self.someStaticMember to access a member of the current type is the same as writing type(of: self).someStaticMember.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>Self.someStaticMemberを書いて現在の型のあるメンバーにアクセスすることは、type(of: self).someStaticMemberを書くことと同じです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Writing self explicitly lets you express your intent, and reminds you to confirm that there isn’t a reference cycle.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>selfを明示的に書くことは、あなたにあなたの意図を表現させます、そして参照循環がないことを確認するのをあなたに思い出させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Writing makeTrapezoid() this way lets it express the fundamental aspect of its public interface—the value it returns is a shape—without making the specific types that the shape is made from a part of its public interface.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>makeTrapezoid()をこの方法で書くことは、それにそれのパブリックインターフェイスの基本となる面 — それが返す値はある形状である — を表現させます、特定の型を作ることなしにです、それはその形状がそれのパブリックインターフェイスの一部に由来して作られることです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Writing Swift code in a playground lets you experiment with code and see the results immediately, without the overhead of building and running an app.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>スウィフトコードをあるプレイグラウンドの中で書くことで、あなたはコードで実験しその結果を直ちに確かめます、アプリをビルドして実行する手間なしにです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Writing the function this way lets you cleanly separate the code that’s responsible for handling a network failure from the code that updates the user interface after a successful download, instead of using just one closure that handles both circumstances.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>関数をこの方法で書くことは、あなたにネットワーク失敗を取り扱うことに責任を持つコードを、成功したダウンロードの後にユーザインターフェイスを更新するコードから分離させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can iterate over a one-sided range that omits its final value; however, because the range continues indefinitely, make sure you add an explicit end condition for the loop.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、それの最後の値を省いた片側範囲に対して反復処理できます；しかしながら、範囲があいまいに続いていることから、確実にあなたが明示的な終了条件をそのループに対して加えるようにしてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You access and modify a dictionary through its methods and properties, or by using subscript syntax.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、辞書へのアクセスおよび修正をそれのメソッドとプロパティを通して、または添え字構文を使うことで行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You access and modify a set through its methods and properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは集合へのアクセス及び変更をそれのメソッドとプロパティを通して行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You access and modify a string through its methods and properties, or by using subscript syntax.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは文字列へのアクセスと修正を、それのメソッドとプロパティを通して、または添え字構文を使うことによって行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You access and modify an array through its methods and properties, or by using subscript syntax.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、そのメソッドとプロパティを通して、または添え字構文を使うことによって、配列にアクセスして修正します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You access the indices before and after a given index using the index(before:) and index(after:) methods of String.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、ある与えられたインデックスの前後のインデックスにStringのindex(before:)とindex(after:)メソッドを使ってアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You access the raw value of an enumeration case with its rawValue property:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ある列挙ケース節の生の値にそれのrawValueプロパティでアクセスしてください：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You add conditional conformance to a protocol by including requirements in an extension declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、あるプロトコルに対する条件準拠を加えることを、要件を拡張宣言に含めることによって行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You also can’t use it as constraint in a generic return type because there isn’t enough information outside the function body to infer what the generic type needs to be.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまたそれを制約として総称体戻り型において使用できません、なぜならどうあることをその総称体型が必要とするか推論するのに十分な情報が関数本文の外側にないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You also can’t use the implicit self property, or call any of the instance’s methods.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた、暗黙のselfプロパティを使うことや、そのインスタンスのメソッドの何も呼ぶことができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You also don’t need to write semicolons at the end of every statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた、すべての文の終わりにセミコロンを書く必要がありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You also saw how to use weak and unowned references to break these strong reference cycles.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた、これらの強い参照循環を壊すために弱いおよび非所有参照を使う方法を見ました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You also use an initializer expression to delegate to the initializer of a superclass.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた、スーパークラスのイニシャライザに委任するために、イニシャライザ式を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You always write the override modifier when overriding a superclass designated initializer, even if your subclass’s implementation of the initializer is a convenience initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはスーパークラスの指定イニシャライザをオーバーライドする時に常にoverride修飾子を書きます、そのイニシャライザのあなたのサブクラスでの実装が便宜イニシャライザであるとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You apply a wrapper to a property by writing the wrapper’s name before the property as an attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、ラッパーのもつ名前をそのプロパティの前に属性として書くことによって、ラッパーをプロパティに適用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You apply it to a parameter’s type in a function or method declaration, for a parameter whose type is a function type that takes no arguments and that returns a value of the type of the expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはそれを、関数またはメソッドの宣言の中であるパラメータの持つ型へと適用します、あるパラメータでそれの型が関数型のものに対して、それは引数を取らずそしてそれは式の型のひとつの値を返すものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You apply the IBOutlet and IBInspectable attributes to property declarations of a class.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、IBOutletとIBInspectable属性をクラスのプロパティ宣言に適用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You apply the IBAction and IBSegueAction attribute to method declarations of a class and the IBDesignable attribute to class declarations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、IBActionとIBSegueAction属性をクラスのメソッド宣言に、そしてIBDesignable属性をクラス宣言に適用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You are free to implement subscripts in the most appropriate way for your particular class or structure’s functionality.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、あなたの特定のクラスまたは構造体の機能性に最も適切な方法で、添え字を実装して結構です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You aren’t allowed to call a deinitializer yourself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、デイニシャライザをあなた自身で呼び出すことは許されません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You assign a lower access level by writing fileprivate(set), private(set), or internal(set) before the var or subscript introducer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、より低いアクセス水準を割り当てることを、fileprivate(set)、private(set)、またはinternal(set)をvarまたはsubscript導入子の前に書くことによって行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You call an init? failable initializer in the same way that you call a nonfailable initializer, except that you must deal with the optionality of the result.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは失敗できるイニシャライザinit?を、オプショナルの結果を処理する必要があることを除き、失敗できないイニシャライザを呼び出すのと同じ方法で呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You call instance methods with the same dot syntax as properties:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、インスタンスメソッドをプロパティと同じドット構文を使って呼び出します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You call the greet(person:) function by passing it a String value after the person argument label, such as greet(person: "Anna").</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、greet(person:)関数をそれにString値をperson引数ラベルの後で渡すことによって、例えばgreet(person: "Anna")のように呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You call the greet(person:alreadyGreeted:) function by passing it both a String argument value labeled person and a Bool argument value labeled alreadyGreeted in parentheses, separated by commas.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはgreet(person:alreadyGreeted:)関数をそれにpersonでラベルしたString引数値とalreadyGreetedでラベルしたBool引き数値を両方とも丸括弧内に、コンマで区切って渡すことで呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You call the UINavigationController class pushViewController(_:animated:) method to add (or push) a view controller on to the navigation stack, and its popViewControllerAnimated(_:) method to remove (or pop) a view controller from the navigation stack.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはUINavigationControllerクラスのpushViewController(_:animated:)メソッドをナビゲーション・スタックにビュー・コントローラを加える（またはプッシュする）ために、そしてそれのpopViewControllerAnimated(_:)メソッドをナビゲーション・スタックからビュー・コントローラを取り除くために呼びます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can decompose a tuple’s contents into separate constants or variables, which you then access as usual:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはタプルの内容を個々の定数または変数に分解することができます。そして、あなたはそれから通常通りそれにアクセスします：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can access a UTF-16 representation of a String by iterating over its utf16 property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、あるStringのUTF-16叙述に、それのutf16プロパティのすべてに渡って繰り返していくことによってアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can access a UTF-8 representation of a String by iterating over its utf8 property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、あるStringのUTF-８叙述に、それのutf8プロパティのすべてに渡って繰り返していくことによってアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can access a Unicode scalar representation of a String value by iterating over its unicodeScalars property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、あるStringのUnicodeスカラー叙述に、それのunicodeScalarsプロパティのすべてに渡って繰り返していくことによってアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can access the individual Character values for a String by iterating over the string with a for-in loop:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、あるStringの個々のCharacter値にfor-inループでその文字列の初めから終わりまで反復することによってアクセスできます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can access the minimum and maximum values of each integer type with its min and max properties:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、そのminとmaxプロパティで各整数型の最小と最大の値を得ることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can access the properties of an instance using dot syntax.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、ドット構文を使ってインスタンスのプロパティにアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can add a new item into a set by calling the set’s insert(_:) method:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは新しい項目を集合に加えることが集合のinsert(_:)メソッドを呼ぶことによって行えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can add a new item to a dictionary with subscript syntax.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、添え字構文を使って辞書に新しい項目を付け加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can add a new item to the end of an array by calling the array’s append(_:) method:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、配列のappend(_:)メソッドを呼ぶことによって配列の終わりに新しい項目を加えることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can add any number of additional branches using #elseif clauses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、任意の数の追加の分岐を加えることが#elseifを使って行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can add property observers in the following places:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、プロパティオブザーバを以下の場所に追加できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can add property observers to any stored property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、プロパティオブザーバーをどんな格納プロパティにでも加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can add protocol conformance to a previously declared type by adopting the protocol in an extension declaration of that type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、プロトコル準拠を以前に宣言された型に加えることが、その型の拡張宣言においてそのプロトコルを採用することによってできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can add type constraints to an associated type in a protocol to require that conforming types satisfy those constraints.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、型制約を関連型へとプロトコルの中で加えることで、準拠する型がそれら制約を満たすことを要求できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also add a final additional branch using an #else clause.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた、最後の追加の分岐を#else節を使って加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also add new characteristics to the subclass.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、また、新しい特徴をサブクラスに加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also add property observers to any inherited property (whether stored or computed) by overriding the property within a subclass, as described in Overriding Property Observers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、また、プロパティオブザーバーをあらゆる継承されたプロパティ（格納されるか、計算されるかに関係なく）にでも加えることが、サブクラスの内部でプロパティをオーバーライドすることによって、プロパティオブザーバーのオーバーライドで記述されるように、可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also aggregate the conformance requirements of multiple protocols using protocol composition types, as described in Protocol Composition Type and Protocol Composition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、また、プロトコル合成型とプロトコル合成で記述されるように、複数のプロトコルの準拠要件をひとまとめにすることがプロトコル合成（コンポジション）型を使って可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also append a String value to an existing String variable with the addition assignment operator (+=):</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、また、あるString値を既存のString変数に加算代入演算子（+=）を使って追加することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also attempt to set a property’s value through optional chaining:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまたプロパティの値をオプショナル連鎖を通して設定することを試みることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also bind an arbitrary expression to a named value in a capture list.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた、ある任意の式を、キャプチャリストの中の名前をつけられた値と結び付けることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also call the preconditionFailure(_:file:line:) [https://developer.apple.com/documentation/swift/1539374-preconditionfailure] function to indicate that a failure has occurred—for example, if the default case of a switch was taken, but all valid input data should have been handled by one of the switch’s other cases.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた、preconditionFailure(_:file:line:) [https://developer.apple.com/documentation/swift/1539374-preconditionfailure]関数を呼び出して失敗がすでに起こっていることを示すことができます — 例えば、あるスイッチ文の省略時のケース節が取られた、しかし全ての有効な入力データがそのスイッチ文の他のケース節の１つによって取り扱われてしまっている場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also check whether a one-sided range contains a particular value, as shown in the code below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた、以下のコードで示すように、片側範囲が特定の値を含むかどうか調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also combine opaque return types with generics.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた、不透明戻り型を総称体と結合できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also create a task group and add child tasks to that group, which gives you more control over priority and cancellation, and lets you create a dynamic number of tasks.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた、タスクグループを作成して、子タスクそれらをそのグループに加えることができます、それはあなたに優先と取消に対するさらなる制御を与えます、そしてあなたに動的な数のタスクを作成させます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also declare a stored variable or property with willSet and didSet observers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、また、willSetとdidSetオブザーバーをもつ格納変数やプロパティを宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also declare properties in the context of a protocol declaration, as described in Protocol Property Declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコルプロパティ宣言で記述されるように、あなたはまた、プロトコル宣言の文脈において、プロパティを宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also declare subscripts in the context of a protocol declaration, as described in Protocol Subscript Declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>プロトコル添え字宣言で記述されるように、あなたはまた、プロトコル宣言の文脈において添え字を宣言することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also define a convenience initializer to create an instance of that class for a specific use case or input value type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、また、ある便宜イニシャライザを定義して、そのクラスのインスタンスを特定の使用状況のために作成したり、値型を入力することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also define custom operators that begin with a dot (.).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた、１つのドット（.）で始まるあつらえの演算子を定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also define functions inside the bodies of other functions, known as nested functions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた、他の関数の本体の内側に関数を、入れ子にされた関数として知られるものを、定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also define methods that are called on the type itself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、また、型それ自体の上で呼ばれるメソッドを定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also define properties that belong to the type itself, not to any one instance of that type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、また、その型のどれかひとつのインスタンスにではなく、型それ自体に属しているいくらかのプロパティを定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also define subscripts that are called on the type itself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた、型それ自身の上で呼び出される添え字を定義できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also delegate from init to init!, although doing so will trigger an assertion if the init! initializer causes initialization to fail.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた、initからinit!へ委任することができます、もっともそうすることは、init!イニシャライザが初期化失敗の原因となるならば、ある表明を引き起こすことになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also extend a generic type to conditionally add functionality, as described in Extensions with a Generic Where Clause.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた総称体型を拡張することで条件付きの機能性を追加することができます、総称体where節を持つ拡張で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also initialize a dictionary with a dictionary literal, which has a similar syntax to the array literal seen earlier.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた、辞書リテラルで辞書を初期化することができます、それは以前に見た配列リテラルに似ている構文を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also initialize a set with an array literal, as a shorthand way to write one or more values as a set collection.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた、１つ以上の値を集合コレクションとして書くための省略法として、集合を配列リテラルを使って初期化することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also initialize an array with an array literal, which is a shorthand way to write one or more values as an array collection.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた配列リテラルを使って配列を初期化することができます、それは１つ以上の値を配列コレクションとして書くための短縮形の方法です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also iterate over a dictionary to access its key-value pairs.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、また、辞書の端から端まで繰り返して、その「キーと値」の対にアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also make the generic Stack type conform to the Container protocol:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、また、総称体Stack型をContainerプロトコルに準拠させることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also mix both of these approaches in the same code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた、これら取り組みの両方を同じコードにおいて混ぜることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also modify the inherited currentSpeed property of a Bicycle instance, and query the instance’s inherited description property:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた、あるBicycleインスタンスの継承されたcurrentSpeedプロパティを変更することが出来ます、そしてそのインスタンスの持つ継承されたdescriptionプロパティについて問い合わせることが出来ます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also name the elements of a tuple type and use those names to refer to the values of the individual elements.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、また、タプル型の要素に名をつけることができて、それらの名前を個々の要素の値に言及するために使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also optionally define a type of value that the function will pass back as output when it’s done, known as its return type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた、随意にその関数が実行を終えたとき出力として逆に渡す値の型、その戻り型として知られるものを定義できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also override a subscript declaration inherited from a superclass.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた、スーパークラスから継承した添え字宣言をオーバーライドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also provide arguments to the attribute when you apply it to a property, and those arguments are passed to the property wrapper’s initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた引数いくつかを、属性に対して提供することが、それをあなたがプロパティに適用する時に行えます、そしてそれら引数は、プロパティラッパーのもつイニシャライザに渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also replace a type parameter with a type argument that’s itself a specialized version of a generic type (provided it satisfies the appropriate constraints and requirements).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた、型パラメータを、それ自身が総称体型の特殊化版である型引数と置き換えることができます（それが適切な制約と要件を満たすという条件で）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also retrieve an iterable collection of a dictionary’s keys or values by accessing its keys and values properties:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、また、そのkeysとvaluesプロパティにアクセスすることによって、ある辞書のキーまたは値からなる、for-in文で繰り返し可能なコレクション（集まり）を取り出すことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also set and modify the initial value for a stored property during initialization.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、また、初期化のときに格納プロパティに対して最初の値を設定および修正することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also specify the requirement that two types be identical, using the == operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた、==演算子を使用して、２つの型が同一であるという要件を指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also subclass any open class that’s defined in a different module.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた、異なるモジュールにおいて定義されるどんな開放クラスにでもサブクラスを作れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also use for-in loops with numeric ranges.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたまた、for-inループを数値範囲とともに使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also use a declaration to extend the behavior of an existing named type and to import symbols into your program that are declared elsewhere.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、また、ある宣言を使うことで、既存の名前付きの型の振るまいを拡張することや、どこか他で宣言されるシンボルをあなたのプログラムへインポートすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also use a generic where clause as part of an extension.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたまた、総称体where節を拡張の一部として使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also use a property wrapper to reuse code in the getter and setter of multiple properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまたプロパティラッパーを使用して、複数のプロパティのゲッターとセッターでコードを再利用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also use a raw value to find a corresponding case, if there is one, by calling the enumeration’s failable initializer, as in ExampleEnum(rawValue: 5), which returns an optional case.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた生の値を使用して対応するケース節を見つけることが、もしそれが１つあるならば、列挙の持つ失敗できるイニシャライザを呼ぶことによって可能です、例えばExampleEnum(rawValue: 5)のように、それはオプショナルのケース節を返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also use an asterisk (*) to indicate the availability of the declaration on all of the platform names listed above.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた、アスタリスク（*）を使って上でリストされるプラットホーム名の全てでその宣言の有効性を指し示すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also use an implicitly unwrapped optional with optional binding, to check and unwrap its value in a single statement:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、また、暗黙的にアンラップされるオプショナルをオプショナル束縛とともに使うことができます、１つの文でその値を確認してアンラップするためには：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also use dot syntax to assign a new value to a variable property:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、また、新しい値を変数プロパティに代入するためにドット構文を使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also use optional chaining and optional binding to conditionally perform an operation on an optional expression.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまたオプショナル連鎖とオプショナル束縛を使って、あるオプショナルの式に関して演算を条件付きで実行することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also use optional chaining to call a method that returns a value of optional type, and to chain on that method’s return value if needed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまたオプショナル連鎖を使って、オプショナルの型の値を返すメソッドを呼び出すこと、そして必要ならば、そのメソッドの戻り値の上で連鎖することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also use strings or floating-point numbers as the raw type of an enumeration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた、列挙の生の型として、文字列または浮動小数点数を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also use strings to insert constants, variables, literals, and expressions into longer strings, in a process known as string interpolation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた文字列を、文字列補間として知られているやり方で、定数、変数、リテラル、および式をより長い文字列に差し入れるために使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also use subscript syntax to change a range of values at once, even if the replacement set of values has a different length than the range you are replacing.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、また、添え字構文を使って、ある範囲の値を一度に変えることができます、たとえ代替の値一式があなたが置き換えている範囲と異なる長さを持つとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also use subscript syntax to change the value associated with a particular key:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、また、添え字構文を特定のキーと結びつけられる値を変えるために使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also use subscript syntax to retrieve a value from the dictionary for a particular key.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、また、添え字構文を特定のキーに対する値を辞書から取り出すために使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also use type casting to check whether a type conforms to a protocol, as described in Checking for Protocol Conformance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた、プロトコル準拠の確認で記述されるように、その型があるプロトコルに準拠しているどうか調べるために型キャストを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also write indirect before the beginning of the enumeration to enable indirection for all of the enumeration’s cases that have an associated value:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた、列挙の始まりの前にindirectを書くことで、列挙の持つケース節で関連値を持つもの全てに対して間接参照を可能にできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also write the type of a dictionary in shorthand form as [Key: Value].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた、辞書の型を[Key: Value]のような省略形で書くこともできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also write the type of an array in shorthand form as [Element].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、また、短縮形形式で配列の型を[Element]のように書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can append a Character value to a String variable with the String type’s append() method:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、Character値をString変数にそのString型のもつappend()メソッドを使って追加することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can apply a declaration attribute to declarations only.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、宣言属性を宣言だけに適用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can apply a property wrapper to a local stored variable, but not to a global variable or a computed variable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、プロパティラッパーをローカル格納変数に適用できます、しかしグローパル変数または計算変数にはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can apply multiple available attributes on a single declaration to specify the declaration’s availability on different platforms and different versions of Swift.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、複数のavailable属性を単一の宣言上に適用することで、その宣言の有効性を異なるプラットホームおよび異なるバージョンのスウィフトに関して指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can apply switch case attributes to switch cases only.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、スイッチケース節属性をスイッチケース節のみに適用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can apply that attribute in the following places:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、その属性を以下の場所で適用できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can apply the @DrawingBuilder attribute to a function’s parameter, which turns a closure passed to the function into the value that the result builder creates from that closure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、@DrawingBuilder属性を関数のもつパラメータに対して適用できます、それはその関数に渡されたクロージャを、リザルトビルダーがそのクロージャから作成する値へと変えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can apply the @unknown attribute to the default case, which indicates that the default case should match only enumeration cases that are added in the future.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは@unknown属性をdefaultケース節に適用できます、それはそのdefaultケース節が、将来に加えられる列挙ケース節だけに合致すべきであることを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can apply the available attribute with the renamed and unavailable arguments to a type alias declaration, as shown below, to indicate that the name of a declaration changed between releases of a framework or library.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、available属性をrenamedおよびunavailable属性とともに型エイリアス宣言に対して使うことで、下で示されるように、ある宣言の名前がフレームワークまたはライブラリのリリースの間に変わったことを指し示せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can apply the optional modifier only to protocols that are marked with the objc attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはoptional修飾子をobjc属性で印されるプロトコルだけに適用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can apply type attributes to types only.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、型属性を型だけに適用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can assign a Residence instance to john.residence, so that it no longer has a nil value:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはjohn.residenceにResidenceインスタンスを代入することができます、それによってそれはもはやnil値を持ちません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can assign a value to a constant property at any point during initialization, as long as it’s set to a definite value by the time initialization finishes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、それが初期化終了時にある明確な値に設定されさえするならば、ある値を初期化の間のどの時点ででも定数プロパティに割り当てることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can assign specific access levels to individual types (classes, structures, and enumerations), as well as to properties, methods, initializers, and subscripts belonging to those types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは特定のアクセス水準を個々の型（クラス、構造体、および列挙）、それだけでなくそれらの型に属しているプロパティ、メソッド、イニシャライザ、そして添え字に、個別に割り当てることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can assign the same product a different type of barcode:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、同じ商品を異なる型のバーゴードに割り当てることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can be confident that the string you are passed won’t be modified unless you modify it yourself.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、あなたが渡される文字列があなたが自身でそれを修正しない限り修正されないことを確信することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can call self.init only from within an initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、self.initをイニシャライザ内からだけ呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can call an instance of a dynamically callable type as if it’s a function that takes any number of arguments.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは動的callable型のインスタンスを、まるでそれがいくらかの数の引数を取る関数であるかのように呼び出せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can call such functions with either a String or Substring value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、そのような関数をStringまたはSubstring値で呼出せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can call the greet(person:) function multiple times with different input values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、異なる入力値を使ってgreet(person:)関数を複数回呼び出すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can call the swapTwoInts(_:_:) function with two variables of type Int to swap their values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、swapTwoInts(_:_:)関数を、それらの値を交換する２つのInt型の変数で呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can call the type(of:) function with an instance of a type to access that instance’s dynamic, runtime type as a value, as the following example shows:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、ある型のインスタンスを使ってtype(of:)関数を呼び出して、そのインスタンスの持つ動的な、実行時の型にひとつの値としてアクセスできます、以下の例で示すように：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can call this function to swap the values in two Int variables:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、２つのInt変数の値を交換するためにこの関数を呼ぶことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can chain multiple if statements together to consider additional clauses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、複数のif文を一緒につないで追加の条項を考慮することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can change the value of an existing variable to another value of a compatible type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、既存の変数の値を、別の互換性を持つ型の値に変えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can check for the existence of a value in the weak reference, just like any other optional value, and you will never end up with a reference to an invalid instance that no longer exists.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>他のあらゆるオプショナルの値と同じように、あなたは弱い参照の中の値の存在について調べることができます、そして、あなたは既に存在しない無効なインスタンスへの参照に至ることは決してありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can check that an index is valid before using it by comparing it to the array’s count property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはあるインデックスが有効なことを、それを配列のcountプロパティと比較することによって、それを使う前に確認することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can check the different barcode types using a switch statement, similar to the example in Matching Enumeration Values with a Switch Statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、異なるバーコード型それらを、列挙値をスイッチ文で照合するでの例に似たあるスイッチ文を使って調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can check whether an implicitly unwrapped optional is nil the same way you check a normal optional:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、暗黙的にアンラップされるオプショナルがnilであるかどうかを確認することが、あなたが通常のオプショナルを調べるのと同じ方法で可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can combine and negate compilation conditions using the logical operators &amp;&amp;, ||, and ! and use parentheses for grouping.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、コンパイル条件を結合および否定することが論理演算子&amp;&amp;、||、そして!を使って可能です、そして丸括弧をグループにするのに使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can combine multiple logical operators to create longer compound expressions:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、より長く複雑な式をつくるために複数の論理演算子を結合することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can combine multiple protocols into a single requirement with a protocol composition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、プロトコル合成を使って複数のプロトコルを１つの要件に結合することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can combine this multiline chained syntax with compiler control statements to control when each method is called.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、この複数行連鎖構文をコンパイラ制御文いくらかと結合することで、いつ各メソッドが呼び出されるかを制御できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can compare two tuples if they have the same type and the same number of values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、２つのタプルを比較することが、それらが同じ型と同じ数の値を持つならば可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can constrain a tuple pattern to match certain kinds of tuple types by using type annotations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、型注釈を使うことによって特定の種類のタプル型にマッチするようにタプルパターンに制約を加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can construct a new Matrix instance by passing an appropriate row and column count to its initializer:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、そのイニシャライザに適切な行と列の数を渡すことによって新しいMatrixインスタンスを造ることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can create a new array by adding together two existing arrays with compatible types with the addition operator (+).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、互換性を持つ型の２つの既存の配列を加算演算子（+）を使って一緒に加えることによって、新しい配列をつくることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can create an array that holds Int values, or an array that holds String values, or indeed an array for any other type that can be created in Swift.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、Int値を保持する配列、またはString値を保持する配列、またはそれどころかスウィフトで作成可能なあらゆる他の型のためにも配列をつくることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can create an empty array of a certain type using initializer syntax:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、特定の型の空の配列をイニシャライザ構文を使って作成できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can create an empty set of a certain type using initializer syntax:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは特定の型の空の集合を初期化構文を使って作成することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can create an instance of the Player class for a new player, and see what happens when the player completes level one:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、新しいプレーヤーのためにPlayerクラスのインスタンスをつくることができて、そのプレーヤーがレベル１を完了するとき、何が起こるか見ることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can create and print an HTMLElement instance as before:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、HTMLElementインスタンスを前の通り作成して出力することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can create multidimensional arrays by nesting pairs of square brackets, where the name of the base type of the elements is contained in the innermost pair of square brackets.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、角括弧の対を入れにすることによって多次元配列をつくることができます、そこで要素の基本型の名前は最も内側の角括弧の対の中に含まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can create tuples from any permutation of types, and they can contain as many different types as you like.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、いろいろな型をどんな順列にしてタプルを作っても構いません、そして、それらはあなたが望むだけ多くの異なる型を含むことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can customize the initialization process with input parameters and optional property types, or by assigning constant properties during initialization, as described in the following sections.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、以下の節で記述されるように、入力パラメータとオプショナルプロパティ型を使って、または初期化の間に定数プロパティを割り当てることによって、初期化処理を目的に合わせて作り変えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can declare and implement your own custom operators in addition to the standard operators provided by Swift.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、スウィフトによって提供される標準の演算子に加えて、あなた独自のあつらえの演算子を宣言して実装することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can declare multiple constants or multiple variables on a single line, separated by commas:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは複数の定数または複数の変数を、コンマで区切ることで１つの行に宣言することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can declare operators of three different fixities: infix, prefix, and postfix.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、３つの異なる定着性の演算子を宣言することができます：接中辞、接頭辞、そして接尾辞。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can decompose the tuple into temporary constants or variables as part of the iteration:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、繰り返しの一部としてそのタプルを一時的な定数または変数に分解することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can define optional requirements for protocols.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、オプショナル要件をプロトコルに対して定義できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can define Swift enumerations to store associated values of any given type, and the value types can be different for each case of the enumeration if needed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはスウィフト列挙を、どんな与えられた型の関連値でも格納するように定義することができます、そして値の型は列挙のケース節それぞれで異なっていることが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can define a default value for any parameter in a function by assigning a value to the parameter after that parameter’s type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、ある関数のすべてのパラメータに対して省略時の値を定義することが、そのパラメーターの型の後でパラメーターに値を割り当てることによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can define a common set of related cases as part of one enumeration, each of which has a different set of values of appropriate types associated with it.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、１つの列挙の一部として、関連したケース節のよくある集合を定義することができます、そのそれぞれはそれと結びつけられる適切な型の値の集合をそれぞれ別に持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can define a convenience initializer to call a designated initializer from the same class as the convenience initializer with some of the designated initializer’s parameters set to default values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、ある便宜イニシャライザを定義して、同じクラスからある指定イニシャライザをその便宜イニシャライザとして呼び出し、その指定イニシャライザのパラメータのいくつかを省略時の値に設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can define an overload of buildExpression(_:) that takes an argument of type () to handle assignments specifically.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはbuildExpression(_:)のあるオーバーロードを定義できます、それは型()の１つの引数を取ることで特に代入を取り扱うものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can define anything from a simple utility function with a single unnamed parameter to a complex function with expressive parameter names and different parameter options.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、ただ１つの無名のパラメータを持つ単純で便利な支援関数から、表現豊かなパラメータ名と種々のパラメータ・オプションを持つ複雑な関数まで何でも定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can define multiple related variables of the same type on a single line, separated by commas, with a single type annotation after the final variable name:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは同じ型の複数の関連した変数を、１行上に、コンマで区切って、型注釈を１つだけ最後の変数名の後につけて、定義することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can define multiple subscripts for a single type, and the appropriate subscript overload to use is selected based on the type of index value you pass to the subscript.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは１つの型のために複数の添え字を定義することができます、そしてあなたが添え字に渡すインデックス値の型に基づいて、使うのに適切な添え字のオーバーロードが選択されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can define your own type constraints when creating custom generic types, and these constraints provide much of the power of generic programming.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、独自の型制約をあつらえの総称体型を作成する時に定義することができます、そして、それらの制約は総称体プログラミングの力の多くを提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can delegate from init? to init! and vice versa, and you can override init? with init! and vice versa.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、init?からinit!への委任およびその逆が行えます、そしてあなたはinit?をinit!でオーバーライドすること、およびその逆もできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can do this even if that method doesn’t define a return value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>たとえそのメソッドが戻り値を定義しないとしても、あなたはこれをすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can drill down into subproperties, such as the width property in the resolution property of a VideoMode:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、下位プロパティへと掘り下っていくことができます、例えば、あるVideoModeのresolutionプロパティの中のwidthプロパティ：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can efficiently perform fundamental set operations, such as combining two sets together, determining which values two sets have in common, or determining whether two sets contain all, some, or none of the same values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは効率的に基本的な集合演算を実行することができます、例えば２つの集合を１つに結合する、２つの集合が共通して持つ値はどれか決定する、または２つの集合が同じ値のすべて、いくつか、または全く含まないかどうかを決定するなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can explicitly add the objc attribute to a subclass that meets these criteria, to specify its Objective-C name as discussed below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、明示的にobjc属性をこの基準に合うサブクラスに適用して、下で議論されるように、それのObjective-C名を指定できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can extend a class, structure, or enumeration in any access context in which the class, structure, or enumeration is available.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、あるクラス、構造体、または列挙を拡張することが、そこにおいてそのクラス、構造体、または列挙が利用可能であるあらゆるアクセス文脈において可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can extend a generic type to conditionally conform to a protocol, so that instances of the type conform to the protocol only when certain requirements are met.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、条件付きでプロトコルに準拠するように総称体型を拡張できます、それでその型のインスタンスは特定の要件が満たされた場合にのみそのプロトコルに準拠します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can extend an existing type to add conformance to a protocol, as described in Adding Protocol Conformance with an Extension.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、拡張を使ってプロトコル準拠を加えるで記述されるように、既存の型を拡張することでプロトコルへの準拠を加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can extend an existing type to adopt and conform to a new protocol, even if you don’t have access to the source code for the existing type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、ある新しいプロトコルを採用して準拠することで既存の型を拡張することができます、たとえあなたが既存の型のソース・コードにアクセスをしないとしてもです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can extend the Rect structure to provide an additional initializer that takes a specific center point and size:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、Rect構造体を拡張して、特定の中心点と大きさをとる追加のイニシャライザを提供することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can extend the behavior of a class type with an extension declaration, as discussed in Extension Declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはクラス型の挙動を拡張宣言を使って拡張できます、拡張宣言で議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can extend the behavior of a structure type with an extension declaration, as discussed in Extension Declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはある構造体型の挙動を拡張宣言を使って拡張できます、拡張宣言で議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can extend the behavior of an enumeration type with an extension declaration, as discussed in Extension Declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは列挙型の挙動を拡張宣言を使って拡張できます、拡張宣言で議論されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can fit two 4s inside 9, and the remainder is 1 (shown in orange).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは２つの4を9の内部に収めることができます、そして余りは1です（オレンジ色で示されます）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can give a setter a lower access level than its corresponding getter, to restrict the read-write scope of that variable, property, or subscript.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、セッターにその対応するゲッターよりもより低いアクセス水準を与えて、その変数、プロパティ、または添え字の読み書きのスコープを制限することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can implement a protocol initializer requirement on a conforming class as either a designated initializer or a convenience initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、イニシャライザ要件プロトコルを準拠クラス上で指定イニシャライザまたは便宜イニシャライザとして実装することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can implement this method as part of a result builder that uses a different type for partial and final results, or to perform other postprocessing on a result before returning it.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはこのメソッドを、部分的および最終的結果に対して異なる型を使うあるリザルトビルダーの一部として、または他の処理をある結果上でそれが返る前に実行するために実装できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can implement this method to perform preprocessing—for example, converting expressions to an internal type—or to provide additional information for type inference at use sites.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはこのメソッドを実装することで、処理 — 例えば、いくつかの式をある内部型へ変換すること — を実行します、または追加の情報を型推論に対してさまざまな現場で提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can include a generic where clause on an associated type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、総称体where節を関連型に関して含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can include additional spaces and tabs after that indentation; those spaces and tabs appear in the string.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、追加の空白とタブをその字下げの後に含めることができます；それらの空白とタブは文字列の中に現れます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can include as many optional bindings and Boolean conditions in a single if statement as you need to, separated by commas.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、単一のif文の中に、コンマで区切ったオプショナル束縛とブール条件をあなたが必要とするだけ多く含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can include labels in a dynamic method call if you implement the dynamicallyCall(withKeywordArguments:) method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、いくつかのラベルを動的メソッド呼び出しに含めることができます、もしあなたがdynamicallyCall(withKeywordArguments:)メソッドを実装するならば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can include multiple requirements in a generic where clause that’s part of an extension, just like you can for a generic where clause that you write elsewhere.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、複数の要件を拡張の一部であるひとつのwhere節の中に含めることができます、ちょうどあなたがどこか他で書く総称体where節に対してできるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can include predefined String values within your code as string literals.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、あらかじめ定義されたString値を文字列リテラルとしてあなたのコードの内部に含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can initialize the Rect structure below in one of three ways—by using its default zero-initialized origin and size property values, by providing a specific origin point and size, or by providing a specific center point and size.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、以下のRect構造体を３つの方法のうちの１つで初期化することができます ― それの省略時の０で初期化されたoriginとsizeプロパティ値を使うことによって、特定の原点とサイズを提供することによって、または特定の中心点とサイズを提供することによって。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can iterate over the entire set of values in an array with the for-in loop:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、for-inループを使って配列中の値ひとそろい全部に渡って繰り返すことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can iterate over the key-value pairs in a dictionary with a for-in loop.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、for-inループを使って、ある辞書の中の「キーと値」のすべてに対して操作を繰り返し適用していくことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can iterate over the string with a for-in statement, to access its individual Character values as Unicode extended grapheme clusters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは文字列の全体にわたってfor-in文を使って繰り返すことができます、それでユニコードの拡張書記素クラスタとしてのそれの個々のCharacter値にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can iterate over the values in a set with a for-in loop.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは集合の中の値すべてに渡って繰り返しすることがfor-inループによって行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can keep an index in a loop by using ..&lt; to make a range of indexes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、インデックス（索引）をループにおいて保持することが、..&lt;を使ってインデックスの範囲を作ることで可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can limit protocol adoption to class types (and not structures or enumerations) by adding the AnyObject protocol to a protocol’s inheritance list.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、プロトコル採用をクラス型に制限する（つまり構造体や列挙で採用しない）ことがAnyObjectプロトコルをプロトコルのもつ継承リストに加えることによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can link together multiple levels of optional chaining to drill down to properties, methods, and subscripts deeper within a model.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、オプショナル連鎖の複数の階層を結びつけて、あるモデル内のより深いプロパティ、メソッド、そして添え字に掘り下げていくことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can list as many protocols as you need, separating them with ampersands (&amp;).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、あなたが必要とするだけ多くのプロトコルを、それらをアンパサンド（&amp;）で隔てて列記できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can make a generic type conditionally conform to a protocol by listing constraints when extending the type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、ある総称体型を条件付きでプロトコルに準拠させることが、その型を拡張する時に制約を列記することによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can make generic forms of functions and methods, as well as classes, enumerations, and structures.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは関数やメソッドだけでなく、クラス、列挙、そして構造体も総称体の形式にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can make the structure’s numberOfEdits property getter public, and its property setter private, by combining the public and private(set) access-level modifiers:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、この構造体のnumberOfEditsプロパティゲッターを公開に、そしてそれのプロパティセッターを非公開にすることが、publicとprivate(set)アクセス水準修飾子を組み合わせることによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can mark a declaration with one of the access-level modifiers below to specify the declaration’s access level.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、宣言を以下のアクセス水準修飾子のうちの１つで印して、その宣言のアクセス水準を指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can mark an entire class as final by writing the final modifier before the class keyword in its class definition (final class).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、そのクラス定義においてclassキーワードの前にfinal修飾子を書くことによって（final class）、そのクラス全体を最終版として印することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can mark an optional reference to a class as unowned.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、あるクラスへのオプショナル参照を非所有として印できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can mark designated and convenience initializers with the required declaration modifier to require that every subclass implement the initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは指定および便宜イニシャライザをrequired宣言修飾子で印して、全てのサブクラスがそのイニシャライザを実装することが必須であるようにすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can match individual enumeration values with a switch statement:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、switch文を使って個々の列挙値を照合することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can mix and match components of key paths to access values that are deeply nested within a type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、キーパスの構成要素をうまく組み合わせることで、ある型の内部に深く入れ子にされた値にアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can name the individual elements in a tuple when the tuple is defined:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、タプルの個々の要素に名前をつけることが、そのタプルが定義される時に可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can name the parameter or use the default parameter name of oldValue.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはパラメータに名をつけること、または省略時のパラメータ名のoldValueを使うことが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can nest labeled statements, but the name of each statement label must be unique.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはラベルをつけられた文を入れ子にすることができます、しかし、各文ラベルの名前は特有でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can now call the assigned function with the name mathFunction:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、今や、代入された関数を名前mathFunctionを使って呼ぶことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can now create a Customer instance, and use it to initialize and assign a new CreditCard instance as that customer’s card property:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、現在Customerインスタンスを作成して、それを使って、新しいCreditCardインスタンスを、その顧客のcardプロパティとして初期化して代入することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can now create a new Person instance and assign it to one of these three variables:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、いま新しいPersonインスタンスを作成して、それをこれらの３つの変数のうちの１つに代入することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can now create a specific Person instance and Apartment instance and assign these new instances to the john and unit4A variables:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、今や特定のPersonインスタンスとApartmentインスタンスを作成して、それらの新しいインスタンスをjohnおよびunit4A変数に代入することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can now link the two instances together so that the person has an apartment, and the apartment has a tenant.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは次に人がアパートを持つように、２つのインスタンスを結びつけることができます、するとアパートには賃借人があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can now try to set a property’s value, assign to a subscript, or call a mutating method or operator through Optional Chaining.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは今ではオプショナル連鎖を通して、プロパティの値を設定する、ある添え字に代入する、または変更メソッドまたは演算子を呼び出すことを試みることが出来ます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can now use chooseStepFunction(backward:) to obtain a function that will step in one direction or the other:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>現在あなたはchooseStepFunction(backward:)を使って、ある方向にまたはもう一方に進む関数を取得できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can now use the numbers array to create an array of String values, by passing a closure expression to the array’s map(_:) method as a trailing closure:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、現在、このnumbers配列をString値の配列をつくるために使うことが、あるクロージャ式を配列のmap(_:)メソッドに後付クロージャとして渡すことによって、可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can now use this operator to check whether two Vector2D instances are equivalent:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、今ではこの演算子を使って２つのVector2Dインスタンスが等しいかどうか調べられます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can omit either property or both properties, and the initializer uses the default value for anything you omit—for example:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、どちらかのプロパティまたは両方のプロパティを省略できます、そしてイニシャライザは省略時の値をあなたが省略するどんなものにも使います — 例えば：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can omit the assertion message—for example, when it would just repeat the condition as prose.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは表明メッセージを省略できます — 例えば、それが単に条件を単調に繰り返す場合。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can only call a dynamically callable instance with arguments and a return value that match the types you specify in one of your dynamicallyCall method implementations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは動的callableインスタンスを、あなたのdynamicallyCallメソッド実装の１つにおいてあなたが指定する型に合致する引数いくつかと戻り値ひとつで呼び出せるだけです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can only pass a variable as the argument for an in-out parameter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、in-outパラメータに対する引数として、変数を渡すことだけができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can opt in to this behavior by placing the mutating keyword before the func keyword for that method:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、そのメソッドのためのfuncキーワードの前にmutatingキーワードを置くことによってこの挙動を取り入れることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can opt in to value overflow behavior by using Swift’s overflow operators (such as a &amp;+ b).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、スウィフトのオーバフロー演算子を使用することによって、値オーバフロー挙動を選ぶことが可能です（例えばa &amp;+ bのように）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can opt in to value overflow behavior by using Swift’s overflow operators, as described in Overflow Operators.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>オーバフロー演算子で記述されるように、あなたは、スウィフトのもつオーバフロー演算子を使うことによって、値オーバフロー挙動を選ぶことが可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can overload a generic function or initializer by providing different constraints, requirements, or both on the type parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、総称体の関数やイニシャライザをオーバーロードすることが、異なる制約、要件、または両方を型パラメータ上で提供することによって可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can overload a subscript declaration in the type in which it’s declared, as long as the parameters or the return type differ from the one you’re overloading.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、ある添え字宣言を、そこにおいてそれが宣言される型においてオーバーロードすることができます、パラメーターまたは戻り型があなたがオーバーロードしているものと異なる限りはです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can overload the ~= operator to provide custom expression matching behavior.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、~=演算子をオーバーロードして、あつらえの式マッチング挙動を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can override a failable initializer with a nonfailable initializer but not the other way around.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは失敗できるイニシャライザを、失敗できないイニシャライザでオーバーライドできます、しかし逆はできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can override a nonreturning method, but the new method must preserve its return type and nonreturning behavior.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは非復帰メソッドをオーバーライドすることができます、しかし新しいメソッドはそれの戻り型と非復帰挙動を維持しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can override a property in a subclass by marking the subclass’s property declaration with the override declaration modifier, as described in Overriding.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、オーバーライドで記述されるように、サブクラスのプロパティ宣言をoverride宣言修飾子で印することによってサブクラスの中のプロパティをオーバーライドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can override a superclass failable initializer in a subclass, just like any other initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、スーパークラスの失敗できるイニシャライザをサブクラスにおいてオーバーライドすることが、何らかの他のイニシャライザとまったく同じようにできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can override an inherited instance or type method to provide a tailored or alternative implementation of the method within your subclass.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、ある継承されたインスタンスまたは型メソッドをオーバーライドすることで、あなたのサブクラス内部でそのメソッドの特注のまたは代替の実装を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can override an inherited instance or type property to provide your own custom getter and setter for that property, or to add property observers to enable the overriding property to observe when the underlying property value changes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは継承されたインスタンスまたは型プロパティをオーバーライドして、そのプロパティのためにあなた独自のあつらえのゲッターとセッターを用意したり、根底にあるプロパティ値がいつ変化するか監視することをオーバーライドしているプロパティに可能にするプロパティオブザーバーを加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can override the default behavior for argument labels with one of the following forms:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは引数ラベルに対する初期状態の挙動をオーバーライドすることが以下の形式の１つで可能です：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can override this default behavior by marking the declaration with an access-level modifier, as described in Access Control Levels.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、アクセス制御ラベルで記述されるように、この初期状態のふるまいをその宣言をアクセス水準修飾子で印することによってオーバーライドすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can pass a value of any conforming type in to this parameter when initializing a new Dice instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>新しいDiceインスタンスを初期化するとき、あなたはどんな準拠型の値でもこのパラメータに渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can pass any function of that type as the argument for this first parameter.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、この最初のパラメータに対する引数として、その型のどんな関数でも渡すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can place a string literal within extended delimiters to include special characters in a string without invoking their effect.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、文字列リテラルを拡張区切り記号内に置くことで、いくらかの特殊文字を文字列の中にそれらの効果を発動することなしに含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can prefix a loop statement, an if statement, a switch statement, or a do statement with a statement label, which consists of the name of the label followed immediately by a colon (:).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはループ文、if文、switch文、またはdo文の前に文ラベルを置くことができます、それは、ラベルの名前とそれに直ちに続くコロン（:）から成ります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can present an inherited read-only property as a read-write property by providing both a getter and a setter in your subclass property override.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたのサブクラスプロパティオーバーライドにおいてゲッターとセッターの両方を提供することによって、あなたは継承された読み出し専用のプロパティを、読み書き両用のプロパティとして提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can prevent a method, property, or subscript from being overridden by marking it as final.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはメソッド、プロパティ、または添え字がオーバーライドされるのを、それを最終版（final）と印することによって妨げることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can prevent this problem when using Swift actors because they only allow one operation on their state at a time, and because that code can be interrupted only in places where await marks a suspension point.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはこの問題を防ぐことがスウィフトのアクターを使っている場合は可能です、なぜならそれらの状態に関して一度に１つの演算が許可されるだけだからです、そしてなぜならそのコードが割り込まれるのが可能なのはただawaitが中断地点を印するところにおいてのみだからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can print the current value of a constant or variable with the print(_:separator:terminator:) function:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、print(_:separator:terminator:)関数で定数または変数の現在の値を出力することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can propagate the error from a function to the code that calls that function, handle the error using a do-catch statement, handle the error as an optional value, or assert that the error will not occur.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、エラーを関数からその関数を呼び出しているコードに伝えて、そのエラーをdo-catch文を使って取り扱う、エラーをオプショナルとして取り扱う、またはそのエラーは起こらないことを表明することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can provide initialization parameters as part of an initializer’s definition, to define the types and names of values that customize the initialization process.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、イニシャライザの定義の一部として初期化パラメータを提供することができます、それによって初期化処理をカスタマイズする値の型と名前を定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can provide a type annotation when you declare a constant or variable, to be clear about the kind of values the constant or variable can store.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、あなたが定数または変数を宣言するとき、その定数または変数が格納することができる値の種類について明確にするために、型注釈を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can provide a custom getter (and setter, if appropriate) to override any inherited property, regardless of whether the inherited property is implemented as a stored or computed property at source.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、あつらえのゲッターを（そして適切ならば、セッターも）提供することで、あらゆる継承されたプロパティをオーバーライドできます、継承されたプロパティがその発生源で格納プロパティもしくは計算プロパティとして実装されるかは関係しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can provide a default value for a stored property as part of its definition, as described in Default Property Values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>省略時のプロパティ値で記述されるように、あなたは格納プロパティのために省略時の値をその定義の一部として用意することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can provide an explicit name in parentheses after set.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、setの後に括弧の中ではっきりとした名前を提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can provide more than one type parameter by writing multiple type parameter names within the angle brackets, separated by commas.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、山形括弧内に複数の型パラメータ名をコンマで区切って書くことによって、複数の型パラメータを提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can provide multiple catch blocks that handle specific errors.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、それぞれが特定のエラーを取り扱う複数のcatchブロックを提供することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can provide whatever arguments you need to the attribute, and they’re passed to the initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、どんなものでもあなたが必要とする引数それらを属性に提供できます、そしてそれらはイニシャライザに渡されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can put parentheses around a named type or a compound type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、名前付きの型や複合の型の周りに丸括弧を置くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can query the threeTimesTable instance by calling its subscript, as shown in the call to threeTimesTable[6].</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、threeTimesTableインスタンスにその添え字を呼ぶことによって問い合わせることがthreeTimesTable[6]への呼び出しで示されるように可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can read this code as:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、このコードを次のように読むことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can refer to parameters by number instead of by name—this approach is especially useful in very short closures.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、名前によってでなく、数によってパラメータに言及することができます ― この取り組み方は、特に非常に短いクロージャで役立ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can remove an item from a set by calling the set’s remove(_:) method, which removes the item if it’s a member of the set, and returns the removed value, or returns nil if the set didn’t contain it.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはある項目を集合から取り除くことが集合のremove(_:)メソッドを呼ぶことによって行えます、それは、その項目をそれが集合のメンバーであるならば取り除きます、そして取り除かれた項目を返します、または集合がそれを含まないならばnilを返します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can revise the SurveyQuestion example from above to use a constant property rather than a variable property for the text property of the question, to indicate that the question doesn’t change once an instance of SurveyQuestion is created.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、上記のSurveyQuestion例を、変数プロパティではなく定数プロパティを質問のtextプロパティのために使うように見直して、その質問は一旦SurveyQuestionのインスタンスが作成されるならば変化しないことを示すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can rewrite the TemperatureUnit example from above to use raw values of type Character and to take advantage of the init?(rawValue:) initializer:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、上のTemperatureUnit例をCharacter型の生の値を使うように、そしてinit?(rawValue:)イニシャライザを活用するように書き直すことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can rewrite the chooseStepFunction(backward:) example above to use and return nested functions:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、入れ子にされた関数を使用して返すように、上記のchooseStepFunction(backward:)の例を書き直すことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can rewrite the possibleNumber example from the Optionals section to use optional binding rather than forced unwrapping:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはオプショナル節のpossibleNumber例を、強制アンラップではなくて、オプショナル束縛を使うように書き直すことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can see a similar problem by thinking about how you update a budget that’s written on a piece of paper.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、一片の紙に書かれる予算案を更新する方法について考えることによって、同種の問題を調べられます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can set a constant or variable to Planet.earth, and check for this value later.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、定数または変数をPlanet.earthに設定することができて、後でその値について調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can set a value in a dictionary by providing a key of the dictionary’s key type within subscript brackets, and assigning a value of the dictionary’s value type to the subscript:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、添え字角括弧内にその辞書のキー型のキーを提供し、そしてその添え字に辞書の値型の値を代入することによって、値を辞書に設定することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can set an initial value for a stored property within an initializer, or by assigning a default property value as part of the property’s definition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、イニシャライザの内部で、またはそのプロパティの定義の一部として省略時のプロパティの値を代入することによって、格納プロパティのために初期値を設定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can set the hasBasket property to true for a particular Bicycle instance after that instance is created:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、特定のBicycleインスタンスに対してhasBasketプロパティをtrueに設定することが、そのインスタンスを作成した後で行えます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can set the initial value of a stored property from within an initializer, as shown above.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはイニシャライザ内から格納プロパティの初期値を設定することが、上で示されるように、行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can simplify the declaration of a read-only computed property by removing the get keyword and its braces:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、読み出し専用の計算プロパティの宣言をgetキーワードとそれの波括弧を取り除くことによって単純化することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can specify a name for this parameter as part of your willSet implementation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、あなたのwillSet実装の一部としてこのパラメータに名前を指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can specify a type annotation for these patterns to constrain them to match only values of a certain type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは型注釈をこれらのパターンに指定して、それらがある特定の型の値だけにマッチするように制約を加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can specify additional requirements on type parameters and their associated types by including a generic where clause right before the opening curly brace of a type or function’s body.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、追加の要件を型パラメータおよびそれの関連型に指定することが総称体where節を型または関数の本文の開き波括弧のまさに前に含めることによって行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can subclass any class that can be accessed in the current access context and that’s defined in the same module as the subclass.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、現在のアクセス前後関係においてアクセスされることが出来るどんなクラスにでもサブクラスを作れます、それは同じモジュールの中でサブクラスとして定義されます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can tell that the createAddress() function isn’t called, because nothing is printed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、createAddress()関数が呼ばれなかったと言うことができます、なぜなら何も出力されなかったからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can then create new barcodes using either type:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはそれから新しいバーコードをどちらかの型を使って作成できます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can therefore call the allItemsMatch(_:_:) function with these two containers as its arguments.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、したがって、allItemsMatch(_:_:)関数をその引数としてこれらの２つのコンテナを使って呼ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can think of an implicitly unwrapped optional as giving permission for the optional to be force-unwrapped if needed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは暗黙的にアンラップされるオプショナルを、必要に応じて強制アンラップされる許可をそのオプショナルに与えていると考えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can think of an opaque type like being the reverse of a generic type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、不透明型を総称体の逆であるように考えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can think of the associated values as behaving like stored properties of the enumeration case instance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはそれら関連値を、その列挙ケース節インスタンスに属する格納プロパティのように振る舞うものとして考えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use if and let together to work with values that might be missing.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、ifとletを一緒に使って、見つからないかもしれない値を扱うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use defer to write setup and cleanup code next to each other, even though they need to be executed at different times.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、deferを使うことでセットアップおよびクリーンアップコードを隣り合わせに書くことができます、たとえそれらが異なる時に実行される必要があるにしても。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use allCases like any other collection—the collection’s elements are instances of the enumeration type, so in this case they’re Beverage values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、allCasesを何らかの他のコレクションと同様に使うことができます — コレクションの持つ要素は列挙型のインスタンスです、それでこの場合においてそれらはBeverage値です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use Xcode 13 to build targets that are written in either Swift 5.6, Swift 4.2, or Swift 4.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、Xcode 13を使ってSwift 5.6、Swift 4.2、またはSwift 4のいずれかで書かれたターゲットをビルドできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use a defer statement even when no error handling code is involved.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、defer文を使うことが、エラー処理コードを伴わない時でさえも可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use a capture list to explicitly control how values are captured in a closure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはキャプチャリストを使って、どのようにあるクロージャにおいて値がキャプチャされるかを明示的に制御します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use a failable initializer to select an appropriate enumeration case based on one or more parameters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、失敗できるイニシャライザを使って適切な列挙ケース節を１つ以上のパラメータに基づいて選ぶことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use a function type as the return type of another function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、ある関数型をそれとは違う関数の戻り型として使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use a function type such as (Int, Int) -&gt; Int as a parameter type for another function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、ある関数型、例えば(Int, Int) -&gt; Intを、別の関数のためのパラメータ型として使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use a generic where clause with extensions to a protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、総称体where節をプロトコルに対する拡張で使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use a key path expression in contexts where you would normally provide a function or closure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはキーパス式を、あなたが通常は関数またはクロージャを提供するところの文脈において使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use a protocol in many places where other types are allowed, including:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、プロトコルを、他の型が許可される多くの場所で使用できます、以下を含みます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use a protocol name just like any other named type—for example, to create a collection of objects that have different types but that all conform to a single protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、何かほかの名前付きの型のようにプロトコル名を使用することができます ― 例えば、それぞれ異なる型を持つが全てがただ１つのプロトコルに準拠するオブジェクトいくつかのコレクションをつくるためなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use a set instead of an array when the order of items isn’t important, or when you need to ensure that an item only appears once.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、項目の順番が重要でないときに、またはあなたがひとつの項目がただ一度だけ現れることを確実にする必要があるときに、配列の代わりに集合を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use a tuple to return multiple values from a function as a single compound value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはタプルを使って、関数から複数の値を１つの混成値として返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use a tuple type as the return type for a function to return multiple values as part of one compound return value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、関数の戻り型としてタプル型を使って、複数の値をひとつの複合の戻り値の一部として返すことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use a tuple type as the return type of a function to enable the function to return a single tuple containing multiple values.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、関数の戻り型としてタプル型を使って、その関数に複数の値を含んでいる１つのタプルを返すのを可能にすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use all three of the inherited initializers to create a new ShoppingListItem instance:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、継承されたイニシャライザの３つ全てを新しいShoppingListItemインスタンスをつくるために使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use an if statement to find out whether an optional contains a value by comparing the optional against nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、if文を、あるオプショナルが値を含むかどうか知るために使うことができます、それは、そのオプショナルをnilと比べることによって行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use an empty dictionary literal to create an empty dictionary literal of specified key and value types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、空の辞書リテラルを使って、指定されたキーと値型の空の辞書リテラルを作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use an extension to add protocol conformance to a type that’s declared elsewhere, or even to a type that you imported from a library or framework.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは１つの拡張を使用することで、どこかほかで宣言される型に、またはあなたがライブラリやフレームワークからインポートした型にさえもプロトコル準拠を加えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use an extension to add protocol conformance, like this:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはある拡張を使って、このようにプロトコル準拠を加えることが出来ます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use an instance of ThreeSource as the data source for a new Counter instance:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、ThreeSourceのインスタンスを新しいCounterインスタンスのためのデータ・ソースとして使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use an instance of TowardsZeroSource with the existing Counter instance to count from -4 to zero.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、TowardsZeroSourceのインスタンスを既存のCounterインスタンスとともに使って、-4からゼロへと数えることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use assignment syntax in the definition of a wrapped value to pass the expression on the right-hand side of the assignment as the argument to the wrappedValue parameter of the property wrapper’s initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、代入構文をラップ値の定義において使用して、代入の右手側での式を、プロパティラッパーのもつイニシャライザのwrappedValueパラメータに対する引数として渡せます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use bit shifting to encode and decode values within other data types:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、他のデータ型内の値を符号化したり復号するために、ビットシフトを使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use both constants and variables with optional binding.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、定数と変数の両方をオプショナル束縛で使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use extended delimiters to create strings with characters that would ordinarily have a special effect such as generating a string interpolation, starting an escape sequence, or terminating the string.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは拡張区切り記号を使うことで、例えば文字列補間を生成する、エスケープシーケンスを開始する、または文字列を終端するなど、通常は特別な効果を持つ文字で文字列を作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use extended delimiters to include the text """ in a multiline string, overriding the default behavior that ends the literal.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは拡張区切り文字を使うことで、テキスト"""を複数行文字列の中に含めることが、省略時の挙動であるリテラルの終わりをオーバーライドして行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use extended string delimiters to create strings containing characters that would otherwise be treated as a string interpolation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、拡張文字列区切り記号を使うことで、そうしなければ文字列補間とみなされる文字を含んでいる文字列を作成できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use forced unwrapping in an initializer to call a failable initializer from the superclass as part of the implementation of a subclass’s nonfailable initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、強制アンラップをイニシャライザの中で使うことで、失敗できるイニシャライザをスーパークラスから呼び出し、サブクラスの失敗できないイニシャライザの実装の一部とすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use nested functions to organize the code in a function that’s long or complex.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、長いか複雑である関数においてコードを組織するために、入れ子にされた関数を使用することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use optional binding to check whether this version of the minMax(array:) function returns an actual tuple value or nil:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、minMax(array:)関数のこの改作が返すのは本当のタプルなのかまたはnilなのかを調べるためにオプショナル束縛を使うことが出来ます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use optional chaining to call a method on an optional value, and to check whether that method call is successful.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはオプショナル連鎖を使って、オプショナルの値の上でメソッドを呼んで、そしてそのメソッド呼び出しが成功しているかどうか調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use optional chaining to try to retrieve and set a value from a subscript on an optional value, and to check whether that subscript call is successful.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、オプショナル連鎖を使って、あるオプショナルの値上の添え字から値を取り出したり設定したりすること、そしてその添え字がうまく呼び出されるかどうかを調べることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use optional chaining with calls to properties, methods, and subscripts that are more than one level deep.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、深さ１階層以上であるプロパティ、メソッド、そして添え字への呼び出しでオプショナル連鎖を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use parentheses to specify the precedence of operations by explicitly grouping expressions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは丸括弧を使って、明示的にいくらかの式をグループにまとめることによって演算の優先順位を指定することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use property overriding to add property observers to an inherited property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、プロパティをオーバーライドすることを継承されたプロパティにプロパティオブザーバーを追加するために使用できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use protocol extensions to provide a default implementation to any method or computed property requirement of that protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはプロトコル拡張を使うことで省略時の実装をそのプロトコルのどのメソッドまたは計算プロパティ要件に対しても提供できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use protocols to declare which methods a delegate of a class or structure should implement, as described in Delegation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはプロトコルを使って、あるクラスまたは構造体から委任を受ける側が実装しなければならないのはどのメソッドかを宣言することができます、委任で記述されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use string interpolation in both single-line and multiline string literals.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、文字列補間を単一行および複数行文字列リテラルにおいて使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use subscript syntax to access the Character at a particular String index.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、添え字構文を使うことで特定のStringインデックス位置でのCharacterへアクセスできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use subscript syntax to change an existing value at a given index:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、添え字構文を使って、与えられたインデックス位置にある既存の値を変えることができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use subscript syntax to remove a key-value pair from a dictionary by assigning a value of nil for that key:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは添え字構文を、そのキーに対してnilの値を代入することによって、辞書からある「キーと値」の対を削除するために使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use the AudioChannel structure to create two new audio channels called leftChannel and rightChannel, to represent the audio levels of a stereo sound system:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、AudioChannel構造体を、leftChannelとrightChannelと呼ばれる２つの新しい音声チャンネルをつくるために使用して、ステレオ・オーディオ・システムの音声のレベルを表すことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use the fatalError(_:file:line:) function during prototyping and early development to create stubs for functionality that hasn’t been implemented yet, by writing fatalError("Unimplemented") as the stub implementation.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、fatalError(_:file:line:)関数を試作段階および開発初期の間に使って、まだ実装されていない機能性に対してスタブ（代用品）を作成することが、fatalError("Unimplemented")をスタブ実装として記述することによって行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use the hasPrefix(_:) method with the romeoAndJuliet array to count the number of scenes in Act 1 of the play:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、劇の「一幕（Act 1）」の場面の数を数えるためにhasPrefix(_:)メソッドをromeoAndJuliet配列で使用することができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use the insert(_:at:), insert(contentsOf:at:), remove(at:), and removeSubrange(_:) methods on any type that conforms to the RangeReplaceableCollection protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、insert(_:at:)、insert(contentsOf:at:)、remove(at:)、そしてremoveSubrange(_:)メソッドをRangeReplaceableCollectionプロトコルに準拠するあらゆる型で使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use the is and as operators described in Type Casting to check for protocol conformance, and to cast to a specific protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、型キャストで記述されるisとas演算子を特定のプロトコルへキャストするために使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use the startIndex and endIndex properties and the index(before:), index(after:), and index(_:offsetBy:) methods on any type that conforms to the Collection protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、startIndexとendIndexプロパティそしてindex(before:)、index(after:)、およびindex(_:offsetBy:)メソッドをCollectionプロトコルに準拠するあらゆる型で使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use the rawValue property to access the raw value of an enumeration case, as in ExampleEnum.b.rawValue.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、rawValueプロパティを使うことで列挙ケース節の生の値にアクセスできます、ExampleEnum.b.rawValueにおけるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use the abbreviated form anytime the value’s type is already known.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、値の型がすでに知られているときはいつでも省略形を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use the postfix self expression to access a type as a value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、接尾辞self式を使って、ある型に値としてアクセスすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use this argument to name classes, enumerations, enumeration cases, protocols, methods, getters, setters, and initializers.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはこの引数を、クラス、列挙、列挙ケース、プロトコル、メソッド、ゲッター、セッター、そしてイニシャライザに名前をつけるために使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use this failable initializer to choose an appropriate enumeration case for the three possible states and to cause initialization to fail if the parameter doesn’t match one of these states:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、この失敗できるイニシャライザを使って、適切な列挙ケース節を３つの可能な状態に対して選び取るように、そしてパラメータが３つの状態の内の１つに合わない場合に初期化が失敗するようにできます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use this failable initializer to try to initialize a new Animal instance and to check if initialization succeeded:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、この失敗できるイニシャライザを使うことで、新しいAnimalインスタンスを初期化することを試みて、初期化が成功したか確認することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use this initializer to initialize a new constant called theAceOfSpades:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、theAceOfSpadesと呼ばれる新しい定数を初期化するために、このイニシャライザを使うことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use this initializer to try to create a new instance of the enumeration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、このイニシャライザを使って、この列挙の新しいインスタンスを作成するように試みることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use this optional return value to check whether the optional chaining call was successful (the returned optional contains a value), or didn’t succeed due to a nil value in the chain (the returned optional value is nil).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、このオプショナルの戻り値を使って、オプショナル連鎖呼び出しが成功した（返されたオプショナルが値を含む）か、あるいは連鎖の中のnil値のために成功しなかった（返されたオプショナルの値がnilである）かどうか確認することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use this syntax anywhere that you can write an explicit member expression, not just in top-level code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはこの構文を、あなたが明示的メンバー式を記述可能なあらゆるところに使用できます、単にトップレベルコードにだけでなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use this syntax to hard wrap a multiline string literal in your source code, without changing the value of the resulting string.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、この構文を使うことで、複数行文字列リテラルをあなたのソースコードにおいてハードラップする（次行に送る）ことが、結果となる文字列の値を変更することなく行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use this to erase type information that varies between the conditional branches.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはこれを使うことで、条件分岐の間でさまざまに変化する型情報を消去できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use this type like any other type in Swift, which makes it easy to pass functions as parameters to other functions, and to return functions from functions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはスウィフトの他のあらゆる型と同じようにこの型を使うことができます、そしてそれは、他の関数へのパラメータとして関数を渡して、関数から関数を返すことを簡単にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use tuples to test multiple values in the same switch statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、複数の値を同じswitch文において試験するためにタプルを使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use type casting with a hierarchy of classes and subclasses to check the type of a particular class instance and to cast that instance to another class within the same hierarchy.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、いくつかのクラスおよびサブクラスからなるある階層とともに型キャストを使って、特定のクラスインスタンスの型を調べて、そのインスタンスを同じ階層内の別のクラスにキャストすることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use your own custom types as set value types or dictionary key types by making them conform to the Hashable protocol from the Swift standard library.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、あなた独自のあつらえの型を集合の値型または辞書のキー型として使用することが、それらをSwift標準ライブラリからのHashableプロトコルに適合させることで可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can write a closure without a name by surrounding code with braces ({}).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、名前なしで波括弧（{}）でコードを囲むことによってクロージャを書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can write a generic where clause as part of a declaration that doesn’t have its own generic type constraints, when you’re already working in the context of generic types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは総称体where節を、それ自身の総称体型制約を持たないある宣言の一部として書くことが、あなたが既に総称体型の文脈の中で作業している時は可能です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can write code that avoids duplication and expresses its intent in a clear, abstracted manner.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、重複を避けて、明快な、抽象化された手法で、その意図を表すコードを書くことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can write the Fahrenheit structure from above in a simpler form by providing a default value for its temperature property at the point that the property is declared:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、上記のFahrenheit構造体を、そのtemperatureプロパティのために省略時の値をそのプロパティが宣言される時点で用意することによって、より単純な形式で書くことができます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can write the same functionality as a generic function by replacing any mention of strings with values of some type T instead.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは同じ機能性を総称体関数として書くことが、何であれ文字列への言及部分をその代わりにある何らかの型Tの値で置き換えることで行えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can’t add property observers to inherited constant stored properties or inherited read-only computed properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、プロパティオブザーバーを、継承された定数格納プロパティに、または継承された読み出し専用の計算プロパティに加えることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can’t append a String or Character to an existing Character variable, because a Character value must contain a single character only.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはStringまたはCharacterを既存のCharacter変数に追加することはできません、なぜならCharacter値がただ１つの文字だけを含まなければならないためです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can’t define a failable and a nonfailable initializer with the same parameter types and names.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、失敗できる及び失敗できないイニシャライザを同じパラメータの型と名前で定義することはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can’t iterate over a one-sided range that omits a first value, because it isn’t clear where iteration should begin.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、最初の値を省いた片側範囲に対して反復していくことができません、なぜならどこで反復が始まるべきかが明瞭でないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can’t mark a variadic parameter or a return type with the inout keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、可変長パラメータまたは戻り型にinoutキーワードで印をつけることができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can’t overload a function based only on whether the function can throw an error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはある関数を、その関数がエラーをスローできるかどうかのみに基づいてオーバーロードできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can’t pass a constant or a literal value as the argument, because constants and literals can’t be modified.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは引数として定数またはリテラル値を渡すことができません、なぜなら定数とリテラルは修正されることができないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can’t pass in any type here, however—it has to be a type for which UInt16 provides an initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>しかしながら、あなたはあらゆる型をここに渡すことはできません ― それはUInt16がイニシャライザを提供する型でなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can’t provide an explicit access-level modifier for an extension if you’re using that extension to add protocol conformance.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがプロトコル準拠を加えるためにその拡張を使っているならば、あなたは明確なアクセス水準修飾子を拡張のために用意することが出来ません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can’t set a protocol requirement to a different access level than the protocol it supports.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、あるプロトコル要件をそれが支えるプロトコルと異なるアクセス水準に設定することができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can’t specify a different access level for individual enumeration cases.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、個々の列挙ケース節に対して異なるアクセス水準を指定することができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can’t use Container as the return type of a function because that protocol has an associated type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはContainerを関数の戻り型として使用できません、なぜならそのプロトコルが関連型を持つからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can’t use break, continue, defer, guard, or return statements, while statements, or do-catch statements in the code that a result builder transforms.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、break、continue、defer、guard、またはreturn文、while文、またはdo-catch文をリザルトビルダーが変換するコードにおいて使用できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can’t use nil with non-optional constants and variables.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、nilを非オプショナルの定数および変数で使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can’t use an unlabeled break statement to break out of an if statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、ラベルを付けられないbreak文をif文を脱するために使うことはできません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can’t, however, present an inherited read-write property as a read-only property.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、しかし、継承された読み書き両用プロパティを、読み出し専用のプロパティとして提示することができません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You check for an implementation of an optional method by writing a question mark after the name of the method when it’s called, such as someOptionalMethod?(someArgument).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、それが呼ばれるときに疑問符をそのメソッドの後に書くことによって、あるオプショナルメソッドの実装について確認することができます、例えばsomeOptionalMethod?(someArgument)のように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You could use generics to implement operations like flipping a shape vertically, as shown in the code below.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは総称体を使って、ある形状を垂直に裏返すような演算を実装できました、下のコードで示されるように。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You could write code that uses the behavior of a property wrapper, without taking advantage of the special attribute syntax.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはプロパティラッパーの挙動を使うコードを、この特別な属性構文を利用することなく記述できます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You create a new Stack instance by writing the type to be stored in the stack within angle brackets.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、新しいStackインスタンスを、角括弧の内側にそのスタックの中に格納される型を書くことによって作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You create a new instance of Vehicle with initializer syntax, which is written as a type name followed by empty parentheses:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、Vehicleの新しいインスタンスを初期化構文を使って作成します、それは１つの型名に続く空の丸括弧として書かれます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You create an instance of an actor using the same initializer syntax as structures and classes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、アクターのインスタンスを構造体およびクラスと同じ初期化構文を使って作成します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You declare constants with the let keyword and variables with the var keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、letキーワードを使って定数を、varキーワードを使って変数を宣言します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You define properties and methods to add functionality to your structures and classes using the same syntax you use to define constants, variables, and functions.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはプロパティとメソッドを定義することで、あなたの構造体およびクラスに機能性を加えます、それには定数、変数、そして関数を定義するのにあなたが使うのと同じ構文を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You define protocols in a very similar way to classes, structures, and enumerations:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、クラス、構造体、および列挙と非常に類似した方法で、プロトコルを定義します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You define this form of a variable declaration at global scope, the local scope of a function, or in the context of a class or structure declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、変数宣言のこの形式を、グローバルなスコープ、関数のローカルなスコープで、またはクラスおよび構造体宣言の文脈において定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You define this form of a variable declaration at global scope, the local scope of a function, or in the context of a class, structure, enumeration, or extension declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、変数宣言のこの形式を、グローバルなスコープ、関数のローカルなスコープで、またはクラス、構造体、列挙、および拡張宣言の文脈において定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You define type aliases with the typealias keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、typealiasキーワードで型エイリアスを定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You define type properties with the static keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、型プロパティをstaticキーワードを使って定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You do this by defining a generic where clause.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはこれを総称体where節を定義する事によって行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You do this by writing a complete function type immediately after the return arrow (-&gt;) of the returning function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、返すことになる関数の戻り矢印（-&gt;）の直後に完全な関数型を書くことによってこれをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You do this by writing the break statement as the entire body of the case you want to ignore.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、break文をあなたが無視したいケース節の全本文として書くことによってこれをします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You do this with an empty extension, as described in Declaring Protocol Adoption with an Extension:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>拡張を使ってプロトコル採用を宣言するで記述されるように、あなたは空の拡張でこれを行います</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You don’t have to provide an explicit implementation of a required initializer if you can satisfy the requirement with an inherited initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、あなたがある継承されたイニシャライザの要件を満たすことができるならば、必須イニシャライザの明示的な実装を提供する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You don’t have to provide convenience initializers if your class doesn’t require them.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたのクラスがそれらを必要としないならば、あなたは便宜イニシャライザを提供する必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You don’t know in advance which actual class to use for each item, and so it’s appropriate to use the conditional form of the type cast operator (as?) to check the downcast each time through the loop:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、前もって、各項目のために使われる実際のクラスがどれかを知りません、なので適切なのは、型キャスト演算子の条件形式（as?）を使用してループを通して毎回ダウンキャストを確認することです：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You don’t need to import a separate library for functionality like input/output or string handling.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、入力／出力または文字列取り扱いのような機能性のために個々のライブラリをインポートする必要はありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You don’t need to mark protocol initializer implementations with the required modifier on classes that are marked with the final modifier, because final classes can’t subclassed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはfinal修飾子で印されるクラス上でプロトコルイニシャライザ実装をrequired修飾子で印する必要はありません、なぜなら、finalクラスはサブクラスを作られることができないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You don’t need to specify the type of the closure’s input parameter, number, because the type can be inferred from the values in the array to be mapped.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはクロージャの入力パラメータ、numberの型を指定する必要がありません、なぜならその型は対応付けされる配列の値から推論されることが可能だからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You don’t specify a precedence when defining a prefix or postfix operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、接頭辞または接尾辞演算子を定義するときに優先順位を指定しません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You don’t write the override modifier when overriding a required designated initializer:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、必須指定イニシャライザをオーバーライドする時にoverride修飾子を書きません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You enable this by writing : CaseIterable after the enumeration’s name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、これを: CaseIterableを列挙の名前の後に書くことによって可能にします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You extract each associated value as a constant (with the let prefix) or a variable (with the var prefix) for use within the switch case’s body:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、関連値それぞれを定数（let接頭辞を使って）または変数（var接頭辞を使って）としてswitchのケース節の本文内で使用するために抽出します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You get the same behavior of delayed evaluation when you pass a closure as an argument to a function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが同じ挙動の延期した評価を得るのは、あなたがクロージャを引数として関数に渡す時です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You give a function a name that identifies what it does, and this name is used to “call” the function to perform its task when needed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは関数にそれが何をするかについて識別する名前を与えます、そしてこの名前が必要なときその作業を実行するために関数を「呼び出す」のに使われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You have access to the type parameters (and any of their associated types) in the rest of the type, function, or initializer declaration, including in the signature of the function or initializer.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、そのままの型、関数、またはイニシャライザ宣言の中の、さらに含めて関数またはイニシャライザのシグネチャの中の、型パラメータ（およびあらゆるそれの関連型）にアクセスします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You have complete flexibility to manage unstructured tasks in whatever way your program needs, but you’re also completely responsible for their correctness.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、なんでもあなたのプログラムが必要とする方法において非構造化タスクを管理する完全な柔軟性を持ちます、しかしあなたはまたそれらの正しさに対して完全に責任を負います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You have several options for writing closures more concisely.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、より簡潔にクロージャを書くためにいくつかの選択肢を持ちます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You have the option to define either or both of these observers on a property:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、あるプロパティに関してこれらのオブザーバーのどちらかまたは両方とも定義する選択肢を持ちます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You implement a prefix or postfix unary operator by writing the prefix or postfix modifier before the func keyword when declaring the operator method:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、接頭辞または接尾辞単項演算子を、prefixまたはpostfix修飾子をfuncキーワードの前に演算子メソッドを宣言するときに書くことによって実装します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You implement this initialization process by defining initializers, which are like special methods that can be called to create a new instance of a particular type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはこの初期化処理をイニシャライザを定義することによって実装します、それは、特定の型の新しいインスタンスをつくるために呼ばれることができる特別なメソッドのようなものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You indicate a lazy stored property by writing the lazy modifier before its declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、lazy修飾子をその宣言の前に書くことによって遅延格納プロパティであることを示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You indicate a type subscript by writing the static keyword before the subscript keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは型添え字を、staticキーワードをsubscriptキーワードの前に書くことによって指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You indicate a weak reference by placing the weak keyword before a property or variable declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、プロパティまたは変数の宣言の前にweakキーワードを置くことによって弱い参照を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You indicate an unowned reference by placing the unowned keyword before a property or variable declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、プロパティまたは変数の宣言の前にunownedキーワードを置くことによって非所有参照を示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You indicate an unsafe unowned reference by writing unowned(unsafe).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、安全でない非所有参照をunowned(unsafe)を書くことによって指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You indicate that an enumeration case is recursive by writing indirect before it, which tells the compiler to insert the necessary layer of indirection.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、ある列挙ケース節が再帰することをそれの前にindirectを書くことによって指し示します、それは、コンパイラに不可欠な間接参照の階層を差し入れるように伝えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You indicate the function’s return type with the return arrow -&gt; (a hyphen followed by a right angle bracket), which is followed by the name of the type to return.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、関数の戻り型を、戻り矢印-&gt;（ハイフンに続けて右の山形括弧）、それに続く返す型の名前で示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You indicate type methods by writing the static keyword before the method’s func keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、型メソッドをstaticキーワードをメソッドのfuncキーワードの前に書くことによって示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You indicate whether a particular String can be modified (or mutated) by assigning it to a variable (in which case it can be modified), or to a constant (in which case it can’t be modified):</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、特定のStringが修正される（または変化する）ことができるかどうか、それを変数（その場合それは修が可能です）にまたは定数（その場合それは修正できません）に代入することによって示します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You introduce an actor with the actor keyword, followed by its definition in a pair of braces.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはあるアクターをactorキーワード、それに続けて一対の波カッコの中のそれの定義で導入します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You introduce enumerations with the enum keyword and place their entire definition within a pair of braces:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、列挙をenumキーワードで始めて、一対の波括弧の内側にそれらの全ての定義を置きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You introduce structures with the struct keyword and classes with the class keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、structキーワードで構造体を、そしてclassキーワードでクラスを始めます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You mark a compound assignment operator’s left input parameter type as inout, because the parameter’s value will be modified directly from within the operator method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは複合代入演算子の左入力パラメーター型をinoutとして印します、なぜなら、このパラメーターの値は直接にこの演算子メソッド内で修正されることになるからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You may have noticed that the bodies of the swapTwoInts(_:_:), swapTwoStrings(_:_:), and swapTwoDoubles(_:_:) functions are identical.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、swapTwoInts(_:_:)、swapTwoStrings(_:_:)、そしてswapTwoDoubles(_:_:)関数の本文が同一であると気がついたかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You may, however, want to mark some parts of your code as file private or private in order to hide their implementation details from other code within the app’s module.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、しかし、あなたのコードのいくつかの部分をファイル外非公開または非公開として印して、それらの実施詳細をそのアプリのモジュール内の他のコードから隠したいかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You might expect this function to have the default access level of “internal”, but this isn’t the case.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはこの関数が省略時アクセス水準の「内部」を持つのを期待するかもしれません、しかし事実はそうではありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You might want to run an extra piece of code when an error occurs, or to display a message when a value becomes too high or too low.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、エラーが発生する時にコードの臨時の小片を実行したいかもしれません、またある値があまりに高いかあまりに低くなる時にお知らせを表示したいかもしれません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You must also write the required modifier before every subclass implementation of a required initializer, to indicate that the initializer requirement applies to further subclasses in the chain.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはまた、required修飾子を必須イニシャライザの全てのサブクラス実装の前に書かなければなりません、そうすることでそのイニシャライザ要件がさらにその連鎖のサブクラスに適用されることを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You must always declare a lazy property as a variable (with the var keyword), because its initial value might not be retrieved until after instance initialization completes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは常に遅延プロパティを変数として（varキーワードを使って）宣言しなければなりません、なぜならその最初の値はインスタンスの初期化が完了する後まで取り出されないかもしれないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You must always state both the name and the type of the property you are overriding, to enable the compiler to check that your override matches a superclass property with the same name and type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、常にあなたがオーバーライドしているプロパティの名前と型を明確に述べなければなりません、そうすることであなたのオーバーライドがスーパークラスの同じ名前と型をもつプロパティと合致することをコンパイラが確認できるようになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You must declare computed properties—including read-only computed properties—as variable properties with the var keyword, because their value isn’t fixed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、計算プロパティ ― 読み出し専用の計算プロパティを含む ― をvarキーワードをつかって変数プロパティとして宣言しなければなりません、なぜならそれらの値は固定されないからです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You must specify the access level explicitly as part of the function’s definition if the function’s calculated access level doesn’t match the contextual default.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>その関数の計算されたアクセス水準が省略時の文脈に合致しないと思うならば、あなたは関数の定義の一部として明確にアクセス水準を指定しなければなりません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You need to mark an entity as open or public only if you want it to become part of your framework’s API.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、それにあなたのフレームワークのもつAPIの一部になってほしいならば、ある実在を開放または公開として印する必要があります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You now write prefix operator rather than operator prefix, for example.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは今や、prefix operatorと書きます、operator prefixではなく、例えば。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You pass this function an expression that evaluates to true or false and a message to display if the result of the condition is false.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはこの関数に、trueまたはfalseに評価する式と条件の結果がfalseであるならば表示するメッセージを渡します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You pass this initializer a default value of the appropriate type (called repeating): and the number of times that value is repeated in the new array (called count):</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、このイニシャライザに対して、適切な型のひとつの初期値（repeatingと呼ばれます）、そしてその値が新しい配列の中で繰り返される回数（countと呼ばれます）とを渡します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You perform this comparison with the “equal to” operator (==) or the “not equal to” operator (!=).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、この比較を「同等」演算子（==）または「不等」演算子（!=）を使って実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You place an ampersand (&amp;) directly before a variable’s name when you pass it as an argument to an in-out parameter, to indicate that it can be modified by the function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは変数の名前の直前に、あなたがin-outパラメータに対する引数としてそれを渡すときに、それが関数によって修正されることができることを示すために、アンパサンド（&amp;）を置きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You place your string within quotation marks (") and surround that with number signs (#).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、あなたの文字列を引用符（"）内に置きます、そしてそれをシャープ記号（#）で囲みます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You provide an implementation of the == operator in the same way as you implement other infix operators:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、==演算子の実装を、あなたが他の接中辞演算子を実装するのと同じ方法で提供します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You replace these types with the actual types that your result builder uses.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、これらの型をあなたのリザルトビルダーが使う実際の型で置き換えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You represent errors using any type that adopts the Error protocol.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、Errorプロトコルを採用するどんな型でも使用してエラーを表します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You resolve a strong reference cycle between a closure and a class instance by defining a capture list as part of the closure’s definition.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、クロージャの定義の一部として捕獲リストを定義することによってクロージャとクラスインスタンスの間で強い参照循環を解消します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You resolve strong reference cycles by defining some of the relationships between classes as weak or unowned references instead of as strong references.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、クラス間の関係の一部を強い参照としてでなくて弱い、または非所有参照として定義することによって強い参照循環を解消します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You saw above how a strong reference cycle can be created when two class instance properties hold a strong reference to each other.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは上で、２つのクラスインスタンスプロパティが強い参照にお互いを守らせるとき、どのように強い参照循環がつくられることができるかを見ました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You set an optional variable to a valueless state by assigning it the special value nil:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたが、あるオプショナルの変数を値が無い状態へと設定するには、それに特別な値nilを代入します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You specify a declaration modifier by writing the appropriate keyword or context-sensitive keyword between a declaration’s attributes (if any) and the keyword that introduces the declaration.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、宣言修飾子を適切なキーワードまたは文脈依存キーワードを宣言の属性（もしあれば）と宣言を導入するキーワードとの間に書くことによって指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You specify a default property value by assigning an initial value to the property when it’s defined.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、それが定義されるときプロパティに初期値を代入することによって、省略時のプロパティ値を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You specify an attribute by writing the @ symbol followed by the attribute’s name and any arguments that the attribute accepts:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、@記号に続いてその属性の名前そしてその属性が受け入れる任意の引数を書くことによって属性を指定します：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You specify optional chaining by placing a question mark (?) after the optional value on which you wish to call a property, method or subscript if the optional is non-nil.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはオプショナル連鎖を、そのオプショナルがnilで無いならばあなたがプロパティ、メソッド、または添え字を呼び出したいオプショナルの値の後に疑問符（?）を置くことによって指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You specify the associativity of an operator by writing one of the context-sensitive keywords left, right, or none—if your omit the associativity, the default is none.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはある演算子の結合性を文脈依存キーワードleft、right、またはnoneのうちの１つを書くことによって指定します—あなたが結合性を省略するならば、初期状態はnoneです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You specify the nature of the mapping and the type of the returned value by writing code in the closure that you pass to map(_:).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、マッピング（対応付け）の性質と返される値の型を、あなたがmap(_:)に渡すクロージャの中でコードを記述することによって指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You typically define a failable initializer that creates an optional instance of the appropriate type by placing a question mark after the init keyword (init?).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは一般的に、適切な型のオプショナルのインスタンスを作成する失敗できるイニシャライザを、疑問符をinitキーワードの後において（init?）定義します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You typically use internal access when defining an app’s or a framework’s internal structure.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは概して内部アクセスを、アプリのまたはフレームワークの内部用の構造体を定義するときに使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You typically use open or public access when specifying the public interface to a framework.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは概して開放または公開アクセスを、あるフレームワークに公開インタフェースを指定するときに使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You use for-in to iterate over items in a dictionary by providing a pair of names to use for each key-value pair.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはfor-inを使って、辞書の中の項目のすべてに対して繰り返すことを、一対の名前を提供してそれぞれの「キーと値」の対に使用することで行います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You use try? to handle an error by converting it to an optional value.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、try?を使って、あるエラーをオプショナルの値に変換することによって取り扱うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You use error handling to respond to error conditions your program may encounter during execution.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、エラー処理を使ってあなたのプログラムが実行の間に遭遇するエラー状態に応答することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You use optional binding to find out whether an optional contains a value, and if so, to make that value available as a temporary constant or variable.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、あるオプショナルが値を含むかどうか知るために、そしてもしそうならば、その値を一時的な定数または変数として利用可能にするために、オプショナル束縛を使うことができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You use optionals in situations where a value may be absent.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはオプショナルを、ある値が不在かもしれない状況において使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You use a defer statement to execute a set of statements just before code execution leaves the current block of code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはdefer文を使うことで、コード実行が現在のコードブロックから離れる直前に一揃いの文を実行するようにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You use a do-catch statement to handle errors by running a block of code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、あるコードの塊を実行することによってエラーを処理するために、do-catch文を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You use a throw statement to throw an error.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはthrow文を使ってエラーをスローします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You use a guard statement to require that a condition must be true in order for the code after the guard statement to be executed.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはguard文を使って、guard文の後のコードが実行されるためにはある条件が真でなけれればならないことを要求します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You use a dictionary when you need to look up values based on their identifier, in much the same way that a real-world dictionary is used to look up the definition for a particular word.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>現実世界の辞書が特定の語の定義を調べるために使われるのと全く同様に、あなたが値をそれらの識別子に基づいて調べる必要があるとき、あなたは辞書を使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You use a generic where clause in a protocol declaration to add constraints to an associated types inherited from another protocol, without redeclaring the associated types.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、総称体where節をプロトコル宣言の中で使うことで、別のプロトコルから継承された関連型に制約を追加します、その関連型を再宣言することなしに。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You use a variadic parameter to specify that the parameter can be passed a varying number of input values when the function is called.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは可変長パラメータを、関数が呼ばれる時にそのパラメータが変動する数の入力値を渡されることができることを示すために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You use an availability condition in an if or guard statement to conditionally execute a block of code, depending on whether the APIs you want to use are available at runtime.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、有効性条件をifまたはguard文の中で使って、あなたが使用したいAPIが実行時に有効かどうかに基づいて、条件付きでコードブロックを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You use an availability condition to execute a block of code, depending on whether the APIs you want to use are available at runtime.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、有効性条件を使って、あなたが使用したいAPIが実行時に有効かどうかに基づいて、あるコードのブロックを実行します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You use assertions and preconditions to express the assumptions you make and the expectations you have while coding, so you can include them as part of your code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは表明と前提条件を使うことであなたのする想定とあなたが持つ期待をコーディングの間に表します、それであなたはそれらをあなたのコードの一部として含めることができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You use function types just like any other types in Swift.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、関数型をスウィフトでのあらゆる他の型と同じように使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You use it to create logical expressions in which only one of the two values has to be true for the overall expression to be true.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはそれを、全体的な式がtrueになるためには２つの値のうちの１つだけがtrueであればよい論理式をつくるために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You use key-path expressions in dynamic programming tasks, such as key-value observing.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはキーパス式を動的なプログラミング作業、例えばキー値監視などにおいて使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You use platform names such as iOS, macOS, watchOS, and tvOS—for the full list, see Declaration Attributes.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、例えばiOS、macOS、watchOS、そしてtvOSのようなプラットホーム名を使います—完全なリストのために、宣言属性を見てください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You use result builders to implement a domain-specific language (DSL) for creating nested data structures in a natural, declarative way.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはリザルトビルダーを使用することで、入れ子にされたデータ構造の自然な、宣言的な方法での作成のためにあるドメイン固有言語 (DSL) を実装します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You use subscripts to set and retrieve values by index without needing separate methods for setting and retrieval.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは添え字を使うことで、独立したメソッドを設定や検索のために必要とすることなしに、インデックスによって値を設定したり取得したりします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You use the for-in loop to iterate over a sequence, such as items in an array, ranges of numbers, or characters in a string.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはfor-inループを、ある連続物について、例えば配列の中の項目、数の範囲、または文字列の中の文字について、それに含まれるすべてに繰り返していくために使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You use the nonobjc attribute to resolve circularity for bridging methods in a class marked with the objc attribute, and to allow overloading of methods and initializers in a class marked with the objc attribute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、objc属性で印されるクラスの中のブリッジしているメソッドに対する循環性を解決するために、そしてobjc属性で印されるクラスにおいてメソッドとイニシャライザをオーバーロードすることを許可するためにnonobjc属性を使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You use the self property to distinguish between the parameter name and the property name.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、selfプロパティをパラメータ名とプロパティ名を区別するために使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You use the self property to refer to the current instance within its own instance methods.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、selfプロパティを現在のインスタンスに言及するためにそれ自身のインスタンスメソッド内で使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You use the buildLimitedAvailability(_:) method to erase type information that changes depending on which branch is taken.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、buildLimitedAvailability(_:)メソッドを使用することで、どの分岐が取られるかに依存して変化する型情報を消去します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You use the case keyword to introduce new enumeration cases.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはcaseキーワードを使って、新しい列挙ケース節を導入することができます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You use the initializer expression in a function call expression to initialize a new instance of a type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、イニシャライザ式を関数呼び出し式において使うことで、ある型の新しいインスタンスを初期化します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You use the runtime name when calling functions that interact with the Objective-C runtime, like NSClassFromString [https://developer.apple.com/documentation/foundation/1395135-nsclassfromstring], and when specifying class names in an app’s Info.plist file.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはランタイム名を、Objective-Cランタイムと相互作用する関数、NSClassFromString [https://developer.apple.com/documentation/foundation/1395135-nsclassfromstring]などを呼び出す時に、そしてクラス名をアプリのもつInfo.plistファイルの中で指定する時に使います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You use them to make sure an essential condition is satisfied before executing any further code.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはそれらを使って、必要不可欠な条件が満たされるのを何らかのその先のコードが実行される前に確実なものにします。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You use these patterns in a case label of a switch statement, a catch clause of a do statement, or in the case condition of an if, while, guard, or for-in statement.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはこれらのパターンをswitch文のケース節ラベル、do文のcatch節において、またはif、while、guard、およびfor-in文のケース節条件において使用します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You usually implement the == operator, and use the standard library’s default implementation of the != operator that negates the result of the == operator.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは普通は==演算子を実装します、そして標準ライブラリのもつ!=演算子の省略時の実装を使います、それは==演算子の結果を否定するものです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You want to draw 60 tick marks, starting with the 0 minute.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、0分から開始して、60個の目盛りを描こうと思います。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You write await in front of the call to mark the possible suspension point.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、awaitをその呼び出しの前に書くことで可能な中断地点を印します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You write return nil within a failable initializer to indicate a point at which initialization failure can be triggered.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは失敗できるイニシャライザの内部でreturn nilを書くことで、そこにおいて初期化失敗が引き起こされる可能性がある地点を指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You write a failable initializer by placing a question mark after the init keyword (init?).</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、失敗可能なイニシャライザを疑問符をinitキーワードの後に置くこと（init?）によって記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You write a generic where clause right before the opening curly brace of a type or function’s body.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、総称体where節を、型や関数のもつ本文の開き波括弧のまさに前に記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You write a pattern after catch to indicate what errors that clause can handle.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、catchの後にあるパターンを書いてどんなエラーをその節が取り扱えるかを指し示します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You write a pattern after catch just as you do after case in a switch.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、まさにあなたがスイッチにおいてcaseの後にするように、catchの後にひとつのパターンを書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You write a precondition by calling the precondition(_:_:file:line:) [https://developer.apple.com/documentation/swift/1540960-precondition] function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、前提条件をprecondition(_:_:file:line:) [https://developer.apple.com/documentation/swift/1540960-precondition]関数を呼び出すことによって記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You write a trailing closure after the function call’s parentheses, even though the trailing closure is still an argument to the function.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、後付クロージャを関数呼び出しのもつ丸括弧それらの後に書きます、そうであってもその後付クロージャは依然として関数への引数のままです。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You write an argument label before the parameter name, separated by a space:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは引数ラベルを、パラメーター名の前に、空白で区切って書きます：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You write an assertion by calling the assert(_:_:file:line:) [https://developer.apple.com/documentation/swift/1541112-assert] function from the Swift standard library.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは表明をassert(_:_:file:line:) [https://developer.apple.com/documentation/swift/1541112-assert]関数をSwift標準ライブラリから呼び出すことによって記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You write an implicitly unwrapped optional by placing an exclamation point (String!) rather than a question mark (String?) after the type that you want to make optional.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは暗黙的にアンラップされるオプショナルを、あなたがオプショナルを作りたい型の後に疑問符（String?）ではなく感嘆符（String!）を置くことによって記述します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You write an in-out parameter by placing the inout keyword right before a parameter’s type.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、パラメータの型のすぐ前にinoutキーワードを置くことによってin-outパラメータを書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You write an instance method within the opening and closing braces of the type it belongs to.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、インスタンスメソッドを、それが属している型の開始と終わりの波括弧の内部に書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You write an optional tuple return type by placing a question mark after the tuple type’s closing parenthesis, such as (Int, Int)? or (String, Int, Bool)?.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはオプショナルタプルの戻り型をタプル型の閉じ括弧の後に疑問符を置くことによって書きます、例えば(Int, Int)?または(String, Int, Bool)?など。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You write deinitializers with the deinit keyword, similar to how initializers are written with the init keyword.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、イニシャライザがinitキーワードで書かれる方法と同様に、デイニシャライザをdeinitキーワードを使って書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You write nested comments by starting a multiline comment block and then starting a second multiline comment within the first block.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはひとつの複数行コメント・ブロックを始めて、それから第二の複数行を最初のブロック以内に始めることによって入れ子にされたコメントを書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You write subscript definitions with the subscript keyword, and specify one or more input parameters and a return type, in the same way as instance methods.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、添え字定義をsubscriptキーワードを使って書きます、そしてインスタンスメソッドと同じ方法で、１つ以上の入力パラメータと戻り型を指定します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You write the diagnostic message as a static string literal.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、診断メッセージを静的文字列リテラルとして書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You write the placeholder type name inside angle brackets after subscript, and you write a generic where clause right before the opening curly brace of the subscript’s body.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、プレースホルダ型名を山括弧の内部にsubscriptの後に書きます、そしてあなたは総称体where節を添え字本文の開き波括弧の直前に書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You write these constraints after the name of the protocol you’re extending by writing a generic where clause.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたはこれらの制約を、総称体where節を書くことによってあなたが拡張しているプロトコルの名前の後に書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You write these initializers as part of the protocol’s definition in exactly the same way as for normal initializers, but without curly braces or an initializer body:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、これらのイニシャライザをプロトコル定義の一部として普通のイニシャライザと正確に同じ方法で書くことができます、しかし波括弧またはイニシャライザ本文はありません：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You write type constraints by placing a single class or protocol constraint after a type parameter’s name, separated by a colon, as part of the type parameter list.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、型パラメーターリストの一部として、型パラメータの名前の後にコロンで区切って１つのクラスまたはプロトコル制約を置くことによって、型制約を書きます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Your code calls the update(with:) method.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたのコードがupdate(with:)メソッドを呼び出します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Your code can interact with these identifiers, but you can’t declare identifiers with that prefix.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたのコードは、それらの識別子と相互作用できます、しかしあなたは識別子をその接頭辞で宣言できません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Your code finishes its update by changing max.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたのコードは、その更新をmaxを変更することによって終了します。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You’re accessing only stored properties of an instance, not computed properties or class properties.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたがインスタンスの格納プロパティだけにアクセスしている、計算プロパティやクラスプロパティではなく。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You’re likely to encounter this kind of error in two kinds of situations.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、この種のエラーに２種類の状況において出くわしそうに思われます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You’re not limited to the predefined operators.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、あらかじめ定義された演算子に制限されていません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You’ve actually been using value types extensively throughout the previous chapters.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>あなたは、実際に前の章を通して広く値型を使っていました。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Zeros are inserted in the spaces left behind after the original bits are moved to the left or right.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>元のビットが左または右へ移動した後に残される空きに、ゼロが差し込まれます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Zeros become ones, and ones become zeros.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ゼロは１になります、そして１はゼロになります。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>but is written over multiple lines.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>（しかし複数行にわたって書かれます。）</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>giving a remainder value of -1.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>そして-1の余り値を与えます。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>there’s only one loop in the game, and therefore no ambiguity as to which loop the continue statement will affect.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>このゲームにはただ１つのループしかありません、それゆえにcontinue文が影響を及ぼすループはどれかについての曖昧さもありません。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>where some multiplier is the largest number of multiples of b that will fit inside a.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>ここでsome multiplierはbの倍数でaの内部に収まる最も大きな数です。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>“A function that has two parameters, both of type Int, and that returns a value of type Int.”</seg>
      </tuv>
      <tuv lang="ja">
        <seg>「２つのパラメータを持ち、両方とも型Intで、そして型Intの値をひとつ返す関数」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>“Consider the value of directionToHead.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>「directionToHeadの値を考慮する。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>“Declare a new constant called maximumNumberOfLoginAttempts, and give it a value of 10.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>「maximumNumberOfLoginAttemptsと呼ばれるある新しい定数を宣言して、それに10というひとつの値を与える。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>“Declare a variable called welcomeMessage that’s of type String.”</seg>
      </tuv>
      <tuv lang="ja">
        <seg>「welcomeMessageと呼ばれる型Stringの変数を宣言する。」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>“Define a variable called mathFunction, which has a type of ‘a function that takes two Int values, and returns an Int value.’ Set this new variable to refer to the function called addTwoInts.”</seg>
      </tuv>
      <tuv lang="ja">
        <seg>「『２つのInt値をとり、１つのInt値を返す関数』の型を持ち、mathFunctionと呼ばれる、ある変数を定義する。この新しい変数をaddTwoIntsと呼ばれる関数に言及するように設定する。」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>“Define an enumeration type called Barcode, which can take either a value of upc with an associated value of type (Int, Int, Int, Int), or a value of qrCode with an associated value of type String.”</seg>
      </tuv>
      <tuv lang="ja">
        <seg>「Barcodeと呼ばれる列挙型を定義します、それはupcの値で型（Int、Int、Int、Int）の関連値をもつ、またはqrCodeの値で型Stringの関連値をもつものをとることができます。」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>“If the optional Int returned by Int(possibleNumber) contains a value, set a new constant called actualNumber to the value contained in the optional.”</seg>
      </tuv>
      <tuv lang="ja">
        <seg>「Int(possibleNumber)によって返されるオプショナルのIntが値を含むならば、ある新しい定数actualNumberをそのオプショナルに含まれる値に設定してください。」</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>“Try to access item as a Movie.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>「itemにMovieとしてアクセスを試みてください。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>…and so on.</seg>
      </tuv>
      <tuv lang="ja">
        <seg>…などなど。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>…and so on:</seg>
      </tuv>
      <tuv lang="ja">
        <seg>…などなど：</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
