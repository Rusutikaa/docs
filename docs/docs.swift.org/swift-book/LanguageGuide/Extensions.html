<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="author" content="Apple Inc.">
    <meta name="viewport" content="width=device-width initial-scale=1">
    
    <title>Extensions — The Swift Programming Language (Swift 5.6)</title>
    
    <link rel="license" href="/LICENSE.txt">
    <link rel="stylesheet" media="all" href="../static/stylesheets/application.css">
    <link rel="stylesheet" media="all" href="../static/stylesheets/tspl.css">
    <link rel="shortcut icon" sizes="16x16 24x24 32x32 48x48 64x64" type="image/vnd.microsoft.icon" href="/favicon.ico">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
    <link rel="mask-icon" href="/assets/images/icon-swift.svg" color="#F05339"> 
  </head>
  <body>


<nav role="navigation">
    <header role="banner">
      <h1 id="logo">
        <a href="https://swift.org/" title="Swift.org" role="img" aria-label="Swift.org">
          Swift.org
        </a>
      </h1>
    </header>

    <div id="menu-toggle" class="menu-toggle open"></div>

    <h2>The Swift Programming Language<div>Swift 5.6</div>
</h2>

    <ul>
    <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html"><span class="enstr">Welcome to Swift</span><!--end_enstr-->
<span class="jpstr">
スウィフトにようこそ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1 current">
<a class="reference internal" href="TheBasics.html"><span class="enstr">Language Guide</span><!--end_enstr-->
<span class="jpstr">
言語ガイド
</span><!--end_jpstr-->
</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="TheBasics.html"><span class="enstr">The Basics</span><!--end_enstr-->
<span class="jpstr">
基本
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="BasicOperators.html"><span class="enstr">Basic Operators</span><!--end_enstr-->
<span class="jpstr">
基本の演算子
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="StringsAndCharacters.html"><span class="enstr">Strings and Characters</span><!--end_enstr-->
<span class="jpstr">
文字列と文字
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="CollectionTypes.html"><span class="enstr">Collection Types</span><!--end_enstr-->
<span class="jpstr">
コレクション型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ControlFlow.html"><span class="enstr">Control Flow</span><!--end_enstr-->
<span class="jpstr">
制御の流れ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Functions.html"><span class="enstr">Functions</span><!--end_enstr-->
<span class="jpstr">
関数
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Closures.html"><span class="enstr">Closures</span><!--end_enstr-->
<span class="jpstr">
クロージャ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Enumerations.html"><span class="enstr">Enumerations</span><!--end_enstr-->
<span class="jpstr">
列挙
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ClassesAndStructures.html"><span class="enstr">Structures and Classes</span><!--end_enstr-->
<span class="jpstr">
構造体とクラス
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Properties.html"><span class="enstr">Properties</span><!--end_enstr-->
<span class="jpstr">
プロパティ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Methods.html"><span class="enstr">Methods</span><!--end_enstr-->
<span class="jpstr">
メソッド
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Subscripts.html"><span class="enstr">Subscripts</span><!--end_enstr-->
<span class="jpstr">
添え字
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Inheritance.html"><span class="enstr">Inheritance</span><!--end_enstr-->
<span class="jpstr">
継承
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Initialization.html"><span class="enstr">Initialization</span><!--end_enstr-->
<span class="jpstr">
初期化
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Deinitialization.html"><span class="enstr">Deinitialization</span><!--end_enstr-->
<span class="jpstr">
デイニシャライズ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="OptionalChaining.html"><span class="enstr">Optional Chaining</span><!--end_enstr-->
<span class="jpstr">
オプショナル連鎖
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ErrorHandling.html"><span class="enstr">Error Handling</span><!--end_enstr-->
<span class="jpstr">
エラーの処理
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html"><span class="enstr">Concurrency</span><!--end_enstr-->
<span class="jpstr">
並行性
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="TypeCasting.html"><span class="enstr">Type Casting</span><!--end_enstr-->
<span class="jpstr">
型キャスト
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="NestedTypes.html"><span class="enstr">Nested Types</span><!--end_enstr-->
<span class="jpstr">
入れ子にされた型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#"><span class="enstr">Extensions</span><!--end_enstr-->
<span class="jpstr">
拡張
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Protocols.html"><span class="enstr">Protocols</span><!--end_enstr-->
<span class="jpstr">
プロトコル
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Generics.html"><span class="enstr">Generics</span><!--end_enstr-->
<span class="jpstr">
総称体
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="OpaqueTypes.html"><span class="enstr">Opaque Types</span><!--end_enstr-->
<span class="jpstr">
不透明型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AutomaticReferenceCounting.html"><span class="enstr">Automatic Reference Counting</span><!--end_enstr-->
<span class="jpstr">
自動参照カウント
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="MemorySafety.html"><span class="enstr">Memory Safety</span><!--end_enstr-->
<span class="jpstr">
メモリ安全
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AccessControl.html"><span class="enstr">Access Control</span><!--end_enstr-->
<span class="jpstr">
アクセス制御
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AdvancedOperators.html"><span class="enstr">Advanced Operators</span><!--end_enstr-->
<span class="jpstr">
先進の演算子
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ReferenceManual/AboutTheLanguageReference.html"><span class="enstr">Language Reference</span><!--end_enstr-->
<span class="jpstr">
言語リファレンス
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1"><a class="reference internal" href="../RevisionHistory/RevisionHistory.html"><span class="enstr">Revision History</span><!--end_enstr-->
<span class="jpstr">
改訂履歴
</span><!--end_jpstr-->
</a></li>
</ul>

    <li class="toctree-l1 return"><a class="reference internal" href="../../../index.html">← Go to Index</a></li>
    </ul>
</nav>




<main role="main">
    <article class="page">
        <menu id="bashful" type="toolbar">
          <div class="inner">
            <menuitem id="jump_to" class="menu-bar-item closed">
            <span id="jump_to_toggle">On This Page</span>
            <div class="chevron">
                <div class="chevy chevron-left"></div>
                <div class="chevy chevron-right"></div>
            </div>
            <menu type="list" class="details">
<ul>
<li>
<a class="reference internal" href="#"><span class="enstr">Extensions</span><!--end_enstr-->
<span class="jpstr">
拡張
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID470"><span class="enstr">Extension Syntax</span><!--end_enstr-->
<span class="jpstr">
拡張構文
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID152"><span class="enstr">Computed Properties</span><!--end_enstr-->
<span class="jpstr">
計算プロパティ
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID153"><span class="enstr">Initializers</span><!--end_enstr-->
<span class="jpstr">
イニシャライザ
</span><!--end_jpstr-->
</a></li>
<li>
<a class="reference internal" href="#ID154"><span class="enstr">Methods</span><!--end_enstr-->
<span class="jpstr">
メソッド
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID155"><span class="enstr">Mutating Instance Methods</span><!--end_enstr-->
<span class="jpstr">
変更インスタンスメソッド
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID156"><span class="enstr">Subscripts</span><!--end_enstr-->
<span class="jpstr">
添え字
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID157"><span class="enstr">Nested Types</span><!--end_enstr-->
<span class="jpstr">
入れ子にされた型
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
</ul>

            
                </menu>
            </menuitem>
          </div>
        </menu>

        
  <div class="section" id="extensions">
<h1><span class="enstr">Extensions<a class="headerlink" href="#extensions" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
拡張<a class="headerlink" href="#extensions" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h1>
<p><span class="enstr"><em>Extensions</em> add new functionality to an existing class, structure, enumeration, or protocol type. This includes the ability to extend types for which you don’t have access to the original source code (known as <em>retroactive modeling</em>). Extensions are similar to categories in Objective-C. (Unlike Objective-C categories, Swift extensions don’t have names.)</span><!--end_enstr-->
<span class="jpstr">
<em>拡張</em>は、新しい機能性を既存のクラス、構造体、列挙、またはプロトコル型に加えます。これは、あなたが元々のソース・コードにアクセスをしないで型を拡張する能力を含みます（<em>遡及モデリング</em>として知られます）。拡張は、Objective-Cでのカテゴリーに似ています。（Objective-Cカテゴリーとは異なり、スウィフト拡張には、名前がありません。）
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Extensions in Swift can:</span><!--end_enstr-->
<span class="jpstr">
スウィフトの拡張は、以下が可能です：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li><span class="enstr">Add computed instance properties and computed type properties</span><!--end_enstr-->
<span class="jpstr">
計算インスタンスプロパティと計算型プロパティを加える
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Define instance methods and type methods</span><!--end_enstr-->
<span class="jpstr">
インスタンスメソッドと型メソッドを定義する
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Provide new initializers</span><!--end_enstr-->
<span class="jpstr">
新しいイニシャライザを提供する
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Define subscripts</span><!--end_enstr-->
<span class="jpstr">
添え字を定義する
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Define and use new nested types</span><!--end_enstr-->
<span class="jpstr">
新しい入れ子にされた型を定義して、使用する
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Make an existing type conform to a protocol</span><!--end_enstr-->
<span class="jpstr">
既存の型をプロトコルに準拠させる
</span><!--end_jpstr-->
</li>
</ul>
<p><span class="enstr">In Swift, you can even extend a protocol to provide implementations of its requirements or add additional functionality that conforming types can take advantage of. For more details, see <a class="reference internal" href="Protocols.html#ID521"><span class="std std-ref">Protocol Extensions</span></a>.</span><!--end_enstr-->
<span class="jpstr">
スウィフトでは、あなたはプロトコルを拡張してその要件の実装を提供することやそれの準拠型が利用することができる追加の機能性を加えることさえ可能です。詳細は、<a class="reference internal" href="Protocols.html#ID521"><span class="std std-ref">プロトコル拡張</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Extensions can add new functionality to a type, but they can’t override existing functionality.</span><!--end_enstr-->
<span class="jpstr">
拡張は、新しい機能性をある型に加えることができます、しかしそれは既存の機能性をオーバーライドすることはできません。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID470">
<h2><span class="enstr">Extension Syntax<a class="headerlink" href="#ID470" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
拡張構文<a class="headerlink" href="#ID470" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">Declare extensions with the <code class="docutils literal notranslate"><span class="pre">extension</span></code> keyword:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">extension</span></code>キーワードによって拡張を宣言してください：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">extension</span> <span class="nc">SomeType</span> {
</li>
<li>    <span class="c"><span class="enstr">// new functionality to add to SomeType goes here</span><!--end_enstr--><span class="jpstr">（SomeTypeに加える新しい機能性が、ここにきます）</span><!--end_jpstr--></span>
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">An extension can extend an existing type to make it adopt one or more protocols. To add protocol conformance, you write the protocol names the same way as you write them for a class or structure:</span><!--end_enstr-->
<span class="jpstr">
拡張は、既存の型を拡張して、それが１つ以上のプロトコルを採用するようにできます。プロトコル準拠を加えるには、あなたはそれらプロトコル名を、あなたがそれらをクラスや構造体に対して書くのと同じ方法で記述します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">extension</span> <span class="nc">SomeType</span>: <span class="nc">SomeProtocol</span>, <span class="nc">AnotherProtocol</span> {
</li>
<li>    <span class="c"><span class="enstr">// implementation of protocol requirements goes here</span><!--end_enstr--><span class="jpstr">（プロトコル要件の実装が、ここにきます）</span><!--end_jpstr--></span>
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">Adding protocol conformance in this way is described in <a class="reference internal" href="Protocols.html#ID277"><span class="std std-ref">Adding Protocol Conformance with an Extension</span></a>.</span><!--end_enstr-->
<span class="jpstr">
この方法でプロトコル準拠を加えることは<a class="reference internal" href="Protocols.html#ID277"><span class="std std-ref">拡張を使ってプロトコル準拠を加える</span></a>で記述されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">An extension can be used to extend an existing generic type, as described in <a class="reference internal" href="Generics.html#ID185"><span class="std std-ref">Extending a Generic Type</span></a>. You can also extend a generic type to conditionally add functionality, as described in <a class="reference internal" href="Generics.html#ID553"><span class="std std-ref">Extensions with a Generic Where Clause</span></a>.</span><!--end_enstr-->
<span class="jpstr">
拡張は、既存の総称体型を拡張するために使われることができます、<a class="reference internal" href="Generics.html#ID185"><span class="std std-ref">総称体型を拡張する</span></a>で記述されるように。あなたはまた総称体型を拡張することで条件付きの機能性を追加することができます、<a class="reference internal" href="Generics.html#ID553"><span class="std std-ref">総称体where節を持つ拡張</span></a>で記述されるように。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">If you define an extension to add new functionality to an existing type, the new functionality will be available on all existing instances of that type, even if they were created before the extension was defined.</span><!--end_enstr-->
<span class="jpstr">
あなたが新しい機能性を既存の型に加えるために拡張を定義するならば、新しい機能性はその型の全ての既存の例で利用可能になります、たとえそれらが拡張が定義される前につくられたとしてもです。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID152">
<h2><span class="enstr">Computed Properties<a class="headerlink" href="#ID152" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
計算プロパティ<a class="headerlink" href="#ID152" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">Extensions can add computed instance properties and computed type properties to existing types. This example adds five computed instance properties to Swift’s built-in <code class="docutils literal notranslate"><span class="pre">Double</span></code> type, to provide basic support for working with distance units:</span><!--end_enstr-->
<span class="jpstr">
拡張は、既存の型に計算インスタンスプロパティと計算型プロパティを加えることができます。この例は、５つの計算インスタンスプロパティをスウィフトの組み込みの<code class="docutils literal notranslate"><span class="pre">Double</span></code>型に加えて、距離単位を扱うための基本的な支持を提供します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">extension</span> <span class="nc">Double</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">km</span>: <span class="nc">Double</span> { <span class="k">return</span> <span class="k">self</span> * <span class="m">1_000.0</span> }
</li>
<li>    <span class="k">var</span> <span class="nv">m</span>: <span class="nc">Double</span> { <span class="k">return</span> <span class="k">self</span> }
</li>
<li>    <span class="k">var</span> <span class="nv">cm</span>: <span class="nc">Double</span> { <span class="k">return</span> <span class="k">self</span> / <span class="m">100.0</span> }
</li>
<li>    <span class="k">var</span> <span class="nv">mm</span>: <span class="nc">Double</span> { <span class="k">return</span> <span class="k">self</span> / <span class="m">1_000.0</span> }
</li>
<li>    <span class="k">var</span> <span class="nv">ft</span>: <span class="nc">Double</span> { <span class="k">return</span> <span class="k">self</span> / <span class="m">3.28084</span> }
</li>
<li>}
</li>
<li>
<span class="k">let</span> <span class="nv">oneInch</span> = <span class="m">25.4</span>.<span class="nv">mm</span>
</li>
<li>
<span class="nv">print</span>(<span class="s">"One inch is </span>\<span class="p">(</span><span class="nv">oneInch</span><span class="p">)</span><span class="s"> meters"</span>)
</li>
<li>
<span class="c"><span class="enstr">// Prints "One inch is 0.0254 meters"</span><!--end_enstr--><span class="jpstr">（「１インチは、0.0254メートルです」を出力します）</span><!--end_jpstr--></span>
</li>
<li>
<span class="k">let</span> <span class="nv">threeFeet</span> = <span class="m">3</span>.<span class="nv">ft</span>
</li>
<li>
<span class="nv">print</span>(<span class="s">"Three feet is </span>\<span class="p">(</span><span class="nv">threeFeet</span><span class="p">)</span><span class="s"> meters"</span>)
</li>
<li>
<span class="c"><span class="enstr">// Prints "Three feet is 0.914399970739201 meters"</span><!--end_enstr--><span class="jpstr">（「３フィートは、0.914399970739201メートルです」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">These computed properties express that a <code class="docutils literal notranslate"><span class="pre">Double</span></code> value should be considered as a certain unit of length. Although they’re implemented as computed properties, the names of these properties can be appended to a floating-point literal value with dot syntax, as a way to use that literal value to perform distance conversions.</span><!--end_enstr-->
<span class="jpstr">
これらの計算プロパティは、<code class="docutils literal notranslate"><span class="pre">Double</span></code>値が長さの特定の単位とみなされなければならないことを表します。それらは計算プロパティとして実装されるけれども、これらのプロパティの名前はある浮動小数点リテラル値に、そのリテラル値を距離変換を実行するために使う方法として、ドット構文で追加されることが可能です。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">In this example, a <code class="docutils literal notranslate"><span class="pre">Double</span></code> value of <code class="docutils literal notranslate"><span class="pre">1.0</span></code> is considered to represent “one meter”. This is why the <code class="docutils literal notranslate"><span class="pre">m</span></code> computed property returns <code class="docutils literal notranslate"><span class="pre">self</span></code>—the expression <code class="docutils literal notranslate"><span class="pre">1.m</span></code> is considered to calculate a <code class="docutils literal notranslate"><span class="pre">Double</span></code> value of <code class="docutils literal notranslate"><span class="pre">1.0</span></code>.</span><!--end_enstr-->
<span class="jpstr">
この例では、<code class="docutils literal notranslate"><span class="pre">1.0</span></code>の<code class="docutils literal notranslate"><span class="pre">Double</span></code>値は「１メートル」を表すと考慮されます。これが<code class="docutils literal notranslate"><span class="pre">m</span></code>計算プロパティが<code class="docutils literal notranslate"><span class="pre">self</span></code>を返す理由です ― 式<code class="docutils literal notranslate"><span class="pre">1.m</span></code>は、<code class="docutils literal notranslate"><span class="pre">1.0</span></code>の<code class="docutils literal notranslate"><span class="pre">Double</span></code>値を計算するものと考えられます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Other units require some conversion to be expressed as a value measured in meters. One kilometer is the same as 1,000 meters, so the <code class="docutils literal notranslate"><span class="pre">km</span></code> computed property multiplies the value by <code class="docutils literal notranslate"><span class="pre">1_000.00</span></code> to convert into a number expressed in meters. Similarly, there are 3.28084 feet in a meter, and so the <code class="docutils literal notranslate"><span class="pre">ft</span></code> computed property divides the underlying <code class="docutils literal notranslate"><span class="pre">Double</span></code> value by <code class="docutils literal notranslate"><span class="pre">3.28084</span></code>, to convert it from feet to meters.</span><!--end_enstr-->
<span class="jpstr">
他の単位は、メートルで計られる値として表されるためにいくらかの変換を必要とします。１キロメートルは1,000メートルと同じものですので、<code class="docutils literal notranslate"><span class="pre">km</span></code>計算プロパティは<code class="docutils literal notranslate"><span class="pre">1_000.00</span></code>を掛けられて、メートルで表される数に変換されます。同じように、１メートルは3.28084フィートあります、なので<code class="docutils literal notranslate"><span class="pre">ft</span></code>計算プロパティは、もとの<code class="docutils literal notranslate"><span class="pre">Double</span></code>値を<code class="docutils literal notranslate"><span class="pre">3.28084</span></code>で割って、それをフィートからメートルに変換します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">These properties are read-only computed properties, and so they’re expressed without the <code class="docutils literal notranslate"><span class="pre">get</span></code> keyword, for brevity. Their return value is of type <code class="docutils literal notranslate"><span class="pre">Double</span></code>, and can be used within mathematical calculations wherever a <code class="docutils literal notranslate"><span class="pre">Double</span></code> is accepted:</span><!--end_enstr-->
<span class="jpstr">
これらのプロパティは、読み出し専用の計算プロパティです、それでそれらは簡潔さのために、<code class="docutils literal notranslate"><span class="pre">get</span></code>キーワードなしで表わされます。それらの戻り値は<code class="docutils literal notranslate"><span class="pre">Double</span></code>型です、そして数学計算内の<code class="docutils literal notranslate"><span class="pre">Double</span></code>が受け入れられるあらゆるところで使われることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">aMarathon</span> = <span class="m">42</span>.<span class="nv">km</span> + <span class="m">195</span>.<span class="nv">m</span>
</li>
<li>
<span class="nv">print</span>(<span class="s">"A marathon is </span>\<span class="p">(</span><span class="nv">aMarathon</span><span class="p">)</span><span class="s"> meters long"</span>)
</li>
<li>
<span class="c"><span class="enstr">// Prints "A marathon is 42195.0 meters long"</span><!--end_enstr--><span class="jpstr">（「マラソンは、42195.0メートルの長さです」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Extensions can add new computed properties, but they can’t add stored properties, or add property observers to existing properties.</span><!--end_enstr-->
<span class="jpstr">
拡張は新しい計算プロパティを加えることができます、しかし、それは格納プロパティを加えることができません、またプロパティオブザーバーを既存のプロパティに加えることができません。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID153">
<h2><span class="enstr">Initializers<a class="headerlink" href="#ID153" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
イニシャライザ<a class="headerlink" href="#ID153" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">Extensions can add new initializers to existing types. This enables you to extend other types to accept your own custom types as initializer parameters, or to provide additional initialization options that were not included as part of the type’s original implementation.</span><!--end_enstr-->
<span class="jpstr">
拡張は、新しいイニシャライザを既存の型に加えることができます。これは、あなたに別の型を拡張してあなた独自のあつらえの型をイニシャライザパラメータとして受け入れるようにすること、またはその型の最初の実装の一部として含まれなかった追加の初期化選択肢を提供することを可能にします。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Extensions can add new convenience initializers to a class, but they can’t add new designated initializers or deinitializers to a class. Designated initializers and deinitializers must always be provided by the original class implementation.</span><!--end_enstr-->
<span class="jpstr">
拡張は、新しい便利なイニシャライザをクラスに加えることができます、しかし、それは新しい指定イニシャライザまたはデイニシャライザをクラスに加えることができません。指定イニシャライザとデイニシャライザは、常に最初のクラス実施によって提供されなければなりません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">If you use an extension to add an initializer to a value type that provides default values for all of its stored properties and doesn’t define any custom initializers, you can call the default initializer and memberwise initializer for that value type from within your extension’s initializer. This wouldn’t be the case if you had written the initializer as part of the value type’s original implementation, as described in <a class="reference internal" href="Initialization.html#ID215"><span class="std std-ref">Initializer Delegation for Value Types</span></a>.</span><!--end_enstr-->
<span class="jpstr">
あなたが拡張を、その格納プロパティの全てに省略時の値を与えて全くあつらえのイニシャライザを定義しない値型に、イニシャライザを加えるために使うならば、あなたはその値型のための省略時のイニシャライザとメンバー関連イニシャライザを、あなたの拡張のイニシャライザ内から呼ぶことができます。<a class="reference internal" href="Initialization.html#ID215"><span class="std std-ref">値型のためのイニシャライザ委任</span></a>で記述されるように、あなたがイニシャライザをその値型の最初の実装の一部として書いたならば、それはこの場合にはなりません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">If you use an extension to add an initializer to a structure that was declared in another module, the new initializer can’t access <code class="docutils literal notranslate"><span class="pre">self</span></code> until it calls an initializer from the defining module.</span><!--end_enstr-->
<span class="jpstr">
あなたが拡張を使ってイニシャライザを別のモジュールの中で宣言された構造体へと加えるならば、その新しいイニシャライザは<code class="docutils literal notranslate"><span class="pre">self</span></code>にアクセスすることが、それがあるイニシャライザを定義されているモジュールから呼び出すまでは出来ません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The example below defines a custom <code class="docutils literal notranslate"><span class="pre">Rect</span></code> structure to represent a geometric rectangle. The example also defines two supporting structures called <code class="docutils literal notranslate"><span class="pre">Size</span></code> and <code class="docutils literal notranslate"><span class="pre">Point</span></code>, both of which provide default values of <code class="docutils literal notranslate"><span class="pre">0.0</span></code> for all of their properties:</span><!--end_enstr-->
<span class="jpstr">
下の例は、幾何学の長方形を表すためにあつらえの<code class="docutils literal notranslate"><span class="pre">Rect</span></code>構造体を定義します。この例はまた、<code class="docutils literal notranslate"><span class="pre">Size</span></code>と<code class="docutils literal notranslate"><span class="pre">Point</span></code>と呼ばれる２つの支援の構造体を定義します、その両方はそれらのプロパティの全てに<code class="docutils literal notranslate"><span class="pre">0.0</span></code>の省略時の値を提供します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">struct</span> <span class="nv">Size</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">width</span> = <span class="m">0.0</span>, <span class="nv">height</span> = <span class="m">0.0</span>
</li>
<li>}
</li>
<li>
<span class="k">struct</span> <span class="nv">Point</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">x</span> = <span class="m">0.0</span>, <span class="nv">y</span> = <span class="m">0.0</span>
</li>
<li>}
</li>
<li>
<span class="k">struct</span> <span class="nv">Rect</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">origin</span> = <span class="nv">Point</span>()
</li>
<li>    <span class="k">var</span> <span class="nv">size</span> = <span class="nv">Size</span>()
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">Because the <code class="docutils literal notranslate"><span class="pre">Rect</span></code> structure provides default values for all of its properties, it receives a default initializer and a memberwise initializer automatically, as described in <a class="reference internal" href="Initialization.html#ID213"><span class="std std-ref">Default Initializers</span></a>. These initializers can be used to create new <code class="docutils literal notranslate"><span class="pre">Rect</span></code> instances:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Rect</span></code>構造体がそのプロパティの全てに省略時の値を与えるので、<a class="reference internal" href="Initialization.html#ID213"><span class="std std-ref">省略時のイニシャライザ</span></a>で記述されるように、それは自動的に省略時のイニシャライザとメンバー関連イニシャライザを受け取ります。これらのイニシャライザが、新しい<code class="docutils literal notranslate"><span class="pre">Rect</span></code>例をつくるために使われることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">defaultRect</span> = <span class="nv">Rect</span>()
</li>
<li>
<span class="k">let</span> <span class="nv">memberwiseRect</span> = <span class="nv">Rect</span>(<span class="nv">origin</span>: <span class="nv">Point</span>(<span class="nv">x</span>: <span class="m">2.0</span>, <span class="nv">y</span>: <span class="m">2.0</span>),
</li>
<li>   <span class="nv">size</span>: <span class="nv">Size</span>(<span class="nv">width</span>: <span class="m">5.0</span>, <span class="nv">height</span>: <span class="m">5.0</span>))
</li>
</ol></div></div></div>
<p><span class="enstr">You can extend the <code class="docutils literal notranslate"><span class="pre">Rect</span></code> structure to provide an additional initializer that takes a specific center point and size:</span><!--end_enstr-->
<span class="jpstr">
あなたは、<code class="docutils literal notranslate"><span class="pre">Rect</span></code>構造体を拡張して、特定の中心点と大きさをとる追加のイニシャライザを提供することができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">extension</span> <span class="nc">Rect</span> {
</li>
<li>    <span class="k">init</span>(<span class="nv">center</span>: <span class="nc">Point</span>, <span class="nv">size</span>: <span class="nc">Size</span>) {
</li>
<li>        <span class="k">let</span> <span class="nv">originX</span> = <span class="nv">center</span>.<span class="nv">x</span> - (<span class="nv">size</span>.<span class="nv">width</span> / <span class="m">2</span>)
</li>
<li>        <span class="k">let</span> <span class="nv">originY</span> = <span class="nv">center</span>.<span class="nv">y</span> - (<span class="nv">size</span>.<span class="nv">height</span> / <span class="m">2</span>)
</li>
<li>        <span class="k">self</span>.<span class="nv">init</span>(<span class="nv">origin</span>: <span class="nv">Point</span>(<span class="nv">x</span>: <span class="nv">originX</span>, <span class="nv">y</span>: <span class="nv">originY</span>), <span class="nv">size</span>: <span class="nv">size</span>)
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">This new initializer starts by calculating an appropriate origin point based on the provided <code class="docutils literal notranslate"><span class="pre">center</span></code> point and <code class="docutils literal notranslate"><span class="pre">size</span></code> value. The initializer then calls the structure’s automatic memberwise initializer <code class="docutils literal notranslate"><span class="pre">init(origin:size:)</span></code>, which stores the new origin and size values in the appropriate properties:</span><!--end_enstr-->
<span class="jpstr">
この新しいイニシャライザは、提供された<code class="docutils literal notranslate"><span class="pre">center</span></code>点と<code class="docutils literal notranslate"><span class="pre">size</span></code>値に基づいて適切な起源点を計算することによって始めます。イニシャライザはそれから、構造体の自動的なメンバー関連イニシャライザ<code class="docutils literal notranslate"><span class="pre">init(origin:size:)</span></code>を呼びます、それは、新しい原点とサイズ値を適切なプロパティに保管します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">centerRect</span> = <span class="nv">Rect</span>(<span class="nv">center</span>: <span class="nv">Point</span>(<span class="nv">x</span>: <span class="m">4.0</span>, <span class="nv">y</span>: <span class="m">4.0</span>),
</li>
<li>                      <span class="nv">size</span>: <span class="nv">Size</span>(<span class="nv">width</span>: <span class="m">3.0</span>, <span class="nv">height</span>: <span class="m">3.0</span>))
</li>
<li>
<span class="c"><span class="enstr">// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)</span><!--end_enstr--><span class="jpstr">（centerRectの原点は(2.5, 2.5)、そのサイズは(3.0, 3.0)です）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">If you provide a new initializer with an extension, you are still responsible for making sure that each instance is fully initialized once the initializer completes.</span><!--end_enstr-->
<span class="jpstr">
あなたが新しいイニシャライザを拡張によって提供する場合、あなたは依然として、一旦イニシャライザが完了するならば各インスタンスが完全に初期化されることを確かにする責任があります。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID154">
<h2><span class="enstr">Methods<a class="headerlink" href="#ID154" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
メソッド<a class="headerlink" href="#ID154" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">Extensions can add new instance methods and type methods to existing types. The following example adds a new instance method called <code class="docutils literal notranslate"><span class="pre">repetitions</span></code> to the <code class="docutils literal notranslate"><span class="pre">Int</span></code> type:</span><!--end_enstr-->
<span class="jpstr">
拡張は、新しいインスタンスメソッドと型メソッドを既存の型に加えることができます。以下の例は、<code class="docutils literal notranslate"><span class="pre">repetitions</span></code>と呼ばれる新しいインスタンスメソッドを<code class="docutils literal notranslate"><span class="pre">Int</span></code>型に加えます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">extension</span> <span class="nc">Int</span> {
</li>
<li>    <span class="k">func</span> <span class="nv">repetitions</span>(<span class="nv">task</span>: () -&gt; <span class="nc">Void</span>) {
</li>
<li>        <span class="k">for</span> <span class="k">_</span> <span class="k">in</span> <span class="m">0</span>..&lt;<span class="k">self</span> {
</li>
<li>            <span class="nv">task</span>()
</li>
<li>        }
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">repetitions(task:)</span></code> method takes a single argument of type <code class="docutils literal notranslate"><span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">Void</span></code>, which indicates a function that has no parameters and doesn’t return a value.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">repetitions(task:)</span></code>メソッドは型<code class="docutils literal notranslate"><span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">Void</span></code>の引数をひとつだけとります、それは、パラメータを持たず、値を返さない関数であることを示します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">After defining this extension, you can call the <code class="docutils literal notranslate"><span class="pre">repetitions(task:)</span></code> method on any integer to perform a task that many number of times:</span><!--end_enstr-->
<span class="jpstr">
この拡張を定義した後、あなたは<code class="docutils literal notranslate"><span class="pre">repetitions(task:)</span></code>メソッドをあらゆる整数上で呼び出して、ある作業をそれだけ多くの回数実行できます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="m">3</span>.<span class="nv">repetitions</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"Hello!"</span>)
</li>
<li>}
</li>
<li>
<span class="c">// Hello!</span>
</li>
<li>
<span class="c">// Hello!</span>
</li>
<li>
<span class="c">// Hello!</span>
</li>
</ol></div></div></div>
<div class="section" id="ID155">
<h3><span class="enstr">Mutating Instance Methods<a class="headerlink" href="#ID155" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
変更インスタンスメソッド<a class="headerlink" href="#ID155" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">Instance methods added with an extension can also modify (or <em>mutate</em>) the instance itself. Structure and enumeration methods that modify <code class="docutils literal notranslate"><span class="pre">self</span></code> or its properties must mark the instance method as <code class="docutils literal notranslate"><span class="pre">mutating</span></code>, just like mutating methods from an original implementation.</span><!--end_enstr-->
<span class="jpstr">
拡張を使って加えられるインスタンスメソッドは、また、インスタンスそれ自体を修正（または<em>変更</em>）することができます。<code class="docutils literal notranslate"><span class="pre">self</span></code>またはそのプロパティを修正する構造および列挙メソッドは、ちょうど最初の実施からの変更メソッドのように、そのインスタンスメソッドに<code class="docutils literal notranslate"><span class="pre">mutating</span></code>として印されなければなりません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The example below adds a new mutating method called <code class="docutils literal notranslate"><span class="pre">square</span></code> to Swift’s <code class="docutils literal notranslate"><span class="pre">Int</span></code> type, which squares the original value:</span><!--end_enstr-->
<span class="jpstr">
下の例は、<code class="docutils literal notranslate"><span class="pre">square</span></code>と呼ばれる新しい変更メソッドをスウィフトの<code class="docutils literal notranslate"><span class="pre">Int</span></code>型に加えます、それは、もとの値を二乗します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">extension</span> <span class="nc">Int</span> {
</li>
<li>    <span class="k">mutating</span> <span class="k">func</span> <span class="nv">square</span>() {
</li>
<li>        <span class="k">self</span> = <span class="k">self</span> * <span class="k">self</span>
</li>
<li>    }
</li>
<li>}
</li>
<li>
<span class="k">var</span> <span class="nv">someInt</span> = <span class="m">3</span>
</li>
<li>
<span class="nv">someInt</span>.<span class="nv">square</span>()
</li>
<li>
<span class="c"><span class="enstr">// someInt is now 9</span><!--end_enstr--><span class="jpstr">（someIntは、現在９です）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
</div>
</div>
<div class="section" id="ID156">
<h2><span class="enstr">Subscripts<a class="headerlink" href="#ID156" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
添え字<a class="headerlink" href="#ID156" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">Extensions can add new subscripts to an existing type. This example adds an integer subscript to Swift’s built-in <code class="docutils literal notranslate"><span class="pre">Int</span></code> type. This subscript <code class="docutils literal notranslate"><span class="pre">[n]</span></code> returns the decimal digit <code class="docutils literal notranslate"><span class="pre">n</span></code> places in from the right of the number:</span><!--end_enstr-->
<span class="jpstr">
拡張は、新しい添え字を既存の型に加えることができます。この例は、整数添え字をスウィフトの組み込みの<code class="docutils literal notranslate"><span class="pre">Int</span></code>型に加えます。この添え字<code class="docutils literal notranslate"><span class="pre">[n]</span></code>は、右の数からの10進桁<code class="docutils literal notranslate"><span class="pre">n</span></code>位置を返します：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li>
<span class="enstr"><code class="docutils literal notranslate"><span class="pre">123456789[0]</span></code> returns <code class="docutils literal notranslate"><span class="pre">9</span></code></span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">123456789[0]</span></code>は<code class="docutils literal notranslate"><span class="pre">9</span></code>を返します
</span><!--end_jpstr-->

</li>
<li>
<span class="enstr"><code class="docutils literal notranslate"><span class="pre">123456789[1]</span></code> returns <code class="docutils literal notranslate"><span class="pre">8</span></code></span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">123456789[1]</span></code>は<code class="docutils literal notranslate"><span class="pre">8</span></code>を返します
</span><!--end_jpstr-->

</li>
</ul>
<p><span class="enstr">…and so on:</span><!--end_enstr-->
<span class="jpstr">
…などなど：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">extension</span> <span class="nc">Int</span> {
</li>
<li>    <span class="k">subscript</span>(<span class="nv">digitIndex</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Int</span> {
</li>
<li>        <span class="k">var</span> <span class="nv">decimalBase</span> = <span class="m">1</span>
</li>
<li>        <span class="k">for</span> <span class="k">_</span> <span class="k">in</span> <span class="m">0</span>..&lt;<span class="nv">digitIndex</span> {
</li>
<li>            <span class="nv">decimalBase</span> *= <span class="m">10</span>
</li>
<li>        }
</li>
<li>        <span class="k">return</span> (<span class="k">self</span> / <span class="nv">decimalBase</span>) % <span class="m">10</span>
</li>
<li>    }
</li>
<li>}
</li>
<li>
<span class="m">746381295</span>[<span class="m">0</span>]
</li>
<li>
<span class="c"><span class="enstr">// returns 5</span><!--end_enstr--><span class="jpstr">（5を返します）</span><!--end_jpstr--></span>
</li>
<li>
<span class="m">746381295</span>[<span class="m">1</span>]
</li>
<li>
<span class="c"><span class="enstr">// returns 9</span><!--end_enstr--><span class="jpstr">（9を返します）</span><!--end_jpstr--></span>
</li>
<li>
<span class="m">746381295</span>[<span class="m">2</span>]
</li>
<li>
<span class="c"><span class="enstr">// returns 2</span><!--end_enstr--><span class="jpstr">（2を返します）</span><!--end_jpstr--></span>
</li>
<li>
<span class="m">746381295</span>[<span class="m">8</span>]
</li>
<li>
<span class="c"><span class="enstr">// returns 7</span><!--end_enstr--><span class="jpstr">（7を返します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">If the <code class="docutils literal notranslate"><span class="pre">Int</span></code> value doesn’t have enough digits for the requested index, the subscript implementation returns <code class="docutils literal notranslate"><span class="pre">0</span></code>, as if the number had been padded with zeros to the left:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Int</span></code>値には要十分な桁が請されたインデックスに対してないならば、この添え字実装は、まるで数が左にゼロを詰められたように<code class="docutils literal notranslate"><span class="pre">0</span></code>を返します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="m">746381295</span>[<span class="m">9</span>]
</li>
<li>
<span class="c"><span class="enstr">// returns 0, as if you had requested:</span><!--end_enstr--><span class="jpstr">（まるであなたが次のように要請したかのように、0を返します：）</span><!--end_jpstr--></span>
</li>
<li>
<span class="m">0746381295</span>[<span class="m">9</span>]
</li>
</ol></div></div></div>
</div>
<div class="section" id="ID157">
<h2><span class="enstr">Nested Types<a class="headerlink" href="#ID157" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
入れ子にされた型<a class="headerlink" href="#ID157" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">Extensions can add new nested types to existing classes, structures, and enumerations:</span><!--end_enstr-->
<span class="jpstr">
拡張は、新しい入れ子にされた型を既存のクラス、構造体、および列挙に加えることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">extension</span> <span class="nc">Int</span> {
</li>
<li>    <span class="k">enum</span> <span class="nv">Kind</span> {
</li>
<li>        <span class="k">case</span> <span class="nv">negative</span>, <span class="nv">zero</span>, <span class="nv">positive</span>
</li>
<li>    }
</li>
<li>    <span class="k">var</span> <span class="nv">kind</span>: <span class="nc">Kind</span> {
</li>
<li>        <span class="k">switch</span> <span class="k">self</span> {
</li>
<li>        <span class="k">case</span> <span class="m">0</span>:
</li>
<li>            <span class="k">return</span> .<span class="nv">zero</span>
</li>
<li>        <span class="k">case</span> <span class="k">let</span> <span class="nv">x</span> <span class="k">where</span> <span class="nv">x</span> &gt; <span class="m">0</span>:
</li>
<li>            <span class="k">return</span> .<span class="nv">positive</span>
</li>
<li>        <span class="k">default</span>:
</li>
<li>            <span class="k">return</span> .<span class="nv">negative</span>
</li>
<li>        }
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">This example adds a new nested enumeration to <code class="docutils literal notranslate"><span class="pre">Int</span></code>. This enumeration, called <code class="docutils literal notranslate"><span class="pre">Kind</span></code>, expresses the kind of number that a particular integer represents. Specifically, it expresses whether the number is negative, zero, or positive.</span><!--end_enstr-->
<span class="jpstr">
この例は、新しい入れ子にされた列挙を<code class="docutils literal notranslate"><span class="pre">Int</span></code>に加えます。この列挙は、<code class="docutils literal notranslate"><span class="pre">Kind</span></code>と呼ばれ、特定の整数を表わす数の種類を表わします。具体的には、それはその数が負、ゼロ、または正かを表わします。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">This example also adds a new computed instance property to <code class="docutils literal notranslate"><span class="pre">Int</span></code>, called <code class="docutils literal notranslate"><span class="pre">kind</span></code>, which returns the appropriate <code class="docutils literal notranslate"><span class="pre">Kind</span></code> enumeration case for that integer.</span><!--end_enstr-->
<span class="jpstr">
この例はまた、新しい計算インスタンスプロパティを<code class="docutils literal notranslate"><span class="pre">Int</span></code>に加えます、それは、<code class="docutils literal notranslate"><span class="pre">kind</span></code>と呼ばれ、その整数に対する適切な<code class="docutils literal notranslate"><span class="pre">Kind</span></code>列挙ケース節を返します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The nested enumeration can now be used with any <code class="docutils literal notranslate"><span class="pre">Int</span></code> value:</span><!--end_enstr-->
<span class="jpstr">
入れ子にされた列挙は今やあらゆる<code class="docutils literal notranslate"><span class="pre">Int</span></code>値で使われることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">func</span> <span class="nv">printIntegerKinds</span>(<span class="k">_</span> <span class="nv">numbers</span>: [<span class="nc">Int</span>]) {
</li>
<li>    <span class="k">for</span> <span class="nv">number</span> <span class="k">in</span> <span class="nv">numbers</span> {
</li>
<li>        <span class="k">switch</span> <span class="nv">number</span>.<span class="nv">kind</span> {
</li>
<li>        <span class="k">case</span> .<span class="nv">negative</span>:
</li>
<li>            <span class="nv">print</span>(<span class="s">"- "</span>, <span class="nv">terminator</span>: <span class="s">""</span>)
</li>
<li>        <span class="k">case</span> .<span class="nv">zero</span>:
</li>
<li>            <span class="nv">print</span>(<span class="s">"0 "</span>, <span class="nv">terminator</span>: <span class="s">""</span>)
</li>
<li>        <span class="k">case</span> .<span class="nv">positive</span>:
</li>
<li>            <span class="nv">print</span>(<span class="s">"+ "</span>, <span class="nv">terminator</span>: <span class="s">""</span>)
</li>
<li>        }
</li>
<li>    }
</li>
<li>    <span class="nv">print</span>(<span class="s">""</span>)
</li>
<li>}
</li>
<li>
<span class="nv">printIntegerKinds</span>([<span class="m">3</span>, <span class="m">19</span>, <span class="m">-27</span>, <span class="m">0</span>, <span class="m">-6</span>, <span class="m">0</span>, <span class="m">7</span>])
</li>
<li>
<span class="c">// Prints "+ + - 0 - 0 + "</span>
</li>
</ol></div></div></div>
<p><span class="enstr">This function, <code class="docutils literal notranslate"><span class="pre">printIntegerKinds(_:)</span></code>, takes an input array of <code class="docutils literal notranslate"><span class="pre">Int</span></code> values and iterates over those values in turn. For each integer in the array, the function considers the <code class="docutils literal notranslate"><span class="pre">kind</span></code> computed property for that integer, and prints an appropriate description.</span><!--end_enstr-->
<span class="jpstr">
この関数、<code class="docutils literal notranslate"><span class="pre">printIntegerKinds(_:)</span></code>は、<code class="docutils literal notranslate"><span class="pre">Int</span></code>値の配列の入力を取り、それらの値に最初から終わりまで順番に繰り返していきます。その配列の各整数に対して、この関数はその整数に対する<code class="docutils literal notranslate"><span class="pre">kind</span></code>計算プロパティを考慮して、適切な説明を出力します。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr"><code class="docutils literal notranslate"><span class="pre">number.kind</span></code> is already known to be of type <code class="docutils literal notranslate"><span class="pre">Int.Kind</span></code>. Because of this, all of the <code class="docutils literal notranslate"><span class="pre">Int.Kind</span></code> case values can be written in shorthand form inside the <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement, such as <code class="docutils literal notranslate"><span class="pre">.negative</span></code> rather than <code class="docutils literal notranslate"><span class="pre">Int.Kind.negative</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">number.kind</span></code>は、既に型<code class="docutils literal notranslate"><span class="pre">Int.Kind</span></code>であると知られます。そのことから、<code class="docutils literal notranslate"><span class="pre">Int.Kind</span></code>のケース節の値の全ては、<code class="docutils literal notranslate"><span class="pre">switch</span></code>文内で略記形式で書かれることができます、たとえば<code class="docutils literal notranslate"><span class="pre">Int.Kind.negative</span></code>ではなく<code class="docutils literal notranslate"><span class="pre">.negative</span></code>のように。
</span><!--end_jpstr-->
</p>
</div>
</div>
</div>


    </article>
    <div class="next_previous">
        <p class="previous"><a href="NestedTypes.html"><span class="enstr">Nested Types</span><!--end_enstr-->
<span class="jpstr">
入れ子にされた型
</span><!--end_jpstr-->
</a></p>
        <p class="next"><a href="Protocols.html"><span class="enstr">Protocols</span><!--end_enstr-->
<span class="jpstr">
プロトコル
</span><!--end_jpstr-->
</a></p>
    </div>
</main>


<footer role="contentinfo">
  <aside>
    <a href="//swift.org/atom.xml" title="Subscribe to Site Updates"><i class="feed">Subscribe</i></a>
    <a href="https://twitter.com/swiftlang" rel="nofollow" title="Follow @SwiftLang on Twitter"><i class="twitter">Twitter</i></a>
  </aside>

  <p class="copyright">Copyright © 2022 Apple Inc. All rights reserved.</p>
  <p class="trademark">Swift and the Swift logo are trademarks of Apple Inc.</p>
  <p class="privacy">
    <a href="//www.apple.com/privacy/privacy-policy/">Privacy Policy</a>
    <a href="//www.apple.com/legal/privacy/en-ww/cookies/">Cookies</a>
  </p>
</footer>
<div id="jump_to_overlay"></div>
<script src="../static/javascripts/application.js"></script>
  
</body>
</html>
