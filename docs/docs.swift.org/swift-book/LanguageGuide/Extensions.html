

<!DOCTYPE html>



<head>
    <meta charset="utf-8" />
    <meta name="author" content="Apple Inc." />
    <meta name="viewport" content="width=device-width initial-scale=1" />
    
    <title>Extensions &mdash; The Swift Programming Language (Swift 4.2)</title>
    
    <link rel="license" href="/LICENSE.txt" />
    <link rel="stylesheet" media="all" href="../static/stylesheets/application.css" />
    <link rel="stylesheet" media="all" href="../static/stylesheets/tspl.css" />
    <link rel="shortcut icon" sizes="16x16 24x24 32x32 48x48 64x64" type="image/vnd.microsoft.icon" href="/favicon.ico" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png" />
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png" />
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png" />
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png" />
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png" />
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png" />
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png" />
    <link rel="mask-icon" href="/assets/images/icon-swift.svg" color="#F05339" /> 
  </head>
  <body>


<nav role="navigation">
    <header role="banner">
      <h1 id="logo">
        <a href="https://swift.org/" title="Swift.org" role="img" aria-label="Swift.org">
          Swift.org
        </a>
      </h1>
    </header>

    <div id="menu-toggle" class="menu-toggle open"></div>

    <h2>The Swift Programming Language<div>Swift 4.2</div></h2>

    <ul>
    <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">Welcome to Swift<br><span class="jpstr">
スウィフトにようこそ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="TheBasics.html">Language Guide<br><span class="jpstr">
言語ガイド
</span><!--end_jpstr-->
</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="TheBasics.html">The Basics<br><span class="jpstr">
基本
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="BasicOperators.html">Basic Operators<br><span class="jpstr">
基本の演算子
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="StringsAndCharacters.html">Strings and Characters<br><span class="jpstr">
文字列と文字
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="CollectionTypes.html">Collection Types<br><span class="jpstr">
コレクション型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ControlFlow.html">Control Flow<br><span class="jpstr">
制御の流れ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Functions.html">Functions<br><span class="jpstr">
関数
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Closures.html">Closures<br><span class="jpstr">
クロージャ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Enumerations.html">Enumerations<br><span class="jpstr">
列挙
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ClassesAndStructures.html">Structures and Classes<br><span class="jpstr">
構造体とクラス
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Properties.html">Properties<br><span class="jpstr">
プロパティ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Methods.html">Methods<br><span class="jpstr">
メソッド
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Subscripts.html">Subscripts<br><span class="jpstr">
添え字
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Inheritance.html">Inheritance<br><span class="jpstr">
継承
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Initialization.html">Initialization<br><span class="jpstr">
初期化
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Deinitialization.html">Deinitialization<br><span class="jpstr">
デイニシャライズ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="OptionalChaining.html">Optional Chaining<br><span class="jpstr">
オプショナル連鎖
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ErrorHandling.html">Error Handling<br><span class="jpstr">
エラーの処理
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="TypeCasting.html">Type Casting<br><span class="jpstr">
型キャスト
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="NestedTypes.html">Nested Types<br><span class="jpstr">
入れ子にされた型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Extensions<br><span class="jpstr">
拡張
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Protocols.html">Protocols<br><span class="jpstr">
プロトコル
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Generics.html">Generics<br><span class="jpstr">
総称体
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AutomaticReferenceCounting.html">Automatic Reference Counting<br><span class="jpstr">
自動参照カウント
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="MemorySafety.html">Memory Safety<br><span class="jpstr">
メモリ安全
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AccessControl.html">Access Control<br><span class="jpstr">
アクセス制御
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AdvancedOperators.html">Advanced Operators<br><span class="jpstr">
先進の演算子
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ReferenceManual/AboutTheLanguageReference.html">Language Reference<br><span class="jpstr">
言語リファレンス
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1"><a class="reference internal" href="../RevisionHistory/RevisionHistory.html">Revision History<br><span class="jpstr">
改訂履歴
</span><!--end_jpstr-->
</a></li>
</ul>

    <li class="toctree-l1 return"><a class="reference internal" href="../../../index.html">← Go to Index</a></li>
    </ul>
</nav>




<main role="main">
    <article class="page">
        <menu id="bashful" type="toolbar">
          <div class="inner">
            <menuitem id="jump_to" class="menu-bar-item closed">
            <span id="jump_to_toggle">On This Page</span>
            <div class="chevron">
                <div class="chevy chevron-left"></div>
                <div class="chevy chevron-right"></div>
            </div>
            <menu type="list" class="details">
                <ul>
<li><a class="reference internal" href="#">Extensions<br><span class="jpstr">
拡張
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID470">Extension Syntax<br><span class="jpstr">
拡張構文
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID152">Computed Properties<br><span class="jpstr">
計算プロパティ
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID153">Initializers<br><span class="jpstr">
イニシャライザ
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID154">Methods<br><span class="jpstr">
メソッド
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID155">Mutating Instance Methods<br><span class="jpstr">
変更インスタンスメソッド
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID156">Subscripts<br><span class="jpstr">
添え字
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID157">Nested Types<br><span class="jpstr">
入れ子にされた型
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
</ul>

            </menu>
            </menuitem>
          </div>
        </menu>

        
  <div class="section" id="extensions">
<h1>Extensions<a class="headerlink" href="#extensions" title="Permalink to this headline">¶</a><br><span class="jpstr">
拡張<a class="headerlink" href="#extensions" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h1>
<p><em>Extensions</em> add new functionality to an existing class, structure, enumeration, or protocol type. This includes the ability to extend types for which you do not have access to the original source code (known as <em>retroactive modeling</em>). Extensions are similar to categories in Objective-C. (Unlike Objective-C categories, Swift extensions do not have names.)<br><span class="jpstr">
<em>拡張</em>は、新しい機能性を既存のクラス、構造体、列挙、またはプロトコル型に加えます。これは、あなたが元々のソース・コードにアクセスをしないで型を拡張する能力を含みます（<em>遡及モデリング</em>として知られます）。拡張は、Objective-Cでのカテゴリーに似ています。（Objective-Cカテゴリーとは異なり、スウィフト拡張には、名前がありません。）
</span><!--end_jpstr-->
</p>
<p>Extensions in Swift can:<br><span class="jpstr">
スウィフトの拡張は、以下が可能です：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li>Add computed instance properties and computed type properties<br><span class="jpstr">
計算インスタンスプロパティと計算型プロパティを加える
</span><!--end_jpstr-->
</li>
<li>Define instance methods and type methods<br><span class="jpstr">
インスタンスメソッドと型メソッドを定義する
</span><!--end_jpstr-->
</li>
<li>Provide new initializers<br><span class="jpstr">
新しいイニシャライザを提供する
</span><!--end_jpstr-->
</li>
<li>Define subscripts<br><span class="jpstr">
添え字を定義する
</span><!--end_jpstr-->
</li>
<li>Define and use new nested types<br><span class="jpstr">
新しい入れ子にされた型を定義して、使用する
</span><!--end_jpstr-->
</li>
<li>Make an existing type conform to a protocol<br><span class="jpstr">
既存の型をプロトコルに準拠させる
</span><!--end_jpstr-->
</li>
</ul>
<p>In Swift, you can even extend a protocol to provide implementations of its requirements or add additional functionality that conforming types can take advantage of. For more details, see <a class="reference internal" href="Protocols.html#ID521"><span class="std std-ref">Protocol Extensions</span></a>.<br><span class="jpstr">
スウィフトでは、あなたはプロトコルを拡張してその要件の実装を提供することやそれの準拠型が利用することができる追加の機能性を加えることさえ可能です。詳細は、<a class="reference internal" href="Protocols.html#ID521"><span class="std std-ref">プロトコル拡張</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title">Note<br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last">Extensions can add new functionality to a type, but they cannot override existing functionality.<br><span class="jpstr">
拡張は、新しい機能性をある型に加えることができます、しかしそれは既存の機能性をオーバーライドすることはできません。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID470">
<h2>Extension Syntax<a class="headerlink" href="#ID470" title="Permalink to this headline">¶</a><br><span class="jpstr">
拡張構文<a class="headerlink" href="#ID470" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>Declare extensions with the <code class="docutils literal notranslate"><span class="pre">extension</span></code> keyword:<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">extension</span></code>キーワードによって拡張を宣言してください：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">SomeType</span> {
</li><li>    <span class="c">// new functionality to add to SomeType goes here&nbsp;<span class="jpstr">（SomeTypeに加える新しい機能性が、ここにきます）</span><!--end_jpstr-->
</span>
</li><li>}
</li></ol></div></div></div>
<p>An extension can extend an existing type to make it adopt one or more protocols. To add protocol conformance, you write the protocol names the same way as you write them for a class or structure:<br><span class="jpstr">
拡張は、既存の型を拡張して、それが一つ以上のプロトコルを採用するようにできます。プロトコル準拠を加えるには、あなたはそれらプロトコル名を、あなたがそれらをクラスや構造体に対して書くのと同じ方法で記述します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">SomeType</span>: <span class="nc">SomeProtocol</span>, <span class="nc">AnotherProtocol</span> {
</li><li>    <span class="c">// implementation of protocol requirements goes here&nbsp;<span class="jpstr">（プロトコル要件の実装が、ここにきます）</span><!--end_jpstr-->
</span>
</li><li>}
</li></ol></div></div></div>
<p>Adding protocol conformance in this way is described in <a class="reference internal" href="Protocols.html#ID277"><span class="std std-ref">Adding Protocol Conformance with an Extension</span></a>.<br><span class="jpstr">
この方法でプロトコル準拠を加えることは<a class="reference internal" href="Protocols.html#ID277"><span class="std std-ref">拡張を使ってプロトコル準拠を加える</span></a>で記述されます。
</span><!--end_jpstr-->
</p>
<p>An extension can be used to extend an existing generic type, as described in <a class="reference internal" href="Generics.html#ID185"><span class="std std-ref">Extending a Generic Type</span></a>. You can also extend a generic type to conditionally add functionality, as described in <a class="reference internal" href="Generics.html#ID553"><span class="std std-ref">Extensions with a Generic Where Clause</span></a>.<br><span class="jpstr">
拡張は、既存の総称体型を拡張するために使われることができます、<a class="reference internal" href="Generics.html#ID185"><span class="std std-ref">総称体型を拡張する</span></a>で記述されるように。あなたはまた総称体型を拡張することで条件付きの機能性を追加することができます、<a class="reference internal" href="Generics.html#ID553"><span class="std std-ref">ひとつの総称体where節を持つ拡張</span></a>で記述されるように。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title">Note<br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last">If you define an extension to add new functionality to an existing type, the new functionality will be available on all existing instances of that type, even if they were created before the extension was defined.<br><span class="jpstr">
あなたが新しい機能性を既存の型に加えるために拡張を定義するならば、新しい機能性はその型の全ての既存の例で利用可能になります、たとえそれらが拡張が定義される前につくられたとしてもです。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID152">
<h2>Computed Properties<a class="headerlink" href="#ID152" title="Permalink to this headline">¶</a><br><span class="jpstr">
計算プロパティ<a class="headerlink" href="#ID152" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>Extensions can add computed instance properties and computed type properties to existing types. This example adds five computed instance properties to Swift’s built-in <code class="docutils literal notranslate"><span class="pre">Double</span></code> type, to provide basic support for working with distance units:<br><span class="jpstr">
拡張は、既存の型に計算インスタンスプロパティと計算型プロパティを加えることができます。この例は、５つの計算インスタンスプロパティをスウィフトの組み込みの<code class="docutils literal notranslate"><span class="pre">Double</span></code>型に加えて、距離単位を扱うための基本的な支持を提供します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">Double</span> {
</li><li>    <span class="k">var</span> <span class="nv">km</span>: <span class="nc">Double</span> { <span class="k">return</span> <span class="k">self</span> * <span class="m">1_000.0</span> }
</li><li>    <span class="k">var</span> <span class="nv">m</span>: <span class="nc">Double</span> { <span class="k">return</span> <span class="k">self</span> }
</li><li>    <span class="k">var</span> <span class="nv">cm</span>: <span class="nc">Double</span> { <span class="k">return</span> <span class="k">self</span> / <span class="m">100.0</span> }
</li><li>    <span class="k">var</span> <span class="nv">mm</span>: <span class="nc">Double</span> { <span class="k">return</span> <span class="k">self</span> / <span class="m">1_000.0</span> }
</li><li>    <span class="k">var</span> <span class="nv">ft</span>: <span class="nc">Double</span> { <span class="k">return</span> <span class="k">self</span> / <span class="m">3.28084</span> }
</li><li>}
</li><li><span class="k">let</span> <span class="nv">oneInch</span> = <span class="m">25.4</span>.<span class="nv">mm</span>
</li><li><span class="nv">print</span>(<span class="s">&quot;One inch is </span>\<span class="p">(</span><span class="nv">oneInch</span><span class="p">)</span><span class="s"> meters&quot;</span>)
</li><li><span class="c">// Prints &quot;One inch is 0.0254 meters&quot;&nbsp;<span class="jpstr">（「１インチは、0.0254メートルです」を出力します）</span><!--end_jpstr-->
</span>
</li><li><span class="k">let</span> <span class="nv">threeFeet</span> = <span class="m">3</span>.<span class="nv">ft</span>
</li><li><span class="nv">print</span>(<span class="s">&quot;Three feet is </span>\<span class="p">(</span><span class="nv">threeFeet</span><span class="p">)</span><span class="s"> meters&quot;</span>)
</li><li><span class="c">// Prints &quot;Three feet is 0.914399970739201 meters&quot;&nbsp;<span class="jpstr">（「３フィートは、0.914399970739201メートルです」を出力します）</span><!--end_jpstr-->
</span>
</li></ol></div></div></div>
<p>These computed properties express that a <code class="docutils literal notranslate"><span class="pre">Double</span></code> value should be considered as a certain unit of length. Although they are implemented as computed properties, the names of these properties can be appended to a floating-point literal value with dot syntax, as a way to use that literal value to perform distance conversions.<br><span class="jpstr">
これらの計算プロパティは、<code class="docutils literal notranslate"><span class="pre">Double</span></code>値が長さの特定の単位とみなされなければならないことを表します。それらは計算プロパティとして実装されるけれども、これらのプロパティの名前はある浮動小数点リテラル値に、そのリテラル値を距離変換を実行するために使う方法として、ドット構文で追加されることが可能です。
</span><!--end_jpstr-->
</p>
<p>In this example, a <code class="docutils literal notranslate"><span class="pre">Double</span></code> value of <code class="docutils literal notranslate"><span class="pre">1.0</span></code> is considered to represent “one meter”. This is why the <code class="docutils literal notranslate"><span class="pre">m</span></code> computed property returns <code class="docutils literal notranslate"><span class="pre">self</span></code>—the expression <code class="docutils literal notranslate"><span class="pre">1.m</span></code> is considered to calculate a <code class="docutils literal notranslate"><span class="pre">Double</span></code> value of <code class="docutils literal notranslate"><span class="pre">1.0</span></code>.<br><span class="jpstr">
この例では、<code class="docutils literal notranslate"><span class="pre">1.0</span></code>の<code class="docutils literal notranslate"><span class="pre">Double</span></code>値は「１メートル」を表すと考慮されます。これが<code class="docutils literal notranslate"><span class="pre">m</span></code>計算プロパティが<code class="docutils literal notranslate"><span class="pre">self</span></code>を返す理由です ― 式<code class="docutils literal notranslate"><span class="pre">1.m</span></code>は、<code class="docutils literal notranslate"><span class="pre">1.0</span></code>の<code class="docutils literal notranslate"><span class="pre">Double</span></code>値を計算するものと考えられます。
</span><!--end_jpstr-->
</p>
<p>Other units require some conversion to be expressed as a value measured in meters. One kilometer is the same as 1,000 meters, so the <code class="docutils literal notranslate"><span class="pre">km</span></code> computed property multiplies the value by <code class="docutils literal notranslate"><span class="pre">1_000.00</span></code> to convert into a number expressed in meters. Similarly, there are 3.28084 feet in a meter, and so the <code class="docutils literal notranslate"><span class="pre">ft</span></code> computed property divides the underlying <code class="docutils literal notranslate"><span class="pre">Double</span></code> value by <code class="docutils literal notranslate"><span class="pre">3.28084</span></code>, to convert it from feet to meters.<br><span class="jpstr">
他の単位は、メートルで計られる値として表されるためにいくらかの変換を必要とします。１キロメートルは1,000メートルと同じものですので、<code class="docutils literal notranslate"><span class="pre">km</span></code>計算プロパティは<code class="docutils literal notranslate"><span class="pre">1_000.00</span></code>を掛けられて、メートルで表される数に変換されます。同じように、１メートルは3.28084フィートあります、なので<code class="docutils literal notranslate"><span class="pre">ft</span></code>計算プロパティは、もとの<code class="docutils literal notranslate"><span class="pre">Double</span></code>値を<code class="docutils literal notranslate"><span class="pre">3.28084</span></code>で割って、それをフィートからメートルに変換します。
</span><!--end_jpstr-->
</p>
<p>These properties are read-only computed properties, and so they are expressed without the <code class="docutils literal notranslate"><span class="pre">get</span></code> keyword, for brevity. Their return value is of type <code class="docutils literal notranslate"><span class="pre">Double</span></code>, and can be used within mathematical calculations wherever a <code class="docutils literal notranslate"><span class="pre">Double</span></code> is accepted:<br><span class="jpstr">
これらのプロパティは、読み出し専用の計算プロパティです、それでそれらは簡潔さのために、<code class="docutils literal notranslate"><span class="pre">get</span></code>キーワードなしで表わされます。それらの戻り値は<code class="docutils literal notranslate"><span class="pre">Double</span></code>型です、そして数学計算内の<code class="docutils literal notranslate"><span class="pre">Double</span></code>が受け入れられるあらゆるところで使われることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">aMarathon</span> = <span class="m">42</span>.<span class="nv">km</span> + <span class="m">195</span>.<span class="nv">m</span>
</li><li><span class="nv">print</span>(<span class="s">&quot;A marathon is </span>\<span class="p">(</span><span class="nv">aMarathon</span><span class="p">)</span><span class="s"> meters long&quot;</span>)
</li><li><span class="c">// Prints &quot;A marathon is 42195.0 meters long&quot;&nbsp;<span class="jpstr">（「マラソンは、42195.0メートルの長さです」を出力します）</span><!--end_jpstr-->
</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note<br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last">Extensions can add new computed properties, but they cannot add stored properties, or add property observers to existing properties.<br><span class="jpstr">
拡張は新しい計算プロパティを加えることができます、しかし、それは格納プロパティを加えることができません、またプロパティオブザーバーを既存のプロパティに加えることができません。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID153">
<h2>Initializers<a class="headerlink" href="#ID153" title="Permalink to this headline">¶</a><br><span class="jpstr">
イニシャライザ<a class="headerlink" href="#ID153" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>Extensions can add new initializers to existing types. This enables you to extend other types to accept your own custom types as initializer parameters, or to provide additional initialization options that were not included as part of the type’s original implementation.<br><span class="jpstr">
拡張は、新しいイニシャライザを既存の型に加えることができます。これは、あなたに別の型を拡張してあなた独自のあつらえの型をイニシャライザパラメータとして受け入れるようにすること、またはその型の最初の実装の一部として含まれなかった追加の初期化選択肢を提供することを可能にします。
</span><!--end_jpstr-->
</p>
<p>Extensions can add new convenience initializers to a class, but they cannot add new designated initializers or deinitializers to a class. Designated initializers and deinitializers must always be provided by the original class implementation.<br><span class="jpstr">
拡張は、新しい便利なイニシャライザをクラスに加えることができます、しかし、それは新しい指定イニシャライザまたはデイニシャライザをクラスに加えることができません。指定イニシャライザとデイニシャライザは、常に最初のクラス実施によって提供されなければなりません。
</span><!--end_jpstr-->
</p>
<p>If you use an extension to add an initializer to a value type that provides default values for all of its stored properties and does not define any custom initializers, you can call the default initializer and memberwise initializer for that value type from within your extension’s initializer. This wouldn’t be the case if you had written the initializer as part of the value type’s original implementation, as described in <a class="reference internal" href="Initialization.html#ID215"><span class="std std-ref">Initializer Delegation for Value Types</span></a>.<br><span class="jpstr">
あなたが拡張を、その格納プロパティの全てに省略時の値を与えて全くあつらえのイニシャライザを定義しない値型に、イニシャライザを加えるために使うならば、あなたはその値型のための省略時のイニシャライザとメンバー関連イニシャライザを、あなたの拡張のイニシャライザ内から呼ぶことができます。<a class="reference internal" href="Initialization.html#ID215"><span class="std std-ref">値型のためのイニシャライザ委任</span></a>で記述されるように、あなたがイニシャライザをその値型の最初の実装の一部として書いたならば、それはこの場合にはなりません。
</span><!--end_jpstr-->
</p>
<p>If you use an extension to add an initializer to a structure that was declared in another module, the new initializer can’t access <code class="docutils literal notranslate"><span class="pre">self</span></code> until it calls an initializer from the defining module.<br><span class="jpstr">
あなたが拡張を使ってイニシャライザを別のモジュールの中で宣言された構造体へと加えるならば、その新しいイニシャライザは<code class="docutils literal notranslate"><span class="pre">self</span></code>にアクセスすることが、それがあるイニシャライザを定義されているモジュールから呼び出すまでは出来ません。
</span><!--end_jpstr-->
</p>
<p>The example below defines a custom <code class="docutils literal notranslate"><span class="pre">Rect</span></code> structure to represent a geometric rectangle. The example also defines two supporting structures called <code class="docutils literal notranslate"><span class="pre">Size</span></code> and <code class="docutils literal notranslate"><span class="pre">Point</span></code>, both of which provide default values of <code class="docutils literal notranslate"><span class="pre">0.0</span></code> for all of their properties:<br><span class="jpstr">
下の例は、幾何学の長方形を表すためにあつらえの<code class="docutils literal notranslate"><span class="pre">Rect</span></code>構造体を定義します。この例はまた、<code class="docutils literal notranslate"><span class="pre">Size</span></code>と<code class="docutils literal notranslate"><span class="pre">Point</span></code>と呼ばれる２つの支援の構造体を定義します、その両方はそれらのプロパティの全てに<code class="docutils literal notranslate"><span class="pre">0.0</span></code>の省略時の値を提供します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Size</span> {
</li><li>    <span class="k">var</span> <span class="nv">width</span> = <span class="m">0.0</span>, <span class="nv">height</span> = <span class="m">0.0</span>
</li><li>}
</li><li><span class="k">struct</span> <span class="nv">Point</span> {
</li><li>    <span class="k">var</span> <span class="nv">x</span> = <span class="m">0.0</span>, <span class="nv">y</span> = <span class="m">0.0</span>
</li><li>}
</li><li><span class="k">struct</span> <span class="nv">Rect</span> {
</li><li>    <span class="k">var</span> <span class="nv">origin</span> = <span class="nv">Point</span>()
</li><li>    <span class="k">var</span> <span class="nv">size</span> = <span class="nv">Size</span>()
</li><li>}
</li></ol></div></div></div>
<p>Because the <code class="docutils literal notranslate"><span class="pre">Rect</span></code> structure provides default values for all of its properties, it receives a default initializer and a memberwise initializer automatically, as described in <a class="reference internal" href="Initialization.html#ID213"><span class="std std-ref">Default Initializers</span></a>. These initializers can be used to create new <code class="docutils literal notranslate"><span class="pre">Rect</span></code> instances:<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Rect</span></code>構造体がそのプロパティの全てに省略時の値を与えるので、<a class="reference internal" href="Initialization.html#ID213"><span class="std std-ref">省略時のイニシャライザ</span></a>で記述されるように、それは自動的に省略時のイニシャライザとメンバー関連イニシャライザを受け取ります。これらのイニシャライザが、新しい<code class="docutils literal notranslate"><span class="pre">Rect</span></code>例をつくるために使われることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">defaultRect</span> = <span class="nv">Rect</span>()
</li><li><span class="k">let</span> <span class="nv">memberwiseRect</span> = <span class="nv">Rect</span>(<span class="nv">origin</span>: <span class="nv">Point</span>(<span class="nv">x</span>: <span class="m">2.0</span>, <span class="nv">y</span>: <span class="m">2.0</span>),
</li><li>   <span class="nv">size</span>: <span class="nv">Size</span>(<span class="nv">width</span>: <span class="m">5.0</span>, <span class="nv">height</span>: <span class="m">5.0</span>))
</li></ol></div></div></div>
<p>You can extend the <code class="docutils literal notranslate"><span class="pre">Rect</span></code> structure to provide an additional initializer that takes a specific center point and size:<br><span class="jpstr">
あなたは、<code class="docutils literal notranslate"><span class="pre">Rect</span></code>構造体を拡張して、特定の中心点と大きさをとる追加のイニシャライザを提供することができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">Rect</span> {
</li><li>    <span class="k">init</span>(<span class="nv">center</span>: <span class="nc">Point</span>, <span class="nv">size</span>: <span class="nc">Size</span>) {
</li><li>        <span class="k">let</span> <span class="nv">originX</span> = <span class="nv">center</span>.<span class="nv">x</span> - (<span class="nv">size</span>.<span class="nv">width</span> / <span class="m">2</span>)
</li><li>        <span class="k">let</span> <span class="nv">originY</span> = <span class="nv">center</span>.<span class="nv">y</span> - (<span class="nv">size</span>.<span class="nv">height</span> / <span class="m">2</span>)
</li><li>        <span class="k">self</span>.<span class="nv">init</span>(<span class="nv">origin</span>: <span class="nv">Point</span>(<span class="nv">x</span>: <span class="nv">originX</span>, <span class="nv">y</span>: <span class="nv">originY</span>), <span class="nv">size</span>: <span class="nv">size</span>)
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>This new initializer starts by calculating an appropriate origin point based on the provided <code class="docutils literal notranslate"><span class="pre">center</span></code> point and <code class="docutils literal notranslate"><span class="pre">size</span></code> value. The initializer then calls the structure’s automatic memberwise initializer <code class="docutils literal notranslate"><span class="pre">init(origin:size:)</span></code>, which stores the new origin and size values in the appropriate properties:<br><span class="jpstr">
この新しいイニシャライザは、提供された<code class="docutils literal notranslate"><span class="pre">center</span></code>点と<code class="docutils literal notranslate"><span class="pre">size</span></code>値に基づいて適切な起源点を計算することによって始めます。イニシャライザはそれから、構造体の自動的なメンバー関連イニシャライザ<code class="docutils literal notranslate"><span class="pre">init(origin:size:)</span></code>を呼びます、それは、新しい原点とサイズ値を適切なプロパティに保管します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">centerRect</span> = <span class="nv">Rect</span>(<span class="nv">center</span>: <span class="nv">Point</span>(<span class="nv">x</span>: <span class="m">4.0</span>, <span class="nv">y</span>: <span class="m">4.0</span>),
</li><li>                      <span class="nv">size</span>: <span class="nv">Size</span>(<span class="nv">width</span>: <span class="m">3.0</span>, <span class="nv">height</span>: <span class="m">3.0</span>))
</li><li><span class="c">// centerRect&#39;s origin is (2.5, 2.5) and its size is (3.0, 3.0)&nbsp;<span class="jpstr">（centerRectの原点は(2.5, 2.5)、そのサイズは(3.0, 3.0)です）</span><!--end_jpstr-->
</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title">Note<br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last">If you provide a new initializer with an extension, you are still responsible for making sure that each instance is fully initialized once the initializer completes.<br><span class="jpstr">
あなたが新しいイニシャライザを拡張によって提供する場合、あなたは依然として、一旦イニシャライザが完了するならば各インスタンスが完全に初期化されることを確かにする責任があります。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID154">
<h2>Methods<a class="headerlink" href="#ID154" title="Permalink to this headline">¶</a><br><span class="jpstr">
メソッド<a class="headerlink" href="#ID154" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>Extensions can add new instance methods and type methods to existing types. The following example adds a new instance method called <code class="docutils literal notranslate"><span class="pre">repetitions</span></code> to the <code class="docutils literal notranslate"><span class="pre">Int</span></code> type:<br><span class="jpstr">
拡張は、新しいインスタンスメソッドと型メソッドを既存の型に加えることができます。以下の例は、<code class="docutils literal notranslate"><span class="pre">repetitions</span></code>と呼ばれる新しいインスタンスメソッドを<code class="docutils literal notranslate"><span class="pre">Int</span></code>型に加えます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">Int</span> {
</li><li>    <span class="k">func</span> <span class="nv">repetitions</span>(<span class="nv">task</span>: () -&gt; <span class="nc">Void</span>) {
</li><li>        <span class="k">for</span> <span class="k">_</span> <span class="k">in</span> <span class="m">0</span>..&lt;<span class="k">self</span> {
</li><li>            <span class="nv">task</span>()
</li><li>        }
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>The <code class="docutils literal notranslate"><span class="pre">repetitions(task:)</span></code> method takes a single argument of type <code class="docutils literal notranslate"><span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">Void</span></code>, which indicates a function that has no parameters and does not return a value.<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">repetitions(task:)</span></code>メソッドは型<code class="docutils literal notranslate"><span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">Void</span></code>の引数をひとつだけとります、それは、パラメータを持たず、値を返さない関数であることを示します。
</span><!--end_jpstr-->
</p>
<p>After defining this extension, you can call the <code class="docutils literal notranslate"><span class="pre">repetitions(task:)</span></code> method on any integer to perform a task that many number of times:<br><span class="jpstr">
この拡張を定義した後、あなたは<code class="docutils literal notranslate"><span class="pre">repetitions(task:)</span></code>メソッドをあらゆる整数上で呼び出して、ある作業をそれだけ多くの回数実行できます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="m">3</span>.<span class="nv">repetitions</span> {
</li><li>    <span class="nv">print</span>(<span class="s">&quot;Hello!&quot;</span>)
</li><li>}
</li><li><span class="c">// Hello!</span>
</li><li><span class="c">// Hello!</span>
</li><li><span class="c">// Hello!</span>
</li></ol></div></div></div>
<div class="section" id="ID155">
<h3>Mutating Instance Methods<a class="headerlink" href="#ID155" title="Permalink to this headline">¶</a><br><span class="jpstr">
変更インスタンスメソッド<a class="headerlink" href="#ID155" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p>Instance methods added with an extension can also modify (or <em>mutate</em>) the instance itself. Structure and enumeration methods that modify <code class="docutils literal notranslate"><span class="pre">self</span></code> or its properties must mark the instance method as <code class="docutils literal notranslate"><span class="pre">mutating</span></code>, just like mutating methods from an original implementation.<br><span class="jpstr">
拡張を使って加えられるインスタンスメソッドは、また、インスタンスそれ自体を修正（または<em>変更</em>）することができます。<code class="docutils literal notranslate"><span class="pre">self</span></code>またはそのプロパティを修正する構造および列挙メソッドは、ちょうど最初の実施からの変更メソッドのように、そのインスタンスメソッドに<code class="docutils literal notranslate"><span class="pre">mutating</span></code>として印されなければなりません。
</span><!--end_jpstr-->
</p>
<p>The example below adds a new mutating method called <code class="docutils literal notranslate"><span class="pre">square</span></code> to Swift’s <code class="docutils literal notranslate"><span class="pre">Int</span></code> type, which squares the original value:<br><span class="jpstr">
下の例は、<code class="docutils literal notranslate"><span class="pre">square</span></code>と呼ばれる新しい変更メソッドをスウィフトの<code class="docutils literal notranslate"><span class="pre">Int</span></code>型に加えます、それは、もとの値を二乗します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">Int</span> {
</li><li>    <span class="k">mutating</span> <span class="k">func</span> <span class="nv">square</span>() {
</li><li>        <span class="k">self</span> = <span class="k">self</span> * <span class="k">self</span>
</li><li>    }
</li><li>}
</li><li><span class="k">var</span> <span class="nv">someInt</span> = <span class="m">3</span>
</li><li><span class="nv">someInt</span>.<span class="nv">square</span>()
</li><li><span class="c">// someInt is now 9&nbsp;<span class="jpstr">（someIntは、現在９です）</span><!--end_jpstr-->
</span>
</li></ol></div></div></div>
</div>
</div>
<div class="section" id="ID156">
<h2>Subscripts<a class="headerlink" href="#ID156" title="Permalink to this headline">¶</a><br><span class="jpstr">
添え字<a class="headerlink" href="#ID156" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>Extensions can add new subscripts to an existing type. This example adds an integer subscript to Swift’s built-in <code class="docutils literal notranslate"><span class="pre">Int</span></code> type. This subscript <code class="docutils literal notranslate"><span class="pre">[n]</span></code> returns the decimal digit <code class="docutils literal notranslate"><span class="pre">n</span></code> places in from the right of the number:<br><span class="jpstr">
拡張は、新しい添え字を既存の型に加えることができます。この例は、整数添え字をスウィフトの組み込みの<code class="docutils literal notranslate"><span class="pre">Int</span></code>型に加えます。この添え字<code class="docutils literal notranslate"><span class="pre">[n]</span></code>は、右の数からの10進桁<code class="docutils literal notranslate"><span class="pre">n</span></code>位置を返します：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">123456789[0]</span></code> returns <code class="docutils literal notranslate"><span class="pre">9</span></code><br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">123456789[0]</span></code>は<code class="docutils literal notranslate"><span class="pre">9</span></code>を返します
</span><!--end_jpstr-->
</li>
<li><code class="docutils literal notranslate"><span class="pre">123456789[1]</span></code> returns <code class="docutils literal notranslate"><span class="pre">8</span></code><br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">123456789[1]</span></code>は<code class="docutils literal notranslate"><span class="pre">8</span></code>を返します
</span><!--end_jpstr-->
</li>
</ul>
<p>…and so on:<br><span class="jpstr">
…などなど：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">Int</span> {
</li><li>    <span class="k">subscript</span>(<span class="nv">digitIndex</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Int</span> {
</li><li>        <span class="k">var</span> <span class="nv">decimalBase</span> = <span class="m">1</span>
</li><li>        <span class="k">for</span> <span class="k">_</span> <span class="k">in</span> <span class="m">0</span>..&lt;<span class="nv">digitIndex</span> {
</li><li>            <span class="nv">decimalBase</span> *= <span class="m">10</span>
</li><li>        }
</li><li>        <span class="k">return</span> (<span class="k">self</span> / <span class="nv">decimalBase</span>) % <span class="m">10</span>
</li><li>    }
</li><li>}
</li><li><span class="m">746381295</span>[<span class="m">0</span>]
</li><li><span class="c">// returns 5&nbsp;<span class="jpstr">（5を返します）</span><!--end_jpstr-->
</span>
</li><li><span class="m">746381295</span>[<span class="m">1</span>]
</li><li><span class="c">// returns 9&nbsp;<span class="jpstr">（9を返します）</span><!--end_jpstr-->
</span>
</li><li><span class="m">746381295</span>[<span class="m">2</span>]
</li><li><span class="c">// returns 2&nbsp;<span class="jpstr">（2を返します）</span><!--end_jpstr-->
</span>
</li><li><span class="m">746381295</span>[<span class="m">8</span>]
</li><li><span class="c">// returns 7&nbsp;<span class="jpstr">（7を返します）</span><!--end_jpstr-->
</span>
</li></ol></div></div></div>
<p>If the <code class="docutils literal notranslate"><span class="pre">Int</span></code> value does not have enough digits for the requested index, the subscript implementation returns <code class="docutils literal notranslate"><span class="pre">0</span></code>, as if the number had been padded with zeros to the left:<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Int</span></code>値には要十分な桁が請されたインデックスに対してないならば、この添え字実装は、まるで数が左にゼロを詰められたように<code class="docutils literal notranslate"><span class="pre">0</span></code>を返します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="m">746381295</span>[<span class="m">9</span>]
</li><li><span class="c">// returns 0, as if you had requested:&nbsp;<span class="jpstr">（まるであなたが次のように要請したかのように、0を返します：）</span><!--end_jpstr-->
</span>
</li><li><span class="m">0746381295</span>[<span class="m">9</span>]
</li></ol></div></div></div>
</div>
<div class="section" id="ID157">
<h2>Nested Types<a class="headerlink" href="#ID157" title="Permalink to this headline">¶</a><br><span class="jpstr">
入れ子にされた型<a class="headerlink" href="#ID157" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p>Extensions can add new nested types to existing classes, structures, and enumerations:<br><span class="jpstr">
拡張は、新しい入れ子にされた型を既存のクラス、構造体、および列挙に加えることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">extension</span> <span class="nc">Int</span> {
</li><li>    <span class="k">enum</span> <span class="nv">Kind</span> {
</li><li>        <span class="k">case</span> <span class="nv">negative</span>, <span class="nv">zero</span>, <span class="nv">positive</span>
</li><li>    }
</li><li>    <span class="k">var</span> <span class="nv">kind</span>: <span class="nc">Kind</span> {
</li><li>        <span class="k">switch</span> <span class="k">self</span> {
</li><li>        <span class="k">case</span> <span class="m">0</span>:
</li><li>            <span class="k">return</span> .<span class="nv">zero</span>
</li><li>        <span class="k">case</span> <span class="k">let</span> <span class="nv">x</span> <span class="k">where</span> <span class="nv">x</span> &gt; <span class="m">0</span>:
</li><li>            <span class="k">return</span> .<span class="nv">positive</span>
</li><li>        <span class="k">default</span>:
</li><li>            <span class="k">return</span> .<span class="nv">negative</span>
</li><li>        }
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p>This example adds a new nested enumeration to <code class="docutils literal notranslate"><span class="pre">Int</span></code>. This enumeration, called <code class="docutils literal notranslate"><span class="pre">Kind</span></code>, expresses the kind of number that a particular integer represents. Specifically, it expresses whether the number is negative, zero, or positive.<br><span class="jpstr">
この例は、新しい入れ子にされた列挙を<code class="docutils literal notranslate"><span class="pre">Int</span></code>に加えます。この列挙は、<code class="docutils literal notranslate"><span class="pre">Kind</span></code>と呼ばれ、特定の整数を表わす数の種類を表わします。具体的には、それはその数が負、ゼロ、または正かを表わします。
</span><!--end_jpstr-->
</p>
<p>This example also adds a new computed instance property to <code class="docutils literal notranslate"><span class="pre">Int</span></code>, called <code class="docutils literal notranslate"><span class="pre">kind</span></code>, which returns the appropriate <code class="docutils literal notranslate"><span class="pre">Kind</span></code> enumeration case for that integer.<br><span class="jpstr">
この例はまた、新しい計算インスタンスプロパティを<code class="docutils literal notranslate"><span class="pre">Int</span></code>に加えます、それは、<code class="docutils literal notranslate"><span class="pre">kind</span></code>と呼ばれ、その整数に対する適切な<code class="docutils literal notranslate"><span class="pre">Kind</span></code>列挙ケース節を返します。
</span><!--end_jpstr-->
</p>
<p>The nested enumeration can now be used with any <code class="docutils literal notranslate"><span class="pre">Int</span></code> value:<br><span class="jpstr">
入れ子にされた列挙は今やあらゆる<code class="docutils literal notranslate"><span class="pre">Int</span></code>値で使われることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">printIntegerKinds</span>(<span class="k">_</span> <span class="nv">numbers</span>: [<span class="nc">Int</span>]) {
</li><li>    <span class="k">for</span> <span class="nv">number</span> <span class="k">in</span> <span class="nv">numbers</span> {
</li><li>        <span class="k">switch</span> <span class="nv">number</span>.<span class="nv">kind</span> {
</li><li>        <span class="k">case</span> .<span class="nv">negative</span>:
</li><li>            <span class="nv">print</span>(<span class="s">&quot;- &quot;</span>, <span class="nv">terminator</span>: <span class="s">&quot;&quot;</span>)
</li><li>        <span class="k">case</span> .<span class="nv">zero</span>:
</li><li>            <span class="nv">print</span>(<span class="s">&quot;0 &quot;</span>, <span class="nv">terminator</span>: <span class="s">&quot;&quot;</span>)
</li><li>        <span class="k">case</span> .<span class="nv">positive</span>:
</li><li>            <span class="nv">print</span>(<span class="s">&quot;+ &quot;</span>, <span class="nv">terminator</span>: <span class="s">&quot;&quot;</span>)
</li><li>        }
</li><li>    }
</li><li>    <span class="nv">print</span>(<span class="s">&quot;&quot;</span>)
</li><li>}
</li><li><span class="nv">printIntegerKinds</span>([<span class="m">3</span>, <span class="m">19</span>, <span class="m">-27</span>, <span class="m">0</span>, <span class="m">-6</span>, <span class="m">0</span>, <span class="m">7</span>])
</li><li><span class="c">// Prints &quot;+ + - 0 - 0 + &quot;</span>
</li></ol></div></div></div>
<p>This function, <code class="docutils literal notranslate"><span class="pre">printIntegerKinds(_:)</span></code>, takes an input array of <code class="docutils literal notranslate"><span class="pre">Int</span></code> values and iterates over those values in turn. For each integer in the array, the function considers the <code class="docutils literal notranslate"><span class="pre">kind</span></code> computed property for that integer, and prints an appropriate description.<br><span class="jpstr">
この関数、<code class="docutils literal notranslate"><span class="pre">printIntegerKinds(_:)</span></code>は、<code class="docutils literal notranslate"><span class="pre">Int</span></code>値の配列の入力を取り、それらの値に最初から終わりまで順番に繰り返していきます。その配列の各整数に対して、この関数はその整数に対する<code class="docutils literal notranslate"><span class="pre">kind</span></code>計算プロパティを考慮して、適切な説明を出力します。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title">Note<br><span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">number.kind</span></code> is already known to be of type <code class="docutils literal notranslate"><span class="pre">Int.Kind</span></code>. Because of this, all of the <code class="docutils literal notranslate"><span class="pre">Int.Kind</span></code> case values can be written in shorthand form inside the <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement, such as <code class="docutils literal notranslate"><span class="pre">.negative</span></code> rather than <code class="docutils literal notranslate"><span class="pre">Int.Kind.negative</span></code>.<br><span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">number.kind</span></code>は、既に型<code class="docutils literal notranslate"><span class="pre">Int.Kind</span></code>であると知られます。そのことから、<code class="docutils literal notranslate"><span class="pre">Int.Kind</span></code>のケース節の値の全ては、<code class="docutils literal notranslate"><span class="pre">switch</span></code>文内で略記形式で書かれることができます、たとえば<code class="docutils literal notranslate"><span class="pre">Int.Kind.negative</span></code>ではなく<code class="docutils literal notranslate"><span class="pre">.negative</span></code>のように。
</span><!--end_jpstr-->
</p>
</div>
</div>
</div>


    </article>
    <div class="next_previous">
        <p class="previous"><a href="NestedTypes.html">Nested Types<br><span class="jpstr">
入れ子にされた型
</span><!--end_jpstr-->
</a></p>
        <p class="next"><a href="Protocols.html">Protocols<br><span class="jpstr">
プロトコル
</span><!--end_jpstr-->
</a></p>
    </div>

    <div class="admonition-beta admonition">
        <p class="first admonition-title">Beta Software</p>
        <p>
          This documentation contains preliminary information about an API or technology in development.
          This information is subject to change, and software implemented according to this documentation should be tested with final operating system software.
        <br><span class="jpstr">
この文書は、開発でのテクノロジーまたはAPIのための事前の情報を含んでいます。
          この情報は変更される場合があり、この文書に沿って実装されるソフトウェアは最終的なオペレーティングシステム・ソフトウェアでテストされなければなりません。
</span><!--end_jpstr-->
</p>
        <p class="last"><a class="reference external" href="https://developer.apple.com/support/beta-software/">Learn more about using Apple's beta software</a></p>
    </div>
</main>


<footer role="contentinfo">
  <aside>
    <a href="//swift.org/atom.xml" title="Subscribe to Site Updates"><i class="feed">Subscribe</i></a>
    <a href="https://twitter.com/swiftlang" rel="nofollow" title="Follow @SwiftLang on Twitter"><i class="twitter">Twitter</i></a>
  </aside>

  <p class="copyright">Copyright &copy; 2018 Apple Inc. All rights reserved.</p>
  <p class="trademark">Swift and the Swift logo are trademarks of Apple Inc.</p>
  <p class="privacy">
    <a href="//www.apple.com/privacy/privacy-policy/">Privacy Policy</a>
    <a href="//www.apple.com/legal/privacy/en-ww/cookies/">Cookies</a>
  </p>
</footer>
<div id="jump_to_overlay"></div>
<script src="../static/javascripts/application.js"></script>
  </body>
</html>
