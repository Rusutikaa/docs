

<!DOCTYPE html>



<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8" />
    <meta name="author" content="Apple Inc." />
    <meta name="viewport" content="width=device-width initial-scale=1" />
    
    <title>Properties — The Swift Programming Language (Swift 5.5)</title>
    
    <link rel="license" href="/LICENSE.txt" />
    <link rel="stylesheet" media="all" href="../static/stylesheets/application.css" />
    <link rel="stylesheet" media="all" href="../static/stylesheets/tspl.css" />
    <link rel="shortcut icon" sizes="16x16 24x24 32x32 48x48 64x64" type="image/vnd.microsoft.icon" href="/favicon.ico" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png" />
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png" />
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png" />
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png" />
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png" />
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png" />
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png" />
    <link rel="mask-icon" href="/assets/images/icon-swift.svg" color="#F05339" /> 
  </head>
  <body>


<nav role="navigation">
    <header role="banner">
      <h1 id="logo">
        <a href="https://swift.org/" title="Swift.org" role="img" aria-label="Swift.org">
          Swift.org
        </a>
      </h1>
    </header>

    <div id="menu-toggle" class="menu-toggle open"></div>

    <h2>The Swift Programming Language<div>Swift 5.5</div></h2>

    <ul>
    <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html"><span class="enstr">Welcome to Swift</span><!--end_enstr-->
<span class="jpstr">
スウィフトにようこそ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="TheBasics.html"><span class="enstr">Language Guide</span><!--end_enstr-->
<span class="jpstr">
言語ガイド
</span><!--end_jpstr-->
</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="TheBasics.html"><span class="enstr">The Basics</span><!--end_enstr-->
<span class="jpstr">
基本
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="BasicOperators.html"><span class="enstr">Basic Operators</span><!--end_enstr-->
<span class="jpstr">
基本の演算子
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="StringsAndCharacters.html"><span class="enstr">Strings and Characters</span><!--end_enstr-->
<span class="jpstr">
文字列と文字
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="CollectionTypes.html"><span class="enstr">Collection Types</span><!--end_enstr-->
<span class="jpstr">
コレクション型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ControlFlow.html"><span class="enstr">Control Flow</span><!--end_enstr-->
<span class="jpstr">
制御の流れ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Functions.html"><span class="enstr">Functions</span><!--end_enstr-->
<span class="jpstr">
関数
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Closures.html"><span class="enstr">Closures</span><!--end_enstr-->
<span class="jpstr">
クロージャ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Enumerations.html"><span class="enstr">Enumerations</span><!--end_enstr-->
<span class="jpstr">
列挙
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ClassesAndStructures.html"><span class="enstr">Structures and Classes</span><!--end_enstr-->
<span class="jpstr">
構造体とクラス
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#"><span class="enstr">Properties</span><!--end_enstr-->
<span class="jpstr">
プロパティ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Methods.html"><span class="enstr">Methods</span><!--end_enstr-->
<span class="jpstr">
メソッド
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Subscripts.html"><span class="enstr">Subscripts</span><!--end_enstr-->
<span class="jpstr">
添え字
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Inheritance.html"><span class="enstr">Inheritance</span><!--end_enstr-->
<span class="jpstr">
継承
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Initialization.html"><span class="enstr">Initialization</span><!--end_enstr-->
<span class="jpstr">
初期化
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Deinitialization.html"><span class="enstr">Deinitialization</span><!--end_enstr-->
<span class="jpstr">
デイニシャライズ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="OptionalChaining.html"><span class="enstr">Optional Chaining</span><!--end_enstr-->
<span class="jpstr">
オプショナル連鎖
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ErrorHandling.html"><span class="enstr">Error Handling</span><!--end_enstr-->
<span class="jpstr">
エラーの処理
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html"><span class="enstr">Concurrency</span><!--end_enstr-->
<span class="jpstr">
並行性
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="TypeCasting.html"><span class="enstr">Type Casting</span><!--end_enstr-->
<span class="jpstr">
型キャスト
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="NestedTypes.html"><span class="enstr">Nested Types</span><!--end_enstr-->
<span class="jpstr">
入れ子にされた型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Extensions.html"><span class="enstr">Extensions</span><!--end_enstr-->
<span class="jpstr">
拡張
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Protocols.html"><span class="enstr">Protocols</span><!--end_enstr-->
<span class="jpstr">
プロトコル
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Generics.html"><span class="enstr">Generics</span><!--end_enstr-->
<span class="jpstr">
総称体
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="OpaqueTypes.html"><span class="enstr">Opaque Types</span><!--end_enstr-->
<span class="jpstr">
不透明型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AutomaticReferenceCounting.html"><span class="enstr">Automatic Reference Counting</span><!--end_enstr-->
<span class="jpstr">
自動参照カウント
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="MemorySafety.html"><span class="enstr">Memory Safety</span><!--end_enstr-->
<span class="jpstr">
メモリ安全
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AccessControl.html"><span class="enstr">Access Control</span><!--end_enstr-->
<span class="jpstr">
アクセス制御
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AdvancedOperators.html"><span class="enstr">Advanced Operators</span><!--end_enstr-->
<span class="jpstr">
先進の演算子
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ReferenceManual/AboutTheLanguageReference.html"><span class="enstr">Language Reference</span><!--end_enstr-->
<span class="jpstr">
言語リファレンス
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1"><a class="reference internal" href="../RevisionHistory/RevisionHistory.html"><span class="enstr">Revision History</span><!--end_enstr-->
<span class="jpstr">
改訂履歴
</span><!--end_jpstr-->
</a></li>
</ul>

    <li class="toctree-l1 return"><a class="reference internal" href="../../../index.html">← Go to Index</a></li>
    </ul>
</nav>




<main role="main">
    <article class="page">
        <menu id="bashful" type="toolbar">
          <div class="inner">
            <menuitem id="jump_to" class="menu-bar-item closed">
            <span id="jump_to_toggle">On This Page</span>
            <div class="chevron">
                <div class="chevy chevron-left"></div>
                <div class="chevy chevron-right"></div>
            </div>
            <menu type="list" class="details">
                <ul>
<li><a class="reference internal" href="#"><span class="enstr">Properties</span><!--end_enstr-->
<span class="jpstr">
プロパティ
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID255"><span class="enstr">Stored Properties</span><!--end_enstr-->
<span class="jpstr">
格納プロパティ
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID256"><span class="enstr">Stored Properties of Constant Structure Instances</span><!--end_enstr-->
<span class="jpstr">
定数構造体インスタンスの格納プロパティ
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID257"><span class="enstr">Lazy Stored Properties</span><!--end_enstr-->
<span class="jpstr">
遅延格納プロパティ
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID258"><span class="enstr">Stored Properties and Instance Variables</span><!--end_enstr-->
<span class="jpstr">
格納プロパティとインスタンス変数
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID259"><span class="enstr">Computed Properties</span><!--end_enstr-->
<span class="jpstr">
計算プロパティ
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID260"><span class="enstr">Shorthand Setter Declaration</span><!--end_enstr-->
<span class="jpstr">
短縮形セッター宣言
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID608"><span class="enstr">Shorthand Getter Declaration</span><!--end_enstr-->
<span class="jpstr">
略記ゲッター宣言
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID261"><span class="enstr">Read-Only Computed Properties</span><!--end_enstr-->
<span class="jpstr">
読み出し専用の計算プロパティ
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID262"><span class="enstr">Property Observers</span><!--end_enstr-->
<span class="jpstr">
プロパティオブザーバー
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID617"><span class="enstr">Property Wrappers</span><!--end_enstr-->
<span class="jpstr">
プロパティラッパー
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID618"><span class="enstr">Setting Initial Values for Wrapped Properties</span><!--end_enstr-->
<span class="jpstr">
ラップされたプロパティに初期値を設定する
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID619"><span class="enstr">Projecting a Value From a Property Wrapper</span><!--end_enstr-->
<span class="jpstr">
値をプロパティラッパーから投影する
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID263"><span class="enstr">Global and Local Variables</span><!--end_enstr-->
<span class="jpstr">
グローバルおよびローカル変数
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID264"><span class="enstr">Type Properties</span><!--end_enstr-->
<span class="jpstr">
型プロパティ
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID265"><span class="enstr">Type Property Syntax</span><!--end_enstr-->
<span class="jpstr">
型プロパティ構文
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID266"><span class="enstr">Querying and Setting Type Properties</span><!--end_enstr-->
<span class="jpstr">
型プロパティを問い合わせて、設定する
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            </menu>
            </menuitem>
          </div>
        </menu>

        
  <div class="section" id="properties">
<h1><span class="enstr">Properties<a class="headerlink" href="#properties" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
プロパティ<a class="headerlink" href="#properties" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h1>
<p><span class="enstr"><em>Properties</em> associate values with a particular class, structure, or enumeration. Stored properties store constant and variable values as part of an instance, whereas computed properties calculate (rather than store) a value. Computed properties are provided by classes, structures, and enumerations. Stored properties are provided only by classes and structures.</span><!--end_enstr-->
<span class="jpstr">
<em>プロパティ</em>は、いくつかの値を特定のクラス、構造体、または列挙と結びつけます。格納プロパティは、あるインスタンスの一部として定数と変数の値を格納します、一方で、計算プロパティは、値を（たくわえておくのではなく）計算します。計算プロパティは、クラス、構造体、および列挙で提供されます。格納プロパティは、クラスと構造体だけで提供されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Stored and computed properties are usually associated with instances of a particular type. However, properties can also be associated with the type itself. Such properties are known as type properties.</span><!--end_enstr-->
<span class="jpstr">
格納されるもしくは計算されるプロパティは、通常は特定の型のインスタンスに結び付けられます。しかし、プロパティはまた、型それ自体に結び付けられることができます。そのようなプロパティは、型プロパティとして知られています。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">In addition, you can define property observers to monitor changes in a property’s value, which you can respond to with custom actions. Property observers can be added to stored properties you define yourself, and also to properties that a subclass inherits from its superclass.</span><!--end_enstr-->
<span class="jpstr">
それに加えて、あなたはプロパティオブザーバーを定義して、あるプロパティの値の変化を監視することができて、あなたはあつらえの動作でそれに応答することができます。プロパティオブザーバーは、あなたがあなた自身で定義する格納プロパティに、そのうえにサブクラスがそのスーパークラスから継承するプロパティにも加えられることができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can also use a property wrapper to reuse code in the getter and setter of multiple properties.</span><!--end_enstr-->
<span class="jpstr">
あなたはまたプロパティラッパーを使用して、複数のプロパティのゲッターとセッターでコードを再利用できます。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID255">
<h2><span class="enstr">Stored Properties<a class="headerlink" href="#ID255" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
格納プロパティ<a class="headerlink" href="#ID255" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">In its simplest form, a stored property is a constant or variable that’s stored as part of an instance of a particular class or structure. Stored properties can be either <em>variable stored properties</em> (introduced by the <code class="docutils literal notranslate"><span class="pre">var</span></code> keyword) or <em>constant stored properties</em> (introduced by the <code class="docutils literal notranslate"><span class="pre">let</span></code> keyword).</span><!--end_enstr-->
<span class="jpstr">
その最も単純な形式で、格納プロパティは、特定のクラスまたは構造体のあるひとつのインスタンスの一部として格納される定数または変数です。格納プロパティは、<em>変数格納プロパティ</em>（<code class="docutils literal notranslate"><span class="pre">var</span></code>キーワードによって導入される）か<em>定数格納プロパティ</em>（<code class="docutils literal notranslate"><span class="pre">let</span></code>キーワードによって導入される）であることができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can provide a default value for a stored property as part of its definition, as described in <a class="reference internal" href="Initialization.html#ID206"><span class="std std-ref">Default Property Values</span></a>. You can also set and modify the initial value for a stored property during initialization. This is true even for constant stored properties, as described in <a class="reference internal" href="Initialization.html#ID212"><span class="std std-ref">Assigning Constant Properties During Initialization</span></a>.</span><!--end_enstr-->
<span class="jpstr">
<a class="reference internal" href="Initialization.html#ID206"><span class="std std-ref">省略時のプロパティ値</span></a>で記述されるように、あなたは格納プロパティのために省略時の値をその定義の一部として用意することができます。あなたは、また、初期化のときに格納プロパティに対して最初の値を設定および修正することができます。<a class="reference internal" href="Initialization.html#ID212"><span class="std std-ref">初期化の間に定数プロパティを割り当てる</span></a>で記述されるように、これは定数格納プロパティにさえあてはまります。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The example below defines a structure called <code class="docutils literal notranslate"><span class="pre">FixedLengthRange</span></code>, which describes a range of integers whose range length can’t be changed after it’s created:</span><!--end_enstr-->
<span class="jpstr">
以下の例は<code class="docutils literal notranslate"><span class="pre">FixedLengthRange</span></code>と呼ばれる構造体を定義します、それは、それが作成された後に範囲長が変更されることが出来ない、整数からなるある範囲を記述します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">FixedLengthRange</span> {
</li><li>    <span class="k">var</span> <span class="nv">firstValue</span>: <span class="nc">Int</span>
</li><li>    <span class="k">let</span> <span class="nv">length</span>: <span class="nc">Int</span>
</li><li>}
</li><li><span class="k">var</span> <span class="nv">rangeOfThreeItems</span> = <span class="nv">FixedLengthRange</span>(<span class="nv">firstValue</span>: <span class="m">0</span>, <span class="nv">length</span>: <span class="m">3</span>)
</li><li><span class="c"><span class="enstr">// the range represents integer values 0, 1, and 2</span><!--end_enstr--><span class="jpstr">（範囲は、整数値０、１、そして２を表します）</span><!--end_jpstr--></span>
</li><li><span class="nv">rangeOfThreeItems</span>.<span class="nv">firstValue</span> = <span class="m">6</span>
</li><li><span class="c"><span class="enstr">// the range now represents integer values 6, 7, and 8</span><!--end_enstr--><span class="jpstr">（範囲は、現在は整数値６、７、そして８を表します）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">Instances of <code class="docutils literal notranslate"><span class="pre">FixedLengthRange</span></code> have a variable stored property called <code class="docutils literal notranslate"><span class="pre">firstValue</span></code> and a constant stored property called <code class="docutils literal notranslate"><span class="pre">length</span></code>. In the example above, <code class="docutils literal notranslate"><span class="pre">length</span></code> is initialized when the new range is created and can’t be changed thereafter, because it’s a constant property.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">FixedLengthRange</span></code>のインスタンスは<code class="docutils literal notranslate"><span class="pre">firstValue</span></code>と呼ばれる変数格納プロパティと<code class="docutils literal notranslate"><span class="pre">length</span></code>と呼ばれる定数格納プロパティをもちます。上の例で、<code class="docutils literal notranslate"><span class="pre">length</span></code>は新しい範囲が作成される時に初期化されます、そしてその後は変更されることが出来ません、なぜならそれが変数プロパティだからです。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID256">
<h3><span class="enstr">Stored Properties of Constant Structure Instances<a class="headerlink" href="#ID256" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
定数構造体インスタンスの格納プロパティ<a class="headerlink" href="#ID256" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p><span class="enstr">If you create an instance of a structure and assign that instance to a constant, you can’t modify the instance’s properties, even if they were declared as variable properties:</span><!--end_enstr-->
<span class="jpstr">
あなたが構造体のインスタンスをつくって、そのインスタンスを定数に代入するならば、あなたはそのインスタンスのもつプロパティを、たとえそれらが変数プロパティとして宣言されたとしても、修正することはできません：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">rangeOfFourItems</span> = <span class="nv">FixedLengthRange</span>(<span class="nv">firstValue</span>: <span class="m">0</span>, <span class="nv">length</span>: <span class="m">4</span>)
</li><li><span class="c"><span class="enstr">// this range represents integer values 0, 1, 2, and 3</span><!--end_enstr--><span class="jpstr">（この範囲構造体、整数値０、１、２、そして３を表します）</span><!--end_jpstr--></span>
</li><li><span class="nv">rangeOfFourItems</span>.<span class="nv">firstValue</span> = <span class="m">6</span>
</li><li><span class="c"><span class="enstr">// this will report an error, even though firstValue is a variable property</span><!--end_enstr--><span class="jpstr">（これはエラーを報告します、たとえfirstValueが変数プロパティであるとしてもです）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">Because <code class="docutils literal notranslate"><span class="pre">rangeOfFourItems</span></code> is declared as a constant (with the <code class="docutils literal notranslate"><span class="pre">let</span></code> keyword), it isn’t possible to change its <code class="docutils literal notranslate"><span class="pre">firstValue</span></code> property, even though <code class="docutils literal notranslate"><span class="pre">firstValue</span></code> is a variable property.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">rangeOfFourItems</span></code>が定数（<code class="docutils literal notranslate"><span class="pre">let</span></code>キーワードを使って）として宣言されるので、たとえ<code class="docutils literal notranslate"><span class="pre">firstValue</span></code>が変数プロパティであるとしても、その<code class="docutils literal notranslate"><span class="pre">firstValue</span></code>プロパティを変えることは可能ではありません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">This behavior is due to structures being <em>value types</em>. When an instance of a value type is marked as a constant, so are all of its properties.</span><!--end_enstr-->
<span class="jpstr">
この挙動は、この構造体が<em>値型</em>であるためです。値型のインスタンスが定数として印される時は、そのプロパティの全てがそうです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The same isn’t true for classes, which are <em>reference types</em>. If you assign an instance of a reference type to a constant, you can still change that instance’s variable properties.</span><!--end_enstr-->
<span class="jpstr">
同じことはクラスにはあてはまりません、それは<em>参照型</em>です。あなたが参照型のインスタンスを定数に代入するならば、あなたは依然としてそのインスタンスの変数プロパティを変えることができます。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID257">
<h3><span class="enstr">Lazy Stored Properties<a class="headerlink" href="#ID257" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
遅延格納プロパティ<a class="headerlink" href="#ID257" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p><span class="enstr">A <em>lazy stored property</em> is a property whose initial value isn’t calculated until the first time it’s used. You indicate a lazy stored property by writing the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> modifier before its declaration.</span><!--end_enstr-->
<span class="jpstr">
<em>遅延格納プロパティ</em>は、初めてそれが使われるまで、初期値が計算されないプロパティです。あなたは、<code class="docutils literal notranslate"><span class="pre">lazy</span></code>修飾子をその宣言の前に書くことによって遅延格納プロパティであることを示します。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">You must always declare a lazy property as a variable (with the <code class="docutils literal notranslate"><span class="pre">var</span></code> keyword), because its initial value might not be retrieved until after instance initialization completes. Constant properties must always have a value <em>before</em> initialization completes, and therefore can’t be declared as lazy.</span><!--end_enstr-->
<span class="jpstr">
あなたは常に遅延プロパティを変数として（<code class="docutils literal notranslate"><span class="pre">var</span></code>キーワードを使って）宣言しなければなりません、なぜならその最初の値はインスタンスの初期化が完了する後まで取り出されないかもしれないからです。定数プロパティは常に値を、初期化が完了する<em>前に</em>持たなければなりません、それゆえに遅延であると宣言されることが出来ません。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">Lazy properties are useful when the initial value for a property is dependent on outside factors whose values aren’t known until after an instance’s initialization is complete. Lazy properties are also useful when the initial value for a property requires complex or computationally expensive setup that shouldn’t be performed unless or until it’s needed.</span><!--end_enstr-->
<span class="jpstr">
遅延プロパティが役に立つのは、プロパティのための最初の値がインスタンスの初期化が終了する後まで値が知られない外部の要因に依存しているときです。遅延プロパティはまた、プロパティのための最初の値が、それが必要でないなら、あるいは必要になるまで、実行されるべきではない複雑なまたはコンピュータ処理的に高くつく準備を必要とするときに役に立ちます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The example below uses a lazy stored property to avoid unnecessary initialization of a complex class. This example defines two classes called <code class="docutils literal notranslate"><span class="pre">DataImporter</span></code> and <code class="docutils literal notranslate"><span class="pre">DataManager</span></code>, neither of which is shown in full:</span><!--end_enstr-->
<span class="jpstr">
下の例は、ある複雑なクラスの必要でない初期化を避けるために遅延格納プロパティを使います。この例は、<code class="docutils literal notranslate"><span class="pre">DataImporter</span></code>と<code class="docutils literal notranslate"><span class="pre">DataManager</span></code>と呼ばれる２つのクラスを定義します、そのどちらも全部は示されません：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">DataImporter</span> {
</li><li>    <span class="c">/*</span>
</li><li><span class="c">    <span class="enstr">DataImporter is a class to import data from an external file.</span><!--end_enstr--><span class="jpstr">（DataImporterは、データを外部ファイルからインポートするクラスです。）</span><!--end_jpstr--></span>
</li><li><span class="c">    <span class="enstr">The class is assumed to take a nontrivial amount of time to initialize.</span><!--end_enstr--><span class="jpstr">（このクラスは、瑣末でない量の時間が初期化にかかると仮定されます。）</span><!--end_jpstr--></span>
</li><li><span class="c">    */</span>
</li><li>    <span class="k">var</span> <span class="nv">filename</span> = <span class="s">"data.txt"</span>
</li><li>    <span class="c"><span class="enstr">// the DataImporter class would provide data importing functionality here</span><!--end_enstr--><span class="jpstr">（DataImporterクラスは、データをインポートする機能性をここで提供します）</span><!--end_jpstr--></span>
</li><li>}
</li><li>
</li><li><span class="k">class</span> <span class="nv">DataManager</span> {
</li><li>    <span class="k">lazy</span> <span class="k">var</span> <span class="nv">importer</span> = <span class="nv">DataImporter</span>()
</li><li>    <span class="k">var</span> <span class="nv">data</span>: [<span class="nc">String</span>] = []
</li><li>    <span class="c"><span class="enstr">// the DataManager class would provide data management functionality here</span><!--end_enstr--><span class="jpstr">（DataManagerクラスは、データ管理の機能性をここで提供します）</span><!--end_jpstr--></span>
</li><li>}
</li><li>
</li><li><span class="k">let</span> <span class="nv">manager</span> = <span class="nv">DataManager</span>()
</li><li><span class="nv">manager</span>.<span class="nv">data</span>.<span class="nv">append</span>(<span class="s">"Some data"</span>)
</li><li><span class="nv">manager</span>.<span class="nv">data</span>.<span class="nv">append</span>(<span class="s">"Some more data"</span>)
</li><li><span class="c"><span class="enstr">// the DataImporter instance for the importer property hasn't yet been created</span><!--end_enstr--><span class="jpstr">（importerプロパティのためのDataImporterインスタンスは、まだ作成されていません）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">DataManager</span></code> class has a stored property called <code class="docutils literal notranslate"><span class="pre">data</span></code>, which is initialized with a new, empty array of <code class="docutils literal notranslate"><span class="pre">String</span></code> values. Although the rest of its functionality isn’t shown, the purpose of this <code class="docutils literal notranslate"><span class="pre">DataManager</span></code> class is to manage and provide access to this array of <code class="docutils literal notranslate"><span class="pre">String</span></code> data.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">DataManager</span></code>クラスは<code class="docutils literal notranslate"><span class="pre">data</span></code>と呼ばれる格納プロパティを持ちます、それは、<code class="docutils literal notranslate"><span class="pre">String</span></code>値の、新規の、空の配列で初期化されます。その機能性の残りの部分は示されないけれども、この<code class="docutils literal notranslate"><span class="pre">DataManager</span></code>クラスの目的はこの<code class="docutils literal notranslate"><span class="pre">String</span></code>データの配列を管理して、アクセス提供することになっています。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Part of the functionality of the <code class="docutils literal notranslate"><span class="pre">DataManager</span></code> class is the ability to import data from a file. This functionality is provided by the <code class="docutils literal notranslate"><span class="pre">DataImporter</span></code> class, which is assumed to take a nontrivial amount of time to initialize. This might be because a <code class="docutils literal notranslate"><span class="pre">DataImporter</span></code> instance needs to open a file and read its contents into memory when the <code class="docutils literal notranslate"><span class="pre">DataImporter</span></code> instance is initialized.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">DataManager</span></code>クラスの機能性の一部は、データをファイルからインポートする能力です。この機能性は<code class="docutils literal notranslate"><span class="pre">DataImporter</span></code>クラスによって提供されます、それは、初期化するために瑣末でない量の時間がかかると仮定されます。これは、<code class="docutils literal notranslate"><span class="pre">DataImporter</span></code>インスタンスが初期化されるとき、<code class="docutils literal notranslate"><span class="pre">DataImporter</span></code>インスタンスがファイルを開いてメモリーにその内容を読む必要があるからでしょう。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Because it’s possible for a <code class="docutils literal notranslate"><span class="pre">DataManager</span></code> instance to manage its data without ever importing data from a file, <code class="docutils literal notranslate"><span class="pre">DataManager</span></code> doesn’t create a new <code class="docutils literal notranslate"><span class="pre">DataImporter</span></code> instance when the <code class="docutils literal notranslate"><span class="pre">DataManager</span></code> itself is created. Instead, it makes more sense to create the <code class="docutils literal notranslate"><span class="pre">DataImporter</span></code> instance if and when it’s first used.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">DataManager</span></code>インスタンスにはそれのデータを管理することがファイルからデータを一度もインポートせずに可能なので、<code class="docutils literal notranslate"><span class="pre">DataManager</span></code>は新しい<code class="docutils literal notranslate"><span class="pre">DataImporter</span></code>インスタンスの作成を<code class="docutils literal notranslate"><span class="pre">DataManager</span></code>それ自身が作成される時に行いません。その代わりに、それが最初に必要とされる時になれば<code class="docutils literal notranslate"><span class="pre">DataImporter</span></code>を作成するほうが筋が通ります。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Because it’s marked with the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> modifier, the <code class="docutils literal notranslate"><span class="pre">DataImporter</span></code> instance for the <code class="docutils literal notranslate"><span class="pre">importer</span></code> property is only created when the <code class="docutils literal notranslate"><span class="pre">importer</span></code> property is first accessed, such as when its <code class="docutils literal notranslate"><span class="pre">filename</span></code> property is queried:</span><!--end_enstr-->
<span class="jpstr">
それが<code class="docutils literal notranslate"><span class="pre">lazy</span></code>修飾子という特徴をもつので、<code class="docutils literal notranslate"><span class="pre">importer</span></code>プロパティのための<code class="docutils literal notranslate"><span class="pre">DataImporter</span></code>インスタンスは、<code class="docutils literal notranslate"><span class="pre">importer</span></code>プロパティが最初にアクセスされるsgにだけ作成されます、例えばその<code class="docutils literal notranslate"><span class="pre">filename</span></code>プロパティがたずねられるときなど：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">print</span>(<span class="nv">manager</span>.<span class="nv">importer</span>.<span class="nv">filename</span>)
</li><li><span class="c"><span class="enstr">// the DataImporter instance for the importer property has now been created</span><!--end_enstr--><span class="jpstr">（importerプロパティのためのDataImporterインスタンスが、今つくられました）</span><!--end_jpstr--></span>
</li><li><span class="c"><span class="enstr">// Prints "data.txt"</span><!--end_enstr--><span class="jpstr">（「data.txt」を出力します）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">If a property marked with the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> modifier is accessed by multiple threads simultaneously and the property hasn’t yet been initialized, there’s no guarantee that the property will be initialized only once.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">lazy</span></code>修飾子で印されるプロパティが複数のスレッドによって同時にアクセスされ、そのプロパティがその時まだ初期化されないならば、そのプロパティがただ一度だけ初期化されるとは保障されません。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID258">
<h3><span class="enstr">Stored Properties and Instance Variables<a class="headerlink" href="#ID258" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
格納プロパティとインスタンス変数<a class="headerlink" href="#ID258" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p><span class="enstr">If you have experience with Objective-C, you may know that it provides <em>two</em> ways to store values and references as part of a class instance. In addition to properties, you can use instance variables as a backing store for the values stored in a property.</span><!--end_enstr-->
<span class="jpstr">
あなたがObjective-Cでの経験を持つならば、あなたはそれがクラスインスタンスの一部として値や参照を格納するために<em>２つの</em>方法を提供するということを知っているかもしれません。プロパティに加えて、あなたはインスタンス変数をプロパティに格納される値に対する支援外部記憶として使うことができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Swift unifies these concepts into a single property declaration. A Swift property doesn’t have a corresponding instance variable, and the backing store for a property isn’t accessed directly. This approach avoids confusion about how the value is accessed in different contexts and simplifies the property’s declaration into a single, definitive statement. All information about the property—including its name, type, and memory management characteristics—is defined in a single location as part of the type’s definition.</span><!--end_enstr-->
<span class="jpstr">
スウィフトは、これらの概念をだだ１つのプロパティ宣言に統一します。スウィフトのプロパティには対応するインスタンス変数がありません、そしてプロパティのための支援外部記憶は直接にアクセスされません。この取り組み方は、値が異なる文脈においてアクセスされる方法についての混乱を避け、プロパティの宣言をただ１つの、決定的な文に単純化します。プロパティに関する全ての情報は ― その名前、型、そしてメモリ管理などの特徴を含めて ― その型の定義の一部として１つの場所で定義されます。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID259">
<h2><span class="enstr">Computed Properties<a class="headerlink" href="#ID259" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
計算プロパティ<a class="headerlink" href="#ID259" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">In addition to stored properties, classes, structures, and enumerations can define <em>computed properties</em>, which don’t actually store a value. Instead, they provide a getter and an optional setter to retrieve and set other properties and values indirectly.</span><!--end_enstr-->
<span class="jpstr">
格納プロパティに加えて、クラス、構造体、および列挙は<em>計算プロパティ</em>を定義することができます、それは、実際に値を格納しません。その代わりに、それらは他のプロパティや値を間接的に取得したり設定したりするためにゲッターと任意のセッターを提供します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Point</span> {
</li><li>    <span class="k">var</span> <span class="nv">x</span> = <span class="m">0.0</span>, <span class="nv">y</span> = <span class="m">0.0</span>
</li><li>}
</li><li><span class="k">struct</span> <span class="nv">Size</span> {
</li><li>    <span class="k">var</span> <span class="nv">width</span> = <span class="m">0.0</span>, <span class="nv">height</span> = <span class="m">0.0</span>
</li><li>}
</li><li><span class="k">struct</span> <span class="nv">Rect</span> {
</li><li>    <span class="k">var</span> <span class="nv">origin</span> = <span class="nv">Point</span>()
</li><li>    <span class="k">var</span> <span class="nv">size</span> = <span class="nv">Size</span>()
</li><li>    <span class="k">var</span> <span class="nv">center</span>: <span class="nc">Point</span> {
</li><li>        <span class="k">get</span> {
</li><li>            <span class="k">let</span> <span class="nv">centerX</span> = <span class="nv">origin</span>.<span class="nv">x</span> + (<span class="nv">size</span>.<span class="nv">width</span> / <span class="m">2</span>)
</li><li>            <span class="k">let</span> <span class="nv">centerY</span> = <span class="nv">origin</span>.<span class="nv">y</span> + (<span class="nv">size</span>.<span class="nv">height</span> / <span class="m">2</span>)
</li><li>            <span class="k">return</span> <span class="nv">Point</span>(<span class="nv">x</span>: <span class="nv">centerX</span>, <span class="nv">y</span>: <span class="nv">centerY</span>)
</li><li>        }
</li><li>        <span class="k">set</span>(<span class="nv">newCenter</span>) {
</li><li>            <span class="nv">origin</span>.<span class="nv">x</span> = <span class="nv">newCenter</span>.<span class="nv">x</span> - (<span class="nv">size</span>.<span class="nv">width</span> / <span class="m">2</span>)
</li><li>            <span class="nv">origin</span>.<span class="nv">y</span> = <span class="nv">newCenter</span>.<span class="nv">y</span> - (<span class="nv">size</span>.<span class="nv">height</span> / <span class="m">2</span>)
</li><li>        }
</li><li>    }
</li><li>}
</li><li><span class="k">var</span> <span class="nv">square</span> = <span class="nv">Rect</span>(<span class="nv">origin</span>: <span class="nv">Point</span>(<span class="nv">x</span>: <span class="m">0.0</span>, <span class="nv">y</span>: <span class="m">0.0</span>),
</li><li>                  <span class="nv">size</span>: <span class="nv">Size</span>(<span class="nv">width</span>: <span class="m">10.0</span>, <span class="nv">height</span>: <span class="m">10.0</span>))
</li><li><span class="k">let</span> <span class="nv">initialSquareCenter</span> = <span class="nv">square</span>.<span class="nv">center</span>
</li><li><span class="nv">square</span>.<span class="nv">center</span> = <span class="nv">Point</span>(<span class="nv">x</span>: <span class="m">15.0</span>, <span class="nv">y</span>: <span class="m">15.0</span>)
</li><li><span class="nv">print</span>(<span class="s">"square.origin is now at (</span>\<span class="p">(</span><span class="nv">square</span>.<span class="nv">origin</span>.<span class="nv">x</span><span class="p">)</span><span class="s">, </span>\<span class="p">(</span><span class="nv">square</span>.<span class="nv">origin</span>.<span class="nv">y</span><span class="p">)</span><span class="s">)"</span>)
</li><li><span class="c"><span class="enstr">// Prints "square.origin is now at (10.0, 10.0)"</span><!--end_enstr--><span class="jpstr">（「square.originは、現在(10.0, 10.0)です」を出力します））</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">This example defines three structures for working with geometric shapes:</span><!--end_enstr-->
<span class="jpstr">
この例は、幾何学形を扱うために３つの構造体を定義します：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li><span class="enstr"><code class="docutils literal notranslate"><span class="pre">Point</span></code> encapsulates the x- and y-coordinate of a point.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Point</span></code>は、ある地点のxおよひy座標をカプセル化します。
</span><!--end_jpstr-->
</li>
<li><span class="enstr"><code class="docutils literal notranslate"><span class="pre">Size</span></code> encapsulates a <code class="docutils literal notranslate"><span class="pre">width</span></code> and a <code class="docutils literal notranslate"><span class="pre">height</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Size</span></code>は、<code class="docutils literal notranslate"><span class="pre">width</span></code>と<code class="docutils literal notranslate"><span class="pre">height</span></code>をカプセル化します。
</span><!--end_jpstr-->
</li>
<li><span class="enstr"><code class="docutils literal notranslate"><span class="pre">Rect</span></code> defines a rectangle by an origin point and a size.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Rect</span></code>は、原点と大きさによって長方形を定義します。
</span><!--end_jpstr-->
</li>
</ul>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">Rect</span></code> structure also provides a computed property called <code class="docutils literal notranslate"><span class="pre">center</span></code>. The current center position of a <code class="docutils literal notranslate"><span class="pre">Rect</span></code> can always be determined from its <code class="docutils literal notranslate"><span class="pre">origin</span></code> and <code class="docutils literal notranslate"><span class="pre">size</span></code>, and so you don’t need to store the center point as an explicit <code class="docutils literal notranslate"><span class="pre">Point</span></code> value. Instead, <code class="docutils literal notranslate"><span class="pre">Rect</span></code> defines a custom getter and setter for a computed variable called <code class="docutils literal notranslate"><span class="pre">center</span></code>, to enable you to work with the rectangle’s <code class="docutils literal notranslate"><span class="pre">center</span></code> as if it were a real stored property.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Rect</span></code>構造体はまた、<code class="docutils literal notranslate"><span class="pre">center</span></code>（中心）と呼ばれる計算プロパティを提供します。<code class="docutils literal notranslate"><span class="pre">Rect</span></code>の現在の中心位置は常にその<code class="docutils literal notranslate"><span class="pre">origin</span></code>と<code class="docutils literal notranslate"><span class="pre">size</span></code>から決定されることができます、なのであなたは中心点をわざわざ<code class="docutils literal notranslate"><span class="pre">Point</span></code>値として格納する必要ばありません。その代わりに、<code class="docutils literal notranslate"><span class="pre">Rect</span></code>は、<code class="docutils literal notranslate"><span class="pre">center</span></code>と呼ばれる計算される変数のためにあつらえのゲッターとセッターを定義して、矩形の<code class="docutils literal notranslate"><span class="pre">center</span></code>をそれがまったく格納プロパティであるかのようにあなたが扱うことができるようにします。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The example above creates a new <code class="docutils literal notranslate"><span class="pre">Rect</span></code> variable called <code class="docutils literal notranslate"><span class="pre">square</span></code>. The <code class="docutils literal notranslate"><span class="pre">square</span></code> variable is initialized with an origin point of <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0)</span></code>, and a width and height of <code class="docutils literal notranslate"><span class="pre">10</span></code>. This square is represented by the blue square in the diagram below.</span><!--end_enstr-->
<span class="jpstr">
上の例は、<code class="docutils literal notranslate"><span class="pre">square</span></code>と呼ばれる新しい<code class="docutils literal notranslate"><span class="pre">Rect</span></code>変数をつくります。<code class="docutils literal notranslate"><span class="pre">square</span></code>変数は、<code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0)</span></code>の原点、そして<code class="docutils literal notranslate"><span class="pre">10</span></code>の幅と高さで初期化されます。この正方形は、下の図において青い正方形で表されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">square</span></code> variable’s <code class="docutils literal notranslate"><span class="pre">center</span></code> property is then accessed through dot syntax (<code class="docutils literal notranslate"><span class="pre">square.center</span></code>), which causes the getter for <code class="docutils literal notranslate"><span class="pre">center</span></code> to be called, to retrieve the current property value. Rather than returning an existing value, the getter actually calculates and returns a new <code class="docutils literal notranslate"><span class="pre">Point</span></code> to represent the center of the square. As can be seen above, the getter correctly returns a center point of <code class="docutils literal notranslate"><span class="pre">(5,</span> <span class="pre">5)</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">square</span></code>変数の<code class="docutils literal notranslate"><span class="pre">center</span></code>プロパティは、それからドット構文（<code class="docutils literal notranslate"><span class="pre">square.center</span></code>）を通してアクセスされます、それによって<code class="docutils literal notranslate"><span class="pre">center</span></code>のためのゲッターが呼び出されて、現在のプロパティ値を取り出すことになります。既存の値を返すのではなく、このゲッターは正方形の中心を表すために実際に計算して新しい<code class="docutils literal notranslate"><span class="pre">Point</span></code>を返します。上で見られるように、ゲッターは正しく中心点<code class="docutils literal notranslate"><span class="pre">(5,</span> <span class="pre">5)</span></code>を返します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">center</span></code> property is then set to a new value of <code class="docutils literal notranslate"><span class="pre">(15,</span> <span class="pre">15)</span></code>, which moves the square up and to the right, to the new position shown by the orange square in the diagram below. Setting the <code class="docutils literal notranslate"><span class="pre">center</span></code> property calls the setter for <code class="docutils literal notranslate"><span class="pre">center</span></code>, which modifies the <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> values of the stored <code class="docutils literal notranslate"><span class="pre">origin</span></code> property, and moves the square to its new position.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">center</span></code>プロパティは、それから新しい値<code class="docutils literal notranslate"><span class="pre">(15,</span> <span class="pre">15)</span></code>に設定されます、それは、正方形を上にそして右に、下記の図においてオレンジの正方形によって示される新しい位置へと動かします。<code class="docutils literal notranslate"><span class="pre">center</span></code>プロパティを設定することは、<code class="docutils literal notranslate"><span class="pre">center</span></code>のためのセッターを呼び出します、そしてそれは、格納された<code class="docutils literal notranslate"><span class="pre">origin</span></code>プロパティの<code class="docutils literal notranslate"><span class="pre">x</span></code>と<code class="docutils literal notranslate"><span class="pre">y</span></code>値を修正して、正方形をその新しい位置へと動かします。
</span><!--end_jpstr-->
</p>
<img alt="../_images/computedProperties_2x.png" class="align-center" src="../images/computedProperties_2x.png" style="width: 388px;" />
<div class="section" id="ID260">
<h3><span class="enstr">Shorthand Setter Declaration<a class="headerlink" href="#ID260" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
短縮形セッター宣言<a class="headerlink" href="#ID260" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p><span class="enstr">If a computed property’s setter doesn’t define a name for the new value to be set, a default name of <code class="docutils literal notranslate"><span class="pre">newValue</span></code> is used. Here’s an alternative version of the <code class="docutils literal notranslate"><span class="pre">Rect</span></code> structure that takes advantage of this shorthand notation:</span><!--end_enstr-->
<span class="jpstr">
計算プロパティのもつセッターがその設定される新しい値に名前を定義しないならば、<code class="docutils literal notranslate"><span class="pre">newValue</span></code>の省略時の値が使われます。ここに<code class="docutils literal notranslate"><span class="pre">Rect</span></code>構造体の代替のバージョンがあります、それはこの短縮形表記法を利用します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">AlternativeRect</span> {
</li><li>    <span class="k">var</span> <span class="nv">origin</span> = <span class="nv">Point</span>()
</li><li>    <span class="k">var</span> <span class="nv">size</span> = <span class="nv">Size</span>()
</li><li>    <span class="k">var</span> <span class="nv">center</span>: <span class="nc">Point</span> {
</li><li>        <span class="k">get</span> {
</li><li>            <span class="k">let</span> <span class="nv">centerX</span> = <span class="nv">origin</span>.<span class="nv">x</span> + (<span class="nv">size</span>.<span class="nv">width</span> / <span class="m">2</span>)
</li><li>            <span class="k">let</span> <span class="nv">centerY</span> = <span class="nv">origin</span>.<span class="nv">y</span> + (<span class="nv">size</span>.<span class="nv">height</span> / <span class="m">2</span>)
</li><li>            <span class="k">return</span> <span class="nv">Point</span>(<span class="nv">x</span>: <span class="nv">centerX</span>, <span class="nv">y</span>: <span class="nv">centerY</span>)
</li><li>        }
</li><li>        <span class="k">set</span> {
</li><li>            <span class="nv">origin</span>.<span class="nv">x</span> = <span class="nv">newValue</span>.<span class="nv">x</span> - (<span class="nv">size</span>.<span class="nv">width</span> / <span class="m">2</span>)
</li><li>            <span class="nv">origin</span>.<span class="nv">y</span> = <span class="nv">newValue</span>.<span class="nv">y</span> - (<span class="nv">size</span>.<span class="nv">height</span> / <span class="m">2</span>)
</li><li>        }
</li><li>    }
</li><li>}
</li></ol></div></div></div>
</div>
<div class="section" id="ID608">
<h3><span class="enstr">Shorthand Getter Declaration<a class="headerlink" href="#ID608" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
略記ゲッター宣言<a class="headerlink" href="#ID608" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p><span class="enstr">If the entire body of a getter is a single expression, the getter implicitly returns that expression. Here’s an another version of the <code class="docutils literal notranslate"><span class="pre">Rect</span></code> structure that takes advantage of this shorthand notation and the shorthand notation for setters:</span><!--end_enstr-->
<span class="jpstr">
ゲッターの全本文が単一の式ならば、ゲッターは暗黙的にその式を返します。ここに<code class="docutils literal notranslate"><span class="pre">Rect</span></code>構造体の別のバージョンがあります、それはこの省略形表記法とセッターに対する省略形表記法を利用します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">CompactRect</span> {
</li><li>    <span class="k">var</span> <span class="nv">origin</span> = <span class="nv">Point</span>()
</li><li>    <span class="k">var</span> <span class="nv">size</span> = <span class="nv">Size</span>()
</li><li>    <span class="k">var</span> <span class="nv">center</span>: <span class="nc">Point</span> {
</li><li>        <span class="k">get</span> {
</li><li>            <span class="nv">Point</span>(<span class="nv">x</span>: <span class="nv">origin</span>.<span class="nv">x</span> + (<span class="nv">size</span>.<span class="nv">width</span> / <span class="m">2</span>),
</li><li>                  <span class="nv">y</span>: <span class="nv">origin</span>.<span class="nv">y</span> + (<span class="nv">size</span>.<span class="nv">height</span> / <span class="m">2</span>))
</li><li>        }
</li><li>        <span class="k">set</span> {
</li><li>            <span class="nv">origin</span>.<span class="nv">x</span> = <span class="nv">newValue</span>.<span class="nv">x</span> - (<span class="nv">size</span>.<span class="nv">width</span> / <span class="m">2</span>)
</li><li>            <span class="nv">origin</span>.<span class="nv">y</span> = <span class="nv">newValue</span>.<span class="nv">y</span> - (<span class="nv">size</span>.<span class="nv">height</span> / <span class="m">2</span>)
</li><li>        }
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">Omitting the <code class="docutils literal notranslate"><span class="pre">return</span></code> from a getter follows the same rules as omitting <code class="docutils literal notranslate"><span class="pre">return</span></code> from a function, as described in <a class="reference internal" href="Functions.html#ID607"><span class="std std-ref">Functions With an Implicit Return</span></a>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">return</span></code>をゲッターから省くことは、<code class="docutils literal notranslate"><span class="pre">return</span></code>を関数から省くのと同じ規則に従います、<a class="reference internal" href="Functions.html#ID607"><span class="std std-ref">暗黙的なreturnをもつ関数</span></a>で記述されるように。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID261">
<h3><span class="enstr">Read-Only Computed Properties<a class="headerlink" href="#ID261" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
読み出し専用の計算プロパティ<a class="headerlink" href="#ID261" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p><span class="enstr">A computed property with a getter but no setter is known as a <em>read-only computed property</em>. A read-only computed property always returns a value, and can be accessed through dot syntax, but can’t be set to a different value.</span><!--end_enstr-->
<span class="jpstr">
ゲッターを持つ、しかしセッターはない計算プロパティは、<em>読み出し専用の計算プロパティ</em>として知られています。読み出し専用の計算プロパティは常にある値を返します、そしてドット構文を通してアクセスされることができますが、異なる値に設定されることができません。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">You must declare computed properties—including read-only computed properties—as variable properties with the <code class="docutils literal notranslate"><span class="pre">var</span></code> keyword, because their value isn’t fixed. The <code class="docutils literal notranslate"><span class="pre">let</span></code> keyword is only used for constant properties, to indicate that their values can’t be changed once they’re set as part of instance initialization.</span><!--end_enstr-->
<span class="jpstr">
あなたは、計算プロパティ ― 読み出し専用の計算プロパティを含む ― を<code class="docutils literal notranslate"><span class="pre">var</span></code>キーワードをつかって変数プロパティとして宣言しなければなりません、なぜならそれらの値は固定されないからです。<code class="docutils literal notranslate"><span class="pre">let</span></code>キーワードは定数プロパティのためにだけ使われます、そして一旦それがインスタンス初期化の一部として設定されるならば、その値が変わることができないことを示します。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">You can simplify the declaration of a read-only computed property by removing the <code class="docutils literal notranslate"><span class="pre">get</span></code> keyword and its braces:</span><!--end_enstr-->
<span class="jpstr">
あなたは、読み出し専用の計算プロパティの宣言を<code class="docutils literal notranslate"><span class="pre">get</span></code>キーワードとそれの波括弧を取り除くことによって単純化することができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Cuboid</span> {
</li><li>    <span class="k">var</span> <span class="nv">width</span> = <span class="m">0.0</span>, <span class="nv">height</span> = <span class="m">0.0</span>, <span class="nv">depth</span> = <span class="m">0.0</span>
</li><li>    <span class="k">var</span> <span class="nv">volume</span>: <span class="nc">Double</span> {
</li><li>        <span class="k">return</span> <span class="nv">width</span> * <span class="nv">height</span> * <span class="nv">depth</span>
</li><li>    }
</li><li>}
</li><li><span class="k">let</span> <span class="nv">fourByFiveByTwo</span> = <span class="nv">Cuboid</span>(<span class="nv">width</span>: <span class="m">4.0</span>, <span class="nv">height</span>: <span class="m">5.0</span>, <span class="nv">depth</span>: <span class="m">2.0</span>)
</li><li><span class="nv">print</span>(<span class="s">"the volume of fourByFiveByTwo is </span>\<span class="p">(</span><span class="nv">fourByFiveByTwo</span>.<span class="nv">volume</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c"><span class="enstr">// Prints "the volume of fourByFiveByTwo is 40.0"</span><!--end_enstr--><span class="jpstr">（「fourByFiveByTwoのボリュームは、40.0です」を出力します）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">This example defines a new structure called <code class="docutils literal notranslate"><span class="pre">Cuboid</span></code>, which represents a 3D rectangular box with <code class="docutils literal notranslate"><span class="pre">width</span></code>, <code class="docutils literal notranslate"><span class="pre">height</span></code>, and <code class="docutils literal notranslate"><span class="pre">depth</span></code> properties. This structure also has a read-only computed property called <code class="docutils literal notranslate"><span class="pre">volume</span></code>, which calculates and returns the current volume of the cuboid. It doesn’t make sense for <code class="docutils literal notranslate"><span class="pre">volume</span></code> to be settable, because it would be ambiguous as to which values of <code class="docutils literal notranslate"><span class="pre">width</span></code>, <code class="docutils literal notranslate"><span class="pre">height</span></code>, and <code class="docutils literal notranslate"><span class="pre">depth</span></code> should be used for a particular <code class="docutils literal notranslate"><span class="pre">volume</span></code> value. Nonetheless, it’s useful for a <code class="docutils literal notranslate"><span class="pre">Cuboid</span></code> to provide a read-only computed property to enable external users to discover its current calculated volume.</span><!--end_enstr-->
<span class="jpstr">
この例は<code class="docutils literal notranslate"><span class="pre">Cuboid</span></code>と呼ばれる新しい構造体を定義します、それは、<code class="docutils literal notranslate"><span class="pre">width</span></code>、<code class="docutils literal notranslate"><span class="pre">height</span></code>、そして<code class="docutils literal notranslate"><span class="pre">depth</span></code>プロパティで3D矩形の箱を表します。この構造体はまた、<code class="docutils literal notranslate"><span class="pre">volume</span></code>と呼ばれる読み出し専用の計算プロパティを持ちます、それは、現在の立方体の体積を計算して、返します。<code class="docutils literal notranslate"><span class="pre">volume</span></code>が設定可能であることは意味をなしません、なぜなら特定の<code class="docutils literal notranslate"><span class="pre">volume</span></code>値に対して<code class="docutils literal notranslate"><span class="pre">width</span></code>、<code class="docutils literal notranslate"><span class="pre">height</span></code>、そして<code class="docutils literal notranslate"><span class="pre">depth</span></code>にどの値が使われなければならないかはあいまいだからです。それでもなお、<code class="docutils literal notranslate"><span class="pre">Cuboid</span></code>が外部のユーザーにその現在の計算された体積を見つけられるように読み出し専用の計算プロパティを提供することは、役に立ちます。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID262">
<h2><span class="enstr">Property Observers<a class="headerlink" href="#ID262" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
プロパティオブザーバー<a class="headerlink" href="#ID262" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">Property observers observe and respond to changes in a property’s value. Property observers are called every time a property’s value is set, even if the new value is the same as the property’s current value.</span><!--end_enstr-->
<span class="jpstr">
プロパティオブザーバーは、あるプロパティの値の変化を観察して、応答します。プロパティオブザーバーは、あるプロパティの値が設定されるたびに、たとえ新しい値がそのプロパティの現在の値と同じものであるとしても、呼ばれます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can add property observers in the following places:</span><!--end_enstr-->
<span class="jpstr">
あなたは、プロパティオブザーバを以下の場所に追加できます：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li><span class="enstr">Stored properties that you define</span><!--end_enstr-->
<span class="jpstr">
あなたが定義する格納プロパティ
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Stored properties that you inherit</span><!--end_enstr-->
<span class="jpstr">
あなたが継承する格納プロパティ
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Computed properties that you inherit</span><!--end_enstr-->
<span class="jpstr">
あなたが継承する計算プロパティ
</span><!--end_jpstr-->
</li>
</ul>
<p><span class="enstr">For an inherited property, you add a property observer by overriding that property in a subclass. For a computed property that you define, use the property’s setter to observe and respond to value changes, instead of trying to create an observer. Overriding properties is described in <a class="reference internal" href="Inheritance.html#ID196"><span class="std std-ref">Overriding</span></a>.</span><!--end_enstr-->
<span class="jpstr">
継承されたプロパティに対して、あなたはプロパティオブザーバを、そのプロパティをサブクラスの中でオーバーライドすることによって追加します。あなたが定義する計算プロパティに対して、プロパティのもつセッターを使うことで値の変化を監視および応答してください、オブザーバを作成しようとするのではなく。プロパティのオーバーライドは、<a class="reference internal" href="Inheritance.html#ID196"><span class="std std-ref">オーバーライド</span></a>において記述されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You have the option to define either or both of these observers on a property:</span><!--end_enstr-->
<span class="jpstr">
あなたは、あるプロパティに関してこれらのオブザーバーのどちらかまたは両方とも定義する選択肢を持ちます：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li><span class="enstr"><code class="docutils literal notranslate"><span class="pre">willSet</span></code> is called just before the value is stored.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">willSet</span></code>は、値が格納される直前に呼ばれます。
</span><!--end_jpstr-->
</li>
<li><span class="enstr"><code class="docutils literal notranslate"><span class="pre">didSet</span></code> is called immediately after the new value is stored.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">didSet</span></code>は、新しい値が格納された直後に呼ばれます。
</span><!--end_jpstr-->
</li>
</ul>
<p><span class="enstr">If you implement a <code class="docutils literal notranslate"><span class="pre">willSet</span></code> observer, it’s passed the new property value as a constant parameter. You can specify a name for this parameter as part of your <code class="docutils literal notranslate"><span class="pre">willSet</span></code> implementation. If you don’t write the parameter name and parentheses within your implementation, the parameter is made available with a default parameter name of <code class="docutils literal notranslate"><span class="pre">newValue</span></code>.</span><!--end_enstr-->
<span class="jpstr">
あなたが<code class="docutils literal notranslate"><span class="pre">willSet</span></code>オブザーバーを実装するならば、それは新しいプロパティ値を定数パラメータとして渡されます。あなたは、あなたの<code class="docutils literal notranslate"><span class="pre">willSet</span></code>実装の一部としてこのパラメータに名前を指定することができます。あなたがパラメータ名と丸括弧をあなたの実装内で書かないならば、パラメータは省略時のパラメータ名の<code class="docutils literal notranslate"><span class="pre">newValue</span></code>を使って利用可能にされます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Similarly, if you implement a <code class="docutils literal notranslate"><span class="pre">didSet</span></code> observer, it’s passed a constant parameter containing the old property value. You can name the parameter or use the default parameter name of <code class="docutils literal notranslate"><span class="pre">oldValue</span></code>. If you assign a value to a property within its own <code class="docutils literal notranslate"><span class="pre">didSet</span></code> observer, the new value that you assign replaces the one that was just set.</span><!--end_enstr-->
<span class="jpstr">
同じように、あなたが<code class="docutils literal notranslate"><span class="pre">didSet</span></code>オブザーバーを実装するならば、それは古いプロパティ値を含んでいる定数パラメータを渡されます。あなたはパラメータに名をつけること、または省略時のパラメータ名の<code class="docutils literal notranslate"><span class="pre">oldValue</span></code>を使うことが出来ます。あなたが独自の<code class="docutils literal notranslate"><span class="pre">didSet</span></code>オブザーバーの内部で値をプロパティに代入するならば、あなたが代入する新しい値はついさっき設定されたものを置き換えます。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">willSet</span></code> and <code class="docutils literal notranslate"><span class="pre">didSet</span></code> observers of superclass properties are called when a property is set in a subclass initializer, after the superclass initializer has been called. They aren’t called while a class is setting its own properties, before the superclass initializer has been called.</span><!--end_enstr-->
<span class="jpstr">
スーパークラスプロパティの<code class="docutils literal notranslate"><span class="pre">willSet</span></code>と<code class="docutils literal notranslate"><span class="pre">didSet</span></code>オブザーバーは、スーパークラスイニシャライザが呼び出され終わった後、あるプロパティがサプクラスのイニシャライザにおいて設定される時に呼び出されます。それらは、スーパークラスイニシャライザが呼び出され終わる前、あるクラスがそれ自身のプロパティを設定している間には呼び出されません。
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">For more information about initializer delegation, see <a class="reference internal" href="Initialization.html#ID215"><span class="std std-ref">Initializer Delegation for Value Types</span></a> and <a class="reference internal" href="Initialization.html#ID219"><span class="std std-ref">Initializer Delegation for Class Types</span></a>.</span><!--end_enstr-->
<span class="jpstr">
イニシャライザ委任についての更なる情報として、<a class="reference internal" href="Initialization.html#ID215"><span class="std std-ref">値型のためのイニシャライザ委任</span></a>と<a class="reference internal" href="Initialization.html#ID219"><span class="std std-ref">クラス型のためのイニシャライザ委任</span></a>を見てください。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">Here’s an example of <code class="docutils literal notranslate"><span class="pre">willSet</span></code> and <code class="docutils literal notranslate"><span class="pre">didSet</span></code> in action. The example below defines a new class called <code class="docutils literal notranslate"><span class="pre">StepCounter</span></code>, which tracks the total number of steps that a person takes while walking. This class might be used with input data from a pedometer or other step counter to keep track of a person’s exercise during their daily routine.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">willSet</span></code>と<code class="docutils literal notranslate"><span class="pre">didSet</span></code>の作動する例が、ここにあります。下の例は、<code class="docutils literal notranslate"><span class="pre">StepCounter</span></code>と呼ばれる新しいクラスを定義します、それは、ある人が歩いている間にとる総歩数を追跡します。このクラスは、万歩計または他の歩数計からの入力データとともに、ある個人の日課の運動の経過を追うために使われるかもしれません。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">StepCounter</span> {
</li><li>    <span class="k">var</span> <span class="nv">totalSteps</span>: <span class="nc">Int</span> = <span class="m">0</span> {
</li><li>        <span class="k">willSet</span>(<span class="nv">newTotalSteps</span>) {
</li><li>            <span class="nv">print</span>(<span class="s">"About to set totalSteps to </span>\<span class="p">(</span><span class="nv">newTotalSteps</span><span class="p">)</span><span class="s">"</span>)
</li><li>        }
</li><li>        <span class="k">didSet</span> {
</li><li>            <span class="k">if</span> <span class="nv">totalSteps</span> &gt; <span class="nv">oldValue</span>  {
</li><li>                <span class="nv">print</span>(<span class="s">"Added </span>\<span class="p">(</span><span class="nv">totalSteps</span> - <span class="nv">oldValue</span><span class="p">)</span><span class="s"> steps"</span>)
</li><li>            }
</li><li>        }
</li><li>    }
</li><li>}
</li><li><span class="k">let</span> <span class="nv">stepCounter</span> = <span class="nv">StepCounter</span>()
</li><li><span class="nv">stepCounter</span>.<span class="nv">totalSteps</span> = <span class="m">200</span>
</li><li><span class="c"><span class="enstr">// About to set totalSteps to 200</span><!--end_enstr--><span class="jpstr">（totalStepsを200に設定している）</span><!--end_jpstr--></span>
</li><li><span class="c"><span class="enstr">// Added 200 steps</span><!--end_enstr--><span class="jpstr">（200の歩数が加えられた）</span><!--end_jpstr--></span>
</li><li><span class="nv">stepCounter</span>.<span class="nv">totalSteps</span> = <span class="m">360</span>
</li><li><span class="c"><span class="enstr">// About to set totalSteps to 360</span><!--end_enstr--><span class="jpstr">（totalStepsを360に設定している）</span><!--end_jpstr--></span>
</li><li><span class="c"><span class="enstr">// Added 160 steps</span><!--end_enstr--><span class="jpstr">（160の歩数が加えられた）</span><!--end_jpstr--></span>
</li><li><span class="nv">stepCounter</span>.<span class="nv">totalSteps</span> = <span class="m">896</span>
</li><li><span class="c"><span class="enstr">// About to set totalSteps to 896</span><!--end_enstr--><span class="jpstr">（totalStepsを896に設定している）</span><!--end_jpstr--></span>
</li><li><span class="c"><span class="enstr">// Added 536 steps</span><!--end_enstr--><span class="jpstr">（536の歩数が加えられた）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">StepCounter</span></code> class declares a <code class="docutils literal notranslate"><span class="pre">totalSteps</span></code> property of type <code class="docutils literal notranslate"><span class="pre">Int</span></code>. This is a stored property with <code class="docutils literal notranslate"><span class="pre">willSet</span></code> and <code class="docutils literal notranslate"><span class="pre">didSet</span></code> observers.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">StepCounter</span></code>クラスは、型<code class="docutils literal notranslate"><span class="pre">Int</span></code>の<code class="docutils literal notranslate"><span class="pre">totalSteps</span></code>プロパティを宣言します。これは、<code class="docutils literal notranslate"><span class="pre">willSet</span></code>と<code class="docutils literal notranslate"><span class="pre">didSet</span></code>オブザーバーを持つ格納プロパティです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">willSet</span></code> and <code class="docutils literal notranslate"><span class="pre">didSet</span></code> observers for <code class="docutils literal notranslate"><span class="pre">totalSteps</span></code> are called whenever the property is assigned a new value. This is true even if the new value is the same as the current value.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">totalSteps</span></code>のための<code class="docutils literal notranslate"><span class="pre">willSet</span></code>と<code class="docutils literal notranslate"><span class="pre">didSet</span></code>オブザーバーは、プロパティが新しい値を代入されるときはいつでも呼ばれます。これは、たとえ新しい値が現在の値と同じものであるとしても当てはまります。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">This example’s <code class="docutils literal notranslate"><span class="pre">willSet</span></code> observer uses a custom parameter name of <code class="docutils literal notranslate"><span class="pre">newTotalSteps</span></code> for the upcoming new value. In this example, it simply prints out the value that’s about to be set.</span><!--end_enstr-->
<span class="jpstr">
この例の<code class="docutils literal notranslate"><span class="pre">willSet</span></code>オブザーバーは、来るべき新しい値のためにあつらえのパラメータ名<code class="docutils literal notranslate"><span class="pre">newTotalSteps</span></code>を使用します。この例では、それは単に設定されようとしている値を出力します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">didSet</span></code> observer is called after the value of <code class="docutils literal notranslate"><span class="pre">totalSteps</span></code> is updated. It compares the new value of <code class="docutils literal notranslate"><span class="pre">totalSteps</span></code> against the old value. If the total number of steps has increased, a message is printed to indicate how many new steps have been taken. The <code class="docutils literal notranslate"><span class="pre">didSet</span></code> observer doesn’t provide a custom parameter name for the old value, and the default name of <code class="docutils literal notranslate"><span class="pre">oldValue</span></code> is used instead.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">didSet</span></code>オブザーバーは、<code class="docutils literal notranslate"><span class="pre">totalSteps</span></code>の値が更新された後に呼ばれます。それは、<code class="docutils literal notranslate"><span class="pre">totalSteps</span></code>の新しい値をその古い値と比較します。総歩数が増加したならば、どれくらいの新たな歩数がとられたかについて示すためにメッセージが出力されます。<code class="docutils literal notranslate"><span class="pre">didSet</span></code>オブザーバーはあつらえのパラメータ名を古い値のために用意しません、そして省略時の名前の<code class="docutils literal notranslate"><span class="pre">oldValue</span></code>がその代わりに使われます。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">If you pass a property that has observers to a function as an in-out parameter, the <code class="docutils literal notranslate"><span class="pre">willSet</span></code> and <code class="docutils literal notranslate"><span class="pre">didSet</span></code> observers are always called. This is because of the copy-in copy-out memory model for in-out parameters: The value is always written back to the property at the end of the function. For a detailed discussion of the behavior of in-out parameters, see <a class="reference internal" href="../ReferenceManual/Declarations.html#ID545"><span class="std std-ref">In-Out Parameters</span></a>.</span><!--end_enstr-->
<span class="jpstr">
あなたがオブザーバーを持つプロパティをある関数へin-outパラメータとして渡すならば、<code class="docutils literal notranslate"><span class="pre">willSet</span></code>と<code class="docutils literal notranslate"><span class="pre">didSet</span></code>オブザーバーは常に呼び出されます。これは、in-outパラメータのための「コピーイン、コピーアウト」メモリーモデルが理由です：値は常に、その関数の終わりでプロパティへと書き込まれて戻されます。in-outパラメータの振る舞いの詳細な議論のために、<a class="reference internal" href="../ReferenceManual/Declarations.html#ID545"><span class="std std-ref">in-outパラメータ</span></a>を見てください。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID617">
<h2><span class="enstr">Property Wrappers<a class="headerlink" href="#ID617" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
プロパティラッパー<a class="headerlink" href="#ID617" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">A property wrapper adds a layer of separation between code that manages how a property is stored and the code that defines a property. For example, if you have properties that provide thread-safety checks or store their underlying data in a database, you have to write that code on every property. When you use a property wrapper, you write the management code once when you define the wrapper, and then reuse that management code by applying it to multiple properties.</span><!--end_enstr-->
<span class="jpstr">
プロパティラッパーは、プロパティが格納される方法を管理するコードとプロパティを定義するコードとの間に分離のレイヤー（層）を加えます。例えば、あなたがスレッド安全検査を提供するまたはそれらの基礎をなすデータをデータベースに格納するプロパティそれらを持つならば、あなたはそのコードをあらゆるプロパティ上で書かなければなりません。あなたがプロパティラッパーを使う場合、あなたは管理コードを一度だけあなたがラッパーを定義する時に書きます、そしてそれからその管理コードを、それを複数のプロパティに適用することによって再利用します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">To define a property wrapper, you make a structure, enumeration, or class that defines a <code class="docutils literal notranslate"><span class="pre">wrappedValue</span></code> property. In the code below, the <code class="docutils literal notranslate"><span class="pre">TwelveOrLess</span></code> structure ensures that the value it wraps always contains a number less than or equal to 12. If you ask it to store a larger number, it stores 12 instead.</span><!--end_enstr-->
<span class="jpstr">
プロパティラッパーを定義するには、あなたはある<code class="docutils literal notranslate"><span class="pre">wrappedValue</span></code>プロパティを定義する構造体、列挙、またはクラスを作ります。下のコードにおいて、<code class="docutils literal notranslate"><span class="pre">TwelveOrLess</span></code>構造体は、それがラップする値が常に12より少ないか等しいある数を含むことを保証します。あなたがそれにより大きな数を格納するように頼むならば、それは代わりに12を格納します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>@<span class="nv">propertyWrapper</span>
</li><li><span class="k">struct</span> <span class="nv">TwelveOrLess</span> {
</li><li>    <span class="k">private</span> <span class="k">var</span> <span class="nv">number</span> = <span class="m">0</span>
</li><li>    <span class="k">var</span> <span class="nv">wrappedValue</span>: <span class="nc">Int</span> {
</li><li>        <span class="k">get</span> { <span class="k">return</span> <span class="nv">number</span> }
</li><li>        <span class="k">set</span> { <span class="nv">number</span> = <span class="nv">min</span>(<span class="nv">newValue</span>, <span class="m">12</span>) }
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">The setter ensures that new values are less than 12, and the getter returns the stored value.</span><!--end_enstr-->
<span class="jpstr">
セッターは、新しい値が12より少ないことを保証します、そしてゲッターは格納された値を返します。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">The declaration for <code class="docutils literal notranslate"><span class="pre">number</span></code> in the example above marks the variable as <code class="docutils literal notranslate"><span class="pre">private</span></code>, which ensures <code class="docutils literal notranslate"><span class="pre">number</span></code> is used only in the implementation of <code class="docutils literal notranslate"><span class="pre">TwelveOrLess</span></code>. Code that’s written anywhere else accesses the value using the getter and setter for <code class="docutils literal notranslate"><span class="pre">wrappedValue</span></code>, and can’t use <code class="docutils literal notranslate"><span class="pre">number</span></code> directly. For information about <code class="docutils literal notranslate"><span class="pre">private</span></code>, see <a class="reference internal" href="AccessControl.html"><span class="doc">Access Control</span></a>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">number</span></code>に対する宣言は上の例において、変数を<code class="docutils literal notranslate"><span class="pre">private</span></code>として印します、それは<code class="docutils literal notranslate"><span class="pre">number</span></code>が<code class="docutils literal notranslate"><span class="pre">TwelveOrLess</span></code>の実装においてのみ使われることを保証します。どこか他で書かれるコードは、<code class="docutils literal notranslate"><span class="pre">wrappedValue</span></code>に対するゲッターとセッターを使って値にアクセスします、そして<code class="docutils literal notranslate"><span class="pre">number</span></code>を直接に使用できません。<code class="docutils literal notranslate"><span class="pre">private</span></code>に対する情報として、<a class="reference internal" href="AccessControl.html"><span class="doc">アクセス制御</span></a>を見てください。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">You apply a wrapper to a property by writing the wrapper’s name before the property as an attribute. Here’s a structure that stores a rectangle that uses the <code class="docutils literal notranslate"><span class="pre">TwelveOrLess</span></code> property wrapper to ensure its dimensions are always 12 or less:</span><!--end_enstr-->
<span class="jpstr">
あなたは、ラッパーのもつ名前をそのプロパティの前に属性として書くことによって、ラッパーをプロパティに適用します。ここにある構造体があります、それはある矩形を格納します、それは<code class="docutils literal notranslate"><span class="pre">TwelveOrLess</span></code>プロパティラッパーを使うことでそれの寸法を常に12かそれ以下にします：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">SmallRectangle</span> {
</li><li>    @<span class="nv">TwelveOrLess</span> <span class="k">var</span> <span class="nv">height</span>: <span class="nc">Int</span>
</li><li>    @<span class="nv">TwelveOrLess</span> <span class="k">var</span> <span class="nv">width</span>: <span class="nc">Int</span>
</li><li>}
</li><li>
</li><li><span class="k">var</span> <span class="nv">rectangle</span> = <span class="nv">SmallRectangle</span>()
</li><li><span class="nv">print</span>(<span class="nv">rectangle</span>.<span class="nv">height</span>)
</li><li><span class="c"><span class="enstr">// Prints "0"</span><!--end_enstr--><span class="jpstr">（「0」を出力します）</span><!--end_jpstr--></span>
</li><li>
</li><li><span class="nv">rectangle</span>.<span class="nv">height</span> = <span class="m">10</span>
</li><li><span class="nv">print</span>(<span class="nv">rectangle</span>.<span class="nv">height</span>)
</li><li><span class="c"><span class="enstr">// Prints "10"</span><!--end_enstr--><span class="jpstr">（「10」を出力します）</span><!--end_jpstr--></span>
</li><li>
</li><li><span class="nv">rectangle</span>.<span class="nv">height</span> = <span class="m">24</span>
</li><li><span class="nv">print</span>(<span class="nv">rectangle</span>.<span class="nv">height</span>)
</li><li><span class="c"><span class="enstr">// Prints "12"</span><!--end_enstr--><span class="jpstr">（「12」を出力します）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">height</span></code> and <code class="docutils literal notranslate"><span class="pre">width</span></code> properties get their initial values from the definition of <code class="docutils literal notranslate"><span class="pre">TwelveOrLess</span></code>, which sets <code class="docutils literal notranslate"><span class="pre">TwelveOrLess.number</span></code> to zero. The setter in <code class="docutils literal notranslate"><span class="pre">TwelveOrLess</span></code> treats 10 as a valid value so storing the number 10 in <code class="docutils literal notranslate"><span class="pre">rectangle.height</span></code> proceeds as written. However, 24 is larger than <code class="docutils literal notranslate"><span class="pre">TwelveOrLess</span></code> allows, so trying to store 24 end up setting <code class="docutils literal notranslate"><span class="pre">rectangle.height</span></code> to 12 instead, the largest allowed value.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">height</span></code>と<code class="docutils literal notranslate"><span class="pre">width</span></code>プロパティは、それらの初期値を<code class="docutils literal notranslate"><span class="pre">TwelveOrLess</span></code>の定義から取得します、それは<code class="docutils literal notranslate"><span class="pre">TwelveOrLess.number</span></code>をゼロに設定します。<code class="docutils literal notranslate"><span class="pre">TwelveOrLess</span></code>の中のセッターは、10を有効な値として扱うので、数10を<code class="docutils literal notranslate"><span class="pre">rectangle.height</span></code>の中に格納することは、書き出されたとおりに起こります。しかしながら、24は<code class="docutils literal notranslate"><span class="pre">TwelveOrLess</span></code>が許可するより大きいので、24を格納する試みは、<code class="docutils literal notranslate"><span class="pre">rectangle.height</span></code>を代わりに12、最も大きな許可される値へと設定することに結局なります。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">When you apply a wrapper to a property, the compiler synthesizes code that provides storage for the wrapper and code that provides access to the property through the wrapper. (The property wrapper is responsible for storing the wrapped value, so there’s no synthesized code for that.) You could write code that uses the behavior of a property wrapper, without taking advantage of the special attribute syntax. For example, here’s a version of <code class="docutils literal notranslate"><span class="pre">SmallRectangle</span></code> from the previous code listing that wraps its properties in the <code class="docutils literal notranslate"><span class="pre">TwelveOrLess</span></code> structure explicitly, instead of writing <code class="docutils literal notranslate"><span class="pre">@TwelveOrLess</span></code> as an attribute:</span><!--end_enstr-->
<span class="jpstr">
あなたがあるラッパーをプロパティに適用する場合、コンパイラは、そのラッパーに対するストレージを提供するコードそしてそのラッパーに通してプロパティへのアクセスを提供するコードを合成します。（プロパティラッパーは、ラップ値を格納することに責任があります、それでそれに対する合成コードはありません。）あなたはプロパティラッパーの挙動を使うコードを、この特別な属性構文を利用することなく記述できます。例えば、ここに前のコード出力からの<code class="docutils literal notranslate"><span class="pre">SmallRectangle</span></code>の変形版があります、それはそれのプロパティを<code class="docutils literal notranslate"><span class="pre">TwelveOrLess</span></code>構造体の中に明示的にラップします、<code class="docutils literal notranslate"><span class="pre">@TwelveOrLess</span></code>を属性として書く代わりに。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">SmallRectangle</span> {
</li><li>    <span class="k">private</span> <span class="k">var</span> <span class="nv">_height</span> = <span class="nv">TwelveOrLess</span>()
</li><li>    <span class="k">private</span> <span class="k">var</span> <span class="nv">_width</span> = <span class="nv">TwelveOrLess</span>()
</li><li>    <span class="k">var</span> <span class="nv">height</span>: <span class="nc">Int</span> {
</li><li>        <span class="k">get</span> { <span class="k">return</span> <span class="nv">_height</span>.<span class="nv">wrappedValue</span> }
</li><li>        <span class="k">set</span> { <span class="nv">_height</span>.<span class="nv">wrappedValue</span> = <span class="nv">newValue</span> }
</li><li>    }
</li><li>    <span class="k">var</span> <span class="nv">width</span>: <span class="nc">Int</span> {
</li><li>        <span class="k">get</span> { <span class="k">return</span> <span class="nv">_width</span>.<span class="nv">wrappedValue</span> }
</li><li>        <span class="k">set</span> { <span class="nv">_width</span>.<span class="nv">wrappedValue</span> = <span class="nv">newValue</span> }
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">_height</span></code> and <code class="docutils literal notranslate"><span class="pre">_width</span></code> properties store an instance of the property wrapper, <code class="docutils literal notranslate"><span class="pre">TwelveOrLess</span></code>. The getter and setter for <code class="docutils literal notranslate"><span class="pre">height</span></code> and <code class="docutils literal notranslate"><span class="pre">width</span></code> wrap access to the <code class="docutils literal notranslate"><span class="pre">wrappedValue</span></code> property.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">_height</span></code>と<code class="docutils literal notranslate"><span class="pre">_width</span></code>プロパティは、プロパティラッパー、<code class="docutils literal notranslate"><span class="pre">TwelveOrLess</span></code>のインスタンスを格納します。<code class="docutils literal notranslate"><span class="pre">height</span></code>と<code class="docutils literal notranslate"><span class="pre">width</span></code>に対するゲッターとセッターは、<code class="docutils literal notranslate"><span class="pre">wrappedValue</span></code>プロパティへのアクセスをラップします。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID618">
<h3><span class="enstr">Setting Initial Values for Wrapped Properties<a class="headerlink" href="#ID618" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
ラップされたプロパティに初期値を設定する<a class="headerlink" href="#ID618" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p><span class="enstr">The code in the examples above sets the initial value for the wrapped property by giving <code class="docutils literal notranslate"><span class="pre">number</span></code> an initial value in the definition of <code class="docutils literal notranslate"><span class="pre">TwelveOrLess</span></code>. Code that uses this property wrapper, can’t specify a different initial value for a property that’s wrapped by <code class="docutils literal notranslate"><span class="pre">TwelveOrLess</span></code>—for example, the definition of <code class="docutils literal notranslate"><span class="pre">SmallRectangle</span></code> can’t give <code class="docutils literal notranslate"><span class="pre">height</span></code> or <code class="docutils literal notranslate"><span class="pre">width</span></code> initial values. To support setting an initial value or other customization, the property wrapper needs to add an initializer. Here’s an expanded version of <code class="docutils literal notranslate"><span class="pre">TwelveOrLess</span></code> called <code class="docutils literal notranslate"><span class="pre">SmallNumber</span></code> that defines initializers that set the wrapped and maximum value:</span><!--end_enstr-->
<span class="jpstr">
上の例におけるコードは、ラップされたプロパティに初期値を設定することを、<code class="docutils literal notranslate"><span class="pre">number</span></code>を初期値に与えることによって、<code class="docutils literal notranslate"><span class="pre">TwelveOrLess</span></code>の定義の中で、行います。このプロパティラッパーを使うコードは、<code class="docutils literal notranslate"><span class="pre">TwelveOrLess</span></code>によってラップされるプロパティに対して異なる初期値を指定できません — 例えば、<code class="docutils literal notranslate"><span class="pre">SmallRectangle</span></code>に対する定義は<code class="docutils literal notranslate"><span class="pre">height</span></code>や<code class="docutils literal notranslate"><span class="pre">width</span></code>に初期値を与えることができません。初期値の設定または他のカスタマイゼーションをサポートするには、プロパティラッパーはイニシャライザの追加を必要とします。ここにある拡張されたバージョンの<code class="docutils literal notranslate"><span class="pre">TwelveOrLess</span></code>、<code class="docutils literal notranslate"><span class="pre">SmallNumber</span></code>と呼ばれるものがあります、それはラップされたそして最大限の値を設定するイニシャライザそれらを定義します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>@<span class="nv">propertyWrapper</span>
</li><li><span class="k">struct</span> <span class="nv">SmallNumber</span> {
</li><li>    <span class="k">private</span> <span class="k">var</span> <span class="nv">maximum</span>: <span class="nc">Int</span>
</li><li>    <span class="k">private</span> <span class="k">var</span> <span class="nv">number</span>: <span class="nc">Int</span>
</li><li>
</li><li>    <span class="k">var</span> <span class="nv">wrappedValue</span>: <span class="nc">Int</span> {
</li><li>        <span class="k">get</span> { <span class="k">return</span> <span class="nv">number</span> }
</li><li>        <span class="k">set</span> { <span class="nv">number</span> = <span class="nv">min</span>(<span class="nv">newValue</span>, <span class="nv">maximum</span>) }
</li><li>    }
</li><li>
</li><li>    <span class="k">init</span>() {
</li><li>        <span class="nv">maximum</span> = <span class="m">12</span>
</li><li>        <span class="nv">number</span> = <span class="m">0</span>
</li><li>    }
</li><li>    <span class="k">init</span>(<span class="nv">wrappedValue</span>: <span class="nc">Int</span>) {
</li><li>        <span class="nv">maximum</span> = <span class="m">12</span>
</li><li>        <span class="nv">number</span> = <span class="nv">min</span>(<span class="nv">wrappedValue</span>, <span class="nv">maximum</span>)
</li><li>    }
</li><li>    <span class="k">init</span>(<span class="nv">wrappedValue</span>: <span class="nc">Int</span>, <span class="nv">maximum</span>: <span class="nc">Int</span>) {
</li><li>        <span class="k">self</span>.<span class="nv">maximum</span> = <span class="nv">maximum</span>
</li><li>        <span class="nv">number</span> = <span class="nv">min</span>(<span class="nv">wrappedValue</span>, <span class="nv">maximum</span>)
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">The definition of <code class="docutils literal notranslate"><span class="pre">SmallNumber</span></code> includes three initializers—<code class="docutils literal notranslate"><span class="pre">init()</span></code>, <code class="docutils literal notranslate"><span class="pre">init(wrappedValue:)</span></code>, and <code class="docutils literal notranslate"><span class="pre">init(wrappedValue:maximum:)</span></code>—which the examples below use to set the wrapped value and the maximum value. For information about initialization and initializer syntax, see <a class="reference internal" href="Initialization.html"><span class="doc">Initialization</span></a>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">SmallNumber</span></code>の定義は３つのイニシャライザを含みます — <code class="docutils literal notranslate"><span class="pre">init()</span></code>、<code class="docutils literal notranslate"><span class="pre">init(wrappedValue:)</span></code>、そして<code class="docutils literal notranslate"><span class="pre">init(wrappedValue:maximum:)</span></code> — それらは、下の例がラップ値と最大値を設定するのに使用します。初期化とイニシャライザ構文についての情報として、<a class="reference internal" href="Initialization.html"><span class="doc">初期化</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">When you apply a wrapper to a property and you don’t specify an initial value, Swift uses the <code class="docutils literal notranslate"><span class="pre">init()</span></code> initializer to set up the wrapper. For example:</span><!--end_enstr-->
<span class="jpstr">
あなたがラッパーをプロパティに適用するそしてあなたが初期値を指定しないならば、スウィフトは<code class="docutils literal notranslate"><span class="pre">init()</span></code>イニシャライザを使ってラッパーを準備します。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">ZeroRectangle</span> {
</li><li>    @<span class="nv">SmallNumber</span> <span class="k">var</span> <span class="nv">height</span>: <span class="nc">Int</span>
</li><li>    @<span class="nv">SmallNumber</span> <span class="k">var</span> <span class="nv">width</span>: <span class="nc">Int</span>
</li><li>}
</li><li>
</li><li><span class="k">var</span> <span class="nv">zeroRectangle</span> = <span class="nv">ZeroRectangle</span>()
</li><li><span class="nv">print</span>(<span class="nv">zeroRectangle</span>.<span class="nv">height</span>, <span class="nv">zeroRectangle</span>.<span class="nv">width</span>)
</li><li><span class="c">// Prints "0 0"</span>
</li></ol></div></div></div>
<p><span class="enstr">The instances of <code class="docutils literal notranslate"><span class="pre">SmallNumber</span></code> that wrap <code class="docutils literal notranslate"><span class="pre">height</span></code> and <code class="docutils literal notranslate"><span class="pre">width</span></code> are created by calling <code class="docutils literal notranslate"><span class="pre">SmallNumber()</span></code>. The code inside that initializer sets the initial wrapped value and the initial maximum value, using the default values of zero and 12. The property wrapper still provides all of the initial values, like the earlier example that used <code class="docutils literal notranslate"><span class="pre">TwelveOrLess</span></code> in <code class="docutils literal notranslate"><span class="pre">SmallRectangle</span></code>. Unlike that example, <code class="docutils literal notranslate"><span class="pre">SmallNumber</span></code> also supports writing those initial values as part of declaring the property.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">height</span></code>と<code class="docutils literal notranslate"><span class="pre">width</span></code>をラップする<code class="docutils literal notranslate"><span class="pre">SmallNumber</span></code>のインスタンスは、<code class="docutils literal notranslate"><span class="pre">SmallNumber()</span></code>を呼び出すことによって作成されます。そのイニシャライザの内側のコードは、初期ラップ値と初期最大値を設定します、ゼロと12の省略時の値を使って。プロパティラッパーは、依然として初期値のすべてを提供します、<code class="docutils literal notranslate"><span class="pre">SmallRectangle</span></code>での<code class="docutils literal notranslate"><span class="pre">TwelveOrLess</span></code>を使った前の例のように。その例とは違い、<code class="docutils literal notranslate"><span class="pre">SmallNumber</span></code>は、それら初期値を書き込むこともプロパティの宣言の一部としてサポートします。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">When you specify an initial value for the property, Swift uses the <code class="docutils literal notranslate"><span class="pre">init(wrappedValue:)</span></code> initializer to set up the wrapper. For example:</span><!--end_enstr-->
<span class="jpstr">
あなたが初期値をプロパティに対して指定する場合、スウィフトは<code class="docutils literal notranslate"><span class="pre">init(wrappedValue:)</span></code>イニシャライザを使ってラッパーを準備します。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">UnitRectangle</span> {
</li><li>    @<span class="nv">SmallNumber</span> <span class="k">var</span> <span class="nv">height</span>: <span class="nc">Int</span> = <span class="m">1</span>
</li><li>    @<span class="nv">SmallNumber</span> <span class="k">var</span> <span class="nv">width</span>: <span class="nc">Int</span> = <span class="m">1</span>
</li><li>}
</li><li>
</li><li><span class="k">var</span> <span class="nv">unitRectangle</span> = <span class="nv">UnitRectangle</span>()
</li><li><span class="nv">print</span>(<span class="nv">unitRectangle</span>.<span class="nv">height</span>, <span class="nv">unitRectangle</span>.<span class="nv">width</span>)
</li><li><span class="c">// Prints "1 1"</span>
</li></ol></div></div></div>
<p><span class="enstr">When you write <code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">1</span></code> on a property with a wrapper, that’s translated into a call to the <code class="docutils literal notranslate"><span class="pre">init(wrappedValue:)</span></code> initializer. The instances of <code class="docutils literal notranslate"><span class="pre">SmallNumber</span></code> that wrap <code class="docutils literal notranslate"><span class="pre">height</span></code> and <code class="docutils literal notranslate"><span class="pre">width</span></code> are created by calling <code class="docutils literal notranslate"><span class="pre">SmallNumber(wrappedValue:</span> <span class="pre">1)</span></code>. The initializer uses the wrapped value that’s specified here, and it uses the default maximum value of 12.</span><!--end_enstr-->
<span class="jpstr">
あなたが<code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">1</span></code>をラッパーをもつプロパティ上で記述する場合、それは<code class="docutils literal notranslate"><span class="pre">init(wrappedValue:)</span></code>イニシャライザへの呼び出しに変換されます。<code class="docutils literal notranslate"><span class="pre">height</span></code>と<code class="docutils literal notranslate"><span class="pre">width</span></code>をラップする<code class="docutils literal notranslate"><span class="pre">SmallNumber</span></code>のインスタンスは、<code class="docutils literal notranslate"><span class="pre">SmallNumber(wrappedValue:</span> <span class="pre">1)</span></code>を呼び出すことによって作成されます。イニシャライザは、ここで指定されるラップ値を使います、そしてそれは省略時の最大値限の12を使います。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">When you write arguments in parentheses after the custom attribute, Swift uses the initializer that accepts those arguments to set up the wrapper. For example, if you provide an initial value and a maximum value, Swift uses the <code class="docutils literal notranslate"><span class="pre">init(wrappedValue:maximum:)</span></code> initializer:</span><!--end_enstr-->
<span class="jpstr">
あなたが引数を丸括弧の中であつらえの属性の後に書く場合、スウィフトはそれらの引数を受け入れるイニシャライザを使ってそのラッパーを準備します。例えば、あなたが初期値と最大値を提供するならば、スウィフトは<code class="docutils literal notranslate"><span class="pre">init(wrappedValue:maximum:)</span></code>イニシャライザを使います：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">NarrowRectangle</span> {
</li><li>    @<span class="nv">SmallNumber</span>(<span class="nv">wrappedValue</span>: <span class="m">2</span>, <span class="nv">maximum</span>: <span class="m">5</span>) <span class="k">var</span> <span class="nv">height</span>: <span class="nc">Int</span>
</li><li>    @<span class="nv">SmallNumber</span>(<span class="nv">wrappedValue</span>: <span class="m">3</span>, <span class="nv">maximum</span>: <span class="m">4</span>) <span class="k">var</span> <span class="nv">width</span>: <span class="nc">Int</span>
</li><li>}
</li><li>
</li><li><span class="k">var</span> <span class="nv">narrowRectangle</span> = <span class="nv">NarrowRectangle</span>()
</li><li><span class="nv">print</span>(<span class="nv">narrowRectangle</span>.<span class="nv">height</span>, <span class="nv">narrowRectangle</span>.<span class="nv">width</span>)
</li><li><span class="c">// Prints "2 3"</span>
</li><li>
</li><li><span class="nv">narrowRectangle</span>.<span class="nv">height</span> = <span class="m">100</span>
</li><li><span class="nv">narrowRectangle</span>.<span class="nv">width</span> = <span class="m">100</span>
</li><li><span class="nv">print</span>(<span class="nv">narrowRectangle</span>.<span class="nv">height</span>, <span class="nv">narrowRectangle</span>.<span class="nv">width</span>)
</li><li><span class="c">// Prints "5 4"</span>
</li></ol></div></div></div>
<p><span class="enstr">The instance of <code class="docutils literal notranslate"><span class="pre">SmallNumber</span></code> that wraps <code class="docutils literal notranslate"><span class="pre">height</span></code> is created by calling <code class="docutils literal notranslate"><span class="pre">SmallNumber(wrappedValue:</span> <span class="pre">2,</span> <span class="pre">maximum:</span> <span class="pre">5)</span></code>, and the instance that wraps <code class="docutils literal notranslate"><span class="pre">width</span></code> is created by calling <code class="docutils literal notranslate"><span class="pre">SmallNumber(wrappedValue:</span> <span class="pre">3,</span> <span class="pre">maximum:</span> <span class="pre">4)</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">height</span></code>をラップする<code class="docutils literal notranslate"><span class="pre">SmallNumber</span></code>インスタンスは、<code class="docutils literal notranslate"><span class="pre">SmallNumber(wrappedValue:</span> <span class="pre">2,</span> <span class="pre">maximum:</span> <span class="pre">5)</span></code>を呼び出すことによって作成されます、<code class="docutils literal notranslate"><span class="pre">width</span></code>をラップするインスタンスは、<code class="docutils literal notranslate"><span class="pre">SmallNumber(wrappedValue:</span> <span class="pre">3,</span> <span class="pre">maximum:</span> <span class="pre">4)</span></code>を呼び出すことによって作成されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">By including arguments to the property wrapper, you can set up the initial state in the wrapper or pass other options to the wrapper when it’s created. This syntax is the most general way to use a property wrapper. You can provide whatever arguments you need to the attribute, and they’re passed to the initializer.</span><!--end_enstr-->
<span class="jpstr">
引数をプロパティラッパーに含めることによって、あなたは初期状態をラッパーにおいて準備することまたは他のオプションをラッパーに渡すことが、それが作成される時に可能です。この構文は、プロバティラッパーを使う最も一般的な方法です。あなたは、どんなものでもあなたが必要とする引数それらを属性に提供できます、そしてそれらはイニシャライザに渡されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">When you include property wrapper arguments, you can also specify an initial value using assignment. Swift treats the assignment like a <code class="docutils literal notranslate"><span class="pre">wrappedValue</span></code> argument and uses the initializer that accepts the arguments you include. For example:</span><!--end_enstr-->
<span class="jpstr">
あなたがプロパティラッパー引数を含める場合、あなたはまた代入を使って初期値を指定できます。スウィフトは、その代入を<code class="docutils literal notranslate"><span class="pre">wrappedValue</span></code>引数のように扱います、そしてあなたが含める引数を受け入れるイニシャライザを使います。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">MixedRectangle</span> {
</li><li>    @<span class="nv">SmallNumber</span> <span class="k">var</span> <span class="nv">height</span>: <span class="nc">Int</span> = <span class="m">1</span>
</li><li>    @<span class="nv">SmallNumber</span>(<span class="nv">maximum</span>: <span class="m">9</span>) <span class="k">var</span> <span class="nv">width</span>: <span class="nc">Int</span> = <span class="m">2</span>
</li><li>}
</li><li>
</li><li><span class="k">var</span> <span class="nv">mixedRectangle</span> = <span class="nv">MixedRectangle</span>()
</li><li><span class="nv">print</span>(<span class="nv">mixedRectangle</span>.<span class="nv">height</span>)
</li><li><span class="c">// Prints "1"</span>
</li><li>
</li><li><span class="nv">mixedRectangle</span>.<span class="nv">height</span> = <span class="m">20</span>
</li><li><span class="nv">print</span>(<span class="nv">mixedRectangle</span>.<span class="nv">height</span>)
</li><li><span class="c"><span class="enstr">// Prints "12"</span><!--end_enstr--><span class="jpstr">（「12」を出力します）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">The instance of <code class="docutils literal notranslate"><span class="pre">SmallNumber</span></code> that wraps <code class="docutils literal notranslate"><span class="pre">height</span></code> is created by calling <code class="docutils literal notranslate"><span class="pre">SmallNumber(wrappedValue:</span> <span class="pre">1)</span></code>, which uses the default maximum value of 12. The instance that wraps <code class="docutils literal notranslate"><span class="pre">width</span></code> is created by calling <code class="docutils literal notranslate"><span class="pre">SmallNumber(wrappedValue:</span> <span class="pre">2,</span> <span class="pre">maximum:</span> <span class="pre">9)</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">height</span></code>をラップする<code class="docutils literal notranslate"><span class="pre">SmallNumber</span></code>のインスタンスは、<code class="docutils literal notranslate"><span class="pre">SmallNumber(wrappedValue:</span> <span class="pre">1)</span></code>を呼び出すことによって作成されます、それは省略時の最大値の12を使います。<code class="docutils literal notranslate"><span class="pre">width</span></code>をラップするインスタンスは、<code class="docutils literal notranslate"><span class="pre">SmallNumber(wrappedValue:</span> <span class="pre">2,</span> <span class="pre">maximum:</span> <span class="pre">9)</span></code>を呼び出すことによって作成されます。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID619">
<h3><span class="enstr">Projecting a Value From a Property Wrapper<a class="headerlink" href="#ID619" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
値をプロパティラッパーから投影する<a class="headerlink" href="#ID619" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p><span class="enstr">In addition to the wrapped value, a property wrapper can expose additional functionality by defining a <em>projected value</em>—for example, a property wrapper that manages access to a database can expose a <code class="docutils literal notranslate"><span class="pre">flushDatabaseConnection()</span></code> method on its projected value. The name of the projected value is the same as the wrapped value, except it begins with a dollar sign (<code class="docutils literal notranslate"><span class="pre">$</span></code>). Because your code can’t define properties that start with <code class="docutils literal notranslate"><span class="pre">$</span></code> the projected value never interferes with properties you define.</span><!--end_enstr-->
<span class="jpstr">
そのラップされた値に加えて、プロパティラッパーは<em>投影値</em>を定義することによっていっそうの機能性を露出できます — 例えば、データベースへのアクセスを管理するプロパティラッパーは、<code class="docutils literal notranslate"><span class="pre">flushDatabaseConnection()</span></code>メソッドをそれの投影値上で露出できます。投影値の名前は、ラップ値と同じです、それがドル記号（<code class="docutils literal notranslate"><span class="pre">$</span></code>）で始まることを除いては。あなたのコードが<code class="docutils literal notranslate"><span class="pre">$</span></code>で始まるプロパティを定義できないことから投影値は決してあなたが定義するプロパティと干渉しません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">In the <code class="docutils literal notranslate"><span class="pre">SmallNumber</span></code> example above, if you try to set the property to a number that’s too large, the property wrapper adjusts the number before storing it. The code below adds a <code class="docutils literal notranslate"><span class="pre">projectedValue</span></code> property to the <code class="docutils literal notranslate"><span class="pre">SmallNumber</span></code> structure to keep track of whether the property wrapper adjusted the new value for the property before storing that new value.</span><!--end_enstr-->
<span class="jpstr">
上の<code class="docutils literal notranslate"><span class="pre">SmallNumber</span></code>例において、あなたがプロパティをある大きすぎる数へと設定しようとするならば、プロパティラッパーはその数を調節します、それを格納する前に。下のコードは、<code class="docutils literal notranslate"><span class="pre">projectedValue</span></code>プロパティを<code class="docutils literal notranslate"><span class="pre">SmallNumber</span></code>構造体に加えることで、プロパティラッパーがプロパティに対する新しい値を、その新しい値を格納する前に調節したかどうかを追跡します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>@<span class="nv">propertyWrapper</span>
</li><li><span class="k">struct</span> <span class="nv">SmallNumber</span> {
</li><li>    <span class="k">private</span> <span class="k">var</span> <span class="nv">number</span>: <span class="nc">Int</span>
</li><li>    <span class="k">private(set)</span> <span class="k">var</span> <span class="nv">projectedValue</span>: <span class="nc">Bool</span>
</li><li>
</li><li>    <span class="k">var</span> <span class="nv">wrappedValue</span>: <span class="nc">Int</span> {
</li><li>        <span class="k">get</span> { <span class="k">return</span> <span class="nv">number</span> }
</li><li>        <span class="k">set</span> {
</li><li>            <span class="k">if</span> <span class="nv">newValue</span> &gt; <span class="m">12</span> {
</li><li>                <span class="nv">number</span> = <span class="m">12</span>
</li><li>                <span class="nv">projectedValue</span> = <span class="k">true</span>
</li><li>            } <span class="k">else</span> {
</li><li>                <span class="nv">number</span> = <span class="nv">newValue</span>
</li><li>                <span class="nv">projectedValue</span> = <span class="k">false</span>
</li><li>            }
</li><li>        }
</li><li>    }
</li><li>
</li><li>    <span class="k">init</span>() {
</li><li>        <span class="k">self</span>.<span class="nv">number</span> = <span class="m">0</span>
</li><li>        <span class="k">self</span>.<span class="nv">projectedValue</span> = <span class="k">false</span>
</li><li>    }
</li><li>}
</li><li><span class="k">struct</span> <span class="nv">SomeStructure</span> {
</li><li>    @<span class="nv">SmallNumber</span> <span class="k">var</span> <span class="nv">someNumber</span>: <span class="nc">Int</span>
</li><li>}
</li><li><span class="k">var</span> <span class="nv">someStructure</span> = <span class="nv">SomeStructure</span>()
</li><li>
</li><li><span class="nv">someStructure</span>.<span class="nv">someNumber</span> = <span class="m">4</span>
</li><li><span class="nv">print</span>(<span class="nv">someStructure</span>.<span class="nv">$someNumber</span>)
</li><li><span class="c"><span class="enstr">// Prints "false"</span><!--end_enstr--><span class="jpstr">（「false」を出力します）</span><!--end_jpstr--></span>
</li><li>
</li><li><span class="nv">someStructure</span>.<span class="nv">someNumber</span> = <span class="m">55</span>
</li><li><span class="nv">print</span>(<span class="nv">someStructure</span>.<span class="nv">$someNumber</span>)
</li><li><span class="c"><span class="enstr">// Prints "true"</span><!--end_enstr--><span class="jpstr">（「true」を出力します）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">Writing <code class="docutils literal notranslate"><span class="pre">someStructure.$someNumber</span></code> accesses the wrapper’s projected value. After storing a small number like four, the value of <code class="docutils literal notranslate"><span class="pre">someStructure.$someNumber</span></code> is <code class="docutils literal notranslate"><span class="pre">false</span></code>. However, the projected value is <code class="docutils literal notranslate"><span class="pre">true</span></code> after trying to store a number that’s too large, like 55.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">someStructure.$someNumber</span></code>と書くことは、ラッパーのもつ投影値にアクセスします。４のような小さい値を格納後、<code class="docutils literal notranslate"><span class="pre">someStructure.$someNumber</span></code>の値は<code class="docutils literal notranslate"><span class="pre">false</span></code>です。しかしながら、その投影値は、55のような大きすぎる数を格納しようとする後は<code class="docutils literal notranslate"><span class="pre">true</span></code>です。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">A property wrapper can return a value of any type as its projected value. In this example, the property wrapper exposes only one piece of information—whether the number was adjusted—so it exposes that Boolean value as its projected value. A wrapper that needs to expose more information can return an instance of some other data type, or it can return <code class="docutils literal notranslate"><span class="pre">self</span></code> to expose the instance of the wrapper as its projected value.</span><!--end_enstr-->
<span class="jpstr">
プロパティラッパーは、あらゆる型の値をそれの投影値として返せます。この例では、プロパティラッパーは情報の一片だけを露出します — その数が調節されたかどうか — それでそれはそのブール値をそれの投影値として露出します。さらに情報を露出する必要があるラッパーは、何らかの他のデータ型のインスタンスを返せます、またはそれは、<code class="docutils literal notranslate"><span class="pre">self</span></code>を返すことでラッパーのインスタンスをそれの投影値として露出できます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">When you access a projected value from code that’s part of the type, like a property getter or an instance method, you can omit <code class="docutils literal notranslate"><span class="pre">self.</span></code> before the property name, just like accessing other properties. The code in the following example refers to the projected value of the wrapper around <code class="docutils literal notranslate"><span class="pre">height</span></code> and <code class="docutils literal notranslate"><span class="pre">width</span></code> as <code class="docutils literal notranslate"><span class="pre">$height</span></code> and <code class="docutils literal notranslate"><span class="pre">$width</span></code>:</span><!--end_enstr-->
<span class="jpstr">
あなたがある投影値に、プロパティゲッターやインスタンスメソッドのようなその型の一部であるコードからアクセスする場合、あなたは<code class="docutils literal notranslate"><span class="pre">self.</span></code>をプロパティ名の前で省略できます、ちょうど他のプロパティにアクセスするように。次の例におけるコードは、<code class="docutils literal notranslate"><span class="pre">height</span></code>と<code class="docutils literal notranslate"><span class="pre">width</span></code>を囲んでいるラッパーの投影値を、<code class="docutils literal notranslate"><span class="pre">$height</span></code>と<code class="docutils literal notranslate"><span class="pre">$width</span></code>として参照します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">Size</span> {
</li><li>    <span class="k">case</span> <span class="nv">small</span>, <span class="nv">large</span>
</li><li>}
</li><li>
</li><li><span class="k">struct</span> <span class="nv">SizedRectangle</span> {
</li><li>    @<span class="nv">SmallNumber</span> <span class="k">var</span> <span class="nv">height</span>: <span class="nc">Int</span>
</li><li>    @<span class="nv">SmallNumber</span> <span class="k">var</span> <span class="nv">width</span>: <span class="nc">Int</span>
</li><li>
</li><li>    <span class="k">mutating</span> <span class="k">func</span> <span class="nv">resize</span>(<span class="nv">to</span> <span class="nv">size</span>: <span class="nc">Size</span>) -&gt; <span class="nc">Bool</span> {
</li><li>        <span class="k">switch</span> <span class="nv">size</span> {
</li><li>        <span class="k">case</span> .<span class="nv">small</span>:
</li><li>            <span class="nv">height</span> = <span class="m">10</span>
</li><li>            <span class="nv">width</span> = <span class="m">20</span>
</li><li>        <span class="k">case</span> .<span class="nv">large</span>:
</li><li>            <span class="nv">height</span> = <span class="m">100</span>
</li><li>            <span class="nv">width</span> = <span class="m">100</span>
</li><li>        }
</li><li>        <span class="k">return</span> <span class="nv">$height</span> || <span class="nv">$width</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">Because property wrapper syntax is just syntactic sugar for a property with a getter and a setter, accessing <code class="docutils literal notranslate"><span class="pre">height</span></code> and <code class="docutils literal notranslate"><span class="pre">width</span></code> behaves the same as accessing any other property. For example, the code in <code class="docutils literal notranslate"><span class="pre">resize(to:)</span></code> accesses <code class="docutils literal notranslate"><span class="pre">height</span></code> and <code class="docutils literal notranslate"><span class="pre">width</span></code> using their property wrapper. If you call <code class="docutils literal notranslate"><span class="pre">resize(to:</span> <span class="pre">.large)</span></code>, the switch case for <code class="docutils literal notranslate"><span class="pre">.large</span></code> sets the rectangle’s height and width to 100. The wrapper prevents the value of those properties from being larger than 12, and it sets the projected value to <code class="docutils literal notranslate"><span class="pre">true</span></code>, to record the fact that it adjusted their values. At the end of <code class="docutils literal notranslate"><span class="pre">resize(to:)</span></code>, the return statement checks <code class="docutils literal notranslate"><span class="pre">$height</span></code> and <code class="docutils literal notranslate"><span class="pre">$width</span></code> to determine whether the property wrapper adjusted either <code class="docutils literal notranslate"><span class="pre">height</span></code> or <code class="docutils literal notranslate"><span class="pre">width</span></code>.</span><!--end_enstr-->
<span class="jpstr">
プロパティラッパー構文がゲッターとセッターをもつプロパティに対する単なる糖衣構文であることから、<code class="docutils literal notranslate"><span class="pre">height</span></code>と<code class="docutils literal notranslate"><span class="pre">width</span></code>にアクセスすることは、何か他のプロパティと同じ挙動をします。例えば、<code class="docutils literal notranslate"><span class="pre">resize(to:)</span></code>でのコードは、<code class="docutils literal notranslate"><span class="pre">height</span></code>と<code class="docutils literal notranslate"><span class="pre">width</span></code>にそれらのプロパティラッパーを使ってアクセスします。あなたが<code class="docutils literal notranslate"><span class="pre">resize(to:</span> <span class="pre">.large)</span></code>を呼び出すならば、<code class="docutils literal notranslate"><span class="pre">.large</span></code>に対するスイッチケース節は、矩形のもつ高さと幅を100に設定します。ラッパーは、それらプロパティの値が12より大きくなることを防ぎます、そしてそれは投影値を<code class="docutils literal notranslate"><span class="pre">true</span></code>に設定します、それがそれらの値を調節したという事実を記録するために。<code class="docutils literal notranslate"><span class="pre">resize(to:)</span></code>の終わりで、return文は<code class="docutils literal notranslate"><span class="pre">$height</span></code>と<code class="docutils literal notranslate"><span class="pre">$width</span></code>を確認して、プロパティラッパーが<code class="docutils literal notranslate"><span class="pre">height</span></code>または<code class="docutils literal notranslate"><span class="pre">width</span></code>のどちらを調節したかを決定します。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID263">
<h2><span class="enstr">Global and Local Variables<a class="headerlink" href="#ID263" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
グローバルおよびローカル変数<a class="headerlink" href="#ID263" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">The capabilities described above for computing and observing properties are also available to <em>global variables</em> and <em>local variables</em>. Global variables are variables that are defined outside of any function, method, closure, or type context. Local variables are variables that are defined within a function, method, or closure context.</span><!--end_enstr-->
<span class="jpstr">
計算するそして監視するプロパティに対して上で記述される可能なことは、また、<em>グローバル変数</em>と<em>ローカル変数</em>に対して利用できます。グローバルな変数は、あらゆる関数、メソッド、クロージャ、または型の文脈の外で定義される変数です。ローカル変数は、関数、メソッド、またはクロージャの文脈の範囲内で定義される変数です。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The global and local variables you have encountered in previous chapters have all been <em>stored variables</em>. Stored variables, like stored properties, provide storage for a value of a certain type and allow that value to be set and retrieved.</span><!--end_enstr-->
<span class="jpstr">
あなたが前の章において遭遇したグローバルおよびローカル変数は、すべて<em>格納変数</em>でした。格納変数は、格納プロパティの様に、保管場所を特定の型のひとつの値のために用意して、その値の設定と取得を可能にします。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">However, you can also define <em>computed variables</em> and define observers for stored variables, in either a global or local scope. Computed variables calculate their value, rather than storing it, and they’re written in the same way as computed properties.</span><!--end_enstr-->
<span class="jpstr">
しかし、あなたはまた、<em>計算変数</em>を定義すること、そして格納変数のためにオブザーバーを定義することが、グローバルなまたはローカルなスコープのどちらにおいても可能です。計算変数は値を計算します、それの貯蔵ではなくて、そして計算プロパティと同じ方法で書かれます。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Global constants and variables are always computed lazily, in a similar manner to <a class="reference internal" href="#ID257"><span class="std std-ref">Lazy Stored Properties</span></a>. Unlike lazy stored properties, global constants and variables don’t need to be marked with the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> modifier.</span><!--end_enstr-->
<span class="jpstr">
グローバルな定数と変数は、<a class="reference internal" href="#ID257"><span class="std std-ref">遅延格納プロパティ</span></a>と似たやり方で、常に遅延計算されます。遅延格納プロパティと違って、グローバルな定数と変数は<code class="docutils literal notranslate"><span class="pre">lazy</span></code>修飾子で印付けされる必要がありません。
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Local constants and variables are never computed lazily.</span><!--end_enstr-->
<span class="jpstr">
ローカルな定数と変数は、決して遅延して計算されません。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">You can apply a property wrapper to a local stored variable, but not to a global variable or a computed variable. For example, in the code below, <code class="docutils literal notranslate"><span class="pre">myNumber</span></code> uses <code class="docutils literal notranslate"><span class="pre">SmallNumber</span></code> as a property wrapper.</span><!--end_enstr-->
<span class="jpstr">
あなたは、プロパティラッパーをローカル格納変数に適用できます、しかしグローパル変数または計算変数にはできません。例えば、下のコードにおいて、<code class="docutils literal notranslate"><span class="pre">myNumber</span></code>は<code class="docutils literal notranslate"><span class="pre">SmallNumber</span></code>をプロパティラッパーとして使います。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">someFunction</span>() {
</li><li>    @<span class="nv">SmallNumber</span> <span class="k">var</span> <span class="nv">myNumber</span>: <span class="nc">Int</span> = <span class="m">0</span>
</li><li>
</li><li>    <span class="nv">myNumber</span> = <span class="m">10</span>
</li><li>    <span class="c">// now myNumber is 10</span>
</li><li>
</li><li>    <span class="nv">myNumber</span> = <span class="m">24</span>
</li><li>    <span class="c">// now myNumber is 12</span>
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">Like when you apply <code class="docutils literal notranslate"><span class="pre">SmallNumber</span></code> to a property, setting the value of <code class="docutils literal notranslate"><span class="pre">myNumber</span></code> to 10 is valid. Because the property wrapper doesn’t allow values higher than 12, it sets <code class="docutils literal notranslate"><span class="pre">myNumber</span></code> to 12 instead of 24.</span><!--end_enstr-->
<span class="jpstr">
あなたが<code class="docutils literal notranslate"><span class="pre">SmallNumber</span></code>に適用する時のように、<code class="docutils literal notranslate"><span class="pre">myNumber</span></code>の値を10に設定することは有効です。プロパティラッパーが12より高い値を許可しないので、それは<code class="docutils literal notranslate"><span class="pre">myNumber</span></code>を12に設定します、24の代わりに。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID264">
<h2><span class="enstr">Type Properties<a class="headerlink" href="#ID264" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
型プロパティ<a class="headerlink" href="#ID264" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">Instance properties are properties that belong to an instance of a particular type. Every time you create a new instance of that type, it has its own set of property values, separate from any other instance.</span><!--end_enstr-->
<span class="jpstr">
インスタンスプロパティは、ある特定の型のあるひとつのインスタンスに属しているプロパティです。あなたがその型の新しいインスタンスをつくるたびに、それは、他のあらゆるインスタンスから独立した、独自のひと組のプロパティ値を持ちます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can also define properties that belong to the type itself, not to any one instance of that type. There will only ever be one copy of these properties, no matter how many instances of that type you create. These kinds of properties are called <em>type properties</em>.</span><!--end_enstr-->
<span class="jpstr">
あなたは、また、その型のどれかひとつのインスタンスにではなく、型それ自体に属しているいくらかのプロパティを定義することができます。それらのプロパティのコピーはただ１つだけ存在することになります、あなたが作るその型のインスタンスがいくらあろうとも。これらの種類のプロパティは、<em>型プロパティ</em>と呼ばれています。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Type properties are useful for defining values that are universal to <em>all</em> instances of a particular type, such as a constant property that all instances can use (like a static constant in C), or a variable property that stores a value that’s global to all instances of that type (like a static variable in C).</span><!--end_enstr-->
<span class="jpstr">
型プロパティは、特定の型の<em>全ての</em>インスタンスに共通なさまざまな値を定義することに役立ちます、例えば、全てのインスタンスが使うことができる定数プロパティ（Cでの静的定数のように）、またはその型の全てのインスタンスにグローバルである値を格納する変数プロパティ（Cでの静的変数のように）。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Stored type properties can be variables or constants. Computed type properties are always declared as variable properties, in the same way as computed instance properties.</span><!--end_enstr-->
<span class="jpstr">
格納プロパティは、変数または定数であることができます。計算型プロパティは、計算インスタンスプロパティと同じ方法で、常に変数プロパティとして宣言されます。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Unlike stored instance properties, you must always give stored type properties a default value. This is because the type itself doesn’t have an initializer that can assign a value to a stored type property at initialization time.</span><!--end_enstr-->
<span class="jpstr">
格納インスタンスプロパティと違って、あなたは格納型プロパティに省略時の値を常に与えなければなりません。これは、型それ自身には初期化時に値を格納型プロパティに代入することができるイニシャライザがないからです。
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Stored type properties are lazily initialized on their first access. They’re guaranteed to be initialized only once, even when accessed by multiple threads simultaneously, and they don’t need to be marked with the <code class="docutils literal notranslate"><span class="pre">lazy</span></code> modifier.</span><!--end_enstr-->
<span class="jpstr">
格納型プロパティは、それらの最初のアクセスにおいて遅延して初期化されます。それらは、ただ一度だけ初期化されることを保証されます、複数のスレッドによって同時にアクセスされる場合でさえもです、そしてそれらは<code class="docutils literal notranslate"><span class="pre">lazy</span></code>修飾子で印されることを必要としません。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID265">
<h3><span class="enstr">Type Property Syntax<a class="headerlink" href="#ID265" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
型プロパティ構文<a class="headerlink" href="#ID265" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p><span class="enstr">In C and Objective-C, you define static constants and variables associated with a type as <em>global</em> static variables. In Swift, however, type properties are written as part of the type’s definition, within the type’s outer curly braces, and each type property is explicitly scoped to the type it supports.</span><!--end_enstr-->
<span class="jpstr">
CとObjective-Cでは、あなたは静的定数および<em>グローバルな</em>静的変数として型と結びついた変数を定義します。スウィフトでは、しかしながら、型プロパティは、型の定義の一部として、型の外縁の波括弧の内部に書かれます、そして各型プロパティは、明確にそれが支持する型にスコープを定められます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You define type properties with the <code class="docutils literal notranslate"><span class="pre">static</span></code> keyword. For computed type properties for class types, you can use the <code class="docutils literal notranslate"><span class="pre">class</span></code> keyword instead to allow subclasses to override the superclass’s implementation. The example below shows the syntax for stored and computed type properties:</span><!--end_enstr-->
<span class="jpstr">
あなたは、型プロパティを<code class="docutils literal notranslate"><span class="pre">static</span></code>キーワードを使って定義します。クラス型のための計算型プロパティに対しては、あなたは代わりに<code class="docutils literal notranslate"><span class="pre">class</span></code>キーワードを使って、サブクラスにそのスーパークラスの実装のオーバーライドを許可することができます。以下の例は、格納型プロパティおよび計算型プロパティのための構文を示します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">SomeStructure</span> {
</li><li>    <span class="k">static</span> <span class="k">var</span> <span class="nv">storedTypeProperty</span> = <span class="s">"Some value."</span>
</li><li>    <span class="k">static</span> <span class="k">var</span> <span class="nv">computedTypeProperty</span>: <span class="nc">Int</span> {
</li><li>        <span class="k">return</span> <span class="m">1</span>
</li><li>    }
</li><li>}
</li><li><span class="k">enum</span> <span class="nv">SomeEnumeration</span> {
</li><li>    <span class="k">static</span> <span class="k">var</span> <span class="nv">storedTypeProperty</span> = <span class="s">"Some value."</span>
</li><li>    <span class="k">static</span> <span class="k">var</span> <span class="nv">computedTypeProperty</span>: <span class="nc">Int</span> {
</li><li>        <span class="k">return</span> <span class="m">6</span>
</li><li>    }
</li><li>}
</li><li><span class="k">class</span> <span class="nv">SomeClass</span> {
</li><li>    <span class="k">static</span> <span class="k">var</span> <span class="nv">storedTypeProperty</span> = <span class="s">"Some value."</span>
</li><li>    <span class="k">static</span> <span class="k">var</span> <span class="nv">computedTypeProperty</span>: <span class="nc">Int</span> {
</li><li>        <span class="k">return</span> <span class="m">27</span>
</li><li>    }
</li><li>    <span class="k">class</span> <span class="k">var</span> <span class="nv">overrideableComputedTypeProperty</span>: <span class="nc">Int</span> {
</li><li>        <span class="k">return</span> <span class="m">107</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">The computed type property examples above are for read-only computed type properties, but you can also define read-write computed type properties with the same syntax as for computed instance properties.</span><!--end_enstr-->
<span class="jpstr">
上の計算型プロパティの例は、読み出し専用の計算型プロパティのためのものです、しかしあなたはまた、計算インスタンスプロパティについては同じ構文をつかって読み書き両用の計算型プロパティを定義することができます。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID266">
<h3><span class="enstr">Querying and Setting Type Properties<a class="headerlink" href="#ID266" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
型プロパティを問い合わせて、設定する<a class="headerlink" href="#ID266" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p><span class="enstr">Type properties are queried and set with dot syntax, just like instance properties. However, type properties are queried and set on the <em>type</em>, not on an instance of that type. For example:</span><!--end_enstr-->
<span class="jpstr">
型プロパティは、インスタンスプロパティのように、ドット構文で問い合わせられ設定されます。しかし、型プロパティは、その型のインスタンスにではなく、その<em>型</em>に問い合わせられ設定されます。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">print</span>(<span class="nv">SomeStructure</span>.<span class="nv">storedTypeProperty</span>)
</li><li><span class="c"><span class="enstr">// Prints "Some value."</span><!--end_enstr--><span class="jpstr">（「ある値。」を出力します）</span><!--end_jpstr--></span>
</li><li><span class="nv">SomeStructure</span>.<span class="nv">storedTypeProperty</span> = <span class="s">"Another value."</span>
</li><li><span class="nv">print</span>(<span class="nv">SomeStructure</span>.<span class="nv">storedTypeProperty</span>)
</li><li><span class="c"><span class="enstr">// Prints "Another value."</span><!--end_enstr--><span class="jpstr">（「別の値。」を出力します）</span><!--end_jpstr--></span>
</li><li><span class="nv">print</span>(<span class="nv">SomeEnumeration</span>.<span class="nv">computedTypeProperty</span>)
</li><li><span class="c"><span class="enstr">// Prints "6"</span><!--end_enstr--><span class="jpstr">（「6」を出力します）</span><!--end_jpstr--></span>
</li><li><span class="nv">print</span>(<span class="nv">SomeClass</span>.<span class="nv">computedTypeProperty</span>)
</li><li><span class="c"><span class="enstr">// Prints "27"</span><!--end_enstr--><span class="jpstr">（「27」を出力します）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">The examples that follow use two stored type properties as part of a structure that models an audio level meter for a number of audio channels. Each channel has an integer audio level between <code class="docutils literal notranslate"><span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">10</span></code> inclusive.</span><!--end_enstr-->
<span class="jpstr">
あとに続く例は、いくつかのオーディオ・チャンネル用のオーディオ・レベルをモデル化する構造体の一部として、２つの格納型プロパティを使います。各チャンネルは、<code class="docutils literal notranslate"><span class="pre">0</span></code>から<code class="docutils literal notranslate"><span class="pre">10</span></code>を含むまでの整数オーディオ・レベルがあります。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The figure below illustrates how two of these audio channels can be combined to model a stereo audio level meter. When a channel’s audio level is <code class="docutils literal notranslate"><span class="pre">0</span></code>, none of the lights for that channel are lit. When the audio level is <code class="docutils literal notranslate"><span class="pre">10</span></code>, all of the lights for that channel are lit. In this figure, the left channel has a current level of <code class="docutils literal notranslate"><span class="pre">9</span></code>, and the right channel has a current level of <code class="docutils literal notranslate"><span class="pre">7</span></code>:</span><!--end_enstr-->
<span class="jpstr">
下の図は、これらの音声のチャンネルのうちの２つがステレオ音声のレベル・メーターをモデル化するために結合されることができる方法を図示します。チャンネルの音声のレベルが<code class="docutils literal notranslate"><span class="pre">0</span></code>であるとき、そのチャンネルのための光のどれも点灯されません。音声のレベルが<code class="docutils literal notranslate"><span class="pre">10</span></code>であるとき、そのチャンネルのための光の全ては点灯されます。この図には、左のチャンネルに現在<code class="docutils literal notranslate"><span class="pre">9</span></code>のレベルがあり、右のチャンネルに現在<code class="docutils literal notranslate"><span class="pre">7</span></code>のレベルがあります：
</span><!--end_jpstr-->
</p>
<img alt="../_images/staticPropertiesVUMeter_2x.png" class="align-center" src="../images/staticPropertiesVUMeter_2x.png" style="width: 243px;" />
<p><span class="enstr">The audio channels described above are represented by instances of the <code class="docutils literal notranslate"><span class="pre">AudioChannel</span></code> structure:</span><!--end_enstr-->
<span class="jpstr">
上で記述される音声のチャンネルは、<code class="docutils literal notranslate"><span class="pre">AudioChannel</span></code>構造体のインスタンスによって表されます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">AudioChannel</span> {
</li><li>    <span class="k">static</span> <span class="k">let</span> <span class="nv">thresholdLevel</span> = <span class="m">10</span>
</li><li>    <span class="k">static</span> <span class="k">var</span> <span class="nv">maxInputLevelForAllChannels</span> = <span class="m">0</span>
</li><li>    <span class="k">var</span> <span class="nv">currentLevel</span>: <span class="nc">Int</span> = <span class="m">0</span> {
</li><li>        <span class="k">didSet</span> {
</li><li>            <span class="k">if</span> <span class="nv">currentLevel</span> &gt; <span class="nv">AudioChannel</span>.<span class="nv">thresholdLevel</span> {
</li><li>                <span class="c"><span class="enstr">// cap the new audio level to the threshold level</span><!--end_enstr--><span class="jpstr">（新しい音声レベルを限界レベルに制限する）</span><!--end_jpstr--></span>
</li><li>                <span class="nv">currentLevel</span> = <span class="nv">AudioChannel</span>.<span class="nv">thresholdLevel</span>
</li><li>            }
</li><li>            <span class="k">if</span> <span class="nv">currentLevel</span> &gt; <span class="nv">AudioChannel</span>.<span class="nv">maxInputLevelForAllChannels</span> {
</li><li>                <span class="c"><span class="enstr">// store this as the new overall maximum input level</span><!--end_enstr--><span class="jpstr">（これを新しい全体で最大の入力レベルとして格納する）</span><!--end_jpstr--></span>
</li><li>                <span class="nv">AudioChannel</span>.<span class="nv">maxInputLevelForAllChannels</span> = <span class="nv">currentLevel</span>
</li><li>            }
</li><li>        }
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">AudioChannel</span></code> structure defines two stored type properties to support its functionality. The first, <code class="docutils literal notranslate"><span class="pre">thresholdLevel</span></code>, defines the maximum threshold value an audio level can take. This is a constant value of <code class="docutils literal notranslate"><span class="pre">10</span></code> for all <code class="docutils literal notranslate"><span class="pre">AudioChannel</span></code> instances. If an audio signal comes in with a higher value than <code class="docutils literal notranslate"><span class="pre">10</span></code>, it will be capped to this threshold value (as described below).</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">AudioChannel</span></code>構造体は、その機能性を支えるために２つの格納型プロパティを定義します。その一番目、<code class="docutils literal notranslate"><span class="pre">thresholdLevel</span></code>は、音声レベルがとることができる最大の限界値を定義します。これは、定数値で、全ての<code class="docutils literal notranslate"><span class="pre">AudioChannel</span></code>インスタンスのために<code class="docutils literal notranslate"><span class="pre">10</span></code>です。ある音声信号が<code class="docutils literal notranslate"><span class="pre">10</span></code>より高い値でやってくるならば、それはこの限界値に制限されます（下記のように）。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The second type property is a variable stored property called <code class="docutils literal notranslate"><span class="pre">maxInputLevelForAllChannels</span></code>. This keeps track of the maximum input value that has been received by <em>any</em> <code class="docutils literal notranslate"><span class="pre">AudioChannel</span></code> instance. It starts with an initial value of <code class="docutils literal notranslate"><span class="pre">0</span></code>.</span><!--end_enstr-->
<span class="jpstr">
第二の型プロパティは、<code class="docutils literal notranslate"><span class="pre">maxInputLevelForAllChannels</span></code>と呼ばれる変数格納プロパティです。これは、<em>あらゆる</em> <code class="docutils literal notranslate"><span class="pre">AudioChannel</span></code>インスタンスによって受け取られた最大入力値の情報を得続けます。それは、初期値の<code class="docutils literal notranslate"><span class="pre">0</span></code>から始めます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">AudioChannel</span></code> structure also defines a stored instance property called <code class="docutils literal notranslate"><span class="pre">currentLevel</span></code>, which represents the channel’s current audio level on a scale of <code class="docutils literal notranslate"><span class="pre">0</span></code> to <code class="docutils literal notranslate"><span class="pre">10</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">AudioChannel</span></code>構造体はまた、<code class="docutils literal notranslate"><span class="pre">currentLevel</span></code>と呼ばれる格納インスタンスプロパティを定義します、それは、<code class="docutils literal notranslate"><span class="pre">0</span></code>から<code class="docutils literal notranslate"><span class="pre">10</span></code>までの目盛りでチャンネルの現在の音声レベルを表わします。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">currentLevel</span></code> property has a <code class="docutils literal notranslate"><span class="pre">didSet</span></code> property observer to check the value of <code class="docutils literal notranslate"><span class="pre">currentLevel</span></code> whenever it’s set. This observer performs two checks:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">currentLevel</span></code>プロパティは<code class="docutils literal notranslate"><span class="pre">didSet</span></code>プロパティオブザーバーを持ち、<code class="docutils literal notranslate"><span class="pre">currentLevel</span></code>の値をそれが設定されるときはいつでも調べるようにします。このオブザーバーは、２つのチェックをします：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li><span class="enstr">If the new value of <code class="docutils literal notranslate"><span class="pre">currentLevel</span></code> is greater than the allowed <code class="docutils literal notranslate"><span class="pre">thresholdLevel</span></code>, the property observer caps <code class="docutils literal notranslate"><span class="pre">currentLevel</span></code> to <code class="docutils literal notranslate"><span class="pre">thresholdLevel</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">currentLevel</span></code>の新しい値が許可された<code class="docutils literal notranslate"><span class="pre">thresholdLevel</span></code>より大きいならば、このプロパティオブザーバーは<code class="docutils literal notranslate"><span class="pre">currentLevel</span></code>を<code class="docutils literal notranslate"><span class="pre">thresholdLevel</span></code>に制限します。
</span><!--end_jpstr-->
</li>
<li><span class="enstr">If the new value of <code class="docutils literal notranslate"><span class="pre">currentLevel</span></code> (after any capping) is higher than any value previously received by <em>any</em> <code class="docutils literal notranslate"><span class="pre">AudioChannel</span></code> instance, the property observer stores the new <code class="docutils literal notranslate"><span class="pre">currentLevel</span></code> value in the <code class="docutils literal notranslate"><span class="pre">maxInputLevelForAllChannels</span></code> type property.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">currentLevel</span></code>の新しい値が（制限を受けた後に）<em>あらゆる</em> <code class="docutils literal notranslate"><span class="pre">AudioChannel</span></code>インスタンスで以前に受けた値より高いならば、プロパティオブザーバーは、新しい<code class="docutils literal notranslate"><span class="pre">currentLevel</span></code>値を型プロパティ<code class="docutils literal notranslate"><span class="pre">maxInputLevelForAllChannels</span></code>に保管します。
</span><!--end_jpstr-->
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">In the first of these two checks, the <code class="docutils literal notranslate"><span class="pre">didSet</span></code> observer sets <code class="docutils literal notranslate"><span class="pre">currentLevel</span></code> to a different value. This doesn’t, however, cause the observer to be called again.</span><!--end_enstr-->
<span class="jpstr">
これらの２つのチェックで最初のものにおいて、<code class="docutils literal notranslate"><span class="pre">didSet</span></code>オブザーバーは、<code class="docutils literal notranslate"><span class="pre">currentLevel</span></code>を異なる値に設定します。これは、しかし、このオブザーバーが再び呼び出されるようにしません。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">You can use the <code class="docutils literal notranslate"><span class="pre">AudioChannel</span></code> structure to create two new audio channels called <code class="docutils literal notranslate"><span class="pre">leftChannel</span></code> and <code class="docutils literal notranslate"><span class="pre">rightChannel</span></code>, to represent the audio levels of a stereo sound system:</span><!--end_enstr-->
<span class="jpstr">
あなたは、<code class="docutils literal notranslate"><span class="pre">AudioChannel</span></code>構造体を、<code class="docutils literal notranslate"><span class="pre">leftChannel</span></code>と<code class="docutils literal notranslate"><span class="pre">rightChannel</span></code>と呼ばれる２つの新しい音声チャンネルをつくるために使用して、ステレオ・オーディオ・システムの音声のレベルを表すことができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">leftChannel</span> = <span class="nv">AudioChannel</span>()
</li><li><span class="k">var</span> <span class="nv">rightChannel</span> = <span class="nv">AudioChannel</span>()
</li></ol></div></div></div>
<p><span class="enstr">If you set the <code class="docutils literal notranslate"><span class="pre">currentLevel</span></code> of the <em>left</em> channel to <code class="docutils literal notranslate"><span class="pre">7</span></code>, you can see that the <code class="docutils literal notranslate"><span class="pre">maxInputLevelForAllChannels</span></code> type property is updated to equal <code class="docutils literal notranslate"><span class="pre">7</span></code>:</span><!--end_enstr-->
<span class="jpstr">
あなたが<em>左</em>のチャンネルの<code class="docutils literal notranslate"><span class="pre">currentLevel</span></code>を<code class="docutils literal notranslate"><span class="pre">7</span></code>に設定するならば、あなたは型プロパティ<code class="docutils literal notranslate"><span class="pre">maxInputLevelForAllChannels</span></code>が<code class="docutils literal notranslate"><span class="pre">7</span></code>に等しくなるよう更新されるのを見ることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">leftChannel</span>.<span class="nv">currentLevel</span> = <span class="m">7</span>
</li><li><span class="nv">print</span>(<span class="nv">leftChannel</span>.<span class="nv">currentLevel</span>)
</li><li><span class="c"><span class="enstr">// Prints "7"</span><!--end_enstr--><span class="jpstr">（「７」を出力します）</span><!--end_jpstr--></span>
</li><li><span class="nv">print</span>(<span class="nv">AudioChannel</span>.<span class="nv">maxInputLevelForAllChannels</span>)
</li><li><span class="c"><span class="enstr">// Prints "7"</span><!--end_enstr--><span class="jpstr">（「７」を出力します）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">If you try to set the <code class="docutils literal notranslate"><span class="pre">currentLevel</span></code> of the <em>right</em> channel to <code class="docutils literal notranslate"><span class="pre">11</span></code>, you can see that the right channel’s <code class="docutils literal notranslate"><span class="pre">currentLevel</span></code> property is capped to the maximum value of <code class="docutils literal notranslate"><span class="pre">10</span></code>, and the <code class="docutils literal notranslate"><span class="pre">maxInputLevelForAllChannels</span></code> type property is updated to equal <code class="docutils literal notranslate"><span class="pre">10</span></code>:</span><!--end_enstr-->
<span class="jpstr">
あなたが<em>右</em>のチャンネルの<code class="docutils literal notranslate"><span class="pre">currentLevel</span></code>を<code class="docutils literal notranslate"><span class="pre">11</span></code>に設定しようとするならば、あなたは右のチャンネルの<code class="docutils literal notranslate"><span class="pre">currentLevel</span></code>プロパティが最大値の<code class="docutils literal notranslate"><span class="pre">10</span></code>に制限されるのを見ることができます、そして型プロパティ<code class="docutils literal notranslate"><span class="pre">maxInputLevelForAllChannels</span></code>は<code class="docutils literal notranslate"><span class="pre">10</span></code>に等しくなるよう更新されます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">rightChannel</span>.<span class="nv">currentLevel</span> = <span class="m">11</span>
</li><li><span class="nv">print</span>(<span class="nv">rightChannel</span>.<span class="nv">currentLevel</span>)
</li><li><span class="c"><span class="enstr">// Prints "10"</span><!--end_enstr--><span class="jpstr">（「10」を出力します）</span><!--end_jpstr--></span>
</li><li><span class="nv">print</span>(<span class="nv">AudioChannel</span>.<span class="nv">maxInputLevelForAllChannels</span>)
</li><li><span class="c"><span class="enstr">// Prints "10"</span><!--end_enstr--><span class="jpstr">（「10」を出力します）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
</div>
</div>
</div>


    </article>
    <div class="next_previous">
        <p class="previous"><a href="ClassesAndStructures.html"><span class="enstr">Structures and Classes</span><!--end_enstr-->
<span class="jpstr">
構造体とクラス
</span><!--end_jpstr-->
</a></p>
        <p class="next"><a href="Methods.html"><span class="enstr">Methods</span><!--end_enstr-->
<span class="jpstr">
メソッド
</span><!--end_jpstr-->
</a></p>
    </div>
</main>


<footer role="contentinfo">
  <aside>
    <a href="//swift.org/atom.xml" title="Subscribe to Site Updates"><i class="feed">Subscribe</i></a>
    <a href="https://twitter.com/swiftlang" rel="nofollow" title="Follow @SwiftLang on Twitter"><i class="twitter">Twitter</i></a>
  </aside>

  <p class="copyright">Copyright © 2021 Apple Inc. All rights reserved.</p>
  <p class="trademark">Swift and the Swift logo are trademarks of Apple Inc.</p>
  <p class="privacy">
    <a href="//www.apple.com/privacy/privacy-policy/">Privacy Policy</a>
    <a href="//www.apple.com/legal/privacy/en-ww/cookies/">Cookies</a>
  </p>
</footer>
<div id="jump_to_overlay"></div>
<script src="../static/javascripts/application.js"></script>
  </body>
</html>