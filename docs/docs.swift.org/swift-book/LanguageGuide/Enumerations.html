

<!DOCTYPE html>



<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8" />
    <meta name="author" content="Apple Inc." />
    <meta name="viewport" content="width=device-width initial-scale=1" />
    
    <title>Enumerations — The Swift Programming Language (Swift 5.5)</title>
    
    <link rel="license" href="/LICENSE.txt" />
    <link rel="stylesheet" media="all" href="../static/stylesheets/application.css" />
    <link rel="stylesheet" media="all" href="../static/stylesheets/tspl.css" />
    <link rel="shortcut icon" sizes="16x16 24x24 32x32 48x48 64x64" type="image/vnd.microsoft.icon" href="/favicon.ico" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png" />
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png" />
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png" />
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png" />
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png" />
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png" />
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png" />
    <link rel="mask-icon" href="/assets/images/icon-swift.svg" color="#F05339" /> 
  </head>
  <body>


<nav role="navigation">
    <header role="banner">
      <h1 id="logo">
        <a href="https://swift.org/" title="Swift.org" role="img" aria-label="Swift.org">
          Swift.org
        </a>
      </h1>
    </header>

    <div id="menu-toggle" class="menu-toggle open"></div>

    <h2>The Swift Programming Language<div>Swift 5.5</div></h2>

    <ul>
    <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html"><span class="enstr">Welcome to Swift</span><!--end_enstr-->
<span class="jpstr">
スウィフトにようこそ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="TheBasics.html"><span class="enstr">Language Guide</span><!--end_enstr-->
<span class="jpstr">
言語ガイド
</span><!--end_jpstr-->
</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="TheBasics.html"><span class="enstr">The Basics</span><!--end_enstr-->
<span class="jpstr">
基本
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="BasicOperators.html"><span class="enstr">Basic Operators</span><!--end_enstr-->
<span class="jpstr">
基本の演算子
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="StringsAndCharacters.html"><span class="enstr">Strings and Characters</span><!--end_enstr-->
<span class="jpstr">
文字列と文字
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="CollectionTypes.html"><span class="enstr">Collection Types</span><!--end_enstr-->
<span class="jpstr">
コレクション型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ControlFlow.html"><span class="enstr">Control Flow</span><!--end_enstr-->
<span class="jpstr">
制御の流れ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Functions.html"><span class="enstr">Functions</span><!--end_enstr-->
<span class="jpstr">
関数
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Closures.html"><span class="enstr">Closures</span><!--end_enstr-->
<span class="jpstr">
クロージャ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#"><span class="enstr">Enumerations</span><!--end_enstr-->
<span class="jpstr">
列挙
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ClassesAndStructures.html"><span class="enstr">Structures and Classes</span><!--end_enstr-->
<span class="jpstr">
構造体とクラス
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Properties.html"><span class="enstr">Properties</span><!--end_enstr-->
<span class="jpstr">
プロパティ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Methods.html"><span class="enstr">Methods</span><!--end_enstr-->
<span class="jpstr">
メソッド
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Subscripts.html"><span class="enstr">Subscripts</span><!--end_enstr-->
<span class="jpstr">
添え字
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Inheritance.html"><span class="enstr">Inheritance</span><!--end_enstr-->
<span class="jpstr">
継承
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Initialization.html"><span class="enstr">Initialization</span><!--end_enstr-->
<span class="jpstr">
初期化
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Deinitialization.html"><span class="enstr">Deinitialization</span><!--end_enstr-->
<span class="jpstr">
デイニシャライズ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="OptionalChaining.html"><span class="enstr">Optional Chaining</span><!--end_enstr-->
<span class="jpstr">
オプショナル連鎖
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ErrorHandling.html"><span class="enstr">Error Handling</span><!--end_enstr-->
<span class="jpstr">
エラーの処理
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html"><span class="enstr">Concurrency</span><!--end_enstr-->
<span class="jpstr">
並行性
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="TypeCasting.html"><span class="enstr">Type Casting</span><!--end_enstr-->
<span class="jpstr">
型キャスト
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="NestedTypes.html"><span class="enstr">Nested Types</span><!--end_enstr-->
<span class="jpstr">
入れ子にされた型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Extensions.html"><span class="enstr">Extensions</span><!--end_enstr-->
<span class="jpstr">
拡張
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Protocols.html"><span class="enstr">Protocols</span><!--end_enstr-->
<span class="jpstr">
プロトコル
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Generics.html"><span class="enstr">Generics</span><!--end_enstr-->
<span class="jpstr">
総称体
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="OpaqueTypes.html"><span class="enstr">Opaque Types</span><!--end_enstr-->
<span class="jpstr">
不透明型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AutomaticReferenceCounting.html"><span class="enstr">Automatic Reference Counting</span><!--end_enstr-->
<span class="jpstr">
自動参照カウント
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="MemorySafety.html"><span class="enstr">Memory Safety</span><!--end_enstr-->
<span class="jpstr">
メモリ安全
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AccessControl.html"><span class="enstr">Access Control</span><!--end_enstr-->
<span class="jpstr">
アクセス制御
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AdvancedOperators.html"><span class="enstr">Advanced Operators</span><!--end_enstr-->
<span class="jpstr">
先進の演算子
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ReferenceManual/AboutTheLanguageReference.html"><span class="enstr">Language Reference</span><!--end_enstr-->
<span class="jpstr">
言語リファレンス
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1"><a class="reference internal" href="../RevisionHistory/RevisionHistory.html"><span class="enstr">Revision History</span><!--end_enstr-->
<span class="jpstr">
改訂履歴
</span><!--end_jpstr-->
</a></li>
</ul>

    <li class="toctree-l1 return"><a class="reference internal" href="../../../index.html">← Go to Index</a></li>
    </ul>
</nav>




<main role="main">
    <article class="page">
        <menu id="bashful" type="toolbar">
          <div class="inner">
            <menuitem id="jump_to" class="menu-bar-item closed">
            <span id="jump_to_toggle">On This Page</span>
            <div class="chevron">
                <div class="chevy chevron-left"></div>
                <div class="chevy chevron-right"></div>
            </div>
            <menu type="list" class="details">
                <ul>
<li><a class="reference internal" href="#"><span class="enstr">Enumerations</span><!--end_enstr-->
<span class="jpstr">
列挙
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID146"><span class="enstr">Enumeration Syntax</span><!--end_enstr-->
<span class="jpstr">
列挙構文
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID147"><span class="enstr">Matching Enumeration Values with a Switch Statement</span><!--end_enstr-->
<span class="jpstr">
列挙値をスイッチ文で照合する
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID581"><span class="enstr">Iterating over Enumeration Cases</span><!--end_enstr-->
<span class="jpstr">
列挙ケース節の全てにわたって反復する
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID148"><span class="enstr">Associated Values</span><!--end_enstr-->
<span class="jpstr">
関連値
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID149"><span class="enstr">Raw Values</span><!--end_enstr-->
<span class="jpstr">
生の値
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID535"><span class="enstr">Implicitly Assigned Raw Values</span><!--end_enstr-->
<span class="jpstr">
暗黙的に割り当てられる生の値
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID150"><span class="enstr">Initializing from a Raw Value</span><!--end_enstr-->
<span class="jpstr">
生の値から初期化する
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID536"><span class="enstr">Recursive Enumerations</span><!--end_enstr-->
<span class="jpstr">
再帰列挙
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
</ul>

            </menu>
            </menuitem>
          </div>
        </menu>

        
  <div class="section" id="enumerations">
<h1><span class="enstr">Enumerations<a class="headerlink" href="#enumerations" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
列挙<a class="headerlink" href="#enumerations" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h1>
<p><span class="enstr">An <em>enumeration</em> defines a common type for a group of related values and enables you to work with those values in a type-safe way within your code.</span><!--end_enstr-->
<span class="jpstr">
<em>列挙</em>は、一群の関連した値のための共通の型を定義して、それらの値を型安全な方法であなたのコード内で扱えるようにします。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">If you are familiar with C, you will know that C enumerations assign related names to a set of integer values. Enumerations in Swift are much more flexible, and don’t have to provide a value for each case of the enumeration. If a value (known as a <em>raw</em> value) is provided for each enumeration case, the value can be a string, a character, or a value of any integer or floating-point type.</span><!--end_enstr-->
<span class="jpstr">
あなたがCに精通しているならば、あなたはCの列挙がひとまとめの整数値それぞれに対して関連した名前を割り当てるということを知っています。スウィフトの列挙は、ずっと柔軟で、列挙のケース節の各々に値を与える必要はありません。値（<em>raw</em>の値として知られるもの）が列挙のケース節の各々のために提供されている場合には、その値は文字列、文字、またはあらゆる整数または浮動小数点型の値であることができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Alternatively, enumeration cases can specify associated values of <em>any</em> type to be stored along with each different case value, much as unions or variants do in other languages. You can define a common set of related cases as part of one enumeration, each of which has a different set of values of appropriate types associated with it.</span><!--end_enstr-->
<span class="jpstr">
代わりに、列挙ケース節は、ほとんど他の言語における共用体型やバリアント型がするように、それぞれ異なるケース節の値と一緒に格納されるために、<em>あらゆる</em>型の関連値を指定することが出来ます。あなたは、１つの列挙の一部として、関連したケース節のよくある集合を定義することができます、そのそれぞれはそれと結びつけられる適切な型の値の集合をそれぞれ別に持ちます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Enumerations in Swift are first-class types in their own right. They adopt many features traditionally supported only by classes, such as computed properties to provide additional information about the enumeration’s current value, and instance methods to provide functionality related to the values the enumeration represents. Enumerations can also define initializers to provide an initial case value; can be extended to expand their functionality beyond their original implementation; and can conform to protocols to provide standard functionality.</span><!--end_enstr-->
<span class="jpstr">
スウィフトの列挙は、れっきとした第一級の型です。それらはクラスによってのみ伝統的に支えられる多くの特徴を採用します、例えば列挙の現在の値に関する追加の情報を提供する計算プロパティ、そして、列挙が表す値に関連した機能性を提供するインスタンスメソッドなど。列挙は、さらに、最初のケース節値を提供するためにイニシャライザを定義することができます；それらの本来の実装を越えてそれらの機能性を広げるために拡張されることができます；そして、標準の機能性を提供するためにプロトコルに準拠することができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">For more about these capabilities, see <a class="reference internal" href="Properties.html"><span class="doc">Properties</span></a>, <a class="reference internal" href="Methods.html"><span class="doc">Methods</span></a>, <a class="reference internal" href="Initialization.html"><span class="doc">Initialization</span></a>, <a class="reference internal" href="Extensions.html"><span class="doc">Extensions</span></a>, and <a class="reference internal" href="Protocols.html"><span class="doc">Protocols</span></a>.</span><!--end_enstr-->
<span class="jpstr">
これらの能力に関する詳細は、<a class="reference internal" href="Properties.html"><span class="doc">プロパティ</span></a>、<a class="reference internal" href="Methods.html"><span class="doc">メソッド</span></a>、<a class="reference internal" href="Initialization.html"><span class="doc">初期化</span></a>、<a class="reference internal" href="Extensions.html"><span class="doc">拡張</span></a>、そして<a class="reference internal" href="Protocols.html"><span class="doc">プロトコル</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID146">
<h2><span class="enstr">Enumeration Syntax<a class="headerlink" href="#ID146" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
列挙構文<a class="headerlink" href="#ID146" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">You introduce enumerations with the <code class="docutils literal notranslate"><span class="pre">enum</span></code> keyword and place their entire definition within a pair of braces:</span><!--end_enstr-->
<span class="jpstr">
あなたは、列挙を<code class="docutils literal notranslate"><span class="pre">enum</span></code>キーワードで始めて、一対の波括弧の内側にそれらの全ての定義を置きます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">SomeEnumeration</span> {
</li><li>    <span class="c"><span class="enstr">// enumeration definition goes here</span><!--end_enstr--><span class="jpstr">（列挙定義がここにきます）</span><!--end_jpstr--></span>
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">Here’s an example for the four main points of a compass:</span><!--end_enstr-->
<span class="jpstr">
ここに、コンパスの主な４方位のための例があります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">CompassPoint</span> {
</li><li>    <span class="k">case</span> <span class="nv">north</span>
</li><li>    <span class="k">case</span> <span class="nv">south</span>
</li><li>    <span class="k">case</span> <span class="nv">east</span>
</li><li>    <span class="k">case</span> <span class="nv">west</span>
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">The values defined in an enumeration (such as <code class="docutils literal notranslate"><span class="pre">north</span></code>, <code class="docutils literal notranslate"><span class="pre">south</span></code>, <code class="docutils literal notranslate"><span class="pre">east</span></code>, and <code class="docutils literal notranslate"><span class="pre">west</span></code>) are its <em>enumeration cases</em>. You use the <code class="docutils literal notranslate"><span class="pre">case</span></code> keyword to introduce new enumeration cases.</span><!--end_enstr-->
<span class="jpstr">
列挙で定義される値（例えば<code class="docutils literal notranslate"><span class="pre">north</span></code>、<code class="docutils literal notranslate"><span class="pre">south</span></code>、<code class="docutils literal notranslate"><span class="pre">east</span></code>、そして<code class="docutils literal notranslate"><span class="pre">west</span></code>）は、それの<em>列挙ケース節</em>です。あなたは<code class="docutils literal notranslate"><span class="pre">case</span></code>キーワードを使って、新しい列挙ケース節を導入することができます。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Swift enumeration cases don’t have an integer value set by default, unlike languages like C and Objective-C. In the <code class="docutils literal notranslate"><span class="pre">CompassPoint</span></code> example above, <code class="docutils literal notranslate"><span class="pre">north</span></code>, <code class="docutils literal notranslate"><span class="pre">south</span></code>, <code class="docutils literal notranslate"><span class="pre">east</span></code> and <code class="docutils literal notranslate"><span class="pre">west</span></code> don’t implicitly equal <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">2</span></code> and <code class="docutils literal notranslate"><span class="pre">3</span></code>. Instead, the different enumeration cases are values in their own right, with an explicitly defined type of <code class="docutils literal notranslate"><span class="pre">CompassPoint</span></code>.</span><!--end_enstr-->
<span class="jpstr">
スウィフト列挙は、CおよびObjective-Cのような言語と違い、初期状態で設定される整数値を持ちません。上の<code class="docutils literal notranslate"><span class="pre">CompassPoint</span></code>例で、<code class="docutils literal notranslate"><span class="pre">north</span></code>、<code class="docutils literal notranslate"><span class="pre">south</span></code>、<code class="docutils literal notranslate"><span class="pre">east</span></code>そして<code class="docutils literal notranslate"><span class="pre">west</span></code>は、暗黙のうちに<code class="docutils literal notranslate"><span class="pre">0</span></code>、<code class="docutils literal notranslate"><span class="pre">1</span></code>、<code class="docutils literal notranslate"><span class="pre">2</span></code>そして<code class="docutils literal notranslate"><span class="pre">3</span></code>に等しくはありません。その代わりに、異なる列挙ケース節それらは、ある明示的に定義された<code class="docutils literal notranslate"><span class="pre">CompassPoint</span></code>の型を持つ、自分だけのものである値です。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">Multiple cases can appear on a single line, separated by commas:</span><!--end_enstr-->
<span class="jpstr">
複数のケース節は、コンマで区切られて、ただ１つの行に現れることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">Planet</span> {
</li><li>    <span class="k">case</span> <span class="nv">mercury</span>, <span class="nv">venus</span>, <span class="nv">earth</span>, <span class="nv">mars</span>, <span class="nv">jupiter</span>, <span class="nv">saturn</span>, <span class="nv">uranus</span>, <span class="nv">neptune</span>
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">Each enumeration definition defines a new type. Like other types in Swift, their names (such as <code class="docutils literal notranslate"><span class="pre">CompassPoint</span></code> and <code class="docutils literal notranslate"><span class="pre">Planet</span></code>) start with a capital letter. Give enumeration types singular rather than plural names, so that they read as self-evident:</span><!--end_enstr-->
<span class="jpstr">
各列挙定義は、ある新しい型を定義します。スウィフトにおける他の型のように、それらの名前（例えば<code class="docutils literal notranslate"><span class="pre">CompassPoint</span></code>および<code class="docutils literal notranslate"><span class="pre">Planet</span></code>）は、大文字から始まります。列挙型に複数形よりむしろ単数形の名前を与えてください、わかりきったことという印象を受けるので：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">directionToHead</span> = <span class="nv">CompassPoint</span>.<span class="nv">west</span>
</li></ol></div></div></div>
<p><span class="enstr">The type of <code class="docutils literal notranslate"><span class="pre">directionToHead</span></code> is inferred when it’s initialized with one of the possible values of <code class="docutils literal notranslate"><span class="pre">CompassPoint</span></code>. Once <code class="docutils literal notranslate"><span class="pre">directionToHead</span></code> is declared as a <code class="docutils literal notranslate"><span class="pre">CompassPoint</span></code>, you can set it to a different <code class="docutils literal notranslate"><span class="pre">CompassPoint</span></code> value using a shorter dot syntax:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">directionToHead</span></code>の型は、それが<code class="docutils literal notranslate"><span class="pre">CompassPoint</span></code>の可能な値のうちの１つで初期化されるとき、推論されます。一旦<code class="docutils literal notranslate"><span class="pre">directionToHead</span></code>が、ある<code class="docutils literal notranslate"><span class="pre">CompassPoint</span></code>として宣言されるならば、あなたはそれをより短いドット構文を使って、異なる<code class="docutils literal notranslate"><span class="pre">CompassPoint</span></code>値に設定することができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">directionToHead</span> = .<span class="nv">east</span>
</li></ol></div></div></div>
<p><span class="enstr">The type of <code class="docutils literal notranslate"><span class="pre">directionToHead</span></code> is already known, and so you can drop the type when setting its value. This makes for highly readable code when working with explicitly typed enumeration values.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">directionToHead</span></code>の型はすでに知られています、それでその値を設定するとき、あなたは型を省くことができます。これは、明示的に型指定された列挙値を扱う場合に、非常に可読性の高いコードにします。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID147">
<h2><span class="enstr">Matching Enumeration Values with a Switch Statement<a class="headerlink" href="#ID147" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
列挙値をスイッチ文で照合する<a class="headerlink" href="#ID147" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">You can match individual enumeration values with a <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement:</span><!--end_enstr-->
<span class="jpstr">
あなたは、<code class="docutils literal notranslate"><span class="pre">switch</span></code>文を使って個々の列挙値を照合することができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">directionToHead</span> = .<span class="nv">south</span>
</li><li><span class="k">switch</span> <span class="nv">directionToHead</span> {
</li><li><span class="k">case</span> .<span class="nv">north</span>:
</li><li>    <span class="nv">print</span>(<span class="s">"Lots of planets have a north"</span>)
</li><li><span class="k">case</span> .<span class="nv">south</span>:
</li><li>    <span class="nv">print</span>(<span class="s">"Watch out for penguins"</span>)
</li><li><span class="k">case</span> .<span class="nv">east</span>:
</li><li>    <span class="nv">print</span>(<span class="s">"Where the sun rises"</span>)
</li><li><span class="k">case</span> .<span class="nv">west</span>:
</li><li>    <span class="nv">print</span>(<span class="s">"Where the skies are blue"</span>)
</li><li>}
</li><li><span class="c"><span class="enstr">// Prints "Watch out for penguins"</span><!--end_enstr--><span class="jpstr">（「ペンギンに気をつけろ」を出力します）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">You can read this code as:</span><!--end_enstr-->
<span class="jpstr">
あなたは、このコードを次のように読むことができます：
</span><!--end_jpstr-->
</p>
<p><span class="enstr">“Consider the value of <code class="docutils literal notranslate"><span class="pre">directionToHead</span></code>. In the case where it equals <code class="docutils literal notranslate"><span class="pre">.north</span></code>, print <code class="docutils literal notranslate"><span class="pre">"Lots</span> <span class="pre">of</span> <span class="pre">planets</span> <span class="pre">have</span> <span class="pre">a</span> <span class="pre">north"</span></code>. In the case where it equals <code class="docutils literal notranslate"><span class="pre">.south</span></code>, print <code class="docutils literal notranslate"><span class="pre">"Watch</span> <span class="pre">out</span> <span class="pre">for</span> <span class="pre">penguins"</span></code>.”</span><!--end_enstr-->
<span class="jpstr">
「<code class="docutils literal notranslate"><span class="pre">directionToHead</span></code>の値を考慮する。それが<code class="docutils literal notranslate"><span class="pre">.north</span></code>に等しい場合には、<code class="docutils literal notranslate"><span class="pre">"Lots</span> <span class="pre">of</span> <span class="pre">planets</span> <span class="pre">have</span> <span class="pre">a</span> <span class="pre">north"</span></code>を出力する。それが<code class="docutils literal notranslate"><span class="pre">.south</span></code>に等しい場合には、<code class="docutils literal notranslate"><span class="pre">"Watch</span> <span class="pre">out</span> <span class="pre">for</span> <span class="pre">penguins"</span></code>を出力する。」
</span><!--end_jpstr-->
</p>
<p><span class="enstr">…and so on.</span><!--end_enstr-->
<span class="jpstr">
…などなど。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">As described in <a class="reference internal" href="ControlFlow.html"><span class="doc">Control Flow</span></a>, a <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement must be exhaustive when considering an enumeration’s cases. If the <code class="docutils literal notranslate"><span class="pre">case</span></code> for <code class="docutils literal notranslate"><span class="pre">.west</span></code> is omitted, this code doesn’t compile, because it doesn’t consider the complete list of <code class="docutils literal notranslate"><span class="pre">CompassPoint</span></code> cases. Requiring exhaustiveness ensures that enumeration cases aren’t accidentally omitted.</span><!--end_enstr-->
<span class="jpstr">
<a class="reference internal" href="ControlFlow.html"><span class="doc">制御の流れ</span></a>で記述されるように、<code class="docutils literal notranslate"><span class="pre">switch</span></code>文は列挙のケース節を考慮するとき、徹底的でなければなりません。<code class="docutils literal notranslate"><span class="pre">.west</span></code>のための<code class="docutils literal notranslate"><span class="pre">case</span></code>が省略されるならば、このコードはコンパイルしません、なぜなら、それが<code class="docutils literal notranslate"><span class="pre">CompassPoint</span></code>のケース節の完全なリストを考慮しないからです。網羅性を要求することは、列挙ケース節のどれかがうっかり書き落とされないことを確実にします。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">When it isn’t appropriate to provide a <code class="docutils literal notranslate"><span class="pre">case</span></code> for every enumeration case, you can provide a <code class="docutils literal notranslate"><span class="pre">default</span></code> case to cover any cases that aren’t addressed explicitly:</span><!--end_enstr-->
<span class="jpstr">
すべての列挙ケース節に<code class="docutils literal notranslate"><span class="pre">case</span></code>を提供することが妥当でないとき、あなたは明確に指定されないあらゆる場合を扱うために<code class="docutils literal notranslate"><span class="pre">default</span></code>ケース節を提供することができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">somePlanet</span> = <span class="nv">Planet</span>.<span class="nv">earth</span>
</li><li><span class="k">switch</span> <span class="nv">somePlanet</span> {
</li><li><span class="k">case</span> .<span class="nv">earth</span>:
</li><li>    <span class="nv">print</span>(<span class="s">"Mostly harmless"</span>)
</li><li><span class="k">default</span>:
</li><li>    <span class="nv">print</span>(<span class="s">"Not a safe place for humans"</span>)
</li><li>}
</li><li><span class="c"><span class="enstr">// Prints "Mostly harmless"</span><!--end_enstr--><span class="jpstr">（「おおむね無害」を出力します）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID581">
<h2><span class="enstr">Iterating over Enumeration Cases<a class="headerlink" href="#ID581" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
列挙ケース節の全てにわたって反復する<a class="headerlink" href="#ID581" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">For some enumerations, it’s useful to have a collection of all of that enumeration’s cases. You enable this by writing <code class="docutils literal notranslate"><span class="pre">:</span> <span class="pre">CaseIterable</span></code> after the enumeration’s name. Swift exposes a collection of all the cases as an <code class="docutils literal notranslate"><span class="pre">allCases</span></code> property of the enumeration type. Here’s an example:</span><!--end_enstr-->
<span class="jpstr">
いくつかの列挙に対して、その列挙の持つケース節の全てからなるコレクションを持つことは役に立ちます。あなたは、これを<code class="docutils literal notranslate"><span class="pre">:</span> <span class="pre">CaseIterable</span></code>を列挙の名前の後に書くことによって可能にします。スウィフトは、ケース節すべてからなるコレクションを、列挙型の<code class="docutils literal notranslate"><span class="pre">allCases</span></code>プロパティとして公開します。ここにある例があります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">Beverage</span>: <span class="nc">CaseIterable</span> {
</li><li>    <span class="k">case</span> <span class="nv">coffee</span>, <span class="nv">tea</span>, <span class="nv">juice</span>
</li><li>}
</li><li><span class="k">let</span> <span class="nv">numberOfChoices</span> = <span class="nv">Beverage</span>.<span class="nv">allCases</span>.<span class="nv">count</span>
</li><li><span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">numberOfChoices</span><span class="p">)</span><span class="s"> beverages available"</span>)
</li><li><span class="c">// Prints "3 beverages available"</span>
</li></ol></div></div></div>
<p><span class="enstr">In the example above, you write <code class="docutils literal notranslate"><span class="pre">Beverage.allCases</span></code> to access a collection that contains all of the cases of the <code class="docutils literal notranslate"><span class="pre">Beverage</span></code> enumeration. You can use <code class="docutils literal notranslate"><span class="pre">allCases</span></code> like any other collection—the collection’s elements are instances of the enumeration type, so in this case they’re <code class="docutils literal notranslate"><span class="pre">Beverage</span></code> values. The example above counts how many cases there are, and the example below uses a <code class="docutils literal notranslate"><span class="pre">for</span></code>-<code class="docutils literal notranslate"><span class="pre">in</span></code> loop to iterate over all the cases.</span><!--end_enstr-->
<span class="jpstr">
上の例において、あなたは<code class="docutils literal notranslate"><span class="pre">Beverage.allCases</span></code>を書いて、<code class="docutils literal notranslate"><span class="pre">Beverage</span></code>列挙のケース節の全てを含むコレクションにアクセスします。あなたは、<code class="docutils literal notranslate"><span class="pre">allCases</span></code>を何らかの他のコレクションと同様に使うことができます — コレクションの持つ要素は列挙型のインスタンスです、それでこの場合においてそれらは<code class="docutils literal notranslate"><span class="pre">Beverage</span></code>値です。上の例は、どのくらい多くのケース節があるか数えます、そして下の例は、<code class="docutils literal notranslate"><span class="pre">for</span></code>-<code class="docutils literal notranslate"><span class="pre">in</span></code>ループを使って全てのケース節にわたって反復します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">for</span> <span class="nv">beverage</span> <span class="k">in</span> <span class="nv">Beverage</span>.<span class="nv">allCases</span> {
</li><li>    <span class="nv">print</span>(<span class="nv">beverage</span>)
</li><li>}
</li><li><span class="c">// coffee</span>
</li><li><span class="c">// tea</span>
</li><li><span class="c">// juice</span>
</li></ol></div></div></div>
<p><span class="enstr">The syntax used in the examples above marks the enumeration as conforming to the <a class="reference external" href="../../../developer.apple.com/documentation/swift/caseiterable.html"><code class="docutils literal notranslate"><span class="pre">CaseIterable</span></code></a> protocol. For information about protocols, see <a class="reference internal" href="Protocols.html"><span class="doc">Protocols</span></a>.</span><!--end_enstr-->
<span class="jpstr">
上の例において使われる構文は、列挙を<a class="reference external" href="../../../developer.apple.com/documentation/swift/caseiterable.html"><code class="docutils literal notranslate"><span class="pre">CaseIterable</span></code></a>プロトコルに準拠するように印します。プロトコルについての情報として、<a class="reference internal" href="Protocols.html"><span class="doc">プロトコル</span></a>を見てください。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID148">
<h2><span class="enstr">Associated Values<a class="headerlink" href="#ID148" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
関連値<a class="headerlink" href="#ID148" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">The examples in the previous section show how the cases of an enumeration are a defined (and typed) value in their own right. You can set a constant or variable to <code class="docutils literal notranslate"><span class="pre">Planet.earth</span></code>, and check for this value later. However, it’s sometimes useful to be able to store values of other types alongside these case values. This additional information is called an <em>associated value</em>, and it varies each time you use that case as a value in your code.</span><!--end_enstr-->
<span class="jpstr">
前の節での例は、列挙のケース節がどのように自分だけで定義された（そして型付けされた）値であるかについて示します。あなたは、定数または変数を<code class="docutils literal notranslate"><span class="pre">Planet.earth</span></code>に設定することができて、後でその値について調べることができます。しかし、他の型の値をこれらのケース節値の傍らに格納することができることは、時々役に立ちます。この追加的情報は、<em>関連値</em>と呼ばれます、そしてそれは、あなたがそのケース節をある値としてあなたのコードにおいて使うたびに変化します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can define Swift enumerations to store associated values of any given type, and the value types can be different for each case of the enumeration if needed. Enumerations similar to these are known as <em>discriminated unions</em>, <em>tagged unions</em>, or <em>variants</em> in other programming languages.</span><!--end_enstr-->
<span class="jpstr">
あなたはスウィフト列挙を、どんな与えられた型の関連値でも格納するように定義することができます、そして値の型は列挙のケース節それぞれで異なっていることが可能です。これに似ている列挙は、他のプログラミング言語で<em>判別共用体</em>、<em>タグ付き共用体</em>、または<em>バリアント</em>として知られています。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">For example, suppose an inventory tracking system needs to track products by two different types of barcode. Some products are labeled with 1D barcodes in UPC format, which uses the numbers <code class="docutils literal notranslate"><span class="pre">0</span></code> to <code class="docutils literal notranslate"><span class="pre">9</span></code>. Each barcode has a number system digit, followed by five manufacturer code digits and five product code digits. These are followed by a check digit to verify that the code has been scanned correctly:</span><!--end_enstr-->
<span class="jpstr">
例えば、ある在庫追跡システムが、２つの異なる型のバーコードによって製品を追跡する必要があると思ってください。ある製品はUPC形式の一次元バーコードでラベルをつけられます、それは<code class="docutils literal notranslate"><span class="pre">0</span></code>から<code class="docutils literal notranslate"><span class="pre">9</span></code>までの数字を使います。各バーコードは、１つの「ナンバーシステム」桁、それに続く５桁の「製造者コード」そして５桁の「商品コード」を持ちます。これらの後にコードが正しくスキャンされたことを確認するための１つの「チェック」桁が続きます：
</span><!--end_jpstr-->
</p>
<img alt="../_images/barcode_UPC_2x.png" class="align-center" src="../images/barcode_UPC_2x.png" style="width: 252px;" />
<p><span class="enstr">Other products are labeled with 2D barcodes in QR code format, which can use any ISO 8859-1 character and can encode a string up to 2,953 characters long:</span><!--end_enstr-->
<span class="jpstr">
別の製品はQRコード形式の二次元バーコードでラベルをつけられます、それはどんなISO 8859-1の文字でも使うことができて、2,953文字までの長さの文字列をコード化することができます：
</span><!--end_jpstr-->
</p>
<img alt="../_images/barcode_QR_2x.png" class="align-center" src="../images/barcode_QR_2x.png" style="width: 169px;" />
<p><span class="enstr">It’s convenient for an inventory tracking system to store UPC barcodes as a tuple of four integers, and QR code barcodes as a string of any length.</span><!--end_enstr-->
<span class="jpstr">
UPCバーコードを４つの整数のタプルとして、そしてQRコード・バーコードを任意の長さの文字列として格納できるのは、在庫追跡システムにとって便利です。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">In Swift, an enumeration to define product barcodes of either type might look like this:</span><!--end_enstr-->
<span class="jpstr">
スウィフトにおいて、両方の種類の製品バーコードを定義する列挙は、これのように見えるかもしれません：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">Barcode</span> {
</li><li>    <span class="k">case</span> <span class="nv">upc</span>(<span class="nv">Int</span>, <span class="nv">Int</span>, <span class="nv">Int</span>, <span class="nv">Int</span>)
</li><li>    <span class="k">case</span> <span class="nv">qrCode</span>(<span class="nv">String</span>)
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">This can be read as:</span><!--end_enstr-->
<span class="jpstr">
これは、次のように解釈されることができます：
</span><!--end_jpstr-->
</p>
<p><span class="enstr">“Define an enumeration type called <code class="docutils literal notranslate"><span class="pre">Barcode</span></code>, which can take either a value of <code class="docutils literal notranslate"><span class="pre">upc</span></code> with an associated value of type (<code class="docutils literal notranslate"><span class="pre">Int</span></code>, <code class="docutils literal notranslate"><span class="pre">Int</span></code>, <code class="docutils literal notranslate"><span class="pre">Int</span></code>, <code class="docutils literal notranslate"><span class="pre">Int</span></code>), or a value of <code class="docutils literal notranslate"><span class="pre">qrCode</span></code> with an associated value of type <code class="docutils literal notranslate"><span class="pre">String</span></code>.”</span><!--end_enstr-->
<span class="jpstr">
「<code class="docutils literal notranslate"><span class="pre">Barcode</span></code>と呼ばれる列挙型を定義します、それは<code class="docutils literal notranslate"><span class="pre">upc</span></code>の値で型（<code class="docutils literal notranslate"><span class="pre">Int</span></code>、<code class="docutils literal notranslate"><span class="pre">Int</span></code>、<code class="docutils literal notranslate"><span class="pre">Int</span></code>、<code class="docutils literal notranslate"><span class="pre">Int</span></code>）の関連値をもつ、または<code class="docutils literal notranslate"><span class="pre">qrCode</span></code>の値で型<code class="docutils literal notranslate"><span class="pre">String</span></code>の関連値をもつものをとることができます。」
</span><!--end_jpstr-->
</p>
<p><span class="enstr">This definition doesn’t provide any actual <code class="docutils literal notranslate"><span class="pre">Int</span></code> or <code class="docutils literal notranslate"><span class="pre">String</span></code> values—it just defines the <em>type</em> of associated values that <code class="docutils literal notranslate"><span class="pre">Barcode</span></code> constants and variables can store when they’re equal to <code class="docutils literal notranslate"><span class="pre">Barcode.upc</span></code> or <code class="docutils literal notranslate"><span class="pre">Barcode.qrCode</span></code>.</span><!--end_enstr-->
<span class="jpstr">
この定義は、何ら実際の<code class="docutils literal notranslate"><span class="pre">Int</span></code>または<code class="docutils literal notranslate"><span class="pre">String</span></code>値を提供しません ― それは、ただ単に関連値の<em>型</em>を定義します、それは、<code class="docutils literal notranslate"><span class="pre">Barcode</span></code>定数と変数が<code class="docutils literal notranslate"><span class="pre">Barcode.upc</span></code>もしくは<code class="docutils literal notranslate"><span class="pre">Barcode.qrCode</span></code>に等しいときに格納できる型です。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can then create new barcodes using either type:</span><!--end_enstr-->
<span class="jpstr">
あなたはそれから新しいバーコードをどちらかの型を使って作成できます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">productBarcode</span> = <span class="nv">Barcode</span>.<span class="nv">upc</span>(<span class="m">8</span>, <span class="m">85909</span>, <span class="m">51226</span>, <span class="m">3</span>)
</li></ol></div></div></div>
<p><span class="enstr">This example creates a new variable called <code class="docutils literal notranslate"><span class="pre">productBarcode</span></code> and assigns it a value of <code class="docutils literal notranslate"><span class="pre">Barcode.upc</span></code> with an associated tuple value of <code class="docutils literal notranslate"><span class="pre">(8,</span> <span class="pre">85909,</span> <span class="pre">51226,</span> <span class="pre">3)</span></code>.</span><!--end_enstr-->
<span class="jpstr">
この例は、<code class="docutils literal notranslate"><span class="pre">productBarcode</span></code>と呼ばれる新しい変数をつくって、それにあるひとつの<code class="docutils literal notranslate"><span class="pre">Barcode.upc</span></code>の値を関連したタプル値<code class="docutils literal notranslate"><span class="pre">(8,</span> <span class="pre">85909,</span> <span class="pre">51226,</span> <span class="pre">3)</span></code>とともに代入します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can assign the same product a different type of barcode:</span><!--end_enstr-->
<span class="jpstr">
あなたは、同じ商品を異なる型のバーゴードに割り当てることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">productBarcode</span> = .<span class="nv">qrCode</span>(<span class="s">"ABCDEFGHIJKLMNOP"</span>)
</li></ol></div></div></div>
<p><span class="enstr">At this point, the original <code class="docutils literal notranslate"><span class="pre">Barcode.upc</span></code> and its integer values are replaced by the new <code class="docutils literal notranslate"><span class="pre">Barcode.qrCode</span></code> and its string value. Constants and variables of type <code class="docutils literal notranslate"><span class="pre">Barcode</span></code> can store either a <code class="docutils literal notranslate"><span class="pre">.upc</span></code> or a <code class="docutils literal notranslate"><span class="pre">.qrCode</span></code> (together with their associated values), but they can store only one of them at any given time.</span><!--end_enstr-->
<span class="jpstr">
この点で、最初の<code class="docutils literal notranslate"><span class="pre">Barcode.upc</span></code>およびその整数値は、新しい<code class="docutils literal notranslate"><span class="pre">Barcode.qrCode</span></code>およびその文字列値と取り替えられます。型<code class="docutils literal notranslate"><span class="pre">Barcode</span></code>の定数と変数は、<code class="docutils literal notranslate"><span class="pre">.upc</span></code>または<code class="docutils literal notranslate"><span class="pre">.qrCode</span></code>のどちらでも（それらの関連値と共に）格納することができます、しかしそれらはどんな時でもそれらの１つを格納することだけができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can check the different barcode types using a switch statement, similar to the example in <a class="reference internal" href="#ID147"><span class="std std-ref">Matching Enumeration Values with a Switch Statement</span></a>. This time, however, the associated values are extracted as part of the switch statement. You extract each associated value as a constant (with the <code class="docutils literal notranslate"><span class="pre">let</span></code> prefix) or a variable (with the <code class="docutils literal notranslate"><span class="pre">var</span></code> prefix) for use within the <code class="docutils literal notranslate"><span class="pre">switch</span></code> case’s body:</span><!--end_enstr-->
<span class="jpstr">
あなたは、異なるバーコード型それらを、<a class="reference internal" href="#ID147"><span class="std std-ref">列挙値をスイッチ文で照合する</span></a>での例に似たあるスイッチ文を使って調べることができます。今度は、しかし、関連値がスイッチ文の一部として抽出されます。あなたは、関連値それぞれを定数（<code class="docutils literal notranslate"><span class="pre">let</span></code>接頭辞を使って）または変数（<code class="docutils literal notranslate"><span class="pre">var</span></code>接頭辞を使って）として<code class="docutils literal notranslate"><span class="pre">switch</span></code>のケース節の本文内で使用するために抽出します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">switch</span> <span class="nv">productBarcode</span> {
</li><li><span class="k">case</span> .<span class="nv">upc</span>(<span class="k">let</span> <span class="nv">numberSystem</span>, <span class="k">let</span> <span class="nv">manufacturer</span>, <span class="k">let</span> <span class="nv">product</span>, <span class="k">let</span> <span class="nv">check</span>):
</li><li>    <span class="nv">print</span>(<span class="s">"UPC: </span>\<span class="p">(</span><span class="nv">numberSystem</span><span class="p">)</span><span class="s">, </span>\<span class="p">(</span><span class="nv">manufacturer</span><span class="p">)</span><span class="s">, </span>\<span class="p">(</span><span class="nv">product</span><span class="p">)</span><span class="s">, </span>\<span class="p">(</span><span class="nv">check</span><span class="p">)</span><span class="s">."</span>)
</li><li><span class="k">case</span> .<span class="nv">qrCode</span>(<span class="k">let</span> <span class="nv">productCode</span>):
</li><li>    <span class="nv">print</span>(<span class="s">"QR code: </span>\<span class="p">(</span><span class="nv">productCode</span><span class="p">)</span><span class="s">."</span>)
</li><li>}
</li><li><span class="c"><span class="enstr">// Prints "QR code: ABCDEFGHIJKLMNOP."</span><!--end_enstr--><span class="jpstr">（「QRコード：ABCDEFGHIJKLMNOP。」を出力します）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">If all of the associated values for an enumeration case are extracted as constants, or if all are extracted as variables, you can place a single <code class="docutils literal notranslate"><span class="pre">var</span></code> or <code class="docutils literal notranslate"><span class="pre">let</span></code> annotation before the case name, for brevity:</span><!--end_enstr-->
<span class="jpstr">
列挙ケース節の関連値の全てが定数として抽出されるならば、または全てが変数として抽出されるならば、あなたは簡潔に<code class="docutils literal notranslate"><span class="pre">var</span></code>または<code class="docutils literal notranslate"><span class="pre">let</span></code>注釈１つだけをケース節名の前に置くことができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">switch</span> <span class="nv">productBarcode</span> {
</li><li><span class="k">case</span> <span class="k">let</span> .<span class="nv">upc</span>(<span class="nv">numberSystem</span>, <span class="nv">manufacturer</span>, <span class="nv">product</span>, <span class="nv">check</span>):
</li><li>    <span class="nv">print</span>(<span class="s">"UPC : </span>\<span class="p">(</span><span class="nv">numberSystem</span><span class="p">)</span><span class="s">, </span>\<span class="p">(</span><span class="nv">manufacturer</span><span class="p">)</span><span class="s">, </span>\<span class="p">(</span><span class="nv">product</span><span class="p">)</span><span class="s">, </span>\<span class="p">(</span><span class="nv">check</span><span class="p">)</span><span class="s">."</span>)
</li><li><span class="k">case</span> <span class="k">let</span> .<span class="nv">qrCode</span>(<span class="nv">productCode</span>):
</li><li>    <span class="nv">print</span>(<span class="s">"QR code: </span>\<span class="p">(</span><span class="nv">productCode</span><span class="p">)</span><span class="s">."</span>)
</li><li>}
</li><li><span class="c"><span class="enstr">// Prints "QR code: ABCDEFGHIJKLMNOP."</span><!--end_enstr--><span class="jpstr">（「QRコード：ABCDEFGHIJKLMNOP。」を出力します）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID149">
<h2><span class="enstr">Raw Values<a class="headerlink" href="#ID149" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
生の値<a class="headerlink" href="#ID149" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">The barcode example in <a class="reference internal" href="#ID148"><span class="std std-ref">Associated Values</span></a> shows how cases of an enumeration can declare that they store associated values of different types. As an alternative to associated values, enumeration cases can come prepopulated with default values (called <em>raw values</em>), which are all of the same type.</span><!--end_enstr-->
<span class="jpstr">
<a class="reference internal" href="#ID148"><span class="std std-ref">関連値</span></a>におけるバーコード例は、それらが異なる型の関連値を格納することを、ある列挙のケース節それらがどのように宣言可能かを示します。関連値に代わるものとして、列挙ケース節は全て同じ型の（<em>生の値</em>と呼ばれる）初期値があらかじめ入れられた状態であることが出来ます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Here’s an example that stores raw ASCII values alongside named enumeration cases:</span><!--end_enstr-->
<span class="jpstr">
指定した列挙ケース節の傍らに生のASCII値を格納する例は、ここにあります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">ASCIIControlCharacter</span>: <span class="nc">Character</span> {
</li><li>    <span class="k">case</span> <span class="nv">tab</span> = <span class="s">"\t"</span>
</li><li>    <span class="k">case</span> <span class="nv">lineFeed</span> = <span class="s">"\n"</span>
</li><li>    <span class="k">case</span> <span class="nv">carriageReturn</span> = <span class="s">"\r"</span>
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">Here, the raw values for an enumeration called <code class="docutils literal notranslate"><span class="pre">ASCIIControlCharacter</span></code> are defined to be of type <code class="docutils literal notranslate"><span class="pre">Character</span></code>, and are set to some of the more common ASCII control characters. <code class="docutils literal notranslate"><span class="pre">Character</span></code> values are described in <a class="reference internal" href="StringsAndCharacters.html"><span class="doc">Strings and Characters</span></a>.</span><!--end_enstr-->
<span class="jpstr">
ここでは、<code class="docutils literal notranslate"><span class="pre">ASCIIControlCharacter</span></code>と呼ばれる列挙に対する生の値は、型<code class="docutils literal notranslate"><span class="pre">Character</span></code>であると定義されて、たいへんありふれたASCII制御文字のいくつかに設定されます。<code class="docutils literal notranslate"><span class="pre">Character</span></code>値は<a class="reference internal" href="StringsAndCharacters.html"><span class="doc">文字列と文字</span></a>で記述されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Raw values can be strings, characters, or any of the integer or floating-point number types. Each raw value must be unique within its enumeration declaration.</span><!--end_enstr-->
<span class="jpstr">
生の値は、文字列、文字、または何らかの整数や浮動小数点数型であることができます。生の値それぞれは、その列挙宣言の範囲内で固有でなければなりません。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Raw values are <em>not</em> the same as associated values. Raw values are set to prepopulated values when you first define the enumeration in your code, like the three ASCII codes above. The raw value for a particular enumeration case is always the same. Associated values are set when you create a new constant or variable based on one of the enumeration’s cases, and can be different each time you do so.</span><!--end_enstr-->
<span class="jpstr">
生の値は、関連値と同じもので<em>ない</em>点に注意してください。生の値は、上の３つのASCIIコードの様に、あなたがあなたのコードにおいて最初に列挙を定義するとき、あらかじめ入れられた値に設定されます。特定の列挙ケース節のための生の値は、常に同じものです。関連値は、あなたが列挙のケース節のうちの１つに基づいて新しい定数または変数を作るときに設定されます、そしてあなたがそうするたびに違ったものにすることが出来ます。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID535">
<h3><span class="enstr">Implicitly Assigned Raw Values<a class="headerlink" href="#ID535" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
暗黙的に割り当てられる生の値<a class="headerlink" href="#ID535" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p><span class="enstr">When you’re working with enumerations that store integer or string raw values, you don’t have to explicitly assign a raw value for each case. When you don’t, Swift automatically assigns the values for you.</span><!--end_enstr-->
<span class="jpstr">
あなたが整数や文字列の生の値を格納する列挙を使って作業している時、あなたは各ケース節に生の値を明示的に割り当てる必要はありません。あなたがそうしない時は、スウィフトはあなたの代わりに自動的に値を割り当てます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">For example, when integers are used for raw values, the implicit value for each case is one more than the previous case. If the first case doesn’t have a value set, its value is <code class="docutils literal notranslate"><span class="pre">0</span></code>.</span><!--end_enstr-->
<span class="jpstr">
例えば、整数が生の値のために使われるとき、各ケース節に対する暗黙の値は、その前のケース節よりも１つ多くなります。最初のケース節が値を設定されないならば、それの値は<code class="docutils literal notranslate"><span class="pre">0</span></code>です。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The enumeration below is a refinement of the earlier <code class="docutils literal notranslate"><span class="pre">Planet</span></code> enumeration, with integer raw values to represent each planet’s order from the sun:</span><!--end_enstr-->
<span class="jpstr">
下の列挙は、以前の<code class="docutils literal notranslate"><span class="pre">Planet</span></code>列挙の改良で、太陽からの各惑星の順番を表す整数の生の値をもちます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">Planet</span>: <span class="nc">Int</span> {
</li><li>    <span class="k">case</span> <span class="nv">mercury</span> = <span class="m">1</span>, <span class="nv">venus</span>, <span class="nv">earth</span>, <span class="nv">mars</span>, <span class="nv">jupiter</span>, <span class="nv">saturn</span>, <span class="nv">uranus</span>, <span class="nv">neptune</span>
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">In the example above, <code class="docutils literal notranslate"><span class="pre">Planet.mercury</span></code> has an explicit raw value of <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">Planet.venus</span></code> has an implicit raw value of <code class="docutils literal notranslate"><span class="pre">2</span></code>, and so on.</span><!--end_enstr-->
<span class="jpstr">
上の例において、<code class="docutils literal notranslate"><span class="pre">Planet.mercury</span></code>は明示的な生の値の<code class="docutils literal notranslate"><span class="pre">1</span></code>を持ちます、<code class="docutils literal notranslate"><span class="pre">Planet.venus</span></code>は暗黙的な生の値の<code class="docutils literal notranslate"><span class="pre">2</span></code>を持ちます、等々。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">When strings are used for raw values, the implicit value for each case is the text of that case’s name.</span><!--end_enstr-->
<span class="jpstr">
文字列が生の値のために使われる時、各ケース節のための暗黙的な値は、そのケース節の名前のテキストです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The enumeration below is a refinement of the earlier <code class="docutils literal notranslate"><span class="pre">CompassPoint</span></code> enumeration, with string raw values to represent each direction’s name:</span><!--end_enstr-->
<span class="jpstr">
以下の列挙は、前の<code class="docutils literal notranslate"><span class="pre">CompassPoint</span></code>列挙の改良版で、各方位の名前を表す文字列の生の値を持ちます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">CompassPoint</span>: <span class="nc">String</span> {
</li><li>    <span class="k">case</span> <span class="nv">north</span>, <span class="nv">south</span>, <span class="nv">east</span>, <span class="nv">west</span>
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">In the example above, <code class="docutils literal notranslate"><span class="pre">CompassPoint.south</span></code> has an implicit raw value of <code class="docutils literal notranslate"><span class="pre">"south"</span></code>, and so on.</span><!--end_enstr-->
<span class="jpstr">
上の例において、<code class="docutils literal notranslate"><span class="pre">CompassPoint.south</span></code>は暗黙的な生の値の<code class="docutils literal notranslate"><span class="pre">"south"</span></code>をもちます、等々。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You access the raw value of an enumeration case with its <code class="docutils literal notranslate"><span class="pre">rawValue</span></code> property:</span><!--end_enstr-->
<span class="jpstr">
ある列挙ケース節の生の値にそれの<code class="docutils literal notranslate"><span class="pre">rawValue</span></code>プロパティでアクセスしてください：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">earthsOrder</span> = <span class="nv">Planet</span>.<span class="nv">earth</span>.<span class="nv">rawValue</span>
</li><li><span class="c"><span class="enstr">// earthsOrder is 3</span><!--end_enstr--><span class="jpstr">（earthsOrderは、３です）</span><!--end_jpstr--></span>
</li><li>
</li><li><span class="k">let</span> <span class="nv">sunsetDirection</span> = <span class="nv">CompassPoint</span>.<span class="nv">west</span>.<span class="nv">rawValue</span>
</li><li><span class="c"><span class="enstr">// sunsetDirection is "west"</span><!--end_enstr--><span class="jpstr">（sunsetDirectionは、「west」です）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID150">
<h3><span class="enstr">Initializing from a Raw Value<a class="headerlink" href="#ID150" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
生の値から初期化する<a class="headerlink" href="#ID150" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p><span class="enstr">If you define an enumeration with a raw-value type, the enumeration automatically receives an initializer that takes a value of the raw value’s type (as a parameter called <code class="docutils literal notranslate"><span class="pre">rawValue</span></code>) and returns either an enumeration case or <code class="docutils literal notranslate"><span class="pre">nil</span></code>. You can use this initializer to try to create a new instance of the enumeration.</span><!--end_enstr-->
<span class="jpstr">
あなたが列挙を「生の値」型を使って定義したならば、その列挙は生の値の方の値を（<code class="docutils literal notranslate"><span class="pre">rawValue</span></code>と呼ばれるパラメーターとして）とって、１つの列挙ケース節か<code class="docutils literal notranslate"><span class="pre">nil</span></code>のどちらかを返すイニシャライザを自動的に受け取ります。あなたは、このイニシャライザを使って、この列挙の新しいインスタンスを作成するように試みることができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">This example identifies Uranus from its raw value of <code class="docutils literal notranslate"><span class="pre">7</span></code>:</span><!--end_enstr-->
<span class="jpstr">
この例は、その生の値の<code class="docutils literal notranslate"><span class="pre">7</span></code>からUranus（天王星）を特定します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">possiblePlanet</span> = <span class="nv">Planet</span>(<span class="nv">rawValue</span>: <span class="m">7</span>)
</li><li><span class="c"><span class="enstr">// possiblePlanet is of type Planet? and equals Planet.uranus</span><!--end_enstr--><span class="jpstr">（possiblePlanetは、型Planet?で、Planet.uranusに等しい）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">Not all possible <code class="docutils literal notranslate"><span class="pre">Int</span></code> values will find a matching planet, however. Because of this, the raw value initializer always returns an <em>optional</em> enumeration case. In the example above, <code class="docutils literal notranslate"><span class="pre">possiblePlanet</span></code> is of type <code class="docutils literal notranslate"><span class="pre">Planet?</span></code>, or “optional <code class="docutils literal notranslate"><span class="pre">Planet</span></code>.”</span><!--end_enstr-->
<span class="jpstr">
しかし、全ての可能な<code class="docutils literal notranslate"><span class="pre">Int</span></code>値が、適合する惑星を見つけるというわけでありません。そのため、生の値のイニシャライザは常に<em>オプショナル</em>の列挙ケース節を返します。上の例で、<code class="docutils literal notranslate"><span class="pre">possiblePlanet</span></code>は型<code class="docutils literal notranslate"><span class="pre">Planet?</span></code>、すなわち「オプショナルの<code class="docutils literal notranslate"><span class="pre">Planet</span></code>」です。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">The raw value initializer is a failable initializer, because not every raw value will return an enumeration case. For more information, see <a class="reference internal" href="../ReferenceManual/Declarations.html#ID376"><span class="std std-ref">Failable Initializers</span></a>.</span><!--end_enstr-->
<span class="jpstr">
生の値のイニシャライザは、失敗できるイニシャライザです、なぜなら、すべての生の値が列挙ケース節を返すわけではないからです。さらなる情報として、<a class="reference internal" href="../ReferenceManual/Declarations.html#ID376"><span class="std std-ref">失敗できるイニシャライザ</span></a>を見てください。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">If you try to find a planet with a position of <code class="docutils literal notranslate"><span class="pre">11</span></code>, the optional <code class="docutils literal notranslate"><span class="pre">Planet</span></code> value returned by the raw value initializer will be <code class="docutils literal notranslate"><span class="pre">nil</span></code>:</span><!--end_enstr-->
<span class="jpstr">
あなたが<code class="docutils literal notranslate"><span class="pre">11</span></code>の位置で惑星を見つけようとするならば、生の値のイニシャライザによって返されるオプショナルの<code class="docutils literal notranslate"><span class="pre">Planet</span></code>値は、<code class="docutils literal notranslate"><span class="pre">nil</span></code>になります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">positionToFind</span> = <span class="m">11</span>
</li><li><span class="k">if</span> <span class="k">let</span> <span class="nv">somePlanet</span> = <span class="nv">Planet</span>(<span class="nv">rawValue</span>: <span class="nv">positionToFind</span>) {
</li><li>    <span class="k">switch</span> <span class="nv">somePlanet</span> {
</li><li>    <span class="k">case</span> .<span class="nv">earth</span>:
</li><li>        <span class="nv">print</span>(<span class="s">"Mostly harmless"</span>)
</li><li>    <span class="k">default</span>:
</li><li>        <span class="nv">print</span>(<span class="s">"Not a safe place for humans"</span>)
</li><li>    }
</li><li>} <span class="k">else</span> {
</li><li>    <span class="nv">print</span>(<span class="s">"There isn't a planet at position </span>\<span class="p">(</span><span class="nv">positionToFind</span><span class="p">)</span><span class="s">"</span>)
</li><li>}
</li><li><span class="c"><span class="enstr">// Prints "There isn't a planet at position 11"</span><!--end_enstr--><span class="jpstr">（「位置11に惑星は存在しない」を出力します）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">This example uses optional binding to try to access a planet with a raw value of <code class="docutils literal notranslate"><span class="pre">11</span></code>. The statement <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">let</span> <span class="pre">somePlanet</span> <span class="pre">=</span> <span class="pre">Planet(rawValue:</span> <span class="pre">11)</span></code> creates an optional <code class="docutils literal notranslate"><span class="pre">Planet</span></code>, and sets <code class="docutils literal notranslate"><span class="pre">somePlanet</span></code> to the value of that optional <code class="docutils literal notranslate"><span class="pre">Planet</span></code> if it can be retrieved. In this case, it isn’t possible to retrieve a planet with a position of <code class="docutils literal notranslate"><span class="pre">11</span></code>, and so the <code class="docutils literal notranslate"><span class="pre">else</span></code> branch is executed instead.</span><!--end_enstr-->
<span class="jpstr">
この例は、<code class="docutils literal notranslate"><span class="pre">11</span></code>の生の値で惑星にアクセスすることを試みるためにオプショナル束縛を使います。文<code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">let</span> <span class="pre">somePlanet</span> <span class="pre">=</span> <span class="pre">Planet(rawValue:</span> <span class="pre">11)</span></code>は、オプショナルの<code class="docutils literal notranslate"><span class="pre">Planet</span></code>を作成して、それが取り出されることができるならば、<code class="docutils literal notranslate"><span class="pre">somePlanet</span></code>をそのオプショナルの<code class="docutils literal notranslate"><span class="pre">Planet</span></code>のもつ値に設定します。この場合、<code class="docutils literal notranslate"><span class="pre">11</span></code>の位置で惑星を取り出すことは可能ではありません、それで<code class="docutils literal notranslate"><span class="pre">else</span></code>分岐が代わりに実行されます。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID536">
<h2><span class="enstr">Recursive Enumerations<a class="headerlink" href="#ID536" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
再帰列挙<a class="headerlink" href="#ID536" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">A <em>recursive enumeration</em> is an enumeration that has another instance of the enumeration as the associated value for one or more of the enumeration cases. You indicate that an enumeration case is recursive by writing <code class="docutils literal notranslate"><span class="pre">indirect</span></code> before it, which tells the compiler to insert the necessary layer of indirection.</span><!--end_enstr-->
<span class="jpstr">
<em>再帰列挙</em>は、１つ以上の列挙ケース節のための関連値としてその列挙の別のインスタンスを持つ列挙です。あなたは、ある列挙ケース節が再帰することをそれの前に<code class="docutils literal notranslate"><span class="pre">indirect</span></code>を書くことによって指し示します、それは、コンパイラに不可欠な間接参照の階層を差し入れるように伝えます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">For example, here is an enumeration that stores simple arithmetic expressions:</span><!--end_enstr-->
<span class="jpstr">
例えば、ここに単純な算術式を格納する列挙があります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">ArithmeticExpression</span> {
</li><li>    <span class="k">case</span> <span class="nv">number</span>(<span class="nv">Int</span>)
</li><li>    <span class="k">indirect</span> <span class="k">case</span> <span class="nv">addition</span>(<span class="nv">ArithmeticExpression</span>, <span class="nv">ArithmeticExpression</span>)
</li><li>    <span class="k">indirect</span> <span class="k">case</span> <span class="nv">multiplication</span>(<span class="nv">ArithmeticExpression</span>, <span class="nv">ArithmeticExpression</span>)
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">You can also write <code class="docutils literal notranslate"><span class="pre">indirect</span></code> before the beginning of the enumeration to enable indirection for all of the enumeration’s cases that have an associated value:</span><!--end_enstr-->
<span class="jpstr">
あなたはまた、列挙の始まりの前に<code class="docutils literal notranslate"><span class="pre">indirect</span></code>を書くことで、列挙の持つケース節で関連値を持つもの全てに対して間接参照を可能にできます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">indirect</span> <span class="k">enum</span> <span class="nv">ArithmeticExpression</span> {
</li><li>    <span class="k">case</span> <span class="nv">number</span>(<span class="nv">Int</span>)
</li><li>    <span class="k">case</span> <span class="nv">addition</span>(<span class="nv">ArithmeticExpression</span>, <span class="nv">ArithmeticExpression</span>)
</li><li>    <span class="k">case</span> <span class="nv">multiplication</span>(<span class="nv">ArithmeticExpression</span>, <span class="nv">ArithmeticExpression</span>)
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">This enumeration can store three kinds of arithmetic expressions: a plain number, the addition of two expressions, and the multiplication of two expressions. The <code class="docutils literal notranslate"><span class="pre">addition</span></code> and <code class="docutils literal notranslate"><span class="pre">multiplication</span></code> cases have associated values that are also arithmetic expressions—these associated values make it possible to nest expressions. For example, the expression <code class="docutils literal notranslate"><span class="pre">(5</span> <span class="pre">+</span> <span class="pre">4)</span> <span class="pre">*</span> <span class="pre">2</span></code> has a number on the right-hand side of the multiplication and another expression on the left-hand side of the multiplication. Because the data is nested, the enumeration used to store the data also needs to support nesting—this means the enumeration needs to be recursive. The code below shows the <code class="docutils literal notranslate"><span class="pre">ArithmeticExpression</span></code> recursive enumeration being created for <code class="docutils literal notranslate"><span class="pre">(5</span> <span class="pre">+</span> <span class="pre">4)</span> <span class="pre">*</span> <span class="pre">2</span></code>:</span><!--end_enstr-->
<span class="jpstr">
この列挙は、３種類の算術式：普通の数字、２つの式の加算、そして２つの式の乗算を格納することができます。<code class="docutils literal notranslate"><span class="pre">addition</span></code>と<code class="docutils literal notranslate"><span class="pre">multiplication</span></code>ケース節は、それもまた算術式である関連値を持ちます—これらの関連値がそれを入れ子式可能なものにします。例えば、式<code class="docutils literal notranslate"><span class="pre">(5</span> <span class="pre">+</span> <span class="pre">4)</span> <span class="pre">*</span> <span class="pre">2</span></code>は、１つの数を掛け算の右手側に、そして別の式を掛け算の左手側に持ちます。データが入れ子にされるため、データを格納するために使われる列挙もまた、入れ子をサポートする必要があります—これは列挙が再帰することを必要とするのを意味します。以下のコードは、<code class="docutils literal notranslate"><span class="pre">(5</span> <span class="pre">+</span> <span class="pre">4)</span> <span class="pre">*</span> <span class="pre">2</span></code>に対して作成されている再帰列挙<code class="docutils literal notranslate"><span class="pre">ArithmeticExpression</span></code>を示します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">five</span> = <span class="nv">ArithmeticExpression</span>.<span class="nv">number</span>(<span class="m">5</span>)
</li><li><span class="k">let</span> <span class="nv">four</span> = <span class="nv">ArithmeticExpression</span>.<span class="nv">number</span>(<span class="m">4</span>)
</li><li><span class="k">let</span> <span class="nv">sum</span> = <span class="nv">ArithmeticExpression</span>.<span class="nv">addition</span>(<span class="nv">five</span>, <span class="nv">four</span>)
</li><li><span class="k">let</span> <span class="nv">product</span> = <span class="nv">ArithmeticExpression</span>.<span class="nv">multiplication</span>(<span class="nv">sum</span>, <span class="nv">ArithmeticExpression</span>.<span class="nv">number</span>(<span class="m">2</span>))
</li></ol></div></div></div>
<p><span class="enstr">A recursive function is a straightforward way to work with data that has a recursive structure. For example, here’s a function that evaluates an arithmetic expression:</span><!--end_enstr-->
<span class="jpstr">
再帰関数は、率直な方法で再帰構造を持つデータを扱います。例えば、ここに算術式の数値を求める関数があります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">evaluate</span>(<span class="k">_</span> <span class="nv">expression</span>: <span class="nc">ArithmeticExpression</span>) -&gt; <span class="nc">Int</span> {
</li><li>    <span class="k">switch</span> <span class="nv">expression</span> {
</li><li>    <span class="k">case</span> <span class="k">let</span> .<span class="nv">number</span>(<span class="nv">value</span>):
</li><li>        <span class="k">return</span> <span class="nv">value</span>
</li><li>    <span class="k">case</span> <span class="k">let</span> .<span class="nv">addition</span>(<span class="nv">left</span>, <span class="nv">right</span>):
</li><li>        <span class="k">return</span> <span class="nv">evaluate</span>(<span class="nv">left</span>) + <span class="nv">evaluate</span>(<span class="nv">right</span>)
</li><li>    <span class="k">case</span> <span class="k">let</span> .<span class="nv">multiplication</span>(<span class="nv">left</span>, <span class="nv">right</span>):
</li><li>        <span class="k">return</span> <span class="nv">evaluate</span>(<span class="nv">left</span>) * <span class="nv">evaluate</span>(<span class="nv">right</span>)
</li><li>    }
</li><li>}
</li><li>
</li><li><span class="nv">print</span>(<span class="nv">evaluate</span>(<span class="nv">product</span>))
</li><li><span class="c">// Prints "18"</span>
</li></ol></div></div></div>
<p><span class="enstr">This function evaluates a plain number by simply returning the associated value. It evaluates an addition or multiplication by evaluating the expression on the left-hand side, evaluating the expression on the right-hand side, and then adding them or multiplying them.</span><!--end_enstr-->
<span class="jpstr">
この関数は、普通の数字を単に関連値を返すことによって評価します。それは加算や乗算を、左手側の式を評価し、右手側の式を評価して、それからそれらを加算や乗算することで評価します。
</span><!--end_jpstr-->
</p>
</div>
</div>


    </article>
    <div class="next_previous">
        <p class="previous"><a href="Closures.html"><span class="enstr">Closures</span><!--end_enstr-->
<span class="jpstr">
クロージャ
</span><!--end_jpstr-->
</a></p>
        <p class="next"><a href="ClassesAndStructures.html"><span class="enstr">Structures and Classes</span><!--end_enstr-->
<span class="jpstr">
構造体とクラス
</span><!--end_jpstr-->
</a></p>
    </div>
    <div class="admonition-beta admonition">
        <p class="first admonition-title">Beta Software</p>
        <p>
          <span class="enstr">This documentation contains preliminary information about an API or technology in development. This information is subject to change, and software implemented according to this documentation should be tested with final operating system software.</span><!--end_enstr-->
<span class="jpstr">
この文書は、開発でのテクノロジーまたはAPIのための事前の情報を含んでいます。この情報は変更される場合があり、この文書に沿って実装されるソフトウェアは最終的なオペレーティングシステム・ソフトウェアでテストされなければなりません。
</span><!--end_jpstr-->

        </p>
        <p class="last"><a class="reference external" href="https://developer.apple.com/support/beta-software/">Learn more about using Apple's beta software</a></p>
    </div>
</main>


<footer role="contentinfo">
  <aside>
    <a href="//swift.org/atom.xml" title="Subscribe to Site Updates"><i class="feed">Subscribe</i></a>
    <a href="https://twitter.com/swiftlang" rel="nofollow" title="Follow @SwiftLang on Twitter"><i class="twitter">Twitter</i></a>
  </aside>

  <p class="copyright">Copyright © 2021 Apple Inc. All rights reserved.</p>
  <p class="trademark">Swift and the Swift logo are trademarks of Apple Inc.</p>
  <p class="privacy">
    <a href="//www.apple.com/privacy/privacy-policy/">Privacy Policy</a>
    <a href="//www.apple.com/legal/privacy/en-ww/cookies/">Cookies</a>
  </p>
</footer>
<div id="jump_to_overlay"></div>
<script src="../static/javascripts/application.js"></script>
  </body>
</html>