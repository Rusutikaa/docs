<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="author" content="Apple Inc.">
    <meta name="viewport" content="width=device-width initial-scale=1">
    
    <title>Initialization — The Swift Programming Language (Swift 5.6)</title>
    
    <link rel="license" href="/LICENSE.txt">
    <link rel="stylesheet" media="all" href="../static/stylesheets/application.css">
    <link rel="stylesheet" media="all" href="../static/stylesheets/tspl.css">
    <link rel="shortcut icon" sizes="16x16 24x24 32x32 48x48 64x64" type="image/vnd.microsoft.icon" href="/favicon.ico">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
    <link rel="mask-icon" href="/assets/images/icon-swift.svg" color="#F05339"> 
  </head>
  <body>


<nav role="navigation">
    <header role="banner">
      <h1 id="logo">
        <a href="https://swift.org/" title="Swift.org" role="img" aria-label="Swift.org">
          Swift.org
        </a>
      </h1>
    </header>

    <div id="menu-toggle" class="menu-toggle open"></div>

    <h2>The Swift Programming Language<div>Swift 5.6</div>
</h2>

    <ul>
    <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html"><span class="enstr">Welcome to Swift</span><!--end_enstr-->
<span class="jpstr">
スウィフトにようこそ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1 current">
<a class="reference internal" href="TheBasics.html"><span class="enstr">Language Guide</span><!--end_enstr-->
<span class="jpstr">
言語ガイド
</span><!--end_jpstr-->
</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="TheBasics.html"><span class="enstr">The Basics</span><!--end_enstr-->
<span class="jpstr">
基本
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="BasicOperators.html"><span class="enstr">Basic Operators</span><!--end_enstr-->
<span class="jpstr">
基本の演算子
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="StringsAndCharacters.html"><span class="enstr">Strings and Characters</span><!--end_enstr-->
<span class="jpstr">
文字列と文字
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="CollectionTypes.html"><span class="enstr">Collection Types</span><!--end_enstr-->
<span class="jpstr">
コレクション型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ControlFlow.html"><span class="enstr">Control Flow</span><!--end_enstr-->
<span class="jpstr">
制御の流れ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Functions.html"><span class="enstr">Functions</span><!--end_enstr-->
<span class="jpstr">
関数
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Closures.html"><span class="enstr">Closures</span><!--end_enstr-->
<span class="jpstr">
クロージャ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Enumerations.html"><span class="enstr">Enumerations</span><!--end_enstr-->
<span class="jpstr">
列挙
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ClassesAndStructures.html"><span class="enstr">Structures and Classes</span><!--end_enstr-->
<span class="jpstr">
構造体とクラス
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Properties.html"><span class="enstr">Properties</span><!--end_enstr-->
<span class="jpstr">
プロパティ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Methods.html"><span class="enstr">Methods</span><!--end_enstr-->
<span class="jpstr">
メソッド
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Subscripts.html"><span class="enstr">Subscripts</span><!--end_enstr-->
<span class="jpstr">
添え字
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Inheritance.html"><span class="enstr">Inheritance</span><!--end_enstr-->
<span class="jpstr">
継承
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#"><span class="enstr">Initialization</span><!--end_enstr-->
<span class="jpstr">
初期化
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Deinitialization.html"><span class="enstr">Deinitialization</span><!--end_enstr-->
<span class="jpstr">
デイニシャライズ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="OptionalChaining.html"><span class="enstr">Optional Chaining</span><!--end_enstr-->
<span class="jpstr">
オプショナル連鎖
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ErrorHandling.html"><span class="enstr">Error Handling</span><!--end_enstr-->
<span class="jpstr">
エラーの処理
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html"><span class="enstr">Concurrency</span><!--end_enstr-->
<span class="jpstr">
並行性
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="TypeCasting.html"><span class="enstr">Type Casting</span><!--end_enstr-->
<span class="jpstr">
型キャスト
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="NestedTypes.html"><span class="enstr">Nested Types</span><!--end_enstr-->
<span class="jpstr">
入れ子にされた型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Extensions.html"><span class="enstr">Extensions</span><!--end_enstr-->
<span class="jpstr">
拡張
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Protocols.html"><span class="enstr">Protocols</span><!--end_enstr-->
<span class="jpstr">
プロトコル
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Generics.html"><span class="enstr">Generics</span><!--end_enstr-->
<span class="jpstr">
総称体
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="OpaqueTypes.html"><span class="enstr">Opaque Types</span><!--end_enstr-->
<span class="jpstr">
不透明型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AutomaticReferenceCounting.html"><span class="enstr">Automatic Reference Counting</span><!--end_enstr-->
<span class="jpstr">
自動参照カウント
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="MemorySafety.html"><span class="enstr">Memory Safety</span><!--end_enstr-->
<span class="jpstr">
メモリ安全
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AccessControl.html"><span class="enstr">Access Control</span><!--end_enstr-->
<span class="jpstr">
アクセス制御
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AdvancedOperators.html"><span class="enstr">Advanced Operators</span><!--end_enstr-->
<span class="jpstr">
先進の演算子
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ReferenceManual/AboutTheLanguageReference.html"><span class="enstr">Language Reference</span><!--end_enstr-->
<span class="jpstr">
言語リファレンス
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1"><a class="reference internal" href="../RevisionHistory/RevisionHistory.html"><span class="enstr">Revision History</span><!--end_enstr-->
<span class="jpstr">
改訂履歴
</span><!--end_jpstr-->
</a></li>
</ul>

    <li class="toctree-l1 return"><a class="reference internal" href="../../../index.html">← Go to Index</a></li>
    </ul>
</nav>




<main role="main">
    <article class="page">
        <menu id="bashful" type="toolbar">
          <div class="inner">
            <menuitem id="jump_to" class="menu-bar-item closed">
            <span id="jump_to_toggle">On This Page</span>
            <div class="chevron">
                <div class="chevy chevron-left"></div>
                <div class="chevy chevron-right"></div>
            </div>
            <menu type="list" class="details">
<ul>
<li>
<a class="reference internal" href="#"><span class="enstr">Initialization</span><!--end_enstr-->
<span class="jpstr">
初期化
</span><!--end_jpstr-->
</a><ul>
<li>
<a class="reference internal" href="#ID204"><span class="enstr">Setting Initial Values for Stored Properties</span><!--end_enstr-->
<span class="jpstr">
初期値を格納プロパティに設定する
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID205"><span class="enstr">Initializers</span><!--end_enstr-->
<span class="jpstr">
イニシャライザ
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID206"><span class="enstr">Default Property Values</span><!--end_enstr-->
<span class="jpstr">
省略時のプロパティ値
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li>
<a class="reference internal" href="#ID207"><span class="enstr">Customizing Initialization</span><!--end_enstr-->
<span class="jpstr">
初期化をカスタマイズする
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID208"><span class="enstr">Initialization Parameters</span><!--end_enstr-->
<span class="jpstr">
初期化パラメータ
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID209"><span class="enstr">Parameter Names and Argument Labels</span><!--end_enstr-->
<span class="jpstr">
パラメータ名と引数ラベル
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID210"><span class="enstr">Initializer Parameters Without Argument Labels</span><!--end_enstr-->
<span class="jpstr">
引数ラベルのないイニシャライザ・パラメータ
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID211"><span class="enstr">Optional Property Types</span><!--end_enstr-->
<span class="jpstr">
オプショナルプロパティ型
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID212"><span class="enstr">Assigning Constant Properties During Initialization</span><!--end_enstr-->
<span class="jpstr">
初期化の間に定数プロパティを割り当てる
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li>
<a class="reference internal" href="#ID213"><span class="enstr">Default Initializers</span><!--end_enstr-->
<span class="jpstr">
省略時のイニシャライザ
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID214"><span class="enstr">Memberwise Initializers for Structure Types</span><!--end_enstr-->
<span class="jpstr">
構造体型のためのメンバー関連イニシャライザ
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID215"><span class="enstr">Initializer Delegation for Value Types</span><!--end_enstr-->
<span class="jpstr">
値型のためのイニシャライザ委任
</span><!--end_jpstr-->
</a></li>
<li>
<a class="reference internal" href="#ID216"><span class="enstr">Class Inheritance and Initialization</span><!--end_enstr-->
<span class="jpstr">
クラス継承と初期化
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID217"><span class="enstr">Designated Initializers and Convenience Initializers</span><!--end_enstr-->
<span class="jpstr">
指定イニシャライザと便宜イニシャライザ
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID218"><span class="enstr">Syntax for Designated and Convenience Initializers</span><!--end_enstr-->
<span class="jpstr">
指定および便宜イニシャライザのための構文
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID219"><span class="enstr">Initializer Delegation for Class Types</span><!--end_enstr-->
<span class="jpstr">
クラス型のためのイニシャライザ委任
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID220"><span class="enstr">Two-Phase Initialization</span><!--end_enstr-->
<span class="jpstr">
２段階初期化
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID221"><span class="enstr">Initializer Inheritance and Overriding</span><!--end_enstr-->
<span class="jpstr">
イニシャライザの継承およびオーバーライド
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID222"><span class="enstr">Automatic Initializer Inheritance</span><!--end_enstr-->
<span class="jpstr">
自動的なイニシャライザ継承
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID223"><span class="enstr">Designated and Convenience Initializers in Action</span><!--end_enstr-->
<span class="jpstr">
指定および便宜イニシャライザの動作
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li>
<a class="reference internal" href="#ID224"><span class="enstr">Failable Initializers</span><!--end_enstr-->
<span class="jpstr">
失敗できるイニシャライザ
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID225"><span class="enstr">Failable Initializers for Enumerations</span><!--end_enstr-->
<span class="jpstr">
列挙のための失敗できるイニシャライザ
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID226"><span class="enstr">Failable Initializers for Enumerations with Raw Values</span><!--end_enstr-->
<span class="jpstr">
生の値を使う列挙のための失敗できるイニシャライザ
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID228"><span class="enstr">Propagation of Initialization Failure</span><!--end_enstr-->
<span class="jpstr">
初期化失敗の伝播
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID229"><span class="enstr">Overriding a Failable Initializer</span><!--end_enstr-->
<span class="jpstr">
失敗できるイニシャライザのオーバーライド
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID230"><span class="enstr">The init! Failable Initializer</span><!--end_enstr-->
<span class="jpstr">
init!失敗できるイニシャライザ
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID231"><span class="enstr">Required Initializers</span><!--end_enstr-->
<span class="jpstr">
必須イニシャライザ
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID232"><span class="enstr">Setting a Default Property Value with a Closure or Function</span><!--end_enstr-->
<span class="jpstr">
省略時のプロパティ値をクロージャまたは関数を使って設定する
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
</ul>

            
                </menu>
            </menuitem>
          </div>
        </menu>

        
  <div class="section" id="initialization">
<h1><span class="enstr">Initialization<a class="headerlink" href="#initialization" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
初期化<a class="headerlink" href="#initialization" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h1>
<p><span class="enstr"><em>Initialization</em> is the process of preparing an instance of a class, structure, or enumeration for use. This process involves setting an initial value for each stored property on that instance and performing any other setup or initialization that’s required before the new instance is ready for use.</span><!--end_enstr-->
<span class="jpstr">
<em>初期化</em>は、クラス、構造体、または列挙のインスタンスを使用するために前準備する処理です。この過程は、そのインスタンスの格納プロパティそれぞれに初期値を設定すること、および新しいインスタンスの使用準備が整う前に必要とされる他のあらゆる設定や初期化を行うことを含みます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You implement this initialization process by defining <em>initializers</em>, which are like special methods that can be called to create a new instance of a particular type. Unlike Objective-C initializers, Swift initializers don’t return a value. Their primary role is to ensure that new instances of a type are correctly initialized before they’re used for the first time.</span><!--end_enstr-->
<span class="jpstr">
あなたはこの初期化処理を<em>イニシャライザ</em>を定義することによって実装します、それは、特定の型の新しいインスタンスをつくるために呼ばれることができる特別なメソッドのようなものです。Objective-Cのイニシャライザと違って、スウィフトのイニシャライザは値を返しません。それらの主要な役割は、ある型の新しいインスタンスが、それらが初めて使われる前に正しく初期化されることを保証することです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Instances of class types can also implement a <em>deinitializer</em>, which performs any custom cleanup just before an instance of that class is deallocated. For more information about deinitializers, see <a class="reference internal" href="Deinitialization.html"><span class="doc">Deinitialization</span></a>.</span><!--end_enstr-->
<span class="jpstr">
クラス型のインスタンスはまた、<em>デイニシャライザ</em>を実装することができます、それは、そのクラスのインスタンスの割り当て解除がされる直前に、何らかのあつらえのクリーンアップ作業を実行します。デイニシャライザの詳細については、<a class="reference internal" href="Deinitialization.html"><span class="doc">デイニシャライザ</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID204">
<h2><span class="enstr">Setting Initial Values for Stored Properties<a class="headerlink" href="#ID204" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
初期値を格納プロパティに設定する<a class="headerlink" href="#ID204" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">Classes and structures <em>must</em> set all of their stored properties to an appropriate initial value by the time an instance of that class or structure is created. Stored properties can’t be left in an indeterminate state.</span><!--end_enstr-->
<span class="jpstr">
クラスと構造体は、それらの格納プロパティの全てを、そのクラスや構造体のインスタンスがつくられる時には適切な初期値に設定する<em>必要があります</em>。格納プロパティは、不確定な状態のままにされることができません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can set an initial value for a stored property within an initializer, or by assigning a default property value as part of the property’s definition. These actions are described in the following sections.</span><!--end_enstr-->
<span class="jpstr">
あなたは、イニシャライザの内部で、またはそのプロパティの定義の一部として省略時のプロパティの値を代入することによって、格納プロパティのために初期値を設定することができます。これらの行いは、以下の節で記述されます。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">When you assign a default value to a stored property, or set its initial value within an initializer, the value of that property is set directly, without calling any property observers.</span><!--end_enstr-->
<span class="jpstr">
あなたがある格納プロパティに省略時の値を代入する、またはその初期値をイニシャライザの内部で設定するとき、そのプロパティの値は、どんなプロパティオブザーバーも呼び出すことなく、直接に設定されます。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID205">
<h3><span class="enstr">Initializers<a class="headerlink" href="#ID205" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
イニシャライザ<a class="headerlink" href="#ID205" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr"><em>Initializers</em> are called to create a new instance of a particular type. In its simplest form, an initializer is like an instance method with no parameters, written using the <code class="docutils literal notranslate"><span class="pre">init</span></code> keyword:</span><!--end_enstr-->
<span class="jpstr">
<em>イニシャライザ</em>は、特定の型の新しいインスタンスをつくるために呼ばれます。その最も単純な形式では、イニシャライザはパラメータのないインスタンスメソッドのようです、そして<code class="docutils literal notranslate"><span class="pre">init</span></code>キーワードを使用して書かれます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">init</span>() {
</li>
<li>    <span class="c"><span class="enstr">// perform some initialization here</span><!--end_enstr--><span class="jpstr">（ここで何らかの初期化を行う）</span><!--end_jpstr--></span>
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">The example below defines a new structure called <code class="docutils literal notranslate"><span class="pre">Fahrenheit</span></code> to store temperatures expressed in the Fahrenheit scale. The <code class="docutils literal notranslate"><span class="pre">Fahrenheit</span></code> structure has one stored property, <code class="docutils literal notranslate"><span class="pre">temperature</span></code>, which is of type <code class="docutils literal notranslate"><span class="pre">Double</span></code>:</span><!--end_enstr-->
<span class="jpstr">
下の例は、<code class="docutils literal notranslate"><span class="pre">Fahrenheit</span></code>と呼ばれる新しい構造体を定義して、華氏尺度で表される温度を格納します。<code class="docutils literal notranslate"><span class="pre">Fahrenheit</span></code>構造体は、１つの格納プロパティ、<code class="docutils literal notranslate"><span class="pre">temperature</span></code>を持ちます、それは<code class="docutils literal notranslate"><span class="pre">Double</span></code>型です：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">struct</span> <span class="nv">Fahrenheit</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">temperature</span>: <span class="nc">Double</span>
</li>
<li>    <span class="k">init</span>() {
</li>
<li>        <span class="nv">temperature</span> = <span class="m">32.0</span>
</li>
<li>    }
</li>
<li>}
</li>
<li><span class="k">var</span> <span class="nv">f</span> = <span class="nv">Fahrenheit</span>()
</li>
<li><span class="nv">print</span>(<span class="s">"The default temperature is </span>\<span class="p">(</span><span class="nv">f</span>.<span class="nv">temperature</span><span class="p">)</span><span class="s">° Fahrenheit"</span>)
</li>
<li><span class="c"><span class="enstr">// Prints "The default temperature is 32.0° Fahrenheit"</span><!--end_enstr--><span class="jpstr">（「省略時の温度は華氏32.0°です」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">The structure defines a single initializer, <code class="docutils literal notranslate"><span class="pre">init</span></code>, with no parameters, which initializes the stored temperature with a value of <code class="docutils literal notranslate"><span class="pre">32.0</span></code> (the freezing point of water in degrees Fahrenheit).</span><!--end_enstr-->
<span class="jpstr">
この構造体は、パラメータのないただ１つのイニシャライザ、<code class="docutils literal notranslate"><span class="pre">init</span></code>を定義します、それは格納された温度を値<code class="docutils literal notranslate"><span class="pre">32.0</span></code>（華氏度数での水の氷点）で初期化します。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID206">
<h3><span class="enstr">Default Property Values<a class="headerlink" href="#ID206" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
省略時のプロパティ値<a class="headerlink" href="#ID206" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">You can set the initial value of a stored property from within an initializer, as shown above. Alternatively, specify a <em>default property value</em> as part of the property’s declaration. You specify a default property value by assigning an initial value to the property when it’s defined.</span><!--end_enstr-->
<span class="jpstr">
あなたはイニシャライザ内から格納プロパティの初期値を設定することが、上で示されるように、行えます。その代わりの方法として、<em>省略時のプロパティ値</em>をそのプロパティの宣言の一部として指定してください。あなたは、それが定義されるときプロパティに初期値を代入することによって、省略時のプロパティ値を指定します。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">If a property always takes the same initial value, provide a default value rather than setting a value within an initializer. The end result is the same, but the default value ties the property’s initialization more closely to its declaration. It makes for shorter, clearer initializers and enables you to infer the type of the property from its default value. The default value also makes it easier for you to take advantage of default initializers and initializer inheritance, as described later in this chapter.</span><!--end_enstr-->
<span class="jpstr">
あるプロパティが常に同じ初期値をとるならば、イニシャライザ内で値を設定することよりむしろ省略時の値を提供してください。最終的な結果は同じものです、しかし省略時の値は、プロパティの初期化をより密接にその宣言に結び付けます。それは、より短い、より明白なイニシャライザを作り、あなたにその省略時の値からプロパティの型を推論するのを可能にします。省略時の値はまた、あなたが省略時のイニシャライザとイニシャライザ継承を活用することをより簡単にします、そのことはこの章の後で記述されます。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">You can write the <code class="docutils literal notranslate"><span class="pre">Fahrenheit</span></code> structure from above in a simpler form by providing a default value for its <code class="docutils literal notranslate"><span class="pre">temperature</span></code> property at the point that the property is declared:</span><!--end_enstr-->
<span class="jpstr">
あなたは、上記の<code class="docutils literal notranslate"><span class="pre">Fahrenheit</span></code>構造体を、その<code class="docutils literal notranslate"><span class="pre">temperature</span></code>プロパティのために省略時の値をそのプロパティが宣言される時点で用意することによって、より単純な形式で書くことができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">struct</span> <span class="nv">Fahrenheit</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">temperature</span> = <span class="m">32.0</span>
</li>
<li>}
</li>
</ol></div></div></div>
</div>
</div>
<div class="section" id="ID207">
<h2><span class="enstr">Customizing Initialization<a class="headerlink" href="#ID207" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
初期化をカスタマイズする<a class="headerlink" href="#ID207" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">You can customize the initialization process with input parameters and optional property types, or by assigning constant properties during initialization, as described in the following sections.</span><!--end_enstr-->
<span class="jpstr">
あなたは、以下の節で記述されるように、入力パラメータとオプショナルプロパティ型を使って、または初期化の間に定数プロパティを割り当てることによって、初期化処理を目的に合わせて作り変えることができます。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID208">
<h3><span class="enstr">Initialization Parameters<a class="headerlink" href="#ID208" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
初期化パラメータ<a class="headerlink" href="#ID208" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">You can provide <em>initialization parameters</em> as part of an initializer’s definition, to define the types and names of values that customize the initialization process. Initialization parameters have the same capabilities and syntax as function and method parameters.</span><!--end_enstr-->
<span class="jpstr">
あなたは、イニシャライザの定義の一部として<em>初期化パラメータ</em>を提供することができます、それによって初期化処理をカスタマイズする値の型と名前を定義します。初期化パラメータは、関数およびメソッドのパラメータと同じ能力と構文を持ちます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The following example defines a structure called <code class="docutils literal notranslate"><span class="pre">Celsius</span></code>, which stores temperatures expressed in degrees Celsius. The <code class="docutils literal notranslate"><span class="pre">Celsius</span></code> structure implements two custom initializers called <code class="docutils literal notranslate"><span class="pre">init(fromFahrenheit:)</span></code> and <code class="docutils literal notranslate"><span class="pre">init(fromKelvin:)</span></code>, which initialize a new instance of the structure with a value from a different temperature scale:</span><!--end_enstr-->
<span class="jpstr">
以下の例は、<code class="docutils literal notranslate"><span class="pre">Celsius</span></code>と呼ばれる構造体を定義します、それは、摂氏度数で表される温度を格納します。<code class="docutils literal notranslate"><span class="pre">Celsius</span></code>構造体は、<code class="docutils literal notranslate"><span class="pre">init(fromFahrenheit:)</span></code>と<code class="docutils literal notranslate"><span class="pre">init(fromKelvin:)</span></code>と呼ばれる２つのあつらえのイニシャライザを実装します、それは、その構造体の新しいインスタンスを異なる温度尺度の値を使って初期化します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">struct</span> <span class="nv">Celsius</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">temperatureInCelsius</span>: <span class="nc">Double</span>
</li>
<li>    <span class="k">init</span>(<span class="nv">fromFahrenheit</span> <span class="nv">fahrenheit</span>: <span class="nc">Double</span>) {
</li>
<li>        <span class="nv">temperatureInCelsius</span> = (<span class="nv">fahrenheit</span> - <span class="m">32.0</span>) / <span class="m">1.8</span>
</li>
<li>    }
</li>
<li>    <span class="k">init</span>(<span class="nv">fromKelvin</span> <span class="nv">kelvin</span>: <span class="nc">Double</span>) {
</li>
<li>        <span class="nv">temperatureInCelsius</span> = <span class="nv">kelvin</span> - <span class="m">273.15</span>
</li>
<li>    }
</li>
<li>}
</li>
<li><span class="k">let</span> <span class="nv">boilingPointOfWater</span> = <span class="nv">Celsius</span>(<span class="nv">fromFahrenheit</span>: <span class="m">212.0</span>)
</li>
<li><span class="c"><span class="enstr">// boilingPointOfWater.temperatureInCelsius is 100.0</span><!--end_enstr--><span class="jpstr">（boilingPointOfWater.temperatureInCelsiusは、100.0です）</span><!--end_jpstr--></span>
</li>
<li><span class="k">let</span> <span class="nv">freezingPointOfWater</span> = <span class="nv">Celsius</span>(<span class="nv">fromKelvin</span>: <span class="m">273.15</span>)
</li>
<li><span class="c"><span class="enstr">// freezingPointOfWater.temperatureInCelsius is 0.0</span><!--end_enstr--><span class="jpstr">（freezingPointOfWater.temperatureInCelsiusは、0.0です）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">The first initializer has a single initialization parameter with an argument label of <code class="docutils literal notranslate"><span class="pre">fromFahrenheit</span></code> and a parameter name of <code class="docutils literal notranslate"><span class="pre">fahrenheit</span></code>. The second initializer has a single initialization parameter with an argument label of <code class="docutils literal notranslate"><span class="pre">fromKelvin</span></code> and a parameter name of <code class="docutils literal notranslate"><span class="pre">kelvin</span></code>. Both initializers convert their single argument into the corresponding Celsius value and store this value in a property called <code class="docutils literal notranslate"><span class="pre">temperatureInCelsius</span></code>.</span><!--end_enstr-->
<span class="jpstr">
最初のイニシャライザは、<code class="docutils literal notranslate"><span class="pre">fromFahrenheit</span></code>の引数ラベルと<code class="docutils literal notranslate"><span class="pre">fahrenheit</span></code>のパラメータ名を使うただ１つの初期化パラメータを持ちます。第二のイニシャライザは、<code class="docutils literal notranslate"><span class="pre">fromKelvin</span></code>の引数ラベルと<code class="docutils literal notranslate"><span class="pre">kelvin</span></code>のパラメータ名を使うただ１つの初期化パラメータを持ちます。両方のイニシャライザは、それらのただ１つの引数を相当する摂氏の値に変えて、その値を<code class="docutils literal notranslate"><span class="pre">temperatureInCelsius</span></code>と呼ばれるプロパティに保管します。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID209">
<h3><span class="enstr">Parameter Names and Argument Labels<a class="headerlink" href="#ID209" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
パラメータ名と引数ラベル<a class="headerlink" href="#ID209" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">As with function and method parameters, initialization parameters can have both a parameter name for use within the initializer’s body and an argument label for use when calling the initializer.</span><!--end_enstr-->
<span class="jpstr">
関数とメソッドのパラメータと同様に、初期化パラメータは、イニシャライザの本文内で使用するためのパラメータ名とイニシャライザを呼ぶ時に使用するための引数ラベルの両方を持つことができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">However, initializers don’t have an identifying function name before their parentheses in the way that functions and methods do. Therefore, the names and types of an initializer’s parameters play a particularly important role in identifying which initializer should be called. Because of this, Swift provides an automatic argument label for <em>every</em> parameter in an initializer if you don’t provide one.</span><!--end_enstr-->
<span class="jpstr">
しかし、イニシャライザは、関数とメソッドがするように識別する関数名をその括弧の前に持ちません。したがって、イニシャライザのパラメータの名前と型は、どのイニシャライザが呼ばれなければならないか識別することにおいて特に重要な役割を演じます。これのため、スウィフトは、あなたがそれを独自に提供しないならば、自動的な引数ラベルをイニシャライザの<em>あらゆる</em>パラメータに用意します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The following example defines a structure called <code class="docutils literal notranslate"><span class="pre">Color</span></code>, with three constant properties called <code class="docutils literal notranslate"><span class="pre">red</span></code>, <code class="docutils literal notranslate"><span class="pre">green</span></code>, and <code class="docutils literal notranslate"><span class="pre">blue</span></code>. These properties store a value between <code class="docutils literal notranslate"><span class="pre">0.0</span></code> and <code class="docutils literal notranslate"><span class="pre">1.0</span></code> to indicate the amount of red, green, and blue in the color.</span><!--end_enstr-->
<span class="jpstr">
以下の例は<code class="docutils literal notranslate"><span class="pre">Color</span></code>と呼ばれる構造体を定義します、それは<code class="docutils literal notranslate"><span class="pre">red</span></code>、<code class="docutils literal notranslate"><span class="pre">green</span></code>、そして<code class="docutils literal notranslate"><span class="pre">blue</span></code>と呼ばれる３つの定数プロパティを使います。これらのプロパティは、<code class="docutils literal notranslate"><span class="pre">0.0</span></code>と<code class="docutils literal notranslate"><span class="pre">1.0</span></code>の間の値を格納して、その色における赤、緑、および青の量を示します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr"><code class="docutils literal notranslate"><span class="pre">Color</span></code> provides an initializer with three appropriately named parameters of type <code class="docutils literal notranslate"><span class="pre">Double</span></code> for its red, green, and blue components. <code class="docutils literal notranslate"><span class="pre">Color</span></code> also provides a second initializer with a single <code class="docutils literal notranslate"><span class="pre">white</span></code> parameter, which is used to provide the same value for all three color components.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Color</span></code>はイニシャライザに、それの赤、緑、および青の構成要素に対する３つの適切に命名された型<code class="docutils literal notranslate"><span class="pre">Double</span></code>のパラメータを提供します。<code class="docutils literal notranslate"><span class="pre">Color</span></code>はまた、ただ１つの<code class="docutils literal notranslate"><span class="pre">white</span></code>パラメータを持つ第２のイニシャライザを提供します、それは３つの色構成要素すべてに同じ値を提供するのに使用されます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">struct</span> <span class="nv">Color</span> {
</li>
<li>    <span class="k">let</span> <span class="nv">red</span>, <span class="nv">green</span>, <span class="nv">blue</span>: <span class="nc">Double</span>
</li>
<li>    <span class="k">init</span>(<span class="nv">red</span>: <span class="nc">Double</span>, <span class="nv">green</span>: <span class="nc">Double</span>, <span class="nv">blue</span>: <span class="nc">Double</span>) {
</li>
<li>        <span class="k">self</span>.<span class="nv">red</span>   = <span class="nv">red</span>
</li>
<li>        <span class="k">self</span>.<span class="nv">green</span> = <span class="nv">green</span>
</li>
<li>        <span class="k">self</span>.<span class="nv">blue</span>  = <span class="nv">blue</span>
</li>
<li>    }
</li>
<li>    <span class="k">init</span>(<span class="nv">white</span>: <span class="nc">Double</span>) {
</li>
<li>        <span class="nv">red</span>   = <span class="nv">white</span>
</li>
<li>        <span class="nv">green</span> = <span class="nv">white</span>
</li>
<li>        <span class="nv">blue</span>  = <span class="nv">white</span>
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">Both initializers can be used to create a new <code class="docutils literal notranslate"><span class="pre">Color</span></code> instance, by providing named values for each initializer parameter:</span><!--end_enstr-->
<span class="jpstr">
両方のイニシャライザとも、新しい<code class="docutils literal notranslate"><span class="pre">Color</span></code>インスタンスを作成するために、各イニシャライザ・パラメータに名前を付けられた値を提供することで、使用されることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">let</span> <span class="nv">magenta</span> = <span class="nv">Color</span>(<span class="nv">red</span>: <span class="m">1.0</span>, <span class="nv">green</span>: <span class="m">0.0</span>, <span class="nv">blue</span>: <span class="m">1.0</span>)
</li>
<li><span class="k">let</span> <span class="nv">halfGray</span> = <span class="nv">Color</span>(<span class="nv">white</span>: <span class="m">0.5</span>)
</li>
</ol></div></div></div>
<p><span class="enstr">Note that it isn’t possible to call these initializers without using argument labels. Argument labels must always be used in an initializer if they’re defined, and omitting them is a compile-time error:</span><!--end_enstr-->
<span class="jpstr">
引数ラベルを使用することなくこれらのイニシャライザを呼び出すことは可能でない点に注意してください。引数ラベルは、それらが定義されるならば常にイニシャライザで使われなければなりません、そして、それらを省略することはコンパイル時エラーになります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">let</span> <span class="nv">veryGreen</span> = <span class="nv">Color</span>(<span class="m">0.0</span>, <span class="m">1.0</span>, <span class="m">0.0</span>)
</li>
<li><span class="c"><span class="enstr">// this reports a compile-time error - argument labels are required</span><!--end_enstr--><span class="jpstr">（これはコンパイル時エラーを報告します - 引数ラベルが必要とされます）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
</div>
<div class="section" id="ID210">
<h3><span class="enstr">Initializer Parameters Without Argument Labels<a class="headerlink" href="#ID210" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
引数ラベルのないイニシャライザ・パラメータ<a class="headerlink" href="#ID210" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">If you don’t want to use an argument label for an initializer parameter, write an underscore (<code class="docutils literal notranslate"><span class="pre">_</span></code>) instead of an explicit argument label for that parameter to override the default behavior.</span><!--end_enstr-->
<span class="jpstr">
あなたがイニシャライザ・パラメータのために引数ラベルを使うことを望まないならば、そのパラメータに対して明示的な引数ラベルを書くのではなくひとつのアンダーバー（<code class="docutils literal notranslate"><span class="pre">_</span></code>）を書いて、省略時の挙動をオーバーライドしてください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Here’s an expanded version of the <code class="docutils literal notranslate"><span class="pre">Celsius</span></code> example from <a class="reference internal" href="#ID208"><span class="std std-ref">Initialization Parameters</span></a> above, with an additional initializer to create a new <code class="docutils literal notranslate"><span class="pre">Celsius</span></code> instance from a <code class="docutils literal notranslate"><span class="pre">Double</span></code> value that’s already in the Celsius scale:</span><!--end_enstr-->
<span class="jpstr">
ここに上の<a class="reference internal" href="#ID208"><span class="std std-ref">初期化パラメータ</span></a>からの<code class="docutils literal notranslate"><span class="pre">Celsius</span></code>例の拡張版があります、それは追加のイニシャライザを使って、既に摂氏尺度である<code class="docutils literal notranslate"><span class="pre">Double</span></code>値から新しい<code class="docutils literal notranslate"><span class="pre">Celsius</span></code>インスタンスを作ります。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">struct</span> <span class="nv">Celsius</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">temperatureInCelsius</span>: <span class="nc">Double</span>
</li>
<li>    <span class="k">init</span>(<span class="nv">fromFahrenheit</span> <span class="nv">fahrenheit</span>: <span class="nc">Double</span>) {
</li>
<li>        <span class="nv">temperatureInCelsius</span> = (<span class="nv">fahrenheit</span> - <span class="m">32.0</span>) / <span class="m">1.8</span>
</li>
<li>    }
</li>
<li>    <span class="k">init</span>(<span class="nv">fromKelvin</span> <span class="nv">kelvin</span>: <span class="nc">Double</span>) {
</li>
<li>        <span class="nv">temperatureInCelsius</span> = <span class="nv">kelvin</span> - <span class="m">273.15</span>
</li>
<li>    }
</li>
<li>    <span class="k">init</span>(<span class="k">_</span> <span class="nv">celsius</span>: <span class="nc">Double</span>) {
</li>
<li>        <span class="nv">temperatureInCelsius</span> = <span class="nv">celsius</span>
</li>
<li>    }
</li>
<li>}
</li>
<li><span class="k">let</span> <span class="nv">bodyTemperature</span> = <span class="nv">Celsius</span>(<span class="m">37.0</span>)
</li>
<li><span class="c"><span class="enstr">// bodyTemperature.temperatureInCelsius is 37.0</span><!--end_enstr--><span class="jpstr">（bodyTemperature.temperatureInCelsius は 37.0 です）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">The initializer call <code class="docutils literal notranslate"><span class="pre">Celsius(37.0)</span></code> is clear in its intent without the need for an argument label. It’s therefore appropriate to write this initializer as <code class="docutils literal notranslate"><span class="pre">init(_</span> <span class="pre">celsius:</span> <span class="pre">Double)</span></code> so that it can be called by providing an unnamed <code class="docutils literal notranslate"><span class="pre">Double</span></code> value.</span><!--end_enstr-->
<span class="jpstr">
イニシャライザ呼び出し<code class="docutils literal notranslate"><span class="pre">Celsius(37.0)</span></code>は、引数ラベルを必要としなくともその意図は明快です。したがって、適切なのはこのイニシャライザを<code class="docutils literal notranslate"><span class="pre">init(_</span> <span class="pre">celsius:</span> <span class="pre">Double)</span></code>のように書くことであり、それによってそれは名前のない<code class="docutils literal notranslate"><span class="pre">Double</span></code>値を提供することで呼び出されることができます。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID211">
<h3><span class="enstr">Optional Property Types<a class="headerlink" href="#ID211" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
オプショナルプロパティ型<a class="headerlink" href="#ID211" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">If your custom type has a stored property that’s logically allowed to have “no value”—perhaps because its value can’t be set during initialization, or because it’s allowed to have “no value” at some later point—declare the property with an <em>optional</em> type. Properties of optional type are automatically initialized with a value of <code class="docutils literal notranslate"><span class="pre">nil</span></code>, indicating that the property is deliberately intended to have “no value yet” during initialization.</span><!--end_enstr-->
<span class="jpstr">
あなたの特注で作った型が論理的に「無い値」を持つことを許される格納プロパティを ― もしかしたらそれの値が初期化の間に設定されることができないかもしれないため、または後の時点でそれが「無い値」を持つことを許されるため ― 持つならば、そのプロパティを<em>オプショナル</em>の型で宣言してください。オプショナルの型のプロパティは、<code class="docutils literal notranslate"><span class="pre">nil</span></code>の値で自動的に初期化されて、そのプロパティは初期化の時には「まだ無い値」を故意に持つつもりであることを示しています。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The following example defines a class called <code class="docutils literal notranslate"><span class="pre">SurveyQuestion</span></code>, with an optional <code class="docutils literal notranslate"><span class="pre">String</span></code> property called <code class="docutils literal notranslate"><span class="pre">response</span></code>:</span><!--end_enstr-->
<span class="jpstr">
以下の例は、<code class="docutils literal notranslate"><span class="pre">response</span></code>と呼ばれるオプショナルの<code class="docutils literal notranslate"><span class="pre">String</span></code>プロパティで、<code class="docutils literal notranslate"><span class="pre">SurveyQuestion</span></code>と呼ばれるクラスを定義します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">class</span> <span class="nv">SurveyQuestion</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">text</span>: <span class="nc">String</span>
</li>
<li>    <span class="k">var</span> <span class="nv">response</span>: <span class="nc">String</span>?
</li>
<li>    <span class="k">init</span>(<span class="nv">text</span>: <span class="nc">String</span>) {
</li>
<li>        <span class="k">self</span>.<span class="nv">text</span> = <span class="nv">text</span>
</li>
<li>    }
</li>
<li>    <span class="k">func</span> <span class="nv">ask</span>() {
</li>
<li>        <span class="nv">print</span>(<span class="nv">text</span>)
</li>
<li>    }
</li>
<li>}
</li>
<li><span class="k">let</span> <span class="nv">cheeseQuestion</span> = <span class="nv">SurveyQuestion</span>(<span class="nv">text</span>: <span class="s">"Do you like cheese?"</span>)
</li>
<li><span class="nv">cheeseQuestion</span>.<span class="nv">ask</span>()
</li>
<li><span class="c"><span class="enstr">// Prints "Do you like cheese?"</span><!--end_enstr--><span class="jpstr">（「あなたはチーズが好きですか？」を出力します）</span><!--end_jpstr--></span>
</li>
<li><span class="nv">cheeseQuestion</span>.<span class="nv">response</span> = <span class="s">"Yes, I do like cheese."</span>
</li>
</ol></div></div></div>
<p><span class="enstr">The response to a survey question can’t be known until it’s asked, and so the <code class="docutils literal notranslate"><span class="pre">response</span></code> property is declared with a type of <code class="docutils literal notranslate"><span class="pre">String?</span></code>, or “optional <code class="docutils literal notranslate"><span class="pre">String</span></code>”. It’s automatically assigned a default value of <code class="docutils literal notranslate"><span class="pre">nil</span></code>, meaning “no string yet”, when a new instance of <code class="docutils literal notranslate"><span class="pre">SurveyQuestion</span></code> is initialized.</span><!--end_enstr-->
<span class="jpstr">
意識調査への回答は、それが尋ねられるまでは知られることができません、なので<code class="docutils literal notranslate"><span class="pre">response</span></code>プロパティは<code class="docutils literal notranslate"><span class="pre">String?</span></code>の型、すなわち「オプショナルの<code class="docutils literal notranslate"><span class="pre">String</span></code>」を使って宣言されます。それは、<code class="docutils literal notranslate"><span class="pre">SurveyQuestion</span></code>の新しいインスタンスは初期化される時に、「まだ無い文字列」を意味する、省略時の値の<code class="docutils literal notranslate"><span class="pre">nil</span></code>を自動的に代入されます。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID212">
<h3><span class="enstr">Assigning Constant Properties During Initialization<a class="headerlink" href="#ID212" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
初期化の間に定数プロパティを割り当てる<a class="headerlink" href="#ID212" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">You can assign a value to a constant property at any point during initialization, as long as it’s set to a definite value by the time initialization finishes. Once a constant property is assigned a value, it can’t be further modified.</span><!--end_enstr-->
<span class="jpstr">
あなたは、それが初期化終了時にある明確な値に設定されさえするならば、ある値を初期化の間のどの時点ででも定数プロパティに割り当てることができます。いったん定数プロパティが値を割り当てられるならば、それはそれ以上変更されることはできません。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">For class instances, a constant property can be modified during initialization only by the class that introduces it. It can’t be modified by a subclass.</span><!--end_enstr-->
<span class="jpstr">
クラスインスタンスのために、定数プロパティは、それを導入するクラスによってのみ初期化の間に修正されることができます。それは、サブクラスによって修正されることができません。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">You can revise the <code class="docutils literal notranslate"><span class="pre">SurveyQuestion</span></code> example from above to use a constant property rather than a variable property for the <code class="docutils literal notranslate"><span class="pre">text</span></code> property of the question, to indicate that the question doesn’t change once an instance of <code class="docutils literal notranslate"><span class="pre">SurveyQuestion</span></code> is created. Even though the <code class="docutils literal notranslate"><span class="pre">text</span></code> property is now a constant, it can still be set within the class’s initializer:</span><!--end_enstr-->
<span class="jpstr">
あなたは、上記の<code class="docutils literal notranslate"><span class="pre">SurveyQuestion</span></code>例を、変数プロパティではなく定数プロパティを質問の<code class="docutils literal notranslate"><span class="pre">text</span></code>プロパティのために使うように見直して、その質問は一旦<code class="docutils literal notranslate"><span class="pre">SurveyQuestion</span></code>のインスタンスが作成されるならば変化しないことを示すことができます。たとえ<code class="docutils literal notranslate"><span class="pre">text</span></code>プロパティが今や定数であるとしても、それはクラスのイニシャライザの内部ではまだ設定されることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">class</span> <span class="nv">SurveyQuestion</span> {
</li>
<li>    <span class="k">let</span> <span class="nv">text</span>: <span class="nc">String</span>
</li>
<li>    <span class="k">var</span> <span class="nv">response</span>: <span class="nc">String</span>?
</li>
<li>    <span class="k">init</span>(<span class="nv">text</span>: <span class="nc">String</span>) {
</li>
<li>        <span class="k">self</span>.<span class="nv">text</span> = <span class="nv">text</span>
</li>
<li>    }
</li>
<li>    <span class="k">func</span> <span class="nv">ask</span>() {
</li>
<li>        <span class="nv">print</span>(<span class="nv">text</span>)
</li>
<li>    }
</li>
<li>}
</li>
<li><span class="k">let</span> <span class="nv">beetsQuestion</span> = <span class="nv">SurveyQuestion</span>(<span class="nv">text</span>: <span class="s">"How about beets?"</span>)
</li>
<li><span class="nv">beetsQuestion</span>.<span class="nv">ask</span>()
</li>
<li><span class="c"><span class="enstr">// Prints "How about beets?"</span><!--end_enstr--><span class="jpstr">（「赤かぶはどう？」を出力します）</span><!--end_jpstr--></span>
</li>
<li><span class="nv">beetsQuestion</span>.<span class="nv">response</span> = <span class="s">"I also like beets. (But not with cheese.)"</span>
</li>
</ol></div></div></div>
</div>
</div>
<div class="section" id="ID213">
<h2><span class="enstr">Default Initializers<a class="headerlink" href="#ID213" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
省略時のイニシャライザ<a class="headerlink" href="#ID213" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">Swift provides a <em>default initializer</em> for any structure or class that provides default values for all of its properties and doesn’t provide at least one initializer itself. The default initializer simply creates a new instance with all of its properties set to their default values.</span><!--end_enstr-->
<span class="jpstr">
スウィフトは、それのもつプロパティの全てに省略時の値を与えて、ともかく１つのイニシャライザもそれ自身では提供しないあらゆる構造体またはクラスのために、<em>省略時のイニシャライザ</em>を用意します。省略時のイニシャライザは、単に新しいインスタンスを、そのプロパティの全てをそれらの省略時の値に設定することで作成します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">This example defines a class called <code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code>, which encapsulates the name, quantity, and purchase state of an item in a shopping list:</span><!--end_enstr-->
<span class="jpstr">
この例は<code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code>と呼ばれるクラスを定義します、それは、ある購入品目リストにおける名前、量、そしてある項目の購入状態といったものをカプセル化します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">class</span> <span class="nv">ShoppingListItem</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">name</span>: <span class="nc">String</span>?
</li>
<li>    <span class="k">var</span> <span class="nv">quantity</span> = <span class="m">1</span>
</li>
<li>    <span class="k">var</span> <span class="nv">purchased</span> = <span class="k">false</span>
</li>
<li>}
</li>
<li><span class="k">var</span> <span class="nv">item</span> = <span class="nv">ShoppingListItem</span>()
</li>
</ol></div></div></div>
<p><span class="enstr">Because all properties of the <code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code> class have default values, and because it’s a base class with no superclass, <code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code> automatically gains a default initializer implementation that creates a new instance with all of its properties set to their default values. (The <code class="docutils literal notranslate"><span class="pre">name</span></code> property is an optional <code class="docutils literal notranslate"><span class="pre">String</span></code> property, and so it automatically receives a default value of <code class="docutils literal notranslate"><span class="pre">nil</span></code>, even though this value isn’t written in the code.) The example above uses the default initializer for the <code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code> class to create a new instance of the class with initializer syntax, written as <code class="docutils literal notranslate"><span class="pre">ShoppingListItem()</span></code>, and assigns this new instance to a variable called <code class="docutils literal notranslate"><span class="pre">item</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code>クラスの全てのプロパティ省略時の値を持つことから、そしてそれがスーパークラスを持たない基盤クラスであることから、<code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code>は自動的に省略時のイニシャライザ実装を獲得します、それは、それのプロパティの全てをそれらの省略時の値に設定して、新しいインスタンスを作成します。（<code class="docutils literal notranslate"><span class="pre">name</span></code>プロパティはオプショナルの<code class="docutils literal notranslate"><span class="pre">String</span></code>プロパティです、なのでそれは自動的に省略時の値の<code class="docutils literal notranslate"><span class="pre">nil</span></code>を受け取ります、たとえこの値がそのコードに書かれないとしてもです。）上の例は、<code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code>クラスのための省略時のイニシャライザを使って、このクラスの新しいインスタンスを作成します、<code class="docutils literal notranslate"><span class="pre">ShoppingListItem()</span></code>のように書かれる、イニシャライザ構文の所です、そしてこの新しいインスタンスを<code class="docutils literal notranslate"><span class="pre">item</span></code>と呼ばれる変数に代入します。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID214">
<h3><span class="enstr">Memberwise Initializers for Structure Types<a class="headerlink" href="#ID214" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
構造体型のためのメンバー関連イニシャライザ<a class="headerlink" href="#ID214" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">Structure types automatically receive a <em>memberwise initializer</em> if they don’t define any of their own custom initializers. Unlike a default initializer, the structure receives a memberwise initializer even if it has stored properties that don’t have default values.</span><!--end_enstr-->
<span class="jpstr">
構造体型は、それが独自のあつらえのイニシャライザを何ら定義しないならば、自動的に<em>メンバー関連イニシャライザ</em>を受け取ります。省略時のイニシャライザと違って、構造体はメンバー関連イニシャライザを受け取ります、たとえそれが省略時の値を持たない格納プロパティを持つとしても。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The memberwise initializer is a shorthand way to initialize the member properties of new structure instances. Initial values for the properties of the new instance can be passed to the memberwise initializer by name.</span><!--end_enstr-->
<span class="jpstr">
メンバー関連イニシャライザは、新しい構造体インスタンスのメンバープロパティを初期化するための略記方法です。新しいインスタンスのプロパティのための初期値は、名前でメンバー関連イニシャライザに渡されることができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The example below defines a structure called <code class="docutils literal notranslate"><span class="pre">Size</span></code> with two properties called <code class="docutils literal notranslate"><span class="pre">width</span></code> and <code class="docutils literal notranslate"><span class="pre">height</span></code>. Both properties are inferred to be of type <code class="docutils literal notranslate"><span class="pre">Double</span></code> by assigning a default value of <code class="docutils literal notranslate"><span class="pre">0.0</span></code>.</span><!--end_enstr-->
<span class="jpstr">
下の例は、<code class="docutils literal notranslate"><span class="pre">width</span></code>と<code class="docutils literal notranslate"><span class="pre">height</span></code>と呼ばれる２つのプロパティをもつ<code class="docutils literal notranslate"><span class="pre">Size</span></code>と呼ばれる構造体を定義します。両方のプロパティは、省略時の値の<code class="docutils literal notranslate"><span class="pre">0.0</span></code>を代入することによって<code class="docutils literal notranslate"><span class="pre">Double</span></code>型であると推測されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">Size</span></code> structure automatically receives an <code class="docutils literal notranslate"><span class="pre">init(width:height:)</span></code> memberwise initializer, which you can use to initialize a new <code class="docutils literal notranslate"><span class="pre">Size</span></code> instance:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Size</span></code>構造体は自動的にメンバー関連イニシャライザ<code class="docutils literal notranslate"><span class="pre">init(width:height:)</span></code>を受け取ります、それは、あなたが新しい<code class="docutils literal notranslate"><span class="pre">Size</span></code>インスタンスを初期化するために使うことができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">struct</span> <span class="nv">Size</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">width</span> = <span class="m">0.0</span>, <span class="nv">height</span> = <span class="m">0.0</span>
</li>
<li>}
</li>
<li><span class="k">let</span> <span class="nv">twoByTwo</span> = <span class="nv">Size</span>(<span class="nv">width</span>: <span class="m">2.0</span>, <span class="nv">height</span>: <span class="m">2.0</span>)
</li>
</ol></div></div></div>
<p><span class="enstr">When you call a memberwise initializer, you can omit values for any properties that have default values. In the example above, the <code class="docutils literal notranslate"><span class="pre">Size</span></code> structure has a default value for both its <code class="docutils literal notranslate"><span class="pre">height</span></code> and <code class="docutils literal notranslate"><span class="pre">width</span></code> properties. You can omit either property or both properties, and the initializer uses the default value for anything you omit—for example:</span><!--end_enstr-->
<span class="jpstr">
あなたがメンバー関連イニシャライザを呼び出す場合、あなたは省略時の値を持つあらゆるプロパティに対して値を省略できます。上の例において、<code class="docutils literal notranslate"><span class="pre">Size</span></code>構造体は省略時の値をそれの<code class="docutils literal notranslate"><span class="pre">height</span></code>と<code class="docutils literal notranslate"><span class="pre">width</span></code>プロパティの両方に対して持ちます。あなたは、どちらかのプロパティまたは両方のプロパティを省略できます、そしてイニシャライザは省略時の値をあなたが省略するどんなものにも使います — 例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">let</span> <span class="nv">zeroByTwo</span> = <span class="nv">Size</span>(<span class="nv">height</span>: <span class="m">2.0</span>)
</li>
<li><span class="nv">print</span>(<span class="nv">zeroByTwo</span>.<span class="nv">width</span>, <span class="nv">zeroByTwo</span>.<span class="nv">height</span>)
</li>
<li><span class="c">// Prints "0.0 2.0"</span>
</li>
<li>
</li>
<li><span class="k">let</span> <span class="nv">zeroByZero</span> = <span class="nv">Size</span>()
</li>
<li><span class="nv">print</span>(<span class="nv">zeroByZero</span>.<span class="nv">width</span>, <span class="nv">zeroByZero</span>.<span class="nv">height</span>)
</li>
<li><span class="c">// Prints "0.0 0.0"</span>
</li>
</ol></div></div></div>
</div>
</div>
<div class="section" id="ID215">
<h2><span class="enstr">Initializer Delegation for Value Types<a class="headerlink" href="#ID215" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
値型のためのイニシャライザ委任<a class="headerlink" href="#ID215" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">Initializers can call other initializers to perform part of an instance’s initialization. This process, known as <em>initializer delegation</em>, avoids duplicating code across multiple initializers.</span><!--end_enstr-->
<span class="jpstr">
イニシャライザは、あるインスタンスの初期化の一部を実行するために他のイニシャライザを呼ぶことができます。この処理、<em>イニシャライザ委任</em>として知られるものは、複数のイニシャライザにまたがってコードを繰り返し複製することを避けます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The rules for how initializer delegation works, and for what forms of delegation are allowed, are different for value types and class types. Value types (structures and enumerations) don’t support inheritance, and so their initializer delegation process is relatively simple, because they can only delegate to another initializer that they provide themselves. Classes, however, can inherit from other classes, as described in <a class="reference internal" href="Inheritance.html"><span class="doc">Inheritance</span></a>. This means that classes have additional responsibilities for ensuring that all stored properties they inherit are assigned a suitable value during initialization. These responsibilities are described in <a class="reference internal" href="#ID216"><span class="std std-ref">Class Inheritance and Initialization</span></a> below.</span><!--end_enstr-->
<span class="jpstr">
どのようにイニシャライザ委任が働くか、そしてどんな委任の形式が許されるかの規則は、値型とクラス型で異なります。値型（構造体と列挙）は、継承をサポートしません、なので、それらのイニシャライザ委任プロセスは比較的単純です、なぜなら、それらがそれら自身で提供する別のイニシャライザに委任できるだけだからです。クラスはしかし、<a class="reference internal" href="Inheritance.html"><span class="doc">継承</span></a>で記述されるように、他のクラスから継承することができます。これは、クラスが、それが継承する全ての格納プロパティが初期化の間に適切な値を代入されることを確実にすることに対する追加の責任を持つことを意味します。これらの責任は、下記の<a class="reference internal" href="#ID216"><span class="std std-ref">クラス継承と初期化</span></a>で記述されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">For value types, you use <code class="docutils literal notranslate"><span class="pre">self.init</span></code> to refer to other initializers from the same value type when writing your own custom initializers. You can call <code class="docutils literal notranslate"><span class="pre">self.init</span></code> only from within an initializer.</span><!--end_enstr-->
<span class="jpstr">
値型のために、あなたは<code class="docutils literal notranslate"><span class="pre">self.init</span></code>を使って、あなた独自のあつらえのイニシャライザを書くとき同じ値型の他のイニシャライザに言及します。あなたは、<code class="docutils literal notranslate"><span class="pre">self.init</span></code>をイニシャライザ内からだけ呼ぶことができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Note that if you define a custom initializer for a value type, you will no longer have access to the default initializer (or the memberwise initializer, if it’s a structure) for that type. This constraint prevents a situation in which additional essential setup provided in a more complex initializer is accidentally circumvented by someone using one of the automatic initializers.</span><!--end_enstr-->
<span class="jpstr">
あなたがある値型のためにあつらえのイニシャライザを定義するならば、あなたがもはやその型の省略時のイニシャライザに（および、それが構造体の場合には、メンバー関連イニシャライザにも）アクセスをしない点に注意してください。この制約は、あるより複雑なイニシャライザにおいて提供される追加の重要な準備が、自動的なイニシャライザのうちの１つを使う何かによって図らずも回避される状況を防ぎます。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">If you want your custom value type to be initializable with the default initializer and memberwise initializer, and also with your own custom initializers, write your custom initializers in an extension rather than as part of the value type’s original implementation. For more information, see <a class="reference internal" href="Extensions.html"><span class="doc">Extensions</span></a>.</span><!--end_enstr-->
<span class="jpstr">
あなたが、あなたのあつらえの値型に省略時のイニシャライザとメンバー関連イニシャライザで、その上にあなた自身のあつらえのイニシャライザで初期化可能にされて欲しいならば、あなたのあつらえのイニシャライザを値型の元々の実装の一部としてではなく、ある拡張の中で書いてください。詳細は、<a class="reference internal" href="Extensions.html"><span class="doc">拡張</span></a>を見てください。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">The following example defines a custom <code class="docutils literal notranslate"><span class="pre">Rect</span></code> structure to represent a geometric rectangle. The example requires two supporting structures called <code class="docutils literal notranslate"><span class="pre">Size</span></code> and <code class="docutils literal notranslate"><span class="pre">Point</span></code>, both of which provide default values of <code class="docutils literal notranslate"><span class="pre">0.0</span></code> for all of their properties:</span><!--end_enstr-->
<span class="jpstr">
以下の例は、あつらえの<code class="docutils literal notranslate"><span class="pre">Rect</span></code>構造体を定義して、幾何学的な長方形を表わします。この例は、<code class="docutils literal notranslate"><span class="pre">Size</span></code>と<code class="docutils literal notranslate"><span class="pre">Point</span></code>と呼ばれる２つの補助する構造体を必要とします、その両方はそれらのプロパティすべてに<code class="docutils literal notranslate"><span class="pre">0.0</span></code>の省略時の値を提供します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">struct</span> <span class="nv">Size</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">width</span> = <span class="m">0.0</span>, <span class="nv">height</span> = <span class="m">0.0</span>
</li>
<li>}
</li>
<li><span class="k">struct</span> <span class="nv">Point</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">x</span> = <span class="m">0.0</span>, <span class="nv">y</span> = <span class="m">0.0</span>
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">You can initialize the <code class="docutils literal notranslate"><span class="pre">Rect</span></code> structure below in one of three ways—by using its default zero-initialized <code class="docutils literal notranslate"><span class="pre">origin</span></code> and <code class="docutils literal notranslate"><span class="pre">size</span></code> property values, by providing a specific origin point and size, or by providing a specific center point and size. These initialization options are represented by three custom initializers that are part of the <code class="docutils literal notranslate"><span class="pre">Rect</span></code> structure’s definition:</span><!--end_enstr-->
<span class="jpstr">
あなたは、以下の<code class="docutils literal notranslate"><span class="pre">Rect</span></code>構造体を３つの方法のうちの１つで初期化することができます ― それの省略時の０で初期化された<code class="docutils literal notranslate"><span class="pre">origin</span></code>と<code class="docutils literal notranslate"><span class="pre">size</span></code>プロパティ値を使うことによって、特定の原点とサイズを提供することによって、または特定の中心点とサイズを提供することによって。これらの初期化オプションは、<code class="docutils literal notranslate"><span class="pre">Rect</span></code>構造体の定義の一部である３つのあつらえのイニシャライザによって表されます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">struct</span> <span class="nv">Rect</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">origin</span> = <span class="nv">Point</span>()
</li>
<li>    <span class="k">var</span> <span class="nv">size</span> = <span class="nv">Size</span>()
</li>
<li>    <span class="k">init</span>() {}
</li>
<li>    <span class="k">init</span>(<span class="nv">origin</span>: <span class="nc">Point</span>, <span class="nv">size</span>: <span class="nc">Size</span>) {
</li>
<li>        <span class="k">self</span>.<span class="nv">origin</span> = <span class="nv">origin</span>
</li>
<li>        <span class="k">self</span>.<span class="nv">size</span> = <span class="nv">size</span>
</li>
<li>    }
</li>
<li>    <span class="k">init</span>(<span class="nv">center</span>: <span class="nc">Point</span>, <span class="nv">size</span>: <span class="nc">Size</span>) {
</li>
<li>        <span class="k">let</span> <span class="nv">originX</span> = <span class="nv">center</span>.<span class="nv">x</span> - (<span class="nv">size</span>.<span class="nv">width</span> / <span class="m">2</span>)
</li>
<li>        <span class="k">let</span> <span class="nv">originY</span> = <span class="nv">center</span>.<span class="nv">y</span> - (<span class="nv">size</span>.<span class="nv">height</span> / <span class="m">2</span>)
</li>
<li>        <span class="k">self</span>.<span class="nv">init</span>(<span class="nv">origin</span>: <span class="nv">Point</span>(<span class="nv">x</span>: <span class="nv">originX</span>, <span class="nv">y</span>: <span class="nv">originY</span>), <span class="nv">size</span>: <span class="nv">size</span>)
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">The first <code class="docutils literal notranslate"><span class="pre">Rect</span></code> initializer, <code class="docutils literal notranslate"><span class="pre">init()</span></code>, is functionally the same as the default initializer that the structure would have received if it didn’t have its own custom initializers. This initializer has an empty body, represented by an empty pair of curly braces <code class="docutils literal notranslate"><span class="pre">{}</span></code>. Calling this initializer returns a <code class="docutils literal notranslate"><span class="pre">Rect</span></code> instance whose <code class="docutils literal notranslate"><span class="pre">origin</span></code> and <code class="docutils literal notranslate"><span class="pre">size</span></code> properties are both initialized with the default values of <code class="docutils literal notranslate"><span class="pre">Point(x:</span> <span class="pre">0.0,</span> <span class="pre">y:</span> <span class="pre">0.0)</span></code> and <code class="docutils literal notranslate"><span class="pre">Size(width:</span> <span class="pre">0.0,</span> <span class="pre">height:</span> <span class="pre">0.0)</span></code> from their property definitions:</span><!--end_enstr-->
<span class="jpstr">
最初の<code class="docutils literal notranslate"><span class="pre">Rect</span></code>イニシャライザ、<code class="docutils literal notranslate"><span class="pre">init()</span></code>は、構造体が独自のあつらえのイニシャライザを持たない場合に受け取る省略時のイニシャライザと機能的に同じものです。このイニシャライザは、一対の空の波括弧<code class="docutils literal notranslate"><span class="pre">{}</span></code>によって表される空の本文を持ちます。このイニシャライザを呼ぶことは<code class="docutils literal notranslate"><span class="pre">Rect</span></code>インスタンスを返します、それは、<code class="docutils literal notranslate"><span class="pre">origin</span></code>と<code class="docutils literal notranslate"><span class="pre">size</span></code>プロパティが両方ともそれらのプロパティ定義からの省略時の値の<code class="docutils literal notranslate"><span class="pre">Point(x:</span> <span class="pre">0.0,</span> <span class="pre">y:</span> <span class="pre">0.0)</span></code>と<code class="docutils literal notranslate"><span class="pre">Size(width:</span> <span class="pre">0.0,</span> <span class="pre">height:</span> <span class="pre">0.0)</span></code>で初期化されるものです：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">let</span> <span class="nv">basicRect</span> = <span class="nv">Rect</span>()
</li>
<li><span class="c"><span class="enstr">// basicRect's origin is (0.0, 0.0) and its size is (0.0, 0.0)</span><!--end_enstr--><span class="jpstr">（centerRectの原点は(0.0, 0.0)、そのサイズは(0.0, 0.0)です）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">The second <code class="docutils literal notranslate"><span class="pre">Rect</span></code> initializer, <code class="docutils literal notranslate"><span class="pre">init(origin:size:)</span></code>, is functionally the same as the memberwise initializer that the structure would have received if it didn’t have its own custom initializers. This initializer simply assigns the <code class="docutils literal notranslate"><span class="pre">origin</span></code> and <code class="docutils literal notranslate"><span class="pre">size</span></code> argument values to the appropriate stored properties:</span><!--end_enstr-->
<span class="jpstr">
二番目の<code class="docutils literal notranslate"><span class="pre">Rect</span></code>イニシャライザ、<code class="docutils literal notranslate"><span class="pre">init(origin:size:)</span></code>は、構造体が独自のあつらえのイニシャライザを持たない場合に受け取る省略時のメンバー関連イニシャライザと機能的に同じものです。このイニシャライザは、単に引数値<code class="docutils literal notranslate"><span class="pre">origin</span></code>と<code class="docutils literal notranslate"><span class="pre">size</span></code>を適切な格納プロパティに代入します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">let</span> <span class="nv">originRect</span> = <span class="nv">Rect</span>(<span class="nv">origin</span>: <span class="nv">Point</span>(<span class="nv">x</span>: <span class="m">2.0</span>, <span class="nv">y</span>: <span class="m">2.0</span>),
</li>
<li>                      <span class="nv">size</span>: <span class="nv">Size</span>(<span class="nv">width</span>: <span class="m">5.0</span>, <span class="nv">height</span>: <span class="m">5.0</span>))
</li>
<li><span class="c"><span class="enstr">// originRect's origin is (2.0, 2.0) and its size is (5.0, 5.0)</span><!--end_enstr--><span class="jpstr">（centerRectの原点は (2.0, 2.0)、そのサイズは(5.0, 5.0)です）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">The third <code class="docutils literal notranslate"><span class="pre">Rect</span></code> initializer, <code class="docutils literal notranslate"><span class="pre">init(center:size:)</span></code>, is slightly more complex. It starts by calculating an appropriate origin point based on a <code class="docutils literal notranslate"><span class="pre">center</span></code> point and a <code class="docutils literal notranslate"><span class="pre">size</span></code> value. It then calls (or <em>delegates</em>) to the <code class="docutils literal notranslate"><span class="pre">init(origin:size:)</span></code> initializer, which stores the new origin and size values in the appropriate properties:</span><!--end_enstr-->
<span class="jpstr">
第３の<code class="docutils literal notranslate"><span class="pre">Rect</span></code>イニシャライザ、<code class="docutils literal notranslate"><span class="pre">init(center:size:)</span></code>は、わずかにより複雑です。それは、<code class="docutils literal notranslate"><span class="pre">center</span></code>地点と<code class="docutils literal notranslate"><span class="pre">size</span></code>値に基づいて適切な原点を計算することによって始まります。それは、それから<code class="docutils literal notranslate"><span class="pre">init(origin:size:)</span></code>イニシャライザに呼び出し（または<em>委任</em>）をします、それは、新しい原点とサイズ値を適切なプロパティに格納します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">let</span> <span class="nv">centerRect</span> = <span class="nv">Rect</span>(<span class="nv">center</span>: <span class="nv">Point</span>(<span class="nv">x</span>: <span class="m">4.0</span>, <span class="nv">y</span>: <span class="m">4.0</span>),
</li>
<li>                      <span class="nv">size</span>: <span class="nv">Size</span>(<span class="nv">width</span>: <span class="m">3.0</span>, <span class="nv">height</span>: <span class="m">3.0</span>))
</li>
<li><span class="c"><span class="enstr">// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)</span><!--end_enstr--><span class="jpstr">（centerRectの原点は(2.5, 2.5)、そのサイズは(3.0, 3.0)です）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">init(center:size:)</span></code> initializer could have assigned the new values of <code class="docutils literal notranslate"><span class="pre">origin</span></code> and <code class="docutils literal notranslate"><span class="pre">size</span></code> to the appropriate properties itself. However, it’s more convenient (and clearer in intent) for the <code class="docutils literal notranslate"><span class="pre">init(center:size:)</span></code> initializer to take advantage of an existing initializer that already provides exactly that functionality.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">init(center:size:)</span></code>イニシャライザは、それ自体で<code class="docutils literal notranslate"><span class="pre">origin</span></code>と<code class="docutils literal notranslate"><span class="pre">size</span></code>の新しい値を適切なプロパティに代入することができました。しかし、すでに正確にその機能性を提供する既存のイニシャライザを利用するほうが、<code class="docutils literal notranslate"><span class="pre">init(center:size:)</span></code>イニシャライザにとってより便利です（そして意図においてより明白です）。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">For an alternative way to write this example without defining the <code class="docutils literal notranslate"><span class="pre">init()</span></code> and <code class="docutils literal notranslate"><span class="pre">init(origin:size:)</span></code> initializers yourself, see <a class="reference internal" href="Extensions.html"><span class="doc">Extensions</span></a>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">init()</span></code>と<code class="docutils literal notranslate"><span class="pre">init(origin:size:)</span></code>イニシャライザをあなた自身で定義することなくこの例を書く代わりの方法のために、<a class="reference internal" href="Extensions.html"><span class="doc">拡張</span></a>を見てください。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID216">
<h2><span class="enstr">Class Inheritance and Initialization<a class="headerlink" href="#ID216" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
クラス継承と初期化<a class="headerlink" href="#ID216" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">All of a class’s stored properties—including any properties the class inherits from its superclass—<em>must</em> be assigned an initial value during initialization.</span><!--end_enstr-->
<span class="jpstr">
あるクラスの全ての格納プロパティは ― そのクラスがそれのスーパークラスから継承するあらゆるプロパティを含めて ― 初期化の間に初期値を代入される<em>必要があります</em>。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Swift defines two kinds of initializers for class types to help ensure all stored properties receive an initial value. These are known as designated initializers and convenience initializers.</span><!--end_enstr-->
<span class="jpstr">
スウィフトは、クラス型のために２種類のイニシャライザを定義して、全ての格納プロパティが初期値を受け取ることを確実にするのを手伝います。これらは、指定イニシャライザと便宜イニシャライザとして知られています。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID217">
<h3><span class="enstr">Designated Initializers and Convenience Initializers<a class="headerlink" href="#ID217" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
指定イニシャライザと便宜イニシャライザ<a class="headerlink" href="#ID217" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr"><em>Designated initializers</em> are the primary initializers for a class. A designated initializer fully initializes all properties introduced by that class and calls an appropriate superclass initializer to continue the initialization process up the superclass chain.</span><!--end_enstr-->
<span class="jpstr">
<em>指定イニシャライザ</em>は、あるクラスのための主要なイニシャライザです。指定イニシャライザは、そのクラスによって導入される全てのプロパティを完全に初期化して、適切なスーパークラスのイニシャライザを呼んで初期化プロセスを続けていきスーパークラス連鎖を上っていきます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Classes tend to have very few designated initializers, and it’s quite common for a class to have only one. Designated initializers are “funnel” points through which initialization takes place, and through which the initialization process continues up the superclass chain.</span><!--end_enstr-->
<span class="jpstr">
クラスはほとんど指定イニシャライザを持たない傾向があります、そして、あるクラスが１つだけしか持たないことは全く普通です。指定イニシャライザは、「漏斗」地点です、そこを通して初期化が行われ、そこを通して初期化処理がスーパークラス連鎖を上って続いていきます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Every class must have at least one designated initializer. In some cases, this requirement is satisfied by inheriting one or more designated initializers from a superclass, as described in <a class="reference internal" href="#ID222"><span class="std std-ref">Automatic Initializer Inheritance</span></a> below.</span><!--end_enstr-->
<span class="jpstr">
あらゆるクラスは、少なくとも１つの指定イニシャライザを持たなければなりません。若干の場合には、この必要条件は、下記の<a class="reference internal" href="#ID222"><span class="std std-ref">自動的なイニシャライザ継承</span></a>で記述されるように、あるスーパークラスから１つ以上の指定イニシャライザを継承することによって満たされます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr"><em>Convenience initializers</em> are secondary, supporting initializers for a class. You can define a convenience initializer to call a designated initializer from the same class as the convenience initializer with some of the designated initializer’s parameters set to default values. You can also define a convenience initializer to create an instance of that class for a specific use case or input value type.</span><!--end_enstr-->
<span class="jpstr">
<em>便宜イニシャライザ</em>は副次的なもので、あるクラスのためのイニシャライザを支援します。あなたは、ある便宜イニシャライザを定義して、同じクラスからある指定イニシャライザをその便宜イニシャライザとして呼び出し、その指定イニシャライザのパラメータのいくつかを省略時の値に設定することができます。あなたは、また、ある便宜イニシャライザを定義して、そのクラスのインスタンスを特定の使用状況のために作成したり、値型を入力することができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You don’t have to provide convenience initializers if your class doesn’t require them. Create convenience initializers whenever a shortcut to a common initialization pattern will save time or make initialization of the class clearer in intent.</span><!--end_enstr-->
<span class="jpstr">
あなたのクラスがそれらを必要としないならば、あなたは便宜イニシャライザを提供する必要はありません。共通の初期化の繰り返しに対する近道が時間を節約したり、そのクラスの初期化を意図においてより明白にするときはいつでも、便宜イニシャライザをつくってください。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID218">
<h3><span class="enstr">Syntax for Designated and Convenience Initializers<a class="headerlink" href="#ID218" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
指定および便宜イニシャライザのための構文<a class="headerlink" href="#ID218" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">Designated initializers for classes are written in the same way as simple initializers for value types:</span><!--end_enstr-->
<span class="jpstr">
クラスのための指定イニシャライザは、値型のための単純なイニシャライザと同様に書かれます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">init</span>(<span class="gi">parameters</span>) {
</li>
<li>    <span class="gi">statements</span>
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">Convenience initializers are written in the same style, but with the <code class="docutils literal notranslate"><span class="pre">convenience</span></code> modifier placed before the <code class="docutils literal notranslate"><span class="pre">init</span></code> keyword, separated by a space:</span><!--end_enstr-->
<span class="jpstr">
便宜イニシャライザは同じ形式で書かれます、しかし<code class="docutils literal notranslate"><span class="pre">convenience</span></code>修飾子が<code class="docutils literal notranslate"><span class="pre">init</span></code>キーワードの前に空白で区切って置かれます：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">convenience</span> <span class="k">init</span>(<span class="gi">parameters</span>) {
</li>
<li>    <span class="gi">statements</span>
</li>
<li>}
</li>
</ol></div></div></div>
</div>
<div class="section" id="ID219">
<h3><span class="enstr">Initializer Delegation for Class Types<a class="headerlink" href="#ID219" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
クラス型のためのイニシャライザ委任<a class="headerlink" href="#ID219" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">To simplify the relationships between designated and convenience initializers, Swift applies the following three rules for delegation calls between initializers:</span><!--end_enstr-->
<span class="jpstr">
指定と便宜イニシャライザの間の関係を単純化するために、スウィフトは以下の３つの規則をイニシャライザ間の委任呼び出しに対して適用します：
</span><!--end_jpstr-->
</p>
<dl class="docutils">
<dt><strong><span class="enstr">Rule 1</span><!--end_enstr-->
<span class="jpstr">
規則１
</span><!--end_jpstr-->
</strong></dt>
<dd><span class="enstr">A designated initializer must call a designated initializer from its immediate superclass.</span><!--end_enstr-->
<span class="jpstr">
指定イニシャライザは、その直接のスーパークラスから指定イニシャライザを呼ばなければなりません。
</span><!--end_jpstr-->
</dd>
<dt><strong><span class="enstr">Rule 2</span><!--end_enstr-->
<span class="jpstr">
規則２
</span><!--end_jpstr-->
</strong></dt>
<dd><span class="enstr">A convenience initializer must call another initializer from the <em>same</em> class.</span><!--end_enstr-->
<span class="jpstr">
便宜イニシャライザは、別のイニシャライザを<em>同じ</em>クラスから呼ばなければなりません。
</span><!--end_jpstr-->
</dd>
<dt><strong><span class="enstr">Rule 3</span><!--end_enstr-->
<span class="jpstr">
規則３
</span><!--end_jpstr-->
</strong></dt>
<dd><span class="enstr">A convenience initializer must ultimately call a designated initializer.</span><!--end_enstr-->
<span class="jpstr">
便宜イニシャライザは、最終的に指定イニシャライザを呼ばなければなりません。
</span><!--end_jpstr-->
</dd>
</dl>
<p><span class="enstr">A simple way to remember this is:</span><!--end_enstr-->
<span class="jpstr">
これを覚えている単純な方法は、以下の通りです：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li><span class="enstr">Designated initializers must always delegate <em>up</em>.</span><!--end_enstr-->
<span class="jpstr">
指定イニシャライザは、常に<em>上に</em>委任しなければなりません。
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Convenience initializers must always delegate <em>across</em>.</span><!--end_enstr-->
<span class="jpstr">
便宜イニシャライザは、常に<em>横に</em>委任しなければなりません。
</span><!--end_jpstr-->
</li>
</ul>
<p><span class="enstr">These rules are illustrated in the figure below:</span><!--end_enstr-->
<span class="jpstr">
これらの規則は、下の図で説明されます：
</span><!--end_jpstr-->
</p>
<img alt="../_images/initializerDelegation01_2x.png" class="align-center" src="../images/initializerDelegation01_2x.png" style="width: 411px;">
<p><span class="enstr">Here, the superclass has a single designated initializer and two convenience initializers. One convenience initializer calls another convenience initializer, which in turn calls the single designated initializer. This satisfies rules 2 and 3 from above. The superclass doesn’t itself have a further superclass, and so rule 1 doesn’t apply.</span><!--end_enstr-->
<span class="jpstr">
ここでは、スーパークラスは１つの指定イニシャライザと２つの便宜イニシャライザを持ちます。１つの便宜イニシャライザは、別の便宜イニシャライザを呼びます、それは、今度は１つだけある指定イニシャライザを呼びます。これは、上記の規則２と３を満たします。このスーパークラスにはそれ自身には更にスーパークラスをもちません、なので規則１は適用されません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The subclass in this figure has two designated initializers and one convenience initializer. The convenience initializer must call one of the two designated initializers, because it can only call another initializer from the same class. This satisfies rules 2 and 3 from above. Both designated initializers must call the single designated initializer from the superclass, to satisfy rule 1 from above.</span><!--end_enstr-->
<span class="jpstr">
この図の中のサブクラスは、２つの指定イニシャライザと１つの便宜イニシャライザを持ちます。便宜イニシャライザは、２つの指定イニシャライザのうちの１つを呼ぶに違いありません、なぜなら、それが同じクラスから別のイニシャライザを呼ぶことができるだけだからです。これは、上記の規則２と３を満たします。上記の規則１を満たすために、両方の指定イニシャライザは、スーパークラスからその１つだけある指定イニシャライザを呼ばなければなりません。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">These rules don’t affect how users of your classes <em>create</em> instances of each class. Any initializer in the diagram above can be used to create a fully initialized instance of the class they belong to. The rules only affect how you write the implementation of the class’s initializers.</span><!--end_enstr-->
<span class="jpstr">
これらの規則は、あなたのクラスのユーザーが各クラスのインスタンスを<em>作成する</em>方法に影響を及ぼしません。上の図の中のどんなイニシャライザでも、それらが属しているクラスの充分に初期化されたインスタンスをつくるために使用されることができます。これらの規則は、あなたがクラスのイニシャライザの実装を書く方法に影響を及ぼすだけです。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">The figure below shows a more complex class hierarchy for four classes. It illustrates how the designated initializers in this hierarchy act as “funnel” points for class initialization, simplifying the interrelationships among classes in the chain:</span><!--end_enstr-->
<span class="jpstr">
下の図は、４つのクラスのためのより複雑なクラス階層を示します。それは、この階層の中の指定イニシャライザが、どのようにクラス初期化のために「漏斗」地点の働きをして、この連鎖におけるクラス間の相互関係を単純化しているかを図示します：
</span><!--end_jpstr-->
</p>
<img alt="../_images/initializerDelegation02_2x.png" class="align-center" src="../images/initializerDelegation02_2x.png" style="width: 411px;">
</div>
<div class="section" id="ID220">
<h3><span class="enstr">Two-Phase Initialization<a class="headerlink" href="#ID220" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
２段階初期化<a class="headerlink" href="#ID220" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">Class initialization in Swift is a two-phase process. In the first phase, each stored property is assigned an initial value by the class that introduced it. Once the initial state for every stored property has been determined, the second phase begins, and each class is given the opportunity to customize its stored properties further before the new instance is considered ready for use.</span><!--end_enstr-->
<span class="jpstr">
スウィフトでのクラス初期化は、２段階処理です。最初の段階では、各格納プロパティは、それを導入したクラスによって、初期値を代入されます。一旦あらゆる格納プロパティのための最初の状態が決定されるならば、第２の段階が始まります、そして各クラスは、新しいインスタンスが使用する準備ができているとみなされる前に、さらにその格納プロパティを好みに合わせて作り変える機会を与えられます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The use of a two-phase initialization process makes initialization safe, while still giving complete flexibility to each class in a class hierarchy. Two-phase initialization prevents property values from being accessed before they’re initialized, and prevents property values from being set to a different value by another initializer unexpectedly.</span><!--end_enstr-->
<span class="jpstr">
２段階初期化処理の使用は初期化を安全にします、その一方でさらに、クラス階層において各クラスに完全な柔軟性を与えます。２段階初期化は、プロパティ値が初期化される前にアクセスされるのを妨げます、それによってプロパティ値が思いもよらず別のイニシャライザによって異なる値に設定されるのを防ぎます。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Swift’s two-phase initialization process is similar to initialization in Objective-C. The main difference is that during phase 1, Objective-C assigns zero or null values (such as <code class="docutils literal notranslate"><span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">nil</span></code>) to every property. Swift’s initialization flow is more flexible in that it lets you set custom initial values, and can cope with types for which <code class="docutils literal notranslate"><span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">nil</span></code> isn’t a valid default value.</span><!--end_enstr-->
<span class="jpstr">
スウィフトの２段階初期化プロセスは、Objective-Cでの初期化に似ています。主な違いは、段階１の間に、Objective-Cがゼロまたは無効な値（例えば<code class="docutils literal notranslate"><span class="pre">0</span></code>または<code class="docutils literal notranslate"><span class="pre">nil</span></code>）をあらゆるプロパティに代入するということです。それがあなたに好みに合わせた初期値を設定させて、<code class="docutils literal notranslate"><span class="pre">0</span></code>または<code class="docutils literal notranslate"><span class="pre">nil</span></code>が有効な省略時の値でない型に対処することができるという点で、スウィフトの初期化の流れはより柔軟です。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">Swift’s compiler performs four helpful safety-checks to make sure that two-phase initialization is completed without error:</span><!--end_enstr-->
<span class="jpstr">
スウィフトのコンパイラは、２段階初期化がエラーなしで完了されることを確認するために４つの役に立つ安全点検を実行します：
</span><!--end_jpstr-->
</p>
<dl class="docutils">
<dt><strong><span class="enstr">Safety check 1</span><!--end_enstr-->
<span class="jpstr">
安全点検１
</span><!--end_jpstr-->
</strong></dt>
<dd><span class="enstr">A designated initializer must ensure that all of the properties introduced by its class are initialized before it delegates up to a superclass initializer.</span><!--end_enstr-->
<span class="jpstr">
指定イニシャライザは、それがスーパークラスのイニシャライザへと委任する前に、そのクラスによって導入されるプロパティの全てが初期化されることを確実にしなければなりません。
</span><!--end_jpstr-->
</dd>
</dl>
<p><span class="enstr">As mentioned above, the memory for an object is only considered fully initialized once the initial state of all of its stored properties is known. In order for this rule to be satisfied, a designated initializer must make sure that all of its own properties are initialized before it hands off up the chain.</span><!--end_enstr-->
<span class="jpstr">
上で言及したように、いったんその格納プロパティの全ての最初の状態が知られる場合にのみ、あるオブジェクトに対するメモリが充分に初期化されたとみなされます。この規則が満たされるために、指定イニシャライザは、それがその連鎖を上って手渡す前に、それ自身のプロパティの全てが初期化されることを確認しなければなりません。
</span><!--end_jpstr-->
</p>
<dl class="docutils">
<dt><strong><span class="enstr">Safety check 2</span><!--end_enstr-->
<span class="jpstr">
安全点検２
</span><!--end_jpstr-->
</strong></dt>
<dd><span class="enstr">A designated initializer must delegate up to a superclass initializer before assigning a value to an inherited property. If it doesn’t, the new value the designated initializer assigns will be overwritten by the superclass as part of its own initialization.</span><!--end_enstr-->
<span class="jpstr">
指定イニシャライザは、継承されたプロパティに代入する前にスーパークラスのイニシャライザへ委任しなければなりません。それがそうしないならば、指定イニシャライザが代入する新しい値は、スーパークラスによってそれ自身の初期化の一部として上書きされます。
</span><!--end_jpstr-->
</dd>
<dt><strong><span class="enstr">Safety check 3</span><!--end_enstr-->
<span class="jpstr">
安全点検３
</span><!--end_jpstr-->
</strong></dt>
<dd><span class="enstr">A convenience initializer must delegate to another initializer before assigning a value to <em>any</em> property (including properties defined by the same class). If it doesn’t, the new value the convenience initializer assigns will be overwritten by its own class’s designated initializer.</span><!--end_enstr-->
<span class="jpstr">
便宜イニシャライザは、値を<em>何らかの</em>プロパティ（同じクラスによって定義されるプロパティを含む）に代入する前に、別のイニシャライザに委任しなければなりません。それがそうしないならば、便宜イニシャライザが代入する新しい値は、それ自身のクラスの指定イニシャライザによって上書きされます。
</span><!--end_jpstr-->
</dd>
<dt><strong><span class="enstr">Safety check 4</span><!--end_enstr-->
<span class="jpstr">
安全点検４
</span><!--end_jpstr-->
</strong></dt>
<dd><span class="enstr">An initializer can’t call any instance methods, read the values of any instance properties, or refer to <code class="docutils literal notranslate"><span class="pre">self</span></code> as a value until after the first phase of initialization is complete.</span><!--end_enstr-->
<span class="jpstr">
イニシャライザは、初期化の最初の段階が完了するまで、どんなインスタンスメソッドも呼ぶこと、どんなインスタンスプロパティの値も読むこと、または<code class="docutils literal notranslate"><span class="pre">self</span></code>をひとつの値として参照することができません。
</span><!--end_jpstr-->
</dd>
</dl>
<p><span class="enstr">The class instance isn’t fully valid until the first phase ends. Properties can only be accessed, and methods can only be called, once the class instance is known to be valid at the end of the first phase.</span><!--end_enstr-->
<span class="jpstr">
第１段階が終わるまで、クラスインスタンスは充分に有効ではありません。一旦クラスインスタンスが第１段階の終わりに有効であるということを知られる場合にのみ、プロパティはアクセスされることができ、そしてメソッドは呼ばれることができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Here’s how two-phase initialization plays out, based on the four safety checks above:</span><!--end_enstr-->
<span class="jpstr">
２段階初期化が、上の４つの安全点検に基づいて最後までやり終える方法がここにあります：
</span><!--end_jpstr-->
</p>
<p><strong><span class="enstr">Phase 1</span><!--end_enstr-->
<span class="jpstr">
第１段階
</span><!--end_jpstr-->
</strong></p>
<ul class="simple">
<li><span class="enstr">A designated or convenience initializer is called on a class.</span><!--end_enstr-->
<span class="jpstr">
指定または便宜イニシャライザが、あるクラスで呼ばれます。
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Memory for a new instance of that class is allocated. The memory isn’t yet initialized.</span><!--end_enstr-->
<span class="jpstr">
そのクラスの新しいインスタンスに対するメモリが割り当てられます。そのメモリは、まだ初期化されません。
</span><!--end_jpstr-->
</li>
<li><span class="enstr">A designated initializer for that class confirms that all stored properties introduced by that class have a value. The memory for these stored properties is now initialized.</span><!--end_enstr-->
<span class="jpstr">
そのクラスのための指定イニシャライザは、そのクラスによって導入される全ての格納プロパティが値を持つことを確かめます。これらの格納プロパティに対するメモリは、今や初期化されます。
</span><!--end_jpstr-->
</li>
<li><span class="enstr">The designated initializer hands off to a superclass initializer to perform the same task for its own stored properties.</span><!--end_enstr-->
<span class="jpstr">
指定イニシャライザは、そのスーパークラスのイニシャライザに、それ自身の格納プロパティに対して同じ作業を実行するように任せます。
</span><!--end_jpstr-->
</li>
<li><span class="enstr">This continues up the class inheritance chain until the top of the chain is reached.</span><!--end_enstr-->
<span class="jpstr">
これは、クラス継承連鎖を上って、その連鎖の最上部に着くまで続きます。
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Once the top of the chain is reached, and the final class in the chain has ensured that all of its stored properties have a value, the instance’s memory is considered to be fully initialized, and phase 1 is complete.</span><!--end_enstr-->
<span class="jpstr">
いったん連鎖の最上部に届き、そして連鎖の中の最終的なクラスがその格納プロパティの全てが値を持つことを確実にしたならば、インスタンスのメモリは充分に初期化されるとみなされます、そして、第１段階は完了です。
</span><!--end_jpstr-->
</li>
</ul>
<p><strong><span class="enstr">Phase 2</span><!--end_enstr-->
<span class="jpstr">
第２段階
</span><!--end_jpstr-->
</strong></p>
<ul class="simple">
<li><span class="enstr">Working back down from the top of the chain, each designated initializer in the chain has the option to customize the instance further. Initializers are now able to access <code class="docutils literal notranslate"><span class="pre">self</span></code> and can modify its properties, call its instance methods, and so on.</span><!--end_enstr-->
<span class="jpstr">
連鎖の最上部から逆に階層を下って、連鎖の中の各指定イニシャライザは、さらにインスタンスを好みに合わせて作り変える選択肢を持ちます。イニシャライザは、今では<code class="docutils literal notranslate"><span class="pre">self</span></code>にアクセスすることができます、そしてそれのプロパティを修正すること、それのインスタンスをメソッドを呼び出すこと、などが行えます。
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Finally, any convenience initializers in the chain have the option to customize the instance and to work with <code class="docutils literal notranslate"><span class="pre">self</span></code>.</span><!--end_enstr-->
<span class="jpstr">
最後に、連鎖の中のあらゆる便宜イニシャライザは、インスタンスを好みに合わせて作り変えるために、<code class="docutils literal notranslate"><span class="pre">self</span></code>を扱うために選択肢を持ちます。
</span><!--end_jpstr-->
</li>
</ul>
<p><span class="enstr">Here’s how phase 1 looks for an initialization call for a hypothetical subclass and superclass:</span><!--end_enstr-->
<span class="jpstr">
第１段階がある仮定のサブクラスとスーパークラスのための初期化呼び出しを捜す方法がここにあります：
</span><!--end_jpstr-->
</p>
<img alt="../_images/twoPhaseInitialization01_2x.png" class="align-center" src="../images/twoPhaseInitialization01_2x.png" style="width: 420px;">
<p><span class="enstr">In this example, initialization begins with a call to a convenience initializer on the subclass. This convenience initializer can’t yet modify any properties. It delegates across to a designated initializer from the same class.</span><!--end_enstr-->
<span class="jpstr">
この例では、初期化はサブクラス上での便宜イニシャライザへの呼び出しから始まります。この便宜イニシャライザは、まだどのプロパティも修正することはできません。それは、横の同じクラスの指定イニシャライザに向かって委任します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The designated initializer makes sure that all of the subclass’s properties have a value, as per safety check 1. It then calls a designated initializer on its superclass to continue the initialization up the chain.</span><!--end_enstr-->
<span class="jpstr">
指定イニシャライザは、安全検査１のように、サブクラスのプロパティの全てが値を持つことを確認します。それはそれから、連鎖を上って初期化を続けるために、そのスーパークラス上で指定イニシャライザを呼びます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The superclass’s designated initializer makes sure that all of the superclass properties have a value. There are no further superclasses to initialize, and so no further delegation is needed.</span><!--end_enstr-->
<span class="jpstr">
スーパークラスの指定イニシャライザは、スーパークラスのプロパティの全てが値を持つことを確認します。初期化するための更なるスーパークラスはありません、なので、更なる委任は必要ありません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">As soon as all properties of the superclass have an initial value, its memory is considered fully initialized, and phase 1 is complete.</span><!--end_enstr-->
<span class="jpstr">
スーパークラスの全てのプロパティが初期値を持つとすぐに、そのメモリは完全に初期化されるとみなされます、そして第１段階は完了します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Here’s how phase 2 looks for the same initialization call:</span><!--end_enstr-->
<span class="jpstr">
第２段階が同じ初期化呼び出しを捜す方法は、ここにあります：
</span><!--end_jpstr-->
</p>
<img alt="../_images/twoPhaseInitialization02_2x.png" class="align-center" src="../images/twoPhaseInitialization02_2x.png" style="width: 420px;">
<p><span class="enstr">The superclass’s designated initializer now has an opportunity to customize the instance further (although it doesn’t have to).</span><!--end_enstr-->
<span class="jpstr">
スーパークラスの指定イニシャライザは、現在、さらにインスタンスを好みに合わせて作り返る機会があります（しかしながら、それはそうしなければならない訳ではない）。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Once the superclass’s designated initializer is finished, the subclass’s designated initializer can perform additional customization (although again, it doesn’t have to).</span><!--end_enstr-->
<span class="jpstr">
一旦スーパークラスの指定イニシャライザが作業をし終えるならば、サブクラスの指定イニシャライザは追加の改良を実行することができます（しかし再び、そうしなければならない訳ではない）。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Finally, once the subclass’s designated initializer is finished, the convenience initializer that was originally called can perform additional customization.</span><!--end_enstr-->
<span class="jpstr">
最後に、一旦サブクラスの指定イニシャライザが作業をし終えるならば、最初に呼ばれた便宜イニシャライザは追加の特注処理を実行することができます。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID221">
<h3><span class="enstr">Initializer Inheritance and Overriding<a class="headerlink" href="#ID221" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
イニシャライザの継承およびオーバーライド<a class="headerlink" href="#ID221" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">Unlike subclasses in Objective-C, Swift subclasses don’t inherit their superclass initializers by default. Swift’s approach prevents a situation in which a simple initializer from a superclass is inherited by a more specialized subclass and is used to create a new instance of the subclass that isn’t fully or correctly initialized.</span><!--end_enstr-->
<span class="jpstr">
Objective-Cでのサブクラスとは異なり、スウィフトのサブクラスは、特に何もしなくてもそれらのスーパークラスのイニシャライザを継承します。スウィフトの取り組み方は、スーパークラスのもつ単純なイニシャライザがより特殊化されたサブクラスによって継承されて、充分にまたは正しく初期化されない状態の、サブクラスの新しいインスタンスをつくるのに使われる状況を防ぎます。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Superclass initializers <em>are</em> inherited in certain circumstances, but only when it’s safe and appropriate to do so. For more information, see <a class="reference internal" href="#ID222"><span class="std std-ref">Automatic Initializer Inheritance</span></a> below.</span><!--end_enstr-->
<span class="jpstr">
スーパークラスのイニシャライザはある特定の状況において継承<em>されます</em>、しかしそれが安全にそして適切にそうできる時だけです。更なる情報は、以下の<a class="reference internal" href="#ID222"><span class="std std-ref">自動的なイニシャライザ継承</span></a>を見てください。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">If you want a custom subclass to present one or more of the same initializers as its superclass, you can provide a custom implementation of those initializers within the subclass.</span><!--end_enstr-->
<span class="jpstr">
あなたが、あるあつらえのサブクラスにそれのスーパークラスと同じイニシャライザがひとつ以上存在することを望むならば、あなたはそれらのイニシャライザのあつらえの実装をそのサブクラスにおいて提供することができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">When you write a subclass initializer that matches a superclass <em>designated</em> initializer, you are effectively providing an override of that designated initializer. Therefore, you must write the <code class="docutils literal notranslate"><span class="pre">override</span></code> modifier before the subclass’s initializer definition. This is true even if you are overriding an automatically provided default initializer, as described in <a class="reference internal" href="#ID213"><span class="std std-ref">Default Initializers</span></a>.</span><!--end_enstr-->
<span class="jpstr">
あなたがスーパークラスの<em>指定</em>イニシャライザと一致するあるサブクラス・イニシャライザを書く時、あなたは事実上その指定イニシャライザのオーバーライドを提供しています。したがって、あなたは<code class="docutils literal notranslate"><span class="pre">override</span></code>修飾子をそのサブクラスのイニシャライザ定義の前に書かなければなりません。これは、<a class="reference internal" href="#ID213"><span class="std std-ref">省略時のイニシャライザ</span></a>で記述されるように、あなたが自動的に提供される省略時のイニシャライザをオーバーライドしている場合にさえもあてはまります。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">As with an overridden property, method or subscript, the presence of the <code class="docutils literal notranslate"><span class="pre">override</span></code> modifier prompts Swift to check that the superclass has a matching designated initializer to be overridden, and validates that the parameters for your overriding initializer have been specified as intended.</span><!--end_enstr-->
<span class="jpstr">
オーバーライドされるプロパティ、メソッドや添え字を書く時と同様に、<code class="docutils literal notranslate"><span class="pre">override</span></code>修飾子の存在はスウィフトにスーパークラスが一致している、オーバーライドされる指定イニシャライザを持つのを確認すること、そしてあなたがオーバーライドするイニシャライザのパラメータが意図されるように指定されてしまっているのを検証することを促します。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">You always write the <code class="docutils literal notranslate"><span class="pre">override</span></code> modifier when overriding a superclass designated initializer, even if your subclass’s implementation of the initializer is a convenience initializer.</span><!--end_enstr-->
<span class="jpstr">
あなたはスーパークラスの指定イニシャライザをオーバーライドする時に常に<code class="docutils literal notranslate"><span class="pre">override</span></code>修飾子を書きます、そのイニシャライザのあなたのサブクラスでの実装が便宜イニシャライザであるとしてもです。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">Conversely, if you write a subclass initializer that matches a superclass <em>convenience</em> initializer, that superclass convenience initializer can never be called directly by your subclass, as per the rules described above in <a class="reference internal" href="#ID219"><span class="std std-ref">Initializer Delegation for Class Types</span></a>. Therefore, your subclass is not (strictly speaking) providing an override of the superclass initializer. As a result, you don’t write the <code class="docutils literal notranslate"><span class="pre">override</span></code> modifier when providing a matching implementation of a superclass convenience initializer.</span><!--end_enstr-->
<span class="jpstr">
逆に言えば、上記の<a class="reference internal" href="#ID219"><span class="std std-ref">クラス型のためのイニシャライザ委任</span></a>で記述される規則どおりに、あなたがスーパークラスの<em>便宜</em>イニシャライザに一致するサブクラスのイニシャライザを書くならば、そのスーパークラスの便宜イニシャライザは直接にあなたのサブクラスによって呼び出されることが決してできません。それゆえに、あなたのサブクラスはスーパークラスのイニシャライザのオーバーライドを（厳密に言えば）提供していません。結果として、あなたはスーパークラスの便宜イニシャライザに一致する実装を提供している時に<code class="docutils literal notranslate"><span class="pre">override</span></code>修飾子を書きません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The example below defines a base class called <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>. This base class declares a stored property called <code class="docutils literal notranslate"><span class="pre">numberOfWheels</span></code>, with a default <code class="docutils literal notranslate"><span class="pre">Int</span></code> value of <code class="docutils literal notranslate"><span class="pre">0</span></code>. The <code class="docutils literal notranslate"><span class="pre">numberOfWheels</span></code> property is used by a computed property called <code class="docutils literal notranslate"><span class="pre">description</span></code> to create a <code class="docutils literal notranslate"><span class="pre">String</span></code> description of the vehicle’s characteristics:</span><!--end_enstr-->
<span class="jpstr">
下の例は、<code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>と呼ばれる基盤クラスを定義します。この基盤クラスは<code class="docutils literal notranslate"><span class="pre">numberOfWheels</span></code>と呼ばれる格納プロパティを、省略時の値として<code class="docutils literal notranslate"><span class="pre">Int</span></code>値<code class="docutils literal notranslate"><span class="pre">0</span></code>を使って、宣言します。<code class="docutils literal notranslate"><span class="pre">numberOfWheels</span></code>プロパティは<code class="docutils literal notranslate"><span class="pre">description</span></code>と呼ばれる計算プロパティによって使用されて、この乗り物の特徴のある<code class="docutils literal notranslate"><span class="pre">String</span></code>の解説を作成します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">class</span> <span class="nv">Vehicle</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">numberOfWheels</span> = <span class="m">0</span>
</li>
<li>    <span class="k">var</span> <span class="nv">description</span>: <span class="nc">String</span> {
</li>
<li>        <span class="k">return</span> <span class="s">"</span>\<span class="p">(</span><span class="nv">numberOfWheels</span><span class="p">)</span><span class="s"> wheel(s)"</span>
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code> class provides a default value for its only stored property, and doesn’t provide any custom initializers itself. As a result, it automatically receives a default initializer, as described in <a class="reference internal" href="#ID213"><span class="std std-ref">Default Initializers</span></a>. The default initializer (when available) is always a designated initializer for a class, and can be used to create a new <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code> instance with a <code class="docutils literal notranslate"><span class="pre">numberOfWheels</span></code> of <code class="docutils literal notranslate"><span class="pre">0</span></code>:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>クラスは、それの格納プロパティのためにのみ省略時の値を提供します、そしてそれ自身では何らあつらえのイニシャライザを提供しません。結果として、<a class="reference internal" href="#ID213"><span class="std std-ref">省略時のイニシャライザ</span></a>で記述されるように、それは自動的に省略時のイニシャライザを受け取ります。省略時のイニシャライザは（利用可能な場合は）、常にクラスのための指定イニシャライザです、そして<code class="docutils literal notranslate"><span class="pre">0</span></code>の<code class="docutils literal notranslate"><span class="pre">numberOfWheels</span></code>をもつ新しい<code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>インスタンスを作成するために使用されることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">let</span> <span class="nv">vehicle</span> = <span class="nv">Vehicle</span>()
</li>
<li><span class="nv">print</span>(<span class="s">"Vehicle: </span>\<span class="p">(</span><span class="nv">vehicle</span>.<span class="nv">description</span><span class="p">)</span><span class="s">"</span>)
</li>
<li><span class="c"><span class="enstr">// Vehicle: 0 wheel(s)</span><!--end_enstr--><span class="jpstr">（乗り物: ０輪）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">The next example defines a subclass of <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code> called <code class="docutils literal notranslate"><span class="pre">Bicycle</span></code>:</span><!--end_enstr-->
<span class="jpstr">
次の例は、<code class="docutils literal notranslate"><span class="pre">Bicycle</span></code>と呼ばれる<code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>のサブクラスを定義します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">class</span> <span class="nv">Bicycle</span>: <span class="nc">Vehicle</span> {
</li>
<li>    <span class="k">override</span> <span class="k">init</span>() {
</li>
<li>        <span class="k">super</span>.<span class="nv">init</span>()
</li>
<li>        <span class="nv">numberOfWheels</span> = <span class="m">2</span>
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">Bicycle</span></code> subclass defines a custom designated initializer, <code class="docutils literal notranslate"><span class="pre">init()</span></code>. This designated initializer matches a designated initializer from the superclass of <code class="docutils literal notranslate"><span class="pre">Bicycle</span></code>, and so the <code class="docutils literal notranslate"><span class="pre">Bicycle</span></code> version of this initializer is marked with the <code class="docutils literal notranslate"><span class="pre">override</span></code> modifier.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Bicycle</span></code>サブクラスはあつらえの指定イニシャライザ、<code class="docutils literal notranslate"><span class="pre">init()</span></code>を定義します。この指定イニシャライザは<code class="docutils literal notranslate"><span class="pre">Bicycle</span></code>のスーパークラスでのある指定イニシャライザと一致します、なのでこのイニシャライザの<code class="docutils literal notranslate"><span class="pre">Bicycle</span></code>改変板は<code class="docutils literal notranslate"><span class="pre">override</span></code>修飾子で印されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">init()</span></code> initializer for <code class="docutils literal notranslate"><span class="pre">Bicycle</span></code> starts by calling <code class="docutils literal notranslate"><span class="pre">super.init()</span></code>, which calls the default initializer for the <code class="docutils literal notranslate"><span class="pre">Bicycle</span></code> class’s superclass, <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>. This ensures that the <code class="docutils literal notranslate"><span class="pre">numberOfWheels</span></code> inherited property is initialized by <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code> before <code class="docutils literal notranslate"><span class="pre">Bicycle</span></code> has the opportunity to modify the property. After calling <code class="docutils literal notranslate"><span class="pre">super.init()</span></code>, the original value of <code class="docutils literal notranslate"><span class="pre">numberOfWheels</span></code> is replaced with a new value of <code class="docutils literal notranslate"><span class="pre">2</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Bicycle</span></code>のための<code class="docutils literal notranslate"><span class="pre">init()</span></code>イニシャライザは、<code class="docutils literal notranslate"><span class="pre">super.init()</span></code>を呼ぶことによって始まります、それは、<code class="docutils literal notranslate"><span class="pre">Bicycle</span></code>クラスのスーパークラス、<code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>のための省略時のイニシャライザを呼び出します。これは継承されたプロパティ<code class="docutils literal notranslate"><span class="pre">numberOfWheels</span></code>が、<code class="docutils literal notranslate"><span class="pre">Bicycle</span></code>がそのプロパティを変更する機会を得る前に、<code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>によってイニシャライズされることを確実にします。<code class="docutils literal notranslate"><span class="pre">super.init()</span></code>の呼び出しの後、<code class="docutils literal notranslate"><span class="pre">numberOfWheels</span></code>のもとの値は新しい値の<code class="docutils literal notranslate"><span class="pre">2</span></code>で置き換えられます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">If you create an instance of <code class="docutils literal notranslate"><span class="pre">Bicycle</span></code>, you can call its inherited <code class="docutils literal notranslate"><span class="pre">description</span></code> computed property to see how its <code class="docutils literal notranslate"><span class="pre">numberOfWheels</span></code> property has been updated:</span><!--end_enstr-->
<span class="jpstr">
あなたが<code class="docutils literal notranslate"><span class="pre">Bicycle</span></code>のインスタンスを作成するならば、あなたはそれの継承された<code class="docutils literal notranslate"><span class="pre">description</span></code>計算プロパティを呼び出して、どのようにそれの<code class="docutils literal notranslate"><span class="pre">numberOfWheels</span></code>プロパティが更新されたか見ることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">let</span> <span class="nv">bicycle</span> = <span class="nv">Bicycle</span>()
</li>
<li><span class="nv">print</span>(<span class="s">"Bicycle: </span>\<span class="p">(</span><span class="nv">bicycle</span>.<span class="nv">description</span><span class="p">)</span><span class="s">"</span>)
</li>
<li><span class="c"><span class="enstr">// Bicycle: 2 wheel(s)</span><!--end_enstr--><span class="jpstr">（自転車: ２輪）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">If a subclass initializer performs no customization in phase 2 of the initialization process, and the superclass has a zero-argument designated initializer, you can omit a call to <code class="docutils literal notranslate"><span class="pre">super.init()</span></code> after assigning values to all of the subclass’s stored properties.</span><!--end_enstr-->
<span class="jpstr">
サブクラスのイニシャライザが初期化過程の第２段階においてなんら特注の挙動を実行しない、そしてスーパークラスがゼロ個引数の指定イニシャライザを持つならば、あなたはサブクラスの持つ格納プロパティの全てに値を割り当てた後、<code class="docutils literal notranslate"><span class="pre">super.init()</span></code>の呼び出しを省略できます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">This example defines another subclass of <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>, called <code class="docutils literal notranslate"><span class="pre">Hoverboard</span></code>. In its initializer, the <code class="docutils literal notranslate"><span class="pre">Hoverboard</span></code> class sets only its <code class="docutils literal notranslate"><span class="pre">color</span></code> property. Instead of making an explicit call to <code class="docutils literal notranslate"><span class="pre">super.init()</span></code>, this initializer relies on an implicit call to its superclass’s initializer to complete the process.</span><!--end_enstr-->
<span class="jpstr">
この例は、もう１つ<code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>のサブクラスを定義します、それは<code class="docutils literal notranslate"><span class="pre">Hoverboard</span></code>と呼ばれます。そのイニシャライザにおいて、<code class="docutils literal notranslate"><span class="pre">Hoverboard</span></code>クラスはそれの<code class="docutils literal notranslate"><span class="pre">color</span></code>プロパティのみを設定します。<code class="docutils literal notranslate"><span class="pre">super.init()</span></code>への明示的な呼び出しをする代わりに、このイニシャライザはそれのスーパークラスの持つイニシャライザへの暗黙的な呼び出しを当てにすることで、その過程を完了します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">class</span> <span class="nv">Hoverboard</span>: <span class="nc">Vehicle</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">color</span>: <span class="nc">String</span>
</li>
<li>    <span class="k">init</span>(<span class="nv">color</span>: <span class="nc">String</span>) {
</li>
<li>        <span class="k">self</span>.<span class="nv">color</span> = <span class="nv">color</span>
</li>
<li>        <span class="c"><span class="enstr">// super.init() implicitly called here</span><!--end_enstr--><span class="jpstr">（super.init() が暗黙的にここで呼び出されます）</span><!--end_jpstr--></span>
</li>
<li>    }
</li>
<li>    <span class="k">override</span> <span class="k">var</span> <span class="nv">description</span>: <span class="nc">String</span> {
</li>
<li>        <span class="k">return</span> <span class="s">"</span>\<span class="p">(</span><span class="k">super</span>.<span class="nv">description</span><span class="p">)</span><span class="s"> in a beautiful </span>\<span class="p">(</span><span class="nv">color</span><span class="p">)</span><span class="s">"</span>
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">An instance of <code class="docutils literal notranslate"><span class="pre">Hoverboard</span></code> uses the default number of wheels supplied by the <code class="docutils literal notranslate"><span class="pre">Vehicle</span></code> initializer.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Hoverboard</span></code>のインスタンスは、<code class="docutils literal notranslate"><span class="pre">Vehicle</span></code>イニシャライザによって提供される省略時の車輪数を使います。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">let</span> <span class="nv">hoverboard</span> = <span class="nv">Hoverboard</span>(<span class="nv">color</span>: <span class="s">"silver"</span>)
</li>
<li><span class="nv">print</span>(<span class="s">"Hoverboard: </span>\<span class="p">(</span><span class="nv">hoverboard</span>.<span class="nv">description</span><span class="p">)</span><span class="s">"</span>)
</li>
<li><span class="c"><span class="enstr">// Hoverboard: 0 wheel(s) in a beautiful silver</span><!--end_enstr--><span class="jpstr">（ホバーボード: ０個の車輪、美しい銀色で）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Subclasses can modify inherited variable properties during initialization, but can’t modify inherited constant properties.</span><!--end_enstr-->
<span class="jpstr">
サブクラスは、初期化の間に継承された変数プロパティを修正することできます、しかし継承された定数プロパティを変更することはできません。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID222">
<h3><span class="enstr">Automatic Initializer Inheritance<a class="headerlink" href="#ID222" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
自動的なイニシャライザ継承<a class="headerlink" href="#ID222" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">As mentioned above, subclasses don’t inherit their superclass initializers by default. However, superclass initializers <em>are</em> automatically inherited if certain conditions are met. In practice, this means that you don’t need to write initializer overrides in many common scenarios, and can inherit your superclass initializers with minimal effort whenever it’s safe to do so.</span><!--end_enstr-->
<span class="jpstr">
上で述べたように、サブクラスは何もしなければそれらのスーパークラスのイニシャライザを継承しません。しかし、スーパークラスのイニシャライザは、決まった条件が満たされるならば、自動的に継承<em>されます</em>。実際問題として、これは、あなたが多くの通常の状況ではイニシャライザのオーバーライドを書く必要がなく、そしてそれが安全にそうできる時はいつでも最小の努力であなたのスーパークラスのイニシャライザを継承することができることを意味します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Assuming that you provide default values for any new properties you introduce in a subclass, the following two rules apply:</span><!--end_enstr-->
<span class="jpstr">
あなたが省略時の値をあなたがサブクラスで導入するあらゆる新しいプロパティに用意すると仮定して、以下の２つの規則が適用されます：
</span><!--end_jpstr-->
</p>
<dl class="docutils">
<dt><strong><span class="enstr">Rule 1</span><!--end_enstr-->
<span class="jpstr">
規則１
</span><!--end_jpstr-->
</strong></dt>
<dd><span class="enstr">If your subclass doesn’t define any designated initializers, it automatically inherits all of its superclass designated initializers.</span><!--end_enstr-->
<span class="jpstr">
あなたのサブクラスがまったく指定イニシャライザを定義しないならば、それは自動的にそれのスーパークラスの指定イニシャライザの全てを継承します。
</span><!--end_jpstr-->
</dd>
<dt><strong><span class="enstr">Rule 2</span><!--end_enstr-->
<span class="jpstr">
規則２
</span><!--end_jpstr-->
</strong></dt>
<dd><span class="enstr">If your subclass provides an implementation of <em>all</em> of its superclass designated initializers—either by inheriting them as per rule 1, or by providing a custom implementation as part of its definition—then it automatically inherits all of the superclass convenience initializers.</span><!--end_enstr-->
<span class="jpstr">
もしあなたのサブクラスがそれのスーパークラスの指定イニシャライザの実装の<em>全て</em>を ― 規則１に従ってそれらを継承することによって、またはあつらえの実装をそれの定義の一部として提供することによってのどちらかで ― 提供するならば、その時それは自動的にスーパークラスの便宜イニシャライザの全てを継承します。
</span><!--end_jpstr-->
</dd>
</dl>
<p><span class="enstr">These rules apply even if your subclass adds further convenience initializers.</span><!--end_enstr-->
<span class="jpstr">
これらの規則は、たとえあなたのサブクラスが更なる便宜イニシャライザを加えるとしてもあてはまります。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">A subclass can implement a superclass designated initializer as a subclass convenience initializer as part of satisfying rule 2.</span><!--end_enstr-->
<span class="jpstr">
サブクラスは、規則２を満たすことの一部として、スーパークラスの指定イニシャライザをサブクラスの便宜イニシャライザとして実装することができます。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID223">
<h3><span class="enstr">Designated and Convenience Initializers in Action<a class="headerlink" href="#ID223" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
指定および便宜イニシャライザの動作<a class="headerlink" href="#ID223" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">The following example shows designated initializers, convenience initializers, and automatic initializer inheritance in action. This example defines a hierarchy of three classes called <code class="docutils literal notranslate"><span class="pre">Food</span></code>, <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code>, and <code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code>, and demonstrates how their initializers interact.</span><!--end_enstr-->
<span class="jpstr">
以下の例は、指定イニシャライザ、便宜イニシャライザ、そして自動的なイニシャライザ継承の動作を示します。この例は、<code class="docutils literal notranslate"><span class="pre">Food</span></code>、<code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code>、そして<code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code>と呼ばれる３つのクラスの階層を定義して、それらのイニシャライザが相互に作用する方法を示します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The base class in the hierarchy is called <code class="docutils literal notranslate"><span class="pre">Food</span></code>, which is a simple class to encapsulate the name of a foodstuff. The <code class="docutils literal notranslate"><span class="pre">Food</span></code> class introduces a single <code class="docutils literal notranslate"><span class="pre">String</span></code> property called <code class="docutils literal notranslate"><span class="pre">name</span></code> and provides two initializers for creating <code class="docutils literal notranslate"><span class="pre">Food</span></code> instances:</span><!--end_enstr-->
<span class="jpstr">
この階層構造における基盤クラスは<code class="docutils literal notranslate"><span class="pre">Food</span></code>と呼ばれています、それは、食品の名前をカプセル化する単純なクラスです。<code class="docutils literal notranslate"><span class="pre">Food</span></code>クラスは、<code class="docutils literal notranslate"><span class="pre">name</span></code>と呼ばれる１つの<code class="docutils literal notranslate"><span class="pre">String</span></code>プロパティを導入して、２つのイニシャライザを<code class="docutils literal notranslate"><span class="pre">Food</span></code>インスタンスをつくるために提供します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">class</span> <span class="nv">Food</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">name</span>: <span class="nc">String</span>
</li>
<li>    <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>) {
</li>
<li>        <span class="k">self</span>.<span class="nv">name</span> = <span class="nv">name</span>
</li>
<li>    }
</li>
<li>    <span class="k">convenience</span> <span class="k">init</span>() {
</li>
<li>        <span class="k">self</span>.<span class="nv">init</span>(<span class="nv">name</span>: <span class="s">"[Unnamed]"</span>)
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">The figure below shows the initializer chain for the <code class="docutils literal notranslate"><span class="pre">Food</span></code> class:</span><!--end_enstr-->
<span class="jpstr">
下の図は、<code class="docutils literal notranslate"><span class="pre">Food</span></code>クラスのためのイニシャライザ連鎖を示します：
</span><!--end_jpstr-->
</p>
<img alt="../_images/initializersExample01_2x.png" class="align-center" src="../images/initializersExample01_2x.png" style="width: 411px;">
<p><span class="enstr">Classes don’t have a default memberwise initializer, and so the <code class="docutils literal notranslate"><span class="pre">Food</span></code> class provides a designated initializer that takes a single argument called <code class="docutils literal notranslate"><span class="pre">name</span></code>. This initializer can be used to create a new <code class="docutils literal notranslate"><span class="pre">Food</span></code> instance with a specific name:</span><!--end_enstr-->
<span class="jpstr">
これらのクラスには省略時のメンバー関連イニシャライザがありません、なので、<code class="docutils literal notranslate"><span class="pre">Food</span></code>クラスは<code class="docutils literal notranslate"><span class="pre">name</span></code>と呼ばれる１つの引数をとる指定イニシャライザを提供します。このイニシャライザが、ある特定の名前を使って新しい<code class="docutils literal notranslate"><span class="pre">Food</span></code>インスタンスをつくるために使われることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">let</span> <span class="nv">namedMeat</span> = <span class="nv">Food</span>(<span class="nv">name</span>: <span class="s">"Bacon"</span>)
</li>
<li><span class="c"><span class="enstr">// namedMeat's name is "Bacon"</span><!--end_enstr--><span class="jpstr">（nameMeatの名前は「ベーコン」です）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">init(name:</span> <span class="pre">String)</span></code> initializer from the <code class="docutils literal notranslate"><span class="pre">Food</span></code> class is provided as a <em>designated</em> initializer, because it ensures that all stored properties of a new <code class="docutils literal notranslate"><span class="pre">Food</span></code> instance are fully initialized. The <code class="docutils literal notranslate"><span class="pre">Food</span></code> class doesn’t have a superclass, and so the <code class="docutils literal notranslate"><span class="pre">init(name:</span> <span class="pre">String)</span></code> initializer doesn’t need to call <code class="docutils literal notranslate"><span class="pre">super.init()</span></code> to complete its initialization.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">init(name:</span> <span class="pre">String)</span></code>イニシャライザは、この<code class="docutils literal notranslate"><span class="pre">Food</span></code>クラス由来で、<em>指定</em>イニシャライザとして提供されます、なぜならそれは新しい<code class="docutils literal notranslate"><span class="pre">Food</span></code>インスタンスのすべての格納プロパティが完全に初期化されるのを確実にするからです。<code class="docutils literal notranslate"><span class="pre">Food</span></code>クラスには、スーパークラスがありません、なので、<code class="docutils literal notranslate"><span class="pre">init(name:</span> <span class="pre">String)</span></code>イニシャライザはその初期化を完了するために<code class="docutils literal notranslate"><span class="pre">super.init()</span></code>を呼ぶ必要がありません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">Food</span></code> class also provides a <em>convenience</em> initializer, <code class="docutils literal notranslate"><span class="pre">init()</span></code>, with no arguments. The <code class="docutils literal notranslate"><span class="pre">init()</span></code> initializer provides a default placeholder name for a new food by delegating across to the <code class="docutils literal notranslate"><span class="pre">Food</span></code> class’s <code class="docutils literal notranslate"><span class="pre">init(name:</span> <span class="pre">String)</span></code> with a <code class="docutils literal notranslate"><span class="pre">name</span></code> value of <code class="docutils literal notranslate"><span class="pre">[Unnamed]</span></code>:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Food</span></code>クラスはまた、引数のない<em>便宜</em>イニシャライザ、<code class="docutils literal notranslate"><span class="pre">init()</span></code>を提供します。<code class="docutils literal notranslate"><span class="pre">init()</span></code>イニシャライザは、<code class="docutils literal notranslate"><span class="pre">Food</span></code>クラスの<code class="docutils literal notranslate"><span class="pre">init(name:</span> <span class="pre">String)</span></code>に<code class="docutils literal notranslate"><span class="pre">[Unnamed]</span></code>の<code class="docutils literal notranslate"><span class="pre">name</span></code>値を使って横に委任することで、省略時のプレースホルダ名を新しい食物のために用意します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">let</span> <span class="nv">mysteryMeat</span> = <span class="nv">Food</span>()
</li>
<li><span class="c"><span class="enstr">// mysteryMeat's name is "[Unnamed]"</span><!--end_enstr--><span class="jpstr">（nameMeatの名前は「[Unnamed]」です）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">The second class in the hierarchy is a subclass of <code class="docutils literal notranslate"><span class="pre">Food</span></code> called <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code>. The <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> class models an ingredient in a cooking recipe. It introduces an <code class="docutils literal notranslate"><span class="pre">Int</span></code> property called <code class="docutils literal notranslate"><span class="pre">quantity</span></code> (in addition to the <code class="docutils literal notranslate"><span class="pre">name</span></code> property it inherits from <code class="docutils literal notranslate"><span class="pre">Food</span></code>) and defines two initializers for creating <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> instances:</span><!--end_enstr-->
<span class="jpstr">
この階層構造における第二のクラスは、<code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code>と呼ばれる<code class="docutils literal notranslate"><span class="pre">Food</span></code>のサブクラスです。<code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code>クラスは、料理のレシピの材料をモデル化します。それは、<code class="docutils literal notranslate"><span class="pre">quantity</span></code>と呼ばれる<code class="docutils literal notranslate"><span class="pre">Int</span></code>プロパティ（加えてそれが<code class="docutils literal notranslate"><span class="pre">Food</span></code>から受け継ぐ<code class="docutils literal notranslate"><span class="pre">name</span></code>プロパティ）を導入して、そして<code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code>インスタンスをつくるために２つのイニシャライザを定義します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">class</span> <span class="nv">RecipeIngredient</span>: <span class="nc">Food</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">quantity</span>: <span class="nc">Int</span>
</li>
<li>    <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>, <span class="nv">quantity</span>: <span class="nc">Int</span>) {
</li>
<li>        <span class="k">self</span>.<span class="nv">quantity</span> = <span class="nv">quantity</span>
</li>
<li>        <span class="k">super</span>.<span class="nv">init</span>(<span class="nv">name</span>: <span class="nv">name</span>)
</li>
<li>    }
</li>
<li>    <span class="k">override</span> <span class="k">convenience</span> <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>) {
</li>
<li>        <span class="k">self</span>.<span class="nv">init</span>(<span class="nv">name</span>: <span class="nv">name</span>, <span class="nv">quantity</span>: <span class="m">1</span>)
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">The figure below shows the initializer chain for the <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> class:</span><!--end_enstr-->
<span class="jpstr">
下の図は、<code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code>クラスのためのイニシャライザ連鎖を示します：
</span><!--end_jpstr-->
</p>
<img alt="../_images/initializersExample02_2x.png" class="align-center" src="../images/initializersExample02_2x.png" style="width: 472px;">
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> class has a single designated initializer, <code class="docutils literal notranslate"><span class="pre">init(name:</span> <span class="pre">String,</span> <span class="pre">quantity:</span> <span class="pre">Int)</span></code>, which can be used to populate all of the properties of a new <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> instance. This initializer starts by assigning the passed <code class="docutils literal notranslate"><span class="pre">quantity</span></code> argument to the <code class="docutils literal notranslate"><span class="pre">quantity</span></code> property, which is the only new property introduced by <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code>. After doing so, the initializer delegates up to the <code class="docutils literal notranslate"><span class="pre">init(name:</span> <span class="pre">String)</span></code> initializer of the <code class="docutils literal notranslate"><span class="pre">Food</span></code> class. This process satisfies safety check 1 from <a class="reference internal" href="#ID220"><span class="std std-ref">Two-Phase Initialization</span></a> above.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code>クラスは、１つの指定イニシャライザ、<code class="docutils literal notranslate"><span class="pre">init(name:</span> <span class="pre">String,</span> <span class="pre">quantity:</span> <span class="pre">Int)</span></code>を持ちます、それは、新しい<code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code>インスタンスのプロパティの全てに何か入れるために使われることができます。このイニシャライザは、渡された<code class="docutils literal notranslate"><span class="pre">quantity</span></code>引数を<code class="docutils literal notranslate"><span class="pre">quantity</span></code>プロパティに代入することによって始めます、それは、<code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code>によって導入される唯一の新しいプロパティです。そうした後に、イニシャライザは上って<code class="docutils literal notranslate"><span class="pre">Food</span></code>クラスの<code class="docutils literal notranslate"><span class="pre">init(name:</span> <span class="pre">String)</span></code>イニシャライザに委任します。この過程は、上記の<a class="reference internal" href="#ID220"><span class="std std-ref">２段階初期化</span></a>の安全点検１を満たします。
</span><!--end_jpstr-->
</p>
<p><span class="enstr"><code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> also defines a convenience initializer, <code class="docutils literal notranslate"><span class="pre">init(name:</span> <span class="pre">String)</span></code>, which is used to create a <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> instance by name alone. This convenience initializer assumes a quantity of <code class="docutils literal notranslate"><span class="pre">1</span></code> for any <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> instance that’s created without an explicit quantity. The definition of this convenience initializer makes <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> instances quicker and more convenient to create, and avoids code duplication when creating several single-quantity <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> instances. This convenience initializer simply delegates across to the class’s designated initializer, passing in a <code class="docutils literal notranslate"><span class="pre">quantity</span></code> value of <code class="docutils literal notranslate"><span class="pre">1</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code>はまた、便宜イニシャライザ、<code class="docutils literal notranslate"><span class="pre">init(name:</span> <span class="pre">String)</span></code>を定義します、それは、名前だけで<code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code>インスタンスを作成するのに使われることができます。この便宜イニシャライザは、はっきりした量なしで作成されるあらゆる<code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code>インスタンスに対して数量<code class="docutils literal notranslate"><span class="pre">1</span></code>を仮定します。この便宜イニシャライザの定義は、<code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code>インスタンスを素早くより便利に作成されるようにします、そして数量１の<code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code>インスタンスをいくつか作成する時にコードの繰り返しを防止します。この便宜イニシャライザはそのクラスの指定イニシャライザに、単純に<code class="docutils literal notranslate"><span class="pre">quantity</span></code>に値<code class="docutils literal notranslate"><span class="pre">1</span></code>を渡して横に委任します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">init(name:</span> <span class="pre">String)</span></code> convenience initializer provided by <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> takes the same parameters as the <code class="docutils literal notranslate"><span class="pre">init(name:</span> <span class="pre">String)</span></code> <em>designated</em> initializer from <code class="docutils literal notranslate"><span class="pre">Food</span></code>. Because this convenience initializer overrides a designated initializer from its superclass, it must be marked with the <code class="docutils literal notranslate"><span class="pre">override</span></code> modifier (as described in <a class="reference internal" href="#ID221"><span class="std std-ref">Initializer Inheritance and Overriding</span></a>).</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code>によって提供される便宜イニシャライザ<code class="docutils literal notranslate"><span class="pre">init(name:</span> <span class="pre">String)</span></code>は、<code class="docutils literal notranslate"><span class="pre">Food</span></code>からの<em>指定</em>イニシャライザ<code class="docutils literal notranslate"><span class="pre">init(name:</span> <span class="pre">String)</span></code>と同じパラメータを取ります。この便宜イニシャライザがそれのスーパークラスからの指定イニシャライザをオーバーライドするので、それは<code class="docutils literal notranslate"><span class="pre">override</span></code>修飾子で印されなければなりません（<a class="reference internal" href="#ID221"><span class="std std-ref">イニシャライザの継承およびオーバーライド</span></a>で記述されるように）。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Even though <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> provides the <code class="docutils literal notranslate"><span class="pre">init(name:</span> <span class="pre">String)</span></code> initializer as a convenience initializer, <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> has nonetheless provided an implementation of all of its superclass’s designated initializers. Therefore, <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> automatically inherits all of its superclass’s convenience initializers too.</span><!--end_enstr-->
<span class="jpstr">
たとえ<code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code>が便宜イニシャライザとして<code class="docutils literal notranslate"><span class="pre">init(name:</span> <span class="pre">String)</span></code>イニシャライザを提供するとしても、<code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code>はそれでもやはりそれのスーパークラスの指定イニシャライザの全ての実装を提供しました。したがって、<code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code>は自動的にそのスーパークラスの便宜イニシャライザの全てもまた継承します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">In this example, the superclass for <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> is <code class="docutils literal notranslate"><span class="pre">Food</span></code>, which has a single convenience initializer called <code class="docutils literal notranslate"><span class="pre">init()</span></code>. This initializer is therefore inherited by <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code>. The inherited version of <code class="docutils literal notranslate"><span class="pre">init()</span></code> functions in exactly the same way as the <code class="docutils literal notranslate"><span class="pre">Food</span></code> version, except that it delegates to the <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> version of <code class="docutils literal notranslate"><span class="pre">init(name:</span> <span class="pre">String)</span></code> rather than the <code class="docutils literal notranslate"><span class="pre">Food</span></code> version.</span><!--end_enstr-->
<span class="jpstr">
この例では、<code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code>のためのスーパークラスは<code class="docutils literal notranslate"><span class="pre">Food</span></code>です、それは、<code class="docutils literal notranslate"><span class="pre">init()</span></code>と呼ばれる１つの便宜イニシャライザを持ちます。このイニシャライザは、したがって、<code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code>によって継承されます。<code class="docutils literal notranslate"><span class="pre">init()</span></code>の継承された改変板は、<code class="docutils literal notranslate"><span class="pre">Food</span></code>版と同じ正確に方法で機能しますが、それが<code class="docutils literal notranslate"><span class="pre">Food</span></code>板ではなく<code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code>版の<code class="docutils literal notranslate"><span class="pre">init(name:</span> <span class="pre">String)</span></code>に委任することを除きます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">All three of these initializers can be used to create new <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> instances:</span><!--end_enstr-->
<span class="jpstr">
これらのイニシャライザの３つ全てが、新しい<code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code>インスタンスを作るために使用されることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">let</span> <span class="nv">oneMysteryItem</span> = <span class="nv">RecipeIngredient</span>()
</li>
<li><span class="k">let</span> <span class="nv">oneBacon</span> = <span class="nv">RecipeIngredient</span>(<span class="nv">name</span>: <span class="s">"Bacon"</span>)
</li>
<li><span class="k">let</span> <span class="nv">sixEggs</span> = <span class="nv">RecipeIngredient</span>(<span class="nv">name</span>: <span class="s">"Eggs"</span>, <span class="nv">quantity</span>: <span class="m">6</span>)
</li>
</ol></div></div></div>
<p><span class="enstr">The third and final class in the hierarchy is a subclass of <code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code> called <code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code>. The <code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code> class models a recipe ingredient as it appears in a shopping list.</span><!--end_enstr-->
<span class="jpstr">
この階層構造の中の３番目の最後のクラスは、<code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code>と呼ばれる<code class="docutils literal notranslate"><span class="pre">RecipeIngredient</span></code>のサブクラスです。<code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code>クラスは、それが購入品目リストに現れるように、レシピの材料をモデル化します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Every item in the shopping list starts out as “unpurchased”. To represent this fact, <code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code> introduces a Boolean property called <code class="docutils literal notranslate"><span class="pre">purchased</span></code>, with a default value of <code class="docutils literal notranslate"><span class="pre">false</span></code>. <code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code> also adds a computed <code class="docutils literal notranslate"><span class="pre">description</span></code> property, which provides a textual description of a <code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code> instance:</span><!--end_enstr-->
<span class="jpstr">
購入品目リストでのあらゆる項目は、「未購入」として始まります。この事実を表すために、<code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code>は、<code class="docutils literal notranslate"><span class="pre">false</span></code>の省略時の値で、<code class="docutils literal notranslate"><span class="pre">purchased</span></code>と呼ばれるブールのプロパティを導入します。<code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code>はまた、計算される<code class="docutils literal notranslate"><span class="pre">description</span></code>プロパティを加えます、それは、<code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code>インスタンスのテキストでの解説を提供します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">class</span> <span class="nv">ShoppingListItem</span>: <span class="nc">RecipeIngredient</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">purchased</span> = <span class="k">false</span>
</li>
<li>    <span class="k">var</span> <span class="nv">description</span>: <span class="nc">String</span> {
</li>
<li>        <span class="k">var</span> <span class="nv">output</span> = <span class="s">"</span>\<span class="p">(</span><span class="nv">quantity</span><span class="p">)</span><span class="s"> x </span>\<span class="p">(</span><span class="nv">name</span><span class="p">)</span><span class="s">"</span>
</li>
<li>        <span class="nv">output</span> += <span class="nv">purchased</span> ? <span class="s">" ✔"</span> : <span class="s">" ✘"</span>
</li>
<li>        <span class="k">return</span> <span class="nv">output</span>
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr"><code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code> doesn’t define an initializer to provide an initial value for <code class="docutils literal notranslate"><span class="pre">purchased</span></code>, because items in a shopping list (as modeled here) always start out unpurchased.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code>は<code class="docutils literal notranslate"><span class="pre">purchased</span></code>に初期値を用意するイニシャライザを定義しません、なぜなら、購入品目リストの項目が（ここでモデル化されるように）常に未購入で始められるからです。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">Because it provides a default value for all of the properties it introduces and doesn’t define any initializers itself, <code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code> automatically inherits <em>all</em> of the designated and convenience initializers from its superclass.</span><!--end_enstr-->
<span class="jpstr">
それが、省略時の値をそれが導入するプロパティの全てに与えて、そしてまったくイニシャライザを定義しないので、<code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code>はそのスーパークラスから自動的に指定および便宜イニシャライザの<em>全て</em>を継承します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The figure below shows the overall initializer chain for all three classes:</span><!--end_enstr-->
<span class="jpstr">
下の図は、３つのクラス全てのために全体的なイニシャライザ連鎖を示します：
</span><!--end_jpstr-->
</p>
<img alt="../_images/initializersExample03_2x.png" class="align-center" src="../images/initializersExample03_2x.png" style="width: 473px;">
<p><span class="enstr">You can use all three of the inherited initializers to create a new <code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code> instance:</span><!--end_enstr-->
<span class="jpstr">
あなたは、継承されたイニシャライザの３つ全てを新しい<code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code>インスタンスをつくるために使うことができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">var</span> <span class="nv">breakfastList</span> = [
</li>
<li>    <span class="nv">ShoppingListItem</span>(),
</li>
<li>    <span class="nv">ShoppingListItem</span>(<span class="nv">name</span>: <span class="s">"Bacon"</span>),
</li>
<li>    <span class="nv">ShoppingListItem</span>(<span class="nv">name</span>: <span class="s">"Eggs"</span>, <span class="nv">quantity</span>: <span class="m">6</span>),
</li>
<li>]
</li>
<li><span class="nv">breakfastList</span>[<span class="m">0</span>].<span class="nv">name</span> = <span class="s">"Orange juice"</span>
</li>
<li><span class="nv">breakfastList</span>[<span class="m">0</span>].<span class="nv">purchased</span> = <span class="k">true</span>
</li>
<li><span class="k">for</span> <span class="nv">item</span> <span class="k">in</span> <span class="nv">breakfastList</span> {
</li>
<li>    <span class="nv">print</span>(<span class="nv">item</span>.<span class="nv">description</span>)
</li>
<li>}
</li>
<li><span class="c">// 1 x Orange juice ✔</span>
</li>
<li><span class="c">// 1 x Bacon ✘</span>
</li>
<li><span class="c">// 6 x Eggs ✘</span>
</li>
</ol></div></div></div>
<p><span class="enstr">Here, a new array called <code class="docutils literal notranslate"><span class="pre">breakfastList</span></code> is created from an array literal containing three new <code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code> instances. The type of the array is inferred to be <code class="docutils literal notranslate"><span class="pre">[ShoppingListItem]</span></code>. After the array is created, the name of the <code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code> at the start of the array is changed from <code class="docutils literal notranslate"><span class="pre">"[Unnamed]"</span></code> to <code class="docutils literal notranslate"><span class="pre">"Orange</span> <span class="pre">juice"</span></code> and it’s marked as having been purchased. Printing the description of each item in the array shows that their default states have been set as expected.</span><!--end_enstr-->
<span class="jpstr">
ここでは、<code class="docutils literal notranslate"><span class="pre">breakfastList</span></code>と呼ばれる新しい配列は、３つの新しい<code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code>インスタンスを含んでいる配列リテラルからつくられます。配列の型は、<code class="docutils literal notranslate"><span class="pre">[ShoppingListItem]</span></code>であると推論されます。配列がつくられたあと、配列の始めの<code class="docutils literal notranslate"><span class="pre">ShoppingListItem</span></code>の名前は、<code class="docutils literal notranslate"><span class="pre">"[Unnamed]"</span></code>から<code class="docutils literal notranslate"><span class="pre">"Orange</span> <span class="pre">juice"</span></code>へ変えられます、そしてそれは購入済みとして印されます。配列の各項目の説明を出力することは、予想されるようにそれらの省略時の状態が設定されたことを示します。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID224">
<h2><span class="enstr">Failable Initializers<a class="headerlink" href="#ID224" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
失敗できるイニシャライザ<a class="headerlink" href="#ID224" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">It’s sometimes useful to define a class, structure, or enumeration for which initialization can fail. This failure might be triggered by invalid initialization parameter values, the absence of a required external resource, or some other condition that prevents initialization from succeeding.</span><!--end_enstr-->
<span class="jpstr">
それに対するイニシャライザが失敗できるクラス、構造体、または列挙を定義することは時として便利です。この失敗は、無効な初期化パラメータ、必須の外部リソースの欠如、または初期化がうまくいくのを妨げる何か他の状況によって引き起こされるかもしれません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">To cope with initialization conditions that can fail, define one or more failable initializers as part of a class, structure, or enumeration definition. You write a failable initializer by placing a question mark after the <code class="docutils literal notranslate"><span class="pre">init</span></code> keyword (<code class="docutils literal notranslate"><span class="pre">init?</span></code>).</span><!--end_enstr-->
<span class="jpstr">
失敗の可能性がある初期化状況にうまく対処するために、１つ以上の失敗可能なイニシャライザをクラス、構造体、または列挙定義の一部として定義してください。あなたは、失敗可能なイニシャライザを疑問符を<code class="docutils literal notranslate"><span class="pre">init</span></code>キーワードの後に置くこと（<code class="docutils literal notranslate"><span class="pre">init?</span></code>）によって記述します。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">You can’t define a failable and a nonfailable initializer with the same parameter types and names.</span><!--end_enstr-->
<span class="jpstr">
あなたは、失敗できる及び失敗できないイニシャライザを同じパラメータの型と名前で定義することはできません。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">A failable initializer creates an <em>optional</em> value of the type it initializes. You write <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">nil</span></code> within a failable initializer to indicate a point at which initialization failure can be triggered.</span><!--end_enstr-->
<span class="jpstr">
失敗できるイニシャライザは、そのイニシャライザの型の<em>オプショナル</em>の値を作成します。あなたは失敗できるイニシャライザの内部で<code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">nil</span></code>を書くことで、そこにおいて初期化失敗が引き起こされる可能性がある地点を指し示します。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Strictly speaking, initializers don’t return a value. Rather, their role is to ensure that <code class="docutils literal notranslate"><span class="pre">self</span></code> is fully and correctly initialized by the time that initialization ends. Although you write <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">nil</span></code> to trigger an initialization failure, you don’t use the <code class="docutils literal notranslate"><span class="pre">return</span></code> keyword to indicate initialization success.</span><!--end_enstr-->
<span class="jpstr">
厳密にいえば、イニシャライザは値を返しません。というより、それの役割は、初期化が終わるまでに<code class="docutils literal notranslate"><span class="pre">self</span></code>が完全にそして正確に初期化されることを確実にすることです。あなたは<code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">nil</span></code>を書くことで初期化失敗を引き起こすけれども、あなたは<code class="docutils literal notranslate"><span class="pre">return</span></code>キーワードを初期化成功を指し示すためには使いません。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">For instance, failable initializers are implemented for numeric type conversions. To ensure conversion between numeric types maintains the value exactly, use the <code class="docutils literal notranslate"><span class="pre">init(exactly:)</span></code> initializer. If the type conversion can’t maintain the value, the initializer fails.</span><!--end_enstr-->
<span class="jpstr">
例えば、いくつかの失敗できるイニシャライザが数値型変換のために実装されます。数値型の間の変換がその値を正確に維持するのを保証するために、<code class="docutils literal notranslate"><span class="pre">init(exactly:)</span></code>イニシャライザを使ってください。型変換が値を維持できないならば、イニシャライザは失敗します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">let</span> <span class="nv">wholeNumber</span>: <span class="nc">Double</span> = <span class="m">12345.0</span>
</li>
<li><span class="k">let</span> <span class="nv">pi</span> = <span class="m">3.14159</span>
</li>
<li>
</li>
<li><span class="k">if</span> <span class="k">let</span> <span class="nv">valueMaintained</span> = <span class="nv">Int</span>(<span class="nv">exactly</span>: <span class="nv">wholeNumber</span>) {
</li>
<li>    <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">wholeNumber</span><span class="p">)</span><span class="s"> conversion to Int maintains value of </span>\<span class="p">(</span><span class="nv">valueMaintained</span><span class="p">)</span><span class="s">"</span>)
</li>
<li>}
</li>
<li><span class="c">// Prints "12345.0 conversion to Int maintains value of 12345"</span>
</li>
<li>
</li>
<li><span class="k">let</span> <span class="nv">valueChanged</span> = <span class="nv">Int</span>(<span class="nv">exactly</span>: <span class="nv">pi</span>)
</li>
<li><span class="c"><span class="enstr">// valueChanged is of type Int?, not Int</span><!--end_enstr--><span class="jpstr">（valueChanged は、型 Int? のものです、Int ではなく）</span><!--end_jpstr--></span>
</li>
<li>
</li>
<li><span class="k">if</span> <span class="nv">valueChanged</span> == <span class="k">nil</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">pi</span><span class="p">)</span><span class="s"> conversion to Int doesn't maintain value"</span>)
</li>
<li>}
</li>
<li><span class="c">// Prints "3.14159 conversion to Int doesn't maintain value"</span>
</li>
</ol></div></div></div>
<p><span class="enstr">The example below defines a structure called <code class="docutils literal notranslate"><span class="pre">Animal</span></code>, with a constant <code class="docutils literal notranslate"><span class="pre">String</span></code> property called <code class="docutils literal notranslate"><span class="pre">species</span></code>. The <code class="docutils literal notranslate"><span class="pre">Animal</span></code> structure also defines a failable initializer with a single parameter called <code class="docutils literal notranslate"><span class="pre">species</span></code>. This initializer checks if the <code class="docutils literal notranslate"><span class="pre">species</span></code> value passed to the initializer is an empty string. If an empty string is found, an initialization failure is triggered. Otherwise, the <code class="docutils literal notranslate"><span class="pre">species</span></code> property’s value is set, and initialization succeeds:</span><!--end_enstr-->
<span class="jpstr">
以下の例は、<code class="docutils literal notranslate"><span class="pre">Animal</span></code>と呼ばれるある構造体を、<code class="docutils literal notranslate"><span class="pre">species</span></code>と呼ばれる定数<code class="docutils literal notranslate"><span class="pre">String</span></code>プロパティを使って定義します。<code class="docutils literal notranslate"><span class="pre">Animal</span></code>構造体はまた、<code class="docutils literal notranslate"><span class="pre">species</span></code>と呼ばれるただ１つのパラメータを持つ、失敗できるイニシャライザを定義します。このイニシャライザは、イニシャライザに渡される<code class="docutils literal notranslate"><span class="pre">species</span></code>値が空の文字列かどうか検査します。もし空の文字列が見つけられたならば、初期化失敗が引き起こされます。そうでなければ、<code class="docutils literal notranslate"><span class="pre">species</span></code>プロパティの値は設定されて、初期化は成功します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">struct</span> <span class="nv">Animal</span> {
</li>
<li>    <span class="k">let</span> <span class="nv">species</span>: <span class="nc">String</span>
</li>
<li>    <span class="k">init</span>?(<span class="nv">species</span>: <span class="nc">String</span>) {
</li>
<li>        <span class="k">if</span> <span class="nv">species</span>.<span class="nv">isEmpty</span> { <span class="k">return</span> <span class="k">nil</span> }
</li>
<li>        <span class="k">self</span>.<span class="nv">species</span> = <span class="nv">species</span>
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">You can use this failable initializer to try to initialize a new <code class="docutils literal notranslate"><span class="pre">Animal</span></code> instance and to check if initialization succeeded:</span><!--end_enstr-->
<span class="jpstr">
あなたは、この失敗できるイニシャライザを使うことで、新しい<code class="docutils literal notranslate"><span class="pre">Animal</span></code>インスタンスを初期化することを試みて、初期化が成功したか確認することができます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">let</span> <span class="nv">someCreature</span> = <span class="nv">Animal</span>(<span class="nv">species</span>: <span class="s">"Giraffe"</span>)
</li>
<li><span class="c"><span class="enstr">// someCreature is of type Animal?, not Animal</span><!--end_enstr--><span class="jpstr">（someCreatureは、型Animal?です、Animalではなく）</span><!--end_jpstr--></span>
</li>
<li>
</li>
<li><span class="k">if</span> <span class="k">let</span> <span class="nv">giraffe</span> = <span class="nv">someCreature</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"An animal was initialized with a species of </span>\<span class="p">(</span><span class="nv">giraffe</span>.<span class="nv">species</span><span class="p">)</span><span class="s">"</span>)
</li>
<li>}
</li>
<li><span class="c"><span class="enstr">// Prints "An animal was initialized with a species of Giraffe"</span><!--end_enstr--><span class="jpstr">（「一匹の動物がキリンの種族で初期化された」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">If you pass an empty string value to the failable initializer’s <code class="docutils literal notranslate"><span class="pre">species</span></code> parameter, the initializer triggers an initialization failure:</span><!--end_enstr-->
<span class="jpstr">
あなたが失敗できるイニシャライザの<code class="docutils literal notranslate"><span class="pre">species</span></code>パラメータに空の文字列値を渡すならば、イニシャライザは初期化失敗を引き起こします：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">let</span> <span class="nv">anonymousCreature</span> = <span class="nv">Animal</span>(<span class="nv">species</span>: <span class="s">""</span>)
</li>
<li><span class="c"><span class="enstr">// anonymousCreature is of type Animal?, not Animal</span><!--end_enstr--><span class="jpstr">（anonymousCreatureは、型Animal?です、Animalではなく）</span><!--end_jpstr--></span>
</li>
<li>
</li>
<li><span class="k">if</span> <span class="nv">anonymousCreature</span> == <span class="k">nil</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"The anonymous creature couldn't be initialized"</span>)
</li>
<li>}
</li>
<li><span class="c">// Prints "The anonymous creature couldn't be initialized"</span>
</li>
</ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Checking for an empty string value (such as <code class="docutils literal notranslate"><span class="pre">""</span></code> rather than <code class="docutils literal notranslate"><span class="pre">"Giraffe"</span></code>) isn’t the same as checking for <code class="docutils literal notranslate"><span class="pre">nil</span></code> to indicate the absence of an <em>optional</em> <code class="docutils literal notranslate"><span class="pre">String</span></code> value. In the example above, an empty string (<code class="docutils literal notranslate"><span class="pre">""</span></code>) is a valid, non-optional <code class="docutils literal notranslate"><span class="pre">String</span></code>. However, it’s not appropriate for an animal to have an empty string as the value of its <code class="docutils literal notranslate"><span class="pre">species</span></code> property. To model this restriction, the failable initializer triggers an initialization failure if an empty string is found.</span><!--end_enstr-->
<span class="jpstr">
空の文字列値（例えば<code class="docutils literal notranslate"><span class="pre">"Giraffe"</span></code>といったものでなく<code class="docutils literal notranslate"><span class="pre">""</span></code>）について調べることは、<em>オプショナル</em>の<code class="docutils literal notranslate"><span class="pre">String</span></code>値の不在を指し示す<code class="docutils literal notranslate"><span class="pre">nil</span></code>について調べることと同じではありません。上の例において、空の文字列（<code class="docutils literal notranslate"><span class="pre">""</span></code>）は有効な、オプショナルでない<code class="docutils literal notranslate"><span class="pre">String</span></code>です。しかしながら、ある動物にとってそれの<code class="docutils literal notranslate"><span class="pre">species</span></code>（種族）プロパティの値として空の文字列を持つことはふさわしくありません。この制約条件をモデル化するために、失敗できるイニシャライザは空の文字列が見つけられるならば初期化失敗を引き起こします。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID225">
<h3><span class="enstr">Failable Initializers for Enumerations<a class="headerlink" href="#ID225" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
列挙のための失敗できるイニシャライザ<a class="headerlink" href="#ID225" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">You can use a failable initializer to select an appropriate enumeration case based on one or more parameters. The initializer can then fail if the provided parameters don’t match an appropriate enumeration case.</span><!--end_enstr-->
<span class="jpstr">
あなたは、失敗できるイニシャライザを使って適切な列挙ケース節を１つ以上のパラメータに基づいて選ぶことができます。このイニシャライザは、提供されたパラメータが適切な列挙ケース節に適合しないならばその時に失敗できます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The example below defines an enumeration called <code class="docutils literal notranslate"><span class="pre">TemperatureUnit</span></code>, with three possible states (<code class="docutils literal notranslate"><span class="pre">kelvin</span></code>, <code class="docutils literal notranslate"><span class="pre">celsius</span></code>, and <code class="docutils literal notranslate"><span class="pre">fahrenheit</span></code>). A failable initializer is used to find an appropriate enumeration case for a <code class="docutils literal notranslate"><span class="pre">Character</span></code> value representing a temperature symbol:</span><!--end_enstr-->
<span class="jpstr">
以下の例は、３つの可能な状態（<code class="docutils literal notranslate"><span class="pre">kelvin</span></code>、<code class="docutils literal notranslate"><span class="pre">celsius</span></code>、そして<code class="docutils literal notranslate"><span class="pre">fahrenheit</span></code>）を持つ、<code class="docutils literal notranslate"><span class="pre">TemperatureUnit</span></code>と呼ばれる列挙を定義します。失敗できるイニシャライザは、ある温度記号で表されている<code class="docutils literal notranslate"><span class="pre">Character</span></code>値に対して適切な列挙ケース節を見つけるために使用されます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">enum</span> <span class="nv">TemperatureUnit</span> {
</li>
<li>    <span class="k">case</span> <span class="nv">kelvin</span>, <span class="nv">celsius</span>, <span class="nv">fahrenheit</span>
</li>
<li>    <span class="k">init</span>?(<span class="nv">symbol</span>: <span class="nc">Character</span>) {
</li>
<li>        <span class="k">switch</span> <span class="nv">symbol</span> {
</li>
<li>        <span class="k">case</span> <span class="s">"K"</span>:
</li>
<li>            <span class="k">self</span> = .<span class="nv">kelvin</span>
</li>
<li>        <span class="k">case</span> <span class="s">"C"</span>:
</li>
<li>            <span class="k">self</span> = .<span class="nv">celsius</span>
</li>
<li>        <span class="k">case</span> <span class="s">"F"</span>:
</li>
<li>            <span class="k">self</span> = .<span class="nv">fahrenheit</span>
</li>
<li>        <span class="k">default</span>:
</li>
<li>            <span class="k">return</span> <span class="k">nil</span>
</li>
<li>        }
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">You can use this failable initializer to choose an appropriate enumeration case for the three possible states and to cause initialization to fail if the parameter doesn’t match one of these states:</span><!--end_enstr-->
<span class="jpstr">
あなたは、この失敗できるイニシャライザを使って、適切な列挙ケース節を３つの可能な状態に対して選び取るように、そしてパラメータが３つの状態の内の１つに合わない場合に初期化が失敗するようにできます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">let</span> <span class="nv">fahrenheitUnit</span> = <span class="nv">TemperatureUnit</span>(<span class="nv">symbol</span>: <span class="s">"F"</span>)
</li>
<li><span class="k">if</span> <span class="nv">fahrenheitUnit</span> != <span class="k">nil</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"This is a defined temperature unit, so initialization succeeded."</span>)
</li>
<li>}
</li>
<li><span class="c"><span class="enstr">// Prints "This is a defined temperature unit, so initialization succeeded."</span><!--end_enstr--><span class="jpstr">（「これは定義済み温度単位です、なので初期化は成功しました。」を出力します）</span><!--end_jpstr--></span>
</li>
<li>
</li>
<li><span class="k">let</span> <span class="nv">unknownUnit</span> = <span class="nv">TemperatureUnit</span>(<span class="nv">symbol</span>: <span class="s">"X"</span>)
</li>
<li><span class="k">if</span> <span class="nv">unknownUnit</span> == <span class="k">nil</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"This isn't a defined temperature unit, so initialization failed."</span>)
</li>
<li>}
</li>
<li><span class="c"><span class="enstr">// Prints "This isn't a defined temperature unit, so initialization failed."</span><!--end_enstr--><span class="jpstr">（「これは定義済み温度単位ではありません、なので初期化は失敗しました。」を出力します」）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
</div>
<div class="section" id="ID226">
<h3><span class="enstr">Failable Initializers for Enumerations with Raw Values<a class="headerlink" href="#ID226" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
生の値を使う列挙のための失敗できるイニシャライザ<a class="headerlink" href="#ID226" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">Enumerations with raw values automatically receive a failable initializer, <code class="docutils literal notranslate"><span class="pre">init?(rawValue:)</span></code>, that takes a parameter called <code class="docutils literal notranslate"><span class="pre">rawValue</span></code> of the appropriate raw-value type and selects a matching enumeration case if one is found, or triggers an initialization failure if no matching value exists.</span><!--end_enstr-->
<span class="jpstr">
生の値を持つ列挙は、自動的にひとつの失敗できるイニシャライザ、<code class="docutils literal notranslate"><span class="pre">init?(rawValue:)</span></code>を受け取ります、それは、適切な「生の値」型の<code class="docutils literal notranslate"><span class="pre">rawValue</span></code>と呼ばれるパラメータを取って、適合する列挙ケース節をそれが見つかったならば選択します、または適合する値が存在しないならば初期化失敗を引き起こします。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can rewrite the <code class="docutils literal notranslate"><span class="pre">TemperatureUnit</span></code> example from above to use raw values of type <code class="docutils literal notranslate"><span class="pre">Character</span></code> and to take advantage of the <code class="docutils literal notranslate"><span class="pre">init?(rawValue:)</span></code> initializer:</span><!--end_enstr-->
<span class="jpstr">
あなたは、上の<code class="docutils literal notranslate"><span class="pre">TemperatureUnit</span></code>例を<code class="docutils literal notranslate"><span class="pre">Character</span></code>型の生の値を使うように、そして<code class="docutils literal notranslate"><span class="pre">init?(rawValue:)</span></code>イニシャライザを活用するように書き直すことができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">enum</span> <span class="nv">TemperatureUnit</span>: <span class="nc">Character</span> {
</li>
<li>    <span class="k">case</span> <span class="nv">kelvin</span> = <span class="s">"K"</span>, <span class="nv">celsius</span> = <span class="s">"C"</span>, <span class="nv">fahrenheit</span> = <span class="s">"F"</span>
</li>
<li>}
</li>
<li>
</li>
<li><span class="k">let</span> <span class="nv">fahrenheitUnit</span> = <span class="nv">TemperatureUnit</span>(<span class="nv">rawValue</span>: <span class="s">"F"</span>)
</li>
<li><span class="k">if</span> <span class="nv">fahrenheitUnit</span> != <span class="k">nil</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"This is a defined temperature unit, so initialization succeeded."</span>)
</li>
<li>}
</li>
<li><span class="c"><span class="enstr">// Prints "This is a defined temperature unit, so initialization succeeded."</span><!--end_enstr--><span class="jpstr">（「これは定義済み温度単位です、なので初期化は成功しました。」を出力します）</span><!--end_jpstr--></span>
</li>
<li>
</li>
<li><span class="k">let</span> <span class="nv">unknownUnit</span> = <span class="nv">TemperatureUnit</span>(<span class="nv">rawValue</span>: <span class="s">"X"</span>)
</li>
<li><span class="k">if</span> <span class="nv">unknownUnit</span> == <span class="k">nil</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"This isn't a defined temperature unit, so initialization failed."</span>)
</li>
<li>}
</li>
<li><span class="c"><span class="enstr">// Prints "This isn't a defined temperature unit, so initialization failed."</span><!--end_enstr--><span class="jpstr">（「これは定義済み温度単位ではありません、なので初期化は失敗しました。」を出力します」）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
</div>
<div class="section" id="ID228">
<h3><span class="enstr">Propagation of Initialization Failure<a class="headerlink" href="#ID228" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
初期化失敗の伝播<a class="headerlink" href="#ID228" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">A failable initializer of a class, structure, or enumeration can delegate across to another failable initializer from the same class, structure, or enumeration. Similarly, a subclass failable initializer can delegate up to a superclass failable initializer.</span><!--end_enstr-->
<span class="jpstr">
クラス、構造体、または列挙のための失敗できるイニシャライザは、同じクラス、構造体、または列挙からの別の失敗できるイニシャライザに横つながりに委任することができます。同じように、サブクラスの失敗できるイニシャライザは、スーパークラスの失敗できるイニシャライザにさかのぼって委任することができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">In either case, if you delegate to another initializer that causes initialization to fail, the entire initialization process fails immediately, and no further initialization code is executed.</span><!--end_enstr-->
<span class="jpstr">
どちらの場合においても、あなたが初期化失敗の原因となる別のイニシャライザに委任するならば、全体の初期化プロセスは直ちに失敗します、そしてそれ以上初期化コードが実行されることはありません。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">A failable initializer can also delegate to a nonfailable initializer. Use this approach if you need to add a potential failure state to an existing initialization process that doesn’t otherwise fail.</span><!--end_enstr-->
<span class="jpstr">
失敗できるイニシャライザは、また、失敗できないイニシャライザへと委任することもできます。あなたが、起こりうる失敗状況を、その場合にも失敗しない既存の初期化プロセスに加える必要がある場合に、このやり方を使ってください。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">The example below defines a subclass of <code class="docutils literal notranslate"><span class="pre">Product</span></code> called <code class="docutils literal notranslate"><span class="pre">CartItem</span></code>. The <code class="docutils literal notranslate"><span class="pre">CartItem</span></code> class models an item in an online shopping cart. <code class="docutils literal notranslate"><span class="pre">CartItem</span></code> introduces a stored constant property called <code class="docutils literal notranslate"><span class="pre">quantity</span></code> and ensures that this property always has a value of at least <code class="docutils literal notranslate"><span class="pre">1</span></code>:</span><!--end_enstr-->
<span class="jpstr">
下の例は、<code class="docutils literal notranslate"><span class="pre">CartItem</span></code>と呼ばれる<code class="docutils literal notranslate"><span class="pre">Product</span></code>のサブクラスを定義します。<code class="docutils literal notranslate"><span class="pre">CartItem</span></code>クラスは、あるオンライン買物かごの中のひとつの項目をモデル化します。<code class="docutils literal notranslate"><span class="pre">CartItem</span></code>は<code class="docutils literal notranslate"><span class="pre">quantity</span></code>と呼ばれる格納定数プロパティを導入します、そしてこのプロパティが常に少なくとも<code class="docutils literal notranslate"><span class="pre">1</span></code>の値を持つことを確実にします：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">class</span> <span class="nv">Product</span> {
</li>
<li>    <span class="k">let</span> <span class="nv">name</span>: <span class="nc">String</span>
</li>
<li>    <span class="k">init</span>?(<span class="nv">name</span>: <span class="nc">String</span>) {
</li>
<li>        <span class="k">if</span> <span class="nv">name</span>.<span class="nv">isEmpty</span> { <span class="k">return</span> <span class="k">nil</span> }
</li>
<li>        <span class="k">self</span>.<span class="nv">name</span> = <span class="nv">name</span>
</li>
<li>    }
</li>
<li>}
</li>
<li>
</li>
<li><span class="k">class</span> <span class="nv">CartItem</span>: <span class="nc">Product</span> {
</li>
<li>    <span class="k">let</span> <span class="nv">quantity</span>: <span class="nc">Int</span>
</li>
<li>    <span class="k">init</span>?(<span class="nv">name</span>: <span class="nc">String</span>, <span class="nv">quantity</span>: <span class="nc">Int</span>) {
</li>
<li>        <span class="k">if</span> <span class="nv">quantity</span> &lt; <span class="m">1</span> { <span class="k">return</span> <span class="k">nil</span> }
</li>
<li>        <span class="k">self</span>.<span class="nv">quantity</span> = <span class="nv">quantity</span>
</li>
<li>        <span class="k">super</span>.<span class="nv">init</span>(<span class="nv">name</span>: <span class="nv">name</span>)
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">The failable initializer for <code class="docutils literal notranslate"><span class="pre">CartItem</span></code> starts by validating that it has received a <code class="docutils literal notranslate"><span class="pre">quantity</span></code> value of <code class="docutils literal notranslate"><span class="pre">1</span></code> or more. If the <code class="docutils literal notranslate"><span class="pre">quantity</span></code> is invalid, the entire initialization process fails immediately and no further initialization code is executed. Likewise, the failable initializer for <code class="docutils literal notranslate"><span class="pre">Product</span></code> checks the <code class="docutils literal notranslate"><span class="pre">name</span></code> value, and the initializer process fails immediately if <code class="docutils literal notranslate"><span class="pre">name</span></code> is the empty string.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">CartItem</span></code>のための失敗できるイニシャライザは、それが<code class="docutils literal notranslate"><span class="pre">1</span></code>以上の<code class="docutils literal notranslate"><span class="pre">quantity</span></code>値を受け取ったことを検証することによって始めます。<code class="docutils literal notranslate"><span class="pre">quantity</span></code>が無効ならば、初期化処理全体が直ちに失敗して、以降の初期化コードは実行されません。同じように、<code class="docutils literal notranslate"><span class="pre">Product</span></code>のための失敗できるイニシャライザは、<code class="docutils literal notranslate"><span class="pre">name</span></code>値を確認して、<code class="docutils literal notranslate"><span class="pre">name</span></code>が空の文字列ならば初期化処理は直ちに失敗します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">If you create a <code class="docutils literal notranslate"><span class="pre">CartItem</span></code> instance with a nonempty name and a quantity of <code class="docutils literal notranslate"><span class="pre">1</span></code> or more, initialization succeeds:</span><!--end_enstr-->
<span class="jpstr">
あなたが<code class="docutils literal notranslate"><span class="pre">CartItem</span></code>インスタンスを空でない名前と<code class="docutils literal notranslate"><span class="pre">1</span></code>以上の数量で作成するならば、初期化は成功します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">if</span> <span class="k">let</span> <span class="nv">twoSocks</span> = <span class="nv">CartItem</span>(<span class="nv">name</span>: <span class="s">"sock"</span>, <span class="nv">quantity</span>: <span class="m">2</span>) {
</li>
<li>    <span class="nv">print</span>(<span class="s">"Item: </span>\<span class="p">(</span><span class="nv">twoSocks</span>.<span class="nv">name</span><span class="p">)</span><span class="s">, quantity: </span>\<span class="p">(</span><span class="nv">twoSocks</span>.<span class="nv">quantity</span><span class="p">)</span><span class="s">"</span>)
</li>
<li>}
</li>
<li><span class="c"><span class="enstr">// Prints "Item: sock, quantity: 2"</span><!--end_enstr--><span class="jpstr">（「項目：靴下、数量：２」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">If you try to create a <code class="docutils literal notranslate"><span class="pre">CartItem</span></code> instance with a <code class="docutils literal notranslate"><span class="pre">quantity</span></code> value of <code class="docutils literal notranslate"><span class="pre">0</span></code>, the <code class="docutils literal notranslate"><span class="pre">CartItem</span></code> initializer causes initialization to fail:</span><!--end_enstr-->
<span class="jpstr">
あなたが<code class="docutils literal notranslate"><span class="pre">CartItem</span></code>インスタンスを<code class="docutils literal notranslate"><span class="pre">0</span></code>の<code class="docutils literal notranslate"><span class="pre">quantity</span></code>値で作成することを試みるならば、<code class="docutils literal notranslate"><span class="pre">CartItem</span></code>イニシャライザが初期化を失敗する原因となります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">if</span> <span class="k">let</span> <span class="nv">zeroShirts</span> = <span class="nv">CartItem</span>(<span class="nv">name</span>: <span class="s">"shirt"</span>, <span class="nv">quantity</span>: <span class="m">0</span>) {
</li>
<li>    <span class="nv">print</span>(<span class="s">"Item: </span>\<span class="p">(</span><span class="nv">zeroShirts</span>.<span class="nv">name</span><span class="p">)</span><span class="s">, quantity: </span>\<span class="p">(</span><span class="nv">zeroShirts</span>.<span class="nv">quantity</span><span class="p">)</span><span class="s">"</span>)
</li>
<li>} <span class="k">else</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"Unable to initialize zero shirts"</span>)
</li>
<li>}
</li>
<li><span class="c"><span class="enstr">// Prints "Unable to initialize zero shirts"</span><!--end_enstr--><span class="jpstr">（「０個のシャツを初期化できません」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">Similarly, if you try to create a <code class="docutils literal notranslate"><span class="pre">CartItem</span></code> instance with an empty <code class="docutils literal notranslate"><span class="pre">name</span></code> value, the superclass <code class="docutils literal notranslate"><span class="pre">Product</span></code> initializer causes initialization to fail:</span><!--end_enstr-->
<span class="jpstr">
同様に、あなたが<code class="docutils literal notranslate"><span class="pre">CartItem</span></code>インスタンスを空の<code class="docutils literal notranslate"><span class="pre">name</span></code>値で作成することを試みるならば、スーパークラスの<code class="docutils literal notranslate"><span class="pre">Product</span></code>イニシャライザは初期化が失敗する原因となります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">if</span> <span class="k">let</span> <span class="nv">oneUnnamed</span> = <span class="nv">CartItem</span>(<span class="nv">name</span>: <span class="s">""</span>, <span class="nv">quantity</span>: <span class="m">1</span>) {
</li>
<li>    <span class="nv">print</span>(<span class="s">"Item: </span>\<span class="p">(</span><span class="nv">oneUnnamed</span>.<span class="nv">name</span><span class="p">)</span><span class="s">, quantity: </span>\<span class="p">(</span><span class="nv">oneUnnamed</span>.<span class="nv">quantity</span><span class="p">)</span><span class="s">"</span>)
</li>
<li>} <span class="k">else</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"Unable to initialize one unnamed product"</span>)
</li>
<li>}
</li>
<li><span class="c"><span class="enstr">// Prints "Unable to initialize one unnamed product"</span><!--end_enstr--><span class="jpstr">（「１個の名前のない製品を初期化できません」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
</div>
<div class="section" id="ID229">
<h3><span class="enstr">Overriding a Failable Initializer<a class="headerlink" href="#ID229" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
失敗できるイニシャライザのオーバーライド<a class="headerlink" href="#ID229" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">You can override a superclass failable initializer in a subclass, just like any other initializer. Alternatively, you can override a superclass failable initializer with a subclass <em>nonfailable</em> initializer. This enables you to define a subclass for which initialization can’t fail, even though initialization of the superclass is allowed to fail.</span><!--end_enstr-->
<span class="jpstr">
あなたは、スーパークラスの失敗できるイニシャライザをサブクラスにおいてオーバーライドすることが、何らかの他のイニシャライザとまったく同じようにできます。または代わりに、あなたはスーパークラスの失敗できるイニシャライザをサブクラスの<em>失敗できない</em>イニシャライザでオーバーライドできます。これはあなたに、それに対しての初期化が失敗することが出来ないサブクラスを定義することを可能にします、たとえスーパークラスの初期化が失敗することが許されるとしてもです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Note that if you override a failable superclass initializer with a nonfailable subclass initializer, the only way to delegate up to the superclass initializer is to force-unwrap the result of the failable superclass initializer.</span><!--end_enstr-->
<span class="jpstr">
注意することは、あなたが失敗できるスーパークラス・イニシャライザを、失敗できないサブクラス・イニシャライザでオーバーライドする場合、唯一の方法としてスーパークラスのイニシャライザにまで委任するには、失敗できるスーパークラスイニシャライザの結果を強制アンラップすることです。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">You can override a failable initializer with a nonfailable initializer but not the other way around.</span><!--end_enstr-->
<span class="jpstr">
あなたは失敗できるイニシャライザを、失敗できないイニシャライザでオーバーライドできます、しかし逆はできません。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">The example below defines a class called <code class="docutils literal notranslate"><span class="pre">Document</span></code>. This class models a document that can be initialized with a <code class="docutils literal notranslate"><span class="pre">name</span></code> property that’s either a nonempty string value or <code class="docutils literal notranslate"><span class="pre">nil</span></code>, but can’t be an empty string:</span><!--end_enstr-->
<span class="jpstr">
下の例は、<code class="docutils literal notranslate"><span class="pre">Document</span></code>と呼ばれるクラスを定義します。このクラスはある書類をモデル化します、それは空でない文字列か<code class="docutils literal notranslate"><span class="pre">nil</span></code>のどちらかである<code class="docutils literal notranslate"><span class="pre">name</span></code>プロパティで初期化されることができます、しかし空の文字列であることはできません：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">class</span> <span class="nv">Document</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">name</span>: <span class="nc">String</span>?
</li>
<li>    <span class="c"><span class="enstr">// this initializer creates a document with a nil name value</span><!--end_enstr--><span class="jpstr">（このイニシャライザはnilのname値を使って書類を作成します）</span><!--end_jpstr--></span>
</li>
<li>    <span class="k">init</span>() {}
</li>
<li>    <span class="c"><span class="enstr">// this initializer creates a document with a nonempty name value</span><!--end_enstr--><span class="jpstr">（このイニシャライザは空でないname値を使って書類を作成します）</span><!--end_jpstr--></span>
</li>
<li>    <span class="k">init</span>?(<span class="nv">name</span>: <span class="nc">String</span>) {
</li>
<li>        <span class="k">if</span> <span class="nv">name</span>.<span class="nv">isEmpty</span> { <span class="k">return</span> <span class="k">nil</span> }
</li>
<li>        <span class="k">self</span>.<span class="nv">name</span> = <span class="nv">name</span>
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">The next example defines a subclass of <code class="docutils literal notranslate"><span class="pre">Document</span></code> called <code class="docutils literal notranslate"><span class="pre">AutomaticallyNamedDocument</span></code>. The <code class="docutils literal notranslate"><span class="pre">AutomaticallyNamedDocument</span></code> subclass overrides both of the designated initializers introduced by <code class="docutils literal notranslate"><span class="pre">Document</span></code>. These overrides ensure that an <code class="docutils literal notranslate"><span class="pre">AutomaticallyNamedDocument</span></code> instance has an initial <code class="docutils literal notranslate"><span class="pre">name</span></code> value of <code class="docutils literal notranslate"><span class="pre">"[Untitled]"</span></code> if the instance is initialized without a name, or if an empty string is passed to the <code class="docutils literal notranslate"><span class="pre">init(name:)</span></code> initializer:</span><!--end_enstr-->
<span class="jpstr">
次の例は、<code class="docutils literal notranslate"><span class="pre">AutomaticallyNamedDocument</span></code>とよばれる<code class="docutils literal notranslate"><span class="pre">Document</span></code>のサブクラスを定義します。<code class="docutils literal notranslate"><span class="pre">AutomaticallyNamedDocument</span></code>サブクラスは、<code class="docutils literal notranslate"><span class="pre">Document</span></code>で導入される指定イニシャライザを両方ともオーバーライドします。これらのオーバーライドは、<code class="docutils literal notranslate"><span class="pre">AutomaticallyNamedDocument</span></code>インスタンスが、そのインスタンスが名前なしで初期化されるならば、または空の文字列が<code class="docutils literal notranslate"><span class="pre">init(name:)</span></code>イニシャライザに渡されるならば、初期<code class="docutils literal notranslate"><span class="pre">name</span></code>値の<code class="docutils literal notranslate"><span class="pre">"[Untitled]"</span></code>を持つことを確実にします：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">class</span> <span class="nv">AutomaticallyNamedDocument</span>: <span class="nc">Document</span> {
</li>
<li>    <span class="k">override</span> <span class="k">init</span>() {
</li>
<li>        <span class="k">super</span>.<span class="nv">init</span>()
</li>
<li>        <span class="k">self</span>.<span class="nv">name</span> = <span class="s">"[Untitled]"</span>
</li>
<li>    }
</li>
<li>    <span class="k">override</span> <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>) {
</li>
<li>        <span class="k">super</span>.<span class="nv">init</span>()
</li>
<li>        <span class="k">if</span> <span class="nv">name</span>.<span class="nv">isEmpty</span> {
</li>
<li>            <span class="k">self</span>.<span class="nv">name</span> = <span class="s">"[Untitled]"</span>
</li>
<li>        } <span class="k">else</span> {
</li>
<li>            <span class="k">self</span>.<span class="nv">name</span> = <span class="nv">name</span>
</li>
<li>        }
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">AutomaticallyNamedDocument</span></code> overrides its superclass’s failable <code class="docutils literal notranslate"><span class="pre">init?(name:)</span></code> initializer with a nonfailable <code class="docutils literal notranslate"><span class="pre">init(name:)</span></code> initializer. Because <code class="docutils literal notranslate"><span class="pre">AutomaticallyNamedDocument</span></code> copes with the empty string case in a different way than its superclass, its initializer doesn’t need to fail, and so it provides a nonfailable version of the initializer instead.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">AutomaticallyNamedDocument</span></code>は、それのスーパークラスの失敗できる<code class="docutils literal notranslate"><span class="pre">init?(name:)</span></code>イニシャライザを、失敗できない<code class="docutils literal notranslate"><span class="pre">init(name:)</span></code>イニシャライザでオーバーライドします。<code class="docutils literal notranslate"><span class="pre">AutomaticallyNamedDocument</span></code>が空の文字列の場合をそれのスーパークラスと異なるやり方でうまく処理するので、それのイニシャライザは失敗する必要はありません、それでそれはそうせずに、失敗できない改作のイニシャライザを提供します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can use forced unwrapping in an initializer to call a failable initializer from the superclass as part of the implementation of a subclass’s nonfailable initializer. For example, the <code class="docutils literal notranslate"><span class="pre">UntitledDocument</span></code> subclass below is always named <code class="docutils literal notranslate"><span class="pre">"[Untitled]"</span></code>, and it uses the failable <code class="docutils literal notranslate"><span class="pre">init(name:)</span></code> initializer from its superclass during initialization.</span><!--end_enstr-->
<span class="jpstr">
あなたは、強制アンラップをイニシャライザの中で使うことで、失敗できるイニシャライザをスーパークラスから呼び出し、サブクラスの失敗できないイニシャライザの実装の一部とすることができます。例えば、下の<code class="docutils literal notranslate"><span class="pre">UntitledDocument</span></code>サブクラスは、常に<code class="docutils literal notranslate"><span class="pre">"[Untitled]"</span></code>と名前をつけられます、そしてそれは失敗できる<code class="docutils literal notranslate"><span class="pre">init(name:)</span></code>イニシャライザをそれのスーパークラスから初期化の間に使います。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">class</span> <span class="nv">UntitledDocument</span>: <span class="nc">Document</span> {
</li>
<li>    <span class="k">override</span> <span class="k">init</span>() {
</li>
<li>        <span class="k">super</span>.<span class="nv">init</span>(<span class="nv">name</span>: <span class="s">"[Untitled]"</span>)!
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">In this case, if the <code class="docutils literal notranslate"><span class="pre">init(name:)</span></code> initializer of the superclass were ever called with an empty string as the name, the forced unwrapping operation would result in a runtime error. However, because it’s called with a string constant, you can see that the initializer won’t fail, so no runtime error can occur in this case.</span><!--end_enstr-->
<span class="jpstr">
この場合、スーパークラスの<code class="docutils literal notranslate"><span class="pre">init(name:)</span></code>イニシャライザがもしかその名前として空の文字列で呼び出されたならば、強制アンラップ操作は実行時エラーという結果になるでしょう。しかしながら、それは文字列定数で呼び出されるので、あなたはこのイニシャライザが失敗することはないと分かります、それで実行時エラーはこの場合には起こりえません。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID230">
<h3><span class="enstr">The init! Failable Initializer<a class="headerlink" href="#ID230" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
init!失敗できるイニシャライザ<a class="headerlink" href="#ID230" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">You typically define a failable initializer that creates an optional instance of the appropriate type by placing a question mark after the <code class="docutils literal notranslate"><span class="pre">init</span></code> keyword (<code class="docutils literal notranslate"><span class="pre">init?</span></code>). Alternatively, you can define a failable initializer that creates an implicitly unwrapped optional instance of the appropriate type. Do this by placing an exclamation point after the <code class="docutils literal notranslate"><span class="pre">init</span></code> keyword (<code class="docutils literal notranslate"><span class="pre">init!</span></code>) instead of a question mark.</span><!--end_enstr-->
<span class="jpstr">
あなたは一般的に、適切な型のオプショナルのインスタンスを作成する失敗できるイニシャライザを、疑問符を<code class="docutils literal notranslate"><span class="pre">init</span></code>キーワードの後において（<code class="docutils literal notranslate"><span class="pre">init?</span></code>）定義します。またはその代わりに、あなたは適切な型の暗黙的にアンラップされるオプショナルのインスタンスを作成する失敗できるイニシャライザを定義することができます。これを、疑問符ではなく、感嘆符を<code class="docutils literal notranslate"><span class="pre">init</span></code>キーワードの後に置くこと（<code class="docutils literal notranslate"><span class="pre">init!</span></code>）によって行ってください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can delegate from <code class="docutils literal notranslate"><span class="pre">init?</span></code> to <code class="docutils literal notranslate"><span class="pre">init!</span></code> and vice versa, and you can override <code class="docutils literal notranslate"><span class="pre">init?</span></code> with <code class="docutils literal notranslate"><span class="pre">init!</span></code> and vice versa. You can also delegate from <code class="docutils literal notranslate"><span class="pre">init</span></code> to <code class="docutils literal notranslate"><span class="pre">init!</span></code>, although doing so will trigger an assertion if the <code class="docutils literal notranslate"><span class="pre">init!</span></code> initializer causes initialization to fail.</span><!--end_enstr-->
<span class="jpstr">
あなたは、<code class="docutils literal notranslate"><span class="pre">init?</span></code>から<code class="docutils literal notranslate"><span class="pre">init!</span></code>への委任およびその逆が行えます、そしてあなたは<code class="docutils literal notranslate"><span class="pre">init?</span></code>を<code class="docutils literal notranslate"><span class="pre">init!</span></code>でオーバーライドすること、およびその逆もできます。あなたはまた、<code class="docutils literal notranslate"><span class="pre">init</span></code>から<code class="docutils literal notranslate"><span class="pre">init!</span></code>へ委任することができます、もっともそうすることは、<code class="docutils literal notranslate"><span class="pre">init!</span></code>イニシャライザが初期化失敗の原因となるならば、ある表明を引き起こすことになります。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID231">
<h2><span class="enstr">Required Initializers<a class="headerlink" href="#ID231" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
必須イニシャライザ<a class="headerlink" href="#ID231" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">Write the <code class="docutils literal notranslate"><span class="pre">required</span></code> modifier before the definition of a class initializer to indicate that every subclass of the class must implement that initializer:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">required</span></code>修飾子をクラス・イニシャライザの定義の前に書いて、そのクラスの全てのサブクラスがそのイニシャライザを実装しなければならないことを示してください：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">class</span> <span class="nv">SomeClass</span> {
</li>
<li>    <span class="k">required</span> <span class="k">init</span>() {
</li>
<li>        <span class="c"><span class="enstr">// initializer implementation goes here</span><!--end_enstr--><span class="jpstr">（イニシャライザ実装がここに来ます）</span><!--end_jpstr--></span>
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">You must also write the <code class="docutils literal notranslate"><span class="pre">required</span></code> modifier before every subclass implementation of a required initializer, to indicate that the initializer requirement applies to further subclasses in the chain. You don’t write the <code class="docutils literal notranslate"><span class="pre">override</span></code> modifier when overriding a required designated initializer:</span><!--end_enstr-->
<span class="jpstr">
あなたはまた、<code class="docutils literal notranslate"><span class="pre">required</span></code>修飾子を必須イニシャライザの全てのサブクラス実装の前に書かなければなりません、そうすることでそのイニシャライザ要件がさらにその連鎖のサブクラスに適用されることを指し示します。あなたは、必須指定イニシャライザをオーバーライドする時に<code class="docutils literal notranslate"><span class="pre">override</span></code>修飾子を書きません：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">class</span> <span class="nv">SomeSubclass</span>: <span class="nc">SomeClass</span> {
</li>
<li>    <span class="k">required</span> <span class="k">init</span>() {
</li>
<li>        <span class="c"><span class="enstr">// subclass implementation of the required initializer goes here</span><!--end_enstr--><span class="jpstr">（必須イニシャライザのサブクラス実装がここに来ます）</span><!--end_jpstr--></span>
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">You don’t have to provide an explicit implementation of a required initializer if you can satisfy the requirement with an inherited initializer.</span><!--end_enstr-->
<span class="jpstr">
あなたは、あなたがある継承されたイニシャライザの要件を満たすことができるならば、必須イニシャライザの明示的な実装を提供する必要はありません。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID232">
<h2><span class="enstr">Setting a Default Property Value with a Closure or Function<a class="headerlink" href="#ID232" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
省略時のプロパティ値をクロージャまたは関数を使って設定する<a class="headerlink" href="#ID232" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">If a stored property’s default value requires some customization or setup, you can use a closure or global function to provide a customized default value for that property. Whenever a new instance of the type that the property belongs to is initialized, the closure or function is called, and its return value is assigned as the property’s default value.</span><!--end_enstr-->
<span class="jpstr">
ある格納プロパティの省略時の値が、いくらかの特別な注文または準備を必要とするならば、あなたは特注の省略時の値をそのプロパティのために用意するために、クロージャまたはグローバル関数を使用することができます。そのプロパティが属している型の新しいインスタンスが初期化されるときはいつでも、そのクロージャまたは関数が呼ばれます、そしてその戻り値はプロパティの省略時の値として代入されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">These kinds of closures or functions typically create a temporary value of the same type as the property, tailor that value to represent the desired initial state, and then return that temporary value to be used as the property’s default value.</span><!--end_enstr-->
<span class="jpstr">
これらの種類のクロージャまたは関数は、概してプロパティと同じ型の一時的な値をつくって、望み通りの初期状態を表すようにその値を仕立てて、それからその一時的な値がプロパティの省略時の値として使われるように返します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Here’s a skeleton outline of how a closure can be used to provide a default property value:</span><!--end_enstr-->
<span class="jpstr">
ここに、あるクロージャが省略時のプロパティ値を提供するために使われることができる方法の骨組み概要があります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">class</span> <span class="nv">SomeClass</span> {
</li>
<li>    <span class="k">let</span> <span class="nv">someProperty</span>: <span class="nc">SomeType</span> = {
</li>
<li>        <span class="c"><span class="enstr">// create a default value for someProperty inside this closure</span><!--end_enstr--><span class="jpstr">（このクロージャの内側でsomePropertyのための省略時の値をつくる）</span><!--end_jpstr--></span>
</li>
<li>        <span class="c"><span class="enstr">// someValue must be of the same type as SomeType</span><!--end_enstr--><span class="jpstr">（someValueは、SomeTypeと同じ型でなければなりません）</span><!--end_jpstr--></span>
</li>
<li>        <span class="k">return</span> <span class="nv">someValue</span>
</li>
<li>    }()
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">Note that the closure’s end curly brace is followed by an empty pair of parentheses. This tells Swift to execute the closure immediately. If you omit these parentheses, you are trying to assign the closure itself to the property, and not the return value of the closure.</span><!--end_enstr-->
<span class="jpstr">
クロージャの閉じ波括弧に、一対の空の丸括弧が続くことに注意してください。これは、スウィフトにこのクロージャを直ちに実行するように言います。あなたがこの丸括弧を省略するならば、あなたはプロパティにクロージャそれ自体を代入することを試みています、つまりそのクロージャの戻り値でなく。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">If you use a closure to initialize a property, remember that the rest of the instance hasn’t yet been initialized at the point that the closure is executed. This means that you can’t access any other property values from within your closure, even if those properties have default values. You also can’t use the implicit <code class="docutils literal notranslate"><span class="pre">self</span></code> property, or call any of the instance’s methods.</span><!--end_enstr-->
<span class="jpstr">
あなたがプロパティを初期化するためにクロージャを使うならば、そのクロージャが実行される時点で、残りのインスタンスはまだ初期化されていないのを思い出してください。これは、たとえそれらのプロパティには省略時の値があるとしても、あなたがあなたのクロージャ内から他のどのプロパティ値にもアクセスすることができないことを意味します。あなたはまた、暗黙の<code class="docutils literal notranslate"><span class="pre">self</span></code>プロパティを使うことや、そのインスタンスのメソッドの何も呼ぶことができません。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">The example below defines a structure called <code class="docutils literal notranslate"><span class="pre">Chessboard</span></code>, which models a board for the game of chess. Chess is played on an 8 x 8 board, with alternating black and white squares.</span><!--end_enstr-->
<span class="jpstr">
下の例は<code class="docutils literal notranslate"><span class="pre">Chessboard</span></code>と呼ばれる構造体を定義します、それは、「チェス」ゲーム用の盤をモデル化します。チェスは、黒と白の正方形を互い違いに持つ、８×８マスの盤上で行われます。
</span><!--end_jpstr-->
</p>
<img alt="../_images/chessBoard_2x.png" class="align-center" src="../images/chessBoard_2x.png" style="width: 345px;">
<p><span class="enstr">To represent this game board, the <code class="docutils literal notranslate"><span class="pre">Chessboard</span></code> structure has a single property called <code class="docutils literal notranslate"><span class="pre">boardColors</span></code>, which is an array of 64 <code class="docutils literal notranslate"><span class="pre">Bool</span></code> values. A value of <code class="docutils literal notranslate"><span class="pre">true</span></code> in the array represents a black square and a value of <code class="docutils literal notranslate"><span class="pre">false</span></code> represents a white square. The first item in the array represents the top left square on the board and the last item in the array represents the bottom right square on the board.</span><!--end_enstr-->
<span class="jpstr">
このゲーム板を表すために、<code class="docutils literal notranslate"><span class="pre">Chessboard</span></code>構造体は<code class="docutils literal notranslate"><span class="pre">boardColors</span></code>と呼ばれる１つのプロパティだけを持ちます、それは64個の<code class="docutils literal notranslate"><span class="pre">Bool</span></code>値の配列です。この配列の中の<code class="docutils literal notranslate"><span class="pre">true</span></code>の値は黒の正方形を表します、そして<code class="docutils literal notranslate"><span class="pre">false</span></code>の値は白い正方形を表します。配列の最初の項目は盤上の一番左上の正方形を表わします、そして配列の最後の項目は盤上の一番右下の正方形を表します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">boardColors</span></code> array is initialized with a closure to set up its color values:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">boardColors</span></code>配列は、その色値を設定するために、クロージャで初期化されます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">struct</span> <span class="nv">Chessboard</span> {
</li>
<li>    <span class="k">let</span> <span class="nv">boardColors</span>: [<span class="nc">Bool</span>] = {
</li>
<li>        <span class="k">var</span> <span class="nv">temporaryBoard</span>: [<span class="nc">Bool</span>] = []
</li>
<li>        <span class="k">var</span> <span class="nv">isBlack</span> = <span class="k">false</span>
</li>
<li>        <span class="k">for</span> <span class="nv">i</span> <span class="k">in</span> <span class="m">1</span>...<span class="m">8</span> {
</li>
<li>            <span class="k">for</span> <span class="nv">j</span> <span class="k">in</span> <span class="m">1</span>...<span class="m">8</span> {
</li>
<li>                <span class="nv">temporaryBoard</span>.<span class="nv">append</span>(<span class="nv">isBlack</span>)
</li>
<li>                <span class="nv">isBlack</span> = !<span class="nv">isBlack</span>
</li>
<li>            }
</li>
<li>            <span class="nv">isBlack</span> = !<span class="nv">isBlack</span>
</li>
<li>        }
</li>
<li>        <span class="k">return</span> <span class="nv">temporaryBoard</span>
</li>
<li>    }()
</li>
<li>    <span class="k">func</span> <span class="nv">squareIsBlackAt</span>(<span class="nv">row</span>: <span class="nc">Int</span>, <span class="nv">column</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Bool</span> {
</li>
<li>        <span class="k">return</span> <span class="nv">boardColors</span>[(<span class="nv">row</span> * <span class="m">8</span>) + <span class="nv">column</span>]
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">Whenever a new <code class="docutils literal notranslate"><span class="pre">Chessboard</span></code> instance is created, the closure is executed, and the default value of <code class="docutils literal notranslate"><span class="pre">boardColors</span></code> is calculated and returned. The closure in the example above calculates and sets the appropriate color for each square on the board in a temporary array called <code class="docutils literal notranslate"><span class="pre">temporaryBoard</span></code>, and returns this temporary array as the closure’s return value once its setup is complete. The returned array value is stored in <code class="docutils literal notranslate"><span class="pre">boardColors</span></code> and can be queried with the <code class="docutils literal notranslate"><span class="pre">squareIsBlackAt(row:column:)</span></code> utility function:</span><!--end_enstr-->
<span class="jpstr">
新しい<code class="docutils literal notranslate"><span class="pre">Chessboard</span></code>インスタンスがつくられるときはいつでも、このクロージャは実行されます、そして<code class="docutils literal notranslate"><span class="pre">boardColors</span></code>の省略時の値が計算されて、返されます。上の例でのクロージャは<code class="docutils literal notranslate"><span class="pre">temporaryBoard</span></code>と呼ばれる一時的な配列の中の板上の各正方形に対して適切な色を計算して設定します、そしてひとたびその準備が完了されるならば、この一時的な配列をクロージャの戻り値として返します。返された配列値は、<code class="docutils literal notranslate"><span class="pre">boardColors</span></code>に格納されて、便利な支援関数の<code class="docutils literal notranslate"><span class="pre">squareIsBlackAt(row:column:)</span></code>で問い合わされることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li><span class="k">let</span> <span class="nv">board</span> = <span class="nv">Chessboard</span>()
</li>
<li><span class="nv">print</span>(<span class="nv">board</span>.<span class="nv">squareIsBlackAt</span>(<span class="nv">row</span>: <span class="m">0</span>, <span class="nv">column</span>: <span class="m">1</span>))
</li>
<li><span class="c"><span class="enstr">// Prints "true"</span><!--end_enstr--><span class="jpstr">（「true」を出力します）</span><!--end_jpstr--></span>
</li>
<li><span class="nv">print</span>(<span class="nv">board</span>.<span class="nv">squareIsBlackAt</span>(<span class="nv">row</span>: <span class="m">7</span>, <span class="nv">column</span>: <span class="m">7</span>))
</li>
<li><span class="c"><span class="enstr">// Prints "false"</span><!--end_enstr--><span class="jpstr">（「false」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
</div>
</div>


    </article>
    <div class="next_previous">
        <p class="previous"><a href="Inheritance.html"><span class="enstr">Inheritance</span><!--end_enstr-->
<span class="jpstr">
継承
</span><!--end_jpstr-->
</a></p>
        <p class="next"><a href="Deinitialization.html"><span class="enstr">Deinitialization</span><!--end_enstr-->
<span class="jpstr">
デイニシャライズ
</span><!--end_jpstr-->
</a></p>
    </div>
</main>


<footer role="contentinfo">
  <aside>
    <a href="//swift.org/atom.xml" title="Subscribe to Site Updates"><i class="feed">Subscribe</i></a>
    <a href="https://twitter.com/swiftlang" rel="nofollow" title="Follow @SwiftLang on Twitter"><i class="twitter">Twitter</i></a>
  </aside>

  <p class="copyright">Copyright © 2022 Apple Inc. All rights reserved.</p>
  <p class="trademark">Swift and the Swift logo are trademarks of Apple Inc.</p>
  <p class="privacy">
    <a href="//www.apple.com/privacy/privacy-policy/">Privacy Policy</a>
    <a href="//www.apple.com/legal/privacy/en-ww/cookies/">Cookies</a>
  </p>
</footer>
<div id="jump_to_overlay"></div>
<script src="../static/javascripts/application.js"></script>
  
</body>
</html>
