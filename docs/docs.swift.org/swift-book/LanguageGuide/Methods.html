

<!DOCTYPE html>



<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8" />
    <meta name="author" content="Apple Inc." />
    <meta name="viewport" content="width=device-width initial-scale=1" />
    
    <title>Methods — The Swift Programming Language (Swift 5.1)</title>
    
    <link rel="license" href="/LICENSE.txt" />
    <link rel="stylesheet" media="all" href="../_static/stylesheets/application.css" />
    <link rel="stylesheet" media="all" href="../_static/stylesheets/tspl.css" />
    <link rel="shortcut icon" sizes="16x16 24x24 32x32 48x48 64x64" type="image/vnd.microsoft.icon" href="/favicon.ico" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png" />
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png" />
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png" />
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png" />
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png" />
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png" />
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png" />
    <link rel="mask-icon" href="/assets/images/icon-swift.svg" color="#F05339" /> 
  </head>
  <body>


<nav role="navigation">
    <header role="banner">
      <h1 id="logo">
        <a href="https://swift.org/" title="Swift.org" role="img" aria-label="Swift.org">
          Swift.org
        </a>
      </h1>
    </header>

    <div id="menu-toggle" class="menu-toggle open"></div>

    <h2>The Swift Programming Language<div>Swift 5.1</div></h2>

    <ul>
    <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html"><span class="enstr">Welcome to Swift</span><!--end_enstr-->
<span class="jpstr">
スウィフトにようこそ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="TheBasics.html"><span class="enstr">Language Guide</span><!--end_enstr-->
<span class="jpstr">
言語ガイド
</span><!--end_jpstr-->
</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="TheBasics.html"><span class="enstr">The Basics</span><!--end_enstr-->
<span class="jpstr">
基本
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="BasicOperators.html"><span class="enstr">Basic Operators</span><!--end_enstr-->
<span class="jpstr">
基本の演算子
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="StringsAndCharacters.html"><span class="enstr">Strings and Characters</span><!--end_enstr-->
<span class="jpstr">
文字列と文字
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="CollectionTypes.html"><span class="enstr">Collection Types</span><!--end_enstr-->
<span class="jpstr">
コレクション型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ControlFlow.html"><span class="enstr">Control Flow</span><!--end_enstr-->
<span class="jpstr">
制御の流れ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Functions.html"><span class="enstr">Functions</span><!--end_enstr-->
<span class="jpstr">
関数
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Closures.html"><span class="enstr">Closures</span><!--end_enstr-->
<span class="jpstr">
クロージャ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Enumerations.html"><span class="enstr">Enumerations</span><!--end_enstr-->
<span class="jpstr">
列挙
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ClassesAndStructures.html"><span class="enstr">Structures and Classes</span><!--end_enstr-->
<span class="jpstr">
構造体とクラス
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Properties.html"><span class="enstr">Properties</span><!--end_enstr-->
<span class="jpstr">
プロパティ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#"><span class="enstr">Methods</span><!--end_enstr-->
<span class="jpstr">
メソッド
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Subscripts.html"><span class="enstr">Subscripts</span><!--end_enstr-->
<span class="jpstr">
添え字
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Inheritance.html"><span class="enstr">Inheritance</span><!--end_enstr-->
<span class="jpstr">
継承
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Initialization.html"><span class="enstr">Initialization</span><!--end_enstr-->
<span class="jpstr">
初期化
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Deinitialization.html"><span class="enstr">Deinitialization</span><!--end_enstr-->
<span class="jpstr">
デイニシャライズ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="OptionalChaining.html"><span class="enstr">Optional Chaining</span><!--end_enstr-->
<span class="jpstr">
オプショナル連鎖
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ErrorHandling.html"><span class="enstr">Error Handling</span><!--end_enstr-->
<span class="jpstr">
エラーの処理
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="TypeCasting.html"><span class="enstr">Type Casting</span><!--end_enstr-->
<span class="jpstr">
型キャスト
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="NestedTypes.html"><span class="enstr">Nested Types</span><!--end_enstr-->
<span class="jpstr">
入れ子にされた型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Extensions.html"><span class="enstr">Extensions</span><!--end_enstr-->
<span class="jpstr">
拡張
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Protocols.html"><span class="enstr">Protocols</span><!--end_enstr-->
<span class="jpstr">
プロトコル
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Generics.html"><span class="enstr">Generics</span><!--end_enstr-->
<span class="jpstr">
総称体
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="OpaqueTypes.html"><span class="enstr">Opaque Types</span><!--end_enstr-->
<span class="jpstr">
不透明型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AutomaticReferenceCounting.html"><span class="enstr">Automatic Reference Counting</span><!--end_enstr-->
<span class="jpstr">
自動参照カウント
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="MemorySafety.html"><span class="enstr">Memory Safety</span><!--end_enstr-->
<span class="jpstr">
メモリ安全
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AccessControl.html"><span class="enstr">Access Control</span><!--end_enstr-->
<span class="jpstr">
アクセス制御
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AdvancedOperators.html"><span class="enstr">Advanced Operators</span><!--end_enstr-->
<span class="jpstr">
先進の演算子
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ReferenceManual/AboutTheLanguageReference.html"><span class="enstr">Language Reference</span><!--end_enstr-->
<span class="jpstr">
言語リファレンス
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1"><a class="reference internal" href="../RevisionHistory/RevisionHistory.html"><span class="enstr">Revision History</span><!--end_enstr-->
<span class="jpstr">
改訂履歴
</span><!--end_jpstr-->
</a></li>
</ul>

    <li class="toctree-l1 return"><a class="reference internal" href="../../../index.html">← Go to Index</a></li>
    </ul>
</nav>




<main role="main">
    <article class="page">
        <menu id="bashful" type="toolbar">
          <div class="inner">
            <menuitem id="jump_to" class="menu-bar-item closed">
            <span id="jump_to_toggle">On This Page</span>
            <div class="chevron">
                <div class="chevy chevron-left"></div>
                <div class="chevy chevron-right"></div>
            </div>
            <menu type="list" class="details">
                <ul>
<li><a class="reference internal" href="#"><span class="enstr">Methods</span><!--end_enstr-->
<span class="jpstr">
メソッド
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID235"><span class="enstr">Instance Methods</span><!--end_enstr-->
<span class="jpstr">
インスタンスメソッド
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID238"><span class="enstr">The self Property</span><!--end_enstr-->
<span class="jpstr">
selfプロパティ
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID239"><span class="enstr">Modifying Value Types from Within Instance Methods</span><!--end_enstr-->
<span class="jpstr">
値型をインスタンスメソッド内から修正する
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID240"><span class="enstr">Assigning to self Within a Mutating Method</span><!--end_enstr-->
<span class="jpstr">
変更メソッド内部でselfに代入する
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID241"><span class="enstr">Type Methods</span><!--end_enstr-->
<span class="jpstr">
型メソッド
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
</ul>

            </menu>
            </menuitem>
          </div>
        </menu>

        
  <div class="section" id="methods">
<h1><span class="enstr">Methods<a class="headerlink" href="#methods" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
メソッド<a class="headerlink" href="#methods" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h1>
<p><span class="enstr"><em>Methods</em> are functions that are associated with a particular type. Classes, structures, and enumerations can all define instance methods, which encapsulate specific tasks and functionality for working with an instance of a given type. Classes, structures, and enumerations can also define type methods, which are associated with the type itself. Type methods are similar to class methods in Objective-C.</span><!--end_enstr-->
<span class="jpstr">
<em>メソッド</em>は、特定の型と結び付けられる関数です。それぞれのクラス、構造体、および列挙は、すべてインスタンスメソッドを定義することができます、それは、ある定められた型のあるインスタンスで働くために特定の作業や機能性をカプセル化します。クラス、構造体、および列挙は、また、型メソッドを定義することができます、それは型それ自身に結び付けられます。型メソッドは、Objective-Cにおけるクラスメソッドに似ています。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The fact that structures and enumerations can define methods in Swift is a major difference from C and Objective-C. In Objective-C, classes are the only types that can define methods. In Swift, you can choose whether to define a class, structure, or enumeration, and still have the flexibility to define methods on the type you create.</span><!--end_enstr-->
<span class="jpstr">
構造体と列挙がスウィフトにおいてはメソッドを定義することができるという事実は、CやObjective-Cとの重大な違いです。Objective-Cでは、クラスはメソッドを定義することができる唯一の型です。スウィフトでは、あなたは、クラス、構造体、または列挙を定義すべきかを選択することができます、そしてまだあなたがつくる型でメソッドを定義する柔軟性を持ちます。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID235">
<h2><span class="enstr">Instance Methods<a class="headerlink" href="#ID235" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
インスタンスメソッド<a class="headerlink" href="#ID235" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr"><em>Instance methods</em> are functions that belong to instances of a particular class, structure, or enumeration. They support the functionality of those instances, either by providing ways to access and modify instance properties, or by providing functionality related to the instance’s purpose. Instance methods have exactly the same syntax as functions, as described in <a class="reference internal" href="Functions.html"><span class="doc">Functions</span></a>.</span><!--end_enstr-->
<span class="jpstr">
<em>インスタンスメソッド</em>は、特定のクラス、構造体、または列挙のインスタンスに属している機能です。それは、そういったもののインスタンスの機能性を、インスタンスプロパティにアクセスしたり修正したりする方法を提供することで、またはインスタンスの目的と関連がある機能性を提供することでのどちらかで支えます。インスタンスメソッドは、関数と正確に同じ構文を持ちます、<a class="reference internal" href="Functions.html"><span class="doc">関数</span></a>で記述されるように。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You write an instance method within the opening and closing braces of the type it belongs to. An instance method has implicit access to all other instance methods and properties of that type. An instance method can be called only on a specific instance of the type it belongs to. It cannot be called in isolation without an existing instance.</span><!--end_enstr-->
<span class="jpstr">
あなたは、インスタンスメソッドを、それが属している型の開始と終わりの波括弧の内部に書きます。あるインスタンスメソッドは、無条件にその型の他のインスタンスメソッドとプロパティの全てへのアクセスを持ちます。インスタンスメソッドは、それが属している型のある特定のインスタンスでだけ呼ばれることができます。それは、単独で既存のインスタンスなしで呼ばれることができません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Here’s an example that defines a simple <code class="docutils literal notranslate"><span class="pre">Counter</span></code> class, which can be used to count the number of times an action occurs:</span><!--end_enstr-->
<span class="jpstr">
単純な<code class="docutils literal notranslate"><span class="pre">Counter</span></code>クラスを定義する例がここにあります、それは、ある動作が起こる回数を数えるために使われることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Counter</span> {
</li><li>    <span class="k">var</span> <span class="nv">count</span> = <span class="m">0</span>
</li><li>    <span class="k">func</span> <span class="nv">increment</span>() {
</li><li>        <span class="nv">count</span> += <span class="m">1</span>
</li><li>    }
</li><li>    <span class="k">func</span> <span class="nv">increment</span>(<span class="nv">by</span> <span class="nv">amount</span>: <span class="nc">Int</span>) {
</li><li>        <span class="nv">count</span> += <span class="nv">amount</span>
</li><li>    }
</li><li>    <span class="k">func</span> <span class="nv">reset</span>() {
</li><li>        <span class="nv">count</span> = <span class="m">0</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">Counter</span></code> class defines three instance methods:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Counter</span></code>クラスは、３つのインスタンスメソッドを定義します：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li><span class="enstr"><code class="docutils literal notranslate"><span class="pre">increment()</span></code> increments the counter by <code class="docutils literal notranslate"><span class="pre">1</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">increment()</span></code>は、<code class="docutils literal notranslate"><span class="pre">1</span></code>だけカウンターを増加させます。
</span><!--end_jpstr-->
</li>
<li><span class="enstr"><code class="docutils literal notranslate"><span class="pre">increment(by:</span> <span class="pre">Int)</span></code> increments the counter by a specified integer amount.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">increment(by:</span> <span class="pre">Int)</span></code>は、指定された量の整数でカウンターを増加させます。
</span><!--end_jpstr-->
</li>
<li><span class="enstr"><code class="docutils literal notranslate"><span class="pre">reset()</span></code> resets the counter to zero.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">reset()</span></code>は、カウンターをゼロに再設定します。
</span><!--end_jpstr-->
</li>
</ul>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">Counter</span></code> class also declares a variable property, <code class="docutils literal notranslate"><span class="pre">count</span></code>, to keep track of the current counter value.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Counter</span></code>クラスはまた、変数プロパティ、<code class="docutils literal notranslate"><span class="pre">count</span></code>を宣言して、現在のカウンターの値の情報を得続けます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You call instance methods with the same dot syntax as properties:</span><!--end_enstr-->
<span class="jpstr">
あなたは、インスタンスメソッドをプロパティと同じドット構文を使って呼び出します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">counter</span> = <span class="nv">Counter</span>()
</li><li><span class="c"><span class="enstr">// the initial counter value is 0</span><!--end_enstr--><span class="jpstr">（counterの最初の値は、0です）</span><!--end_jpstr--></span>
</li><li><span class="nv">counter</span>.<span class="nv">increment</span>()
</li><li><span class="c"><span class="enstr">// the counter's value is now 1</span><!--end_enstr--><span class="jpstr">（counterの値は、いま１です）</span><!--end_jpstr--></span>
</li><li><span class="nv">counter</span>.<span class="nv">increment</span>(<span class="nv">by</span>: <span class="m">5</span>)
</li><li><span class="c"><span class="enstr">// the counter's value is now 6</span><!--end_enstr--><span class="jpstr">（counterの値は、いま６です）</span><!--end_jpstr--></span>
</li><li><span class="nv">counter</span>.<span class="nv">reset</span>()
</li><li><span class="c"><span class="enstr">// the counter's value is now 0</span><!--end_enstr--><span class="jpstr">（counterの値は、いま0です）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">Function parameters can have both a name (for use within the function’s body) and an argument label (for use when calling the function), as described in <a class="reference internal" href="Functions.html#ID166"><span class="std std-ref">Function Argument Labels and Parameter Names</span></a>. The same is true for method parameters, because methods are just functions that are associated with a type.</span><!--end_enstr-->
<span class="jpstr">
関数パラメータは、名前（関数の本文内で使うため）と引数ラベル（関数を呼び出すとき使うため）の両方を持つことができます、<a class="reference internal" href="Functions.html#ID166"><span class="std std-ref">関数の引数ラベルとパラメータ名</span></a>で記述されるように。同じことはメソッドパラメータにもあてはまります、なぜならメソッドは、あるひとつの型に結び付けられた単なる関数だからです。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID238">
<h3><span class="enstr">The self Property<a class="headerlink" href="#ID238" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
selfプロパティ<a class="headerlink" href="#ID238" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p><span class="enstr">Every instance of a type has an implicit property called <code class="docutils literal notranslate"><span class="pre">self</span></code>, which is exactly equivalent to the instance itself. You use the <code class="docutils literal notranslate"><span class="pre">self</span></code> property to refer to the current instance within its own instance methods.</span><!--end_enstr-->
<span class="jpstr">
ある型のすべてのインスタンスは、暗黙的に<code class="docutils literal notranslate"><span class="pre">self</span></code>と呼ばれるプロパティを持ちます、それは、正確にそのインスタンスそれ自身に等しいです。あなたは、<code class="docutils literal notranslate"><span class="pre">self</span></code>プロパティを現在のインスタンスに言及するためにそれ自身のインスタンスメソッド内で使います。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">increment()</span></code> method in the example above could have been written like this:</span><!--end_enstr-->
<span class="jpstr">
上の例における<code class="docutils literal notranslate"><span class="pre">increment()</span></code>メソッドは、このように記述されることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">increment</span>() {
</li><li>    <span class="k">self</span>.<span class="nv">count</span> += <span class="m">1</span>
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">In practice, you don’t need to write <code class="docutils literal notranslate"><span class="pre">self</span></code> in your code very often. If you don’t explicitly write <code class="docutils literal notranslate"><span class="pre">self</span></code>, Swift assumes that you are referring to a property or method of the current instance whenever you use a known property or method name within a method. This assumption is demonstrated by the use of <code class="docutils literal notranslate"><span class="pre">count</span></code> (rather than <code class="docutils literal notranslate"><span class="pre">self.count</span></code>) inside the three instance methods for <code class="docutils literal notranslate"><span class="pre">Counter</span></code>.</span><!--end_enstr-->
<span class="jpstr">
実際問題として、あなたは頻繁にあなたのコードに<code class="docutils literal notranslate"><span class="pre">self</span></code>を書く必要がありません。あなたが明示的に<code class="docutils literal notranslate"><span class="pre">self</span></code>を書かないならば、スウィフトは、あなたがメソッド内で既知のプロパティまたはメソッド名を使用するときはいつでも、あなたが現在のインスタンスに属するプロパティまたはメソッドに言及していると仮定します。この仮定は、<code class="docutils literal notranslate"><span class="pre">Counter</span></code>のための３つのインスタンスメソッド内部での（<code class="docutils literal notranslate"><span class="pre">self.count</span></code>ではなく）<code class="docutils literal notranslate"><span class="pre">count</span></code>の使用によって示されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The main exception to this rule occurs when a parameter name for an instance method has the same name as a property of that instance. In this situation, the parameter name takes precedence, and it becomes necessary to refer to the property in a more qualified way. You use the <code class="docutils literal notranslate"><span class="pre">self</span></code> property to distinguish between the parameter name and the property name.</span><!--end_enstr-->
<span class="jpstr">
この規則に対する主な例外は、インスタンスメソッドのパラメータ名がそのインスタンスのプロパティと同じ名前を持つ時に起こります。この状況には、パラメータ名が優先されます、そして、より対象を限定するやり方でプロパティに言及することが必要になります。あなたは、<code class="docutils literal notranslate"><span class="pre">self</span></code>プロパティをパラメータ名とプロパティ名を区別するために使います。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Here, <code class="docutils literal notranslate"><span class="pre">self</span></code> disambiguates between a method parameter called <code class="docutils literal notranslate"><span class="pre">x</span></code> and an instance property that is also called <code class="docutils literal notranslate"><span class="pre">x</span></code>:</span><!--end_enstr-->
<span class="jpstr">
ここでは、<code class="docutils literal notranslate"><span class="pre">self</span></code>は、<code class="docutils literal notranslate"><span class="pre">x</span></code>と呼ばれるメソッドパラメータと同様にまた<code class="docutils literal notranslate"><span class="pre">x</span></code>と呼ばれるインスタンスプロパティの間の曖昧さをなくします：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Point</span> {
</li><li>    <span class="k">var</span> <span class="nv">x</span> = <span class="m">0.0</span>, <span class="nv">y</span> = <span class="m">0.0</span>
</li><li>    <span class="k">func</span> <span class="nv">isToTheRightOf</span>(<span class="nv">x</span>: <span class="nc">Double</span>) -&gt; <span class="nc">Bool</span> {
</li><li>        <span class="k">return</span> <span class="k">self</span>.<span class="nv">x</span> &gt; <span class="nv">x</span>
</li><li>    }
</li><li>}
</li><li><span class="k">let</span> <span class="nv">somePoint</span> = <span class="nv">Point</span>(<span class="nv">x</span>: <span class="m">4.0</span>, <span class="nv">y</span>: <span class="m">5.0</span>)
</li><li><span class="k">if</span> <span class="nv">somePoint</span>.<span class="nv">isToTheRightOf</span>(<span class="nv">x</span>: <span class="m">1.0</span>) {
</li><li>    <span class="nv">print</span>(<span class="s">"This point is to the right of the line where x == 1.0"</span>)
</li><li>}
</li><li><span class="c"><span class="enstr">// Prints "This point is to the right of the line where x == 1.0"</span><!--end_enstr--><span class="jpstr">（「この点は線x == 1.0の右にある」を出力します）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">Without the <code class="docutils literal notranslate"><span class="pre">self</span></code> prefix, Swift would assume that both uses of <code class="docutils literal notranslate"><span class="pre">x</span></code> referred to the method parameter called <code class="docutils literal notranslate"><span class="pre">x</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">self</span></code>接頭辞なしでは、スウィフトは両方の<code class="docutils literal notranslate"><span class="pre">x</span></code>の使用が<code class="docutils literal notranslate"><span class="pre">x</span></code>と呼ばれるメソッドパラメータに言及したものと仮定します。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID239">
<h3><span class="enstr">Modifying Value Types from Within Instance Methods<a class="headerlink" href="#ID239" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
値型をインスタンスメソッド内から修正する<a class="headerlink" href="#ID239" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p><span class="enstr">Structures and enumerations are <em>value types</em>. By default, the properties of a value type cannot be modified from within its instance methods.</span><!--end_enstr-->
<span class="jpstr">
構造体と列挙は、<em>値型</em>です。初期状態では、ある値型に属するプロパティは、それのインスタンスメソッド内から修正されることができません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">However, if you need to modify the properties of your structure or enumeration within a particular method, you can opt in to <em>mutating</em> behavior for that method. The method can then mutate (that is, change) its properties from within the method, and any changes that it makes are written back to the original structure when the method ends. The method can also assign a completely new instance to its implicit <code class="docutils literal notranslate"><span class="pre">self</span></code> property, and this new instance will replace the existing one when the method ends.</span><!--end_enstr-->
<span class="jpstr">
しかし、あなたがある特定のメソッド内であなたの構造体または列挙のプロパティを修正する必要があるならば、あなたはそのメソッドのために<em>可変</em>挙動を選ぶことができます。このメソッドはそれからそれのプロパティをメソッド内部から変化させること（すなわち変更）ができます、そして、そのメソッドが終了するとき、それが行ったどんな変更も本来の構造体へ書き込まれます。このメソッドはまた、完全に新しいインスタンスをその暗黙の<code class="docutils literal notranslate"><span class="pre">self</span></code>プロパティに代入することができます、そして、そのメソッドが終了するとき、この新しいインスタンスは既存のものを置き換えます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can opt in to this behavior by placing the <code class="docutils literal notranslate"><span class="pre">mutating</span></code> keyword before the <code class="docutils literal notranslate"><span class="pre">func</span></code> keyword for that method:</span><!--end_enstr-->
<span class="jpstr">
あなたは、そのメソッドのための<code class="docutils literal notranslate"><span class="pre">func</span></code>キーワードの前に<code class="docutils literal notranslate"><span class="pre">mutating</span></code>キーワードを置くことによってこの挙動を取り入れることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Point</span> {
</li><li>    <span class="k">var</span> <span class="nv">x</span> = <span class="m">0.0</span>, <span class="nv">y</span> = <span class="m">0.0</span>
</li><li>    <span class="k">mutating</span> <span class="k">func</span> <span class="nv">moveBy</span>(<span class="nv">x</span> <span class="nv">deltaX</span>: <span class="nc">Double</span>, <span class="nv">y</span> <span class="nv">deltaY</span>: <span class="nc">Double</span>) {
</li><li>        <span class="nv">x</span> += <span class="nv">deltaX</span>
</li><li>        <span class="nv">y</span> += <span class="nv">deltaY</span>
</li><li>    }
</li><li>}
</li><li><span class="k">var</span> <span class="nv">somePoint</span> = <span class="nv">Point</span>(<span class="nv">x</span>: <span class="m">1.0</span>, <span class="nv">y</span>: <span class="m">1.0</span>)
</li><li><span class="nv">somePoint</span>.<span class="nv">moveBy</span>(<span class="nv">x</span>: <span class="m">2.0</span>, <span class="nv">y</span>: <span class="m">3.0</span>)
</li><li><span class="nv">print</span>(<span class="s">"The point is now at (</span>\<span class="p">(</span><span class="nv">somePoint</span>.<span class="nv">x</span><span class="p">)</span><span class="s">, </span>\<span class="p">(</span><span class="nv">somePoint</span>.<span class="nv">y</span><span class="p">)</span><span class="s">)"</span>)
</li><li><span class="c"><span class="enstr">// Prints "The point is now at (3.0, 4.0)"</span><!--end_enstr--><span class="jpstr">（「ポイントは現在は(3.0, 4.0)です」を出力します）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">Point</span></code> structure above defines a mutating <code class="docutils literal notranslate"><span class="pre">moveBy(x:y:)</span></code> method, which moves a <code class="docutils literal notranslate"><span class="pre">Point</span></code> instance by a certain amount. Instead of returning a new point, this method actually modifies the point on which it is called. The <code class="docutils literal notranslate"><span class="pre">mutating</span></code> keyword is added to its definition to enable it to modify its properties.</span><!--end_enstr-->
<span class="jpstr">
上の<code class="docutils literal notranslate"><span class="pre">Point構</span></code>造体は変更<code class="docutils literal notranslate"><span class="pre">moveBy(x:y:)</span></code>メソッドを定義します、それは、<code class="docutils literal notranslate"><span class="pre">Point</span></code>インスタンスを特定の量だけ動かします。新しい点を返す代わりに、このメソッドは、それが呼び出された点を実際に修正します。<code class="docutils literal notranslate"><span class="pre">mutating</span></code>キーワードがその定義に加えられ、それにそのプロパティを修正するのを可能にします。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Note that you cannot call a mutating method on a constant of structure type, because its properties cannot be changed, even if they are variable properties, as described in <a class="reference internal" href="Properties.html#ID256"><span class="std std-ref">Stored Properties of Constant Structure Instances</span></a>:</span><!--end_enstr-->
<span class="jpstr">
あなたが定数の構造体型で変更メソッドを呼ぶことができないということに注意してください、なぜなら、<a class="reference internal" href="Properties.html#ID256"><span class="std std-ref">定数構造体インスタンスの格納プロパティ</span></a>で記述されるように、そのプロパティは、たとえそれらが変数プロパティであるとしても変わることができないからです。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">fixedPoint</span> = <span class="nv">Point</span>(<span class="nv">x</span>: <span class="m">3.0</span>, <span class="nv">y</span>: <span class="m">3.0</span>)
</li><li><span class="nv">fixedPoint</span>.<span class="nv">moveBy</span>(<span class="nv">x</span>: <span class="m">2.0</span>, <span class="nv">y</span>: <span class="m">3.0</span>)
</li><li><span class="c"><span class="enstr">// this will report an error</span><!--end_enstr--><span class="jpstr">（これは、エラーを報告します）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
</div>
<div class="section" id="ID240">
<h3><span class="enstr">Assigning to self Within a Mutating Method<a class="headerlink" href="#ID240" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
変更メソッド内部でselfに代入する<a class="headerlink" href="#ID240" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h3>
<p><span class="enstr">Mutating methods can assign an entirely new instance to the implicit <code class="docutils literal notranslate"><span class="pre">self</span></code> property. The <code class="docutils literal notranslate"><span class="pre">Point</span></code> example shown above could have been written in the following way instead:</span><!--end_enstr-->
<span class="jpstr">
変更メソッドは、まったく新しいインスタンスを暗黙の<code class="docutils literal notranslate"><span class="pre">self</span></code>プロパティに代入することができます。上で示される<code class="docutils literal notranslate"><span class="pre">Point</span></code>の例は、その代わりに以下のようにして書かれることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Point</span> {
</li><li>    <span class="k">var</span> <span class="nv">x</span> = <span class="m">0.0</span>, <span class="nv">y</span> = <span class="m">0.0</span>
</li><li>    <span class="k">mutating</span> <span class="k">func</span> <span class="nv">moveBy</span>(<span class="nv">x</span> <span class="nv">deltaX</span>: <span class="nc">Double</span>, <span class="nv">y</span> <span class="nv">deltaY</span>: <span class="nc">Double</span>) {
</li><li>        <span class="k">self</span> = <span class="nv">Point</span>(<span class="nv">x</span>: <span class="nv">x</span> + <span class="nv">deltaX</span>, <span class="nv">y</span>: <span class="nv">y</span> + <span class="nv">deltaY</span>)
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">This version of the mutating <code class="docutils literal notranslate"><span class="pre">moveBy(x:y:)</span></code> method creates a new structure whose <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> values are set to the target location. The end result of calling this alternative version of the method will be exactly the same as for calling the earlier version.</span><!--end_enstr-->
<span class="jpstr">
変更<code class="docutils literal notranslate"><span class="pre">moveBy(x:y:)</span></code>メソッドのこの改作は、それの持つ<code class="docutils literal notranslate"><span class="pre">x</span></code>と<code class="docutils literal notranslate"><span class="pre">y</span></code>の値が目標場所に設定される、新しい構造体を作成します。メソッドのこの代替版を呼ぶ最終結果は、以前の版を呼ぶことと正確に同じです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Mutating methods for enumerations can set the implicit <code class="docutils literal notranslate"><span class="pre">self</span></code> parameter to be a different case from the same enumeration:</span><!--end_enstr-->
<span class="jpstr">
列挙のための変更メソッドは、暗黙の<code class="docutils literal notranslate"><span class="pre">self</span></code>パラメータを同じ列挙からの異なるケース節に設定することができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">enum</span> <span class="nv">TriStateSwitch</span> {
</li><li>    <span class="k">case</span> <span class="nv">off</span>, <span class="nv">low</span>, <span class="nv">high</span>
</li><li>    <span class="k">mutating</span> <span class="k">func</span> <span class="nv">next</span>() {
</li><li>        <span class="k">switch</span> <span class="k">self</span> {
</li><li>        <span class="k">case</span> .<span class="nv">off</span>:
</li><li>            <span class="k">self</span> = .<span class="nv">low</span>
</li><li>        <span class="k">case</span> .<span class="nv">low</span>:
</li><li>            <span class="k">self</span> = .<span class="nv">high</span>
</li><li>        <span class="k">case</span> .<span class="nv">high</span>:
</li><li>            <span class="k">self</span> = .<span class="nv">off</span>
</li><li>        }
</li><li>    }
</li><li>}
</li><li><span class="k">var</span> <span class="nv">ovenLight</span> = <span class="nv">TriStateSwitch</span>.<span class="nv">low</span>
</li><li><span class="nv">ovenLight</span>.<span class="nv">next</span>()
</li><li><span class="c"><span class="enstr">// ovenLight is now equal to .high</span><!--end_enstr--><span class="jpstr">（ovenLightは現在.hightと等しい）</span><!--end_jpstr--></span>
</li><li><span class="nv">ovenLight</span>.<span class="nv">next</span>()
</li><li><span class="c"><span class="enstr">// ovenLight is now equal to .off</span><!--end_enstr--><span class="jpstr">（ovenLightは現在.lowと等しい）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">This example defines an enumeration for a three-state switch. The switch cycles between three different power states (<code class="docutils literal notranslate"><span class="pre">off</span></code>, <code class="docutils literal notranslate"><span class="pre">low</span></code> and <code class="docutils literal notranslate"><span class="pre">high</span></code>) every time its <code class="docutils literal notranslate"><span class="pre">next()</span></code> method is called.</span><!--end_enstr-->
<span class="jpstr">
この例は、３つの状態を切り替えるために、ある列挙を定義します。この切替えは、３つの異なる出力状態（<code class="docutils literal notranslate"><span class="pre">off</span></code>、<code class="docutils literal notranslate"><span class="pre">low</span></code>と<code class="docutils literal notranslate"><span class="pre">high</span></code>）の間を、それの<code class="docutils literal notranslate"><span class="pre">next()</span></code>メソッドが呼ばれるたびに循環します。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID241">
<h2><span class="enstr">Type Methods<a class="headerlink" href="#ID241" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
型メソッド<a class="headerlink" href="#ID241" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">Instance methods, as described above, are methods that you call on an instance of a particular type. You can also define methods that are called on the type itself. These kinds of methods are called <em>type methods</em>. You indicate type methods by writing the <code class="docutils literal notranslate"><span class="pre">static</span></code> keyword before the method’s <code class="docutils literal notranslate"><span class="pre">func</span></code> keyword. Classes can use the <code class="docutils literal notranslate"><span class="pre">class</span></code> keyword instead, to allow subclasses to override the superclass’s implementation of that method.</span><!--end_enstr-->
<span class="jpstr">
インスタンスメソッドは、上で記述されるように、あなたが特定の型のインスタンス上で呼び出すメソッドです。あなたは、また、型それ自体の上で呼ばれるメソッドを定義することができます。これらの種類のメソッドは、<em>型メソッド</em>と呼ばれています。あなたは、型メソッドを<code class="docutils literal notranslate"><span class="pre">static</span></code>キーワードをメソッドの<code class="docutils literal notranslate"><span class="pre">func</span></code>キーワードの前に書くことによって示します。クラスは代わりに<code class="docutils literal notranslate"><span class="pre">class</span></code>キーワードを使って、サブクラスにスーパークラスのもつそのメソッドの実装をオーバーライドすることを許可できます。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">In Objective-C, you can define type-level methods only for Objective-C classes. In Swift, you can define type-level methods for all classes, structures, and enumerations. Each type method is explicitly scoped to the type it supports.</span><!--end_enstr-->
<span class="jpstr">
Objective-Cでは、あなたはObjective-Cクラスのためにだけ型レベルのメソッドを定義することができます。スウィフトでは、あなたは全てのクラス、構造体、および列挙のために型レベルのメソッドを定義することができます。各型メソッドは、当然ながらそれが支える型にスコープを指定されます。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">Type methods are called with dot syntax, like instance methods. However, you call type methods on the type, not on an instance of that type. Here’s how you call a type method on a class called <code class="docutils literal notranslate"><span class="pre">SomeClass</span></code>:</span><!--end_enstr-->
<span class="jpstr">
型メソッドは、インスタンスメソッドの様に、ドット構文で呼ばれます。しかし、あなたは型のメソッドを型の上で呼び出します、その型のインスタンスの上ではなく。あなたが型メソッドを<code class="docutils literal notranslate"><span class="pre">SomeClass</span></code>と呼ばれるクラスの上で呼び出す方法がここにあります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">SomeClass</span> {
</li><li>    <span class="k">class</span> <span class="k">func</span> <span class="nv">someTypeMethod</span>() {
</li><li>        <span class="c"><span class="enstr">// type method implementation goes here</span><!--end_enstr--><span class="jpstr">（型メソッドの実施が、ここにきます）</span><!--end_jpstr--></span>
</li><li>    }
</li><li>}
</li><li><span class="nv">SomeClass</span>.<span class="nv">someTypeMethod</span>()
</li></ol></div></div></div>
<p><span class="enstr">Within the body of a type method, the implicit <code class="docutils literal notranslate"><span class="pre">self</span></code> property refers to the type itself, rather than an instance of that type. This means that you can use <code class="docutils literal notranslate"><span class="pre">self</span></code> to disambiguate between type properties and type method parameters, just as you do for instance properties and instance method parameters.</span><!--end_enstr-->
<span class="jpstr">
ある型メソッドの本文内で、暗黙の<code class="docutils literal notranslate"><span class="pre">self</span></code>プロパティはその型自身に言及します、その型のインスタンスではありません。これはあなたが型プロパティと型メソッドパラメータの間で曖昧さをなくすために<code class="docutils literal notranslate"><span class="pre">self</span></code>を使うことができることを意味します、ちょうどあなたがインスタンスプロパティとインスタンスメソッドパラメータでするように。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">More generally, any unqualified method and property names that you use within the body of a type method will refer to other type-level methods and properties. A type method can call another type method with the other method’s name, without needing to prefix it with the type name. Similarly, type methods on structures and enumerations can access type properties by using the type property’s name without a type name prefix.</span><!--end_enstr-->
<span class="jpstr">
より一般的に言えば、あなたがある型メソッドの本文内で使うどんな非修飾のメソッドやプロパティ名でも、他の型レベルのメソッドやプロパティに言及します。ある型メソッドは、別の型メソッドを他のメソッドの名前を使って呼ぶことができます、その型名をそれの前に置く必要なしに。同じように、構造体と列挙の型メソッドは、型名前接頭辞なしで型プロパティの名前を使用することによって型プロパティにアクセスすることができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The example below defines a structure called <code class="docutils literal notranslate"><span class="pre">LevelTracker</span></code>, which tracks a player’s progress through the different levels or stages of a game. It is a single-player game, but can store information for multiple players on a single device.</span><!--end_enstr-->
<span class="jpstr">
下の例は<code class="docutils literal notranslate"><span class="pre">LevelTracker</span></code>と呼ばれる構造体を定義します、それは、プレイヤーの進み具合をゲームの異なるレベルまたはステージを通して追跡します。それはシングルプレーヤーのゲームです、しかし１つの装置上で複数のプレーヤーのために情報を蓄えることができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">All of the game’s levels (apart from level one) are locked when the game is first played. Every time a player finishes a level, that level is unlocked for all players on the device. The <code class="docutils literal notranslate"><span class="pre">LevelTracker</span></code> structure uses type properties and methods to keep track of which levels of the game have been unlocked. It also tracks the current level for an individual player.</span><!--end_enstr-->
<span class="jpstr">
ゲームが最初にプレイされるとき、ゲームのレベルの全ては鍵をかけられます（レベル１は別として）。プレーヤーがあるレベルを終了するごとに、そのレベルはその装置上の全てのプレーヤーのために鍵を外されます。<code class="docutils literal notranslate"><span class="pre">LevelTracker</span></code>構造体は、そのゲームのどのレベルが鍵を開けられているかを追跡し続けるために型プロパティとメソッドを使用します。それはまた、個々のプレーヤーのために現在のレベルを追跡します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">LevelTracker</span> {
</li><li>    <span class="k">static</span> <span class="k">var</span> <span class="nv">highestUnlockedLevel</span> = <span class="m">1</span>
</li><li>    <span class="k">var</span> <span class="nv">currentLevel</span> = <span class="m">1</span>
</li><li>
</li><li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">unlock</span>(<span class="k">_</span> <span class="nv">level</span>: <span class="nc">Int</span>) {
</li><li>        <span class="k">if</span> <span class="nv">level</span> &gt; <span class="nv">highestUnlockedLevel</span> { <span class="nv">highestUnlockedLevel</span> = <span class="nv">level</span> }
</li><li>    }
</li><li>
</li><li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">isUnlocked</span>(<span class="k">_</span> <span class="nv">level</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Bool</span> {
</li><li>        <span class="k">return</span> <span class="nv">level</span> &lt;= <span class="nv">highestUnlockedLevel</span>
</li><li>    }
</li><li>
</li><li>    <span class="k">@discardableResult</span>
</li><li>    <span class="k">mutating</span> <span class="k">func</span> <span class="nv">advance</span>(<span class="nv">to</span> <span class="nv">level</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Bool</span> {
</li><li>        <span class="k">if</span> <span class="nv">LevelTracker</span>.<span class="nv">isUnlocked</span>(<span class="nv">level</span>) {
</li><li>            <span class="nv">currentLevel</span> = <span class="nv">level</span>
</li><li>            <span class="k">return</span> <span class="k">true</span>
</li><li>        } <span class="k">else</span> {
</li><li>            <span class="k">return</span> <span class="k">false</span>
</li><li>        }
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">LevelTracker</span></code> structure keeps track of the highest level that any player has unlocked. This value is stored in a type property called <code class="docutils literal notranslate"><span class="pre">highestUnlockedLevel</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">LevelTracker</span></code>構造体は、プレーヤーのだれかが鍵を開けた最も高いレベルの情報を得続けます。この値は、<code class="docutils literal notranslate"><span class="pre">highestUnlockedLevel</span></code>と呼ばれる型プロパティに格納されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr"><code class="docutils literal notranslate"><span class="pre">LevelTracker</span></code> also defines two type functions to work with the <code class="docutils literal notranslate"><span class="pre">highestUnlockedLevel</span></code> property. The first is a type function called <code class="docutils literal notranslate"><span class="pre">unlock(_:)</span></code>, which updates the value of <code class="docutils literal notranslate"><span class="pre">highestUnlockedLevel</span></code> whenever a new level is unlocked. The second is a convenience type function called <code class="docutils literal notranslate"><span class="pre">isUnlocked(_:)</span></code>, which returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if a particular level number is already unlocked. (Note that these type methods can access the <code class="docutils literal notranslate"><span class="pre">highestUnlockedLevel</span></code> type property without your needing to write it as <code class="docutils literal notranslate"><span class="pre">LevelTracker.highestUnlockedLevel</span></code>.)</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">LevelTracker</span></code>はまた、２つの型関数を定義して<code class="docutils literal notranslate"><span class="pre">highestUnlockedLevel</span></code>プロパティを取り扱います。第一は、<code class="docutils literal notranslate"><span class="pre">unlock(_:)</span></code>と呼ばれる型関数です、それは、新しいレベルが錠を開けられるときはいつでも、<code class="docutils literal notranslate"><span class="pre">highestUnlockedLevel</span></code>の値を更新します。第二は、<code class="docutils literal notranslate"><span class="pre">isUnlocked(_:)</span></code>と呼ばれる便利な型関数です、それは、特定のレベル番号がすでに錠を開けられるならば、<code class="docutils literal notranslate"><span class="pre">true</span></code>を返します。（これらの型メソッドは、あなたがそれを<code class="docutils literal notranslate"><span class="pre">LevelTracker.highestUnlockedLevel</span></code>と書かなくても、<code class="docutils literal notranslate"><span class="pre">highestUnlockedLevel</span></code>型プロパティにアクセスできる点に注意してください）。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">In addition to its type property and type methods, <code class="docutils literal notranslate"><span class="pre">LevelTracker</span></code> tracks an individual player’s progress through the game. It uses an instance property called <code class="docutils literal notranslate"><span class="pre">currentLevel</span></code> to track the level that a player is currently playing.</span><!--end_enstr-->
<span class="jpstr">
その型プロパティと型メソッドに加えて、<code class="docutils literal notranslate"><span class="pre">LevelTracker</span></code>は個々のプレーヤーのゲームを通しての進捗を追います。それは<code class="docutils literal notranslate"><span class="pre">currentLevel</span></code>と呼ばれるインスタンスプロパティをプレーヤーが現在プレイしているレベルを追跡するために使います。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">To help manage the <code class="docutils literal notranslate"><span class="pre">currentLevel</span></code> property, <code class="docutils literal notranslate"><span class="pre">LevelTracker</span></code> defines an instance method called <code class="docutils literal notranslate"><span class="pre">advance(to:)</span></code>. Before updating <code class="docutils literal notranslate"><span class="pre">currentLevel</span></code>, this method checks whether the requested new level is already unlocked. The <code class="docutils literal notranslate"><span class="pre">advance(to:)</span></code> method returns a Boolean value to indicate whether or not it was actually able to set <code class="docutils literal notranslate"><span class="pre">currentLevel</span></code>. Because it’s not necessarily a mistake for code that calls the <code class="docutils literal notranslate"><span class="pre">advance(to:)</span></code> method to ignore the return value, this function is marked with the <code class="docutils literal notranslate"><span class="pre">@discardableResult</span></code> attribute. For more information about this attribute, see <a class="reference internal" href="../ReferenceManual/Attributes.html"><span class="doc">Attributes</span></a>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">currentLevel</span></code>プロパティを管理するのを手伝うために、<code class="docutils literal notranslate"><span class="pre">LevelTracker</span></code>は<code class="docutils literal notranslate"><span class="pre">advance(to:)</span></code>と呼ばれるインスタンスメソッドを定義します。<code class="docutils literal notranslate"><span class="pre">currentLevel</span></code>を更新する前に、このメソッドは要請された新しいレベルがすでに錠を開けられるかどうか調べます。<code class="docutils literal notranslate"><span class="pre">advance(to:)</span></code>メソッドは、それが実際に<code class="docutils literal notranslate"><span class="pre">currentLevel</span></code>を設定することができたかどうか示すためにブールの値を返します。<code class="docutils literal notranslate"><span class="pre">advance(to:)</span></code>メソッドを呼び出して戻り値を無視することが必ずしもコードの誤りでないことから、この関数は<code class="docutils literal notranslate"><span class="pre">@discardableResult</span></code>属性で印されます。この属性についてのさらなる情報として、<a class="reference internal" href="../ReferenceManual/Attributes.html"><span class="doc">属性</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">LevelTracker</span></code> structure is used with the <code class="docutils literal notranslate"><span class="pre">Player</span></code> class, shown below, to track and update the progress of an individual player:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">LevelTracker</span></code>構造体は<code class="docutils literal notranslate"><span class="pre">Player</span></code>クラスとともに使用され、下で示されるように、個々のプレーヤーの進捗を追跡して更新します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">class</span> <span class="nv">Player</span> {
</li><li>    <span class="k">var</span> <span class="nv">tracker</span> = <span class="nv">LevelTracker</span>()
</li><li>    <span class="k">let</span> <span class="nv">playerName</span>: <span class="nc">String</span>
</li><li>    <span class="k">func</span> <span class="nv">complete</span>(<span class="nv">level</span>: <span class="nc">Int</span>) {
</li><li>        <span class="nv">LevelTracker</span>.<span class="nv">unlock</span>(<span class="nv">level</span> + <span class="m">1</span>)
</li><li>        <span class="nv">tracker</span>.<span class="nv">advance</span>(<span class="nv">to</span>: <span class="nv">level</span> + <span class="m">1</span>)
</li><li>    }
</li><li>    <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>) {
</li><li>        <span class="nv">playerName</span> = <span class="nv">name</span>
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">Player</span></code> class creates a new instance of <code class="docutils literal notranslate"><span class="pre">LevelTracker</span></code> to track that player’s progress. It also provides a method called <code class="docutils literal notranslate"><span class="pre">complete(level:)</span></code>, which is called whenever a player completes a particular level. This method unlocks the next level for all players and updates the player’s progress to move them to the next level. (The Boolean return value of <code class="docutils literal notranslate"><span class="pre">advance(to:)</span></code> is ignored, because the level is known to have been unlocked by the call to <code class="docutils literal notranslate"><span class="pre">LevelTracker.unlock(_:)</span></code> on the previous line.)</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Player</span></code>クラスは、そのプレーヤーの進捗を追うために<code class="docutils literal notranslate"><span class="pre">LevelTracker</span></code>の新しいインスタンスをつくります。それはまた<code class="docutils literal notranslate"><span class="pre">complete(level:)</span></code>と呼ばれるメソッドを提供します、それは、プレーヤーが特定のレベルを完了するときはいつでも呼び出されます。このメソッドは、全てのプレーヤーたちのために次のレベルの錠をあけて、プレーヤーの進捗をかれらを次のレベルへ移動するために更新します。（<code class="docutils literal notranslate"><span class="pre">advance(to:)</span></code>のブールの戻り値は無視されます、なぜなら、このレベルは前の行で<code class="docutils literal notranslate"><span class="pre">LevelTracker.unlock(_:)</span></code>呼び出しによってすでに錠を開けられていると分かるからです）。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can create an instance of the <code class="docutils literal notranslate"><span class="pre">Player</span></code> class for a new player, and see what happens when the player completes level one:</span><!--end_enstr-->
<span class="jpstr">
あなたは、新しいプレーヤーのために<code class="docutils literal notranslate"><span class="pre">Player</span></code>クラスのインスタンスをつくることができて、そのプレーヤーがレベル１を完了するとき、何が起こるか見ることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">var</span> <span class="nv">player</span> = <span class="nv">Player</span>(<span class="nv">name</span>: <span class="s">"Argyrios"</span>)
</li><li><span class="nv">player</span>.<span class="nv">complete</span>(<span class="nv">level</span>: <span class="m">1</span>)
</li><li><span class="nv">print</span>(<span class="s">"highest unlocked level is now </span>\<span class="p">(</span><span class="nv">LevelTracker</span>.<span class="nv">highestUnlockedLevel</span><span class="p">)</span><span class="s">"</span>)
</li><li><span class="c"><span class="enstr">// Prints "highest unlocked level is now 2"</span><!--end_enstr--><span class="jpstr">（「最も高い鍵の開いたレベルは現在２です」を出力します）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">If you create a second player, whom you try to move to a level that is not yet unlocked by any player in the game, the attempt to set the player’s current level fails:</span><!--end_enstr-->
<span class="jpstr">
あなたが二番目のプレーヤーを作成して、あなたがその人をそのゲームにおいてどのプレーヤーによってもまだ錠を開けられていないレベルへ動かそうとするならば、プレーヤーの現在のレベルを決めるその試みは失敗します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="nv">player</span> = <span class="nv">Player</span>(<span class="nv">name</span>: <span class="s">"Beto"</span>)
</li><li><span class="k">if</span> <span class="nv">player</span>.<span class="nv">tracker</span>.<span class="nv">advance</span>(<span class="nv">to</span>: <span class="m">6</span>) {
</li><li>    <span class="nv">print</span>(<span class="s">"player is now on level 6"</span>)
</li><li>} <span class="k">else</span> {
</li><li>    <span class="nv">print</span>(<span class="s">"level 6 has not yet been unlocked"</span>)
</li><li>}
</li><li><span class="c"><span class="enstr">// Prints "level 6 has not yet been unlocked"</span><!--end_enstr--><span class="jpstr">（「レベル６はまだ開錠されていません」を出力します）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
</div>
</div>


    </article>
    <div class="next_previous">
        <p class="previous"><a href="Properties.html"><span class="enstr">Properties</span><!--end_enstr-->
<span class="jpstr">
プロパティ
</span><!--end_jpstr-->
</a></p>
        <p class="next"><a href="Subscripts.html"><span class="enstr">Subscripts</span><!--end_enstr-->
<span class="jpstr">
添え字
</span><!--end_jpstr-->
</a></p>
    </div>
</main>


<footer role="contentinfo">
  <aside>
    <a href="//swift.org/atom.xml" title="Subscribe to Site Updates"><i class="feed">Subscribe</i></a>
    <a href="https://twitter.com/swiftlang" rel="nofollow" title="Follow @SwiftLang on Twitter"><i class="twitter">Twitter</i></a>
  </aside>

  <p class="copyright">Copyright © 2019 Apple Inc. All rights reserved.</p>
  <p class="trademark">Swift and the Swift logo are trademarks of Apple Inc.</p>
  <p class="privacy">
    <a href="//www.apple.com/privacy/privacy-policy/">Privacy Policy</a>
    <a href="//www.apple.com/legal/privacy/en-ww/cookies/">Cookies</a>
  </p>
</footer>
<div id="jump_to_overlay"></div>
<script src="../_static/javascripts/application.js"></script>
  </body>
</html>
