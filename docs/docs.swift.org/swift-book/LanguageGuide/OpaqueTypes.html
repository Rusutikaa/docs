

<!DOCTYPE html>



<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8" />
    <meta name="author" content="Apple Inc." />
    <meta name="viewport" content="width=device-width initial-scale=1" />
    
    <title>Opaque Types — The Swift Programming Language (Swift 5.5)</title>
    
    <link rel="license" href="/LICENSE.txt" />
    <link rel="stylesheet" media="all" href="../static/stylesheets/application.css" />
    <link rel="stylesheet" media="all" href="../static/stylesheets/tspl.css" />
    <link rel="shortcut icon" sizes="16x16 24x24 32x32 48x48 64x64" type="image/vnd.microsoft.icon" href="/favicon.ico" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png" />
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png" />
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png" />
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png" />
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png" />
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png" />
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png" />
    <link rel="mask-icon" href="/assets/images/icon-swift.svg" color="#F05339" /> 
  </head>
  <body>


<nav role="navigation">
    <header role="banner">
      <h1 id="logo">
        <a href="https://swift.org/" title="Swift.org" role="img" aria-label="Swift.org">
          Swift.org
        </a>
      </h1>
    </header>

    <div id="menu-toggle" class="menu-toggle open"></div>

    <h2>The Swift Programming Language<div>Swift 5.5</div></h2>

    <ul>
    <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html"><span class="enstr">Welcome to Swift</span><!--end_enstr-->
<span class="jpstr">
スウィフトにようこそ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="TheBasics.html"><span class="enstr">Language Guide</span><!--end_enstr-->
<span class="jpstr">
言語ガイド
</span><!--end_jpstr-->
</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="TheBasics.html"><span class="enstr">The Basics</span><!--end_enstr-->
<span class="jpstr">
基本
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="BasicOperators.html"><span class="enstr">Basic Operators</span><!--end_enstr-->
<span class="jpstr">
基本の演算子
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="StringsAndCharacters.html"><span class="enstr">Strings and Characters</span><!--end_enstr-->
<span class="jpstr">
文字列と文字
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="CollectionTypes.html"><span class="enstr">Collection Types</span><!--end_enstr-->
<span class="jpstr">
コレクション型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ControlFlow.html"><span class="enstr">Control Flow</span><!--end_enstr-->
<span class="jpstr">
制御の流れ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Functions.html"><span class="enstr">Functions</span><!--end_enstr-->
<span class="jpstr">
関数
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Closures.html"><span class="enstr">Closures</span><!--end_enstr-->
<span class="jpstr">
クロージャ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Enumerations.html"><span class="enstr">Enumerations</span><!--end_enstr-->
<span class="jpstr">
列挙
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ClassesAndStructures.html"><span class="enstr">Structures and Classes</span><!--end_enstr-->
<span class="jpstr">
構造体とクラス
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Properties.html"><span class="enstr">Properties</span><!--end_enstr-->
<span class="jpstr">
プロパティ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Methods.html"><span class="enstr">Methods</span><!--end_enstr-->
<span class="jpstr">
メソッド
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Subscripts.html"><span class="enstr">Subscripts</span><!--end_enstr-->
<span class="jpstr">
添え字
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Inheritance.html"><span class="enstr">Inheritance</span><!--end_enstr-->
<span class="jpstr">
継承
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Initialization.html"><span class="enstr">Initialization</span><!--end_enstr-->
<span class="jpstr">
初期化
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Deinitialization.html"><span class="enstr">Deinitialization</span><!--end_enstr-->
<span class="jpstr">
デイニシャライズ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="OptionalChaining.html"><span class="enstr">Optional Chaining</span><!--end_enstr-->
<span class="jpstr">
オプショナル連鎖
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ErrorHandling.html"><span class="enstr">Error Handling</span><!--end_enstr-->
<span class="jpstr">
エラーの処理
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html"><span class="enstr">Concurrency</span><!--end_enstr-->
<span class="jpstr">
並行性
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="TypeCasting.html"><span class="enstr">Type Casting</span><!--end_enstr-->
<span class="jpstr">
型キャスト
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="NestedTypes.html"><span class="enstr">Nested Types</span><!--end_enstr-->
<span class="jpstr">
入れ子にされた型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Extensions.html"><span class="enstr">Extensions</span><!--end_enstr-->
<span class="jpstr">
拡張
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Protocols.html"><span class="enstr">Protocols</span><!--end_enstr-->
<span class="jpstr">
プロトコル
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Generics.html"><span class="enstr">Generics</span><!--end_enstr-->
<span class="jpstr">
総称体
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#"><span class="enstr">Opaque Types</span><!--end_enstr-->
<span class="jpstr">
不透明型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AutomaticReferenceCounting.html"><span class="enstr">Automatic Reference Counting</span><!--end_enstr-->
<span class="jpstr">
自動参照カウント
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="MemorySafety.html"><span class="enstr">Memory Safety</span><!--end_enstr-->
<span class="jpstr">
メモリ安全
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AccessControl.html"><span class="enstr">Access Control</span><!--end_enstr-->
<span class="jpstr">
アクセス制御
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AdvancedOperators.html"><span class="enstr">Advanced Operators</span><!--end_enstr-->
<span class="jpstr">
先進の演算子
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ReferenceManual/AboutTheLanguageReference.html"><span class="enstr">Language Reference</span><!--end_enstr-->
<span class="jpstr">
言語リファレンス
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1"><a class="reference internal" href="../RevisionHistory/RevisionHistory.html"><span class="enstr">Revision History</span><!--end_enstr-->
<span class="jpstr">
改訂履歴
</span><!--end_jpstr-->
</a></li>
</ul>

    <li class="toctree-l1 return"><a class="reference internal" href="../../../index.html">← Go to Index</a></li>
    </ul>
</nav>




<main role="main">
    <article class="page">
        <menu id="bashful" type="toolbar">
          <div class="inner">
            <menuitem id="jump_to" class="menu-bar-item closed">
            <span id="jump_to_toggle">On This Page</span>
            <div class="chevron">
                <div class="chevy chevron-left"></div>
                <div class="chevy chevron-right"></div>
            </div>
            <menu type="list" class="details">
                <ul>
<li><a class="reference internal" href="#"><span class="enstr">Opaque Types</span><!--end_enstr-->
<span class="jpstr">
不透明型
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID613"><span class="enstr">The Problem That Opaque Types Solve</span><!--end_enstr-->
<span class="jpstr">
不透明型が解決する問題
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID614"><span class="enstr">Returning an Opaque Type</span><!--end_enstr-->
<span class="jpstr">
不透明型を返す
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID615"><span class="enstr">Differences Between Opaque Types and Protocol Types</span><!--end_enstr-->
<span class="jpstr">
不透明型とプロトコル型の間の違い
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
</ul>

            </menu>
            </menuitem>
          </div>
        </menu>

        
  <div class="section" id="opaque-types">
<h1><span class="enstr">Opaque Types<a class="headerlink" href="#opaque-types" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
不透明型<a class="headerlink" href="#opaque-types" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h1>
<p><span class="enstr">A function or method with an opaque return type hides its return value’s type information. Instead of providing a concrete type as the function’s return type, the return value is described in terms of the protocols it supports. Hiding type information is useful at boundaries between a module and code that calls into the module, because the underlying type of the return value can remain private. Unlike returning a value whose type is a protocol type, opaque types preserve type identity—the compiler has access to the type information, but clients of the module don’t.</span><!--end_enstr-->
<span class="jpstr">
不透明戻り型をもつ関数またはメソッドは、それの戻り値のもつ型情報を隠します。ある具象型を関数のもつ戻り型として提供する代わりに、戻り値はそれがサポートするプロトコルそれらの観点から記述されます。型情報を隠すことは、あるモジュールとモジュールへと呼び出しをするコードとの間の境界で役立ちます、なぜなら戻り値のその基礎をなす型は、プライベートのままであることが可能だからです。それの型があるプロトコル型である値を返すのとは違い、不透明型は型同一性を保全します — コンパイラは型情報にアクセスします、しかしモジュールのクライアントはしません。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID613">
<h2><span class="enstr">The Problem That Opaque Types Solve<a class="headerlink" href="#ID613" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
不透明型が解決する問題<a class="headerlink" href="#ID613" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">For example, suppose you’re writing a module that draws ASCII art shapes. The basic characteristic of an ASCII art shape is a <code class="docutils literal notranslate"><span class="pre">draw()</span></code> function that returns the string representation of that shape, which you can use as the requirement for the <code class="docutils literal notranslate"><span class="pre">Shape</span></code> protocol:</span><!--end_enstr-->
<span class="jpstr">
例えば、あなたがさまざまなASCIIアート形状を描くモジュールを記述していると仮定してください。あるASCIIアート形状の基本的な特徴は、その形状の文字列表現を返す<code class="docutils literal notranslate"><span class="pre">draw()</span></code>関数です、それはあなたが要件として<code class="docutils literal notranslate"><span class="pre">Shape</span></code>プロトコルに対して使用できます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">Shape</span> {
</li><li>    <span class="k">func</span> <span class="nv">draw</span>() -&gt; <span class="nc">String</span>
</li><li>}
</li><li>
</li><li><span class="k">struct</span> <span class="nv">Triangle</span>: <span class="nc">Shape</span> {
</li><li>    <span class="k">var</span> <span class="nv">size</span>: <span class="nc">Int</span>
</li><li>    <span class="k">func</span> <span class="nv">draw</span>() -&gt; <span class="nc">String</span> {
</li><li>        <span class="k">var</span> <span class="nv">result</span>: [<span class="nc">String</span>] = []
</li><li>        <span class="k">for</span> <span class="nv">length</span> <span class="k">in</span> <span class="m">1</span>...<span class="nv">size</span> {
</li><li>            <span class="nv">result</span>.<span class="nv">append</span>(<span class="nv">String</span>(<span class="nv">repeating</span>: <span class="s">"*"</span>, <span class="nv">count</span>: <span class="nv">length</span>))
</li><li>        }
</li><li>        <span class="k">return</span> <span class="nv">result</span>.<span class="nv">joined</span>(<span class="nv">separator</span>: <span class="s">"\n"</span>)
</li><li>    }
</li><li>}
</li><li><span class="k">let</span> <span class="nv">smallTriangle</span> = <span class="nv">Triangle</span>(<span class="nv">size</span>: <span class="m">3</span>)
</li><li><span class="nv">print</span>(<span class="nv">smallTriangle</span>.<span class="nv">draw</span>())
</li><li><span class="c">// *</span>
</li><li><span class="c">// **</span>
</li><li><span class="c">// ***</span>
</li></ol></div></div></div>
<p><span class="enstr">You could use generics to implement operations like flipping a shape vertically, as shown in the code below. However, there’s an important limitation to this approach: The flipped result exposes the exact generic types that were used to create it.</span><!--end_enstr-->
<span class="jpstr">
あなたは総称体を使って、ある形状を垂直に裏返すような演算を実装できました、下のコードで示されるように。しかしながら、重大な限界がこの取り組みにはあります：その裏返された結果は、それを作成するのに使われた正確な総称体型を露出します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">FlippedShape</span>&lt;<span class="nv">T</span>: <span class="nc">Shape</span>&gt;: <span class="nc">Shape</span> {
</li><li>    <span class="k">var</span> <span class="nv">shape</span>: <span class="nc">T</span>
</li><li>    <span class="k">func</span> <span class="nv">draw</span>() -&gt; <span class="nc">String</span> {
</li><li>        <span class="k">let</span> <span class="nv">lines</span> = <span class="nv">shape</span>.<span class="nv">draw</span>().<span class="nv">split</span>(<span class="nv">separator</span>: <span class="s">"\n"</span>)
</li><li>        <span class="k">return</span> <span class="nv">lines</span>.<span class="nv">reversed</span>().<span class="nv">joined</span>(<span class="nv">separator</span>: <span class="s">"\n"</span>)
</li><li>    }
</li><li>}
</li><li><span class="k">let</span> <span class="nv">flippedTriangle</span> = <span class="nv">FlippedShape</span>(<span class="nv">shape</span>: <span class="nv">smallTriangle</span>)
</li><li><span class="nv">print</span>(<span class="nv">flippedTriangle</span>.<span class="nv">draw</span>())
</li><li><span class="c">// ***</span>
</li><li><span class="c">// **</span>
</li><li><span class="c">// *</span>
</li></ol></div></div></div>
<p><span class="enstr">This approach to defining a <code class="docutils literal notranslate"><span class="pre">JoinedShape&lt;T:</span> <span class="pre">Shape,</span> <span class="pre">U:</span> <span class="pre">Shape&gt;</span></code> structure that joins two shapes together vertically, like the code below shows, results in types like <code class="docutils literal notranslate"><span class="pre">JoinedShape&lt;FlippedShape&lt;Triangle&gt;,</span> <span class="pre">Triangle&gt;</span></code> from joining a flipped triangle with another triangle.</span><!--end_enstr-->
<span class="jpstr">
２つの形状を一緒に垂直につなぐ<code class="docutils literal notranslate"><span class="pre">JoinedShape&lt;T:</span> <span class="pre">Shape,</span> <span class="pre">U:</span> <span class="pre">Shape&gt;</span></code>構造体を定義するこの取り組みは、下のコードが示すように、裏返した三角を別の三角とつなぐことから<code class="docutils literal notranslate"><span class="pre">JoinedShape&lt;FlippedShape&lt;Triangle&gt;,</span> <span class="pre">Triangle&gt;</span></code>のような型という結果になります。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">JoinedShape</span>&lt;<span class="nv">T</span>: <span class="nc">Shape</span>, <span class="nv">U</span>: <span class="nc">Shape</span>&gt;: <span class="nc">Shape</span> {
</li><li>    <span class="k">var</span> <span class="nv">top</span>: <span class="nc">T</span>
</li><li>    <span class="k">var</span> <span class="nv">bottom</span>: <span class="nc">U</span>
</li><li>    <span class="k">func</span> <span class="nv">draw</span>() -&gt; <span class="nc">String</span> {
</li><li>        <span class="k">return</span> <span class="nv">top</span>.<span class="nv">draw</span>() + <span class="s">"\n"</span> + <span class="nv">bottom</span>.<span class="nv">draw</span>()
</li><li>    }
</li><li>}
</li><li><span class="k">let</span> <span class="nv">joinedTriangles</span> = <span class="nv">JoinedShape</span>(<span class="nv">top</span>: <span class="nv">smallTriangle</span>, <span class="nv">bottom</span>: <span class="nv">flippedTriangle</span>)
</li><li><span class="nv">print</span>(<span class="nv">joinedTriangles</span>.<span class="nv">draw</span>())
</li><li><span class="c">// *</span>
</li><li><span class="c">// **</span>
</li><li><span class="c">// ***</span>
</li><li><span class="c">// ***</span>
</li><li><span class="c">// **</span>
</li><li><span class="c">// *</span>
</li></ol></div></div></div>
<p><span class="enstr">Exposing detailed information about the creation of a shape allows types that aren’t meant to be part of the ASCII art module’s public interface to leak out because of the need to state the full return type. The code inside the module could build up the same shape in a variety of ways, and other code outside the module that uses the shape shouldn’t have to account for the implementation details about the list of transformations. Wrapper types like <code class="docutils literal notranslate"><span class="pre">JoinedShape</span></code> and <code class="docutils literal notranslate"><span class="pre">FlippedShape</span></code> don’t matter to the module’s users, and they shouldn’t be visible. The module’s public interface consists of operations like joining and flipping a shape, and those operations return another <code class="docutils literal notranslate"><span class="pre">Shape</span></code> value.</span><!--end_enstr-->
<span class="jpstr">
ある形状の作成についての詳細な情報を露出することは、ASCIIアートモジュールのもつパブリックインターフェイスの一部であることを意図する型それらに漏れ出ていくのを許します、完全な戻り型を公表する必要があるのが原因で。モジュール内のコードは、同じ形状をさまざまな方法で作り上げることができました、そしてその形状を使うモジュール外のその他のコードは、ずらっとある変形それらについての実装詳細に関知する必要はないはずです。<code class="docutils literal notranslate"><span class="pre">JoinedShape</span></code>と<code class="docutils literal notranslate"><span class="pre">FlippedShape</span></code>のようなラッパー型は、モジュールのユーザにとって重要ではありません、そしてそれらは可視でないべきです。モジュールのもつパブリックインターフェイスは、形の結合および裏返しのような演算からなります、そしてそれらの演算は別の<code class="docutils literal notranslate"><span class="pre">Shape</span></code>値を返します。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID614">
<h2><span class="enstr">Returning an Opaque Type<a class="headerlink" href="#ID614" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
不透明型を返す<a class="headerlink" href="#ID614" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">You can think of an opaque type like being the reverse of a generic type. Generic types let the code that calls a function pick the type for that function’s parameters and return value in a way that’s abstracted away from the function implementation. For example, the function in the following code returns a type that depends on its caller:</span><!--end_enstr-->
<span class="jpstr">
あなたは、不透明型を総称体の逆であるように考えることができます。総称体型は、ある関数を呼び出すコードに、その関数のもつパラメータと戻り値に対する型を、関数実装から離れて抽象化されるある方法で選択させます。例えば、以下のコードの関数は、それの呼び出し側に依存する、ある型を返します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">max</span>&lt;<span class="nv">T</span>&gt;(<span class="k">_</span> <span class="nv">x</span>: <span class="nc">T</span>, <span class="k">_</span> <span class="nv">y</span>: <span class="nc">T</span>) -&gt; <span class="nc">T</span> <span class="k">where</span> <span class="nc">T</span>: <span class="nc">Comparable</span> { ... }
</li></ol></div></div></div>
<p><span class="enstr">The code that calls <code class="docutils literal notranslate"><span class="pre">max(_:_:)</span></code> chooses the values for <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>, and the type of those values determines the concrete type of <code class="docutils literal notranslate"><span class="pre">T</span></code>. The calling code can use any type that conforms to the <code class="docutils literal notranslate"><span class="pre">Comparable</span></code> protocol. The code inside the function is written in a general way so it can handle whatever type the caller provides. The implementation of <code class="docutils literal notranslate"><span class="pre">max(_:_:)</span></code> uses only functionality that all <code class="docutils literal notranslate"><span class="pre">Comparable</span></code> types share.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">max(_:_:)</span></code>を呼び出すコードは、<code class="docutils literal notranslate"><span class="pre">x</span></code>と<code class="docutils literal notranslate"><span class="pre">y</span></code>に対して値を選びます、そしてそれらの値の型は<code class="docutils literal notranslate"><span class="pre">T</span></code>の具象型を決定します。呼び出しているコードは、<code class="docutils literal notranslate"><span class="pre">Comparable</span></code>プロトコルに準拠するあらゆる型を使用できます。関数の内側のコードは、ある一般化された方法で記述されます、それでそれは呼び出し側が提供するどんな型でも取り扱うことができます。<code class="docutils literal notranslate"><span class="pre">max(_:_:)</span></code>の実装は、全ての<code class="docutils literal notranslate"><span class="pre">Comparable</span></code>型が共有する機能性だけを使います。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Those roles are reversed for a function with an opaque return type. An opaque type lets the function implementation pick the type for the value it returns in a way that’s abstracted away from the code that calls the function. For example, the function in the following example returns a trapezoid without exposing the underlying type of that shape.</span><!--end_enstr-->
<span class="jpstr">
それらの役割は、不透明戻り型をもつある関数に対しては逆にされます。ある不透明型は、関数実装に、それが返す値に対する型を、その関数を呼び出すコードから離れて抽象化されるある方法で選択させます。例えば、以下の例での関数は、ある台形を、その形状の基礎をなす型を露出することなしに返します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">Square</span>: <span class="nc">Shape</span> {
</li><li>    <span class="k">var</span> <span class="nv">size</span>: <span class="nc">Int</span>
</li><li>    <span class="k">func</span> <span class="nv">draw</span>() -&gt; <span class="nc">String</span> {
</li><li>        <span class="k">let</span> <span class="nv">line</span> = <span class="nv">String</span>(<span class="nv">repeating</span>: <span class="s">"*"</span>, <span class="nv">count</span>: <span class="nv">size</span>)
</li><li>        <span class="k">let</span> <span class="nv">result</span> = <span class="nv">Array</span>&lt;<span class="nc">String</span>&gt;(<span class="nv">repeating</span>: <span class="nv">line</span>, <span class="nv">count</span>: <span class="nv">size</span>)
</li><li>        <span class="k">return</span> <span class="nv">result</span>.<span class="nv">joined</span>(<span class="nv">separator</span>: <span class="s">"\n"</span>)
</li><li>    }
</li><li>}
</li><li>
</li><li><span class="k">func</span> <span class="nv">makeTrapezoid</span>() -&gt; <span class="nc">some</span> <span class="nv">Shape</span> {
</li><li>    <span class="k">let</span> <span class="nv">top</span> = <span class="nv">Triangle</span>(<span class="nv">size</span>: <span class="m">2</span>)
</li><li>    <span class="k">let</span> <span class="nv">middle</span> = <span class="nv">Square</span>(<span class="nv">size</span>: <span class="m">2</span>)
</li><li>    <span class="k">let</span> <span class="nv">bottom</span> = <span class="nv">FlippedShape</span>(<span class="nv">shape</span>: <span class="nv">top</span>)
</li><li>    <span class="k">let</span> <span class="nv">trapezoid</span> = <span class="nv">JoinedShape</span>(
</li><li>        <span class="nv">top</span>: <span class="nv">top</span>,
</li><li>        <span class="nv">bottom</span>: <span class="nv">JoinedShape</span>(<span class="nv">top</span>: <span class="nv">middle</span>, <span class="nv">bottom</span>: <span class="nv">bottom</span>)
</li><li>    )
</li><li>    <span class="k">return</span> <span class="nv">trapezoid</span>
</li><li>}
</li><li><span class="k">let</span> <span class="nv">trapezoid</span> = <span class="nv">makeTrapezoid</span>()
</li><li><span class="nv">print</span>(<span class="nv">trapezoid</span>.<span class="nv">draw</span>())
</li><li><span class="c">// *</span>
</li><li><span class="c">// **</span>
</li><li><span class="c">// **</span>
</li><li><span class="c">// **</span>
</li><li><span class="c">// **</span>
</li><li><span class="c">// *</span>
</li></ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">makeTrapezoid()</span></code> function in this example declares its return type as <code class="docutils literal notranslate"><span class="pre">some</span> <span class="pre">Shape</span></code>; as a result, the function returns a value of some given type that conforms to the <code class="docutils literal notranslate"><span class="pre">Shape</span></code> protocol, without specifying any particular concrete type. Writing <code class="docutils literal notranslate"><span class="pre">makeTrapezoid()</span></code> this way lets it express the fundamental aspect of its public interface—the value it returns is a shape—without making the specific types that the shape is made from a part of its public interface. This implementation uses two triangles and a square, but the function could be rewritten to draw a trapezoid in a variety of other ways without changing its return type.</span><!--end_enstr-->
<span class="jpstr">
この例での<code class="docutils literal notranslate"><span class="pre">makeTrapezoid()</span></code>関数は、それの戻り型を<code class="docutils literal notranslate"><span class="pre">some</span> <span class="pre">Shape</span></code>として宣言します；その結果、関数は、<code class="docutils literal notranslate"><span class="pre">Shape</span></code>プロトコルに準拠するある与えられた型の値を返します、何らかの特定の具象型を指定することなしに。<code class="docutils literal notranslate"><span class="pre">makeTrapezoid()</span></code>をこの方法で書くことは、それにそれのパブリックインターフェイスの基本となる面 — それが返す値はある形状である — を表現させます、特定の型を作ることなしにです、それはその形状がそれのパブリックインターフェイスの一部に由来して作られることです。この実装は、２つの三角形とある四角形を使います、しかし関数は、台形をさまざまな他の方法で描画するよう書き直されることがそれの戻り型を変更することなしにできました。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">This example highlights the way that an opaque return type is like the reverse of a generic type. The code inside <code class="docutils literal notranslate"><span class="pre">makeTrapezoid()</span></code> can return any type it needs to, as long as that type conforms to the <code class="docutils literal notranslate"><span class="pre">Shape</span></code> protocol, like the calling code does for a generic function. The code that calls the function needs to be written in a general way, like the implementation of a generic function, so that it can work with any <code class="docutils literal notranslate"><span class="pre">Shape</span></code> value that’s returned by <code class="docutils literal notranslate"><span class="pre">makeTrapezoid()</span></code>.</span><!--end_enstr-->
<span class="jpstr">
この例は、不透明型が総称体型のまるで逆であるやり方に光を当てます。<code class="docutils literal notranslate"><span class="pre">makeTrapezoid()</span></code>内部のコードは、それが必要とするどんな型でも返すことが、その型が<code class="docutils literal notranslate"><span class="pre">Shape</span></code>プロトコルに準拠する限りは可能です、呼び出しているコードが総称体関数に対してするように。関数を呼び出すコードは、ある一般的な方法で書かれることを必要とします、総称体関数の実装のように、それでそれは、<code class="docutils literal notranslate"><span class="pre">makeTrapezoid()</span></code>によって返されるあらゆる<code class="docutils literal notranslate"><span class="pre">Shape</span></code>と仕事できます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can also combine opaque return types with generics. The functions in the following code both return a value of some type that conforms to the <code class="docutils literal notranslate"><span class="pre">Shape</span></code> protocol.</span><!--end_enstr-->
<span class="jpstr">
あなたはまた、不透明戻り型を総称体と結合できます。以下のコードでの関数は両方とも、<code class="docutils literal notranslate"><span class="pre">Shape</span></code>プロトコルに準拠する何らかの型の値を返します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">flip</span>&lt;<span class="nv">T</span>: <span class="nc">Shape</span>&gt;(<span class="k">_</span> <span class="nv">shape</span>: <span class="nc">T</span>) -&gt; <span class="nc">some</span> <span class="nv">Shape</span> {
</li><li>    <span class="k">return</span> <span class="nv">FlippedShape</span>(<span class="nv">shape</span>: <span class="nv">shape</span>)
</li><li>}
</li><li><span class="k">func</span> <span class="nv">join</span>&lt;<span class="nv">T</span>: <span class="nc">Shape</span>, <span class="nv">U</span>: <span class="nc">Shape</span>&gt;(<span class="k">_</span> <span class="nv">top</span>: <span class="nc">T</span>, <span class="k">_</span> <span class="nv">bottom</span>: <span class="nc">U</span>) -&gt; <span class="nc">some</span> <span class="nv">Shape</span> {
</li><li>    <span class="nv">JoinedShape</span>(<span class="nv">top</span>: <span class="nv">top</span>, <span class="nv">bottom</span>: <span class="nv">bottom</span>)
</li><li>}
</li><li>
</li><li><span class="k">let</span> <span class="nv">opaqueJoinedTriangles</span> = <span class="nv">join</span>(<span class="nv">smallTriangle</span>, <span class="nv">flip</span>(<span class="nv">smallTriangle</span>))
</li><li><span class="nv">print</span>(<span class="nv">opaqueJoinedTriangles</span>.<span class="nv">draw</span>())
</li><li><span class="c">// *</span>
</li><li><span class="c">// **</span>
</li><li><span class="c">// ***</span>
</li><li><span class="c">// ***</span>
</li><li><span class="c">// **</span>
</li><li><span class="c">// *</span>
</li></ol></div></div></div>
<p><span class="enstr">The value of <code class="docutils literal notranslate"><span class="pre">opaqueJoinedTriangles</span></code> in this example is the same as <code class="docutils literal notranslate"><span class="pre">joinedTriangles</span></code> in the generics example in the <a class="reference internal" href="#ID613"><span class="std std-ref">The Problem That Opaque Types Solve</span></a> section earlier in this chapter. However, unlike the value in that example, <code class="docutils literal notranslate"><span class="pre">flip(_:)</span></code> and <code class="docutils literal notranslate"><span class="pre">join(_:_:)</span></code> wrap the underlying types that the generic shape operations return in an opaque return type, which prevents those types from being visible. Both functions are generic because the types they rely on are generic, and the type parameters to the function pass along the type information needed by <code class="docutils literal notranslate"><span class="pre">FlippedShape</span></code> and <code class="docutils literal notranslate"><span class="pre">JoinedShape</span></code>.</span><!--end_enstr-->
<span class="jpstr">
この例での<code class="docutils literal notranslate"><span class="pre">opaqueJoinedTriangles</span></code>の値は、この章の前の<a class="reference internal" href="#ID613"><span class="std std-ref">不透明型が解決する問題</span></a>節の総称体の例での<code class="docutils literal notranslate"><span class="pre">joinedTriangles</span></code>と同じです。しかしながら、その例での値と違い、<code class="docutils literal notranslate"><span class="pre">flip(_:)</span></code>と<code class="docutils literal notranslate"><span class="pre">join(_:_:)</span></code>は基礎をなす型それらをラップします、それらは総称体の形状演算が不透明戻り型において返すものです、それはこれらの型が可視であるのを防ぎます。両方の関数は総称体です、なぜならそれらが頼りにする型が総称体であるからです、そして関数への型パラメータは、<code class="docutils literal notranslate"><span class="pre">FlippedShape</span></code>と<code class="docutils literal notranslate"><span class="pre">JoinedShape</span></code>によって必要とされる型情報を伝達します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">If a function with an opaque return type returns from multiple places, all of the possible return values must have the same type. For a generic function, that return type can use the function’s generic type parameters, but it must still be a single type. For example, here’s an <em>invalid</em> version of the shape-flipping function that includes a special case for squares:</span><!--end_enstr-->
<span class="jpstr">
不透明戻り型をもつ関数が複数の場所から返るならば、可能な戻り値の全ては、同じ型を持たなければなりません。総称体関数に対して、その戻り型は、関数のもつ総称体型パラメータを使用できます、しかしそれは依然として単一の型でなければなりません。例えば、ここに形状反転関数の<em>無効な</em>バージョンがあります、それは正方形に対する特別な場合を含みます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">invalidFlip</span>&lt;<span class="nv">T</span>: <span class="nc">Shape</span>&gt;(<span class="k">_</span> <span class="nv">shape</span>: <span class="nc">T</span>) -&gt; <span class="nc">some</span> <span class="nv">Shape</span> {
</li><li>    <span class="k">if</span> <span class="nv">shape</span> <span class="k">is</span> <span class="nc">Square</span> {
</li><li>        <span class="k">return</span> <span class="nv">shape</span> <span class="enstr"><span class="c">// Error: return types don't match</span></span><!--end_enstr--><span class="jpstr"><span class="c">（エラー：戻り型は一致しません）</span></span><!--end_jpstr--></li><li>    }
</li><li>    <span class="k">return</span> <span class="nv">FlippedShape</span>(<span class="nv">shape</span>: <span class="nv">shape</span>) <span class="enstr"><span class="c">// Error: return types don't match</span></span><!--end_enstr--><span class="jpstr"><span class="c">（エラー：戻り型は一致しません）</span></span><!--end_jpstr--></li><li>}
</li></ol></div></div></div>
<p><span class="enstr">If you call this function with a <code class="docutils literal notranslate"><span class="pre">Square</span></code>, it returns a <code class="docutils literal notranslate"><span class="pre">Square</span></code>; otherwise, it returns a <code class="docutils literal notranslate"><span class="pre">FlippedShape</span></code>. This violates the requirement to return values of only one type and makes <code class="docutils literal notranslate"><span class="pre">invalidFlip(_:)</span></code> invalid code. One way to fix <code class="docutils literal notranslate"><span class="pre">invalidFlip(_:)</span></code> is to move the special case for squares into the implementation of <code class="docutils literal notranslate"><span class="pre">FlippedShape</span></code>, which lets this function always return a <code class="docutils literal notranslate"><span class="pre">FlippedShape</span></code> value:</span><!--end_enstr-->
<span class="jpstr">
あなたがこの関数を<code class="docutils literal notranslate"><span class="pre">Square</span></code>で呼び出すならば、それは<code class="docutils literal notranslate"><span class="pre">Square</span></code>を返します；そうでなければ、それは<code class="docutils literal notranslate"><span class="pre">FlippedShape</span></code>を返します。これは、ただ１つの型だけの値を返すという要件に違反します、そして<code class="docutils literal notranslate"><span class="pre">invalidFlip(_:)</span></code>を無効なコードにします。<code class="docutils literal notranslate"><span class="pre">invalidFlip(_:)</span></code>を修正する１つの方法は、正方形の特別な事例を<code class="docutils literal notranslate"><span class="pre">FlippedShape</span></code>の実装へと移動することです、それはこの関数に常に<code class="docutils literal notranslate"><span class="pre">FlippedShape</span></code>値を返させます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">struct</span> <span class="nv">FlippedShape</span>&lt;<span class="nv">T</span>: <span class="nc">Shape</span>&gt;: <span class="nc">Shape</span> {
</li><li>    <span class="k">var</span> <span class="nv">shape</span>: <span class="nc">T</span>
</li><li>    <span class="k">func</span> <span class="nv">draw</span>() -&gt; <span class="nc">String</span> {
</li><li>        <span class="k">if</span> <span class="nv">shape</span> <span class="k">is</span> <span class="nc">Square</span> {
</li><li>            <span class="k">return</span> <span class="nv">shape</span>.<span class="nv">draw</span>()
</li><li>        }
</li><li>        <span class="k">let</span> <span class="nv">lines</span> = <span class="nv">shape</span>.<span class="nv">draw</span>().<span class="nv">split</span>(<span class="nv">separator</span>: <span class="s">"\n"</span>)
</li><li>        <span class="k">return</span> <span class="nv">lines</span>.<span class="nv">reversed</span>().<span class="nv">joined</span>(<span class="nv">separator</span>: <span class="s">"\n"</span>)
</li><li>    }
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">The requirement to always return a single type doesn’t prevent you from using generics in an opaque return type. Here’s an example of a function that incorporates its type parameter into the underlying type of the value it returns:</span><!--end_enstr-->
<span class="jpstr">
常に単一の型を返すという要件は、あなたが総称体を不透明戻り型において使う妨げになりません。ここに、ある関数の例があります、それはそれの型パラメータを、それが返す値のその基礎をなす型へと組み入れます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">`repeat`</span>&lt;<span class="nv">T</span>: <span class="nc">Shape</span>&gt;(<span class="nv">shape</span>: <span class="nc">T</span>, <span class="nv">count</span>: <span class="nc">Int</span>) -&gt; <span class="nc">some</span> <span class="nv">Collection</span> {
</li><li>    <span class="k">return</span> <span class="nv">Array</span>&lt;<span class="nc">T</span>&gt;(<span class="nv">repeating</span>: <span class="nv">shape</span>, <span class="nv">count</span>: <span class="nv">count</span>)
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">In this case, the underlying type of the return value varies depending on <code class="docutils literal notranslate"><span class="pre">T</span></code>: Whatever shape is passed it, <code class="docutils literal notranslate"><span class="pre">repeat(shape:count:)</span></code> creates and returns an array of that shape. Nevertheless, the return value always has the same underlying type of <code class="docutils literal notranslate"><span class="pre">[T]</span></code>, so it follows the requirement that functions with opaque return types must return values of only a single type.</span><!--end_enstr-->
<span class="jpstr">
この場合には、戻り値のその基礎をなす型は<code class="docutils literal notranslate"><span class="pre">T</span></code>に依存して変動します：どんな形状がそれに渡されても、<code class="docutils literal notranslate"><span class="pre">repeat(shape:count:)</span></code>はその形状からなるある配列を作成して返します。それにもかかわらず、戻り値は常に同じ基礎をなす型の<code class="docutils literal notranslate"><span class="pre">[T]</span></code>を持ちます、それでそれは、不透明戻り型をもつ関数はもっぱら単一の型の値だけを返さなければならないという要件に従います。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID615">
<h2><span class="enstr">Differences Between Opaque Types and Protocol Types<a class="headerlink" href="#ID615" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
不透明型とプロトコル型の間の違い<a class="headerlink" href="#ID615" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->
</h2>
<p><span class="enstr">Returning an opaque type looks very similar to using a protocol type as the return type of a function, but these two kinds of return type differ in whether they preserve type identity. An opaque type refers to one specific type, although the caller of the function isn’t able to see which type; a protocol type can refer to any type that conforms to the protocol. Generally speaking, protocol types give you more flexibility about the underlying types of the values they store, and opaque types let you make stronger guarantees about those underlying types.</span><!--end_enstr-->
<span class="jpstr">
不透明型を返すことは、プロトコル型を関数の戻り型として使うことと大変よく似て見えます、しかしこれら２つの種類の戻り型は、それらが型同一性を保全するかどうかにおいて異なります。不透明型は１つの特定の型を参照します、とはいえ関数の呼び出し側はどの型か知ることができません；プロトコル型はそのプロトコルに準拠するどんな型でも参照できます。一般的に言えば、プロトコル型はそれらが格納する値の基礎をなす型についてあなたにより柔軟性を与えます、そして不透明型はそれらの基礎をなす型についてあなたにより確固とした保証をさせます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">For example, here’s a version of <code class="docutils literal notranslate"><span class="pre">flip(_:)</span></code> that uses a protocol type as its return type instead of an opaque return type:</span><!--end_enstr-->
<span class="jpstr">
例えば、ここに<code class="docutils literal notranslate"><span class="pre">flip(_:)</span></code>のあるバージョンがあります、それはあるプロトコル型をそれの戻り型として使います、不透明戻り型の代わりに：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">protoFlip</span>&lt;<span class="nv">T</span>: <span class="nc">Shape</span>&gt;(<span class="k">_</span> <span class="nv">shape</span>: <span class="nc">T</span>) -&gt; <span class="nc">Shape</span> {
</li><li>    <span class="k">return</span> <span class="nv">FlippedShape</span>(<span class="nv">shape</span>: <span class="nv">shape</span>)
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">This version of <code class="docutils literal notranslate"><span class="pre">protoFlip(_:)</span></code> has the same body as <code class="docutils literal notranslate"><span class="pre">flip(_:)</span></code>, and it always returns a value of the same type. Unlike <code class="docutils literal notranslate"><span class="pre">flip(_:)</span></code>, the value that <code class="docutils literal notranslate"><span class="pre">protoFlip(_:)</span></code> returns isn’t required to always have the same type—it just has to conform to the <code class="docutils literal notranslate"><span class="pre">Shape</span></code> protocol. Put another way, <code class="docutils literal notranslate"><span class="pre">protoFlip(_:)</span></code> makes a much looser API contract with its caller than <code class="docutils literal notranslate"><span class="pre">flip(_:)</span></code> makes. It reserves the flexibility to return values of multiple types:</span><!--end_enstr-->
<span class="jpstr">
このバージョンの<code class="docutils literal notranslate"><span class="pre">protoFlip(_:)</span></code>は、<code class="docutils literal notranslate"><span class="pre">flip(_:)</span></code>と同じ本文を持ちます、そしてそれは常に同じ型の値を返します。<code class="docutils literal notranslate"><span class="pre">flip(_:)</span></code>とは違い、<code class="docutils literal notranslate"><span class="pre">protoFlip(_:)</span></code>が返す値は、常に同じ型を持つように要求されません — それは単に<code class="docutils literal notranslate"><span class="pre">Shape</span></code>プロトコルに準拠しなければならないだけです。言い換えれば、<code class="docutils literal notranslate"><span class="pre">protoFlip(_:)</span></code>は、それの呼び出し側とずっとゆるいAPI契約をします、<code class="docutils literal notranslate"><span class="pre">flip(_:)</span></code>がするよりも。それは複数の型の値を返す柔軟性を確保します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">protoFlip</span>&lt;<span class="nv">T</span>: <span class="nc">Shape</span>&gt;(<span class="k">_</span> <span class="nv">shape</span>: <span class="nc">T</span>) -&gt; <span class="nc">Shape</span> {
</li><li>    <span class="k">if</span> <span class="nv">shape</span> <span class="k">is</span> <span class="nc">Square</span> {
</li><li>        <span class="k">return</span> <span class="nv">shape</span>
</li><li>    }
</li><li>
</li><li>    <span class="k">return</span> <span class="nv">FlippedShape</span>(<span class="nv">shape</span>: <span class="nv">shape</span>)
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">The revised version of the code returns an instance of <code class="docutils literal notranslate"><span class="pre">Square</span></code> or an instance of <code class="docutils literal notranslate"><span class="pre">FlippedShape</span></code>, depending on what shape is passed in. Two flipped shapes returned by this function might have completely different types. Other valid versions of this function could return values of different types when flipping multiple instances of the same shape. The less specific return type information from <code class="docutils literal notranslate"><span class="pre">protoFlip(_:)</span></code> means that many operations that depend on type information aren’t available on the returned value. For example, it’s not possible to write an <code class="docutils literal notranslate"><span class="pre">==</span></code> operator comparing results returned by this function.</span><!--end_enstr-->
<span class="jpstr">
この改訂版のコードは、<code class="docutils literal notranslate"><span class="pre">Square</span></code>のインスタンスまたは<code class="docutils literal notranslate"><span class="pre">FlippedShape</span></code>のインスタンスを返します、どの形状が渡されるかに依存して。この関数によって返される２つの裏返された形状が、完全に異なる型を持つかもしれません。この関数の他の有効なバージョンそれらは、異なる型の値を返すことが、同じ形状の複数のインスタンスを裏返す時にありえます。<code class="docutils literal notranslate"><span class="pre">protoFlip(_:)</span></code>からの具体性のより少ない戻り型情報は、型情報に依存する多くの演算が、その返された値の上で利用可能でないことを意味します。例えば、この関数によって返される結果を比較する<code class="docutils literal notranslate"><span class="pre">==</span></code>演算子を書くことは可能ではありません。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">let</span> <span class="nv">protoFlippedTriangle</span> = <span class="nv">protoFlip</span>(<span class="nv">smallTriangle</span>)
</li><li><span class="k">let</span> <span class="nv">sameThing</span> = <span class="nv">protoFlip</span>(<span class="nv">smallTriangle</span>)
</li><li><span class="nv">protoFlippedTriangle</span> == <span class="nv">sameThing</span>  <span class="enstr"><span class="c">// Error</span></span><!--end_enstr--><span class="jpstr"><span class="c">（エラー）</span></span><!--end_jpstr--></li></ol></div></div></div>
<p><span class="enstr">The error on the last line of the example occurs for several reasons. The immediate issue is that the <code class="docutils literal notranslate"><span class="pre">Shape</span></code> doesn’t include an <code class="docutils literal notranslate"><span class="pre">==</span></code> operator as part of its protocol requirements. If you try adding one, the next issue you’ll encounter is that the <code class="docutils literal notranslate"><span class="pre">==</span></code> operator needs to know the types of its left-hand and right-hand arguments. This sort of operator usually takes arguments of type <code class="docutils literal notranslate"><span class="pre">Self</span></code>, matching whatever concrete type adopts the protocol, but adding a <code class="docutils literal notranslate"><span class="pre">Self</span></code> requirement to the protocol doesn’t allow for the type erasure that happens when you use the protocol as a type.</span><!--end_enstr-->
<span class="jpstr">
この例の最後の行でのエラーは、いくつかの理由で発生します。当面の問題は、<code class="docutils literal notranslate"><span class="pre">Shape</span></code>がそれのプロトコル要件として<code class="docutils literal notranslate"><span class="pre">==</span></code>演算子を含まないことです。あなたがそれを加えることを試みるならば、あなたがぶつかる次の問題は、<code class="docutils literal notranslate"><span class="pre">==</span></code>演算子はそれの左手および右手の引数の型を知る必要があることです。この種の演算子は通常は、どんな具象型がそのプロトコルを採用しても合う、型<code class="docutils literal notranslate"><span class="pre">Self</span></code>の引数を取ります、しかし<code class="docutils literal notranslate"><span class="pre">Self</span></code>要件をプロトコルに加えることは型消去を想定しません、それはあなたがプロトコルをひとつの型として使う場合に予期せず起こります。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Using a protocol type as the return type for a function gives you the flexibility to return any type that conforms to the protocol. However, the cost of that flexibility is that some operations aren’t possible on the returned values. The example shows how the <code class="docutils literal notranslate"><span class="pre">==</span></code> operator isn’t available—it depends on specific type information that isn’t preserved by using a protocol type.</span><!--end_enstr-->
<span class="jpstr">
プロトコル型を戻り型として関数に使うことは、あなたに、そのプロトコルに準拠するどんな型でも返す柔軟性を与えます。しかしながら、その柔軟性の対価は、いくつかの演算がその返される値の上で可能でないということです。この例は、どのように<code class="docutils literal notranslate"><span class="pre">==</span></code>演算子が利用可能でないか示します — それは具体的な型情報に依存します、それはプロトコル型を使うことでは保全されないものです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Another problem with this approach is that the shape transformations don’t nest. The result of flipping a triangle is a value of type <code class="docutils literal notranslate"><span class="pre">Shape</span></code>, and the <code class="docutils literal notranslate"><span class="pre">protoFlip(_:)</span></code> function takes an argument of some type that conforms to the <code class="docutils literal notranslate"><span class="pre">Shape</span></code> protocol. However, a value of a protocol type doesn’t conform to that protocol; the value returned by <code class="docutils literal notranslate"><span class="pre">protoFlip(_:)</span></code> doesn’t conform to <code class="docutils literal notranslate"><span class="pre">Shape</span></code>. This means code like <code class="docutils literal notranslate"><span class="pre">protoFlip(protoFlip(smallTriange))</span></code> that applies multiple transformations is invalid because the flipped shape isn’t a valid argument to <code class="docutils literal notranslate"><span class="pre">protoFlip(_:)</span></code>.</span><!--end_enstr-->
<span class="jpstr">
この取り組みの別の問題は、形状変換が入れ子にされないことです。三角形を裏返すことの結果は、型<code class="docutils literal notranslate"><span class="pre">Shape</span></code>の値です、そして<code class="docutils literal notranslate"><span class="pre">protoFlip(_:)</span></code>関数は<code class="docutils literal notranslate"><span class="pre">Shape</span></code>プロトコルに準拠する型の引数を取ります。しかしながら、あるプロトコル型からなるある値は、そのプロトコルに準拠しません；<code class="docutils literal notranslate"><span class="pre">protoFlip(_:)</span></code>によって返される値は、<code class="docutils literal notranslate"><span class="pre">Shape</span></code>に準拠しません。これは、複数の変換を適用する<code class="docutils literal notranslate"><span class="pre">protoFlip(protoFlip(smallTriange))</span></code>のようなコードが無効であることを意味します、なぜなら裏返された形状は<code class="docutils literal notranslate"><span class="pre">protoFlip(_:)</span></code>への有効な引数ではないからです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">In contrast, opaque types preserve the identity of the underlying type. Swift can infer associated types, which lets you use an opaque return value in places where a protocol type can’t be used as a return value. For example, here’s a version of the <code class="docutils literal notranslate"><span class="pre">Container</span></code> protocol from <a class="reference internal" href="Generics.html"><span class="doc">Generics</span></a>:</span><!--end_enstr-->
<span class="jpstr">
対照的に、不透明型は基礎をなす型の同一性を保全します。スウィフトは関連型を推論できます、それはあなたに不透明戻り値を、プロトコル型が戻り値として使われることができないところあちこちで使用させます。例えば、ここに<a class="reference internal" href="Generics.html"><span class="doc">総称体</span></a>からの、<code class="docutils literal notranslate"><span class="pre">Container</span></code>プロトコルのあるバージョンがあります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">protocol</span> <span class="nv">Container</span> {
</li><li>    <span class="k">associatedtype</span> <span class="nv">Item</span>
</li><li>    <span class="k">var</span> <span class="nv">count</span>: <span class="nc">Int</span> { <span class="k">get</span> }
</li><li>    <span class="k">subscript</span>(<span class="nv">i</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Item</span> { <span class="k">get</span> }
</li><li>}
</li><li><span class="k">extension</span> <span class="nc">Array</span>: <span class="nc">Container</span> { }
</li></ol></div></div></div>
<p><span class="enstr">You can’t use <code class="docutils literal notranslate"><span class="pre">Container</span></code> as the return type of a function because that protocol has an associated type. You also can’t use it as constraint in a generic return type because there isn’t enough information outside the function body to infer what the generic type needs to be.</span><!--end_enstr-->
<span class="jpstr">
あなたは<code class="docutils literal notranslate"><span class="pre">Container</span></code>を関数の戻り型として使用できません、なぜならそのプロトコルが関連型を持つからです。あなたはまたそれを制約として総称体戻り型において使用できません、なぜならどうあることをその総称体型が必要とするか推論するのに十分な情報が関数本文の外側にないからです。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="c"><span class="enstr">// Error: Protocol with associated types can't be used as a return type.</span><!--end_enstr--><span class="jpstr">（Error: 関連型を持つプロトコルは戻り型として使われることができません。）</span><!--end_jpstr--></span>
</li><li><span class="k">func</span> <span class="nv">makeProtocolContainer</span>&lt;<span class="nv">T</span>&gt;(<span class="nv">item</span>: <span class="nc">T</span>) -&gt; <span class="nc">Container</span> {
</li><li>    <span class="k">return</span> [<span class="nv">item</span>]
</li><li>}
</li><li>
</li><li><span class="c"><span class="enstr">// Error: Not enough information to infer C.</span><!--end_enstr--><span class="jpstr">（Error: Cを推論するための情報が十分でない。）</span><!--end_jpstr--></span>
</li><li><span class="k">func</span> <span class="nv">makeProtocolContainer</span>&lt;<span class="nv">T</span>, <span class="nv">C</span>: <span class="nc">Container</span>&gt;(<span class="nv">item</span>: <span class="nc">T</span>) -&gt; <span class="nc">C</span> {
</li><li>    <span class="k">return</span> [<span class="nv">item</span>]
</li><li>}
</li></ol></div></div></div>
<p><span class="enstr">Using the opaque type <code class="docutils literal notranslate"><span class="pre">some</span> <span class="pre">Container</span></code> as a return type expresses the desired API contract—the function returns a container, but declines to specify the container’s type:</span><!--end_enstr-->
<span class="jpstr">
不透明型<code class="docutils literal notranslate"><span class="pre">some</span> <span class="pre">Container</span></code>を戻り型として使うことは、望まれるAPI契約を表現します — 関数はあるコンテナ（容れ物）を返します、しかしコンテナのもつ型を指定することを辞退します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li><span class="k">func</span> <span class="nv">makeOpaqueContainer</span>&lt;<span class="nv">T</span>&gt;(<span class="nv">item</span>: <span class="nc">T</span>) -&gt; <span class="nc">some</span> <span class="nv">Container</span> {
</li><li>    <span class="k">return</span> [<span class="nv">item</span>]
</li><li>}
</li><li><span class="k">let</span> <span class="nv">opaqueContainer</span> = <span class="nv">makeOpaqueContainer</span>(<span class="nv">item</span>: <span class="m">12</span>)
</li><li><span class="k">let</span> <span class="nv">twelve</span> = <span class="nv">opaqueContainer</span>[<span class="m">0</span>]
</li><li><span class="nv">print</span>(<span class="nv">type</span>(<span class="nv">of</span>: <span class="nv">twelve</span>))
</li><li><span class="c"><span class="enstr">// Prints "Int"</span><!--end_enstr--><span class="jpstr">（「Int」を出力します）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">The type of <code class="docutils literal notranslate"><span class="pre">twelve</span></code> is inferred to be <code class="docutils literal notranslate"><span class="pre">Int</span></code>, which illustrates the fact that type inference works with opaque types. In the implementation of <code class="docutils literal notranslate"><span class="pre">makeOpaqueContainer(item:)</span></code>, the underlying type of the opaque container is <code class="docutils literal notranslate"><span class="pre">[T]</span></code>. In this case, <code class="docutils literal notranslate"><span class="pre">T</span></code> is <code class="docutils literal notranslate"><span class="pre">Int</span></code>, so the return value is an array of integers and the <code class="docutils literal notranslate"><span class="pre">Item</span></code> associated type is inferred to be <code class="docutils literal notranslate"><span class="pre">Int</span></code>. The subscript on <code class="docutils literal notranslate"><span class="pre">Container</span></code> returns <code class="docutils literal notranslate"><span class="pre">Item</span></code>, which means that the type of <code class="docutils literal notranslate"><span class="pre">twelve</span></code> is also inferred to be <code class="docutils literal notranslate"><span class="pre">Int</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">twelve</span></code>の型は、<code class="docutils literal notranslate"><span class="pre">Int</span></code>であると推論されます、それは型推論が不透明型を扱うという事実を例示します。<code class="docutils literal notranslate"><span class="pre">makeOpaqueContainer(item:)</span></code>の実装において、不透明コンテナの基礎をなす型は、<code class="docutils literal notranslate"><span class="pre">[T]</span></code>です。この場合に、<code class="docutils literal notranslate"><span class="pre">T</span></code>は<code class="docutils literal notranslate"><span class="pre">Int</span></code>です、それで戻り値は整数からなるある配列です、そして<code class="docutils literal notranslate"><span class="pre">Item</span></code>関連型は<code class="docutils literal notranslate"><span class="pre">Int</span></code>と推論されます。<code class="docutils literal notranslate"><span class="pre">Container</span></code>上での添え字は、 <code class="docutils literal notranslate"><span class="pre">Item</span></code>を返します、それは<code class="docutils literal notranslate"><span class="pre">twelve</span></code>の型もまた<code class="docutils literal notranslate"><span class="pre">Int</span></code>に推論されることを意味します。
</span><!--end_jpstr-->
</p>
</div>
</div>


    </article>
    <div class="next_previous">
        <p class="previous"><a href="Generics.html"><span class="enstr">Generics</span><!--end_enstr-->
<span class="jpstr">
総称体
</span><!--end_jpstr-->
</a></p>
        <p class="next"><a href="AutomaticReferenceCounting.html"><span class="enstr">Automatic Reference Counting</span><!--end_enstr-->
<span class="jpstr">
自動参照カウント
</span><!--end_jpstr-->
</a></p>
    </div>
    <div class="admonition-beta admonition">
        <p class="first admonition-title">Beta Software</p>
        <p>
          <span class="enstr">This documentation contains preliminary information about an API or technology in development. This information is subject to change, and software implemented according to this documentation should be tested with final operating system software.</span><!--end_enstr-->
<span class="jpstr">
この文書は、開発でのテクノロジーまたはAPIのための事前の情報を含んでいます。この情報は変更される場合があり、この文書に沿って実装されるソフトウェアは最終的なオペレーティングシステム・ソフトウェアでテストされなければなりません。
</span><!--end_jpstr-->

        </p>
        <p class="last"><a class="reference external" href="https://developer.apple.com/support/beta-software/">Learn more about using Apple's beta software</a></p>
    </div>
</main>


<footer role="contentinfo">
  <aside>
    <a href="//swift.org/atom.xml" title="Subscribe to Site Updates"><i class="feed">Subscribe</i></a>
    <a href="https://twitter.com/swiftlang" rel="nofollow" title="Follow @SwiftLang on Twitter"><i class="twitter">Twitter</i></a>
  </aside>

  <p class="copyright">Copyright © 2021 Apple Inc. All rights reserved.</p>
  <p class="trademark">Swift and the Swift logo are trademarks of Apple Inc.</p>
  <p class="privacy">
    <a href="//www.apple.com/privacy/privacy-policy/">Privacy Policy</a>
    <a href="//www.apple.com/legal/privacy/en-ww/cookies/">Cookies</a>
  </p>
</footer>
<div id="jump_to_overlay"></div>
<script src="../static/javascripts/application.js"></script>
  </body>
</html>