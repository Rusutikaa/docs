<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="author" content="Apple Inc.">
    <meta name="viewport" content="width=device-width initial-scale=1">
    
    <title>Advanced Operators — The Swift Programming Language (Swift 5.6)</title>
    
    <link rel="license" href="/LICENSE.txt">
    <link rel="stylesheet" media="all" href="../static/stylesheets/application.css">
    <link rel="stylesheet" media="all" href="../static/stylesheets/tspl.css">
    <link rel="shortcut icon" sizes="16x16 24x24 32x32 48x48 64x64" type="image/vnd.microsoft.icon" href="/favicon.ico">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
    <link rel="mask-icon" href="/assets/images/icon-swift.svg" color="#F05339"> 
  </head>
  <body>


<nav role="navigation">
    <header role="banner">
      <h1 id="logo">
        <a href="https://swift.org/" title="Swift.org" role="img" aria-label="Swift.org">
          Swift.org
        </a>
      </h1>
    </header>

    <div id="menu-toggle" class="menu-toggle open"></div>

    <h2>The Swift Programming Language<div>Swift 5.6</div>
</h2>

    <ul>
    <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html"><span class="enstr">Welcome to Swift</span><!--end_enstr-->
<span class="jpstr">
スウィフトにようこそ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1 current">
<a class="reference internal" href="TheBasics.html"><span class="enstr">Language Guide</span><!--end_enstr-->
<span class="jpstr">
言語ガイド
</span><!--end_jpstr-->
</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="TheBasics.html"><span class="enstr">The Basics</span><!--end_enstr-->
<span class="jpstr">
基本
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="BasicOperators.html"><span class="enstr">Basic Operators</span><!--end_enstr-->
<span class="jpstr">
基本の演算子
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="StringsAndCharacters.html"><span class="enstr">Strings and Characters</span><!--end_enstr-->
<span class="jpstr">
文字列と文字
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="CollectionTypes.html"><span class="enstr">Collection Types</span><!--end_enstr-->
<span class="jpstr">
コレクション型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ControlFlow.html"><span class="enstr">Control Flow</span><!--end_enstr-->
<span class="jpstr">
制御の流れ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Functions.html"><span class="enstr">Functions</span><!--end_enstr-->
<span class="jpstr">
関数
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Closures.html"><span class="enstr">Closures</span><!--end_enstr-->
<span class="jpstr">
クロージャ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Enumerations.html"><span class="enstr">Enumerations</span><!--end_enstr-->
<span class="jpstr">
列挙
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ClassesAndStructures.html"><span class="enstr">Structures and Classes</span><!--end_enstr-->
<span class="jpstr">
構造体とクラス
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Properties.html"><span class="enstr">Properties</span><!--end_enstr-->
<span class="jpstr">
プロパティ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Methods.html"><span class="enstr">Methods</span><!--end_enstr-->
<span class="jpstr">
メソッド
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Subscripts.html"><span class="enstr">Subscripts</span><!--end_enstr-->
<span class="jpstr">
添え字
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Inheritance.html"><span class="enstr">Inheritance</span><!--end_enstr-->
<span class="jpstr">
継承
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Initialization.html"><span class="enstr">Initialization</span><!--end_enstr-->
<span class="jpstr">
初期化
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Deinitialization.html"><span class="enstr">Deinitialization</span><!--end_enstr-->
<span class="jpstr">
デイニシャライズ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="OptionalChaining.html"><span class="enstr">Optional Chaining</span><!--end_enstr-->
<span class="jpstr">
オプショナル連鎖
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ErrorHandling.html"><span class="enstr">Error Handling</span><!--end_enstr-->
<span class="jpstr">
エラーの処理
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html"><span class="enstr">Concurrency</span><!--end_enstr-->
<span class="jpstr">
並行性
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="TypeCasting.html"><span class="enstr">Type Casting</span><!--end_enstr-->
<span class="jpstr">
型キャスト
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="NestedTypes.html"><span class="enstr">Nested Types</span><!--end_enstr-->
<span class="jpstr">
入れ子にされた型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Extensions.html"><span class="enstr">Extensions</span><!--end_enstr-->
<span class="jpstr">
拡張
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Protocols.html"><span class="enstr">Protocols</span><!--end_enstr-->
<span class="jpstr">
プロトコル
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Generics.html"><span class="enstr">Generics</span><!--end_enstr-->
<span class="jpstr">
総称体
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="OpaqueTypes.html"><span class="enstr">Opaque Types</span><!--end_enstr-->
<span class="jpstr">
不透明型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AutomaticReferenceCounting.html"><span class="enstr">Automatic Reference Counting</span><!--end_enstr-->
<span class="jpstr">
自動参照カウント
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="MemorySafety.html"><span class="enstr">Memory Safety</span><!--end_enstr-->
<span class="jpstr">
メモリ安全
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AccessControl.html"><span class="enstr">Access Control</span><!--end_enstr-->
<span class="jpstr">
アクセス制御
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#"><span class="enstr">Advanced Operators</span><!--end_enstr-->
<span class="jpstr">
先進の演算子
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ReferenceManual/AboutTheLanguageReference.html"><span class="enstr">Language Reference</span><!--end_enstr-->
<span class="jpstr">
言語リファレンス
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1"><a class="reference internal" href="../RevisionHistory/RevisionHistory.html"><span class="enstr">Revision History</span><!--end_enstr-->
<span class="jpstr">
改訂履歴
</span><!--end_jpstr-->
</a></li>
</ul>

    <li class="toctree-l1 return"><a class="reference internal" href="../../../index.html">← Go to Index</a></li>
    </ul>
</nav>




<main role="main">
    <article class="page">
        <menu id="bashful" type="toolbar">
          <div class="inner">
            <menuitem id="jump_to" class="menu-bar-item closed">
            <span id="jump_to_toggle">On This Page</span>
            <div class="chevron">
                <div class="chevy chevron-left"></div>
                <div class="chevy chevron-right"></div>
            </div>
            <menu type="list" class="details">
<ul>
<li>
<a class="reference internal" href="#"><span class="enstr">Advanced Operators</span><!--end_enstr-->
<span class="jpstr">
先進の演算子
</span><!--end_jpstr-->
</a><ul>
<li>
<a class="reference internal" href="#ID29"><span class="enstr">Bitwise Operators</span><!--end_enstr-->
<span class="jpstr">
ビット単位演算子
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID30"><span class="enstr">Bitwise NOT Operator</span><!--end_enstr-->
<span class="jpstr">
ビット単位の論理否定演算子
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID31"><span class="enstr">Bitwise AND Operator</span><!--end_enstr-->
<span class="jpstr">
ビット単位の論理積演算子
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID32"><span class="enstr">Bitwise OR Operator</span><!--end_enstr-->
<span class="jpstr">
ビット単位の論理和演算子
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID33"><span class="enstr">Bitwise XOR Operator</span><!--end_enstr-->
<span class="jpstr">
ビット単位の排他的論理和演算子
</span><!--end_jpstr-->
</a></li>
<li>
<a class="reference internal" href="#ID34"><span class="enstr">Bitwise Left and Right Shift Operators</span><!--end_enstr-->
<span class="jpstr">
ビット単位の左および右シフト演算子
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID35"><span class="enstr">Shifting Behavior for Unsigned Integers</span><!--end_enstr-->
<span class="jpstr">
符号なし整数のためのシフト挙動
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID36"><span class="enstr">Shifting Behavior for Signed Integers</span><!--end_enstr-->
<span class="jpstr">
符号つき整数のためのシフト挙動
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a class="reference internal" href="#ID37"><span class="enstr">Overflow Operators</span><!--end_enstr-->
<span class="jpstr">
オーバフロー演算子
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID38"><span class="enstr">Value Overflow</span><!--end_enstr-->
<span class="jpstr">
値オーバフロー
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID41"><span class="enstr">Precedence and Associativity</span><!--end_enstr-->
<span class="jpstr">
優先順位と結合性
</span><!--end_jpstr-->
</a></li>
<li>
<a class="reference internal" href="#ID42"><span class="enstr">Operator Methods</span><!--end_enstr-->
<span class="jpstr">
演算子メソッド
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID43"><span class="enstr">Prefix and Postfix Operators</span><!--end_enstr-->
<span class="jpstr">
接頭辞と接尾辞演算子
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID44"><span class="enstr">Compound Assignment Operators</span><!--end_enstr-->
<span class="jpstr">
複合代入演算子
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID45"><span class="enstr">Equivalence Operators</span><!--end_enstr-->
<span class="jpstr">
等価演算子
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li>
<a class="reference internal" href="#ID46"><span class="enstr">Custom Operators</span><!--end_enstr-->
<span class="jpstr">
あつらえの演算子
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID47"><span class="enstr">Precedence for Custom Infix Operators</span><!--end_enstr-->
<span class="jpstr">
あつらえの接中辞演算子の優先順位
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID630"><span class="enstr">Result Builders</span><!--end_enstr-->
<span class="jpstr">
リザルトビルダー
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
</ul>

            
                </menu>
            </menuitem>
          </div>
        </menu>

        
  <div class="section" id="advanced-operators">
<h1><span class="enstr">Advanced Operators<a class="headerlink" href="#advanced-operators" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
先進の演算子<a class="headerlink" href="#advanced-operators" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h1>
<p><span class="enstr">In addition to the operators described in <a class="reference internal" href="BasicOperators.html"><span class="doc">Basic Operators</span></a>, Swift provides several advanced operators that perform more complex value manipulation. These include all of the bitwise and bit shifting operators you will be familiar with from C and Objective-C.</span><!--end_enstr-->
<span class="jpstr">
<a class="reference internal" href="BasicOperators.html"><span class="doc">基本の演算子</span></a>で記述される演算子に加えて、スウィフトはより複雑な値操作を実行するいくつかの先進の演算子を提供します。これらは、あなたがCとObjective-Cからお馴染みの、ビット単位およびビットシフト演算子の全てを含んでいます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Unlike arithmetic operators in C, arithmetic operators in Swift don’t overflow by default. Overflow behavior is trapped and reported as an error. To opt in to overflow behavior, use Swift’s second set of arithmetic operators that overflow by default, such as the overflow addition operator (<code class="docutils literal notranslate"><span class="pre">&amp;+</span></code>). All of these overflow operators begin with an ampersand (<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>).</span><!--end_enstr-->
<span class="jpstr">
Cでの算術演算子と違って、スウィフトの算術演算子は、初期状態ではオーバフローしません。オーバフロー挙動は、エラーとして捕まえられて報告されます。オーバフロー挙動を選ぶために、初期状態でオーバフローするスウィフトの算術演算子の第二集合を使ってください、例えばオーバフロー加算演算子（<code class="docutils literal notranslate"><span class="pre">&amp;+</span></code>）など。これらのオーバフロー演算子の全ては、アンパサンド（<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>）から始まります。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">When you define your own structures, classes, and enumerations, it can be useful to provide your own implementations of the standard Swift operators for these custom types. Swift makes it easy to provide tailored implementations of these operators and to determine exactly what their behavior should be for each type you create.</span><!--end_enstr-->
<span class="jpstr">
あなたがあなた自身の構造体、クラス、そして列挙を定義するとき、標準のスウィフト演算子のあなた自身の実施をそれらあつらえの型のために提供することは役に立つことがありえます。スウィフトは、それら演算子の注文仕立ての実装を提供することについて、そしてそれらの挙動があなたがつくる各型のために正確にどういったものでなければならないかについて決定することを簡単にします。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You’re not limited to the predefined operators. Swift gives you the freedom to define your own custom infix, prefix, postfix, and assignment operators, with custom precedence and associativity values. These operators can be used and adopted in your code like any of the predefined operators, and you can even extend existing types to support the custom operators you define.</span><!--end_enstr-->
<span class="jpstr">
あなたは、あらかじめ定義された演算子に制限されていません。スウィフトは、あなたに、特注の優先順位と結合性値で、あなた自身のあつらえの接中辞、接頭辞、接尾辞、そして代入演算子を定義する自由を与えます。これらの演算子は、あらかじめ定義された演算子のどれとも同じように、使用されることができ、あなたのコードにおいて取り入れられることができます、そして、あなたはあなたが定義するカスタム演算子をサポートするように既存の型を拡張することさえ可能です。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID29">
<h2><span class="enstr">Bitwise Operators<a class="headerlink" href="#ID29" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
ビット単位演算子<a class="headerlink" href="#ID29" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr"><em>Bitwise operators</em> enable you to manipulate the individual raw data bits within a data structure. They’re often used in low-level programming, such as graphics programming and device driver creation. Bitwise operators can also be useful when you work with raw data from external sources, such as encoding and decoding data for communication over a custom protocol.</span><!--end_enstr-->
<span class="jpstr">
<em>ビット単位演算子</em>は、あなたにあるデータ構造内の個々の生のデータ・ビットを操作することを可能にします。それらが、低階層のプログラミング、例えばグラフィックス・プログラミングやデバイスドライバー作成において、しばしば使われます。ビット単位演算子はまた、あなたが外部のソースからの生のデータを扱うとき、役に立つことがありえます、例えば、あつらえのプロトコルを越えて通信するためのデータの符号化や復号など。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Swift supports all of the bitwise operators found in C, as described below.</span><!--end_enstr-->
<span class="jpstr">
スウィフトは、下記のように、Cで見つけられるビット単位演算子の全てをサポートします。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID30">
<h3><span class="enstr">Bitwise NOT Operator<a class="headerlink" href="#ID30" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
ビット単位の論理否定演算子<a class="headerlink" href="#ID30" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">The <em>bitwise NOT operator</em> (<code class="docutils literal notranslate"><span class="pre">~</span></code>) inverts all bits in a number:</span><!--end_enstr-->
<span class="jpstr">
<em>ビット単位の論理否定演算子</em>（<code class="docutils literal notranslate"><span class="pre">~</span></code>）は、ある数の中の全てのビットを逆にします：
</span><!--end_jpstr-->
</p>
<img alt="../_images/bitwiseNOT_2x.png" class="align-center" src="../images/bitwiseNOT_2x.png" style="width: 330px;">
<p><span class="enstr">The bitwise NOT operator is a prefix operator, and appears immediately before the value it operates on, without any white space:</span><!--end_enstr-->
<span class="jpstr">
ビット単位の論理否定演算子は、接頭辞演算子で、少しの空白なしで、それが作用する値の直前に現れまます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">initialBits</span>: <span class="nc">UInt8</span> = <span class="m">0b00001111</span>
</li>
<li>
<span class="k">let</span> <span class="nv">invertedBits</span> = ~<span class="nv">initialBits</span>  <span class="enstr"><span class="c">// equals 11110000</span></span><!--end_enstr--><span class="jpstr"><span class="c">（11110000に等しい）</span></span><!--end_jpstr--></li>
</ol></div></div></div>
<p><span class="enstr"><code class="docutils literal notranslate"><span class="pre">UInt8</span></code> integers have eight bits and can store any value between <code class="docutils literal notranslate"><span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">255</span></code>. This example initializes a <code class="docutils literal notranslate"><span class="pre">UInt8</span></code> integer with the binary value <code class="docutils literal notranslate"><span class="pre">00001111</span></code>, which has its first four bits set to <code class="docutils literal notranslate"><span class="pre">0</span></code>, and its second four bits set to <code class="docutils literal notranslate"><span class="pre">1</span></code>. This is equivalent to a decimal value of <code class="docutils literal notranslate"><span class="pre">15</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">UInt8</span></code>整数は、８ビットを持ち、<code class="docutils literal notranslate"><span class="pre">0</span></code>と<code class="docutils literal notranslate"><span class="pre">255</span></code>の間でのどんな値でも格納することができます。この例は、<code class="docutils literal notranslate"><span class="pre">UInt8</span></code>整数を２進数の値<code class="docutils literal notranslate"><span class="pre">00001111</span></code>で初期化します、それは、その最初の４つのビットを<code class="docutils literal notranslate"><span class="pre">0</span></code>に設定して、次の４つのビットを<code class="docutils literal notranslate"><span class="pre">1</span></code>に設定します。これは、10進の値の<code class="docutils literal notranslate"><span class="pre">15</span></code>に等しいです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The bitwise NOT operator is then used to create a new constant called <code class="docutils literal notranslate"><span class="pre">invertedBits</span></code>, which is equal to <code class="docutils literal notranslate"><span class="pre">initialBits</span></code>, but with all of the bits inverted. Zeros become ones, and ones become zeros. The value of <code class="docutils literal notranslate"><span class="pre">invertedBits</span></code> is <code class="docutils literal notranslate"><span class="pre">11110000</span></code>, which is equal to an unsigned decimal value of <code class="docutils literal notranslate"><span class="pre">240</span></code>.</span><!--end_enstr-->
<span class="jpstr">
ビット単位の論理否定演算子は、それから<code class="docutils literal notranslate"><span class="pre">invertedBits</span></code>と呼ばれる新しい定数をつくるために使われます、それは、<code class="docutils literal notranslate"><span class="pre">initialBits</span></code>と等しいです、しかし全てのビットは逆にされます。ゼロは１になります、そして１はゼロになります。<code class="docutils literal notranslate"><span class="pre">invertedBits</span></code>の値は<code class="docutils literal notranslate"><span class="pre">11110000</span></code>です、それは、符号なし10進の値の<code class="docutils literal notranslate"><span class="pre">240</span></code>と等しいです。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID31">
<h3><span class="enstr">Bitwise AND Operator<a class="headerlink" href="#ID31" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
ビット単位の論理積演算子<a class="headerlink" href="#ID31" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">The <em>bitwise AND operator</em> (<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>) combines the bits of two numbers. It returns a new number whose bits are set to <code class="docutils literal notranslate"><span class="pre">1</span></code> only if the bits were equal to <code class="docutils literal notranslate"><span class="pre">1</span></code> in <em>both</em> input numbers:</span><!--end_enstr-->
<span class="jpstr">
<em>ビット単位の論理積演算子</em>（<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>）は、２つの数のビットを結合します。それはある新しい数を返します、それのビットは<em>両方の</em>入力数においてビットが<code class="docutils literal notranslate"><span class="pre">1</span></code>と等しかった場合にだけ<code class="docutils literal notranslate"><span class="pre">1</span></code>に設定されます：
</span><!--end_jpstr-->
</p>
<img alt="../_images/bitwiseAND_2x.png" class="align-center" src="../images/bitwiseAND_2x.png" style="width: 330px;">
<p><span class="enstr">In the example below, the values of <code class="docutils literal notranslate"><span class="pre">firstSixBits</span></code> and <code class="docutils literal notranslate"><span class="pre">lastSixBits</span></code> both have four middle bits equal to <code class="docutils literal notranslate"><span class="pre">1</span></code>. The bitwise AND operator combines them to make the number <code class="docutils literal notranslate"><span class="pre">00111100</span></code>, which is equal to an unsigned decimal value of <code class="docutils literal notranslate"><span class="pre">60</span></code>:</span><!--end_enstr-->
<span class="jpstr">
下記の例で、<code class="docutils literal notranslate"><span class="pre">firstSixBits</span></code>と<code class="docutils literal notranslate"><span class="pre">lastSixBits</span></code>の値は、<code class="docutils literal notranslate"><span class="pre">1</span></code>と等しい４つの中間のビットを両方とも持ちます。ビット単位の論理積演算子は、それらを結合して、数<code class="docutils literal notranslate"><span class="pre">00111100</span></code>をつくります、それは、符号なしの10進数の<code class="docutils literal notranslate"><span class="pre">60</span></code>と等しいです：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">firstSixBits</span>: <span class="nc">UInt8</span> = <span class="m">0b11111100</span>
</li>
<li>
<span class="k">let</span> <span class="nv">lastSixBits</span>: <span class="nc">UInt8</span>  = <span class="m">0b00111111</span>
</li>
<li>
<span class="k">let</span> <span class="nv">middleFourBits</span> = <span class="nv">firstSixBits</span> &amp; <span class="nv">lastSixBits</span>  <span class="enstr"><span class="c">// equals 00111100</span></span><!--end_enstr--><span class="jpstr"><span class="c">（00111100に等しい）</span></span><!--end_jpstr--></li>
</ol></div></div></div>
</div>
<div class="section" id="ID32">
<h3><span class="enstr">Bitwise OR Operator<a class="headerlink" href="#ID32" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
ビット単位の論理和演算子<a class="headerlink" href="#ID32" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">The <em>bitwise OR operator</em> (<code class="docutils literal notranslate"><span class="pre">|</span></code>) compares the bits of two numbers. The operator returns a new number whose bits are set to <code class="docutils literal notranslate"><span class="pre">1</span></code> if the bits are equal to <code class="docutils literal notranslate"><span class="pre">1</span></code> in <em>either</em> input number:</span><!--end_enstr-->
<span class="jpstr">
<em>ビット単位</em>の論理和演算子（<code class="docutils literal notranslate"><span class="pre">|</span></code>）は、２つの数のビットを比較します。この演算子は、<em>どちらかの</em>入力数においてビットが<code class="docutils literal notranslate"><span class="pre">1</span></code>と等しいならばビットが<code class="docutils literal notranslate"><span class="pre">1</span></code>に設定される、ある新しい数を返します：
</span><!--end_jpstr-->
</p>
<img alt="../_images/bitwiseOR_2x.png" class="align-center" src="../images/bitwiseOR_2x.png" style="width: 330px;">
<p><span class="enstr">In the example below, the values of <code class="docutils literal notranslate"><span class="pre">someBits</span></code> and <code class="docutils literal notranslate"><span class="pre">moreBits</span></code> have different bits set to <code class="docutils literal notranslate"><span class="pre">1</span></code>. The bitwise OR operator combines them to make the number <code class="docutils literal notranslate"><span class="pre">11111110</span></code>, which equals an unsigned decimal of <code class="docutils literal notranslate"><span class="pre">254</span></code>:</span><!--end_enstr-->
<span class="jpstr">
下記の例で、<code class="docutils literal notranslate"><span class="pre">someBits</span></code>と<code class="docutils literal notranslate"><span class="pre">moreBits</span></code>の値は、<code class="docutils literal notranslate"><span class="pre">1</span></code>に設定される異なるビットを持ちます。ビット単位の論理和演算子は、それらを結合して、数<code class="docutils literal notranslate"><span class="pre">11111110</span></code>を作ります、それは、符号なしの10進数の<code class="docutils literal notranslate"><span class="pre">254</span></code>と等しいです：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">someBits</span>: <span class="nc">UInt8</span> = <span class="m">0b10110010</span>
</li>
<li>
<span class="k">let</span> <span class="nv">moreBits</span>: <span class="nc">UInt8</span> = <span class="m">0b01011110</span>
</li>
<li>
<span class="k">let</span> <span class="nv">combinedbits</span> = <span class="nv">someBits</span> | <span class="nv">moreBits</span>  <span class="enstr"><span class="c">// equals 11111110</span></span><!--end_enstr--><span class="jpstr"><span class="c">（11111110に等しい）</span></span><!--end_jpstr--></li>
</ol></div></div></div>
</div>
<div class="section" id="ID33">
<h3><span class="enstr">Bitwise XOR Operator<a class="headerlink" href="#ID33" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
ビット単位の排他的論理和演算子<a class="headerlink" href="#ID33" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">The <em>bitwise XOR operator</em>, or “exclusive OR operator” (<code class="docutils literal notranslate"><span class="pre">^</span></code>), compares the bits of two numbers. The operator returns a new number whose bits are set to <code class="docutils literal notranslate"><span class="pre">1</span></code> where the input bits are different and are set to <code class="docutils literal notranslate"><span class="pre">0</span></code> where the input bits are the same:</span><!--end_enstr-->
<span class="jpstr">
<em>ビット単位の排他的論理和（XOR）演算子</em>、あるいは「排他的論理和演算子」（<code class="docutils literal notranslate"><span class="pre">^</span></code>）は、２つの数のビットを比較します。この演算子は、入力ビットそれらが異なっている所で<code class="docutils literal notranslate"><span class="pre">1</span></code>に設定され、入力ビットそれらが同じである所で<code class="docutils literal notranslate"><span class="pre">0</span></code>に設定される、ある新しい数を返します：
</span><!--end_jpstr-->
</p>
<img alt="../_images/bitwiseXOR_2x.png" class="align-center" src="../images/bitwiseXOR_2x.png" style="width: 330px;">
<p><span class="enstr">In the example below, the values of <code class="docutils literal notranslate"><span class="pre">firstBits</span></code> and <code class="docutils literal notranslate"><span class="pre">otherBits</span></code> each have a bit set to <code class="docutils literal notranslate"><span class="pre">1</span></code> in a location that the other does not. The bitwise XOR operator sets both of these bits to <code class="docutils literal notranslate"><span class="pre">1</span></code> in its output value. All of the other bits in <code class="docutils literal notranslate"><span class="pre">firstBits</span></code> and <code class="docutils literal notranslate"><span class="pre">otherBits</span></code> match and are set to <code class="docutils literal notranslate"><span class="pre">0</span></code> in the output value:</span><!--end_enstr-->
<span class="jpstr">
下記の例で、<code class="docutils literal notranslate"><span class="pre">firstBits</span></code>と<code class="docutils literal notranslate"><span class="pre">otherBits</span></code>それぞれの値は、他のものがそうでない場所で、ビットを<code class="docutils literal notranslate"><span class="pre">1</span></code>に設定されます。ビット単位の排他的論理和演算子は、これらのビットの両方ともその出力値において<code class="docutils literal notranslate"><span class="pre">1</span></code>に設定します。<code class="docutils literal notranslate"><span class="pre">firstBits</span></code>と<code class="docutils literal notranslate"><span class="pre">otherBits</span></code>での他の全てのビットは一致していて、出力値において<code class="docutils literal notranslate"><span class="pre">0</span></code>に設定されます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">firstBits</span>: <span class="nc">UInt8</span> = <span class="m">0b00010100</span>
</li>
<li>
<span class="k">let</span> <span class="nv">otherBits</span>: <span class="nc">UInt8</span> = <span class="m">0b00000101</span>
</li>
<li>
<span class="k">let</span> <span class="nv">outputBits</span> = <span class="nv">firstBits</span> ^ <span class="nv">otherBits</span>  <span class="enstr"><span class="c">// equals 00010001</span></span><!--end_enstr--><span class="jpstr"><span class="c">（00010001に等しい）</span></span><!--end_jpstr--></li>
</ol></div></div></div>
</div>
<div class="section" id="ID34">
<h3><span class="enstr">Bitwise Left and Right Shift Operators<a class="headerlink" href="#ID34" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
ビット単位の左および右シフト演算子<a class="headerlink" href="#ID34" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">The <em>bitwise left shift operator</em> (<code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>) and <em>bitwise right shift operator</em> (<code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>) move all bits in a number to the left or the right by a certain number of places, according to the rules defined below.</span><!--end_enstr-->
<span class="jpstr">
<em>ビット単位の左シフト演算子</em>（<code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>）と<em>ビット単位の右シフト演算子</em>（<code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>）は、下で定義される規則に従ってある数の中の全てのビットを左または右に特定の桁数だけ移動します（シフト：移す、ずらす）。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Bitwise left and right shifts have the effect of multiplying or dividing an integer by a factor of two. Shifting an integer’s bits to the left by one position doubles its value, whereas shifting it to the right by one position halves its value.</span><!--end_enstr-->
<span class="jpstr">
ビット単位の左または右シフトは、２の因数によって、ある整数を掛けるまたは割る効果を持ちます。整数のビットを位置１つだけ左へ移すことはその値を２倍にします、一方それを位置１つだけ右へ移すことはその値を半分にします。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID35">
<h4><span class="enstr">Shifting Behavior for Unsigned Integers<a class="headerlink" href="#ID35" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
符号なし整数のためのシフト挙動<a class="headerlink" href="#ID35" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h4>
<p><span class="enstr">The bit-shifting behavior for unsigned integers is as follows:</span><!--end_enstr-->
<span class="jpstr">
符号なし整数のためのビットシフト挙動は、次の通りです：
</span><!--end_jpstr-->
</p>
<ol class="arabic simple">
<li><span class="enstr">Existing bits are moved to the left or right by the requested number of places.</span><!--end_enstr-->
<span class="jpstr">
既存のビットは、左または右へ要請された桁数だけ動かされます。
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Any bits that are moved beyond the bounds of the integer’s storage are discarded.</span><!--end_enstr-->
<span class="jpstr">
整数の格納量の境界を越えて動かされるあらゆるビットは、捨てられます。
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Zeros are inserted in the spaces left behind after the original bits are moved to the left or right.</span><!--end_enstr-->
<span class="jpstr">
元のビットが左または右へ移動した後に残される空きに、ゼロが差し込まれます。
</span><!--end_jpstr-->
</li>
</ol>
<p><span class="enstr">This approach is known as a <em>logical shift</em>.</span><!--end_enstr-->
<span class="jpstr">
このやり方は、<em>論理シフト</em>として知られています。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The illustration below shows the results of <code class="docutils literal notranslate"><span class="pre">11111111</span> <span class="pre">&lt;&lt;</span> <span class="pre">1</span></code> (which is <code class="docutils literal notranslate"><span class="pre">11111111</span></code> shifted to the left by <code class="docutils literal notranslate"><span class="pre">1</span></code> place), and <code class="docutils literal notranslate"><span class="pre">11111111</span> <span class="pre">&gt;&gt;</span> <span class="pre">1</span></code> (which is <code class="docutils literal notranslate"><span class="pre">11111111</span></code> shifted to the right by <code class="docutils literal notranslate"><span class="pre">1</span></code> place). Blue numbers are shifted, gray numbers are discarded, and orange zeros are inserted:</span><!--end_enstr-->
<span class="jpstr">
下のイラストは、<code class="docutils literal notranslate"><span class="pre">11111111</span> <span class="pre">&lt;&lt;</span> <span class="pre">1</span></code>（それは、<code class="docutils literal notranslate"><span class="pre">1</span></code>桁だけ左へシフトされる<code class="docutils literal notranslate"><span class="pre">11111111</span></code>です）、そして<code class="docutils literal notranslate"><span class="pre">11111111</span> <span class="pre">&gt;&gt;</span> <span class="pre">1</span></code>（それは、<code class="docutils literal notranslate"><span class="pre">1</span></code>桁だけ右へシフトされる<code class="docutils literal notranslate"><span class="pre">11111111</span></code>です）の結果を示します。青色の数はシフトされます、灰色の数は捨てられます、そしてオレンジ色のゼロが差し込まれます：
</span><!--end_jpstr-->
</p>
<img alt="../_images/bitshiftUnsigned_2x.png" class="align-center" src="../images/bitshiftUnsigned_2x.png" style="width: 541px;">
<p><span class="enstr">Here’s how bit shifting looks in Swift code:</span><!--end_enstr-->
<span class="jpstr">
ビットシフトがスウィフトコードにおいてどのように見えるかは、ここにあります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">shiftBits</span>: <span class="nc">UInt8</span> = <span class="m">4</span>   <span class="enstr"><span class="c">// 00000100 in binary</span></span><!--end_enstr--><span class="jpstr"><span class="c">（２進数での00000100）</span></span><!--end_jpstr--></li>
<li>
<span class="nv">shiftBits</span> &lt;&lt; <span class="m">1</span>             <span class="c">// 00001000</span>
</li>
<li>
<span class="nv">shiftBits</span> &lt;&lt; <span class="m">2</span>             <span class="c">// 00010000</span>
</li>
<li>
<span class="nv">shiftBits</span> &lt;&lt; <span class="m">5</span>             <span class="c">// 10000000</span>
</li>
<li>
<span class="nv">shiftBits</span> &lt;&lt; <span class="m">6</span>             <span class="c">// 00000000</span>
</li>
<li>
<span class="nv">shiftBits</span> &gt;&gt; <span class="m">2</span>             <span class="c">// 00000001</span>
</li>
</ol></div></div></div>
<p><span class="enstr">You can use bit shifting to encode and decode values within other data types:</span><!--end_enstr-->
<span class="jpstr">
あなたは、他のデータ型内の値を符号化したり復号するために、ビットシフトを使うことができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">pink</span>: <span class="nc">UInt32</span> = <span class="m">0xCC6699</span>
</li>
<li>
<span class="k">let</span> <span class="nv">redComponent</span> = (<span class="nv">pink</span> &amp; <span class="m">0xFF0000</span>) &gt;&gt; <span class="m">16</span>    <span class="enstr"><span class="c">// redComponent is 0xCC, or 204</span></span><!--end_enstr--><span class="jpstr"><span class="c">（redComponent は 0xCC または 204 です）</span></span><!--end_jpstr--></li>
<li>
<span class="k">let</span> <span class="nv">greenComponent</span> = (<span class="nv">pink</span> &amp; <span class="m">0x00FF00</span>) &gt;&gt; <span class="m">8</span>   <span class="enstr"><span class="c">// greenComponent is 0x66, or 102</span></span><!--end_enstr--><span class="jpstr"><span class="c">（greenComponent は 0x66 または 102 です）</span></span><!--end_jpstr--></li>
<li>
<span class="k">let</span> <span class="nv">blueComponent</span> = <span class="nv">pink</span> &amp; <span class="m">0x0000FF</span>           <span class="enstr"><span class="c">// blueComponent is 0x99, or 153</span></span><!--end_enstr--><span class="jpstr"><span class="c">（blueComponent は 0x99 または 153 です）</span></span><!--end_jpstr--></li>
</ol></div></div></div>
<p><span class="enstr">This example uses a <code class="docutils literal notranslate"><span class="pre">UInt32</span></code> constant called <code class="docutils literal notranslate"><span class="pre">pink</span></code> to store a Cascading Style Sheets color value for the color pink. The CSS color value <code class="docutils literal notranslate"><span class="pre">#CC6699</span></code> is written as <code class="docutils literal notranslate"><span class="pre">0xCC6699</span></code> in Swift’s hexadecimal number representation. This color is then decomposed into its red (<code class="docutils literal notranslate"><span class="pre">CC</span></code>), green (<code class="docutils literal notranslate"><span class="pre">66</span></code>), and blue (<code class="docutils literal notranslate"><span class="pre">99</span></code>) components by the bitwise AND operator (<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>) and the bitwise right shift operator (<code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>).</span><!--end_enstr-->
<span class="jpstr">
この例は、ピンク色のカスケーディング・スタイル・シートの色値を保存するために、<code class="docutils literal notranslate"><span class="pre">pink</span></code>と呼ばれる<code class="docutils literal notranslate"><span class="pre">UInt32</span></code>定数を使います。CSS色値<code class="docutils literal notranslate"><span class="pre">#CC6699</span></code>は、スウィフトの16進数表現では<code class="docutils literal notranslate"><span class="pre">0xCC6699</span></code>のように書かれます。この色はそれから、ビット単位の論理積演算子（<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>）とビット単位の右シフト演算子（<code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>）によって、それの赤（<code class="docutils literal notranslate"><span class="pre">CC</span></code>）、緑（<code class="docutils literal notranslate"><span class="pre">66</span></code>）、そして青（<code class="docutils literal notranslate"><span class="pre">99</span></code>）の構成要素に分解されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The red component is obtained by performing a bitwise AND between the numbers <code class="docutils literal notranslate"><span class="pre">0xCC6699</span></code> and <code class="docutils literal notranslate"><span class="pre">0xFF0000</span></code>. The zeros in <code class="docutils literal notranslate"><span class="pre">0xFF0000</span></code> effectively “mask” the second and third bytes of <code class="docutils literal notranslate"><span class="pre">0xCC6699</span></code>, causing the <code class="docutils literal notranslate"><span class="pre">6699</span></code> to be ignored and leaving <code class="docutils literal notranslate"><span class="pre">0xCC0000</span></code> as the result.</span><!--end_enstr-->
<span class="jpstr">
赤の構成要素は、数<code class="docutils literal notranslate"><span class="pre">0xCC6699</span></code>と<code class="docutils literal notranslate"><span class="pre">0xFF0000</span></code>との間のビット単位の論理積を実行することによって得られます。<code class="docutils literal notranslate"><span class="pre">0xFF0000</span></code>のゼロは、<code class="docutils literal notranslate"><span class="pre">0xCC6699</span></code>の２番目と３番目のバイトを効果的に「マスク」します（隠して消します）、そして<code class="docutils literal notranslate"><span class="pre">6699</span></code>が無視されるようになって、結果として<code class="docutils literal notranslate"><span class="pre">0xCC0000</span></code>が残ります。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">This number is then shifted 16 places to the right (<code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span> <span class="pre">16</span></code>). Each pair of characters in a hexadecimal number uses 8 bits, so a move 16 places to the right will convert <code class="docutils literal notranslate"><span class="pre">0xCC0000</span></code> into <code class="docutils literal notranslate"><span class="pre">0x0000CC</span></code>. This is the same as <code class="docutils literal notranslate"><span class="pre">0xCC</span></code>, which has a decimal value of <code class="docutils literal notranslate"><span class="pre">204</span></code>.</span><!--end_enstr-->
<span class="jpstr">
この数は、それから右に16桁シフトされます（<code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span> <span class="pre">16</span></code>）。16進数の中の文字の各ペアは８ビットを使うので、右への16桁の移動は<code class="docutils literal notranslate"><span class="pre">0xCC0000</span></code>を<code class="docutils literal notranslate"><span class="pre">0x0000CC</span></code>へと変えます。これは<code class="docutils literal notranslate"><span class="pre">0xCC</span></code>と同じものです、それは、10進の値の<code class="docutils literal notranslate"><span class="pre">204</span></code>を持ちます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Similarly, the green component is obtained by performing a bitwise AND between the numbers <code class="docutils literal notranslate"><span class="pre">0xCC6699</span></code> and <code class="docutils literal notranslate"><span class="pre">0x00FF00</span></code>, which gives an output value of <code class="docutils literal notranslate"><span class="pre">0x006600</span></code>. This output value is then shifted eight places to the right, giving a value of <code class="docutils literal notranslate"><span class="pre">0x66</span></code>, which has a decimal value of <code class="docutils literal notranslate"><span class="pre">102</span></code>.</span><!--end_enstr-->
<span class="jpstr">
同じように、緑の構成要素は数<code class="docutils literal notranslate"><span class="pre">0xCC6699</span></code>と<code class="docutils literal notranslate"><span class="pre">0x00FF00</span></code>との間のビット単位の論理積を実行することによって得られます、それは、<code class="docutils literal notranslate"><span class="pre">0x006600</span></code>の出力値を与えます。この出力値は、それから８桁右にシフトされて、<code class="docutils literal notranslate"><span class="pre">0x66</span></code>の値を与えます、それは10進の値の<code class="docutils literal notranslate"><span class="pre">102</span></code>を持ちます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Finally, the blue component is obtained by performing a bitwise AND between the numbers <code class="docutils literal notranslate"><span class="pre">0xCC6699</span></code> and <code class="docutils literal notranslate"><span class="pre">0x0000FF</span></code>, which gives an output value of <code class="docutils literal notranslate"><span class="pre">0x000099</span></code>. Because <code class="docutils literal notranslate"><span class="pre">0x000099</span></code> already equals <code class="docutils literal notranslate"><span class="pre">0x99</span></code>, which has a decimal value of <code class="docutils literal notranslate"><span class="pre">153</span></code>, this value is used without shifting it to the right,</span><!--end_enstr-->
<span class="jpstr">
最後に、青の構成要素は数<code class="docutils literal notranslate"><span class="pre">0xCC6699</span></code>と<code class="docutils literal notranslate"><span class="pre">0x0000FF</span></code>との間のビット単位の論理積を実行することによって得られます、それは、<code class="docutils literal notranslate"><span class="pre">0x000099</span></code>の出力値を与えます。<code class="docutils literal notranslate"><span class="pre">0x000099</span></code>はもう既に<code class="docutils literal notranslate"><span class="pre">0x99</span></code>と等しいので、それは10進数の<code class="docutils literal notranslate"><span class="pre">153</span></code>を持ちます、この値はそれを右へとシフトすることなく使用されます。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID36">
<h4><span class="enstr">Shifting Behavior for Signed Integers<a class="headerlink" href="#ID36" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
符号つき整数のためのシフト挙動<a class="headerlink" href="#ID36" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h4>
<p><span class="enstr">The shifting behavior is more complex for signed integers than for unsigned integers, because of the way signed integers are represented in binary. (The examples below are based on 8-bit signed integers for simplicity, but the same principles apply for signed integers of any size.)</span><!--end_enstr-->
<span class="jpstr">
シフト挙動は、符号つき整数では符号なし整数よりももっと複雑です、なぜなら、符号つき整数が２進数において表される方法のためです。（下の例は、単純さのために8ビット符号つき整数に基づきます、しかし同じ原理はあらゆるサイズの符号つき整数に当てはまります）。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Signed integers use their first bit (known as the <em>sign bit</em>) to indicate whether the integer is positive or negative. A sign bit of <code class="docutils literal notranslate"><span class="pre">0</span></code> means positive, and a sign bit of <code class="docutils literal notranslate"><span class="pre">1</span></code> means negative.</span><!--end_enstr-->
<span class="jpstr">
符号つき整数は、それらの最初のビット（<em>符号ビット</em>として知られるもの）を使って、その整数が正であるか負であるかを示します。<code class="docutils literal notranslate"><span class="pre">0</span></code>の符号ビットは正を意味します、そして、<code class="docutils literal notranslate"><span class="pre">1</span></code>の符号ビットは負であることを意味します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The remaining bits (known as the <em>value bits</em>) store the actual value. Positive numbers are stored in exactly the same way as for unsigned integers, counting upwards from <code class="docutils literal notranslate"><span class="pre">0</span></code>. Here’s how the bits inside an <code class="docutils literal notranslate"><span class="pre">Int8</span></code> look for the number <code class="docutils literal notranslate"><span class="pre">4</span></code>:</span><!--end_enstr-->
<span class="jpstr">
残っているビット（<em>値ビット</em>として知られるもの）は、実際の値を格納します。正の数は符号なし整数と正確に同じ方法で格納されて、<code class="docutils literal notranslate"><span class="pre">0</span></code>から上方へ数えます。<code class="docutils literal notranslate"><span class="pre">Int8</span></code>内のビットが数<code class="docutils literal notranslate"><span class="pre">4</span></code>に対してどのように見えるかは、ここにあります：
</span><!--end_jpstr-->
</p>
<img alt="../_images/bitshiftSignedFour_2x.png" class="align-center" src="../images/bitshiftSignedFour_2x.png" style="width: 275px;">
<p><span class="enstr">The sign bit is <code class="docutils literal notranslate"><span class="pre">0</span></code> (meaning “positive”), and the seven value bits are just the number <code class="docutils literal notranslate"><span class="pre">4</span></code>, written in binary notation.</span><!--end_enstr-->
<span class="jpstr">
符号ビットは<code class="docutils literal notranslate"><span class="pre">0</span></code>です（「正」を意味します）、そして７つの値ビットはちょうど、２進数表記法で書かれる数<code class="docutils literal notranslate"><span class="pre">4</span></code>です。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Negative numbers, however, are stored differently. They’re stored by subtracting their absolute value from <code class="docutils literal notranslate"><span class="pre">2</span></code> to the power of <code class="docutils literal notranslate"><span class="pre">n</span></code>, where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the number of value bits. An eight-bit number has seven value bits, so this means <code class="docutils literal notranslate"><span class="pre">2</span></code> to the power of <code class="docutils literal notranslate"><span class="pre">7</span></code>, or <code class="docutils literal notranslate"><span class="pre">128</span></code>.</span><!--end_enstr-->
<span class="jpstr">
負の数は、しかし異なって格納されます。それらは、<code class="docutils literal notranslate"><span class="pre">2</span></code>の<code class="docutils literal notranslate"><span class="pre">n</span></code>乗からそれらの絶対値を減ずることによって格納されます、そこで、<code class="docutils literal notranslate"><span class="pre">n</span></code>は値ビットの数です。８ビットの数は７つの値ビットを持ちますので、これは<code class="docutils literal notranslate"><span class="pre">2</span></code>の<code class="docutils literal notranslate"><span class="pre">7</span></code>乗、つまり<code class="docutils literal notranslate"><span class="pre">128</span></code>を意味します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Here’s how the bits inside an <code class="docutils literal notranslate"><span class="pre">Int8</span></code> look for the number <code class="docutils literal notranslate"><span class="pre">-4</span></code>:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Int8</span></code>内のビットが数<code class="docutils literal notranslate"><span class="pre">-4</span></code>に対してどのように見えるかは、ここにあります：
</span><!--end_jpstr-->
</p>
<img alt="../_images/bitshiftSignedMinusFour_2x.png" class="align-center" src="../images/bitshiftSignedMinusFour_2x.png" style="width: 280px;">
<p><span class="enstr">This time, the sign bit is <code class="docutils literal notranslate"><span class="pre">1</span></code> (meaning “negative”), and the seven value bits have a binary value of <code class="docutils literal notranslate"><span class="pre">124</span></code> (which is <code class="docutils literal notranslate"><span class="pre">128</span> <span class="pre">-</span> <span class="pre">4</span></code>):</span><!--end_enstr-->
<span class="jpstr">
今度は、符号ビットは<code class="docutils literal notranslate"><span class="pre">1</span></code>です（「負」を意味します）、そして、７つの値ビットは２進数の値の<code class="docutils literal notranslate"><span class="pre">124</span></code>を持ちます（それは、<code class="docutils literal notranslate"><span class="pre">128</span> <span class="pre">-</span> <span class="pre">4</span></code>です）：
</span><!--end_jpstr-->
</p>
<img alt="../_images/bitshiftSignedMinusFourValue_2x.png" class="align-center" src="../images/bitshiftSignedMinusFourValue_2x.png" style="width: 252px;">
<p><span class="enstr">This encoding for negative numbers is known as a <em>two’s complement</em> representation. It may seem an unusual way to represent negative numbers, but it has several advantages.</span><!--end_enstr-->
<span class="jpstr">
この負数のための符号化は、<em>２の補数</em>表現として知られています。それは負数を表す普通でない方法のようかもしれません、しかしそれはいくつかの利点を持ちます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">First, you can add <code class="docutils literal notranslate"><span class="pre">-1</span></code> to <code class="docutils literal notranslate"><span class="pre">-4</span></code>, simply by performing a standard binary addition of all eight bits (including the sign bit), and discarding anything that doesn’t fit in the eight bits once you’re done:</span><!--end_enstr-->
<span class="jpstr">
第１に、あなたは<code class="docutils literal notranslate"><span class="pre">-1</span></code>を<code class="docutils literal notranslate"><span class="pre">-4</span></code>に加えることが、単純に８つのビット全て（符号ビットを含む）の通常のバイナリの加算を実行して、あなたがそうしたならばその８ビットに収まらない何でも捨てることによって行えます：
</span><!--end_jpstr-->
</p>
<img alt="../_images/bitshiftSignedAddition_2x.png" class="align-center" src="../images/bitshiftSignedAddition_2x.png" style="width: 334px;">
<p><span class="enstr">Second, the two’s complement representation also lets you shift the bits of negative numbers to the left and right like positive numbers, and still end up doubling them for every shift you make to the left, or halving them for every shift you make to the right. To achieve this, an extra rule is used when signed integers are shifted to the right: When you shift signed integers to the right, apply the same rules as for unsigned integers, but fill any empty bits on the left with the <em>sign bit</em>, rather than with a zero.</span><!--end_enstr-->
<span class="jpstr">
第２に、２の補数表現はまた、あなたに負数のビットを左や右に正の数のようにシフトさせます、そして依然としてあなたが左へとするシフトは全てそれを２倍にすることで、またあなたが右へとするシフトは全てそれを半分にすることで終わります。これを達成するために、符号つき整数が右へシフトされるとき、特別な規則が使われます：あなたが符号つき整数を右にシフトする時は、符号なし整数と同じ規則を適用してください、しかし、その左のあらゆる空のビットを、ゼロではなく<em>符号ビット</em>で満たしてください。
</span><!--end_jpstr-->
</p>
<img alt="../_images/bitshiftSigned_2x.png" class="align-center" src="../images/bitshiftSigned_2x.png" style="width: 541px;">
<p><span class="enstr">This action ensures that signed integers have the same sign after they’re shifted to the right, and is known as an <em>arithmetic shift</em>.</span><!--end_enstr-->
<span class="jpstr">
この動作は、符号つき整数が、それが右へシフトされた後に同じサインを持つことを確実にします、そして<em>算術シフト</em>として知られています。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Because of the special way that positive and negative numbers are stored, shifting either of them to the right moves them closer to zero. Keeping the sign bit the same during this shift means that negative integers remain negative as their value moves closer to zero.</span><!--end_enstr-->
<span class="jpstr">
正および負の数が格納される特別な方法のため、それらのどちらでも右へシフトすることは、それらをゼロの近くに動かします。このシフトの間に符号ビットを同じに保つことは、それの値がゼロの近くに動くとき、負整数が負のままであることを意味します。
</span><!--end_jpstr-->
</p>
</div>
</div>
</div>
<div class="section" id="ID37">
<h2><span class="enstr">Overflow Operators<a class="headerlink" href="#ID37" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
オーバフロー演算子<a class="headerlink" href="#ID37" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">If you try to insert a number into an integer constant or variable that can’t hold that value, by default Swift reports an error rather than allowing an invalid value to be created. This behavior gives extra safety when you work with numbers that are too large or too small.</span><!--end_enstr-->
<span class="jpstr">
あなたがある数をその値を持つことができない整数の定数や変数の中へ入れようとするならば、初期状態では、スウィフトは無効な値がつくられるようにするのではなく、エラーを報告します。この挙動は、あまりに大きいかあまりに小さい数をあなたが扱うとき、追加の安全を与えます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">For example, the <code class="docutils literal notranslate"><span class="pre">Int16</span></code> integer type can hold any signed integer between <code class="docutils literal notranslate"><span class="pre">-32768</span></code> and <code class="docutils literal notranslate"><span class="pre">32767</span></code>. Trying to set an <code class="docutils literal notranslate"><span class="pre">Int16</span></code> constant or variable to a number outside of this range causes an error:</span><!--end_enstr-->
<span class="jpstr">
例えば、<code class="docutils literal notranslate"><span class="pre">Int16</span></code>整数型は、<code class="docutils literal notranslate"><span class="pre">-32768</span></code>と<code class="docutils literal notranslate"><span class="pre">32767</span></code>の間のどんな符号つき整数でも持つことができます。<code class="docutils literal notranslate"><span class="pre">Int16</span></code>定数または変数をこの範囲の外側の数に設定する試みは、エラーを引き起こします：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">var</span> <span class="nv">potentialOverflow</span> = <span class="nv">Int16</span>.<span class="nv">max</span>
</li>
<li>
<span class="c"><span class="enstr">// potentialOverflow equals 32767, which is the maximum value an Int16 can hold</span><!--end_enstr--><span class="jpstr">（potentialOverflowは32767と等しく、それはInt16が持つことができる最大限の値です）</span><!--end_jpstr--></span>
</li>
<li>
<span class="nv">potentialOverflow</span> += <span class="m">1</span>
</li>
<li>
<span class="c"><span class="enstr">// this causes an error</span><!--end_enstr--><span class="jpstr">（これは、エラーを引き起こします）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">Providing error handling when values get too large or too small gives you much more flexibility when coding for boundary value conditions.</span><!--end_enstr-->
<span class="jpstr">
値があまりに大きいかあまりに小さくなる時にエラー処理を提供することは、境界値条件のためのコードを書くとき、あなたにずっと多くの柔軟性を与えます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">However, when you specifically want an overflow condition to truncate the number of available bits, you can opt in to this behavior rather than triggering an error. Swift provides three arithmetic <em>overflow operators</em> that opt in to the overflow behavior for integer calculations. These operators all begin with an ampersand (<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>):</span><!--end_enstr-->
<span class="jpstr">
しかし、あなたがに利用できるビットの数を切り詰めるために特にオーバフロー条件を望むとき、あなたはエラーを引き起こすのではなくこの挙動を選ぶことができます。スウィフトは、整数計算のためにオーバフロー挙動を選択する３つの<em>算術オーバフロー演算子</em>を提供します。これらの演算子は、全てアンパサンド（<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>）で始まります：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li><span class="enstr">Overflow addition (<code class="docutils literal notranslate"><span class="pre">&amp;+</span></code>)</span><!--end_enstr-->
<span class="jpstr">
オーバフロー加算（<code class="docutils literal notranslate"><span class="pre">&amp;+</span></code>）
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Overflow subtraction (<code class="docutils literal notranslate"><span class="pre">&amp;-</span></code>)</span><!--end_enstr-->
<span class="jpstr">
オーバフロー減算（<code class="docutils literal notranslate"><span class="pre">&amp;-</span></code>）
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Overflow multiplication (<code class="docutils literal notranslate"><span class="pre">&amp;*</span></code>)</span><!--end_enstr-->
<span class="jpstr">
オーバフロー乗算（<code class="docutils literal notranslate"><span class="pre">&amp;*</span></code>）
</span><!--end_jpstr-->
</li>
</ul>
<div class="section" id="ID38">
<h3><span class="enstr">Value Overflow<a class="headerlink" href="#ID38" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
値オーバフロー<a class="headerlink" href="#ID38" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">Numbers can overflow in both the positive and negative direction.</span><!--end_enstr-->
<span class="jpstr">
数は正と負の向きの両方においてオーバフローすることができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Here’s an example of what happens when an unsigned integer is allowed to overflow in the positive direction, using the overflow addition operator (<code class="docutils literal notranslate"><span class="pre">&amp;+</span></code>):</span><!--end_enstr-->
<span class="jpstr">
ここに、オーバフロー加算演算子（<code class="docutils literal notranslate"><span class="pre">&amp;+</span></code>）を使用して、正の向きにおいて符号なし整数がオーバフローを許されるとき何が起こるかの例があります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">var</span> <span class="nv">unsignedOverflow</span> = <span class="nv">UInt8</span>.<span class="nv">max</span>
</li>
<li>
<span class="c"><span class="enstr">// unsignedOverflow equals 255, which is the maximum value a UInt8 can hold</span><!--end_enstr--><span class="jpstr">（unsignedOverflowは255に等しく、それはUInt８が持つことができる最大限の値です）</span><!--end_jpstr--></span>
</li>
<li>
<span class="nv">unsignedOverflow</span> = <span class="nv">unsignedOverflow</span> &amp;+ <span class="m">1</span>
</li>
<li>
<span class="c"><span class="enstr">// unsignedOverflow is now equal to 0</span><!--end_enstr--><span class="jpstr">（unsignedOverflowは、現在0と等しいです）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">The variable <code class="docutils literal notranslate"><span class="pre">unsignedOverflow</span></code> is initialized with the maximum value a <code class="docutils literal notranslate"><span class="pre">UInt8</span></code> can hold (<code class="docutils literal notranslate"><span class="pre">255</span></code>, or <code class="docutils literal notranslate"><span class="pre">11111111</span></code> in binary). It’s then incremented by <code class="docutils literal notranslate"><span class="pre">1</span></code> using the overflow addition operator (<code class="docutils literal notranslate"><span class="pre">&amp;+</span></code>). This pushes its binary representation just over the size that a <code class="docutils literal notranslate"><span class="pre">UInt8</span></code> can hold, causing it to overflow beyond its bounds, as shown in the diagram below. The value that remains within the bounds of the <code class="docutils literal notranslate"><span class="pre">UInt8</span></code> after the overflow addition is <code class="docutils literal notranslate"><span class="pre">00000000</span></code>, or zero.</span><!--end_enstr-->
<span class="jpstr">
変数<code class="docutils literal notranslate"><span class="pre">unsignedOverflow</span></code>は、<code class="docutils literal notranslate"><span class="pre">UInt8</span></code>が持つことができる最大限の値で初期化されます（<code class="docutils literal notranslate"><span class="pre">255</span></code>、または２進数での<code class="docutils literal notranslate"><span class="pre">11111111</span></code>）。それは、それからオーバフロー加算演算子（<code class="docutils literal notranslate"><span class="pre">&amp;+</span></code>）を使って<code class="docutils literal notranslate"><span class="pre">1</span></code>だけ増やされます。これは、そのバイナリの表現をちょうど<code class="docutils literal notranslate"><span class="pre">UInt8</span></code>が持つことができる大きさ以上に押し広げて、それを、下の図で示すように、その境界を越えてあふれさせます。オーバフロー加算の後で<code class="docutils literal notranslate"><span class="pre">UInt8</span></code>の領域内に残る値は、<code class="docutils literal notranslate"><span class="pre">00000000</span></code>、またはゼロです。
</span><!--end_jpstr-->
</p>
<img alt="../_images/overflowAddition_2x.png" class="align-center" src="../images/overflowAddition_2x.png" style="width: 242px;">
<p><span class="enstr">Something similar happens when an unsigned integer is allowed to overflow in the negative direction. Here’s an example using the overflow subtraction operator (<code class="docutils literal notranslate"><span class="pre">&amp;-</span></code>):</span><!--end_enstr-->
<span class="jpstr">
符号なし整数が負の向きにおいてオーバフローを認められるときに同じようなことが起こります。ここにオーバフロー減算演算子（<code class="docutils literal notranslate"><span class="pre">&amp;-</span></code>）を使った例があります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">var</span> <span class="nv">unsignedOverflow</span> = <span class="nv">UInt8</span>.<span class="nv">min</span>
</li>
<li>
<span class="c"><span class="enstr">// unsignedOverflow equals 0, which is the minimum value a UInt8 can hold</span><!--end_enstr--><span class="jpstr">（unsignedOverflowは0と等しく、それはUInt8が持つことができる最小限の値です）</span><!--end_jpstr--></span>
</li>
<li>
<span class="nv">unsignedOverflow</span> = <span class="nv">unsignedOverflow</span> &amp;- <span class="m">1</span>
</li>
<li>
<span class="c"><span class="enstr">// unsignedOverflow is now equal to 255</span><!--end_enstr--><span class="jpstr">（unsignedOverflowは、現在255と等しいです）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">The minimum value that a <code class="docutils literal notranslate"><span class="pre">UInt8</span></code> can hold is zero, or <code class="docutils literal notranslate"><span class="pre">00000000</span></code> in binary. If you subtract <code class="docutils literal notranslate"><span class="pre">1</span></code> from <code class="docutils literal notranslate"><span class="pre">00000000</span></code> using the overflow subtraction operator (<code class="docutils literal notranslate"><span class="pre">&amp;-</span></code>), the number will overflow and wrap around to <code class="docutils literal notranslate"><span class="pre">11111111</span></code>, or <code class="docutils literal notranslate"><span class="pre">255</span></code> in decimal.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">UInt8</span></code>が持つことができる最小限の値は、０、または２進数では<code class="docutils literal notranslate"><span class="pre">00000000</span></code>です。あなたがオーバフロー減算演算子（<code class="docutils literal notranslate"><span class="pre">&amp;-</span></code>）を使用して<code class="docutils literal notranslate"><span class="pre">00000000</span></code>から<code class="docutils literal notranslate"><span class="pre">1</span></code>を減ずるならば、その数はあふれ出てぐるっと送り込まれて<code class="docutils literal notranslate"><span class="pre">11111111</span></code>、10進での<code class="docutils literal notranslate"><span class="pre">255</span></code>になります。
</span><!--end_jpstr-->
</p>
<img alt="../_images/overflowUnsignedSubtraction_2x.png" class="align-center" src="../images/overflowUnsignedSubtraction_2x.png" style="width: 307px;">
<p><span class="enstr">Overflow also occurs for signed integers. All addition and subtraction for signed integers is performed in bitwise fashion, with the sign bit included as part of the numbers being added or subtracted, as described in <a class="reference internal" href="#ID34"><span class="std std-ref">Bitwise Left and Right Shift Operators</span></a>.</span><!--end_enstr-->
<span class="jpstr">
オーバフローはまた、符号つき整数に対しても起こります。符号つき整数に対する全ての加算と減算は、<a class="reference internal" href="#ID34"><span class="std std-ref">ビット単位の左および右シフト演算子</span></a>で記述されるように、加算または減算される数の一部として含めらる符号ビットとともに、ビット単位流儀で実行されます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">var</span> <span class="nv">signedOverflow</span> = <span class="nv">Int8</span>.<span class="nv">min</span>
</li>
<li>
<span class="c"><span class="enstr">// signedOverflow equals -128, which is the minimum value an Int8 can hold</span><!--end_enstr--><span class="jpstr">（signedOverflowは-128と等しく、それはInt8が持つことができる最小限の値です）</span><!--end_jpstr--></span>
</li>
<li>
<span class="nv">signedOverflow</span> = <span class="nv">signedOverflow</span> &amp;- <span class="m">1</span>
</li>
<li>
<span class="c"><span class="enstr">// signedOverflow is now equal to 127</span><!--end_enstr--><span class="jpstr">（signedOverflowは、現在127と等しいです）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">The minimum value that an <code class="docutils literal notranslate"><span class="pre">Int8</span></code> can hold is <code class="docutils literal notranslate"><span class="pre">-128</span></code>, or <code class="docutils literal notranslate"><span class="pre">10000000</span></code> in binary. Subtracting <code class="docutils literal notranslate"><span class="pre">1</span></code> from this binary number with the overflow operator gives a binary value of <code class="docutils literal notranslate"><span class="pre">01111111</span></code>, which toggles the sign bit and gives positive <code class="docutils literal notranslate"><span class="pre">127</span></code>, the maximum positive value that an <code class="docutils literal notranslate"><span class="pre">Int8</span></code> can hold.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Int8</span></code>が持つことができる最小限の数は、<code class="docutils literal notranslate"><span class="pre">-128</span></code>、または２進数での<code class="docutils literal notranslate"><span class="pre">10000000</span></code>です。この２進数からオーバフロー演算子を使って<code class="docutils literal notranslate"><span class="pre">1</span></code>を減ずることは、２進数の<code class="docutils literal notranslate"><span class="pre">01111111</span></code>を与えます、それは符号ビットを切り替えて正の<code class="docutils literal notranslate"><span class="pre">127</span></code>、<code class="docutils literal notranslate"><span class="pre">Int8</span></code>が持つことができる最大限の正の値、を与えます。
</span><!--end_jpstr-->
</p>
<img alt="../_images/overflowSignedSubtraction_2x.png" class="align-center" src="../images/overflowSignedSubtraction_2x.png" style="width: 311px;">
<p><span class="enstr">For both signed and unsigned integers, overflow in the positive direction wraps around from the maximum valid integer value back to the minimum, and overflow in the negative direction wraps around from the minimum value to the maximum.</span><!--end_enstr-->
<span class="jpstr">
符号つきおよび符号なし整数の両方に対して、正の方向でのオーバフローは最大限の有効な整数値から逆に最小限へとぐるっと送り込まれ、負の方向でのオーバフローは最小限の値から最大限へとぐるっと送り込まれます。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID41">
<h2><span class="enstr">Precedence and Associativity<a class="headerlink" href="#ID41" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
優先順位と結合性<a class="headerlink" href="#ID41" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">Operator <em>precedence</em> gives some operators higher priority than others; these operators are applied first.</span><!--end_enstr-->
<span class="jpstr">
<em>演算子優先順位</em>は、ある演算子に他のものよりも高い優先権を与えます；これらの演算子は最初に適用されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Operator <em>associativity</em> defines how operators of the same precedence are grouped together—either grouped from the left, or grouped from the right. Think of it as meaning “they associate with the expression to their left,” or “they associate with the expression to their right.”</span><!--end_enstr-->
<span class="jpstr">
演算子<em>結合性</em>は、同じ優先順位の演算子がまとめられる方法を定義します ― 左からまとめられるか右からまとめられるかのどちらか。それは「それらは、式をそれらの左と結びつける」あるいは「それらは、式をそれらの右と結びつける」を意味すると考えてください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">It’s important to consider each operator’s precedence and associativity when working out the order in which a compound expression will be calculated. For example, operator precedence explains why the following expression equals <code class="docutils literal notranslate"><span class="pre">17</span></code>.</span><!--end_enstr-->
<span class="jpstr">
複合の式が計算される順番を解決するとき、各演算子の優先順位と結合性を考慮することは、重要です。例えば、演算子優先順位は、なぜ以下の式が<code class="docutils literal notranslate"><span class="pre">17</span></code>に等しいのかを説明します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="m">2</span> + <span class="m">3</span> % <span class="m">4</span> * <span class="m">5</span>
</li>
<li>
<span class="c"><span class="enstr">// this equals 17</span><!--end_enstr--><span class="jpstr">（これは17に等しい）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">If you read strictly from left to right, you might expect the expression to be calculated as follows:</span><!--end_enstr-->
<span class="jpstr">
あなたが厳密に左から右に読んだならば、あなたはこの式を以下のように計算されることを期待するでしょう：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li>
<span class="enstr"><code class="docutils literal notranslate"><span class="pre">2</span></code> plus <code class="docutils literal notranslate"><span class="pre">3</span></code> equals <code class="docutils literal notranslate"><span class="pre">5</span></code></span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">2</span></code>足す<code class="docutils literal notranslate"><span class="pre">3</span></code>は<code class="docutils literal notranslate"><span class="pre">5</span></code>に等しい
</span><!--end_jpstr-->

</li>
<li>
<span class="enstr"><code class="docutils literal notranslate"><span class="pre">5</span></code> remainder <code class="docutils literal notranslate"><span class="pre">4</span></code> equals <code class="docutils literal notranslate"><span class="pre">1</span></code></span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">5</span></code>割る<code class="docutils literal notranslate"><span class="pre">4</span></code>の余りは<code class="docutils literal notranslate"><span class="pre">1</span></code>に等しい
</span><!--end_jpstr-->

</li>
<li>
<span class="enstr"><code class="docutils literal notranslate"><span class="pre">1</span></code> times <code class="docutils literal notranslate"><span class="pre">5</span></code> equals <code class="docutils literal notranslate"><span class="pre">5</span></code></span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">1</span></code>掛ける<code class="docutils literal notranslate"><span class="pre">5</span></code>は<code class="docutils literal notranslate"><span class="pre">5</span></code>に等しい
</span><!--end_jpstr-->

</li>
</ul>
<p><span class="enstr">However, the actual answer is <code class="docutils literal notranslate"><span class="pre">17</span></code>, not <code class="docutils literal notranslate"><span class="pre">5</span></code>. Higher-precedence operators are evaluated before lower-precedence ones. In Swift, as in C, the remainder operator (<code class="docutils literal notranslate"><span class="pre">%</span></code>) and the multiplication operator (<code class="docutils literal notranslate"><span class="pre">*</span></code>) have a higher precedence than the addition operator (<code class="docutils literal notranslate"><span class="pre">+</span></code>). As a result, they’re both evaluated before the addition is considered.</span><!--end_enstr-->
<span class="jpstr">
しかしながら、実際の答えは<code class="docutils literal notranslate"><span class="pre">17</span></code>です、<code class="docutils literal notranslate"><span class="pre">5</span></code>ではなく。より高い優先順位の演算子は、より低い優先順位のもの前に評価されます。スウィフトでは、Cでのように、剰余演算子（<code class="docutils literal notranslate"><span class="pre">%</span></code>）と乗算演算子（<code class="docutils literal notranslate"><span class="pre">*</span></code>）は、加算演算子（<code class="docutils literal notranslate"><span class="pre">+</span></code>）より高い優先順位を持ちます。結果として、それらは両方とも、加算が考慮される前に評価されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">However, remainder and multiplication have the <em>same</em> precedence as each other. To work out the exact evaluation order to use, you also need to consider their associativity. Remainder and multiplication both associate with the expression to their left. Think of this as adding implicit parentheses around these parts of the expression, starting from their left:</span><!--end_enstr-->
<span class="jpstr">
しかしながら、剰余と乗算は、互いに<em>同じ</em>優先順位を持ちます。使用する的確な評価順序を解き明かすには、あなたはまたそれらの結合性を考慮する必要があります。剰余と乗算は、両方とも式をそれらの左と結びつけます。これを、これらの式部分のまわりに、暗黙の括弧をそれらの左から開始して加えることと考えてみてください：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="m">2</span> + ((<span class="m">3</span> % <span class="m">4</span>) * <span class="m">5</span>)
</li></ol></div></div></div>
<p><span class="enstr"><code class="docutils literal notranslate"><span class="pre">(3</span> <span class="pre">%</span> <span class="pre">4)</span></code> is <code class="docutils literal notranslate"><span class="pre">3</span></code>, so this is equivalent to:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">(3</span> <span class="pre">%</span> <span class="pre">4)</span></code>は<code class="docutils literal notranslate"><span class="pre">3</span></code>なので、これは以下に等しいです：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="m">2</span> + (<span class="m">3</span> * <span class="m">5</span>)
</li></ol></div></div></div>
<p><span class="enstr"><code class="docutils literal notranslate"><span class="pre">(3</span> <span class="pre">*</span> <span class="pre">5)</span></code> is <code class="docutils literal notranslate"><span class="pre">15</span></code>, so this is equivalent to:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">(3</span> <span class="pre">*</span> <span class="pre">5)</span></code>は<code class="docutils literal notranslate"><span class="pre">15</span></code>なので、これは以下に等しいです：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="m">2</span> + <span class="m">15</span>
</li></ol></div></div></div>
<p><span class="enstr">This calculation yields the final answer of <code class="docutils literal notranslate"><span class="pre">17</span></code>.</span><!--end_enstr-->
<span class="jpstr">
この計算は、最終的な答えの<code class="docutils literal notranslate"><span class="pre">17</span></code>を生みます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">For information about the operators provided by the Swift standard library, including a complete list of the operator precedence groups and associativity settings, see <a class="reference external" href="../../../developer.apple.com/documentation/swift/operator_declarations.html">Operator Declarations</a>.</span><!--end_enstr-->
<span class="jpstr">
スウィフト標準ライブラリによって提供される演算子についての情報として、演算子優先順位と結合性の設定の完全なリストを含めて、<a class="reference external" href="../../../developer.apple.com/documentation/swift/operator_declarations.html">さまざまな演算子宣言</a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Swift’s operator precedences and associativity rules are simpler and more predictable than those found in C and Objective-C. However, this means that they aren’t exactly the same as in C-based languages. Be careful to ensure that operator interactions still behave in the way you intend when porting existing code to Swift.</span><!--end_enstr-->
<span class="jpstr">
スウィフトの演算子優先順位と結合性規則は、CとObjective-Cで見つけられるそれらより単純でより予測できます。しかし、これはCに基づく言語とそれらが厳密には同じでないことを意味します。既存のコードをスウィフトに移植するとき、依然としてあなたが意図するやり方で演算子相互作用が振る舞うことを確実にするように注意してください。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID42">
<h2><span class="enstr">Operator Methods<a class="headerlink" href="#ID42" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
演算子メソッド<a class="headerlink" href="#ID42" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">Classes and structures can provide their own implementations of existing operators. This is known as <em>overloading</em> the existing operators.</span><!--end_enstr-->
<span class="jpstr">
クラスと構造体は、既存の演算子のそれら独自の実装を提供することができます。既存の演算子の<em>オーバーロード</em>としてこれは知られています。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The example below shows how to implement the arithmetic addition operator (<code class="docutils literal notranslate"><span class="pre">+</span></code>) for a custom structure. The arithmetic addition operator is a binary operator because it operates on two targets and it’s an infix operator because it appears between those two targets.</span><!--end_enstr-->
<span class="jpstr">
下の例は、あつらえの構造体のために算術加算演算子（<code class="docutils literal notranslate"><span class="pre">+</span></code>）を実装する方法を示します。算術加算演算子は、それが２つの目標に作用するので二項演算子です、そして、それがそれらの２つの目標の間に現れるので接中辞演算子です。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The example defines a <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> structure for a two-dimensional position vector <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span></code>, followed by a definition of an <em>operator method</em> to add together instances of the <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> structure:</span><!--end_enstr-->
<span class="jpstr">
例は、２次元の位置ベクトル<code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span></code>のための<code class="docutils literal notranslate"><span class="pre">Vector2D</span></code>構造体を定義します。そして、<code class="docutils literal notranslate"><span class="pre">Vector2D</span></code>構造体のインスタンスそれらを１つに加えるための<em>演算子メソッド</em>の定義が続きます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">struct</span> <span class="nv">Vector2D</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">x</span> = <span class="m">0.0</span>, <span class="nv">y</span> = <span class="m">0.0</span>
</li>
<li>}
</li>
<li>
</li>
<li>
<span class="k">extension</span> <span class="nc">Vector2D</span> {
</li>
<li>    <span class="k">static</span> <span class="k">func</span> + (<span class="nv">left</span>: <span class="nc">Vector2D</span>, <span class="nv">right</span>: <span class="nc">Vector2D</span>) -&gt; <span class="nc">Vector2D</span> {
</li>
<li>        <span class="k">return</span> <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="nv">left</span>.<span class="nv">x</span> + <span class="nv">right</span>.<span class="nv">x</span>, <span class="nv">y</span>: <span class="nv">left</span>.<span class="nv">y</span> + <span class="nv">right</span>.<span class="nv">y</span>)
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">The operator method is defined as a type method on <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code>, with a method name that matches the operator to be overloaded (<code class="docutils literal notranslate"><span class="pre">+</span></code>). Because addition isn’t part of the essential behavior for a vector, the type method is defined in an extension of <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> rather than in the main structure declaration of <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code>. Because the arithmetic addition operator is a binary operator, this operator method takes two input parameters of type <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> and returns a single output value, also of type <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code>.</span><!--end_enstr-->
<span class="jpstr">
この演算子メソッドは、<code class="docutils literal notranslate"><span class="pre">Vector2D</span></code>上で型メソッドとして定義され、オーバーロードされる演算子と一致するメソッド名を持ちます（<code class="docutils literal notranslate"><span class="pre">+</span></code>）。加算はベクトルの欠くことのできない挙動の部分ではないので、この型メソッドは<code class="docutils literal notranslate"><span class="pre">Vector2D</span></code>の拡張において定義されます、<code class="docutils literal notranslate"><span class="pre">Vector2D</span></code>の主構造定義においてではなく。算術加算演算子は二項演算子なので、この演算子メソッドは<code class="docutils literal notranslate"><span class="pre">Vector2D</span></code>型の２つの入力パラメーターを取り、同じく<code class="docutils literal notranslate"><span class="pre">Vector2D</span></code>型のただ１つの出力値を返します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">In this implementation, the input parameters are named <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code> to represent the <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> instances that will be on the left side and right side of the <code class="docutils literal notranslate"><span class="pre">+</span></code> operator. The method returns a new <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> instance, whose <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> properties are initialized with the sum of the <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> properties from the two <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> instances that are added together.</span><!--end_enstr-->
<span class="jpstr">
この実装において、入力パラメータは、<code class="docutils literal notranslate"><span class="pre">left</span></code>と<code class="docutils literal notranslate"><span class="pre">right</span></code>という名前をつけられ、<code class="docutils literal notranslate"><span class="pre">+</span></code>演算子の左側と右側にある<code class="docutils literal notranslate"><span class="pre">Vector2D</span></code>インスタンスを表します。メソッドは、新しい<code class="docutils literal notranslate"><span class="pre">Vector2D</span></code>インスタンスを返します、それは<code class="docutils literal notranslate"><span class="pre">x</span></code>と<code class="docutils literal notranslate"><span class="pre">y</span></code>プロパティが一緒に加えられる２つの<code class="docutils literal notranslate"><span class="pre">Vector2D</span></code>インスタンスからの<code class="docutils literal notranslate"><span class="pre">x</span></code>と<code class="docutils literal notranslate"><span class="pre">y</span></code>プロパティの合計で初期化されるものです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The type method can be used as an infix operator between existing <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> instances:</span><!--end_enstr-->
<span class="jpstr">
この型メソッドは既存の<code class="docutils literal notranslate"><span class="pre">Vector2D</span></code>インスタンスの間で接中辞演算子として使われることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">vector</span> = <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="m">3.0</span>, <span class="nv">y</span>: <span class="m">1.0</span>)
</li>
<li>
<span class="k">let</span> <span class="nv">anotherVector</span> = <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="m">2.0</span>, <span class="nv">y</span>: <span class="m">4.0</span>)
</li>
<li>
<span class="k">let</span> <span class="nv">combinedVector</span> = <span class="nv">vector</span> + <span class="nv">anotherVector</span>
</li>
<li>
<span class="c"><span class="enstr">// combinedVector is a Vector2D instance with values of (5.0, 5.0)</span><!--end_enstr--><span class="jpstr">（combinedVectorは(5.0, 5.0)の値をもつVector2Dインスタンスです）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">This example adds together the vectors <code class="docutils literal notranslate"><span class="pre">(3.0,</span> <span class="pre">1.0)</span></code> and <code class="docutils literal notranslate"><span class="pre">(2.0,</span> <span class="pre">4.0)</span></code> to make the vector <code class="docutils literal notranslate"><span class="pre">(5.0,</span> <span class="pre">5.0)</span></code>, as illustrated below.</span><!--end_enstr-->
<span class="jpstr">
この例は、下で図示されるように、ベクトル<code class="docutils literal notranslate"><span class="pre">(3.0,</span> <span class="pre">1.0)</span></code>と<code class="docutils literal notranslate"><span class="pre">(2.0,</span> <span class="pre">4.0)</span></code>を加えて一緒にして、ベクトル<code class="docutils literal notranslate"><span class="pre">(5.0,</span> <span class="pre">5.0)</span></code>を作ります。
</span><!--end_jpstr-->
</p>
<img alt="../_images/vectorAddition_2x.png" class="align-center" src="../images/vectorAddition_2x.png" style="width: 477px;">
<div class="section" id="ID43">
<h3><span class="enstr">Prefix and Postfix Operators<a class="headerlink" href="#ID43" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
接頭辞と接尾辞演算子<a class="headerlink" href="#ID43" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">The example shown above demonstrates a custom implementation of a binary infix operator. Classes and structures can also provide implementations of the standard <em>unary operators</em>. Unary operators operate on a single target. They’re <em>prefix</em> if they precede their target (such as <code class="docutils literal notranslate"><span class="pre">-a</span></code>) and <em>postfix</em> operators if they follow their target (such as <code class="docutils literal notranslate"><span class="pre">b!</span></code>).</span><!--end_enstr-->
<span class="jpstr">
上で示される例は、二項接中辞演算子のあつらえの実装を示します。クラスと構造体は、また、標準の<em>単項演算子</em>の実施も提供することができます。単項演算子は、１つの目標に作用します。それらは、それがその目標に先行するならば<em>接頭辞</em>（例えば<code class="docutils literal notranslate"><span class="pre">-a</span></code>）、それがその目標の後に続くならば<em>接尾辞</em>演算子です（例えば<code class="docutils literal notranslate"><span class="pre">b!</span></code>）。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You implement a prefix or postfix unary operator by writing the <code class="docutils literal notranslate"><span class="pre">prefix</span></code> or <code class="docutils literal notranslate"><span class="pre">postfix</span></code> modifier before the <code class="docutils literal notranslate"><span class="pre">func</span></code> keyword when declaring the operator method:</span><!--end_enstr-->
<span class="jpstr">
あなたは、接頭辞または接尾辞単項演算子を、<code class="docutils literal notranslate"><span class="pre">prefix</span></code>または<code class="docutils literal notranslate"><span class="pre">postfix</span></code>修飾子を<code class="docutils literal notranslate"><span class="pre">func</span></code>キーワードの前に演算子メソッドを宣言するときに書くことによって実装します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">extension</span> <span class="nc">Vector2D</span> {
</li>
<li>    <span class="k">static</span> <span class="k">prefix</span> <span class="k">func</span> - (<span class="nv">vector</span>: <span class="nc">Vector2D</span>) -&gt; <span class="nc">Vector2D</span> {
</li>
<li>        <span class="k">return</span> <span class="nv">Vector2D</span>(<span class="nv">x</span>: -<span class="nv">vector</span>.<span class="nv">x</span>, <span class="nv">y</span>: -<span class="nv">vector</span>.<span class="nv">y</span>)
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">The example above implements the unary minus operator (<code class="docutils literal notranslate"><span class="pre">-a</span></code>) for <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> instances. The unary minus operator is a prefix operator, and so this method has to be qualified with the <code class="docutils literal notranslate"><span class="pre">prefix</span></code> modifier.</span><!--end_enstr-->
<span class="jpstr">
上の例は、<code class="docutils literal notranslate"><span class="pre">Vector2D</span></code>インスタンスのための単項マイナス演算子（<code class="docutils literal notranslate"><span class="pre">-a</span></code>）を実装します。この単項マイナス演算子は、接頭辞演算子です、なのでこのメソッドは<code class="docutils literal notranslate"><span class="pre">prefix</span></code>修飾子で修飾されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">For simple numeric values, the unary minus operator converts positive numbers into their negative equivalent and vice versa. The corresponding implementation for <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> instances performs this operation on both the <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> properties:</span><!--end_enstr-->
<span class="jpstr">
単純な数の値のために、この単項マイナス演算子は正の数をその負の等価物に変えます、逆の場合も同じです。<code class="docutils literal notranslate"><span class="pre">Vector2D</span></code>インスタンスのための対応する実装は、<code class="docutils literal notranslate"><span class="pre">x</span></code>と<code class="docutils literal notranslate"><span class="pre">y</span></code>プロパティ両方の上でこの操作を実行します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">positive</span> = <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="m">3.0</span>, <span class="nv">y</span>: <span class="m">4.0</span>)
</li>
<li>
<span class="k">let</span> <span class="nv">negative</span> = -<span class="nv">positive</span>
</li>
<li>
<span class="c"><span class="enstr">// negative is a Vector2D instance with values of (-3.0, -4.0)</span><!--end_enstr--><span class="jpstr">（negativeは、値(-3.0, -4.0)をもつVector2Dインスタンです）</span><!--end_jpstr--></span>
</li>
<li>
<span class="k">let</span> <span class="nv">alsoPositive</span> = -<span class="nv">negative</span>
</li>
<li>
<span class="c"><span class="enstr">// alsoPositive is a Vector2D instance with values of (3.0, 4.0)</span><!--end_enstr--><span class="jpstr">（alsoPositiveは、値(-3.0, -4.0)をもつVector2Dインスタンです）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
</div>
<div class="section" id="ID44">
<h3><span class="enstr">Compound Assignment Operators<a class="headerlink" href="#ID44" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
複合代入演算子<a class="headerlink" href="#ID44" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr"><em>Compound assignment operators</em> combine assignment (<code class="docutils literal notranslate"><span class="pre">=</span></code>) with another operation. For example, the addition assignment operator (<code class="docutils literal notranslate"><span class="pre">+=</span></code>) combines addition and assignment into a single operation. You mark a compound assignment operator’s left input parameter type as <code class="docutils literal notranslate"><span class="pre">inout</span></code>, because the parameter’s value will be modified directly from within the operator method.</span><!--end_enstr-->
<span class="jpstr">
<em>複合代入演算子</em>は、代入（<code class="docutils literal notranslate"><span class="pre">=</span></code>）を別の操作と組み合わせます。例えば、加算代入演算子（<code class="docutils literal notranslate"><span class="pre">+=</span></code>）は、加算と代入を一回の操作に結合します。あなたは複合代入演算子の左入力パラメーター型を<code class="docutils literal notranslate"><span class="pre">inout</span></code>として印します、なぜなら、このパラメーターの値は直接にこの演算子メソッド内で修正されることになるからです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The example below implements an addition assignment operator method for <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> instances:</span><!--end_enstr-->
<span class="jpstr">
下の例は、<code class="docutils literal notranslate"><span class="pre">Vector2D</span></code>インスタンスのために追加代入演算子メソッドを実装します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">extension</span> <span class="nc">Vector2D</span> {
</li>
<li>    <span class="k">static</span> <span class="k">func</span> += (<span class="nv">left</span>: <span class="k">inout</span> <span class="nc">Vector2D</span>, <span class="nv">right</span>: <span class="nc">Vector2D</span>) {
</li>
<li>        <span class="nv">left</span> = <span class="nv">left</span> + <span class="nv">right</span>
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">Because an addition operator was defined earlier, you don’t need to reimplement the addition process here. Instead, the addition assignment operator method takes advantage of the existing addition operator method, and uses it to set the left value to be the left value plus the right value:</span><!--end_enstr-->
<span class="jpstr">
加算演算子は以前に定義されたので、あなたはここでは加算プロセスを再実装する必要はありません。代わりに、追加代入演算子メソッドは、既存の加算演算子メソッドを利用して、左の値を右の値を加えた左の値に設定するためにそれを使います：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">var</span> <span class="nv">original</span> = <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="m">1.0</span>, <span class="nv">y</span>: <span class="m">2.0</span>)
</li>
<li>
<span class="k">let</span> <span class="nv">vectorToAdd</span> = <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="m">3.0</span>, <span class="nv">y</span>: <span class="m">4.0</span>)
</li>
<li>
<span class="nv">original</span> += <span class="nv">vectorToAdd</span>
</li>
<li>
<span class="c"><span class="enstr">// original now has values of (4.0, 6.0)</span><!--end_enstr--><span class="jpstr">（originalは、現在(4.0, 6.0)の値を持ちます）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">It isn’t possible to overload the default assignment operator (<code class="docutils literal notranslate"><span class="pre">=</span></code>). Only the compound assignment operators can be overloaded. Similarly, the ternary conditional operator (<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">?</span> <span class="pre">b</span> <span class="pre">:</span> <span class="pre">c</span></code>) can’t be overloaded.</span><!--end_enstr-->
<span class="jpstr">
もとからある代入演算子（<code class="docutils literal notranslate"><span class="pre">=</span></code>）をオーバーロードすることは不可能です。複合代入演算子だけが、オーバーロードされることができます。同じように三項条件演算子（<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">?</span> <span class="pre">b</span> <span class="pre">:</span> <span class="pre">c</span></code>)は、オーバーロードされることができません。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID45">
<h3><span class="enstr">Equivalence Operators<a class="headerlink" href="#ID45" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
等価演算子<a class="headerlink" href="#ID45" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">By default, custom classes and structures don’t have an implementation of the <em>equivalence operators</em>, known as the <em>equal to</em> operator (<code class="docutils literal notranslate"><span class="pre">==</span></code>) and <em>not equal to</em> operator (<code class="docutils literal notranslate"><span class="pre">!=</span></code>). You usually implement the <code class="docutils literal notranslate"><span class="pre">==</span></code> operator, and use the standard library’s default implementation of the <code class="docutils literal notranslate"><span class="pre">!=</span></code> operator that negates the result of the <code class="docutils literal notranslate"><span class="pre">==</span></code> operator. There are two ways to implement the <code class="docutils literal notranslate"><span class="pre">==</span></code> operator: You can implement it yourself, or for many types, you can ask Swift to synthesize an implementation for you. In both cases, you add conformance to the standard library’s <code class="docutils literal notranslate"><span class="pre">Equatable</span></code> protocol.</span><!--end_enstr-->
<span class="jpstr">
初期状態では、あつらえのクラスと構造体は、<em>「同等」</em>演算子（<code class="docutils literal notranslate"><span class="pre">==</span></code>）そして<em>「不等」</em>演算子（<code class="docutils literal notranslate"><span class="pre">!=</span></code>）として知られる、<em>等価演算子</em>の実装を持ちません。あなたは普通は<code class="docutils literal notranslate"><span class="pre">==</span></code>演算子を実装します、そして標準ライブラリのもつ<code class="docutils literal notranslate"><span class="pre">!=</span></code>演算子の省略時の実装を使います、それは<code class="docutils literal notranslate"><span class="pre">==</span></code>演算子の結果を否定するものです。<code class="docutils literal notranslate"><span class="pre">==</span></code>演算子を実装する２つの方法があります：あなたはそれをあなた自身で実装できます、または多くの型に対して、あなたはスウィフトにある実装をあなたかの代わりに実装するよう頼めます。両方の場合において、あなたは標準ライブラリのもつ<code class="docutils literal notranslate"><span class="pre">Equatable</span></code>プロトコルへの準拠を加えます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You provide an implementation of the <code class="docutils literal notranslate"><span class="pre">==</span></code> operator in the same way as you implement other infix operators:</span><!--end_enstr-->
<span class="jpstr">
あなたは、<code class="docutils literal notranslate"><span class="pre">==</span></code>演算子の実装を、あなたが他の接中辞演算子を実装するのと同じ方法で提供します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">extension</span> <span class="nc">Vector2D</span>: <span class="nc">Equatable</span> {
</li>
<li>    <span class="k">static</span> <span class="k">func</span> == (<span class="nv">left</span>: <span class="nc">Vector2D</span>, <span class="nv">right</span>: <span class="nc">Vector2D</span>) -&gt; <span class="nc">Bool</span> {
</li>
<li>        <span class="k">return</span> (<span class="nv">left</span>.<span class="nv">x</span> == <span class="nv">right</span>.<span class="nv">x</span>) &amp;&amp; (<span class="nv">left</span>.<span class="nv">y</span> == <span class="nv">right</span>.<span class="nv">y</span>)
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">The example above implements an <code class="docutils literal notranslate"><span class="pre">==</span></code> operator to check whether two <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> instances have equivalent values. In the context of <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code>, it makes sense to consider “equal” as meaning “both instances have the same <code class="docutils literal notranslate"><span class="pre">x</span></code> values and <code class="docutils literal notranslate"><span class="pre">y</span></code> values”, and so this is the logic used by the operator implementation.</span><!--end_enstr-->
<span class="jpstr">
上の例は、ある<code class="docutils literal notranslate"><span class="pre">==</span></code>演算子を実装して、２つの<code class="docutils literal notranslate"><span class="pre">Vector2D</span></code>インスタンスが同等な値を持つかどうかを調べます。<code class="docutils literal notranslate"><span class="pre">Vector2D</span></code>の文脈では、「同等」を「両方のインスタンスが同じ<code class="docutils literal notranslate"><span class="pre">x</span></code>値と<code class="docutils literal notranslate"><span class="pre">y</span></code>値を持つ」ことを意味すると考えるのが道理にかなっています、なのでそれが演算子実装によって使われる論理です。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can now use this operator to check whether two <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> instances are equivalent:</span><!--end_enstr-->
<span class="jpstr">
あなたは、今ではこの演算子を使って２つの<code class="docutils literal notranslate"><span class="pre">Vector2D</span></code>インスタンスが等しいかどうか調べられます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">twoThree</span> = <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="m">2.0</span>, <span class="nv">y</span>: <span class="m">3.0</span>)
</li>
<li>
<span class="k">let</span> <span class="nv">anotherTwoThree</span> = <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="m">2.0</span>, <span class="nv">y</span>: <span class="m">3.0</span>)
</li>
<li>
<span class="k">if</span> <span class="nv">twoThree</span> == <span class="nv">anotherTwoThree</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"These two vectors are equivalent."</span>)
</li>
<li>}
</li>
<li>
<span class="c"><span class="enstr">// Prints "These two vectors are equivalent."</span><!--end_enstr--><span class="jpstr">（「これらの２つのベクトルは等しいです。」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">In many simple cases, you can ask Swift to provide synthesized implementations of the equivalence operators for you, as described in <a class="reference internal" href="Protocols.html#ID627"><span class="std std-ref">Adopting a Protocol Using a Synthesized Implementation</span></a>.</span><!--end_enstr-->
<span class="jpstr">
多くの単純な場合では、あなたはスウィフトに頼むことで、等価演算子の合成された実装をあなたの代わりに提供できます。<a class="reference internal" href="Protocols.html#ID627"><span class="std std-ref">プロトコルを合成実装を使って採用する</span></a>で記述されるように。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID46">
<h2><span class="enstr">Custom Operators<a class="headerlink" href="#ID46" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
あつらえの演算子<a class="headerlink" href="#ID46" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">You can declare and implement your own <em>custom operators</em> in addition to the standard operators provided by Swift. For a list of characters that can be used to define custom operators, see <a class="reference internal" href="../ReferenceManual/LexicalStructure.html#ID418"><span class="std std-ref">Operators</span></a>.</span><!--end_enstr-->
<span class="jpstr">
あなたは、スウィフトによって提供される標準の演算子に加えて、あなた独自の<em>あつらえの演算子</em>を宣言して実装することができます。あつらえの演算子を定義するために使用できる文字のリストとして、<a class="reference internal" href="../ReferenceManual/LexicalStructure.html#ID418"><span class="std std-ref">演算子</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">New operators are declared at a global level using the <code class="docutils literal notranslate"><span class="pre">operator</span></code> keyword, and are marked with the <code class="docutils literal notranslate"><span class="pre">prefix</span></code>, <code class="docutils literal notranslate"><span class="pre">infix</span></code> or <code class="docutils literal notranslate"><span class="pre">postfix</span></code> modifiers:</span><!--end_enstr-->
<span class="jpstr">
新しい演算子は<code class="docutils literal notranslate"><span class="pre">operator</span></code>キーワードを使ってグローバル水準で宣言されます、そして<code class="docutils literal notranslate"><span class="pre">prefix</span></code>、<code class="docutils literal notranslate"><span class="pre">infix</span></code>または<code class="docutils literal notranslate"><span class="pre">postfix</span></code>修飾子で印されます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="k">prefix</span> <span class="k">operator</span> +++
</li></ol></div></div></div>
<p><span class="enstr">The example above defines a new prefix operator called <code class="docutils literal notranslate"><span class="pre">+++</span></code>. This operator doesn’t have an existing meaning in Swift, and so it’s given its own custom meaning below in the specific context of working with <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> instances. For the purposes of this example, <code class="docutils literal notranslate"><span class="pre">+++</span></code> is treated as a new “prefix doubling” operator. It doubles the <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> values of a <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> instance, by adding the vector to itself with the addition assignment operator defined earlier. To implement the <code class="docutils literal notranslate"><span class="pre">+++</span></code> operator, you add a type method called <code class="docutils literal notranslate"><span class="pre">+++</span></code> to <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> as follows:</span><!--end_enstr-->
<span class="jpstr">
上の例は、<code class="docutils literal notranslate"><span class="pre">+++</span></code>と呼ばれる新しい接頭辞演算子を定義します。この演算子は、スウィフトにおいて既存の意味を持ちません、なので、それは<code class="docutils literal notranslate"><span class="pre">Vector2D</span></code>インスタンスを扱う特定の文脈の下で、独自のあつらえの意味を与えられます。この例の目的のために、<code class="docutils literal notranslate"><span class="pre">+++</span></code>は新しい「接頭辞倍加」演算子とみなされます。それは<code class="docutils literal notranslate"><span class="pre">Vector2D</span></code>インスタンスの<code class="docutils literal notranslate"><span class="pre">x</span></code>と<code class="docutils literal notranslate"><span class="pre">y</span></code>値を、そのベクトルをそれ自体へと以前に定義される加算代入演算子を使って加えることによって２倍にします。<code class="docutils literal notranslate"><span class="pre">+++</span></code>演算子を実装するには、あなたは<code class="docutils literal notranslate"><span class="pre">+++</span></code>と呼ばれる型メソッドを次のように<code class="docutils literal notranslate"><span class="pre">Vector2D</span></code>に加えます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">extension</span> <span class="nc">Vector2D</span> {
</li>
<li>    <span class="k">static</span> <span class="k">prefix</span> <span class="k">func</span> +++ (<span class="nv">vector</span>: <span class="k">inout</span> <span class="nc">Vector2D</span>) -&gt; <span class="nc">Vector2D</span> {
</li>
<li>        <span class="nv">vector</span> += <span class="nv">vector</span>
</li>
<li>        <span class="k">return</span> <span class="nv">vector</span>
</li>
<li>    }
</li>
<li>}
</li>
<li>
</li>
<li>
<span class="k">var</span> <span class="nv">toBeDoubled</span> = <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="m">1.0</span>, <span class="nv">y</span>: <span class="m">4.0</span>)
</li>
<li>
<span class="k">let</span> <span class="nv">afterDoubling</span> = +++<span class="nv">toBeDoubled</span>
</li>
<li>
<span class="c"><span class="enstr">// toBeDoubled now has values of (2.0, 8.0)</span><!--end_enstr--><span class="jpstr">（toBeDoubledは、現在(2.0, 8.0)の値を持ちます）</span><!--end_jpstr--></span>
</li>
<li>
<span class="c"><span class="enstr">// afterDoubling also has values of (2.0, 8.0)</span><!--end_enstr--><span class="jpstr">（afterDoublingも(2.0, 8.0)の値を持ちます）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<div class="section" id="ID47">
<h3><span class="enstr">Precedence for Custom Infix Operators<a class="headerlink" href="#ID47" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
あつらえの接中辞演算子の優先順位<a class="headerlink" href="#ID47" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">Custom infix operators each belong to a precedence group. A precedence group specifies an operator’s precedence relative to other infix operators, as well as the operator’s associativity. See <a class="reference internal" href="#ID41"><span class="std std-ref">Precedence and Associativity</span></a> for an explanation of how these characteristics affect an infix operator’s interaction with other infix operators.</span><!--end_enstr-->
<span class="jpstr">
あつらえの接中辞演算子それぞれは、ある優先順位グループに属しています。優先順位グループは、他の接中辞演算子と相対的にある演算子の優先順位を、それだけでなく演算子の結合性も指定します。<a class="reference internal" href="#ID41"><span class="std std-ref">優先順位と結合性</span></a>をどのようにそれらの特徴が接中辞演算子の他の接中辞演算子との相互作用に影響を及ぼすかの解説として見てください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">A custom infix operator that isn’t explicitly placed into a precedence group is given a default precedence group with a precedence immediately higher than the precedence of the ternary conditional operator.</span><!--end_enstr-->
<span class="jpstr">
ある優先順位グループの中に明示的に置かれないあつらえの接中辞演算子は、三項条件演算子の優先順位のすぐ上の優先順位を持つ省略時の優先順位グループを与えられます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The following example defines a new custom infix operator called <code class="docutils literal notranslate"><span class="pre">+-</span></code>, which belongs to the precedence group <code class="docutils literal notranslate"><span class="pre">AdditionPrecedence</span></code>:</span><!--end_enstr-->
<span class="jpstr">
以下の例は、<code class="docutils literal notranslate"><span class="pre">+-</span></code>と呼ばれる新しいあつらえの接中辞演算子を定義します、それは優先順位グループ<code class="docutils literal notranslate"><span class="pre">AdditionPrecedence</span></code>に属します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">infix</span> <span class="k">operator</span> +-: <span class="nv">AdditionPrecedence</span>
</li>
<li>
<span class="k">extension</span> <span class="nc">Vector2D</span> {
</li>
<li>    <span class="k">static</span> <span class="k">func</span> +- (<span class="nv">left</span>: <span class="nc">Vector2D</span>, <span class="nv">right</span>: <span class="nc">Vector2D</span>) -&gt; <span class="nc">Vector2D</span> {
</li>
<li>        <span class="k">return</span> <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="nv">left</span>.<span class="nv">x</span> + <span class="nv">right</span>.<span class="nv">x</span>, <span class="nv">y</span>: <span class="nv">left</span>.<span class="nv">y</span> - <span class="nv">right</span>.<span class="nv">y</span>)
</li>
<li>    }
</li>
<li>}
</li>
<li>
<span class="k">let</span> <span class="nv">firstVector</span> = <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="m">1.0</span>, <span class="nv">y</span>: <span class="m">2.0</span>)
</li>
<li>
<span class="k">let</span> <span class="nv">secondVector</span> = <span class="nv">Vector2D</span>(<span class="nv">x</span>: <span class="m">3.0</span>, <span class="nv">y</span>: <span class="m">4.0</span>)
</li>
<li>
<span class="k">let</span> <span class="nv">plusMinusVector</span> = <span class="nv">firstVector</span> +- <span class="nv">secondVector</span>
</li>
<li>
<span class="c"><span class="enstr">// plusMinusVector is a Vector2D instance with values of (4.0, -2.0)</span><!--end_enstr--><span class="jpstr">（plusMinusVectorはVector2Dインスタンスで(4.0, -2.0)の値をもちます）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">This operator adds together the <code class="docutils literal notranslate"><span class="pre">x</span></code> values of two vectors, and subtracts the <code class="docutils literal notranslate"><span class="pre">y</span></code> value of the second vector from the first. Because it’s in essence an “additive” operator, it has been given the same precedence group as additive infix operators such as <code class="docutils literal notranslate"><span class="pre">+</span></code> and <code class="docutils literal notranslate"><span class="pre">-</span></code>. For information about the operators provided by the Swift standard library, including a complete list of the operator precedence groups and associativity settings, see <a class="reference external" href="../../../developer.apple.com/documentation/swift/operator_declarations.html">Operator Declarations</a>. For more information about precedence groups and to see the syntax for defining your own operators and precedence groups, see <a class="reference internal" href="../ReferenceManual/Declarations.html#ID380"><span class="std std-ref">Operator Declaration</span></a>.</span><!--end_enstr-->
<span class="jpstr">
この演算子は、２つのベクトルの<code class="docutils literal notranslate"><span class="pre">x</span></code>値を一緒に加えて、第二のベクトルの<code class="docutils literal notranslate"><span class="pre">y</span></code>値を最初のものから減じます。それは本質的には「加法的な」演算子であるので、それは<code class="docutils literal notranslate"><span class="pre">+</span></code>や<code class="docutils literal notranslate"><span class="pre">-</span></code>といった加法的な接中辞演算子と同じ優先順位グループを与えられています。スウィフト標準ライブラリによって提供される演算子についての情報として、演算子優先順位と結合性の設定の完全なリストを含めて、<a class="reference external" href="../../../developer.apple.com/documentation/swift/operator_declarations.html">さまざまな演算子宣言</a>を見てください。優先順位グループについてのさらなる情報として、そしてあなた独自の演算子と優先順位グループを定義するための構文を見るには、<a class="reference internal" href="../ReferenceManual/Declarations.html#ID380"><span class="std std-ref">演算子宣言</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">You don’t specify a precedence when defining a prefix or postfix operator. However, if you apply both a prefix and a postfix operator to the same operand, the postfix operator is applied first.</span><!--end_enstr-->
<span class="jpstr">
あなたは、接頭辞または接尾辞演算子を定義するときに優先順位を指定しません。しかし、あなたが接頭辞演算子と接尾辞演算子の両方を同じ演算数を適用したならば、接尾辞演算子が最初に適用されます。
</span><!--end_jpstr-->
</p>
</div>
</div>
</div>
<div class="section" id="ID630">
<h2><span class="enstr">Result Builders<a class="headerlink" href="#ID630" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
リザルトビルダー<a class="headerlink" href="#ID630" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">A <em>result builder</em> is a type you define that adds syntax for creating nested data, like a list or tree, in a natural, declarative way. The code that uses the result builder can include ordinary Swift syntax, like <code class="docutils literal notranslate"><span class="pre">if</span></code> and <code class="docutils literal notranslate"><span class="pre">for</span></code>, to handle conditional or repeated pieces of data.</span><!--end_enstr-->
<span class="jpstr">
<em>リザルトビルダー</em>はあなたが定義する型です、それは入れ子にされたデータ、たとえばリストやツリーなどを自然な、宣言的な方法で作成するための構文を加えます。リザルトビルダーを使うコードは、通常のスウィフト構文、たとえば<code class="docutils literal notranslate"><span class="pre">if</span></code>および<code class="docutils literal notranslate"><span class="pre">for</span></code>などを含むことで、条件付きでまたは繰り返してデータの断片を取り扱えます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The code below defines a few types for drawing on a single line using stars and text.</span><!--end_enstr-->
<span class="jpstr">
下のコードは、単一の行上で星とテキストを使って描画するためにいくつかの型を定義します。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">protocol</span> <span class="nv">Drawable</span> {
</li>
<li>    <span class="k">func</span> <span class="nv">draw</span>() -&gt; <span class="nc">String</span>
</li>
<li>}
</li>
<li>
<span class="k">struct</span> <span class="nv">Line</span>: <span class="nc">Drawable</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">elements</span>: [<span class="nc">Drawable</span>]
</li>
<li>    <span class="k">func</span> <span class="nv">draw</span>() -&gt; <span class="nc">String</span> {
</li>
<li>        <span class="k">return</span> <span class="nv">elements</span>.<span class="nv">map</span> { <span class="nv">$0</span>.<span class="nv">draw</span>() }.<span class="nv">joined</span>(<span class="nv">separator</span>: <span class="s">""</span>)
</li>
<li>    }
</li>
<li>}
</li>
<li>
<span class="k">struct</span> <span class="nv">Text</span>: <span class="nc">Drawable</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">content</span>: <span class="nc">String</span>
</li>
<li>    <span class="k">init</span>(<span class="k">_</span> <span class="nv">content</span>: <span class="nc">String</span>) { <span class="k">self</span>.<span class="nv">content</span> = <span class="nv">content</span> }
</li>
<li>    <span class="k">func</span> <span class="nv">draw</span>() -&gt; <span class="nc">String</span> { <span class="k">return</span> <span class="nv">content</span> }
</li>
<li>}
</li>
<li>
<span class="k">struct</span> <span class="nv">Space</span>: <span class="nc">Drawable</span> {
</li>
<li>    <span class="k">func</span> <span class="nv">draw</span>() -&gt; <span class="nc">String</span> { <span class="k">return</span> <span class="s">" "</span> }
</li>
<li>}
</li>
<li>
<span class="k">struct</span> <span class="nv">Stars</span>: <span class="nc">Drawable</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">length</span>: <span class="nc">Int</span>
</li>
<li>    <span class="k">func</span> <span class="nv">draw</span>() -&gt; <span class="nc">String</span> { <span class="k">return</span> <span class="nv">String</span>(<span class="nv">repeating</span>: <span class="s">"*"</span>, <span class="nv">count</span>: <span class="nv">length</span>) }
</li>
<li>}
</li>
<li>
<span class="k">struct</span> <span class="nv">AllCaps</span>: <span class="nc">Drawable</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">content</span>: <span class="nc">Drawable</span>
</li>
<li>    <span class="k">func</span> <span class="nv">draw</span>() -&gt; <span class="nc">String</span> { <span class="k">return</span> <span class="nv">content</span>.<span class="nv">draw</span>().<span class="nv">uppercased</span>() }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">Drawable</span></code> protocol defines the requirement for something that can be drawn, like a line or shape: The type must implement a <code class="docutils literal notranslate"><span class="pre">draw()</span></code> method. The <code class="docutils literal notranslate"><span class="pre">Line</span></code> structure represents a single-line drawing, and it serves the top-level container for most drawings. To draw a <code class="docutils literal notranslate"><span class="pre">Line</span></code>, the structure calls <code class="docutils literal notranslate"><span class="pre">draw()</span></code> on each of the line’s components, and then concatenates the resulting strings into a single string. The <code class="docutils literal notranslate"><span class="pre">Text</span></code> structure wraps a string to make it part of a drawing. The <code class="docutils literal notranslate"><span class="pre">AllCaps</span></code> structure wraps and modifies another drawing, converting any text in the drawing to uppercase.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Drawable</span></code>プロトコルは、描画されることが可能な何らかのもの、ある行または形状などに対する要件を定義します：その型は<code class="docutils literal notranslate"><span class="pre">draw()</span></code>メソッドを実装しなければいけません。<code class="docutils literal notranslate"><span class="pre">Line</span></code>構造体は、ある単一行の描画を表します、そしてそれはほとんどの描画に対するトップレベルコンテナとして利用できます。<code class="docutils literal notranslate"><span class="pre">Line</span></code>を描画するために、構造体は<code class="docutils literal notranslate"><span class="pre">draw()</span></code>をその行のもつ構成要素のそれぞれで呼び出します、そしてそれから結果文字列それらを単一の文字列へと連結します。<code class="docutils literal notranslate"><span class="pre">Text</span></code>構造体は、文字列をラップしてそれを描画の一部とします。<code class="docutils literal notranslate"><span class="pre">AllCaps</span></code>構造体は、別の描画をラップおよび修正して、あらゆるテキストをその描画においてアッパーケースに変換します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">It’s possible to make a drawing with these types by calling their initializers:</span><!--end_enstr-->
<span class="jpstr">
ある描画を３つの型でそれらのイニシャライザを呼び出すことによって作ることは可能です：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">name</span>: <span class="nc">String</span>? = <span class="s">"Ravi Patel"</span>
</li>
<li>
<span class="k">let</span> <span class="nv">manualDrawing</span> = <span class="nv">Line</span>(<span class="nv">elements</span>: [
</li>
<li>    <span class="nv">Stars</span>(<span class="nv">length</span>: <span class="m">3</span>),
</li>
<li>    <span class="nv">Text</span>(<span class="s">"Hello"</span>),
</li>
<li>    <span class="nv">Space</span>(),
</li>
<li>    <span class="nv">AllCaps</span>(<span class="nv">content</span>: <span class="nv">Text</span>((<span class="nv">name</span> ?? <span class="s">"World"</span>) + <span class="s">"!"</span>)),
</li>
<li>    <span class="nv">Stars</span>(<span class="nv">length</span>: <span class="m">2</span>),
</li>
<li>    ])
</li>
<li>
<span class="nv">print</span>(<span class="nv">manualDrawing</span>.<span class="nv">draw</span>())
</li>
<li>
<span class="c">// Prints "***Hello RAVI PATEL!**"</span>
</li>
</ol></div></div></div>
<p><span class="enstr">This code works, but it’s a little awkward. The deeply nested parentheses after <code class="docutils literal notranslate"><span class="pre">AllCaps</span></code> are hard to read. The fallback logic to use “World” when <code class="docutils literal notranslate"><span class="pre">name</span></code> is <code class="docutils literal notranslate"><span class="pre">nil</span></code> has to be done inline using the <code class="docutils literal notranslate"><span class="pre">??</span></code> operator, which would be difficult with anything more complex. If you needed to include switches or <code class="docutils literal notranslate"><span class="pre">for</span></code> loops to build up part of the drawing, there’s no way to do that. A result builder lets you rewrite code like this so that it looks like normal Swift code.</span><!--end_enstr-->
<span class="jpstr">
このコードは働きます、しかしそれは少々ぎこちないものです。<code class="docutils literal notranslate"><span class="pre">AllCaps</span></code>の後ろで深く入れ子にされた丸括弧は読みやすいとは言えません。<code class="docutils literal notranslate"><span class="pre">name</span></code>が<code class="docutils literal notranslate"><span class="pre">nil</span></code>の時に“World” を使う代替論理は、<code class="docutils literal notranslate"><span class="pre">??</span></code>演算子を使用してインラインにされる必要があり、それはより複雑なものでは難しいでしょう。あなたがスイッチ条件分岐または<code class="docutils literal notranslate"><span class="pre">for</span></code>ループを含めることで描画の一部を作り上げる必要があるとしても、それをする方法はありません。リザルトビルダーは、あなたにこのようなコードを、それが通常のスウィフトコードのように見えるように書き直させます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">To define a result builder, you write the <code class="docutils literal notranslate"><span class="pre">@resultBuilder</span></code> attribute on a type declaration. For example, this code defines a result builder called <code class="docutils literal notranslate"><span class="pre">DrawingBuilder</span></code>, which lets you use a declarative syntax to describe a drawing:</span><!--end_enstr-->
<span class="jpstr">
リザルトビルダーを定義するには、あなたは<code class="docutils literal notranslate"><span class="pre">@resultBuilder</span></code>属性を型宣言上で書きます。例えば、このコードは<code class="docutils literal notranslate"><span class="pre">DrawingBuilder</span></code>と呼ばれるリザルトビルダーを定義します、それはあなたに宣言的な構文を使って描画を記述させます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>@<span class="nv">resultBuilder</span>
</li>
<li>
<span class="k">struct</span> <span class="nv">DrawingBuilder</span> {
</li>
<li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">buildBlock</span>(<span class="k">_</span> <span class="nv">components</span>: <span class="nc">Drawable</span>...) -&gt; <span class="nc">Drawable</span> {
</li>
<li>        <span class="k">return</span> <span class="nv">Line</span>(<span class="nv">elements</span>: <span class="nv">components</span>)
</li>
<li>    }
</li>
<li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">buildEither</span>(<span class="nv">first</span>: <span class="nc">Drawable</span>) -&gt; <span class="nc">Drawable</span> {
</li>
<li>        <span class="k">return</span> <span class="nv">first</span>
</li>
<li>    }
</li>
<li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">buildEither</span>(<span class="nv">second</span>: <span class="nc">Drawable</span>) -&gt; <span class="nc">Drawable</span> {
</li>
<li>        <span class="k">return</span> <span class="nv">second</span>
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">DrawingBuilder</span></code> structure defines three methods that implement parts of the result builder syntax. The <code class="docutils literal notranslate"><span class="pre">buildBlock(_:)</span></code> method adds support for writing a series of lines in a block of code. It combines the components in that block into a <code class="docutils literal notranslate"><span class="pre">Line</span></code>. The <code class="docutils literal notranslate"><span class="pre">buildEither(first:)</span></code> and <code class="docutils literal notranslate"><span class="pre">buildEither(second:)</span></code> methods add support for <code class="docutils literal notranslate"><span class="pre">if</span></code>-<code class="docutils literal notranslate"><span class="pre">else</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">DrawingBuilder</span></code>は３つのメソッドを定義します、それらはリザルトビルダー構文の各部分を実装します。<code class="docutils literal notranslate"><span class="pre">buildBlock(_:)</span></code>メソッドは、あるコードのブロックの中の一連の行を記述することに対するサポートを加えます。それは、そのブロックの中の構成要素それらをひとつの<code class="docutils literal notranslate"><span class="pre">Line</span></code>へと結合します。<code class="docutils literal notranslate"><span class="pre">buildEither(first:)</span></code>と<code class="docutils literal notranslate"><span class="pre">buildEither(second:)</span></code>メソッドは、<code class="docutils literal notranslate"><span class="pre">if</span></code>-<code class="docutils literal notranslate"><span class="pre">else</span></code>に対するサポートを加えます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can apply the <code class="docutils literal notranslate"><span class="pre">@DrawingBuilder</span></code> attribute to a function’s parameter, which turns a closure passed to the function into the value that the result builder creates from that closure. For example:</span><!--end_enstr-->
<span class="jpstr">
あなたは、<code class="docutils literal notranslate"><span class="pre">@DrawingBuilder</span></code>属性を関数のもつパラメータに対して適用できます、それはその関数に渡されたクロージャを、リザルトビルダーがそのクロージャから作成する値へと変えます。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">func</span> <span class="nv">draw</span>(@<span class="nv">DrawingBuilder</span> <span class="nv">content</span>: () -&gt; <span class="nc">Drawable</span>) -&gt; <span class="nc">Drawable</span> {
</li>
<li>    <span class="k">return</span> <span class="nv">content</span>()
</li>
<li>}
</li>
<li>
<span class="k">func</span> <span class="nv">caps</span>(@<span class="nv">DrawingBuilder</span> <span class="nv">content</span>: () -&gt; <span class="nc">Drawable</span>) -&gt; <span class="nc">Drawable</span> {
</li>
<li>    <span class="k">return</span> <span class="nv">AllCaps</span>(<span class="nv">content</span>: <span class="nv">content</span>())
</li>
<li>}
</li>
<li>
</li>
<li>
<span class="k">func</span> <span class="nv">makeGreeting</span>(<span class="nv">for</span> <span class="nv">name</span>: <span class="nc">String</span>? = <span class="k">nil</span>) -&gt; <span class="nc">Drawable</span> {
</li>
<li>    <span class="k">let</span> <span class="nv">greeting</span> = <span class="nv">draw</span> {
</li>
<li>        <span class="nv">Stars</span>(<span class="nv">length</span>: <span class="m">3</span>)
</li>
<li>        <span class="nv">Text</span>(<span class="s">"Hello"</span>)
</li>
<li>        <span class="nv">Space</span>()
</li>
<li>        <span class="nv">caps</span> {
</li>
<li>            <span class="k">if</span> <span class="k">let</span> <span class="nv">name</span> = <span class="nv">name</span> {
</li>
<li>                <span class="nv">Text</span>(<span class="nv">name</span> + <span class="s">"!"</span>)
</li>
<li>            } <span class="k">else</span> {
</li>
<li>                <span class="nv">Text</span>(<span class="s">"World!"</span>)
</li>
<li>            }
</li>
<li>        }
</li>
<li>        <span class="nv">Stars</span>(<span class="nv">length</span>: <span class="m">2</span>)
</li>
<li>    }
</li>
<li>    <span class="k">return</span> <span class="nv">greeting</span>
</li>
<li>}
</li>
<li>
<span class="k">let</span> <span class="nv">genericGreeting</span> = <span class="nv">makeGreeting</span>()
</li>
<li>
<span class="nv">print</span>(<span class="nv">genericGreeting</span>.<span class="nv">draw</span>())
</li>
<li>
<span class="c">// Prints "***Hello WORLD!**"</span>
</li>
<li>
</li>
<li>
<span class="k">let</span> <span class="nv">personalGreeting</span> = <span class="nv">makeGreeting</span>(<span class="nv">for</span>: <span class="s">"Ravi Patel"</span>)
</li>
<li>
<span class="nv">print</span>(<span class="nv">personalGreeting</span>.<span class="nv">draw</span>())
</li>
<li>
<span class="c">// Prints "***Hello RAVI PATEL!**"</span>
</li>
</ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">makeGreeting(for:)</span></code> function takes a <code class="docutils literal notranslate"><span class="pre">name</span></code> parameter and uses it to draw a personalized greeting. The <code class="docutils literal notranslate"><span class="pre">draw(_:)</span></code> and <code class="docutils literal notranslate"><span class="pre">caps(_:)</span></code> functions both take a single closure as their argument, which is marked with the <code class="docutils literal notranslate"><span class="pre">@DrawingBuilder</span></code> attribute. When you call those functions, you use the special syntax that <code class="docutils literal notranslate"><span class="pre">DrawingBuilder</span></code> defines. Swift transforms that declarative description of a drawing into a series of calls to the methods on <code class="docutils literal notranslate"><span class="pre">DrawingBuilder</span></code> to build up the value that’s passed as the function argument. For example, Swift transforms the call to <code class="docutils literal notranslate"><span class="pre">caps(_:)</span></code> in that example into code like the following:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">makeGreeting(for:)</span></code>関数は、<code class="docutils literal notranslate"><span class="pre">name</span></code>パラメータを取り、そしてそれを使って各個人向け挨拶を引き出します。<code class="docutils literal notranslate"><span class="pre">draw(_:)</span></code>と<code class="docutils literal notranslate"><span class="pre">caps(_:)</span></code>関数は、両方ともある単一のクロージャをそれらの引数として取ります、それは<code class="docutils literal notranslate"><span class="pre">@DrawingBuilder</span></code>属性で印されます。あなたがそれらの関数を呼び出す場合、あなたは<code class="docutils literal notranslate"><span class="pre">DrawingBuilder</span></code>が定義する特別な構文を使います。スウィフトは、ある描画の宣言的な記述を<code class="docutils literal notranslate"><span class="pre">DrawingBuilder</span></code>上のメソッドへの一連の呼び出しに変換することで、関数引数として渡される値を作り上げます。例えば、スウィフトはその例における<code class="docutils literal notranslate"><span class="pre">caps(_:)</span></code>呼び出しを以下のようなコードに変換します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">capsDrawing</span> = <span class="nv">caps</span> {
</li>
<li>    <span class="k">let</span> <span class="nv">partialDrawing</span>: <span class="nc">Drawable</span>
</li>
<li>    <span class="k">if</span> <span class="k">let</span> <span class="nv">name</span> = <span class="nv">name</span> {
</li>
<li>        <span class="k">let</span> <span class="nv">text</span> = <span class="nv">Text</span>(<span class="nv">name</span> + <span class="s">"!"</span>)
</li>
<li>        <span class="nv">partialDrawing</span> = <span class="nv">DrawingBuilder</span>.<span class="nv">buildEither</span>(<span class="nv">first</span>: <span class="nv">text</span>)
</li>
<li>    } <span class="k">else</span> {
</li>
<li>        <span class="k">let</span> <span class="nv">text</span> = <span class="nv">Text</span>(<span class="s">"World!"</span>)
</li>
<li>        <span class="nv">partialDrawing</span> = <span class="nv">DrawingBuilder</span>.<span class="nv">buildEither</span>(<span class="nv">second</span>: <span class="nv">text</span>)
</li>
<li>    }
</li>
<li>    <span class="k">return</span> <span class="nv">partialDrawing</span>
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">Swift transforms the <code class="docutils literal notranslate"><span class="pre">if</span></code>-<code class="docutils literal notranslate"><span class="pre">else</span></code> block into calls to the <code class="docutils literal notranslate"><span class="pre">buildEither(first:)</span></code> and <code class="docutils literal notranslate"><span class="pre">buildEither(second:)</span></code> methods. Although you don’t call these methods in your own code, showing the result of the transformation makes it easier to see how Swift transforms your code when you use the <code class="docutils literal notranslate"><span class="pre">DrawingBuilder</span></code> syntax.</span><!--end_enstr-->
<span class="jpstr">
スウィフトは、<code class="docutils literal notranslate"><span class="pre">if</span></code>-<code class="docutils literal notranslate"><span class="pre">else</span></code>ブロックを<code class="docutils literal notranslate"><span class="pre">buildEither(first:)</span></code>と<code class="docutils literal notranslate"><span class="pre">buildEither(second:)</span></code>メソッドへの呼び出しへと変換します。あなたがそれらのメソッドをあなた自身のコードにおいて呼び出さないとはいえ、変換の結果を見せることは、どのようにスウィフトがあなたのコードをあなたが<code class="docutils literal notranslate"><span class="pre">DrawingBuilder</span></code>構文を使う時に変換するかを理解しやすくします。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">To add support for writing <code class="docutils literal notranslate"><span class="pre">for</span></code> loops in the special drawing syntax, add a <code class="docutils literal notranslate"><span class="pre">buildArray(_:)</span></code> method.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">for</span></code>ループを書くサポートをこの特別な描画構文に加えるには、<code class="docutils literal notranslate"><span class="pre">buildArray(_:)</span></code>メソッドを加えてください。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">extension</span> <span class="nc">DrawingBuilder</span> {
</li>
<li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">buildArray</span>(<span class="k">_</span> <span class="nv">components</span>: [<span class="nc">Drawable</span>]) -&gt; <span class="nc">Drawable</span> {
</li>
<li>        <span class="k">return</span> <span class="nv">Line</span>(<span class="nv">elements</span>: <span class="nv">components</span>)
</li>
<li>    }
</li>
<li>}
</li>
<li>
<span class="k">let</span> <span class="nv">manyStars</span> = <span class="nv">draw</span> {
</li>
<li>    <span class="nv">Text</span>(<span class="s">"Stars:"</span>)
</li>
<li>    <span class="k">for</span> <span class="nv">length</span> <span class="k">in</span> <span class="m">1</span>...<span class="m">3</span> {
</li>
<li>        <span class="nv">Space</span>()
</li>
<li>        <span class="nv">Stars</span>(<span class="nv">length</span>: <span class="nv">length</span>)
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">In the code above, the <code class="docutils literal notranslate"><span class="pre">for</span></code> loop creates an array of drawings, and the <code class="docutils literal notranslate"><span class="pre">buildArray(_:)</span></code> method turns that array into a <code class="docutils literal notranslate"><span class="pre">Line</span></code>.</span><!--end_enstr-->
<span class="jpstr">
上のコードにおいて、<code class="docutils literal notranslate"><span class="pre">for</span></code>ループは描画それらからなるある配列を作成します、そして<code class="docutils literal notranslate"><span class="pre">buildArray(_:)</span></code>メソッドはその配列を<code class="docutils literal notranslate"><span class="pre">Line</span></code>へと変えます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">For a complete list of how Swift transforms builder syntax into calls to the builder type’s methods, see <a class="reference internal" href="../ReferenceManual/Attributes.html#ID633"><span class="std std-ref">resultBuilder</span></a>.</span><!--end_enstr-->
<span class="jpstr">
どのようにスウィフトがビルダー構文をビルダー型のもつメソッドそれらへと変換するかの完全な一覧として、<a class="reference internal" href="../ReferenceManual/Attributes.html#ID633"><span class="std std-ref">resultBuilder</span></a>を見てください。
</span><!--end_jpstr-->
</p>
</div>
</div>


    </article>
    <div class="next_previous">
        <p class="previous"><a href="AccessControl.html"><span class="enstr">Access Control</span><!--end_enstr-->
<span class="jpstr">
アクセス制御
</span><!--end_jpstr-->
</a></p>
        <p class="next"><a href="../ReferenceManual/AboutTheLanguageReference.html"><span class="enstr">About the Language Reference</span><!--end_enstr-->
<span class="jpstr">
言語リファレンスについて
</span><!--end_jpstr-->
</a></p>
    </div>
</main>


<footer role="contentinfo">
  <aside>
    <a href="//swift.org/atom.xml" title="Subscribe to Site Updates"><i class="feed">Subscribe</i></a>
    <a href="https://twitter.com/swiftlang" rel="nofollow" title="Follow @SwiftLang on Twitter"><i class="twitter">Twitter</i></a>
  </aside>

  <p class="copyright">Copyright © 2022 Apple Inc. All rights reserved.</p>
  <p class="trademark">Swift and the Swift logo are trademarks of Apple Inc.</p>
  <p class="privacy">
    <a href="//www.apple.com/privacy/privacy-policy/">Privacy Policy</a>
    <a href="//www.apple.com/legal/privacy/en-ww/cookies/">Cookies</a>
  </p>
</footer>
<div id="jump_to_overlay"></div>
<script src="../static/javascripts/application.js"></script>
  
</body>
</html>
