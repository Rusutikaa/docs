<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="author" content="Apple Inc.">
    <meta name="viewport" content="width=device-width initial-scale=1">
    
    <title>The Basics — The Swift Programming Language (Swift 5.6)</title>
    
    <link rel="license" href="/LICENSE.txt">
    <link rel="stylesheet" media="all" href="../static/stylesheets/application.css">
    <link rel="stylesheet" media="all" href="../static/stylesheets/tspl.css">
    <link rel="shortcut icon" sizes="16x16 24x24 32x32 48x48 64x64" type="image/vnd.microsoft.icon" href="/favicon.ico">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
    <link rel="mask-icon" href="/assets/images/icon-swift.svg" color="#F05339"> 
  </head>
  <body>


<nav role="navigation">
    <header role="banner">
      <h1 id="logo">
        <a href="https://swift.org/" title="Swift.org" role="img" aria-label="Swift.org">
          Swift.org
        </a>
      </h1>
    </header>

    <div id="menu-toggle" class="menu-toggle open"></div>

    <h2>The Swift Programming Language<div>Swift 5.6</div>
</h2>

    <ul>
    <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html"><span class="enstr">Welcome to Swift</span><!--end_enstr-->
<span class="jpstr">
スウィフトにようこそ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1 current">
<a class="reference internal" href="TheBasics.html"><span class="enstr">Language Guide</span><!--end_enstr-->
<span class="jpstr">
言語ガイド
</span><!--end_jpstr-->
</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#"><span class="enstr">The Basics</span><!--end_enstr-->
<span class="jpstr">
基本
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="BasicOperators.html"><span class="enstr">Basic Operators</span><!--end_enstr-->
<span class="jpstr">
基本の演算子
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="StringsAndCharacters.html"><span class="enstr">Strings and Characters</span><!--end_enstr-->
<span class="jpstr">
文字列と文字
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="CollectionTypes.html"><span class="enstr">Collection Types</span><!--end_enstr-->
<span class="jpstr">
コレクション型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ControlFlow.html"><span class="enstr">Control Flow</span><!--end_enstr-->
<span class="jpstr">
制御の流れ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Functions.html"><span class="enstr">Functions</span><!--end_enstr-->
<span class="jpstr">
関数
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Closures.html"><span class="enstr">Closures</span><!--end_enstr-->
<span class="jpstr">
クロージャ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Enumerations.html"><span class="enstr">Enumerations</span><!--end_enstr-->
<span class="jpstr">
列挙
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ClassesAndStructures.html"><span class="enstr">Structures and Classes</span><!--end_enstr-->
<span class="jpstr">
構造体とクラス
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Properties.html"><span class="enstr">Properties</span><!--end_enstr-->
<span class="jpstr">
プロパティ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Methods.html"><span class="enstr">Methods</span><!--end_enstr-->
<span class="jpstr">
メソッド
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Subscripts.html"><span class="enstr">Subscripts</span><!--end_enstr-->
<span class="jpstr">
添え字
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Inheritance.html"><span class="enstr">Inheritance</span><!--end_enstr-->
<span class="jpstr">
継承
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Initialization.html"><span class="enstr">Initialization</span><!--end_enstr-->
<span class="jpstr">
初期化
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Deinitialization.html"><span class="enstr">Deinitialization</span><!--end_enstr-->
<span class="jpstr">
デイニシャライズ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="OptionalChaining.html"><span class="enstr">Optional Chaining</span><!--end_enstr-->
<span class="jpstr">
オプショナル連鎖
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ErrorHandling.html"><span class="enstr">Error Handling</span><!--end_enstr-->
<span class="jpstr">
エラーの処理
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html"><span class="enstr">Concurrency</span><!--end_enstr-->
<span class="jpstr">
並行性
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="TypeCasting.html"><span class="enstr">Type Casting</span><!--end_enstr-->
<span class="jpstr">
型キャスト
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="NestedTypes.html"><span class="enstr">Nested Types</span><!--end_enstr-->
<span class="jpstr">
入れ子にされた型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Extensions.html"><span class="enstr">Extensions</span><!--end_enstr-->
<span class="jpstr">
拡張
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Protocols.html"><span class="enstr">Protocols</span><!--end_enstr-->
<span class="jpstr">
プロトコル
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Generics.html"><span class="enstr">Generics</span><!--end_enstr-->
<span class="jpstr">
総称体
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="OpaqueTypes.html"><span class="enstr">Opaque Types</span><!--end_enstr-->
<span class="jpstr">
不透明型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AutomaticReferenceCounting.html"><span class="enstr">Automatic Reference Counting</span><!--end_enstr-->
<span class="jpstr">
自動参照カウント
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="MemorySafety.html"><span class="enstr">Memory Safety</span><!--end_enstr-->
<span class="jpstr">
メモリ安全
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AccessControl.html"><span class="enstr">Access Control</span><!--end_enstr-->
<span class="jpstr">
アクセス制御
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AdvancedOperators.html"><span class="enstr">Advanced Operators</span><!--end_enstr-->
<span class="jpstr">
先進の演算子
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ReferenceManual/AboutTheLanguageReference.html"><span class="enstr">Language Reference</span><!--end_enstr-->
<span class="jpstr">
言語リファレンス
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1"><a class="reference internal" href="../RevisionHistory/RevisionHistory.html"><span class="enstr">Revision History</span><!--end_enstr-->
<span class="jpstr">
改訂履歴
</span><!--end_jpstr-->
</a></li>
</ul>

    <li class="toctree-l1 return"><a class="reference internal" href="../../../index.html">← Go to Index</a></li>
    </ul>
</nav>




<main role="main">
    <article class="page">
        <menu id="bashful" type="toolbar">
          <div class="inner">
            <menuitem id="jump_to" class="menu-bar-item closed">
            <span id="jump_to_toggle">On This Page</span>
            <div class="chevron">
                <div class="chevy chevron-left"></div>
                <div class="chevy chevron-right"></div>
            </div>
            <menu type="list" class="details">
<ul>
<li>
<a class="reference internal" href="#"><span class="enstr">The Basics</span><!--end_enstr-->
<span class="jpstr">
基本
</span><!--end_jpstr-->
</a><ul>
<li>
<a class="reference internal" href="#ID310"><span class="enstr">Constants and Variables</span><!--end_enstr-->
<span class="jpstr">
定数と変数
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID311"><span class="enstr">Declaring Constants and Variables</span><!--end_enstr-->
<span class="jpstr">
定数と変数の宣言
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID312"><span class="enstr">Type Annotations</span><!--end_enstr-->
<span class="jpstr">
さまざまな型注釈
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID313"><span class="enstr">Naming Constants and Variables</span><!--end_enstr-->
<span class="jpstr">
定数と変数に名をつける
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID314"><span class="enstr">Printing Constants and Variables</span><!--end_enstr-->
<span class="jpstr">
定数と変数を出力する
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID315"><span class="enstr">Comments</span><!--end_enstr-->
<span class="jpstr">
コメント
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID316"><span class="enstr">Semicolons</span><!--end_enstr-->
<span class="jpstr">
セミコロン
</span><!--end_jpstr-->
</a></li>
<li>
<a class="reference internal" href="#ID317"><span class="enstr">Integers</span><!--end_enstr-->
<span class="jpstr">
整数
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID318"><span class="enstr">Integer Bounds</span><!--end_enstr-->
<span class="jpstr">
整数の限界
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID319">Int</a></li>
<li><a class="reference internal" href="#ID320"><span class="enstr">UInt</span><!--end_enstr-->
<span class="jpstr">
符号なし整数（Unsigned Integer）
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID321"><span class="enstr">Floating-Point Numbers</span><!--end_enstr-->
<span class="jpstr">
浮動小数点数
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID322"><span class="enstr">Type Safety and Type Inference</span><!--end_enstr-->
<span class="jpstr">
型安全と型推論
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID323"><span class="enstr">Numeric Literals</span><!--end_enstr-->
<span class="jpstr">
数のリテラル
</span><!--end_jpstr-->
</a></li>
<li>
<a class="reference internal" href="#ID324"><span class="enstr">Numeric Type Conversion</span><!--end_enstr-->
<span class="jpstr">
数の型変換
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID325"><span class="enstr">Integer Conversion</span><!--end_enstr-->
<span class="jpstr">
整数変換
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID326"><span class="enstr">Integer and Floating-Point Conversion</span><!--end_enstr-->
<span class="jpstr">
整数と浮動小数点の変換
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID327"><span class="enstr">Type Aliases</span><!--end_enstr-->
<span class="jpstr">
型エイリアス
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID328"><span class="enstr">Booleans</span><!--end_enstr-->
<span class="jpstr">
ブール
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID329"><span class="enstr">Tuples</span><!--end_enstr-->
<span class="jpstr">
タプル
</span><!--end_jpstr-->
</a></li>
<li>
<a class="reference internal" href="#ID330"><span class="enstr">Optionals</span><!--end_enstr-->
<span class="jpstr">
オプショナル
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID331">nil</a></li>
<li><a class="reference internal" href="#ID332"><span class="enstr">If Statements and Forced Unwrapping</span><!--end_enstr-->
<span class="jpstr">
if文と強制アンラップ
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID333"><span class="enstr">Optional Binding</span><!--end_enstr-->
<span class="jpstr">
オプショナルを束縛する（定数・変数と結び付ける）
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID334"><span class="enstr">Implicitly Unwrapped Optionals</span><!--end_enstr-->
<span class="jpstr">
暗黙的にアンラップされるオプショナル
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID515"><span class="enstr">Error Handling</span><!--end_enstr-->
<span class="jpstr">
エラーの処理
</span><!--end_jpstr-->
</a></li>
<li>
<a class="reference internal" href="#ID335"><span class="enstr">Assertions and Preconditions</span><!--end_enstr-->
<span class="jpstr">
表明と前提条件
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID336"><span class="enstr">Debugging with Assertions</span><!--end_enstr-->
<span class="jpstr">
表明を使ってデバッグする
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID554"><span class="enstr">Enforcing Preconditions</span><!--end_enstr-->
<span class="jpstr">
前提条件の遵守
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
                </menu>
            </menuitem>
          </div>
        </menu>

        
  <div class="section" id="the-basics">
<h1><span class="enstr">The Basics<a class="headerlink" href="#the-basics" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
基本<a class="headerlink" href="#the-basics" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h1>
<p><span class="enstr">Swift is a new programming language for iOS, macOS, watchOS, and tvOS app development. Nonetheless, many parts of Swift will be familiar from your experience of developing in C and Objective-C.</span><!--end_enstr-->
<span class="jpstr">
スウィフトは、iOS、macOS、watchOS、そしてtvOSアプリ開発のための新しいプログラミング言語です。にもかかわらず、スウィフトの多くの部分は、あなたのCとObjective-Cでの開発経験からきっとお馴染みのものでしょう。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Swift provides its own versions of all fundamental C and Objective-C types, including <code class="docutils literal notranslate"><span class="pre">Int</span></code> for integers, <code class="docutils literal notranslate"><span class="pre">Double</span></code> and <code class="docutils literal notranslate"><span class="pre">Float</span></code> for floating-point values, <code class="docutils literal notranslate"><span class="pre">Bool</span></code> for Boolean values, and <code class="docutils literal notranslate"><span class="pre">String</span></code> for textual data. Swift also provides powerful versions of the three primary collection types, <code class="docutils literal notranslate"><span class="pre">Array</span></code>, <code class="docutils literal notranslate"><span class="pre">Set</span></code>, and <code class="docutils literal notranslate"><span class="pre">Dictionary</span></code>, as described in <a class="reference internal" href="CollectionTypes.html"><span class="doc">Collection Types</span></a>.</span><!--end_enstr-->
<span class="jpstr">
スウィフトは、全ての基本的なCおよびObjective-C型に関してそれ自身のバージョンを提供します、それには、整数のための<code class="docutils literal notranslate"><span class="pre">Int</span></code>、浮動小数点値のための<code class="docutils literal notranslate"><span class="pre">Double</span></code>と<code class="docutils literal notranslate"><span class="pre">Float</span></code>、ブール値のための<code class="docutils literal notranslate"><span class="pre">Bool</span></code>、そして、文字情報データのための<code class="docutils literal notranslate"><span class="pre">String</span></code>を含みます。スウィフトはまた、３つの主要なコレクション型、<code class="docutils literal notranslate"><span class="pre">Array</span></code>、<code class="docutils literal notranslate"><span class="pre">Set</span></code>、そして<code class="docutils literal notranslate"><span class="pre">Dictionary</span></code>の強力なバージョンを提供します、それは<a class="reference internal" href="CollectionTypes.html"><span class="doc">「コレクション型」</span></a>で記述されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Like C, Swift uses variables to store and refer to values by an identifying name. Swift also makes extensive use of variables whose values can’t be changed. These are known as constants, and are much more powerful than constants in C. Constants are used throughout Swift to make code safer and clearer in intent when you work with values that don’t need to change.</span><!--end_enstr-->
<span class="jpstr">
Cのように、スウィフトはひとつの識別名によっていろいろな値を保管したり引用したりするために、変数を使います。スウィフトはまた、それの値が変更されることができない変数を広範囲に利用します。これらは定数として知られています、そしてCにおける定数よりずっと強力です。定数は、変わる必要がない値をあなたが扱う時、コードをより安全により明白にする意図でスウィフトを通して使われます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">In addition to familiar types, Swift introduces advanced types not found in Objective-C, such as tuples. Tuples enable you to create and pass around groupings of values. You can use a tuple to return multiple values from a function as a single compound value.</span><!--end_enstr-->
<span class="jpstr">
よく知られている型に加えて、スウィフトはObjective-Cで見られない先進の型を導入します、例えばタプルのような。タプルは、あなたに値のグループをつくってあちこち渡すことを可能にします。あなたはタプルを使って、関数から複数の値を１つの混成値として返すことができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Swift also introduces optional types, which handle the absence of a value. Optionals say either “there <em>is</em> a value, and it equals <em>x</em>” or “there <em>isn’t</em> a value at all”. Using optionals is similar to using <code class="docutils literal notranslate"><span class="pre">nil</span></code> with pointers in Objective-C, but they work for any type, not just classes. Not only are optionals safer and more expressive than <code class="docutils literal notranslate"><span class="pre">nil</span></code> pointers in Objective-C, they’re at the heart of many of Swift’s most powerful features.</span><!--end_enstr-->
<span class="jpstr">
スウィフトはまたオプショナルの型を導入します、それは値の欠如を取り扱います。オプショナルであるものは、「ひとつの値が<em>ある</em>、そしてそれは<em>x</em>に等しい」または「まったく値が<em>ない</em>」のどちらかを伝えます。オプショナルの使用は、Objective-Cのポインターで<code class="docutils literal notranslate"><span class="pre">nil</span></code>を使うことに似ています、しかしそれは、ただクラスだけでなく、どんな型のためにでも働きます。オプショナルはObjective-Cでの<code class="docutils literal notranslate"><span class="pre">nil</span></code>ポインターより安全でさらに表現豊かであるだけでなく、それはスウィフトのたくさんある非常に強力な特徴のうち核心的なものです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Swift is a <em>type-safe</em> language, which means the language helps you to be clear about the types of values your code can work with. If part of your code requires a <code class="docutils literal notranslate"><span class="pre">String</span></code>, type safety prevents you from passing it an <code class="docutils literal notranslate"><span class="pre">Int</span></code> by mistake. Likewise, type safety prevents you from accidentally passing an optional <code class="docutils literal notranslate"><span class="pre">String</span></code> to a piece of code that requires a non-optional <code class="docutils literal notranslate"><span class="pre">String</span></code>. Type safety helps you catch and fix errors as early as possible in the development process.</span><!--end_enstr-->
<span class="jpstr">
スウィフトは<em>型安全</em>な言語です、それが意味するのは、この言語があなたを助けて、あなたのコードが扱うことができる値の型について明確であるようにすることです。あなたのコードの一部が<code class="docutils literal notranslate"><span class="pre">String</span></code>を要求するならば、型安全はあなたが間違ってそれに<code class="docutils literal notranslate"><span class="pre">Int</span></code>を渡すことを防ぎます。さらに、型安全はあなたがうっかりしてオプショナル<code class="docutils literal notranslate"><span class="pre">String</span></code>を、非オプショナル<code class="docutils literal notranslate"><span class="pre">String</span></code>を要求するコード部分に渡すことを防ぎます。型安全は、あなたが開発プロセスにおいて可能な限り早期にエラーを捕まえて修復するのを助けます。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID310">
<h2><span class="enstr">Constants and Variables<a class="headerlink" href="#ID310" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
定数と変数<a class="headerlink" href="#ID310" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">Constants and variables associate a name (such as <code class="docutils literal notranslate"><span class="pre">maximumNumberOfLoginAttempts</span></code> or <code class="docutils literal notranslate"><span class="pre">welcomeMessage</span></code>) with a value of a particular type (such as the number <code class="docutils literal notranslate"><span class="pre">10</span></code> or the string <code class="docutils literal notranslate"><span class="pre">"Hello"</span></code>). The value of a <em>constant</em> can’t be changed once it’s set, whereas a <em>variable</em> can be set to a different value in the future.</span><!--end_enstr-->
<span class="jpstr">
定数と変数は、ひとつの名前（例えば<code class="docutils literal notranslate"><span class="pre">maximumNumberOfLoginAttempts</span></code>または<code class="docutils literal notranslate"><span class="pre">welcomeMessage</span></code>など）を特定の型のひとつの値（例えば数<code class="docutils literal notranslate"><span class="pre">10</span></code>または文字列<code class="docutils literal notranslate"><span class="pre">"Hello"</span></code>など）と結びつけます。<em>定数</em>の値は、一旦それが設定されるならば変わることができません、一方で<em>変数</em>は将来異なる値に設定されることができます。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID311">
<h3><span class="enstr">Declaring Constants and Variables<a class="headerlink" href="#ID311" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
定数と変数の宣言<a class="headerlink" href="#ID311" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">Constants and variables must be declared before they’re used. You declare constants with the <code class="docutils literal notranslate"><span class="pre">let</span></code> keyword and variables with the <code class="docutils literal notranslate"><span class="pre">var</span></code> keyword. Here’s an example of how constants and variables can be used to track the number of login attempts a user has made:</span><!--end_enstr-->
<span class="jpstr">
定数と変数は、それらが使われる前に宣言されなければなりません。あなたは、<code class="docutils literal notranslate"><span class="pre">let</span></code>キーワードを使って定数を、<code class="docutils literal notranslate"><span class="pre">var</span></code>キーワードを使って変数を宣言します。ここに定数と変数が、どのようにあるユーザーが行ったログインの試みの数を追跡するために使われることができるかの例があります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">maximumNumberOfLoginAttempts</span> = <span class="m">10</span>
</li>
<li>
<span class="k">var</span> <span class="nv">currentLoginAttempt</span> = <span class="m">0</span>
</li>
</ol></div></div></div>
<p><span class="enstr">This code can be read as:</span><!--end_enstr-->
<span class="jpstr">
このコードは、次のように解釈されることができます：
</span><!--end_jpstr-->
</p>
<p><span class="enstr">“Declare a new constant called <code class="docutils literal notranslate"><span class="pre">maximumNumberOfLoginAttempts</span></code>, and give it a value of <code class="docutils literal notranslate"><span class="pre">10</span></code>. Then, declare a new variable called <code class="docutils literal notranslate"><span class="pre">currentLoginAttempt</span></code>, and give it an initial value of <code class="docutils literal notranslate"><span class="pre">0</span></code>.”</span><!--end_enstr-->
<span class="jpstr">
「<code class="docutils literal notranslate"><span class="pre">maximumNumberOfLoginAttempts</span></code>と呼ばれるある新しい定数を宣言して、それに<code class="docutils literal notranslate"><span class="pre">10</span></code>というひとつの値を与える。その後で、<code class="docutils literal notranslate"><span class="pre">currentLoginAttempt</span></code>と呼ばれる新しい変数を宣言して、それに<code class="docutils literal notranslate"><span class="pre">0</span></code>の初期値を与える。」
</span><!--end_jpstr-->
</p>
<p><span class="enstr">In this example, the maximum number of allowed login attempts is declared as a constant, because the maximum value never changes. The current login attempt counter is declared as a variable, because this value must be incremented after each failed login attempt.</span><!--end_enstr-->
<span class="jpstr">
この例において、許可されるログインの試みの最大数は、最大の値が決して変わらないので、定数として宣言されます。現在のログイン試行の計数は、この値が失敗したログインの試みそれぞれの後で増加する必要があるので、変数として宣言されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can declare multiple constants or multiple variables on a single line, separated by commas:</span><!--end_enstr-->
<span class="jpstr">
あなたは複数の定数または複数の変数を、コンマで区切ることで１つの行に宣言することができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="k">var</span> <span class="nv">x</span> = <span class="m">0.0</span>, <span class="nv">y</span> = <span class="m">0.0</span>, <span class="nv">z</span> = <span class="m">0.0</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">If a stored value in your code won’t change, always declare it as a constant with the <code class="docutils literal notranslate"><span class="pre">let</span></code> keyword. Use variables only for storing values that need to be able to change.</span><!--end_enstr-->
<span class="jpstr">
ある格納された値をあなたのコードにおいて変化させる予定がないならば、常に<code class="docutils literal notranslate"><span class="pre">let</span></code>キーワードを使ってそれを定数として宣言してください。変更できる必要がある値を保存するためにだけ、変数を使ってください。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID312">
<h3><span class="enstr">Type Annotations<a class="headerlink" href="#ID312" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
さまざまな型注釈<a class="headerlink" href="#ID312" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">You can provide a <em>type annotation</em> when you declare a constant or variable, to be clear about the kind of values the constant or variable can store. Write a type annotation by placing a colon after the constant or variable name, followed by a space, followed by the name of the type to use.</span><!--end_enstr-->
<span class="jpstr">
あなたは、あなたが定数または変数を宣言するとき、その定数または変数が格納することができる値の種類について明確にするために、<em>型注釈</em>を提供することができます。定数か変数の名前のあとにコロンを置いて、１つの空白に続き、使用する型の名前を続けることによって型注釈を書いてください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">This example provides a type annotation for a variable called <code class="docutils literal notranslate"><span class="pre">welcomeMessage</span></code>, to indicate that the variable can store <code class="docutils literal notranslate"><span class="pre">String</span></code> values:</span><!--end_enstr-->
<span class="jpstr">
この例は、<code class="docutils literal notranslate"><span class="pre">welcomeMessage</span></code>と呼ばれる変数に対して、その変数は<code class="docutils literal notranslate"><span class="pre">String</span></code>値を格納できることを示すために型注釈を提供します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="k">var</span> <span class="nv">welcomeMessage</span>: <span class="nc">String</span>
</li></ol></div></div></div>
<p><span class="enstr">The colon in the declaration means “…of type…,” so the code above can be read as:</span><!--end_enstr-->
<span class="jpstr">
宣言でのコロンは「…の型の…」を意味します、それで上のコードは次のように読まれることができます：
</span><!--end_jpstr-->
</p>
<p><span class="enstr">“Declare a variable called <code class="docutils literal notranslate"><span class="pre">welcomeMessage</span></code> that’s of type <code class="docutils literal notranslate"><span class="pre">String</span></code>.”</span><!--end_enstr-->
<span class="jpstr">
「<code class="docutils literal notranslate"><span class="pre">welcomeMessage</span></code>と呼ばれる型<code class="docutils literal notranslate"><span class="pre">String</span></code>の変数を宣言する。」
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The phrase “of type <code class="docutils literal notranslate"><span class="pre">String</span></code>” means “can store any <code class="docutils literal notranslate"><span class="pre">String</span></code> value.” Think of it as meaning “the type of thing” (or “the kind of thing”) that can be stored.</span><!--end_enstr-->
<span class="jpstr">
フレーズ「型<code class="docutils literal notranslate"><span class="pre">String</span></code>の」は、「どんな<code class="docutils literal notranslate"><span class="pre">String</span></code>値でも格納することができる」ことを意味します。それを、格納されることができる「物の型」（または「物の種類」）の意味と思ってください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">welcomeMessage</span></code> variable can now be set to any string value without error:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">welcomeMessage</span></code>変数は、現在エラーなしでどんな文字列値にでも設定されることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="nv">welcomeMessage</span> = <span class="s">"Hello"</span>
</li></ol></div></div></div>
<p><span class="enstr">You can define multiple related variables of the same type on a single line, separated by commas, with a single type annotation after the final variable name:</span><!--end_enstr-->
<span class="jpstr">
あなたは同じ型の複数の関連した変数を、１行上に、コンマで区切って、型注釈を１つだけ最後の変数名の後につけて、定義することができます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="k">var</span> <span class="nv">red</span>, <span class="nv">green</span>, <span class="nv">blue</span>: <span class="nc">Double</span>
</li></ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">It’s rare that you need to write type annotations in practice. If you provide an initial value for a constant or variable at the point that it’s defined, Swift can almost always infer the type to be used for that constant or variable, as described in <a class="reference internal" href="#ID322"><span class="std std-ref">Type Safety and Type Inference</span></a>. In the <code class="docutils literal notranslate"><span class="pre">welcomeMessage</span></code> example above, no initial value is provided, and so the type of the <code class="docutils literal notranslate"><span class="pre">welcomeMessage</span></code> variable is specified with a type annotation rather than being inferred from an initial value.</span><!--end_enstr-->
<span class="jpstr">
あなたが型注釈を書く必要があることは実際問題として、まれです。あなたが最初の値を定数または変数に、それが定義される時点で提供するならば、スウィフトはたいていその定数または変数のために使われる型を推測することが、<a class="reference internal" href="#ID322"><span class="std std-ref">「型安全と型推論」</span></a>で記述されるように可能です。上の<code class="docutils literal notranslate"><span class="pre">welcomeMessage</span></code>の例では、初期値が提供されません、それで<code class="docutils literal notranslate"><span class="pre">welcomeMessage</span></code>変数の型は、最初の値から推論されるのではなく、型注釈で指定されます。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID313">
<h3><span class="enstr">Naming Constants and Variables<a class="headerlink" href="#ID313" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
定数と変数に名をつける<a class="headerlink" href="#ID313" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">Constant and variable names can contain almost any character, including Unicode characters:</span><!--end_enstr-->
<span class="jpstr">
定数と変数の名前は、ユニコード文字を含めて、ほとんどどんな文字でも含むことができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">π</span> = <span class="m">3.14159</span>
</li>
<li>
<span class="k">let</span> <span class="nv">你好</span> = <span class="s">"你好世界"</span>
</li>
<li>
<span class="k">let</span> <span class="nv">🐶🐮</span> = <span class="s">"dogcow"</span>
</li>
</ol></div></div></div>
<p><span class="enstr">Constant and variable names can’t contain whitespace characters, mathematical symbols, arrows, private-use Unicode scalar values, or line- and box-drawing characters. Nor can they begin with a number, although numbers may be included elsewhere within the name.</span><!--end_enstr-->
<span class="jpstr">
定数と変数の名前は、空白文字、数学記号、矢印、私的使用Unicodeスカラー値、または罫線文字を含むことができません。そしてそれらは数字から始まることもできません、けれども数字が名前内のどこか他で含まれることはできます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Once you’ve declared a constant or variable of a certain type, you can’t declare it again with the same name, or change it to store values of a different type. Nor can you change a constant into a variable or a variable into a constant.</span><!--end_enstr-->
<span class="jpstr">
一旦あなたが特定の型のある定数または変数を宣言してしまったならば、あなたは同じ名前でもう一度それを宣言し直すこと、またはそれを異なる型の値を格納するように変更することは出来ません。そして、あなたはある定数を変数に、またはある変数を定数に変更することもできません。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">If you need to give a constant or variable the same name as a reserved Swift keyword, surround the keyword with backticks (<code class="docutils literal notranslate"><span class="pre">`</span></code>) when using it as a name. However, avoid using keywords as names unless you have absolutely no choice.</span><!--end_enstr-->
<span class="jpstr">
あなたが予約済みのスウィフトのキーワードと同じ名前を定数または変数に与える必要があるならば、名前としてそれを使うときバッククォート（<code class="docutils literal notranslate"><span class="pre">`</span></code>）でそのキーワードを囲んでください。しかし、あなたに選択が全くない場合を除き、キーワードをなんらかの名前として使用することを避けてください。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">You can change the value of an existing variable to another value of a compatible type. In this example, the value of <code class="docutils literal notranslate"><span class="pre">friendlyWelcome</span></code> is changed from <code class="docutils literal notranslate"><span class="pre">"Hello!"</span></code> to <code class="docutils literal notranslate"><span class="pre">"Bonjour!"</span></code>:</span><!--end_enstr-->
<span class="jpstr">
あなたは、既存の変数の値を、別の互換性を持つ型の値に変えることができます。この例では、<code class="docutils literal notranslate"><span class="pre">friendlyWelcome</span></code>の値は、<code class="docutils literal notranslate"><span class="pre">"Hello!"</span></code>から<code class="docutils literal notranslate"><span class="pre">"Bonjour!"</span></code>に変えられます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">var</span> <span class="nv">friendlyWelcome</span> = <span class="s">"Hello!"</span>
</li>
<li>
<span class="nv">friendlyWelcome</span> = <span class="s">"Bonjour!"</span>
</li>
<li>
<span class="c"><span class="enstr">// friendlyWelcome is now "Bonjour!"</span><!--end_enstr--><span class="jpstr">（friendlyWelcomeは、現在「Bonjour!」です）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">Unlike a variable, the value of a constant can’t be changed after it’s set. Attempting to do so is reported as an error when your code is compiled:</span><!--end_enstr-->
<span class="jpstr">
変数とは異なり、それが設定された後で定数の値は変更できません。そうしようとすることは、あなたのコードがコンパイルされる時にエラーとして報告されます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">languageName</span> = <span class="s">"Swift"</span>
</li>
<li>
<span class="nv">languageName</span> = <span class="s">"Swift++"</span>
</li>
<li>
<span class="c"><span class="enstr">// This is a compile-time error: languageName cannot be changed.</span><!--end_enstr--><span class="jpstr">（これはコンパイル時エラーです：anguageNameは変わることができません。）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
</div>
<div class="section" id="ID314">
<h3><span class="enstr">Printing Constants and Variables<a class="headerlink" href="#ID314" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
定数と変数を出力する<a class="headerlink" href="#ID314" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">You can print the current value of a constant or variable with the <code class="docutils literal notranslate"><span class="pre">print(_:separator:terminator:)</span></code> function:</span><!--end_enstr-->
<span class="jpstr">
あなたは、<code class="docutils literal notranslate"><span class="pre">print(_:separator:terminator:)</span></code>関数で定数または変数の現在の値を出力することができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="nv">print</span>(<span class="nv">friendlyWelcome</span>)
</li>
<li>
<span class="c"><span class="enstr">// Prints "Bonjour!"</span><!--end_enstr--><span class="jpstr">（「Bonjour!」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">print(_:separator:terminator:)</span></code> function is a global function that prints one or more values to an appropriate output. In Xcode, for example, the <code class="docutils literal notranslate"><span class="pre">print(_:separator:terminator:)</span></code> function prints its output in Xcode’s “console” pane. The <code class="docutils literal notranslate"><span class="pre">separator</span></code> and <code class="docutils literal notranslate"><span class="pre">terminator</span></code> parameter have default values, so you can omit them when you call this function. By default, the function terminates the line it prints by adding a line break. To print a value without a line break after it, pass an empty string as the terminator—for example, <code class="docutils literal notranslate"><span class="pre">print(someValue,</span> <span class="pre">terminator:</span> <span class="pre">"")</span></code>. For information about parameters with default values, see <a class="reference internal" href="Functions.html#ID169"><span class="std std-ref">Default Parameter Values</span></a>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">print(_:separator:terminator:)</span></code>関数は、ひとつ以上の値を適切な出力先に出力するグローバルな関数です。例えば、Xcodeでは、<code class="docutils literal notranslate"><span class="pre">print(_:separator:terminator:)</span></code>関数はその出力をXcodeの「コンソール」枠に表示します。<code class="docutils literal notranslate"><span class="pre">separator</span></code>と<code class="docutils literal notranslate"><span class="pre">terminator</span></code>パラメータは省略時の値を持ちます、それであなたはそれらを省略することが、この関数をあなたが呼び出す時に可能です。初期状態では、この関数はそれが出力する行を改行を加えて終わります。ある値をそれの後に改行なしで出力するには、空の文字列を終端子（ターミネータ）として渡してください ― 例えば、<code class="docutils literal notranslate"><span class="pre">print(someValue,</span> <span class="pre">terminator:</span> <span class="pre">"")</span></code>。省略時の値を持つパラメータについての情報として、<a class="reference internal" href="Functions.html#ID169"><span class="std std-ref">省略時のパラメータ値</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Swift uses <em>string interpolation</em> to include the name of a constant or variable as a placeholder in a longer string, and to prompt Swift to replace it with the current value of that constant or variable. Wrap the name in parentheses and escape it with a backslash before the opening parenthesis:</span><!--end_enstr-->
<span class="jpstr">
スウィフトは、定数または変数の名前をより長い文字列の中にプレースホルダーとして含めるために、そしてそれをその定数または変数の現在の値と取り替えることをスウィフトに促すために、<em>文字列補間</em>を使います。丸括弧にその名前を包んで、始めの括弧の前のバックスラッシュでそれをエスケープします：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="nv">print</span>(<span class="s">"The current value of friendlyWelcome is </span>\<span class="p">(</span><span class="nv">friendlyWelcome</span><span class="p">)</span><span class="s">"</span>)
</li>
<li>
<span class="c"><span class="enstr">// Prints "The current value of friendlyWelcome is Bonjour!"</span><!--end_enstr--><span class="jpstr">（「The current value of friendlyWelcome is Bonjour!」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">All options you can use with string interpolation are described in <a class="reference internal" href="StringsAndCharacters.html#ID292"><span class="std std-ref">String Interpolation</span></a>.</span><!--end_enstr-->
<span class="jpstr">
あなたが文字列補間で使うことができるオプション全ては、<a class="reference internal" href="StringsAndCharacters.html#ID292"><span class="std std-ref">「文字列補間」</span></a>で記述されます。
</span><!--end_jpstr-->
</p>
</div>
</div>
</div>
<div class="section" id="ID315">
<h2><span class="enstr">Comments<a class="headerlink" href="#ID315" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
コメント<a class="headerlink" href="#ID315" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">Use comments to include nonexecutable text in your code, as a note or reminder to yourself. Comments are ignored by the Swift compiler when your code is compiled.</span><!--end_enstr-->
<span class="jpstr">
あなた自身への注意事項または覚え書きとして、実行可能でないテキストをあなたのコードに含めるために、コメントを使ってください。あなたのコードがコンパイルされるとき、コメントはスウィフトのコンパイラによって無視されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Comments in Swift are very similar to comments in C. Single-line comments begin with two forward-slashes (<code class="docutils literal notranslate"><span class="pre">//</span></code>):</span><!--end_enstr-->
<span class="jpstr">
スウィフトのコメントは、Cのコメントに非常に似ています。一行コメントは２つのスラッシュで始まります（<code class="docutils literal notranslate"><span class="pre">//</span></code>）：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="c"><span class="enstr">// This is a comment.</span><!--end_enstr--><span class="jpstr">（これはコメントです。）</span><!--end_jpstr--></span>
</li></ol></div></div></div>
<p><span class="enstr">Multiline comments start with a forward-slash followed by an asterisk (<code class="docutils literal notranslate"><span class="pre">/*</span></code>) and end with an asterisk followed by a forward-slash (<code class="docutils literal notranslate"><span class="pre">*/</span></code>):</span><!--end_enstr-->
<span class="jpstr">
複数行コメントは、スラッシュに続く星印（<code class="docutils literal notranslate"><span class="pre">/*</span></code>）で始まり、星印に続くスラッシュ（<code class="docutils literal notranslate"><span class="pre">*/</span></code>）で終わります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="c">/* <span class="enstr">This is also a comment</span><!--end_enstr-->
<span class="jpstr">
（これもコメントです）
</span><!--end_jpstr-->
</span>
</li>
<li>
<span class="c"><span class="enstr">but is written over multiple lines.</span><!--end_enstr--><span class="jpstr">（しかし複数行にわたって書かれます。）</span><!--end_jpstr--> */</span>
</li>
</ol></div></div></div>
<p><span class="enstr">Unlike multiline comments in C, multiline comments in Swift can be nested inside other multiline comments. You write nested comments by starting a multiline comment block and then starting a second multiline comment within the first block. The second block is then closed, followed by the first block:</span><!--end_enstr-->
<span class="jpstr">
Cでの複数行コメントと違って、スウィフトの複数行コメントは他の複数行コメント内部に入れ子にされることができます。あなたはひとつの複数行コメント・ブロックを始めて、それから第二の複数行を最初のブロック以内に始めることによって入れ子にされたコメントを書きます。第二のブロックはそれから閉じられます、そして最初のブロックが続きます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="c">/* <span class="enstr">This is the start of the first multiline comment.</span><!--end_enstr-->
<span class="jpstr">
（最初の複数行コメントの始まり。）
</span><!--end_jpstr-->
</span>
</li>
<li>
<span class="c"> /*<span class="enstr">This is the second, nested multiline comment.</span><!--end_enstr--><span class="jpstr">（第二の入れ子の複数行コメント。）</span><!--end_jpstr--> */</span>
</li>
<li>
<span class="c"><span class="enstr">This is the end of the first multiline comment.</span><!--end_enstr--><span class="jpstr">（最初の複数行コメントの終わり。）</span><!--end_jpstr--> */</span>
</li>
</ol></div></div></div>
<p><span class="enstr">Nested multiline comments enable you to comment out large blocks of code quickly and easily, even if the code already contains multiline comments.</span><!--end_enstr-->
<span class="jpstr">
入れ子にされた複数行コメントによって、たとえコードがすでに複数行コメントを含むとしても、あなたは速く簡単にコードの大きなブロックをコメントアウトすることが可能になります。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID316">
<h2><span class="enstr">Semicolons<a class="headerlink" href="#ID316" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
セミコロン<a class="headerlink" href="#ID316" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">Unlike many other languages, Swift doesn’t require you to write a semicolon (<code class="docutils literal notranslate"><span class="pre">;</span></code>) after each statement in your code, although you can do so if you wish. However, semicolons <em>are</em> required if you want to write multiple separate statements on a single line:</span><!--end_enstr-->
<span class="jpstr">
多くの他の言語とは異なり、スウィフトはあなたにあなたのコードにおいて各文の後にセミコロン（<code class="docutils literal notranslate"><span class="pre">;</span></code>）を書くことを要求しません、けれどもあなたが望むならば、あなたはそうできます。それにもかかわらず、セミコロンは必要と<em>されます</em>、もしあなたが１つの行に複数の別々の文を書きたい場合には：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">cat</span> = <span class="s">"🐱"</span>; <span class="nv">print</span>(<span class="nv">cat</span>)
</li>
<li>
<span class="c">// Prints "🐱"</span>
</li>
</ol></div></div></div>
</div>
<div class="section" id="ID317">
<h2><span class="enstr">Integers<a class="headerlink" href="#ID317" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
整数<a class="headerlink" href="#ID317" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr"><em>Integers</em> are whole numbers with no fractional component, such as <code class="docutils literal notranslate"><span class="pre">42</span></code> and <code class="docutils literal notranslate"><span class="pre">-23</span></code>. Integers are either <em>signed</em> (positive, zero, or negative) or <em>unsigned</em> (positive or zero).</span><!--end_enstr-->
<span class="jpstr">
<em>整数</em>は、小数部分のない数すべてです、例えば<code class="docutils literal notranslate"><span class="pre">42</span></code>や<code class="docutils literal notranslate"><span class="pre">-23</span></code>など。整数は、<em>符号つき</em>（正、ゼロ、または負）または<em>符号なし</em>（正またはゼロ）のどちらかです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Swift provides signed and unsigned integers in 8, 16, 32, and 64 bit forms. These integers follow a naming convention similar to C, in that an 8-bit unsigned integer is of type <code class="docutils literal notranslate"><span class="pre">UInt8</span></code>, and a 32-bit signed integer is of type <code class="docutils literal notranslate"><span class="pre">Int32</span></code>. Like all types in Swift, these integer types have capitalized names.</span><!--end_enstr-->
<span class="jpstr">
スウィフトは、８、16、32、そして64ビット形式で、符号つきおよび符号なし整数を提供します。これらの整数は、８ビットの符号なし整数が型<code class="docutils literal notranslate"><span class="pre">UInt8</span></code>である、そして32ビットの符号つき整数が型<code class="docutils literal notranslate"><span class="pre">Int32</span></code>であるという点で、Cに似ている命名規則に従います。スウィフトにおける全ての型のように、これらの整数型は頭文字を使った名前を持ちます。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID318">
<h3><span class="enstr">Integer Bounds<a class="headerlink" href="#ID318" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
整数の限界<a class="headerlink" href="#ID318" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">You can access the minimum and maximum values of each integer type with its <code class="docutils literal notranslate"><span class="pre">min</span></code> and <code class="docutils literal notranslate"><span class="pre">max</span></code> properties:</span><!--end_enstr-->
<span class="jpstr">
あなたは、その<code class="docutils literal notranslate"><span class="pre">min</span></code>と<code class="docutils literal notranslate"><span class="pre">max</span></code>プロパティで各整数型の最小と最大の値を得ることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">minValue</span> = <span class="nv">UInt8</span>.<span class="nv">min</span>  <span class="enstr"><span class="c">// minValue is equal to 0, and is of type UInt8</span></span><!--end_enstr--><span class="jpstr"><span class="c">（minValuesは0に等しく、そしてUInt8型です）</span></span><!--end_jpstr--></li>
<li>
<span class="k">let</span> <span class="nv">maxValue</span> = <span class="nv">UInt8</span>.<span class="nv">max</span>  <span class="enstr"><span class="c">// maxValue is equal to 255, and is of type UInt8</span></span><!--end_enstr--><span class="jpstr"><span class="c">（maxValuesは255に等しく、そしてUInt8型です）</span></span><!--end_jpstr--></li>
</ol></div></div></div>
<p><span class="enstr">The values of these properties are of the appropriate-sized number type (such as <code class="docutils literal notranslate"><span class="pre">UInt8</span></code> in the example above) and can therefore be used in expressions alongside other values of the same type.</span><!--end_enstr-->
<span class="jpstr">
これらのプロパティの値は、適切なサイズの数の型（例えば上の例での<code class="docutils literal notranslate"><span class="pre">UInt8</span></code>）であり、したがって、式の中で同じ型の他の値と並べて使われることができます。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID319">
<h3>Int<a class="headerlink" href="#ID319" title="Permalink to this headline">¶</a>
</h3>
<p><span class="enstr">In most cases, you don’t need to pick a specific size of integer to use in your code. Swift provides an additional integer type, <code class="docutils literal notranslate"><span class="pre">Int</span></code>, which has the same size as the current platform’s native word size:</span><!--end_enstr-->
<span class="jpstr">
ほとんどの場合、あなたはあなたのコードにおいて使用するのに整数の特定のサイズを選択する必要はありません。スウィフトは追加の整数型、<code class="docutils literal notranslate"><span class="pre">Int</span></code>を提供します、そしてそれは、現在のプラットホーム固有のワードサイズと同じ大きさを持ちます：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li><span class="enstr">On a 32-bit platform, <code class="docutils literal notranslate"><span class="pre">Int</span></code> is the same size as <code class="docutils literal notranslate"><span class="pre">Int32</span></code>.</span><!--end_enstr-->
<span class="jpstr">
32ビットのプラットホーム上で、<code class="docutils literal notranslate"><span class="pre">Int</span></code>は<code class="docutils literal notranslate"><span class="pre">Int32</span></code>と同じサイズです。
</span><!--end_jpstr-->
</li>
<li><span class="enstr">On a 64-bit platform, <code class="docutils literal notranslate"><span class="pre">Int</span></code> is the same size as <code class="docutils literal notranslate"><span class="pre">Int64</span></code>.</span><!--end_enstr-->
<span class="jpstr">
64ビットのプラットホーム上で、<code class="docutils literal notranslate"><span class="pre">Int</span></code>は<code class="docutils literal notranslate"><span class="pre">Int64</span></code>と同じサイズです。
</span><!--end_jpstr-->
</li>
</ul>
<p><span class="enstr">Unless you need to work with a specific size of integer, always use <code class="docutils literal notranslate"><span class="pre">Int</span></code> for integer values in your code. This aids code consistency and interoperability. Even on 32-bit platforms, <code class="docutils literal notranslate"><span class="pre">Int</span></code> can store any value between <code class="docutils literal notranslate"><span class="pre">-2,147,483,648</span></code> and <code class="docutils literal notranslate"><span class="pre">2,147,483,647</span></code>, and is large enough for many integer ranges.</span><!--end_enstr-->
<span class="jpstr">
あなたが整数の特定のサイズを扱う必要がない限り、常に、あなたのコードの整数値のために<code class="docutils literal notranslate"><span class="pre">Int</span></code>を使ってください。これは、コードの整合性と相互運用性を支援します。32ビットのプラットホーム上でさえ、<code class="docutils literal notranslate"><span class="pre">Int</span></code>は<code class="docutils literal notranslate"><span class="pre">-2,147,483,648</span></code>と<code class="docutils literal notranslate"><span class="pre">2,147,483,647</span></code>の間のどんな値でも格納することができ、多くの整数範囲のために十分に大きいです。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID320">
<h3><span class="enstr">UInt<a class="headerlink" href="#ID320" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
符号なし整数（Unsigned Integer）<a class="headerlink" href="#ID320" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">Swift also provides an unsigned integer type, <code class="docutils literal notranslate"><span class="pre">UInt</span></code>, which has the same size as the current platform’s native word size:</span><!--end_enstr-->
<span class="jpstr">
スウィフトはまた、符号なし整数型、<code class="docutils literal notranslate"><span class="pre">UInt</span></code>を提供します、そしてそれは、現在のプラットホーム固有のワードサイズと同じ大きさを持ちます：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li><span class="enstr">On a 32-bit platform, <code class="docutils literal notranslate"><span class="pre">UInt</span></code> is the same size as <code class="docutils literal notranslate"><span class="pre">UInt32</span></code>.</span><!--end_enstr-->
<span class="jpstr">
32ビットのプラットホーム上で、<code class="docutils literal notranslate"><span class="pre">UInt</span></code>は<code class="docutils literal notranslate"><span class="pre">UInt32</span></code>と同じサイズです。
</span><!--end_jpstr-->
</li>
<li><span class="enstr">On a 64-bit platform, <code class="docutils literal notranslate"><span class="pre">UInt</span></code> is the same size as <code class="docutils literal notranslate"><span class="pre">UInt64</span></code>.</span><!--end_enstr-->
<span class="jpstr">
64ビットのプラットホーム上で、<code class="docutils literal notranslate"><span class="pre">UInt</span></code>は<code class="docutils literal notranslate"><span class="pre">UInt64</span></code>と同じサイズです。
</span><!--end_jpstr-->
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Use <code class="docutils literal notranslate"><span class="pre">UInt</span></code> only when you specifically need an unsigned integer type with the same size as the platform’s native word size. If this isn’t the case, <code class="docutils literal notranslate"><span class="pre">Int</span></code> is preferred, even when the values to be stored are known to be nonnegative. A consistent use of <code class="docutils literal notranslate"><span class="pre">Int</span></code> for integer values aids code interoperability, avoids the need to convert between different number types, and matches integer type inference, as described in <a class="reference internal" href="#ID322"><span class="std std-ref">Type Safety and Type Inference</span></a>.</span><!--end_enstr-->
<span class="jpstr">
あなたが特にプラットホーム固有のワードサイズと同じ大きさで符号なし整数型を必要とする時にだけ<code class="docutils literal notranslate"><span class="pre">UInt</span></code>を使ってください。この場合でないならば、保存される値が負数でないことがわかっている時でさえ、<code class="docutils literal notranslate"><span class="pre">Int</span></code>がむしろ好まれます。整数値のための<code class="docutils literal notranslate"><span class="pre">Int</span></code>の一貫した使用は、コードの相互運用性を支援して、異なる数の型の間で変換する必要を避けて、<a class="reference internal" href="#ID322"><span class="std std-ref">「型安全と型推論」</span></a>で記述されるように、整数型推論に合致します。
</span><!--end_jpstr-->
</p>
</div>
</div>
</div>
<div class="section" id="ID321">
<h2><span class="enstr">Floating-Point Numbers<a class="headerlink" href="#ID321" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
浮動小数点数<a class="headerlink" href="#ID321" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr"><em>Floating-point numbers</em> are numbers with a fractional component, such as <code class="docutils literal notranslate"><span class="pre">3.14159</span></code>, <code class="docutils literal notranslate"><span class="pre">0.1</span></code>, and <code class="docutils literal notranslate"><span class="pre">-273.15</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<em>浮動小数点数</em>は小数部を持つ数です、例えば<code class="docutils literal notranslate"><span class="pre">3.14159</span></code>、<code class="docutils literal notranslate"><span class="pre">0.1</span></code>、そして<code class="docutils literal notranslate"><span class="pre">-273.15</span></code>など。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Floating-point types can represent a much wider range of values than integer types, and can store numbers that are much larger or smaller than can be stored in an <code class="docutils literal notranslate"><span class="pre">Int</span></code>. Swift provides two signed floating-point number types:</span><!--end_enstr-->
<span class="jpstr">
浮動小数点型は、整数型よりずっと広い値の幅を表すことができ、そして<code class="docutils literal notranslate"><span class="pre">Intに</span></code>格納できるよりずっと大きいまたは小さい数を格納できます。スウィフトは、２つの符号つき浮動小数点数型を提供します：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li>
<span class="enstr"><code class="docutils literal notranslate"><span class="pre">Double</span></code> represents a 64-bit floating-point number.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Double</span></code>は、64ビットの浮動小数点数を表します。
</span><!--end_jpstr-->
</li>
<li>
<span class="enstr"><code class="docutils literal notranslate"><span class="pre">Float</span></code> represents a 32-bit floating-point number.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Float</span></code>は、32ビットの浮動小数点数を表します。
</span><!--end_jpstr-->
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr"><code class="docutils literal notranslate"><span class="pre">Double</span></code> has a precision of at least 15 decimal digits, whereas the precision of <code class="docutils literal notranslate"><span class="pre">Float</span></code> can be as little as 6 decimal digits. The appropriate floating-point type to use depends on the nature and range of values you need to work with in your code. In situations where either type would be appropriate, <code class="docutils literal notranslate"><span class="pre">Double</span></code> is preferred.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Double</span></code>は少なくとも10進数で15桁の精度を持ちます、一方で<code class="docutils literal notranslate"><span class="pre">Float</span></code>の精度は10進数で６桁ほどです。使うのに適切な浮動小数点型は、あなたのコードにおいて扱わなければならない値の種別と幅に依ります。どちらの型でも適切である状況では、<code class="docutils literal notranslate"><span class="pre">Double</span></code>が望ましいです。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID322">
<h2><span class="enstr">Type Safety and Type Inference<a class="headerlink" href="#ID322" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
型安全と型推論<a class="headerlink" href="#ID322" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">Swift is a <em>type-safe</em> language. A type safe language encourages you to be clear about the types of values your code can work with. If part of your code requires a <code class="docutils literal notranslate"><span class="pre">String</span></code>, you can’t pass it an <code class="docutils literal notranslate"><span class="pre">Int</span></code> by mistake.</span><!--end_enstr-->
<span class="jpstr">
スウィフトは、<em>型安全</em>な言語です。型安全な言語は、あなたのコードが扱うことができる値の型について、あなたが確信を持つように促します。あなたのコードの一部が<code class="docutils literal notranslate"><span class="pre">String</span></code>を要求するならば、あなたは誤ってそれに<code class="docutils literal notranslate"><span class="pre">Int</span></code>を渡すことはできません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Because Swift is type safe, it performs <em>type checks</em> when compiling your code and flags any mismatched types as errors. This enables you to catch and fix errors as early as possible in the development process.</span><!--end_enstr-->
<span class="jpstr">
スウィフトが型安全であるので、それは、あなたのコードをコンパイルするとき<em>型チェック</em>を実行して、あらゆる組合せを誤った型をエラーとして合図します。これは、あなたに開発過程においてエラーをできるだけ早く捕えて修復するのを可能にします。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Type-checking helps you avoid errors when you’re working with different types of values. However, this doesn’t mean that you have to specify the type of every constant and variable that you declare. If you don’t specify the type of value you need, Swift uses <em>type inference</em> to work out the appropriate type. Type inference enables a compiler to deduce the type of a particular expression automatically when it compiles your code, simply by examining the values you provide.</span><!--end_enstr-->
<span class="jpstr">
型をチェックすることは、あなたが異なる種類の値を扱っているとき、あなたがエラーを避ける手助けをします。しかし、これはあなたがすべてのあなたが宣言する定数と変数の型を指定しなければならないことを意味しません。あなたが必要とする値の型をあなたが指定しないならば、スウィフトは適切な型を導きだすために<em>型推論</em>を使います。型推論は、コンパイラに自動的に特定の式の型を演繹することを、それがあなたのコードをコンパイルする時に、単純にあなたが提供する値を調べることによって、可能にします。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Because of type inference, Swift requires far fewer type declarations than languages such as C or Objective-C. Constants and variables are still explicitly typed, but much of the work of specifying their type is done for you.</span><!--end_enstr-->
<span class="jpstr">
型推論のため、スウィフトはCまたはObjective-Cのような言語よりはるかに少ない型宣言しか必要としません。定数と変数は依然として明確に型を決められます、しかしそれらの型を指定する行為のほとんどは、あなたのために行われます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Type inference is particularly useful when you declare a constant or variable with an initial value. This is often done by assigning a <em>literal value</em> (or <em>literal</em>) to the constant or variable at the point that you declare it. (A literal value is a value that appears directly in your source code, such as <code class="docutils literal notranslate"><span class="pre">42</span></code> and <code class="docutils literal notranslate"><span class="pre">3.14159</span></code> in the examples below.)</span><!--end_enstr-->
<span class="jpstr">
あなたが最初の値で定数または変数を宣言するとき、型推論は特に役に立ちます。これは、<em>リテラル値</em>（または<em>リテラル</em>）を定数または変数に、あなたがそれを宣言する時点で代入することによって、しばしば行われます。（リテラル値「文字通りの値」は、直接あなたのソース・コードで見かける値です、例えば下の例での<code class="docutils literal notranslate"><span class="pre">42</span></code>と<code class="docutils literal notranslate"><span class="pre">3.14159</span></code>）。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">For example, if you assign a literal value of <code class="docutils literal notranslate"><span class="pre">42</span></code> to a new constant without saying what type it is, Swift infers that you want the constant to be an <code class="docutils literal notranslate"><span class="pre">Int</span></code>, because you have initialized it with a number that looks like an integer:</span><!--end_enstr-->
<span class="jpstr">
例えば、あなたがそれがどんな型であるかについて言うことなく、新しい定数にリテラル値<code class="docutils literal notranslate"><span class="pre">42</span></code>を代入するならば、スウィフトは、あなたがその定数に<code class="docutils literal notranslate"><span class="pre">Int</span></code>であって欲しいのだと推測します、なぜならあなたがそれを整数のように見える数で初期化したからです：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">meaningOfLife</span> = <span class="m">42</span>
</li>
<li>
<span class="c"><span class="enstr">// meaningOfLife is inferred to be of type Int</span><!--end_enstr--><span class="jpstr">（meaningOfLifeはInt型であると推測されます）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">Likewise, if you don’t specify a type for a floating-point literal, Swift infers that you want to create a <code class="docutils literal notranslate"><span class="pre">Double</span></code>:</span><!--end_enstr-->
<span class="jpstr">
同様に、あなたがある浮動小数点リテラルのために型を指定しないならば、スウィフトはあなたが<code class="docutils literal notranslate"><span class="pre">Double</span></code>をつくりたいと推測します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">pi</span> = <span class="m">3.14159</span>
</li>
<li>
<span class="c"><span class="enstr">// pi is inferred to be of type Double</span><!--end_enstr--><span class="jpstr">（パイはDouble型であると推測されます）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">Swift always chooses <code class="docutils literal notranslate"><span class="pre">Double</span></code> (rather than <code class="docutils literal notranslate"><span class="pre">Float</span></code>) when inferring the type of floating-point numbers.</span><!--end_enstr-->
<span class="jpstr">
浮動小数点数の型を推論するとき、スウィフトは常に<code class="docutils literal notranslate"><span class="pre">Double</span></code>を選びます（<code class="docutils literal notranslate"><span class="pre">Float</span></code>ではなく）。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">If you combine integer and floating-point literals in an expression, a type of <code class="docutils literal notranslate"><span class="pre">Double</span></code> will be inferred from the context:</span><!--end_enstr-->
<span class="jpstr">
あなたがある式の中で整数と浮動小数点リテラルを結合するならば、その前後関係から<code class="docutils literal notranslate"><span class="pre">Double</span></code>の型が推論されます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">anotherPi</span> = <span class="m">3</span> + <span class="m">0.14159</span>
</li>
<li>
<span class="c"><span class="enstr">// anotherPi is also inferred to be of type Double</span><!--end_enstr--><span class="jpstr">（anotherPiもまたDouble型であると推論されます）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">The literal value of <code class="docutils literal notranslate"><span class="pre">3</span></code> has no explicit type in and of itself, and so an appropriate output type of <code class="docutils literal notranslate"><span class="pre">Double</span></code> is inferred from the presence of a floating-point literal as part of the addition.</span><!--end_enstr-->
<span class="jpstr">
リテラル値<code class="docutils literal notranslate"><span class="pre">3</span></code>は明確な型をそれ自体は持ちません、それで適切な出力の<code class="docutils literal notranslate"><span class="pre">Double</span></code>型は、加算部分の浮動小数点リテラルの存在から推論されます。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID323">
<h2><span class="enstr">Numeric Literals<a class="headerlink" href="#ID323" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
数のリテラル<a class="headerlink" href="#ID323" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">Integer literals can be written as:</span><!--end_enstr-->
<span class="jpstr">
整数リテラルは、次のように書かれることができます：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li><span class="enstr">A <em>decimal</em> number, with no prefix</span><!--end_enstr-->
<span class="jpstr">
<em>10進</em>数は、接頭辞なしで
</span><!--end_jpstr-->
</li>
<li><span class="enstr">A <em>binary</em> number, with a <code class="docutils literal notranslate"><span class="pre">0b</span></code> prefix</span><!--end_enstr-->
<span class="jpstr">
<em>２進</em>数は、接頭辞<code class="docutils literal notranslate"><span class="pre">0b</span></code>つきで
</span><!--end_jpstr-->
</li>
<li><span class="enstr">An <em>octal</em> number, with a <code class="docutils literal notranslate"><span class="pre">0o</span></code> prefix</span><!--end_enstr-->
<span class="jpstr">
<em>８進</em>数は、接頭辞<code class="docutils literal notranslate"><span class="pre">0o</span></code>つきで
</span><!--end_jpstr-->
</li>
<li><span class="enstr">A <em>hexadecimal</em> number, with a <code class="docutils literal notranslate"><span class="pre">0x</span></code> prefix</span><!--end_enstr-->
<span class="jpstr">
<em>16進</em>数は、接頭辞<code class="docutils literal notranslate"><span class="pre">0x</span></code>つきで
</span><!--end_jpstr-->
</li>
</ul>
<p><span class="enstr">All of these integer literals have a decimal value of <code class="docutils literal notranslate"><span class="pre">17</span></code>:</span><!--end_enstr-->
<span class="jpstr">
次の整数リテラルの全ては、10進の値で<code class="docutils literal notranslate"><span class="pre">17</span></code>を持ちます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">decimalInteger</span> = <span class="m">17</span>
</li>
<li>
<span class="k">let</span> <span class="nv">binaryInteger</span> = <span class="m">0b10001</span>       <span class="enstr"><span class="c">// 17 in binary notation</span></span><!--end_enstr--><span class="jpstr"><span class="c">（２進法での17）</span></span><!--end_jpstr--></li>
<li>
<span class="k">let</span> <span class="nv">octalInteger</span> = <span class="m">0o21</span>           <span class="enstr"><span class="c">// 17 in octal notation</span></span><!--end_enstr--><span class="jpstr"><span class="c">（８進法での17）</span></span><!--end_jpstr--></li>
<li>
<span class="k">let</span> <span class="nv">hexadecimalInteger</span> = <span class="m">0x11</span>     <span class="enstr"><span class="c">// 17 in hexadecimal notation</span></span><!--end_enstr--><span class="jpstr"><span class="c">（16進法での17）</span></span><!--end_jpstr--></li>
</ol></div></div></div>
<p><span class="enstr">Floating-point literals can be decimal (with no prefix), or hexadecimal (with a <code class="docutils literal notranslate"><span class="pre">0x</span></code> prefix). They must always have a number (or hexadecimal number) on both sides of the decimal point. Decimal floats can also have an optional <em>exponent</em>, indicated by an uppercase or lowercase <code class="docutils literal notranslate"><span class="pre">e</span></code>; hexadecimal floats must have an exponent, indicated by an uppercase or lowercase <code class="docutils literal notranslate"><span class="pre">p</span></code>.</span><!--end_enstr-->
<span class="jpstr">
浮動小数点リテラルは、10進（接頭辞なし）、または16進（接頭辞<code class="docutils literal notranslate"><span class="pre">0x</span></code>つき）であることができます。それらは、常に小数点の両側で数（または16進の数）を持たなければなりません。10進浮動小数点はまた、任意に<em>指数</em>を持つことができ、大文字か小文字の<code class="docutils literal notranslate"><span class="pre">e</span></code>で示されます；16進浮動小数点は、指数を持つ必要があり、大文字か小文字の<code class="docutils literal notranslate"><span class="pre">p</span></code>で示されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">For decimal numbers with an exponent of <code class="docutils literal notranslate"><span class="pre">exp</span></code>, the base number is multiplied by 10<sup>exp</sup>:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">exp</span></code>の指数を持つある10進数に対して、その基数は10<sup>exp</sup>を掛けられます：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li>
<span class="enstr"><code class="docutils literal notranslate"><span class="pre">1.25e2</span></code> means 1.25 x 10<sup>2</sup>, or <code class="docutils literal notranslate"><span class="pre">125.0</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">1.25e2</span></code>は、1.25 × 10<sup>2</sup>、または<code class="docutils literal notranslate"><span class="pre">125.0</span></code>を意味します。
</span><!--end_jpstr-->
</li>
<li>
<span class="enstr"><code class="docutils literal notranslate"><span class="pre">1.25e-2</span></code> means 1.25 x 10<sup>-2</sup>, or <code class="docutils literal notranslate"><span class="pre">0.0125</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">1.25e-2</span></code>は、1.25 × 10<sup>-2</sup>、または<code class="docutils literal notranslate"><span class="pre">0.0125</span></code>を意味します。
</span><!--end_jpstr-->
</li>
</ul>
<p><span class="enstr">For hexadecimal numbers with an exponent of <code class="docutils literal notranslate"><span class="pre">exp</span></code>, the base number is multiplied by 2<sup>exp</sup>:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">exp</span></code>の指数を持つある16進数に対して、その基数は２<sup>exp</sup>を掛けられます：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li>
<span class="enstr"><code class="docutils literal notranslate"><span class="pre">0xFp2</span></code> means 15 x 2<sup>2</sup>, or <code class="docutils literal notranslate"><span class="pre">60.0</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">0xFp2</span></code>は、15 × 2<sup>2</sup>、または<code class="docutils literal notranslate"><span class="pre">60.0</span></code>を意味します。
</span><!--end_jpstr-->
</li>
<li>
<span class="enstr"><code class="docutils literal notranslate"><span class="pre">0xFp-2</span></code> means 15 x 2<sup>-2</sup>, or <code class="docutils literal notranslate"><span class="pre">3.75</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">0xFp-2</span></code>は、15 × 2<sup>-2</sup>、または<code class="docutils literal notranslate"><span class="pre">3.75</span></code>を意味します。
</span><!--end_jpstr-->
</li>
</ul>
<p><span class="enstr">All of these floating-point literals have a decimal value of <code class="docutils literal notranslate"><span class="pre">12.1875</span></code>:</span><!--end_enstr-->
<span class="jpstr">
以下の浮動小数点リテラルの全ては、10進の値で<code class="docutils literal notranslate"><span class="pre">12.1875</span></code>を持ちます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">decimalDouble</span> = <span class="m">12.1875</span>
</li>
<li>
<span class="k">let</span> <span class="nv">exponentDouble</span> = <span class="m">1.21875e1</span>
</li>
<li>
<span class="k">let</span> <span class="nv">hexadecimalDouble</span> = <span class="m">0xC.3p0</span>
</li>
</ol></div></div></div>
<p><span class="enstr">Numeric literals can contain extra formatting to make them easier to read. Both integers and floats can be padded with extra zeros and can contain underscores to help with readability. Neither type of formatting affects the underlying value of the literal:</span><!--end_enstr-->
<span class="jpstr">
数のリテラルは、それらをより簡単に読めるように書式を整える追加のものを含むことができます。整数と浮動小数点は、余分のゼロを詰められることができ、読みやすくするためにアンダースコアを含むことができます。書式整形のどちらの種類も、もととなるリテラルの値に影響を及ぼしません：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">paddedDouble</span> = <span class="m">000123.456</span>
</li>
<li>
<span class="k">let</span> <span class="nv">oneMillion</span> = <span class="m">1_000_000</span>
</li>
<li>
<span class="k">let</span> <span class="nv">justOverOneMillion</span> = <span class="m">1_000_000.000_000_1</span>
</li>
</ol></div></div></div>
</div>
<div class="section" id="ID324">
<h2><span class="enstr">Numeric Type Conversion<a class="headerlink" href="#ID324" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
数の型変換<a class="headerlink" href="#ID324" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">Use the <code class="docutils literal notranslate"><span class="pre">Int</span></code> type for all general-purpose integer constants and variables in your code, even if they’re known to be nonnegative. Using the default integer type in everyday situations means that integer constants and variables are immediately interoperable in your code and will match the inferred type for integer literal values.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Int</span></code>型を全ての一般的な目的のための整数の定数と変数に対してあなたのコードにおいて使ってください、たとえそれらが負数でないことが知られているとしてもです。日々の状況において初期状態として整数型を使うことは、整数の定数と変数があなたのコードにおいて直接に情報交換が可能で、いろいろな整数のリテラル値に対して推論される型と調和することを意味します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Use other integer types only when they’re specifically needed for the task at hand, because of explicitly sized data from an external source, or for performance, memory usage, or other necessary optimization. Using explicitly sized types in these situations helps to catch any accidental value overflows and implicitly documents the nature of the data being used.</span><!--end_enstr-->
<span class="jpstr">
外部ソース由来の明確に大きさを設定されたデータのために、またはパフォーマンス、メモリ使用、または他の必要な最適化のためになど、目下の作業に特に必要とされる時にだけ、他の整数を使ってください。これらの状況において明示的に大きさを設定された型を使うことは、偶発的な何らかの値のオーバフローを捕えることや、使われているデータの性質を暗黙的に記録することの手助けになります。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID325">
<h3><span class="enstr">Integer Conversion<a class="headerlink" href="#ID325" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
整数変換<a class="headerlink" href="#ID325" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">The range of numbers that can be stored in an integer constant or variable is different for each numeric type. An <code class="docutils literal notranslate"><span class="pre">Int8</span></code> constant or variable can store numbers between <code class="docutils literal notranslate"><span class="pre">-128</span></code> and <code class="docutils literal notranslate"><span class="pre">127</span></code>, whereas a <code class="docutils literal notranslate"><span class="pre">UInt8</span></code> constant or variable can store numbers between <code class="docutils literal notranslate"><span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">255</span></code>. A number that won’t fit into a constant or variable of a sized integer type is reported as an error when your code is compiled:</span><!--end_enstr-->
<span class="jpstr">
整数の定数または変数に格納されることができる数の範囲は、それぞれの数の型で異なります。<code class="docutils literal notranslate"><span class="pre">Int8</span></code>定数または変数は、<code class="docutils literal notranslate"><span class="pre">-128</span></code>と<code class="docutils literal notranslate"><span class="pre">127</span></code>の間の数を格納することができる一方、<code class="docutils literal notranslate"><span class="pre">UInt8</span></code>定数または変数は、<code class="docutils literal notranslate"><span class="pre">0</span></code>と<code class="docutils literal notranslate"><span class="pre">255</span></code>の間の数を格納することができます。あなたのコードがコンパイルされるとき、ある大きさを設定された整数型の定数または変数に収まらない数はエラーとして報告されます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">cannotBeNegative</span>: <span class="nc">UInt8</span> = <span class="m">-1</span>
</li>
<li>
<span class="c"><span class="enstr">// UInt8 can't store negative numbers, and so this will report an error</span><!--end_enstr--><span class="jpstr">（UInt8は負の数を格納することができません、それでこれはエラーを報告します）</span><!--end_jpstr--></span>
</li>
<li>
<span class="k">let</span> <span class="nv">tooBig</span>: <span class="nc">Int8</span> = <span class="nv">Int8</span>.<span class="nv">max</span> + <span class="m">1</span>
</li>
<li>
<span class="c"><span class="enstr">// Int8 can't store a number larger than its maximum value,</span><!--end_enstr--><span class="jpstr">（Int8はその最大の値より大きい数を格納することができません）</span><!--end_jpstr--></span>
</li>
<li>
<span class="c"><span class="enstr">// and so this will also report an error</span><!--end_enstr--><span class="jpstr">（それでこれも同様にエラーを報告します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">Because each numeric type can store a different range of values, you must opt in to numeric type conversion on a case-by-case basis. This opt-in approach prevents hidden conversion errors and helps make type conversion intentions explicit in your code.</span><!--end_enstr-->
<span class="jpstr">
それぞれの数の型は、値の異なる幅を格納できるので、あなたは数の型変換を一件一件を原則に決めていかなければなりません。このオプトインの（個々に決めていく）取り組み方は、隠された変換エラーを防いで、あなたのコードにおいて型変換の意図を明確にするのを助けます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">To convert one specific number type to another, you initialize a new number of the desired type with the existing value. In the example below, the constant <code class="docutils literal notranslate"><span class="pre">twoThousand</span></code> is of type <code class="docutils literal notranslate"><span class="pre">UInt16</span></code>, whereas the constant <code class="docutils literal notranslate"><span class="pre">one</span></code> is of type <code class="docutils literal notranslate"><span class="pre">UInt8</span></code>. They can’t be added together directly, because they’re not of the same type. Instead, this example calls <code class="docutils literal notranslate"><span class="pre">UInt16(one)</span></code> to create a new <code class="docutils literal notranslate"><span class="pre">UInt16</span></code> initialized with the value of <code class="docutils literal notranslate"><span class="pre">one</span></code>, and uses this value in place of the original:</span><!--end_enstr-->
<span class="jpstr">
１つの特定の数の型を他のものに変換するために、あなたは望む型の新しい数を既存の値で初期化します。下記の例で、定数<code class="docutils literal notranslate"><span class="pre">twoThousand</span></code>は<code class="docutils literal notranslate"><span class="pre">型UInt16</span></code>ですが、定数<code class="docutils literal notranslate"><span class="pre">one</span></code>は型<code class="docutils literal notranslate"><span class="pre">UInt8</span></code>です。それらは直接にひとつに加算されることができません、それらが同じ型でないためです。その代わりに、この例は<code class="docutils literal notranslate"><span class="pre">one</span></code>の値で初期化される新しい<code class="docutils literal notranslate"><span class="pre">UInt16</span></code>を作るために<code class="docutils literal notranslate"><span class="pre">UInt16(one)</span></code>を呼んで、オリジナルの代わりにこの値を使います：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">twoThousand</span>: <span class="nc">UInt16</span> = <span class="m">2_000</span>
</li>
<li>
<span class="k">let</span> <span class="nv">one</span>: <span class="nc">UInt8</span> = <span class="m">1</span>
</li>
<li>
<span class="k">let</span> <span class="nv">twoThousandAndOne</span> = <span class="nv">twoThousand</span> + <span class="nv">UInt16</span>(<span class="nv">one</span>)
</li>
</ol></div></div></div>
<p><span class="enstr">Because both sides of the addition are now of type <code class="docutils literal notranslate"><span class="pre">UInt16</span></code>, the addition is allowed. The output constant (<code class="docutils literal notranslate"><span class="pre">twoThousandAndOne</span></code>) is inferred to be of type <code class="docutils literal notranslate"><span class="pre">UInt16</span></code>, because it’s the sum of two <code class="docutils literal notranslate"><span class="pre">UInt16</span></code> values.</span><!--end_enstr-->
<span class="jpstr">
加算の両側が今では型<code class="docutils literal notranslate"><span class="pre">UInt16</span></code>であるので、加算は許されます。出力された定数（<code class="docutils literal notranslate"><span class="pre">twoThousandAndOne</span></code>）は、型<code class="docutils literal notranslate"><span class="pre">UInt16</span></code>であると推測されます、それが２つの<code class="docutils literal notranslate"><span class="pre">UInt16値</span></code>の合計であるので。
</span><!--end_jpstr-->
</p>
<p><span class="enstr"><code class="docutils literal notranslate"><span class="pre">SomeType(ofInitialValue)</span></code> is the default way to call the initializer of a Swift type and pass in an initial value. Behind the scenes, <code class="docutils literal notranslate"><span class="pre">UInt16</span></code> has an initializer that accepts a <code class="docutils literal notranslate"><span class="pre">UInt8</span></code> value, and so this initializer is used to make a new <code class="docutils literal notranslate"><span class="pre">UInt16</span></code> from an existing <code class="docutils literal notranslate"><span class="pre">UInt8</span></code>. You can’t pass in <em>any</em> type here, however—it has to be a type for which <code class="docutils literal notranslate"><span class="pre">UInt16</span></code> provides an initializer. Extending existing types to provide initializers that accept new types (including your own type definitions) is covered in <a class="reference internal" href="Extensions.html"><span class="doc">Extensions</span></a>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">SomeType(ofInitialValue)</span></code>は、あるスウィフト型のイニシャライザを呼んで、初期値を渡すために通常使う方法です。舞台裏で、<code class="docutils literal notranslate"><span class="pre">UInt16</span></code>は<code class="docutils literal notranslate"><span class="pre">UInt8</span></code>値を受け入れるイニシャライザを持ちます、それでこのイニシャライザが新しい<code class="docutils literal notranslate"><span class="pre">UInt16</span></code>を既存の<code class="docutils literal notranslate"><span class="pre">UInt8</span></code>から作るために使われます。しかしながら、あなたは<em>あらゆる</em>型をここに渡すことはできません ― それは<code class="docutils literal notranslate"><span class="pre">UInt16</span></code>がイニシャライザを提供する型でなければなりません。新しい型（あなた独自の型定義を含む）を受け入れるイニシャライザを提供するように既存の型を拡張することは、<a class="reference internal" href="Extensions.html"><span class="doc">「拡張」</span></a>で扱われます。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID326">
<h3><span class="enstr">Integer and Floating-Point Conversion<a class="headerlink" href="#ID326" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
整数と浮動小数点の変換<a class="headerlink" href="#ID326" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">Conversions between integer and floating-point numeric types must be made explicit:</span><!--end_enstr-->
<span class="jpstr">
整数と浮動小数点数型の間の変換は、明示的に行われる必要があります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">three</span> = <span class="m">3</span>
</li>
<li>
<span class="k">let</span> <span class="nv">pointOneFourOneFiveNine</span> = <span class="m">0.14159</span>
</li>
<li>
<span class="k">let</span> <span class="nv">pi</span> = <span class="nv">Double</span>(<span class="nv">three</span>) + <span class="nv">pointOneFourOneFiveNine</span>
</li>
<li>
<span class="c"><span class="enstr">// pi equals 3.14159, and is inferred to be of type Double</span><!--end_enstr--><span class="jpstr">（piは、3.14159に等しく、型Doubleであると推論されます）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">Here, the value of the constant <code class="docutils literal notranslate"><span class="pre">three</span></code> is used to create a new value of type <code class="docutils literal notranslate"><span class="pre">Double</span></code>, so that both sides of the addition are of the same type. Without this conversion in place, the addition would not be allowed.</span><!--end_enstr-->
<span class="jpstr">
ここでは、定数<code class="docutils literal notranslate"><span class="pre">three</span></code>の値が、<code class="docutils literal notranslate"><span class="pre">Double</span></code>型の新しい値をつくるために使われます、それでこの加算の両側は同じ型です。適切なこの変換なしでは、この加算は許されません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Floating-point to integer conversion must also be made explicit. An integer type can be initialized with a <code class="docutils literal notranslate"><span class="pre">Double</span></code> or <code class="docutils literal notranslate"><span class="pre">Float</span></code> value:</span><!--end_enstr-->
<span class="jpstr">
浮動小数点を整数に変換することは、また、明示的に行われる必要があります。整数型は、<code class="docutils literal notranslate"><span class="pre">Double</span></code>または<code class="docutils literal notranslate"><span class="pre">Float</span></code>値で初期化されることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">integerPi</span> = <span class="nv">Int</span>(<span class="nv">pi</span>)
</li>
<li>
<span class="c"><span class="enstr">// integerPi equals 3, and is inferred to be of type Int</span><!--end_enstr--><span class="jpstr">（integerPiは、３に等しく、型Intであると推測されます）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">Floating-point values are always truncated when used to initialize a new integer value in this way. This means that <code class="docutils literal notranslate"><span class="pre">4.75</span></code> becomes <code class="docutils literal notranslate"><span class="pre">4</span></code>, and <code class="docutils literal notranslate"><span class="pre">-3.9</span></code> becomes <code class="docutils literal notranslate"><span class="pre">-3</span></code>.</span><!--end_enstr-->
<span class="jpstr">
この方法で新しい整数値を初期化するとき、浮動小数点値は常に切り詰められます。これは、<code class="docutils literal notranslate"><span class="pre">4.75</span></code>が<code class="docutils literal notranslate"><span class="pre">4</span></code>に、そして<code class="docutils literal notranslate"><span class="pre">-3.9</span></code>が<code class="docutils literal notranslate"><span class="pre">-3</span></code>になることを意味します。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">The rules for combining numeric constants and variables are different from the rules for numeric literals. The literal value <code class="docutils literal notranslate"><span class="pre">3</span></code> can be added directly to the literal value <code class="docutils literal notranslate"><span class="pre">0.14159</span></code>, because number literals don’t have an explicit type in and of themselves. Their type is inferred only at the point that they’re evaluated by the compiler.</span><!--end_enstr-->
<span class="jpstr">
数の定数や変数を結合することに対する規則は、数のリテラルに対する規則と異なります。リテラル値<code class="docutils literal notranslate"><span class="pre">3</span></code>は、直接にリテラル値<code class="docutils literal notranslate"><span class="pre">0.14159</span></code>に加えられることができます、なぜなら数リテラルがそれら自身において明確な型を持たないためです。それらの型は、それらがコンパイラによって評価される時点においてのみ、推論されます。
</span><!--end_jpstr-->
</p>
</div>
</div>
</div>
<div class="section" id="ID327">
<h2><span class="enstr">Type Aliases<a class="headerlink" href="#ID327" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
型エイリアス<a class="headerlink" href="#ID327" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr"><em>Type aliases</em> define an alternative name for an existing type. You define type aliases with the <code class="docutils literal notranslate"><span class="pre">typealias</span></code> keyword.</span><!--end_enstr-->
<span class="jpstr">
<em>型エイリアス</em>は、既存の型の代替の名前を定義します。あなたは、<code class="docutils literal notranslate"><span class="pre">typealias</span></code>キーワードで型エイリアスを定義します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Type aliases are useful when you want to refer to an existing type by a name that’s contextually more appropriate, such as when working with data of a specific size from an external source:</span><!--end_enstr-->
<span class="jpstr">
型エイリアスは、あなたがより文脈上適切な名前で既存の型に言及したいとき役に立ちます、たとえば外部ソースからの特定の大きさのデータを扱う時など：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="k">typealias</span> <span class="nv">AudioSample</span> = <span class="nc">UInt16</span>
</li></ol></div></div></div>
<p><span class="enstr">Once you define a type alias, you can use the alias anywhere you might use the original name:</span><!--end_enstr-->
<span class="jpstr">
一旦あなたがある型エイリアスを定義するならば、あなたが本来の名前を使うであろうどこにでも、あなたはそのエイリアスを使用することができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">var</span> <span class="nv">maxAmplitudeFound</span> = <span class="nv">AudioSample</span>.<span class="nv">min</span>
</li>
<li>
<span class="c"><span class="enstr">// maxAmplitudeFound is now 0</span><!--end_enstr--><span class="jpstr">（maxAmplitudeFoundは、現在0です）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">Here, <code class="docutils literal notranslate"><span class="pre">AudioSample</span></code> is defined as an alias for <code class="docutils literal notranslate"><span class="pre">UInt16</span></code>. Because it’s an alias, the call to <code class="docutils literal notranslate"><span class="pre">AudioSample.min</span></code> actually calls <code class="docutils literal notranslate"><span class="pre">UInt16.min</span></code>, which provides an initial value of <code class="docutils literal notranslate"><span class="pre">0</span></code> for the <code class="docutils literal notranslate"><span class="pre">maxAmplitudeFound</span></code> variable.</span><!--end_enstr-->
<span class="jpstr">
ここでは、<code class="docutils literal notranslate"><span class="pre">AudioSample</span></code>は<code class="docutils literal notranslate"><span class="pre">UInt16</span></code>に対するエイリアス（別名）として定義されます。それがエイリアスであるので、<code class="docutils literal notranslate"><span class="pre">AudioSample.min</span></code>への呼び出しは実際には<code class="docutils literal notranslate"><span class="pre">UInt16.min</span></code>を呼び、それは<code class="docutils literal notranslate"><span class="pre">0</span></code>の初期値を<code class="docutils literal notranslate"><span class="pre">maxAmplitudeFound</span></code>変数のために提供します。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID328">
<h2><span class="enstr">Booleans<a class="headerlink" href="#ID328" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
ブール<a class="headerlink" href="#ID328" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">Swift has a basic <em>Boolean</em> type, called <code class="docutils literal notranslate"><span class="pre">Bool</span></code>. Boolean values are referred to as <em>logical</em>, because they can only ever be true or false. Swift provides two Boolean constant values, <code class="docutils literal notranslate"><span class="pre">true</span></code> and <code class="docutils literal notranslate"><span class="pre">false</span></code>:</span><!--end_enstr-->
<span class="jpstr">
スウィフトは、ひとつの基本的な<em>ブール</em>型を持ちます、それは<code class="docutils literal notranslate"><span class="pre">Bool</span></code>と呼ばれるものです。ブールの値は、<em>論理</em>として参照されます、なぜならそれらは真か偽であることだけができるからです。スウィフトは２つのブールの定数値、<code class="docutils literal notranslate"><span class="pre">true</span></code>と<code class="docutils literal notranslate"><span class="pre">false</span></code>を提供します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">orangesAreOrange</span> = <span class="k">true</span>
</li>
<li>
<span class="k">let</span> <span class="nv">turnipsAreDelicious</span> = <span class="k">false</span>
</li>
</ol></div></div></div>
<p><span class="enstr">The types of <code class="docutils literal notranslate"><span class="pre">orangesAreOrange</span></code> and <code class="docutils literal notranslate"><span class="pre">turnipsAreDelicious</span></code> have been inferred as <code class="docutils literal notranslate"><span class="pre">Bool</span></code> from the fact that they were initialized with Boolean literal values. As with <code class="docutils literal notranslate"><span class="pre">Int</span></code> and <code class="docutils literal notranslate"><span class="pre">Double</span></code> above, you don’t need to declare constants or variables as <code class="docutils literal notranslate"><span class="pre">Bool</span></code> if you set them to <code class="docutils literal notranslate"><span class="pre">true</span></code> or <code class="docutils literal notranslate"><span class="pre">false</span></code> as soon as you create them. Type inference helps make Swift code more concise and readable when it initializes constants or variables with other values whose type is already known.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">orangesAreOrange</span></code>と<code class="docutils literal notranslate"><span class="pre">turnipsAreDelicious</span></code>の型は、それらがブールのリテラル値で初期化されたという事実から、<code class="docutils literal notranslate"><span class="pre">Bool</span></code>として推論されます。上の<code class="docutils literal notranslate"><span class="pre">Int</span></code>と<code class="docutils literal notranslate"><span class="pre">Double</span></code>と同様に、あなたがそれらを作成するやいなや<code class="docutils literal notranslate"><span class="pre">true</span></code>または<code class="docutils literal notranslate"><span class="pre">false</span></code>に設定するならば、あなたは定数または変数を<code class="docutils literal notranslate"><span class="pre">Bool</span></code>として宣言する必要はありません。型推論は、スウィフトのコードを、それが定数または変数を型がすでに知られている他の値で初期化するとき、より簡潔で読みやすくするのを助けます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Boolean values are particularly useful when you work with conditional statements such as the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement:</span><!--end_enstr-->
<span class="jpstr">
あなたが<code class="docutils literal notranslate"><span class="pre">if</span></code>文のような条件つきの文で作業するとき、ブールの値は特に役に立ちます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">if</span> <span class="nv">turnipsAreDelicious</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"Mmm, tasty turnips!"</span>)
</li>
<li>} <span class="k">else</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"Eww, turnips are horrible."</span>)
</li>
<li>}
</li>
<li>
<span class="c"><span class="enstr">// Prints "Eww, turnips are horrible."</span><!--end_enstr--><span class="jpstr">（「うー、カブ怖い。」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">Conditional statements such as the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement are covered in more detail in <a class="reference internal" href="ControlFlow.html"><span class="doc">Control Flow</span></a>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">if</span></code>文のような条件つきの文は、更に詳細に<a class="reference internal" href="ControlFlow.html"><span class="doc">「制御の流れ」</span></a>で扱われます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Swift’s type safety prevents non-Boolean values from being substituted for <code class="docutils literal notranslate"><span class="pre">Bool</span></code>. The following example reports a compile-time error:</span><!--end_enstr-->
<span class="jpstr">
スウィフトの型安全は、非ブール値が<code class="docutils literal notranslate"><span class="pre">Bool</span></code>の代用にされるのを妨げます。以下の例は、コンパイル時エラーを報告します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">i</span> = <span class="m">1</span>
</li>
<li>
<span class="k">if</span> <span class="nv">i</span> {
</li>
<li>    <span class="c"><span class="enstr">// this example will not compile, and will report an error</span><!--end_enstr--><span class="jpstr">（この例はコンパイルせず、エラーを報告します）</span><!--end_jpstr--></span>
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">However, the alternative example below is valid:</span><!--end_enstr-->
<span class="jpstr">
しかし、これに代わる以下の例は有効です：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">i</span> = <span class="m">1</span>
</li>
<li>
<span class="k">if</span> <span class="nv">i</span> == <span class="m">1</span> {
</li>
<li>    <span class="c"><span class="enstr">// this example will compile successfully</span><!--end_enstr--><span class="jpstr">（この例は、うまくコンパイルします）</span><!--end_jpstr--></span>
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">The result of the <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">==</span> <span class="pre">1</span></code> comparison is of type <code class="docutils literal notranslate"><span class="pre">Bool</span></code>, and so this second example passes the type-check. Comparisons like <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">==</span> <span class="pre">1</span></code> are discussed in <a class="reference internal" href="BasicOperators.html"><span class="doc">Basic Operators</span></a>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">==</span> <span class="pre">1</span></code>の比較の結果は型<code class="docutils literal notranslate"><span class="pre">Bool</span></code>です、それでこの第二の例は型チェックを通ります。<code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">==</span> <span class="pre">1</span></code>のような比較は<a class="reference internal" href="BasicOperators.html"><span class="doc">「基本の演算子」</span></a>で議論されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">As with other examples of type safety in Swift, this approach avoids accidental errors and ensures that the intention of a particular section of code is always clear.</span><!--end_enstr-->
<span class="jpstr">
スウィフトにおける型安全に関する他の例と同様に、このやり方は、偶然のエラーを避けること、そしてコードの特定の節の意図を常にはっきりさせることを確実にします。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID329">
<h2><span class="enstr">Tuples<a class="headerlink" href="#ID329" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
タプル<a class="headerlink" href="#ID329" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr"><em>Tuples</em> group multiple values into a single compound value. The values within a tuple can be of any type and don’t have to be of the same type as each other.</span><!--end_enstr-->
<span class="jpstr">
<em>タプル</em>は、複数の値を１つの複合値にまとめます。タプルの内部の値は、どんな型でもかまいません、そして互いに同じ型である必要はありません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">In this example, <code class="docutils literal notranslate"><span class="pre">(404,</span> <span class="pre">"Not</span> <span class="pre">Found")</span></code> is a tuple that describes an <em>HTTP status code</em>. An HTTP status code is a special value returned by a web server whenever you request a web page. A status code of <code class="docutils literal notranslate"><span class="pre">404</span> <span class="pre">Not</span> <span class="pre">Found</span></code> is returned if you request a webpage that doesn’t exist.</span><!--end_enstr-->
<span class="jpstr">
この例では、<code class="docutils literal notranslate"><span class="pre">(404,</span> <span class="pre">"Not</span> <span class="pre">Found")</span></code>がひとつのタプルです、それは<em>HTTP状態コード</em>を記述します。HTTP状態コードは、あなたがウェブ・ページを要請するときはいつでもウェブ・サーバーによって返されるある特別な値です。状態コード<code class="docutils literal notranslate"><span class="pre">404</span> <span class="pre">Not</span> <span class="pre">Found</span></code>は、あなたが存在しないウェブ・ページを要請するならば返されます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">http404Error</span> = (<span class="m">404</span>, <span class="s">"Not Found"</span>)
</li>
<li>
<span class="c"><span class="enstr">// http404Error is of type (Int, String), and equals (404, "Not Found")</span><!--end_enstr--><span class="jpstr">（http404Errorは、型が(Int, String)です、そして(404, "Not Found")と等しいです）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">(404,</span> <span class="pre">"Not</span> <span class="pre">Found")</span></code> tuple groups together an <code class="docutils literal notranslate"><span class="pre">Int</span></code> and a <code class="docutils literal notranslate"><span class="pre">String</span></code> to give the HTTP status code two separate values: a number and a human-readable description. It can be described as “a tuple of type <code class="docutils literal notranslate"><span class="pre">(Int,</span> <span class="pre">String)</span></code>”.</span><!--end_enstr-->
<span class="jpstr">
この<code class="docutils literal notranslate"><span class="pre">(404,</span> <span class="pre">"Not</span> <span class="pre">Found")</span></code>タプルは<code class="docutils literal notranslate"><span class="pre">Int</span></code>と<code class="docutils literal notranslate"><span class="pre">String</span></code>をひとつにまとめて、HTTP状態コードに２つの別々の値：数と人間の読める説明を与えます。それは型<code class="docutils literal notranslate"><span class="pre">(Int,</span> <span class="pre">String)</span></code>のタプルとして記述されることができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can create tuples from any permutation of types, and they can contain as many different types as you like. There’s nothing stopping you from having a tuple of type <code class="docutils literal notranslate"><span class="pre">(Int,</span> <span class="pre">Int,</span> <span class="pre">Int)</span></code>, or <code class="docutils literal notranslate"><span class="pre">(String,</span> <span class="pre">Bool)</span></code>, or indeed any other permutation you require.</span><!--end_enstr-->
<span class="jpstr">
あなたは、いろいろな型をどんな順列にしてタプルを作っても構いません、そして、それらはあなたが望むだけ多くの異なる型を含むことができます。あなたが<code class="docutils literal notranslate"><span class="pre">(Int,</span> <span class="pre">Int,</span> <span class="pre">Int)</span></code>の型のタプル、または<code class="docutils literal notranslate"><span class="pre">(String,</span> <span class="pre">Bool)</span></code>、またはあなたが実際に必要とするあらゆる他の順列を持つのを止めるものは何もありません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can <em>decompose</em> a tuple’s contents into separate constants or variables, which you then access as usual:</span><!--end_enstr-->
<span class="jpstr">
あなたはタプルの内容を個々の定数または変数に<em>分解</em>することができます。そして、あなたはそれから通常通りそれにアクセスします：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> (<span class="nv">statusCode</span>, <span class="nv">statusMessage</span>) = <span class="nv">http404Error</span>
</li>
<li>
<span class="nv">print</span>(<span class="s">"The status code is </span>\<span class="p">(</span><span class="nv">statusCode</span><span class="p">)</span><span class="s">"</span>)
</li>
<li>
<span class="c"><span class="enstr">// Prints "The status code is 404"</span><!--end_enstr--><span class="jpstr">（「状態コードは404です」を出力します）</span><!--end_jpstr--></span>
</li>
<li>
<span class="nv">print</span>(<span class="s">"The status message is </span>\<span class="p">(</span><span class="nv">statusMessage</span><span class="p">)</span><span class="s">"</span>)
</li>
<li>
<span class="c"><span class="enstr">// Prints "The status message is Not Found"</span><!--end_enstr--><span class="jpstr">（「状態メッセージが見つかりません」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">If you only need some of the tuple’s values, ignore parts of the tuple with an underscore (<code class="docutils literal notranslate"><span class="pre">_</span></code>) when you decompose the tuple:</span><!--end_enstr-->
<span class="jpstr">
あなたがタプルの値の一部を必要とするだけならば、あなたがタプルを分解するとき、アンダースコア（<code class="docutils literal notranslate"><span class="pre">_</span></code>）で、タプルの一部を無視してください：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> (<span class="nv">justTheStatusCode</span>, <span class="k">_</span>) = <span class="nv">http404Error</span>
</li>
<li>
<span class="nv">print</span>(<span class="s">"The status code is </span>\<span class="p">(</span><span class="nv">justTheStatusCode</span><span class="p">)</span><span class="s">"</span>)
</li>
<li>
<span class="c"><span class="enstr">// Prints "The status code is 404"</span><!--end_enstr--><span class="jpstr">（「状態コードは404です」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">Alternatively, access the individual element values in a tuple using index numbers starting at zero:</span><!--end_enstr-->
<span class="jpstr">
あるいは、ゼロから始まっているインデックス番号を使ってタプルの個々の要素の値にアクセスしてください：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="nv">print</span>(<span class="s">"The status code is </span>\<span class="p">(</span><span class="nv">http404Error</span>.<span class="m">0</span><span class="p">)</span><span class="s">"</span>)
</li>
<li>
<span class="c"><span class="enstr">// Prints "The status code is 404"</span><!--end_enstr--><span class="jpstr">（「状態コードは404です」を出力します）</span><!--end_jpstr--></span>
</li>
<li>
<span class="nv">print</span>(<span class="s">"The status message is </span>\<span class="p">(</span><span class="nv">http404Error</span>.<span class="m">1</span><span class="p">)</span><span class="s">"</span>)
</li>
<li>
<span class="c"><span class="enstr">// Prints "The status message is Not Found"</span><!--end_enstr--><span class="jpstr">（「状態メッセージが見つかりません」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">You can name the individual elements in a tuple when the tuple is defined:</span><!--end_enstr-->
<span class="jpstr">
あなたは、タプルの個々の要素に名前をつけることが、そのタプルが定義される時に可能です：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="k">let</span> <span class="nv">http200Status</span> = (<span class="nv">statusCode</span>: <span class="m">200</span>, <span class="nv">description</span>: <span class="s">"OK"</span>)
</li></ol></div></div></div>
<p><span class="enstr">If you name the elements in a tuple, you can use the element names to access the values of those elements:</span><!--end_enstr-->
<span class="jpstr">
あなたがタプルの要素に名をつけるならば、あなたはそれらの要素の値にアクセスするために要素名を使用することができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="nv">print</span>(<span class="s">"The status code is </span>\<span class="p">(</span><span class="nv">http200Status</span>.<span class="nv">statusCode</span><span class="p">)</span><span class="s">"</span>)
</li>
<li>
<span class="c"><span class="enstr">// Prints "The status code is 200"</span><!--end_enstr--><span class="jpstr">（「状態コードは200です」を出力します）</span><!--end_jpstr--></span>
</li>
<li>
<span class="nv">print</span>(<span class="s">"The status message is </span>\<span class="p">(</span><span class="nv">http200Status</span>.<span class="nv">description</span><span class="p">)</span><span class="s">"</span>)
</li>
<li>
<span class="c"><span class="enstr">// Prints "The status message is OK"</span><!--end_enstr--><span class="jpstr">（「状態メッセージはOKです」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">Tuples are particularly useful as the return values of functions. A function that tries to retrieve a web page might return the <code class="docutils literal notranslate"><span class="pre">(Int,</span> <span class="pre">String)</span></code> tuple type to describe the success or failure of the page retrieval. By returning a tuple with two distinct values, each of a different type, the function provides more useful information about its outcome than if it could only return a single value of a single type. For more information, see <a class="reference internal" href="Functions.html#ID164"><span class="std std-ref">Functions with Multiple Return Values</span></a>.</span><!--end_enstr-->
<span class="jpstr">
タプルは、特に関数の戻り値として便利です。ウェブ・ページを探してくるある関数は、ページ検索の成功または失敗を記述するために<code class="docutils literal notranslate"><span class="pre">(Int,</span> <span class="pre">String)</span></code>のタプル型を返すかもしれません。２つの別の値をそれぞれ異なる型で持つひとつのタプルを返すことによって、その関数は、それが１つの型の１つの値を返すことができるだけよりも、その結果に関するより役に立つ情報を提供します。詳細は、<a class="reference internal" href="Functions.html#ID164"><span class="std std-ref">「複数の戻り値をもつ関数」</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Tuples are useful for simple groups of related values. They’re not suited to the creation of complex data structures. If your data structure is likely to be more complex, model it as a class or structure, rather than as a tuple. For more information, see <a class="reference internal" href="ClassesAndStructures.html"><span class="doc">Structures and Classes</span></a>.</span><!--end_enstr-->
<span class="jpstr">
タプルは、関連した値の単純なグループに対して便利です。それらは、複雑なデータ構造物の作成には適していません。あなたのデータ構造体がより複雑になるようならば、それをクラスまたは構造体として形作ってください、タプルとしてよりも。詳細は、<a class="reference internal" href="ClassesAndStructures.html"><span class="doc">クラスと構造体</span></a>を見てください。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID330">
<h2><span class="enstr">Optionals<a class="headerlink" href="#ID330" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
オプショナル<a class="headerlink" href="#ID330" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">You use <em>optionals</em> in situations where a value may be absent. An optional represents two possibilities: Either there <em>is</em> a value, and you can unwrap the optional to access that value, or there <em>isn’t</em> a value at all.</span><!--end_enstr-->
<span class="jpstr">
あなたは<em>オプショナル</em>を、ある値が不在かもしれない状況において使います。あるオプショナルは２つの可能性を表します：ある値が存在<em>する</em>、するとあなたはそのオプショナルをアンラップすることでその値を利用できます、または値がそもそも存在<em>しない</em>かのいずれか。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">The concept of optionals doesn’t exist in C or Objective-C. The nearest thing in Objective-C is the ability to return <code class="docutils literal notranslate"><span class="pre">nil</span></code> from a method that would otherwise return an object, with <code class="docutils literal notranslate"><span class="pre">nil</span></code> meaning “the absence of a valid object.” However, this only works for objects—it doesn’t work for structures, basic C types, or enumeration values. For these types, Objective-C methods typically return a special value (such as <code class="docutils literal notranslate"><span class="pre">NSNotFound</span></code>) to indicate the absence of a value. This approach assumes that the method’s caller knows there’s a special value to test against and remembers to check for it. Swift’s optionals let you indicate the absence of a value for <em>any type at all</em>, without the need for special constants.</span><!--end_enstr-->
<span class="jpstr">
オプショナルの概念は、CまたはObjective-Cの中に存在しません。Objective-Cにおいて最も近いものは、オブジェクトを返すメソッドからそうできない場合に<code class="docutils literal notranslate"><span class="pre">nil</span></code>を返す能力です、そのとき<code class="docutils literal notranslate"><span class="pre">nil</span></code>は「有効なオブジェクトの欠如」を意味しています。しかし、それは単にオブジェクトのためだけに働きます ― それは構造体、基本的なC型、または列挙値のために働きません。これらの型のために、Objective-Cメソッドは、値の欠如を示すために概して特別な値（例えば<code class="docutils literal notranslate"><span class="pre">NSNotFound</span></code>）を返します。このアプローチは、メソッドの呼び出し側が試験するべき特別な値があるのを知っていて、それについて調べるのを忘れないでいると仮定します。スウィフトのオプショナルは、あなたに特別な定数の必要なしに<em>あらゆる全ての型</em>の値の欠如を示させます。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">Here’s an example of how optionals can be used to cope with the absence of a value. Swift’s <code class="docutils literal notranslate"><span class="pre">Int</span></code> type has an initializer which tries to convert a <code class="docutils literal notranslate"><span class="pre">String</span></code> value into an <code class="docutils literal notranslate"><span class="pre">Int</span></code> value. However, not every string can be converted into an integer. The string <code class="docutils literal notranslate"><span class="pre">"123"</span></code> can be converted into the numeric value <code class="docutils literal notranslate"><span class="pre">123</span></code>, but the string <code class="docutils literal notranslate"><span class="pre">"hello,</span> <span class="pre">world"</span></code> doesn’t have an obvious numeric value to convert to.</span><!--end_enstr-->
<span class="jpstr">
ここに、値の欠如に対処するためにどのようにオプショナルが使われることができるかの１つの例があります。スウィフトの<code class="docutils literal notranslate"><span class="pre">Int</span></code>型はあるイニシャライザを持ちます、それは<code class="docutils literal notranslate"><span class="pre">String</span></code>値を<code class="docutils literal notranslate"><span class="pre">Int値</span></code>に変換することを試みます。しかし、すべての文字列が、整数に変えられることができるというわけでありません。文字列<code class="docutils literal notranslate"><span class="pre">"123"</span></code>は数の値<code class="docutils literal notranslate"><span class="pre">123</span></code>に変えられることができます、しかし文字列<code class="docutils literal notranslate"><span class="pre">"hello,</span> <span class="pre">world"</span></code>には変えるための明らかな数の値がありません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The example below uses the initializer to try to convert a <code class="docutils literal notranslate"><span class="pre">String</span></code> into an <code class="docutils literal notranslate"><span class="pre">Int</span></code>:</span><!--end_enstr-->
<span class="jpstr">
下の例は、このイニシャライザを使用して<code class="docutils literal notranslate"><span class="pre">String</span></code>を<code class="docutils literal notranslate"><span class="pre">Int</span></code>に変えることを試みます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">possibleNumber</span> = <span class="s">"123"</span>
</li>
<li>
<span class="k">let</span> <span class="nv">convertedNumber</span> = <span class="nv">Int</span>(<span class="nv">possibleNumber</span>)
</li>
<li>
<span class="c"><span class="enstr">// convertedNumber is inferred to be of type "Int?", or "optional Int"</span><!--end_enstr--><span class="jpstr">（convertedNumberは、型「Int?」または「オプショナルのInt」であると推論されます）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">Because the initializer might fail, it returns an <em>optional</em> <code class="docutils literal notranslate"><span class="pre">Int</span></code>, rather than an <code class="docutils literal notranslate"><span class="pre">Int</span></code>. An optional <code class="docutils literal notranslate"><span class="pre">Int</span></code> is written as <code class="docutils literal notranslate"><span class="pre">Int?</span></code>, not <code class="docutils literal notranslate"><span class="pre">Int</span></code>. The question mark indicates that the value it contains is optional, meaning that it might contain <em>some</em> <code class="docutils literal notranslate"><span class="pre">Int</span></code> value, or it might contain <em>no value at all</em>. (It can’t contain anything else, such as a <code class="docutils literal notranslate"><span class="pre">Bool</span></code> value or a <code class="docutils literal notranslate"><span class="pre">String</span></code> value. It’s either an <code class="docutils literal notranslate"><span class="pre">Int</span></code>, or it’s nothing at all.)</span><!--end_enstr-->
<span class="jpstr">
このイニシャライザが失敗するかもしれないので、それは<code class="docutils literal notranslate"><span class="pre">Int</span></code>ではなくて、<em>オプショナル</em>の<code class="docutils literal notranslate"><span class="pre">Int</span></code>を返します。オプショナルの<code class="docutils literal notranslate"><span class="pre">Int</span></code>は、<code class="docutils literal notranslate"><span class="pre">Int?</span></code>のように書かれます、<code class="docutils literal notranslate"><span class="pre">Int</span></code>ではなく。疑問符はそれが含む値がオプショナルであることを示します、そしてそれが<em>何かの</em> <code class="docutils literal notranslate"><span class="pre">Int</span></code>値を含むかもしれない、あるいはそれが<em>まったく値を含まない</em>かもしれないことを意味しています。 （それは、他の何か、例えば<code class="docutils literal notranslate"><span class="pre">Bool</span></code>値または<code class="docutils literal notranslate"><span class="pre">String</span></code>値などを含むことはできません。それはひとつの<code class="docutils literal notranslate"><span class="pre">Int</span></code>、またはそれは全く何も無いかのどちらかです。）
</span><!--end_jpstr-->
</p>
<div class="section" id="ID331">
<h3>nil<a class="headerlink" href="#ID331" title="Permalink to this headline">¶</a>
</h3>
<p><span class="enstr">You set an optional variable to a valueless state by assigning it the special value <code class="docutils literal notranslate"><span class="pre">nil</span></code>:</span><!--end_enstr-->
<span class="jpstr">
あなたが、あるオプショナルの変数を値が無い状態へと設定するには、それに特別な値<code class="docutils literal notranslate"><span class="pre">nil</span></code>を代入します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">var</span> <span class="nv">serverResponseCode</span>: <span class="nc">Int</span>? = <span class="m">404</span>
</li>
<li>
<span class="c"><span class="enstr">// serverResponseCode contains an actual Int value of 404</span><!--end_enstr--><span class="jpstr">（serverResponseCodeは、実際にあるInt値404を含みます）</span><!--end_jpstr--></span>
</li>
<li>
<span class="nv">serverResponseCode</span> = <span class="k">nil</span>
</li>
<li>
<span class="c"><span class="enstr">// serverResponseCode now contains no value</span><!--end_enstr--><span class="jpstr">（serverResponseCodeは、現在は値を含みません）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">You can’t use <code class="docutils literal notranslate"><span class="pre">nil</span></code> with non-optional constants and variables. If a constant or variable in your code needs to work with the absence of a value under certain conditions, always declare it as an optional value of the appropriate type.</span><!--end_enstr-->
<span class="jpstr">
あなたは、<code class="docutils literal notranslate"><span class="pre">nil</span></code>を非オプショナルの定数および変数で使うことができます。あなたのコードの中の定数または変数が特定の条件下で値の欠如を取り扱う必要があるならば、常に、それを適切な型のオプショナルの値として宣言してください。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">If you define an optional variable without providing a default value, the variable is automatically set to <code class="docutils literal notranslate"><span class="pre">nil</span></code> for you:</span><!--end_enstr-->
<span class="jpstr">
あなたが既定値を提供することなくオプショナルの変数を定義するならば、その変数はあなたのために自動的に<code class="docutils literal notranslate"><span class="pre">nilに</span></code>設定されます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">var</span> <span class="nv">surveyAnswer</span>: <span class="nc">String</span>?
</li>
<li>
<span class="c"><span class="enstr">// surveyAnswer is automatically set to nil</span><!--end_enstr--><span class="jpstr">（surveyAnswerは、自動的にnilに設定されます）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Swift’s <code class="docutils literal notranslate"><span class="pre">nil</span></code> isn’t the same as <code class="docutils literal notranslate"><span class="pre">nil</span></code> in Objective-C. In Objective-C, <code class="docutils literal notranslate"><span class="pre">nil</span></code> is a pointer to a nonexistent object. In Swift, <code class="docutils literal notranslate"><span class="pre">nil</span></code> isn’t a pointer—it’s the absence of a value of a certain type. Optionals of <em>any</em> type can be set to <code class="docutils literal notranslate"><span class="pre">nil</span></code>, not just object types.</span><!--end_enstr-->
<span class="jpstr">
スウィフトの<code class="docutils literal notranslate"><span class="pre">nil</span></code>は、Objective-Cでの<code class="docutils literal notranslate"><span class="pre">nil</span></code>と同じものではありません。Objective-Cでは、<code class="docutils literal notranslate"><span class="pre">nil</span></code>は、ある存在しないオブジェクトへのポインターです。スウィフトでは、<code class="docutils literal notranslate"><span class="pre">nil</span></code>はポインターではありません ― それは、ある特定の型のある値の不在です。<em>すべての</em>型のオプショナルが、<code class="docutils literal notranslate"><span class="pre">nil</span></code>に設定されることができます、単にオブジェクト型だけでなく。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID332">
<h3><span class="enstr">If Statements and Forced Unwrapping<a class="headerlink" href="#ID332" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
if文と強制アンラップ<a class="headerlink" href="#ID332" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">You can use an <code class="docutils literal notranslate"><span class="pre">if</span></code> statement to find out whether an optional contains a value by comparing the optional against <code class="docutils literal notranslate"><span class="pre">nil</span></code>. You perform this comparison with the “equal to” operator (<code class="docutils literal notranslate"><span class="pre">==</span></code>) or the “not equal to” operator (<code class="docutils literal notranslate"><span class="pre">!=</span></code>).</span><!--end_enstr-->
<span class="jpstr">
あなたは、<code class="docutils literal notranslate"><span class="pre">if</span></code>文を、あるオプショナルが値を含むかどうか知るために使うことができます、それは、そのオプショナルを<code class="docutils literal notranslate"><span class="pre">nil</span></code>と比べることによって行います。あなたは、この比較を「同等」演算子（<code class="docutils literal notranslate"><span class="pre">==</span></code>）または「不等」演算子（<code class="docutils literal notranslate"><span class="pre">!=</span></code>）を使って実行します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">If an optional has a value, it’s considered to be “not equal to” <code class="docutils literal notranslate"><span class="pre">nil</span></code>:</span><!--end_enstr-->
<span class="jpstr">
あるオプショナルが値を持つならば、それは<code class="docutils literal notranslate"><span class="pre">nil</span></code>と「同等でない」と判断されます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">if</span> <span class="nv">convertedNumber</span> != <span class="k">nil</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"convertedNumber contains some integer value."</span>)
</li>
<li>}
</li>
<li>
<span class="c"><span class="enstr">// Prints "convertedNumber contains some integer value."</span><!--end_enstr--><span class="jpstr">（「convertedNumberは、何らかの整数値を持ちます」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">Once you’re sure that the optional <em>does</em> contain a value, you can access its underlying value by adding an exclamation point (<code class="docutils literal notranslate"><span class="pre">!</span></code>) to the end of the optional’s name. The exclamation point effectively says, “I know that this optional definitely has a value; please use it.” This is known as <em>forced unwrapping</em> of the optional’s value:</span><!--end_enstr-->
<span class="jpstr">
一旦あなたがそのオプショナルが値を含んで<em>いる</em>ことを確かめたなら、あなたは感嘆符（<code class="docutils literal notranslate"><span class="pre">!</span></code>）をオプショナルの名前の終わりに加えることによって、それに内在する値にアクセスすることが可能です。感嘆符は、実際上こう言っています、「私はこのオプショナルが間違いなくひとつの値を持つことを知っています；どうぞそれを使ってください」。これは、そのオプショナルの所有する値の<em>強制アンラップ</em>として知られます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">if</span> <span class="nv">convertedNumber</span> != <span class="k">nil</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"convertedNumber has an integer value of </span>\<span class="p">(</span><span class="nv">convertedNumber</span>!<span class="p">)</span><span class="s">."</span>)
</li>
<li>}
</li>
<li>
<span class="c"><span class="enstr">// Prints "convertedNumber has an integer value of 123."</span><!--end_enstr--><span class="jpstr">（「convertedNumberは、整数値123を持ちます」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">For more about the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement, see <a class="reference internal" href="ControlFlow.html"><span class="doc">Control Flow</span></a>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">if</span></code>文に関する詳細は、<a class="reference internal" href="ControlFlow.html"><span class="doc">制御の流れ</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Trying to use <code class="docutils literal notranslate"><span class="pre">!</span></code> to access a nonexistent optional value triggers a runtime error. Always make sure that an optional contains a non-<code class="docutils literal notranslate"><span class="pre">nil</span></code> value before using <code class="docutils literal notranslate"><span class="pre">!</span></code> to force-unwrap its value.</span><!--end_enstr-->
<span class="jpstr">
存在しないオプショナルの値にアクセスするために<code class="docutils literal notranslate"><span class="pre">!</span></code>を使うことを試みることは、実行時エラーの引き金となります。必ずあるオプショナルが<code class="docutils literal notranslate"><span class="pre">nil</span></code>ではない値を含むことを、それの値を強制アンラップする<code class="docutils literal notranslate"><span class="pre">!</span></code>を使う前に確かめてください。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID333">
<h3><span class="enstr">Optional Binding<a class="headerlink" href="#ID333" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
オプショナルを束縛する（定数・変数と結び付ける）<a class="headerlink" href="#ID333" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">You use <em>optional binding</em> to find out whether an optional contains a value, and if so, to make that value available as a temporary constant or variable. Optional binding can be used with <code class="docutils literal notranslate"><span class="pre">if</span></code> and <code class="docutils literal notranslate"><span class="pre">while</span></code> statements to check for a value inside an optional, and to extract that value into a constant or variable, as part of a single action. <code class="docutils literal notranslate"><span class="pre">if</span></code> and <code class="docutils literal notranslate"><span class="pre">while</span></code> statements are described in more detail in <a class="reference internal" href="ControlFlow.html"><span class="doc">Control Flow</span></a>.</span><!--end_enstr-->
<span class="jpstr">
あなたは、あるオプショナルが値を含むかどうか知るために、そしてもしそうならば、その値を一時的な定数または変数として利用可能にするために、<em>オプショナル束縛</em>を使うことができます。オプショナル束縛は、<code class="docutils literal notranslate"><span class="pre">if</span></code>や<code class="docutils literal notranslate"><span class="pre">while</span></code>文と一緒に使用して、オプショナルの内部の値を確認すること、そしてその値を定数または変数に抽出することを、一回の動作で可能にします。<code class="docutils literal notranslate"><span class="pre">if</span></code>および<code class="docutils literal notranslate"><span class="pre">while</span></code>文は更に詳細に<a class="reference internal" href="ControlFlow.html"><span class="doc">「制御の流れ」</span></a>で記述されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Write an optional binding for an <code class="docutils literal notranslate"><span class="pre">if</span></code> statement as follows:</span><!--end_enstr-->
<span class="jpstr">
オプショナルの束縛を<code class="docutils literal notranslate"><span class="pre">if</span></code>文のために次のように書いてください：
</span><!--end_jpstr-->
</p>
<div class="syntax-outline highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">if</span> <span class="k">let</span> <span class="gi">constantName</span> = <span class="gi">someOptional</span> {
</li>
<li>    <span class="gi">statements</span>
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">You can rewrite the <code class="docutils literal notranslate"><span class="pre">possibleNumber</span></code> example from the <a class="reference internal" href="#ID330"><span class="std std-ref">Optionals</span></a> section to use optional binding rather than forced unwrapping:</span><!--end_enstr-->
<span class="jpstr">
あなたは<a class="reference internal" href="#ID330"><span class="std std-ref">オプショナル</span></a>節の<code class="docutils literal notranslate"><span class="pre">possibleNumber</span></code>例を、強制アンラップではなくて、オプショナル束縛を使うように書き直すことができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">if</span> <span class="k">let</span> <span class="nv">actualNumber</span> = <span class="nv">Int</span>(<span class="nv">possibleNumber</span>) {
</li>
<li>    <span class="nv">print</span>(<span class="s">"The string \"</span>\<span class="p">(</span><span class="nv">possibleNumber</span><span class="p">)</span><span class="s">\" has an integer value of </span>\<span class="p">(</span><span class="nv">actualNumber</span><span class="p">)</span><span class="s">"</span>)
</li>
<li>} <span class="k">else</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"The string \"</span>\<span class="p">(</span><span class="nv">possibleNumber</span><span class="p">)</span><span class="s">\" couldn't be converted to an integer"</span>)
</li>
<li>}
</li>
<li>
<span class="c">// Prints "The string "123" has an integer value of 123"</span>
</li>
</ol></div></div></div>
<p><span class="enstr">This code can be read as:</span><!--end_enstr-->
<span class="jpstr">
このコードは、次のように解釈されることができます：
</span><!--end_jpstr-->
</p>
<p><span class="enstr">“If the optional <code class="docutils literal notranslate"><span class="pre">Int</span></code> returned by <code class="docutils literal notranslate"><span class="pre">Int(possibleNumber)</span></code> contains a value, set a new constant called <code class="docutils literal notranslate"><span class="pre">actualNumber</span></code> to the value contained in the optional.”</span><!--end_enstr-->
<span class="jpstr">
「<code class="docutils literal notranslate"><span class="pre">Int(possibleNumber)</span></code>によって返されるオプショナルの<code class="docutils literal notranslate"><span class="pre">Int</span></code>が値を含むならば、ある新しい定数<code class="docutils literal notranslate"><span class="pre">actualNumber</span></code>をそのオプショナルに含まれる値に設定してください。」
</span><!--end_jpstr-->
</p>
<p><span class="enstr">If the conversion is successful, the <code class="docutils literal notranslate"><span class="pre">actualNumber</span></code> constant becomes available for use within the first branch of the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement. It has already been initialized with the value contained <em>within</em> the optional, and so you don’t use the <code class="docutils literal notranslate"><span class="pre">!</span></code> suffix to access its value. In this example, <code class="docutils literal notranslate"><span class="pre">actualNumber</span></code> is simply used to print the result of the conversion.</span><!--end_enstr-->
<span class="jpstr">
変換が成功しているならば、定数<code class="docutils literal notranslate"><span class="pre">actualNumber</span></code>は、<code class="docutils literal notranslate"><span class="pre">if</span></code>文の最初の分岐の内部での利用に役立てられます。それは、すでにオプショナルの<em>内部に</em>含まれる値で初期化されています、それであなたはそれの値にアクセスするために<code class="docutils literal notranslate"><span class="pre">!</span></code>接尾辞を使いません。この例では、<code class="docutils literal notranslate"><span class="pre">actualNumber</span></code>は単にその変換の結果を出力するために使われます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can use both constants and variables with optional binding. If you wanted to manipulate the value of <code class="docutils literal notranslate"><span class="pre">actualNumber</span></code> within the first branch of the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement, you could write <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">var</span> <span class="pre">actualNumber</span></code> instead, and the value contained within the optional would be made available as a variable rather than a constant.</span><!--end_enstr-->
<span class="jpstr">
あなたは、定数と変数の両方をオプショナル束縛で使用できます。あなたが<code class="docutils literal notranslate"><span class="pre">actualNumber</span></code>の値を<code class="docutils literal notranslate"><span class="pre">if</span></code>文の最初の分岐内で取り扱うことを望むならば、あなたは<code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">var</span> <span class="pre">actualNumber</span></code>を代わりに書くことができたでしょう、そしてオプショナル内部に含まれる値は定数ではなく変数として利用可能にされたでしょう。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can include as many optional bindings and Boolean conditions in a single <code class="docutils literal notranslate"><span class="pre">if</span></code> statement as you need to, separated by commas. If any of the values in the optional bindings are <code class="docutils literal notranslate"><span class="pre">nil</span></code> or any Boolean condition evaluates to <code class="docutils literal notranslate"><span class="pre">false</span></code>, the whole <code class="docutils literal notranslate"><span class="pre">if</span></code> statement’s condition is considered to be <code class="docutils literal notranslate"><span class="pre">false</span></code>. The following <code class="docutils literal notranslate"><span class="pre">if</span></code> statements are equivalent:</span><!--end_enstr-->
<span class="jpstr">
あなたは、単一の<code class="docutils literal notranslate"><span class="pre">if</span></code>文の中に、コンマで区切ったオプショナル束縛とブール条件をあなたが必要とするだけ多く含めることができます。何れかのオプショナル束縛の中の値が<code class="docutils literal notranslate"><span class="pre">nil</span></code>であるか何かのブール条件の評価が<code class="docutils literal notranslate"><span class="pre">false</span></code>になるならば、<code class="docutils literal notranslate"><span class="pre">if</span></code>文の条件の全体が<code class="docutils literal notranslate"><span class="pre">false</span></code>であるとみなされます。以下の<code class="docutils literal notranslate"><span class="pre">if</span></code>文は同等です：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">if</span> <span class="k">let</span> <span class="nv">firstNumber</span> = <span class="nv">Int</span>(<span class="s">"4"</span>), <span class="k">let</span> <span class="nv">secondNumber</span> = <span class="nv">Int</span>(<span class="s">"42"</span>), <span class="nv">firstNumber</span> &lt; <span class="nv">secondNumber</span> &amp;&amp; <span class="nv">secondNumber</span> &lt; <span class="m">100</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">firstNumber</span><span class="p">)</span><span class="s"> &lt; </span>\<span class="p">(</span><span class="nv">secondNumber</span><span class="p">)</span><span class="s"> &lt; 100"</span>)
</li>
<li>}
</li>
<li>
<span class="c">// Prints "4 &lt; 42 &lt; 100"</span>
</li>
<li>
</li>
<li>
<span class="k">if</span> <span class="k">let</span> <span class="nv">firstNumber</span> = <span class="nv">Int</span>(<span class="s">"4"</span>) {
</li>
<li>    <span class="k">if</span> <span class="k">let</span> <span class="nv">secondNumber</span> = <span class="nv">Int</span>(<span class="s">"42"</span>) {
</li>
<li>        <span class="k">if</span> <span class="nv">firstNumber</span> &lt; <span class="nv">secondNumber</span> &amp;&amp; <span class="nv">secondNumber</span> &lt; <span class="m">100</span> {
</li>
<li>            <span class="nv">print</span>(<span class="s">"</span>\<span class="p">(</span><span class="nv">firstNumber</span><span class="p">)</span><span class="s"> &lt; </span>\<span class="p">(</span><span class="nv">secondNumber</span><span class="p">)</span><span class="s"> &lt; 100"</span>)
</li>
<li>        }
</li>
<li>    }
</li>
<li>}
</li>
<li>
<span class="c">// Prints "4 &lt; 42 &lt; 100"</span>
</li>
</ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Constants and variables created with optional binding in an <code class="docutils literal notranslate"><span class="pre">if</span></code> statement are available only within the body of the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement. In contrast, the constants and variables created with a <code class="docutils literal notranslate"><span class="pre">guard</span></code> statement are available in the lines of code that follow the <code class="docutils literal notranslate"><span class="pre">guard</span></code> statement, as described in <a class="reference internal" href="ControlFlow.html#ID525"><span class="std std-ref">Early Exit</span></a>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">if</span></code>文の中でオプショナル束縛を使って作成された定数と変数は、その<code class="docutils literal notranslate"><span class="pre">if</span></code>文の本文の内部でのみ利用可能です。対照的に、<code class="docutils literal notranslate"><span class="pre">guard</span></code>文で作成された定数と変数は、その<code class="docutils literal notranslate"><span class="pre">guard</span></code>文以降のコード行において利用可能です、<a class="reference internal" href="ControlFlow.html#ID525"><span class="std std-ref">早期退出</span></a>において議論されるように。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID334">
<h3><span class="enstr">Implicitly Unwrapped Optionals<a class="headerlink" href="#ID334" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
暗黙的にアンラップされるオプショナル<a class="headerlink" href="#ID334" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">As described above, optionals indicate that a constant or variable is allowed to have “no value”. Optionals can be checked with an <code class="docutils literal notranslate"><span class="pre">if</span></code> statement to see if a value exists, and can be conditionally unwrapped with optional binding to access the optional’s value if it does exist.</span><!--end_enstr-->
<span class="jpstr">
先に述べたように、オプショナルは、ある定数や変数が「値がない」状態でも許されることを示します。オプショナルは、値が存在しているかどうか見るために、<code class="docutils literal notranslate"><span class="pre">if</span></code>文を使って調べられることが出来ます、そしてオプショナルの持つ値にそれが存在するならばアクセスするために、オプショナル束縛を使って条件に応じてアンラップされることができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Sometimes it’s clear from a program’s structure that an optional will <em>always</em> have a value, after that value is first set. In these cases, it’s useful to remove the need to check and unwrap the optional’s value every time it’s accessed, because it can be safely assumed to have a value all of the time.</span><!--end_enstr-->
<span class="jpstr">
時々、プログラムの構造から、あるオプショナルが<em>必ず</em>値を持つことが、その値が最初に設定される結果として、はっきりしていることがあります。これらの場合には、オプショナルの値をそれがアクセスされるたびに確認してアンラップする必要を無くすことは役に立ちます、なぜならそれがいつでも値を持つと安全に仮定されることが出来るためです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">These kinds of optionals are defined as <em>implicitly unwrapped optionals</em>. You write an implicitly unwrapped optional by placing an exclamation point (<code class="docutils literal notranslate"><span class="pre">String!</span></code>) rather than a question mark (<code class="docutils literal notranslate"><span class="pre">String?</span></code>) after the type that you want to make optional. Rather than placing an exclamation point after the optional’s name when you use it, you place an exclamation point after the optional’s type when you declare it.</span><!--end_enstr-->
<span class="jpstr">
これらの種類のオプショナルは、<em>暗黙的にアンラップされるオプショナル</em>として定義されます。あなたは暗黙的にアンラップされるオプショナルを、あなたがオプショナルを作りたい型の後に疑問符（<code class="docutils literal notranslate"><span class="pre">String?</span></code>）ではなく感嘆符（<code class="docutils literal notranslate"><span class="pre">String!</span></code>）を置くことによって記述します。あなたがそれを使う時にそのオプショナルのもつ名前の後に感嘆符を置くよりも、あなたがそれを宣言する時にそのオプショナルのもつ型の後に感嘆符を書きたいとあなたは思うでしょう。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Implicitly unwrapped optionals are useful when an optional’s value is confirmed to exist immediately after the optional is first defined and can definitely be assumed to exist at every point thereafter. The primary use of implicitly unwrapped optionals in Swift is during class initialization, as described in <a class="reference internal" href="AutomaticReferenceCounting.html#ID55"><span class="std std-ref">Unowned References and Implicitly Unwrapped Optional Properties</span></a>.</span><!--end_enstr-->
<span class="jpstr">
暗黙的にアンラップされるオプショナルは、あるオプショナルの値が存在するのをそのオプショナルが最初に定義された直後に確かめられて、それ以降あらゆる所で存在するのを自信を持って仮定出来るようにされる場合に役に立ちます。スウィフトでの暗黙的にアンラップされるオプショナルの主要な利用法は、<a class="reference internal" href="AutomaticReferenceCounting.html#ID55"><span class="std std-ref">所有参照と暗黙的にアンラップされるオプショナルのプロパティ</span></a>で記述されるように、クラス初期化の間にあります。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">An implicitly unwrapped optional is a normal optional behind the scenes, but can also be used like a non-optional value, without the need to unwrap the optional value each time it’s accessed. The following example shows the difference in behavior between an optional string and an implicitly unwrapped optional string when accessing their wrapped value as an explicit <code class="docutils literal notranslate"><span class="pre">String</span></code>:</span><!--end_enstr-->
<span class="jpstr">
暗黙的にアンラップされるオプショナルは、舞台裏では普通のオプショナルです、しかしまたオプショナルでない値のように扱うこともできます、それがアクセスされるたびにオプショナルの値をアンラップする必要はありません。以下の例は、オプショナルの文字列と、暗黙的にアンラップされるオプショナルの文字列の間での、それらのラップされた値に明示的な<code class="docutils literal notranslate"><span class="pre">String</span></code>としてアクセスする場合での挙動の違いを示します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">possibleString</span>: <span class="nc">String</span>? = <span class="s">"An optional string."</span>
</li>
<li>
<span class="k">let</span> <span class="nv">forcedString</span>: <span class="nc">String</span> = <span class="nv">possibleString</span>! <span class="enstr"><span class="c">// requires an exclamation point</span></span><!--end_enstr--><span class="jpstr"><span class="c">（感嘆符が要求されます）</span></span><!--end_jpstr--></li>
<li>
</li>
<li>
<span class="k">let</span> <span class="nv">assumedString</span>: <span class="nc">String</span>! = <span class="s">"An implicitly unwrapped optional string."</span>
</li>
<li>
<span class="k">let</span> <span class="nv">implicitString</span>: <span class="nc">String</span> = <span class="nv">assumedString</span> <span class="enstr"><span class="c">// no need for an exclamation point</span></span><!--end_enstr--><span class="jpstr"><span class="c">（感嘆符の必要はありません）</span></span><!--end_jpstr--></li>
</ol></div></div></div>
<p><span class="enstr">You can think of an implicitly unwrapped optional as giving permission for the optional to be force-unwrapped if needed. When you use an implicitly unwrapped optional value, Swift first tries to use it as an ordinary optional value; if it can’t be used as an optional, Swift force-unwraps the value. In the code above, the optional value <code class="docutils literal notranslate"><span class="pre">assumedString</span></code> is force-unwrapped before assigning its value to <code class="docutils literal notranslate"><span class="pre">implicitString</span></code> because <code class="docutils literal notranslate"><span class="pre">implicitString</span></code> has an explicit, non-optional type of <code class="docutils literal notranslate"><span class="pre">String</span></code>. In code below, <code class="docutils literal notranslate"><span class="pre">optionalString</span></code> doesn’t have an explicit type so it’s an ordinary optional.</span><!--end_enstr-->
<span class="jpstr">
あなたは暗黙的にアンラップされるオプショナルを、必要に応じて強制アンラップされる許可をそのオプショナルに与えていると考えることができます。あなたがある暗黙的にアンラップされるオプショナル値を使う場合、Swiftはまずそれを普通のオプショナル値として使おうと試みます；それがオプショナルとして使用できないならば、Swiftは値を強制アンラップします。上のコードにおいて、オプショナル値<code class="docutils literal notranslate"><span class="pre">assumedString</span></code>は強制アンラップされます、それの値を<code class="docutils literal notranslate"><span class="pre">implicitString</span></code>に割り当てる前にです、なぜなら<code class="docutils literal notranslate"><span class="pre">implicitString</span></code>はある明示的な、非オプショナル型の<code class="docutils literal notranslate"><span class="pre">String</span></code>を持つからです。下のコードにおいて、<code class="docutils literal notranslate"><span class="pre">optionalString</span></code>は明示的な型を持ちません、それでそれは普通のオプショナルです。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">optionalString</span> = <span class="nv">assumedString</span>
</li>
<li>
<span class="c"><span class="enstr">// The type of optionalString is "String?" and assumedString isn't force-unwrapped.</span><!--end_enstr--><span class="jpstr">（optionalString の型は "String?" です、そして assumedString は強制アンラップされません。）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">If an implicitly unwrapped optional is <code class="docutils literal notranslate"><span class="pre">nil</span></code> and you try to access its wrapped value, you’ll trigger a runtime error. The result is exactly the same as if you place an exclamation point after a normal optional that doesn’t contain a value.</span><!--end_enstr-->
<span class="jpstr">
暗黙的にアンラップされるオプショナルが<code class="docutils literal notranslate"><span class="pre">nil</span></code>であり、あなたがそれのラップされた値にアクセスしようとするならば、あなたは実行時エラーを引き起こします。その結果は、あなたが値を含まない通常のオプショナルの後に感嘆符を置いた場合と正確に同じものです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can check whether an implicitly unwrapped optional is <code class="docutils literal notranslate"><span class="pre">nil</span></code> the same way you check a normal optional:</span><!--end_enstr-->
<span class="jpstr">
あなたは、暗黙的にアンラップされるオプショナルが<code class="docutils literal notranslate"><span class="pre">nil</span></code>であるかどうかを確認することが、あなたが通常のオプショナルを調べるのと同じ方法で可能です。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">if</span> <span class="nv">assumedString</span> != <span class="k">nil</span> {
</li>
<li>    <span class="nv">print</span>(<span class="nv">assumedString</span>!)
</li>
<li>}
</li>
<li>
<span class="c"><span class="enstr">// Prints "An implicitly unwrapped optional string."</span><!--end_enstr--><span class="jpstr">（「暗黙的にアンラップされるオプショナルの文字列。」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">You can also use an implicitly unwrapped optional with optional binding, to check and unwrap its value in a single statement:</span><!--end_enstr-->
<span class="jpstr">
あなたは、また、暗黙的にアンラップされるオプショナルをオプショナル束縛とともに使うことができます、１つの文でその値を確認してアンラップするためには：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">if</span> <span class="k">let</span> <span class="nv">definiteString</span> = <span class="nv">assumedString</span> {
</li>
<li>    <span class="nv">print</span>(<span class="nv">definiteString</span>)
</li>
<li>}
</li>
<li>
<span class="c"><span class="enstr">// Prints "An implicitly unwrapped optional string."</span><!--end_enstr--><span class="jpstr">（「暗黙的にアンラップされるオプショナルの文字列。」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Don’t use an implicitly unwrapped optional when there’s a possibility of a variable becoming <code class="docutils literal notranslate"><span class="pre">nil</span></code> at a later point. Always use a normal optional type if you need to check for a <code class="docutils literal notranslate"><span class="pre">nil</span></code> value during the lifetime of a variable.</span><!--end_enstr-->
<span class="jpstr">
ある変数がその後のある時点で<code class="docutils literal notranslate"><span class="pre">nil</span></code>になる可能性がある時には、暗黙的にアンラップされるオプショナルを使用しないでください。あなたがある変数の生涯のある時期に<code class="docutils literal notranslate"><span class="pre">nil</span></code>値について確認する必要があるならば、必ず普通のオプショナル型を使ってください。
</span><!--end_jpstr-->
</p>
</div>
</div>
</div>
<div class="section" id="ID515">
<h2><span class="enstr">Error Handling<a class="headerlink" href="#ID515" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
エラーの処理<a class="headerlink" href="#ID515" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">You use <em>error handling</em> to respond to error conditions your program may encounter during execution.</span><!--end_enstr-->
<span class="jpstr">
あなたは、<em>エラー処理</em>を使ってあなたのプログラムが実行の間に遭遇するエラー状態に応答することができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">In contrast to optionals, which can use the presence or absence of a value to communicate success or failure of a function, error handling allows you to determine the underlying cause of failure, and, if necessary, propagate the error to another part of your program.</span><!--end_enstr-->
<span class="jpstr">
オプショナルと対比して（それは値の有無を使って、ある関数の成否を伝えることができます）、エラー処理はあなたに根本的な失敗の原因を突き止めること、そして、必要ならば、そのエラーをあなたのプログラムの別の部分に伝えることを可能にします。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">When a function encounters an error condition, it <em>throws</em> an error. That function’s caller can then <em>catch</em> the error and respond appropriately.</span><!--end_enstr-->
<span class="jpstr">
ある関数がエラー状態に遭遇するとき、それはあるエラーを<em>スローします</em>（投げます）。その関数の呼び出し側はそのときそのエラーを<em>キャッチして</em>（捕まえて）適切に応答することができます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">func</span> <span class="nv">canThrowAnError</span>() <span class="k">throws</span> {
</li>
<li>    <span class="c"><span class="enstr">// this function may or may not throw an error</span><!--end_enstr--><span class="jpstr">（この関数はエラーをスローするかもしれないししないかもしれない）</span><!--end_jpstr--></span>
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">A function indicates that it can throw an error by including the <code class="docutils literal notranslate"><span class="pre">throws</span></code> keyword in its declaration. When you call a function that can throw an error, you prepend the <code class="docutils literal notranslate"><span class="pre">try</span></code> keyword to the expression.</span><!--end_enstr-->
<span class="jpstr">
ある関数は、それがエラーをスローできることを<code class="docutils literal notranslate"><span class="pre">throws</span></code>キーワードをそれの宣言に含めることによって示します。あなたがエラーをスローできる関数を呼ぶとき、あなたは<code class="docutils literal notranslate"><span class="pre">try</span></code>キーワードをその式の前に追加します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Swift automatically propagates errors out of their current scope until they’re handled by a <code class="docutils literal notranslate"><span class="pre">catch</span></code> clause.</span><!--end_enstr-->
<span class="jpstr">
スウィフトは自動的に、エラーをそれの現在のスコープの外に、それが<code class="docutils literal notranslate"><span class="pre">catch</span></code>節によって取り扱われるまで伝えます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">do</span> {
</li>
<li>    <span class="k">try</span> <span class="nv">canThrowAnError</span>()
</li>
<li>    <span class="c"><span class="enstr">// no error was thrown</span><!--end_enstr--><span class="jpstr">（エラーはスローされなかった）</span><!--end_jpstr--></span>
</li>
<li>} <span class="k">catch</span> {
</li>
<li>    <span class="c"><span class="enstr">// an error was thrown</span><!--end_enstr--><span class="jpstr">（エラーがスローされた）</span><!--end_jpstr--></span>
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">A <code class="docutils literal notranslate"><span class="pre">do</span></code> statement creates a new containing scope, which allows errors to be propagated to one or more <code class="docutils literal notranslate"><span class="pre">catch</span></code> clauses.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">do</span></code>文はひとつの新しく取り囲んでいるスコープを作成します、それはエラーに１つ以上の<code class="docutils literal notranslate"><span class="pre">catch</span></code>節に伝えられることを可能にします。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Here’s an example of how error handling can be used to respond to different error conditions:</span><!--end_enstr-->
<span class="jpstr">
ここにどのようにエラー処理が異なるエラー状態に応答するために使われることができるかの例があります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">func</span> <span class="nv">makeASandwich</span>() <span class="k">throws</span> {
</li>
<li>    <span class="c">// ...</span>
</li>
<li>}
</li>
<li>
</li>
<li>
<span class="k">do</span> {
</li>
<li>    <span class="k">try</span> <span class="nv">makeASandwich</span>()
</li>
<li>    <span class="nv">eatASandwich</span>()
</li>
<li>} <span class="k">catch</span> <span class="nv">SandwichError</span>.<span class="nv">outOfCleanDishes</span> {
</li>
<li>    <span class="nv">washDishes</span>()
</li>
<li>} <span class="k">catch</span> <span class="nv">SandwichError</span>.<span class="nv">missingIngredients</span>(<span class="k">let</span> <span class="nv">ingredients</span>) {
</li>
<li>    <span class="nv">buyGroceries</span>(<span class="nv">ingredients</span>)
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">In this example, the <code class="docutils literal notranslate"><span class="pre">makeASandwich()</span></code> function will throw an error if no clean dishes are available or if any ingredients are missing. Because <code class="docutils literal notranslate"><span class="pre">makeASandwich()</span></code> can throw an error, the function call is wrapped in a <code class="docutils literal notranslate"><span class="pre">try</span></code> expression. By wrapping the function call in a <code class="docutils literal notranslate"><span class="pre">do</span></code> statement, any errors that are thrown will be propagated to the provided <code class="docutils literal notranslate"><span class="pre">catch</span></code> clauses.</span><!--end_enstr-->
<span class="jpstr">
この例において、<code class="docutils literal notranslate"><span class="pre">makeASandwich()</span></code>関数は、綺麗な皿が利用可能でないならばまたは何の食材も見つからないならばエラーをスローします。<code class="docutils literal notranslate"><span class="pre">makeASandwich()</span></code>はエラーをスロー可能なので、この関数呼び出しは<code class="docutils literal notranslate"><span class="pre">try</span></code>式で包まれます。その関数呼び出しを<code class="docutils literal notranslate"><span class="pre">do</span></code>文の中に包み込むことによって、スローされるどんなエラーも添付の<code class="docutils literal notranslate"><span class="pre">catch</span></code>節に伝えられるようになります。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">If no error is thrown, the <code class="docutils literal notranslate"><span class="pre">eatASandwich()</span></code> function is called. If an error is thrown and it matches the <code class="docutils literal notranslate"><span class="pre">SandwichError.outOfCleanDishes</span></code> case, then the <code class="docutils literal notranslate"><span class="pre">washDishes()</span></code> function will be called. If an error is thrown and it matches the <code class="docutils literal notranslate"><span class="pre">SandwichError.missingIngredients</span></code> case, then the <code class="docutils literal notranslate"><span class="pre">buyGroceries(_:)</span></code> function is called with the associated <code class="docutils literal notranslate"><span class="pre">[String]</span></code> value captured by the <code class="docutils literal notranslate"><span class="pre">catch</span></code> pattern.</span><!--end_enstr-->
<span class="jpstr">
エラーがスローされないならば、<code class="docutils literal notranslate"><span class="pre">eatASandwich()</span></code>関数が呼び出されます。エラーがスローされてそれが<code class="docutils literal notranslate"><span class="pre">SandwichError.outOfCleanDishes</span></code>ケース節にマッチするならば、そのとき<code class="docutils literal notranslate"><span class="pre">washDishes()</span></code>関数が呼ばれます。エラーがスローされてそれが<code class="docutils literal notranslate"><span class="pre">SandwichError.missingIngredients</span></code>ケース節にマッチするならば、そのとき<code class="docutils literal notranslate"><span class="pre">buyGroceries(_:)</span></code>関数がその<code class="docutils literal notranslate"><span class="pre">catch</span></code>パターンによってキャプチャされた<code class="docutils literal notranslate"><span class="pre">[String]</span></code>関連値とともに呼ばれます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Throwing, catching, and propagating errors is covered in greater detail in <a class="reference internal" href="ErrorHandling.html"><span class="doc">Error Handling</span></a>.</span><!--end_enstr-->
<span class="jpstr">
エラーのスロー、キャッチ、そして伝達は、詳細に<a class="reference internal" href="ErrorHandling.html"><span class="doc">エラー処理</span></a>において扱われます。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID335">
<h2><span class="enstr">Assertions and Preconditions<a class="headerlink" href="#ID335" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
表明と前提条件<a class="headerlink" href="#ID335" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr"><em>Assertions</em> and <em>preconditions</em> are checks that happen at runtime. You use them to make sure an essential condition is satisfied before executing any further code. If the Boolean condition in the assertion or precondition evaluates to <code class="docutils literal notranslate"><span class="pre">true</span></code>, code execution continues as usual. If the condition evaluates to <code class="docutils literal notranslate"><span class="pre">false</span></code>, the current state of the program is invalid; code execution ends, and your app is terminated.</span><!--end_enstr-->
<span class="jpstr">
<em>表明</em>と<em>前提条件</em>は、起こることを実行時で調べられます。あなたはそれらを使って、必要不可欠な条件が満たされるのを何らかのその先のコードが実行される前に確実なものにします。表明または前提条件におけるブール条件が<code class="docutils literal notranslate"><span class="pre">true</span></code>に評価されるならば、コードは普段通り続けて実行されます。条件が<code class="docutils literal notranslate"><span class="pre">false</span></code>に評価されるならば、プログラムの現在の状態は無効です；コード実行は止まり、そしてあなたのアプリは終了させられます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You use assertions and preconditions to express the assumptions you make and the expectations you have while coding, so you can include them as part of your code. Assertions help you find mistakes and incorrect assumptions during development, and preconditions help you detect issues in production.</span><!--end_enstr-->
<span class="jpstr">
あなたは表明と前提条件を使うことであなたのする想定とあなたが持つ期待をコーディングの間に表します、それであなたはそれらをあなたのコードの一部として含めることができます。表明は、あなたが失策や間違った想定を見つけるのを開発中に助けます、そして前提条件は、あなたが製品における問題点を見抜くのを助けます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">In addition to verifying your expectations at runtime, assertions and preconditions also become a useful form of documentation within the code. Unlike the error conditions discussed in <a class="reference internal" href="#ID515"><span class="std std-ref">Error Handling</span></a> above, assertions and preconditions aren’t used for recoverable or expected errors. Because a failed assertion or precondition indicates an invalid program state, there’s no way to catch a failed assertion.</span><!--end_enstr-->
<span class="jpstr">
あなたの期待を実行時で実証するのに加えて、表明と前提条件はまたコード内部での有用な文書化形式となります。上の<a class="reference internal" href="#ID515"><span class="std std-ref">エラー処理</span></a>で議論されるエラー条件とは違い、表明と前提条件は回復できるまたは予想されたエラーに対して使われません。失敗した表明または前提条件は無効なプログラム状態を示すことから、失敗した表明を受け止めるための方法はありません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Using assertions and preconditions isn’t a substitute for designing your code in such a way that invalid conditions are unlikely to arise. However, using them to enforce valid data and state causes your app to terminate more predictably if an invalid state occurs, and helps make the problem easier to debug. Stopping execution as soon as an invalid state is detected also helps limit the damage caused by that invalid state.</span><!--end_enstr-->
<span class="jpstr">
表明と前提条件を使用することは、無効な条件が思いもよらず起こるようなあなたのコードの設計に対する代役ではありません。しかしながら、それらを使って有効なデータと状態を遵守させることは、あなたのアプリに不正な状態が生じる場合により予測のつく結びとなるようにします、そして問題をより簡単にデバッグする助けとなります。無効な状態が検知されるやいなや実行を停止することはまた、その無効な状態によって起こされる被害を抑えます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The difference between assertions and preconditions is in when they’re checked: Assertions are checked only in debug builds, but preconditions are checked in both debug and production builds. In production builds, the condition inside an assertion isn’t evaluated. This means you can use as many assertions as you want during your development process, without impacting performance in production.</span><!--end_enstr-->
<span class="jpstr">
表明と前提条件の間の違いは、それらが調べられる時にあります：表明はデバッグビルドにおいてのみ調べられます、しかし前提条件はデバッグおよび製品（プロダクション）ビルドの両方において調べられます。プロダクションビルドでは、表明内の条件は評価されません。これが意味するのは、あなたは多くの表明をあなたが望むだけあなたの開発過程の間に使用できる、製品での性能に影響を与えることなしに、ということです。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID336">
<h3><span class="enstr">Debugging with Assertions<a class="headerlink" href="#ID336" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
表明を使ってデバッグする<a class="headerlink" href="#ID336" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">You write an assertion by calling the <a class="reference external" href="../../../developer.apple.com/documentation/swift/1541112-assert.html"><code class="docutils literal notranslate"><span class="pre">assert(_:_:file:line:)</span></code></a> function from the Swift standard library. You pass this function an expression that evaluates to <code class="docutils literal notranslate"><span class="pre">true</span></code> or <code class="docutils literal notranslate"><span class="pre">false</span></code> and a message to display if the result of the condition is <code class="docutils literal notranslate"><span class="pre">false</span></code>. For example:</span><!--end_enstr-->
<span class="jpstr">
あなたは表明を<a class="reference external" href="../../../developer.apple.com/documentation/swift/1541112-assert.html"><code class="docutils literal notranslate"><span class="pre">assert(_:_:file:line:)</span></code></a>関数をSwift標準ライブラリから呼び出すことによって記述します。あなたはこの関数に、<code class="docutils literal notranslate"><span class="pre">true</span></code>または<code class="docutils literal notranslate"><span class="pre">false</span></code>に評価する式と条件の結果が<code class="docutils literal notranslate"><span class="pre">false</span></code>であるならば表示するメッセージを渡します。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">age</span> = <span class="m">-3</span>
</li>
<li>
<span class="nv">assert</span>(<span class="nv">age</span> &gt;= <span class="m">0</span>, <span class="s">"A person's age can't be less than zero."</span>)
</li>
<li>
<span class="c"><span class="enstr">// This assertion fails because -3 isn't &gt;= 0.</span><!--end_enstr--><span class="jpstr">（この表明は失敗する、なぜなら-3 は &gt;= 0 ではないから。）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">In this example, code execution continues if <code class="docutils literal notranslate"><span class="pre">age</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code> evaluates to <code class="docutils literal notranslate"><span class="pre">true</span></code>, that is, if the value of <code class="docutils literal notranslate"><span class="pre">age</span></code> is nonnegative. If the value of <code class="docutils literal notranslate"><span class="pre">age</span></code> is negative, as in the code above, then <code class="docutils literal notranslate"><span class="pre">age</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code> evaluates to <code class="docutils literal notranslate"><span class="pre">false</span></code>, and the assertion fails, terminating the application.</span><!--end_enstr-->
<span class="jpstr">
この例において、コード実行は<code class="docutils literal notranslate"><span class="pre">age</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code>が<code class="docutils literal notranslate"><span class="pre">true</span></code>に評価されるならば、すなわち<code class="docutils literal notranslate"><span class="pre">age</span></code>の値が負でないならば継続します。<code class="docutils literal notranslate"><span class="pre">age</span></code>の値が負であるならば、上のコードでのように、そのとき<code class="docutils literal notranslate"><span class="pre">age</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code>は<code class="docutils literal notranslate"><span class="pre">false</span></code>に評価され、そして表明は失敗して、アプリケーションを終了します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can omit the assertion message—for example, when it would just repeat the condition as prose.</span><!--end_enstr-->
<span class="jpstr">
あなたは表明メッセージを省略できます — 例えば、それが単に条件を単調に繰り返す場合。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="nv">assert</span>(<span class="nv">age</span> &gt;= <span class="m">0</span>)
</li></ol></div></div></div>
<p><span class="enstr">If the code already checks the condition, you use the <a class="reference external" href="../../../developer.apple.com/documentation/swift/1539616-assertionfailure.html"><code class="docutils literal notranslate"><span class="pre">assertionFailure(_:file:line:)</span></code></a> function to indicate that an assertion has failed. For example:</span><!--end_enstr-->
<span class="jpstr">
コードがすでに条件を調べるならば、あなたは<a class="reference external" href="../../../developer.apple.com/documentation/swift/1539616-assertionfailure.html"><code class="docutils literal notranslate"><span class="pre">assertionFailure(_:file:line:)</span></code></a>関数を使って表明が失敗していることを示してください。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">if</span> <span class="nv">age</span> &gt; <span class="m">10</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"You can ride the roller-coaster or the ferris wheel."</span>)
</li>
<li>} <span class="k">else</span> <span class="k">if</span> <span class="nv">age</span> &gt;= <span class="m">0</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"You can ride the ferris wheel."</span>)
</li>
<li>} <span class="k">else</span> {
</li>
<li>    <span class="nv">assertionFailure</span>(<span class="s">"A person's age can't be less than zero."</span>)
</li>
<li>}
</li>
</ol></div></div></div>
</div>
<div class="section" id="ID554">
<h3><span class="enstr">Enforcing Preconditions<a class="headerlink" href="#ID554" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
前提条件の遵守<a class="headerlink" href="#ID554" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">Use a precondition whenever a condition has the potential to be false, but must <em>definitely</em> be true for your code to continue execution. For example, use a precondition to check that a subscript isn’t out of bounds, or to check that a function has been passed a valid value.</span><!--end_enstr-->
<span class="jpstr">
ある条件が偽である可能性をもつ、しかし<em>definitely</em>があなたのコードの実行の継続のためにtrueでなければならない時はいつでも前提条件を使ってください。例えば、前提時要件を使って、ある添え字が範囲外でないことを調べてください、またはある関数が有効な値を渡されていることを確認してください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You write a precondition by calling the <a class="reference external" href="../../../developer.apple.com/documentation/swift/1540960-precondition.html"><code class="docutils literal notranslate"><span class="pre">precondition(_:_:file:line:)</span></code></a> function. You pass this function an expression that evaluates to <code class="docutils literal notranslate"><span class="pre">true</span></code> or <code class="docutils literal notranslate"><span class="pre">false</span></code> and a message to display if the result of the condition is <code class="docutils literal notranslate"><span class="pre">false</span></code>. For example:</span><!--end_enstr-->
<span class="jpstr">
あなたは、前提条件を<a class="reference external" href="../../../developer.apple.com/documentation/swift/1540960-precondition.html"><code class="docutils literal notranslate"><span class="pre">precondition(_:_:file:line:)</span></code></a>関数を呼び出すことによって記述します。あなたはこの関数に、<code class="docutils literal notranslate"><span class="pre">true</span></code>または<code class="docutils literal notranslate"><span class="pre">false</span></code>に評価する式と条件の結果が<code class="docutils literal notranslate"><span class="pre">false</span></code>であるならば表示するメッセージを渡します。例えば：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="c"><span class="enstr">// In the implementation of a subscript...</span><!--end_enstr--><span class="jpstr">（ある添え字の実装において...）</span><!--end_jpstr--></span>
</li>
<li>
<span class="nv">precondition</span>(<span class="nv">index</span> &gt; <span class="m">0</span>, <span class="s">"Index must be greater than zero."</span>)
</li>
</ol></div></div></div>
<p><span class="enstr">You can also call the <a class="reference external" href="../../../developer.apple.com/documentation/swift/1539374-preconditionfailure.html"><code class="docutils literal notranslate"><span class="pre">preconditionFailure(_:file:line:)</span></code></a> function to indicate that a failure has occurred—for example, if the default case of a switch was taken, but all valid input data should have been handled by one of the switch’s other cases.</span><!--end_enstr-->
<span class="jpstr">
あなたはまた、<a class="reference external" href="../../../developer.apple.com/documentation/swift/1539374-preconditionfailure.html"><code class="docutils literal notranslate"><span class="pre">preconditionFailure(_:file:line:)</span></code></a>関数を呼び出して失敗がすでに起こっていることを示すことができます — 例えば、あるスイッチ文の省略時のケース節が取られた、しかし全ての有効な入力データがそのスイッチ文の他のケース節の１つによって取り扱われてしまっている場合。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p><span class="enstr">If you compile in unchecked mode (<code class="docutils literal notranslate"><span class="pre">-Ounchecked</span></code>), preconditions aren’t checked. The compiler assumes that preconditions are always true, and it optimizes your code accordingly. However, the <code class="docutils literal notranslate"><span class="pre">fatalError(_:file:line:)</span></code> function always halts execution, regardless of optimization settings.</span><!--end_enstr-->
<span class="jpstr">
あなたが未検査モード（<code class="docutils literal notranslate"><span class="pre">-Ounchecked</span></code>）でコンパイルするならば、前提条件は調べられません。コンパイラは、その前提条件が常にtrueであるとみなします、そしてそれはあなたのコードをそれを受けて最適化します。しかしながら、<code class="docutils literal notranslate"><span class="pre">fatalError(_:file:line:)</span></code>関数は常に実行を停止します、最適化設定に関係なく。
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">You can use the <code class="docutils literal notranslate"><span class="pre">fatalError(_:file:line:)</span></code> function during prototyping and early development to create stubs for functionality that hasn’t been implemented yet, by writing <code class="docutils literal notranslate"><span class="pre">fatalError("Unimplemented")</span></code> as the stub implementation. Because fatal errors are never optimized out, unlike assertions or preconditions, you can be sure that execution always halts if it encounters a stub implementation.</span><!--end_enstr-->
<span class="jpstr">
あなたは、<code class="docutils literal notranslate"><span class="pre">fatalError(_:file:line:)</span></code>関数を試作段階および開発初期の間に使って、まだ実装されていない機能性に対してスタブ（代用品）を作成することが、<code class="docutils literal notranslate"><span class="pre">fatalError("Unimplemented")</span></code>をスタブ実装として記述することによって行えます。致命的なエラーは決して間違って最適化されません、表明や前提条件と違います、あなたは実行が常に停止することをそれがスタブ実装に遭遇する場合には確信できます。
</span><!--end_jpstr-->
</p>
</div>
</div>
</div>
</div>


    </article>
    <div class="next_previous">
        <p class="previous"><a href="../GuidedTour/GuidedTour.html"><span class="enstr">A Swift Tour</span><!--end_enstr-->
<span class="jpstr">
スウィフトツアー
</span><!--end_jpstr-->
</a></p>
        <p class="next"><a href="BasicOperators.html"><span class="enstr">Basic Operators</span><!--end_enstr-->
<span class="jpstr">
基本の演算子
</span><!--end_jpstr-->
</a></p>
    </div>
</main>


<footer role="contentinfo">
  <aside>
    <a href="//swift.org/atom.xml" title="Subscribe to Site Updates"><i class="feed">Subscribe</i></a>
    <a href="https://twitter.com/swiftlang" rel="nofollow" title="Follow @SwiftLang on Twitter"><i class="twitter">Twitter</i></a>
  </aside>

  <p class="copyright">Copyright © 2022 Apple Inc. All rights reserved.</p>
  <p class="trademark">Swift and the Swift logo are trademarks of Apple Inc.</p>
  <p class="privacy">
    <a href="//www.apple.com/privacy/privacy-policy/">Privacy Policy</a>
    <a href="//www.apple.com/legal/privacy/en-ww/cookies/">Cookies</a>
  </p>
</footer>
<div id="jump_to_overlay"></div>
<script src="../static/javascripts/application.js"></script>
  
</body>
</html>
