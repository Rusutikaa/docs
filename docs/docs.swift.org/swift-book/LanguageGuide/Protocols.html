<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="author" content="Apple Inc.">
    <meta name="viewport" content="width=device-width initial-scale=1">
    
    <title>Protocols — The Swift Programming Language (Swift 5.6)</title>
    
    <link rel="license" href="/LICENSE.txt">
    <link rel="stylesheet" media="all" href="../static/stylesheets/application.css">
    <link rel="stylesheet" media="all" href="../static/stylesheets/tspl.css">
    <link rel="shortcut icon" sizes="16x16 24x24 32x32 48x48 64x64" type="image/vnd.microsoft.icon" href="/favicon.ico">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
    <link rel="mask-icon" href="/assets/images/icon-swift.svg" color="#F05339"> 
  </head>
  <body>


<nav role="navigation">
    <header role="banner">
      <h1 id="logo">
        <a href="https://swift.org/" title="Swift.org" role="img" aria-label="Swift.org">
          Swift.org
        </a>
      </h1>
    </header>

    <div id="menu-toggle" class="menu-toggle open"></div>

    <h2>The Swift Programming Language<div>Swift 5.6</div>
</h2>

    <ul>
    <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html"><span class="enstr">Welcome to Swift</span><!--end_enstr-->
<span class="jpstr">
スウィフトにようこそ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1 current">
<a class="reference internal" href="TheBasics.html"><span class="enstr">Language Guide</span><!--end_enstr-->
<span class="jpstr">
言語ガイド
</span><!--end_jpstr-->
</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="TheBasics.html"><span class="enstr">The Basics</span><!--end_enstr-->
<span class="jpstr">
基本
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="BasicOperators.html"><span class="enstr">Basic Operators</span><!--end_enstr-->
<span class="jpstr">
基本の演算子
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="StringsAndCharacters.html"><span class="enstr">Strings and Characters</span><!--end_enstr-->
<span class="jpstr">
文字列と文字
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="CollectionTypes.html"><span class="enstr">Collection Types</span><!--end_enstr-->
<span class="jpstr">
コレクション型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ControlFlow.html"><span class="enstr">Control Flow</span><!--end_enstr-->
<span class="jpstr">
制御の流れ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Functions.html"><span class="enstr">Functions</span><!--end_enstr-->
<span class="jpstr">
関数
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Closures.html"><span class="enstr">Closures</span><!--end_enstr-->
<span class="jpstr">
クロージャ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Enumerations.html"><span class="enstr">Enumerations</span><!--end_enstr-->
<span class="jpstr">
列挙
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ClassesAndStructures.html"><span class="enstr">Structures and Classes</span><!--end_enstr-->
<span class="jpstr">
構造体とクラス
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Properties.html"><span class="enstr">Properties</span><!--end_enstr-->
<span class="jpstr">
プロパティ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Methods.html"><span class="enstr">Methods</span><!--end_enstr-->
<span class="jpstr">
メソッド
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Subscripts.html"><span class="enstr">Subscripts</span><!--end_enstr-->
<span class="jpstr">
添え字
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Inheritance.html"><span class="enstr">Inheritance</span><!--end_enstr-->
<span class="jpstr">
継承
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Initialization.html"><span class="enstr">Initialization</span><!--end_enstr-->
<span class="jpstr">
初期化
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Deinitialization.html"><span class="enstr">Deinitialization</span><!--end_enstr-->
<span class="jpstr">
デイニシャライズ
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="OptionalChaining.html"><span class="enstr">Optional Chaining</span><!--end_enstr-->
<span class="jpstr">
オプショナル連鎖
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="ErrorHandling.html"><span class="enstr">Error Handling</span><!--end_enstr-->
<span class="jpstr">
エラーの処理
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Concurrency.html"><span class="enstr">Concurrency</span><!--end_enstr-->
<span class="jpstr">
並行性
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="TypeCasting.html"><span class="enstr">Type Casting</span><!--end_enstr-->
<span class="jpstr">
型キャスト
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="NestedTypes.html"><span class="enstr">Nested Types</span><!--end_enstr-->
<span class="jpstr">
入れ子にされた型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Extensions.html"><span class="enstr">Extensions</span><!--end_enstr-->
<span class="jpstr">
拡張
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#"><span class="enstr">Protocols</span><!--end_enstr-->
<span class="jpstr">
プロトコル
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="Generics.html"><span class="enstr">Generics</span><!--end_enstr-->
<span class="jpstr">
総称体
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="OpaqueTypes.html"><span class="enstr">Opaque Types</span><!--end_enstr-->
<span class="jpstr">
不透明型
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AutomaticReferenceCounting.html"><span class="enstr">Automatic Reference Counting</span><!--end_enstr-->
<span class="jpstr">
自動参照カウント
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="MemorySafety.html"><span class="enstr">Memory Safety</span><!--end_enstr-->
<span class="jpstr">
メモリ安全
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AccessControl.html"><span class="enstr">Access Control</span><!--end_enstr-->
<span class="jpstr">
アクセス制御
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l2"><a class="reference internal" href="AdvancedOperators.html"><span class="enstr">Advanced Operators</span><!--end_enstr-->
<span class="jpstr">
先進の演算子
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ReferenceManual/AboutTheLanguageReference.html"><span class="enstr">Language Reference</span><!--end_enstr-->
<span class="jpstr">
言語リファレンス
</span><!--end_jpstr-->
</a></li>
<li class="toctree-l1"><a class="reference internal" href="../RevisionHistory/RevisionHistory.html"><span class="enstr">Revision History</span><!--end_enstr-->
<span class="jpstr">
改訂履歴
</span><!--end_jpstr-->
</a></li>
</ul>

    <li class="toctree-l1 return"><a class="reference internal" href="../../../index.html">← Go to Index</a></li>
    </ul>
</nav>




<main role="main">
    <article class="page">
        <menu id="bashful" type="toolbar">
          <div class="inner">
            <menuitem id="jump_to" class="menu-bar-item closed">
            <span id="jump_to_toggle">On This Page</span>
            <div class="chevron">
                <div class="chevy chevron-left"></div>
                <div class="chevy chevron-right"></div>
            </div>
            <menu type="list" class="details">
<ul>
<li>
<a class="reference internal" href="#"><span class="enstr">Protocols</span><!--end_enstr-->
<span class="jpstr">
プロトコル
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID268"><span class="enstr">Protocol Syntax</span><!--end_enstr-->
<span class="jpstr">
プロトコル構文
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID269"><span class="enstr">Property Requirements</span><!--end_enstr-->
<span class="jpstr">
プロパティ要件
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID270"><span class="enstr">Method Requirements</span><!--end_enstr-->
<span class="jpstr">
メソッド要件
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID271"><span class="enstr">Mutating Method Requirements</span><!--end_enstr-->
<span class="jpstr">
変更メソッド要件
</span><!--end_jpstr-->
</a></li>
<li>
<a class="reference internal" href="#ID272"><span class="enstr">Initializer Requirements</span><!--end_enstr-->
<span class="jpstr">
イニシャライザ要件
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID273"><span class="enstr">Class Implementations of Protocol Initializer Requirements</span><!--end_enstr-->
<span class="jpstr">
イニシャライザ要件プロトコルのクラス実装
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID274"><span class="enstr">Failable Initializer Requirements</span><!--end_enstr-->
<span class="jpstr">
失敗できるイニシャライザ要件
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID275"><span class="enstr">Protocols as Types</span><!--end_enstr-->
<span class="jpstr">
型としてのプロトコル
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID276"><span class="enstr">Delegation</span><!--end_enstr-->
<span class="jpstr">
委任
</span><!--end_jpstr-->
</a></li>
<li>
<a class="reference internal" href="#ID277"><span class="enstr">Adding Protocol Conformance with an Extension</span><!--end_enstr-->
<span class="jpstr">
拡張を使ってプロトコル準拠を加える
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID574"><span class="enstr">Conditionally Conforming to a Protocol</span><!--end_enstr-->
<span class="jpstr">
あるプロトコルに条件付きで準拠する
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID278"><span class="enstr">Declaring Protocol Adoption with an Extension</span><!--end_enstr-->
<span class="jpstr">
拡張を使ってプロトコル採用を宣言する
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ID627"><span class="enstr">Adopting a Protocol Using a Synthesized Implementation</span><!--end_enstr-->
<span class="jpstr">
プロトコルを合成実装を使って採用する
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID279"><span class="enstr">Collections of Protocol Types</span><!--end_enstr-->
<span class="jpstr">
プロトコル型のコレクション
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID280"><span class="enstr">Protocol Inheritance</span><!--end_enstr-->
<span class="jpstr">
プロトコル継承
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID281"><span class="enstr">Class-Only Protocols</span><!--end_enstr-->
<span class="jpstr">
クラス専用プロトコル
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID282"><span class="enstr">Protocol Composition</span><!--end_enstr-->
<span class="jpstr">
プロトコル合成
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID283"><span class="enstr">Checking for Protocol Conformance</span><!--end_enstr-->
<span class="jpstr">
プロトコル準拠の確認
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID284"><span class="enstr">Optional Protocol Requirements</span><!--end_enstr-->
<span class="jpstr">
オプショナルのプロトコル要件
</span><!--end_jpstr-->
</a></li>
<li>
<a class="reference internal" href="#ID521"><span class="enstr">Protocol Extensions</span><!--end_enstr-->
<span class="jpstr">
プロトコル拡張
</span><!--end_jpstr-->
</a><ul>
<li><a class="reference internal" href="#ID529"><span class="enstr">Providing Default Implementations</span><!--end_enstr-->
<span class="jpstr">
省略時の実装を提供する
</span><!--end_jpstr-->
</a></li>
<li><a class="reference internal" href="#ID527"><span class="enstr">Adding Constraints to Protocol Extensions</span><!--end_enstr-->
<span class="jpstr">
プロトコル拡張に制約を加える
</span><!--end_jpstr-->
</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
                </menu>
            </menuitem>
          </div>
        </menu>

        
  <div class="section" id="protocols">
<h1><span class="enstr">Protocols<a class="headerlink" href="#protocols" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
プロトコル<a class="headerlink" href="#protocols" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h1>
<p><span class="enstr">A <em>protocol</em> defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. The protocol can then be <em>adopted</em> by a class, structure, or enumeration to provide an actual implementation of those requirements. Any type that satisfies the requirements of a protocol is said to <em>conform</em> to that protocol.</span><!--end_enstr-->
<span class="jpstr">
ある<em>プロトコル</em>（規約）は、メソッド、プロパティ、そして他の要件からなるひとつの青写真を定義します、それは、ある特定の作業またはある機能性断片にふさわしくするものです。そのプロトコルは、それから、クラス、構造体、または列挙によって<em>採用される</em>ことで、それらの要件の実際の実装を提供することができます。あるプロトコルの要件を満たす何らかの型は、そのプロトコルに<em>準拠する</em>と言われます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">In addition to specifying requirements that conforming types must implement, you can extend a protocol to implement some of these requirements or to implement additional functionality that conforming types can take advantage of.</span><!--end_enstr-->
<span class="jpstr">
準拠する型が実装しなければならない要件を指定することに加えて、あなたはあるプロトコルを拡張してそれらの要件のいくつかを実装したり、更なる機能性を実装したりできます、それらは、準拠する型それぞれで利用可能です。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID268">
<h2><span class="enstr">Protocol Syntax<a class="headerlink" href="#ID268" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
プロトコル構文<a class="headerlink" href="#ID268" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">You define protocols in a very similar way to classes, structures, and enumerations:</span><!--end_enstr-->
<span class="jpstr">
あなたは、クラス、構造体、および列挙と非常に類似した方法で、プロトコルを定義します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">protocol</span> <span class="nv">SomeProtocol</span> {
</li>
<li>    <span class="c"><span class="enstr">// protocol definition goes here</span><!--end_enstr--><span class="jpstr">（プロトコル定義が、ここにきます）</span><!--end_jpstr--></span>
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">Custom types state that they adopt a particular protocol by placing the protocol’s name after the type’s name, separated by a colon, as part of their definition. Multiple protocols can be listed, and are separated by commas:</span><!--end_enstr-->
<span class="jpstr">
あつらえの型は、それが特定のプロトコルを採用することを、型の名前の後に、コロンで区切って、それらの定義の一部としてプロトコルの名前を置くことによって示します。複数のプロトコルが、コンマで区切られて、リストされることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">struct</span> <span class="nv">SomeStructure</span>: <span class="nc">FirstProtocol</span>, <span class="nc">AnotherProtocol</span> {
</li>
<li>    <span class="c"><span class="enstr">// structure definition goes here</span><!--end_enstr--><span class="jpstr">（構造体定義が、ここにきます）</span><!--end_jpstr--></span>
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">If a class has a superclass, list the superclass name before any protocols it adopts, followed by a comma:</span><!--end_enstr-->
<span class="jpstr">
あるクラスがスーパークラスを持つならば、それが採用するあらゆるプロトコルの前に、コンマに続けてスーパークラス名を列記してください：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">class</span> <span class="nv">SomeClass</span>: <span class="nc">SomeSuperclass</span>, <span class="nc">FirstProtocol</span>, <span class="nc">AnotherProtocol</span> {
</li>
<li>    <span class="c"><span class="enstr">// class definition goes here</span><!--end_enstr--><span class="jpstr">（クラス定義が、ここにきます）</span><!--end_jpstr--></span>
</li>
<li>}
</li>
</ol></div></div></div>
</div>
<div class="section" id="ID269">
<h2><span class="enstr">Property Requirements<a class="headerlink" href="#ID269" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
プロパティ要件<a class="headerlink" href="#ID269" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">A protocol can require any conforming type to provide an instance property or type property with a particular name and type. The protocol doesn’t specify whether the property should be a stored property or a computed property—it only specifies the required property name and type. The protocol also specifies whether each property must be gettable or gettable <em>and</em> settable.</span><!--end_enstr-->
<span class="jpstr">
あるプロトコルは、あらゆる準拠型に、特定の名前と型をもつインスタンスプロパティまたは型プロパティを提供するように要求することができます。プロトコルは、そのプロパティが格納プロパティまたは計算プロパティでなければならないかどうかは指定しません ― それは、必要なプロパティ名と型を指定するだけです。プロトコルはまた、各プロパティが取得可能または取得可能<em>かつまた</em>設定可能でなければならないかどうか指定します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">If a protocol requires a property to be gettable and settable, that property requirement can’t be fulfilled by a constant stored property or a read-only computed property. If the protocol only requires a property to be gettable, the requirement can be satisfied by any kind of property, and it’s valid for the property to be also settable if this is useful for your own code.</span><!--end_enstr-->
<span class="jpstr">
あるプロトコルがプロパティに取得可能かつまた設定可能であることを要求するならば、そのプロパティ要件は、定数格納プロパティまたは読み出し専用の計算プロパティによって満たされることができません。プロトコルがプロパティに取得可能であるのを要求するだけならば、その要件はどんなプロパティにでもよって満たされることができます、そして、同時にまた設定可能でもあることは、もしそれがあなた自身のコードに役立つ場合には、そのプロパティにとって有効です。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Property requirements are always declared as variable properties, prefixed with the <code class="docutils literal notranslate"><span class="pre">var</span></code> keyword. Gettable and settable properties are indicated by writing <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">get</span> <span class="pre">set</span> <span class="pre">}</span></code> after their type declaration, and gettable properties are indicated by writing <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">get</span> <span class="pre">}</span></code>.</span><!--end_enstr-->
<span class="jpstr">
プロパティ要件は常に変数プロパティとして宣言されます、それで<code class="docutils literal notranslate"><span class="pre">var</span></code>キーワードを前に置かれます。取得可能かつまた設定可能なプロパティは、それらの型宣言の後に<code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">get</span> <span class="pre">set</span> <span class="pre">}</span></code>を書くことによって示されます、そして取得可能なプロパティは<code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">get</span> <span class="pre">}</span></code>を書くことによって示されます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">protocol</span> <span class="nv">SomeProtocol</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">mustBeSettable</span>: <span class="nc">Int</span> { <span class="k">get</span> <span class="k">set</span> }
</li>
<li>    <span class="k">var</span> <span class="nv">doesNotNeedToBeSettable</span>: <span class="nc">Int</span> { <span class="k">get</span> }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">Always prefix type property requirements with the <code class="docutils literal notranslate"><span class="pre">static</span></code> keyword when you define them in a protocol. This rule pertains even though type property requirements can be prefixed with the <code class="docutils literal notranslate"><span class="pre">class</span></code> or <code class="docutils literal notranslate"><span class="pre">static</span></code> keyword when implemented by a class:</span><!--end_enstr-->
<span class="jpstr">
あなたがあるプロトコルにおいてそれを定義するとき、常に、型プロパティ要件の前に<code class="docutils literal notranslate"><span class="pre">static</span></code>キーワードを置いてください。たとえ型プロパティ要件がクラスによって実装されるとき<code class="docutils literal notranslate"><span class="pre">class</span></code>または<code class="docutils literal notranslate"><span class="pre">static</span></code>キーワードを前に置かれるとしても、この規則は当てはまります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">protocol</span> <span class="nv">AnotherProtocol</span> {
</li>
<li>    <span class="k">static</span> <span class="k">var</span> <span class="nv">someTypeProperty</span>: <span class="nc">Int</span> { <span class="k">get</span> <span class="k">set</span> }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">Here’s an example of a protocol with a single instance property requirement:</span><!--end_enstr-->
<span class="jpstr">
ただ１つのインスタンスプロパティ要件を持つプロトコルの例が、ここにあります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">protocol</span> <span class="nv">FullyNamed</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">fullName</span>: <span class="nc">String</span> { <span class="k">get</span> }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">FullyNamed</span></code> protocol requires a conforming type to provide a fully qualified name. The protocol doesn’t specify anything else about the nature of the conforming type—it only specifies that the type must be able to provide a full name for itself. The protocol states that any <code class="docutils literal notranslate"><span class="pre">FullyNamed</span></code> type must have a gettable instance property called <code class="docutils literal notranslate"><span class="pre">fullName</span></code>, which is of type <code class="docutils literal notranslate"><span class="pre">String</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">FullyNamed</span></code>プロトコルは、完全修飾名を提供するある準拠型を要件とします。このプロトコルは、その準拠型の性質について何ら指定しません ― それはただその型がそれ自身のフルネームを提供できなければならないことだけを指定します。このプロトコルは、あらゆる<code class="docutils literal notranslate"><span class="pre">FullyNamed</span></code>型は<code class="docutils literal notranslate"><span class="pre">fullName</span></code>と呼ばれる、<code class="docutils literal notranslate"><span class="pre">String</span></code>型である、取得可能なインスタンスプロパティを持たなければならないことを述べます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Here’s an example of a simple structure that adopts and conforms to the <code class="docutils literal notranslate"><span class="pre">FullyNamed</span></code> protocol:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">FullyNamed</span></code>プロトコルを採用して準拠する単純な構造体の例は、ここにあります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">struct</span> <span class="nv">Person</span>: <span class="nc">FullyNamed</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">fullName</span>: <span class="nc">String</span>
</li>
<li>}
</li>
<li>
<span class="k">let</span> <span class="nv">john</span> = <span class="nv">Person</span>(<span class="nv">fullName</span>: <span class="s">"John Appleseed"</span>)
</li>
<li>
<span class="c"><span class="enstr">// john.fullName is "John Appleseed"</span><!--end_enstr--><span class="jpstr">（john.fullNameは、「John Appleseed」です）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">This example defines a structure called <code class="docutils literal notranslate"><span class="pre">Person</span></code>, which represents a specific named person. It states that it adopts the <code class="docutils literal notranslate"><span class="pre">FullyNamed</span></code> protocol as part of the first line of its definition.</span><!--end_enstr-->
<span class="jpstr">
この例は、<code class="docutils literal notranslate"><span class="pre">Person</span></code>と呼ばれる構造体を定義します、それは、特定の名前の人物を表します。それは、その定義の最初の行の部分でそれが<code class="docutils literal notranslate"><span class="pre">FullyNamed</span></code>プロトコルを採用すると述べます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Each instance of <code class="docutils literal notranslate"><span class="pre">Person</span></code> has a single stored property called <code class="docutils literal notranslate"><span class="pre">fullName</span></code>, which is of type <code class="docutils literal notranslate"><span class="pre">String</span></code>. This matches the single requirement of the <code class="docutils literal notranslate"><span class="pre">FullyNamed</span></code> protocol, and means that <code class="docutils literal notranslate"><span class="pre">Person</span></code> has correctly conformed to the protocol. (Swift reports an error at compile time if a protocol requirement isn’t fulfilled.)</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Person</span></code>の各インスタンスは、<code class="docutils literal notranslate"><span class="pre">fullName</span></code>と呼ばれる１つの格納プロパティを持ちます、それは、型<code class="docutils literal notranslate"><span class="pre">String</span></code>です。これは、<code class="docutils literal notranslate"><span class="pre">FullyNamed</span></code>プロトコルの唯一の要件に適合します、したがってその<code class="docutils literal notranslate"><span class="pre">Person</span></code>が正しくそのプロトコルに従ったことを意味します。（プロトコル要件が満たされないならば、スウィフトは実行時にエラーを報告します）。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Here’s a more complex class, which also adopts and conforms to the <code class="docutils literal notranslate"><span class="pre">FullyNamed</span></code> protocol:</span><!--end_enstr-->
<span class="jpstr">
また、<code class="docutils literal notranslate"><span class="pre">FullyNamed</span></code>プロトコルを採用して準拠するさらに複雑なクラスが、ここにあります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">class</span> <span class="nv">Starship</span>: <span class="nc">FullyNamed</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">prefix</span>: <span class="nc">String</span>?
</li>
<li>    <span class="k">var</span> <span class="nv">name</span>: <span class="nc">String</span>
</li>
<li>    <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>, <span class="nv">prefix</span>: <span class="nc">String</span>? = <span class="k">nil</span>) {
</li>
<li>        <span class="k">self</span>.<span class="nv">name</span> = <span class="nv">name</span>
</li>
<li>        <span class="k">self</span>.<span class="nv">prefix</span> = <span class="nv">prefix</span>
</li>
<li>    }
</li>
<li>    <span class="k">var</span> <span class="nv">fullName</span>: <span class="nc">String</span> {
</li>
<li>        <span class="k">return</span> (<span class="nv">prefix</span> != <span class="k">nil</span> ? <span class="nv">prefix</span>! + <span class="s">" "</span> : <span class="s">""</span>) + <span class="nv">name</span>
</li>
<li>    }
</li>
<li>}
</li>
<li>
<span class="k">var</span> <span class="nv">ncc1701</span> = <span class="nv">Starship</span>(<span class="nv">name</span>: <span class="s">"Enterprise"</span>, <span class="nv">prefix</span>: <span class="s">"USS"</span>)
</li>
<li>
<span class="c"><span class="enstr">// ncc1701.fullName is "USS Enterprise"</span><!--end_enstr--><span class="jpstr">（ncc1701.fullNameは、USSエンタープライズです）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">This class implements the <code class="docutils literal notranslate"><span class="pre">fullName</span></code> property requirement as a computed read-only property for a starship. Each <code class="docutils literal notranslate"><span class="pre">Starship</span></code> class instance stores a mandatory <code class="docutils literal notranslate"><span class="pre">name</span></code> and an optional <code class="docutils literal notranslate"><span class="pre">prefix</span></code>. The <code class="docutils literal notranslate"><span class="pre">fullName</span></code> property uses the <code class="docutils literal notranslate"><span class="pre">prefix</span></code> value if it exists, and prepends it to the beginning of <code class="docutils literal notranslate"><span class="pre">name</span></code> to create a full name for the starship.</span><!--end_enstr-->
<span class="jpstr">
このクラスは、<code class="docutils literal notranslate"><span class="pre">fullName</span></code>プロパティ要件をある宇宙船のための読み出し専用の計算プロパティとして実装します。各<code class="docutils literal notranslate"><span class="pre">Starship</span></code>クラスインスタンスは、義務的な<code class="docutils literal notranslate"><span class="pre">name</span></code>そしてオプショナルの<code class="docutils literal notranslate"><span class="pre">prefix</span></code>を格納します。<code class="docutils literal notranslate"><span class="pre">fullName</span></code>プロパティは、<code class="docutils literal notranslate"><span class="pre">prefix</span></code>値を、それが存在するならば使います、そしてそれを<code class="docutils literal notranslate"><span class="pre">name</span></code>の始めに付けて、その宇宙船の完全な名前をつくります。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID270">
<h2><span class="enstr">Method Requirements<a class="headerlink" href="#ID270" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
メソッド要件<a class="headerlink" href="#ID270" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">Protocols can require specific instance methods and type methods to be implemented by conforming types. These methods are written as part of the protocol’s definition in exactly the same way as for normal instance and type methods, but without curly braces or a method body. Variadic parameters are allowed, subject to the same rules as for normal methods. Default values, however, can’t be specified for method parameters within a protocol’s definition.</span><!--end_enstr-->
<span class="jpstr">
プロトコルは、準拠型によって特定のインスタンスメソッドと型メソッドが実装されるように要求することができます。これらのメソッドは、プロトコルの定義の一部として普通のインスタンスおよび型メソッドと正確に同じ方法で書かれます、しかし波括弧またはメソッド本文はありません。可変長パラメータは、許され、普通のメソッドと同じ規則の支配下にあります。省略時の値は、しかしながら、プロトコル定義の内部のメソッドパラメーターに対して指定されることはできません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">As with type property requirements, you always prefix type method requirements with the <code class="docutils literal notranslate"><span class="pre">static</span></code> keyword when they’re defined in a protocol. This is true even though type method requirements are prefixed with the <code class="docutils literal notranslate"><span class="pre">class</span></code> or <code class="docutils literal notranslate"><span class="pre">static</span></code> keyword when implemented by a class:</span><!--end_enstr-->
<span class="jpstr">
型プロパティ要件と同様に、あなたは常に型メソッド要件の前に、それらがプロトコルにおいて定義されるとき、<code class="docutils literal notranslate"><span class="pre">static</span></code>キーワードを置きます。たとえ型メソッド要件がクラスによって実装されるとき<code class="docutils literal notranslate"><span class="pre">class</span></code>または<code class="docutils literal notranslate"><span class="pre">static</span></code>キーワードを前に置かれるとしても、これは当てはまります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">protocol</span> <span class="nv">SomeProtocol</span> {
</li>
<li>    <span class="k">static</span> <span class="k">func</span> <span class="nv">someTypeMethod</span>()
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">The following example defines a protocol with a single instance method requirement:</span><!--end_enstr-->
<span class="jpstr">
以下の例は、１つのインスタンスメソッド要件で、プロトコルを定義します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">protocol</span> <span class="nv">RandomNumberGenerator</span> {
</li>
<li>    <span class="k">func</span> <span class="nv">random</span>() -&gt; <span class="nc">Double</span>
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">This protocol, <code class="docutils literal notranslate"><span class="pre">RandomNumberGenerator</span></code>, requires any conforming type to have an instance method called <code class="docutils literal notranslate"><span class="pre">random</span></code>, which returns a <code class="docutils literal notranslate"><span class="pre">Double</span></code> value whenever it’s called. Although it’s not specified as part of the protocol, it’s assumed that this value will be a number from <code class="docutils literal notranslate"><span class="pre">0.0</span></code> up to (but not including) <code class="docutils literal notranslate"><span class="pre">1.0</span></code>.</span><!--end_enstr-->
<span class="jpstr">
このプロトコル、<code class="docutils literal notranslate"><span class="pre">RandomNumberGenerator</span></code>は、あらゆる準拠型に<code class="docutils literal notranslate"><span class="pre">random</span></code>と呼ばれるインスタンスメソッドを持つことを要求します、それは、それが呼ばれた時はいつでもある<code class="docutils literal notranslate"><span class="pre">Double</span></code>値を返すものです。それはプロトコルの一部として指定されないけれども、この値は<code class="docutils literal notranslate"><span class="pre">0.0</span></code>から<code class="docutils literal notranslate"><span class="pre">1.0</span></code>まで（しかし含めてではない）のある数であるのを仮定されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">RandomNumberGenerator</span></code> protocol doesn’t make any assumptions about how each random number will be generated—it simply requires the generator to provide a standard way to generate a new random number.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">RandomNumberGenerator</span></code>プロトコルは、乱数それぞれが生成される方法について、全く仮定しません ― それは単に生成器に新しい乱数を生み出す標準の方法を提供することを要求します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Here’s an implementation of a class that adopts and conforms to the <code class="docutils literal notranslate"><span class="pre">RandomNumberGenerator</span></code> protocol. This class implements a pseudorandom number generator algorithm known as a <em>linear congruential generator</em>:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">RandomNumberGenerator</span></code>プロトコルを採用して準拠するクラスの実施が、ここにあります。このクラスは、<em>線形合同法生成器</em>として知られている擬似乱数生成器アルゴリズムを実装します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">class</span> <span class="nv">LinearCongruentialGenerator</span>: <span class="nc">RandomNumberGenerator</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">lastRandom</span> = <span class="m">42.0</span>
</li>
<li>    <span class="k">let</span> <span class="nv">m</span> = <span class="m">139968.0</span>
</li>
<li>    <span class="k">let</span> <span class="nv">a</span> = <span class="m">3877.0</span>
</li>
<li>    <span class="k">let</span> <span class="nv">c</span> = <span class="m">29573.0</span>
</li>
<li>    <span class="k">func</span> <span class="nv">random</span>() -&gt; <span class="nc">Double</span> {
</li>
<li>        <span class="nv">lastRandom</span> = ((<span class="nv">lastRandom</span> * <span class="nv">a</span> + <span class="nv">c</span>)
</li>
<li>            .<span class="nv">truncatingRemainder</span>(<span class="nv">dividingBy</span>:<span class="nv">m</span>))
</li>
<li>        <span class="k">return</span> <span class="nv">lastRandom</span> / <span class="nv">m</span>
</li>
<li>    }
</li>
<li>}
</li>
<li>
<span class="k">let</span> <span class="nv">generator</span> = <span class="nv">LinearCongruentialGenerator</span>()
</li>
<li>
<span class="nv">print</span>(<span class="s">"Here's a random number: </span>\<span class="p">(</span><span class="nv">generator</span>.<span class="nv">random</span>()<span class="p">)</span><span class="s">"</span>)
</li>
<li>
<span class="c"><span class="enstr">// Prints "Here's a random number: 0.3746499199817101"</span><!--end_enstr--><span class="jpstr">（「ここに任意の数: 0.3746499199817101があります」を出力します）</span><!--end_jpstr--></span>
</li>
<li>
<span class="nv">print</span>(<span class="s">"And another one: </span>\<span class="p">(</span><span class="nv">generator</span>.<span class="nv">random</span>()<span class="p">)</span><span class="s">"</span>)
</li>
<li>
<span class="c"><span class="enstr">// Prints "And another one: 0.729023776863283"</span><!--end_enstr--><span class="jpstr">（「さらにもう１つ：0.729023776863283」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
</div>
<div class="section" id="ID271">
<h2><span class="enstr">Mutating Method Requirements<a class="headerlink" href="#ID271" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
変更メソッド要件<a class="headerlink" href="#ID271" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">It’s sometimes necessary for a method to modify (or <em>mutate</em>) the instance it belongs to. For instance methods on value types (that is, structures and enumerations) you place the <code class="docutils literal notranslate"><span class="pre">mutating</span></code> keyword before a method’s <code class="docutils literal notranslate"><span class="pre">func</span></code> keyword to indicate that the method is allowed to modify the instance it belongs to and any properties of that instance. This process is described in <a class="reference internal" href="Methods.html#ID239"><span class="std std-ref">Modifying Value Types from Within Instance Methods</span></a>.</span><!--end_enstr-->
<span class="jpstr">
メソッドがそれが属しているインスタンスを修正する（または<em>変化させる</em>）ことは、時々必要です。値型（すなわち、構造体と列挙）のインスタンスメソッドのために、あなたは<code class="docutils literal notranslate"><span class="pre">mutating</span></code>キーワードをメソッドの<code class="docutils literal notranslate"><span class="pre">func</span></code>キーワードの前に置いて、メソッドがそれが属しているインスタンスおよびそのインスタンスのあらゆるプロパティを修正するのを許可されることを示します。この過程は、<a class="reference internal" href="Methods.html#ID239"><span class="std std-ref">値型をインスタンスメソッド内から修正する</span></a>で記述されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">If you define a protocol instance method requirement that’s intended to mutate instances of any type that adopts the protocol, mark the method with the <code class="docutils literal notranslate"><span class="pre">mutating</span></code> keyword as part of the protocol’s definition. This enables structures and enumerations to adopt the protocol and satisfy that method requirement.</span><!--end_enstr-->
<span class="jpstr">
あなたがそのプロトコルを採用するあらゆる型のインスタンスを変化させることを意図したインスタンスメソッド要件プロトコルを定義するならば、プロトコルの定義の一部としてそのメソッドに<code class="docutils literal notranslate"><span class="pre">mutating</span></code>キーワードで印をつけてください。これは、構造体と列挙に、そのプロトコルを採用してメソッド要件を満たすのを可能にします。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">If you mark a protocol instance method requirement as <code class="docutils literal notranslate"><span class="pre">mutating</span></code>, you don’t need to write the <code class="docutils literal notranslate"><span class="pre">mutating</span></code> keyword when writing an implementation of that method for a class. The <code class="docutils literal notranslate"><span class="pre">mutating</span></code> keyword is only used by structures and enumerations.</span><!--end_enstr-->
<span class="jpstr">
あなたがインスタンスメソッド要件プロトコルに<code class="docutils literal notranslate"><span class="pre">mutating</span></code>として印するならば、あるクラスのためにそのメソッドの実装を書くとき、あなたは<code class="docutils literal notranslate"><span class="pre">mutating</span></code>キーワードを書く必要がありません。<code class="docutils literal notranslate"><span class="pre">mutating</span></code>キーワードは、構造体と列挙によって使われるだけです。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">The example below defines a protocol called <code class="docutils literal notranslate"><span class="pre">Togglable</span></code>, which defines a single instance method requirement called <code class="docutils literal notranslate"><span class="pre">toggle</span></code>. As its name suggests, the <code class="docutils literal notranslate"><span class="pre">toggle()</span></code> method is intended to toggle or invert the state of any conforming type, typically by modifying a property of that type.</span><!--end_enstr-->
<span class="jpstr">
下の例は、<code class="docutils literal notranslate"><span class="pre">Togglable</span></code>と呼ばれるプロトコルを定義します、それは、<code class="docutils literal notranslate"><span class="pre">toggle</span></code>と呼ばれる１つのインスタンスメソッド要件を定義します。その名前が暗示するように、<code class="docutils literal notranslate"><span class="pre">toggle()</span></code>メソッドはあらゆる準拠型の状態を切り換えるか逆にすることを意図します、概してその型のプロパティの修正によって。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">toggle()</span></code> method is marked with the <code class="docutils literal notranslate"><span class="pre">mutating</span></code> keyword as part of the <code class="docutils literal notranslate"><span class="pre">Togglable</span></code> protocol definition, to indicate that the method is expected to mutate the state of a conforming instance when it’s called:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">toggle()</span></code>メソッドは、<code class="docutils literal notranslate"><span class="pre">Togglable</span></code>プロトコル定義の一部として<code class="docutils literal notranslate"><span class="pre">mutating</span></code>キーワードで印されます、それによってそのメソッドが、それが呼ばれるとき準拠インスタンスの状態を変化させることを予期されるようにします：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">protocol</span> <span class="nv">Togglable</span> {
</li>
<li>    <span class="k">mutating</span> <span class="k">func</span> <span class="nv">toggle</span>()
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">If you implement the <code class="docutils literal notranslate"><span class="pre">Togglable</span></code> protocol for a structure or enumeration, that structure or enumeration can conform to the protocol by providing an implementation of the <code class="docutils literal notranslate"><span class="pre">toggle()</span></code> method that’s also marked as <code class="docutils literal notranslate"><span class="pre">mutating</span></code>.</span><!--end_enstr-->
<span class="jpstr">
あなたが<code class="docutils literal notranslate"><span class="pre">Togglable</span></code>プロトコルをある構造体または列挙のために実装するならば、その構造体または列挙は、同様に<code class="docutils literal notranslate"><span class="pre">mutating</span></code>として印される<code class="docutils literal notranslate"><span class="pre">toggle()</span></code>メソッドの実施を提供することによって、このプロトコルに準拠できます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The example below defines an enumeration called <code class="docutils literal notranslate"><span class="pre">OnOffSwitch</span></code>. This enumeration toggles between two states, indicated by the enumeration cases <code class="docutils literal notranslate"><span class="pre">on</span></code> and <code class="docutils literal notranslate"><span class="pre">off</span></code>. The enumeration’s <code class="docutils literal notranslate"><span class="pre">toggle</span></code> implementation is marked as <code class="docutils literal notranslate"><span class="pre">mutating</span></code>, to match the <code class="docutils literal notranslate"><span class="pre">Togglable</span></code> protocol’s requirements:</span><!--end_enstr-->
<span class="jpstr">
下の例は、<code class="docutils literal notranslate"><span class="pre">OnOffSwitch</span></code>と呼ばれる列挙を定義します。この列挙は、列挙のケース節<code class="docutils literal notranslate"><span class="pre">on</span></code>と<code class="docutils literal notranslate"><span class="pre">off</span></code>で示される、２つの状態の間で切替えをします。列挙の<code class="docutils literal notranslate"><span class="pre">toggle</span></code>実装は、<code class="docutils literal notranslate"><span class="pre">Togglable</span></code>プロトコルの要件に適合するように、<code class="docutils literal notranslate"><span class="pre">mutating</span></code>として印されます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">enum</span> <span class="nv">OnOffSwitch</span>: <span class="nc">Togglable</span> {
</li>
<li>    <span class="k">case</span> <span class="nv">off</span>, <span class="nv">on</span>
</li>
<li>    <span class="k">mutating</span> <span class="k">func</span> <span class="nv">toggle</span>() {
</li>
<li>        <span class="k">switch</span> <span class="k">self</span> {
</li>
<li>        <span class="k">case</span> .<span class="nv">off</span>:
</li>
<li>            <span class="k">self</span> = .<span class="nv">on</span>
</li>
<li>        <span class="k">case</span> .<span class="nv">on</span>:
</li>
<li>            <span class="k">self</span> = .<span class="nv">off</span>
</li>
<li>        }
</li>
<li>    }
</li>
<li>}
</li>
<li>
<span class="k">var</span> <span class="nv">lightSwitch</span> = <span class="nv">OnOffSwitch</span>.<span class="nv">off</span>
</li>
<li>
<span class="nv">lightSwitch</span>.<span class="nv">toggle</span>()
</li>
<li>
<span class="c"><span class="enstr">// lightSwitch is now equal to .on</span><!--end_enstr--><span class="jpstr">（lightSwitchは、現在.onと等しいです）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
</div>
<div class="section" id="ID272">
<h2><span class="enstr">Initializer Requirements<a class="headerlink" href="#ID272" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
イニシャライザ要件<a class="headerlink" href="#ID272" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">Protocols can require specific initializers to be implemented by conforming types. You write these initializers as part of the protocol’s definition in exactly the same way as for normal initializers, but without curly braces or an initializer body:</span><!--end_enstr-->
<span class="jpstr">
プロトコルは、準拠型によって特定のイニシャライザが実装されるように要求することができます。あなたは、これらのイニシャライザをプロトコル定義の一部として普通のイニシャライザと正確に同じ方法で書くことができます、しかし波括弧またはイニシャライザ本文はありません：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">protocol</span> <span class="nv">SomeProtocol</span> {
</li>
<li>    <span class="k">init</span>(<span class="nv">someParameter</span>: <span class="nc">Int</span>)
</li>
<li>}
</li>
</ol></div></div></div>
<div class="section" id="ID273">
<h3><span class="enstr">Class Implementations of Protocol Initializer Requirements<a class="headerlink" href="#ID273" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
イニシャライザ要件プロトコルのクラス実装<a class="headerlink" href="#ID273" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">You can implement a protocol initializer requirement on a conforming class as either a designated initializer or a convenience initializer. In both cases, you must mark the initializer implementation with the <code class="docutils literal notranslate"><span class="pre">required</span></code> modifier:</span><!--end_enstr-->
<span class="jpstr">
あなたは、イニシャライザ要件プロトコルを準拠クラス上で指定イニシャライザまたは便宜イニシャライザとして実装することができます。両方の場合で、あなたはそのイニシャライザ実装を<code class="docutils literal notranslate"><span class="pre">required</span></code>修飾子で印しなければなりません：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">class</span> <span class="nv">SomeClass</span>: <span class="nc">SomeProtocol</span> {
</li>
<li>    <span class="k">required</span> <span class="k">init</span>(<span class="nv">someParameter</span>: <span class="nc">Int</span>) {
</li>
<li>        <span class="c"><span class="enstr">// initializer implementation goes here</span><!--end_enstr--><span class="jpstr">（イニシャライザ実装がここに来ます）</span><!--end_jpstr--></span>
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">The use of the <code class="docutils literal notranslate"><span class="pre">required</span></code> modifier ensures that you provide an explicit or inherited implementation of the initializer requirement on all subclasses of the conforming class, such that they also conform to the protocol.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">required</span></code>修飾子の使用は、あなたがある明確なもしくは継承されたイニシャライザ要件の実装を準拠クラスの全てのサブクラス上で、それらもまたそのプロトコルに準拠するように、提供することを確かなものにします。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">For more information on required initializers, see <a class="reference internal" href="Initialization.html#ID231"><span class="std std-ref">Required Initializers</span></a>.</span><!--end_enstr-->
<span class="jpstr">
必須イニシャライザに関する更なる情報として、<a class="reference internal" href="Initialization.html#ID231"><span class="std std-ref">必須イニシャライザ</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">You don’t need to mark protocol initializer implementations with the <code class="docutils literal notranslate"><span class="pre">required</span></code> modifier on classes that are marked with the <code class="docutils literal notranslate"><span class="pre">final</span></code> modifier, because final classes can’t subclassed. For more about the <code class="docutils literal notranslate"><span class="pre">final</span></code> modifier, see <a class="reference internal" href="Inheritance.html#ID202"><span class="std std-ref">Preventing Overrides</span></a>.</span><!--end_enstr-->
<span class="jpstr">
あなたは<code class="docutils literal notranslate"><span class="pre">final</span></code>修飾子で印されるクラス上でプロトコルイニシャライザ実装を<code class="docutils literal notranslate"><span class="pre">required</span></code>修飾子で印する必要はありません、なぜなら、finalクラスはサブクラスを作られることができないからです。<code class="docutils literal notranslate"><span class="pre">final</span></code>修飾子に関する詳細は、<a class="reference internal" href="Inheritance.html#ID202"><span class="std std-ref">オーバーライドを防ぐ</span></a>を見てください。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">If a subclass overrides a designated initializer from a superclass, and also implements a matching initializer requirement from a protocol, mark the initializer implementation with both the <code class="docutils literal notranslate"><span class="pre">required</span></code> and <code class="docutils literal notranslate"><span class="pre">override</span></code> modifiers:</span><!--end_enstr-->
<span class="jpstr">
あるサブクラスが、スーパークラスからの指定イニシャライザをオーバーライドして、またプロトコルからのイニシャライザ要件にも合致するものを実装するならば、そのイニシャライザ実装を<code class="docutils literal notranslate"><span class="pre">required</span></code>と<code class="docutils literal notranslate"><span class="pre">override</span></code>の両方の修飾子を使って印してください：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">protocol</span> <span class="nv">SomeProtocol</span> {
</li>
<li>    <span class="k">init</span>()
</li>
<li>}
</li>
<li>
</li>
<li>
<span class="k">class</span> <span class="nv">SomeSuperClass</span> {
</li>
<li>    <span class="k">init</span>() {
</li>
<li>        <span class="c"><span class="enstr">// initializer implementation goes here</span><!--end_enstr--><span class="jpstr">（イニシャライザ実装がここに来ます）</span><!--end_jpstr--></span>
</li>
<li>    }
</li>
<li>}
</li>
<li>
</li>
<li>
<span class="k">class</span> <span class="nv">SomeSubClass</span>: <span class="nc">SomeSuperClass</span>, <span class="nc">SomeProtocol</span> {
</li>
<li>    <span class="c"><span class="enstr">// "required" from SomeProtocol conformance; "override" from SomeSuperClass</span><!--end_enstr--><span class="jpstr">（SomeProtocol準拠からの「required」；SomeSuperClasからの「override」）</span><!--end_jpstr--></span>
</li>
<li>    <span class="k">required</span> <span class="k">override</span> <span class="k">init</span>() {
</li>
<li>        <span class="c"><span class="enstr">// initializer implementation goes here</span><!--end_enstr--><span class="jpstr">（イニシャライザ実装がここに来ます）</span><!--end_jpstr--></span>
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
</div>
<div class="section" id="ID274">
<h3><span class="enstr">Failable Initializer Requirements<a class="headerlink" href="#ID274" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
失敗できるイニシャライザ要件<a class="headerlink" href="#ID274" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">Protocols can define failable initializer requirements for conforming types, as defined in <a class="reference internal" href="Initialization.html#ID224"><span class="std std-ref">Failable Initializers</span></a>.</span><!--end_enstr-->
<span class="jpstr">
プロトコルは、<a class="reference internal" href="Initialization.html#ID224"><span class="std std-ref">失敗できるイニシャライザ</span></a>で記述されるように、準拠している型に対して失敗できるイニシャライザ要件を定義することができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">A failable initializer requirement can be satisfied by a failable or nonfailable initializer on a conforming type. A nonfailable initializer requirement can be satisfied by a nonfailable initializer or an implicitly unwrapped failable initializer.</span><!--end_enstr-->
<span class="jpstr">
失敗できるイニシャライザ要件は、準拠している型上の失敗できるもしくは失敗できないイニシャライザによって満たされることができます。失敗できないイニシャライザ要件は、失敗できないイニシャライザまたは暗黙的にアンラップされる失敗できるイニシャライザによって満たされることができます。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID275">
<h2><span class="enstr">Protocols as Types<a class="headerlink" href="#ID275" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
型としてのプロトコル<a class="headerlink" href="#ID275" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">Protocols don’t actually implement any functionality themselves. Nonetheless, you can use protocols as a fully fledged types in your code. Using a protocol as a type is sometimes called an <em>existential type</em>, which comes from the phrase “there exists a type <em>T</em> such that <em>T</em> conforms to the protocol”.</span><!--end_enstr-->
<span class="jpstr">
プロトコルは、実際に少しの機能性も実装しません。それにもかかわらず、あなたはプロトコルを完全に一人前の型としてあなたのコードにおいて使用できます。プロトコルを型として使うことは、ときどき<em>存在型</em>と呼ばれます、それは語句 “そこに型<em>T</em>が存在する、そのような<em>T</em>はそのプロトコルに準拠する” から来ています。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can use a protocol in many places where other types are allowed, including:</span><!--end_enstr-->
<span class="jpstr">
あなたは、プロトコルを、他の型が許可される多くの場所で使用できます、以下を含みます：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li><span class="enstr">As a parameter type or return type in a function, method, or initializer</span><!--end_enstr-->
<span class="jpstr">
関数、メソッド、またはイニシャライザにおいてパラメータ型または戻り型として
</span><!--end_jpstr-->
</li>
<li><span class="enstr">As the type of a constant, variable, or property</span><!--end_enstr-->
<span class="jpstr">
定数、変数、またはプロパティの型として
</span><!--end_jpstr-->
</li>
<li><span class="enstr">As the type of items in an array, dictionary, or other container</span><!--end_enstr-->
<span class="jpstr">
配列、辞書、または他のコンテナ中の項目の型として
</span><!--end_jpstr-->
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Because protocols are types, begin their names with a capital letter (such as <code class="docutils literal notranslate"><span class="pre">FullyNamed</span></code> and <code class="docutils literal notranslate"><span class="pre">RandomNumberGenerator</span></code>) to match the names of other types in Swift (such as <code class="docutils literal notranslate"><span class="pre">Int</span></code>, <code class="docutils literal notranslate"><span class="pre">String</span></code>, and <code class="docutils literal notranslate"><span class="pre">Double</span></code>).</span><!--end_enstr-->
<span class="jpstr">
プロトコルが型であるので、それらの名前を大文字で開始してください（例えば<code class="docutils literal notranslate"><span class="pre">FullyNamed</span></code>と<code class="docutils literal notranslate"><span class="pre">RandomNumberGenerator</span></code>のように）、それによってスウィフトでの他の型の名前（例えば<code class="docutils literal notranslate"><span class="pre">Int</span></code>、<code class="docutils literal notranslate"><span class="pre">String</span></code>、および<code class="docutils literal notranslate"><span class="pre">Double</span></code>）と釣り合いがとれます。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">Here’s an example of a protocol used as a type:</span><!--end_enstr-->
<span class="jpstr">
型として使われるプロトコルの例は、ここにあります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">class</span> <span class="nv">Dice</span> {
</li>
<li>    <span class="k">let</span> <span class="nv">sides</span>: <span class="nc">Int</span>
</li>
<li>    <span class="k">let</span> <span class="nv">generator</span>: <span class="nc">RandomNumberGenerator</span>
</li>
<li>    <span class="k">init</span>(<span class="nv">sides</span>: <span class="nc">Int</span>, <span class="nv">generator</span>: <span class="nc">RandomNumberGenerator</span>) {
</li>
<li>        <span class="k">self</span>.<span class="nv">sides</span> = <span class="nv">sides</span>
</li>
<li>        <span class="k">self</span>.<span class="nv">generator</span> = <span class="nv">generator</span>
</li>
<li>    }
</li>
<li>    <span class="k">func</span> <span class="nv">roll</span>() -&gt; <span class="nc">Int</span> {
</li>
<li>        <span class="k">return</span> <span class="nv">Int</span>(<span class="nv">generator</span>.<span class="nv">random</span>() * <span class="nv">Double</span>(<span class="nv">sides</span>)) + <span class="m">1</span>
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">This example defines a new class called <code class="docutils literal notranslate"><span class="pre">Dice</span></code>, which represents an <em>n</em>-sided dice for use in a board game. <code class="docutils literal notranslate"><span class="pre">Dice</span></code> instances have an integer property called <code class="docutils literal notranslate"><span class="pre">sides</span></code>, which represents how many sides they have, and a property called <code class="docutils literal notranslate"><span class="pre">generator</span></code>, which provides a random number generator from which to create dice roll values.</span><!--end_enstr-->
<span class="jpstr">
この例は<code class="docutils literal notranslate"><span class="pre">Dice</span></code>と呼ばれる新しいクラスを定義します、それは、ボードゲームで使うのために<em>n</em>面のさいころを表します。<code class="docutils literal notranslate"><span class="pre">Dice</span></code>インスタンスは、それがどれくらいの面を持つのかを表す<code class="docutils literal notranslate"><span class="pre">sides</span></code>と呼ばれる整数プロパティ、そしてそこからさいころを振った値を作成する乱数生成器を提供する<code class="docutils literal notranslate"><span class="pre">generator</span></code>と呼ばれるプロパティを持ちます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">generator</span></code> property is of type <code class="docutils literal notranslate"><span class="pre">RandomNumberGenerator</span></code>. Therefore, you can set it to an instance of <em>any</em> type that adopts the <code class="docutils literal notranslate"><span class="pre">RandomNumberGenerator</span></code> protocol. Nothing else is required of the instance you assign to this property, except that the instance must adopt the <code class="docutils literal notranslate"><span class="pre">RandomNumberGenerator</span></code> protocol. Because its type is <code class="docutils literal notranslate"><span class="pre">RandomNumberGenerator</span></code>, code inside the <code class="docutils literal notranslate"><span class="pre">Dice</span></code> class can only interact with <code class="docutils literal notranslate"><span class="pre">generator</span></code> in ways that apply to all generators that conform to this protocol. That means it can’t use any methods or properties that are defined by the underlying type of the generator. However, you can downcast from a protocol type to an underlying type in the same way you can downcast from a superclass to a subclass, as discussed in <a class="reference internal" href="TypeCasting.html#ID341"><span class="std std-ref">Downcasting</span></a>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">generator</span></code>プロパティは、型<code class="docutils literal notranslate"><span class="pre">RandomNumberGenerator</span></code>のものです。したがって、あなたはそれを<code class="docutils literal notranslate"><span class="pre">RandomNumberGenerator</span></code>プロトコルを採用する<em>あらゆる</em>型のインスタンスに設定できます。そのインスタンスが<code class="docutils literal notranslate"><span class="pre">RandomNumberGenerator</span></code>プロトコルを採用しなければならないことをのぞいては、あなたがこのプロパティに代入するところのインスタンスに必要とされるものは他に何もありません。それの型が<code class="docutils literal notranslate"><span class="pre">RandomNumberGenerator</span></code>であることから、<code class="docutils literal notranslate"><span class="pre">Dice</span></code>クラスの内部のコードは、全ての生成子にこのプロトコルに準拠することを適用するという方法で<code class="docutils literal notranslate"><span class="pre">generator</span></code>と相互作用できるだけです。それは意味するのは、それが生成子の基礎をなす型によって定義されるどんなメソッドまたはプロパティも使用できないということです。しかしながら、あなたはあるプロトコル型からある基礎をなす型へとダウンキャストすることが、あなたがスーパークラスからサブクラスへとダウンキャスト出来るのと同じ方法で可能です、<a class="reference internal" href="TypeCasting.html#ID341"><span class="std std-ref">ダウンキャスト</span></a>で記述されるように。
</span><!--end_jpstr-->
</p>
<p><span class="enstr"><code class="docutils literal notranslate"><span class="pre">Dice</span></code> also has an initializer, to set up its initial state. This initializer has a parameter called <code class="docutils literal notranslate"><span class="pre">generator</span></code>, which is also of type <code class="docutils literal notranslate"><span class="pre">RandomNumberGenerator</span></code>. You can pass a value of any conforming type in to this parameter when initializing a new <code class="docutils literal notranslate"><span class="pre">Dice</span></code> instance.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Dice</span></code>はまた、その最初の状態を設定するために、イニシャライザを持ちます。このイニシャライザは、<code class="docutils literal notranslate"><span class="pre">generator</span></code>と呼ばれるパラメータを持ちます、それもまた、型<code class="docutils literal notranslate"><span class="pre">RandomNumberGenerator</span></code>です。新しい<code class="docutils literal notranslate"><span class="pre">Dice</span></code>インスタンスを初期化するとき、あなたはどんな準拠型の値でもこのパラメータに渡すことができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr"><code class="docutils literal notranslate"><span class="pre">Dice</span></code> provides one instance method, <code class="docutils literal notranslate"><span class="pre">roll</span></code>, which returns an integer value between 1 and the number of sides on the dice. This method calls the generator’s <code class="docutils literal notranslate"><span class="pre">random()</span></code> method to create a new random number between <code class="docutils literal notranslate"><span class="pre">0.0</span></code> and <code class="docutils literal notranslate"><span class="pre">1.0</span></code>, and uses this random number to create a dice roll value within the correct range. Because <code class="docutils literal notranslate"><span class="pre">generator</span></code> is known to adopt <code class="docutils literal notranslate"><span class="pre">RandomNumberGenerator</span></code>, it’s guaranteed to have a <code class="docutils literal notranslate"><span class="pre">random()</span></code> method to call.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Dice</span></code>は１つのインスタンスメソッド、<code class="docutils literal notranslate"><span class="pre">roll</span></code>を提供します、それは、１とさいころ上の面の数との間の整数値を返します。このメソッドは、<code class="docutils literal notranslate"><span class="pre">0.0</span></code>と<code class="docutils literal notranslate"><span class="pre">1.0</span></code>の間で新しい乱数をつくるgeneratorの<code class="docutils literal notranslate"><span class="pre">random()</span></code>メソッドを呼んで、この乱数を正しい範囲内でさいころを振った値をつくるために使います。<code class="docutils literal notranslate"><span class="pre">generator</span></code>が<code class="docutils literal notranslate"><span class="pre">RandomNumberGenerator</span></code>を採用すると知られているので、それは<code class="docutils literal notranslate"><span class="pre">random()</span></code>メソッドを呼ぶことを保証されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Here’s how the <code class="docutils literal notranslate"><span class="pre">Dice</span></code> class can be used to create a six-sided dice with a <code class="docutils literal notranslate"><span class="pre">LinearCongruentialGenerator</span></code> instance as its random number generator:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Dice</span></code>クラスが、６面のさいころをつくるためにその乱数生成器として<code class="docutils literal notranslate"><span class="pre">LinearCongruentialGenerator</span></code>インスタンスをつかってどのように使われることができるかが、ここにあります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">var</span> <span class="nv">d6</span> = <span class="nv">Dice</span>(<span class="nv">sides</span>: <span class="m">6</span>, <span class="nv">generator</span>: <span class="nv">LinearCongruentialGenerator</span>())
</li>
<li>
<span class="k">for</span> <span class="k">_</span> <span class="k">in</span> <span class="m">1</span>...<span class="m">5</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"Random dice roll is </span>\<span class="p">(</span><span class="nv">d6</span>.<span class="nv">roll</span>()<span class="p">)</span><span class="s">"</span>)
</li>
<li>}
</li>
<li>
<span class="c"><span class="enstr">// Random dice roll is 3</span><!--end_enstr--><span class="jpstr">（無作為にさいころを転がして、３です）</span><!--end_jpstr--></span>
</li>
<li>
<span class="c"><span class="enstr">// Random dice roll is 5</span><!--end_enstr--><span class="jpstr">（無作為にさいころを転がして、５です）</span><!--end_jpstr--></span>
</li>
<li>
<span class="c"><span class="enstr">// Random dice roll is 4</span><!--end_enstr--><span class="jpstr">（無作為にさいころを転がして、４です）</span><!--end_jpstr--></span>
</li>
<li>
<span class="c"><span class="enstr">// Random dice roll is 5</span><!--end_enstr--><span class="jpstr">（無作為にさいころを転がして、５です）</span><!--end_jpstr--></span>
</li>
<li>
<span class="c"><span class="enstr">// Random dice roll is 4</span><!--end_enstr--><span class="jpstr">（無作為にさいころを転がして、４です）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
</div>
<div class="section" id="ID276">
<h2><span class="enstr">Delegation<a class="headerlink" href="#ID276" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
委任<a class="headerlink" href="#ID276" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr"><em>Delegation</em> is a design pattern that enables a class or structure to hand off (or <em>delegate</em>) some of its responsibilities to an instance of another type. This design pattern is implemented by defining a protocol that encapsulates the delegated responsibilities, such that a conforming type (known as a delegate) is guaranteed to provide the functionality that has been delegated. Delegation can be used to respond to a particular action, or to retrieve data from an external source without needing to know the underlying type of that source.</span><!--end_enstr-->
<span class="jpstr">
<em>委任</em>は、クラスまたは構造体にそれのもつ責務の一部を別の型のインスタンスへと手渡す（または<em>委任する</em>）ことを可能にするデザイン・パターンです。このデザイン・パターンは、委任された責務をカプセル化するプロトコルを定義することによって実装されます、例えば、委任プロトコルに拠準する型が（代表、委任先として知られるものが）その委任されている機能性を提供する責任を負わされるといったこと。委任は、特定の動作に応答したり、外部ソースからそのソースの根底の型を知る必要なしにデータを取り出したりするのに使われることができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The example below defines two protocols for use with dice-based board games:</span><!--end_enstr-->
<span class="jpstr">
下の例は、さいころに基づく様々なボードゲームで使うために、２つのプロトコルを定義します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">protocol</span> <span class="nv">DiceGame</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">dice</span>: <span class="nc">Dice</span> { <span class="k">get</span> }
</li>
<li>    <span class="k">func</span> <span class="nv">play</span>()
</li>
<li>}
</li>
<li>
<span class="k">protocol</span> <span class="nv">DiceGameDelegate</span>: <span class="nc">AnyObject</span> {
</li>
<li>    <span class="k">func</span> <span class="nv">gameDidStart</span>(<span class="k">_</span> <span class="nv">game</span>: <span class="nc">DiceGame</span>)
</li>
<li>    <span class="k">func</span> <span class="nv">game</span>(<span class="k">_</span> <span class="nv">game</span>: <span class="nc">DiceGame</span>, <span class="nv">didStartNewTurnWithDiceRoll</span> <span class="nv">diceRoll</span>: <span class="nc">Int</span>)
</li>
<li>    <span class="k">func</span> <span class="nv">gameDidEnd</span>(<span class="k">_</span> <span class="nv">game</span>: <span class="nc">DiceGame</span>)
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">DiceGame</span></code> protocol is a protocol that can be adopted by any game that involves dice.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">DiceGame</span></code>プロトコルは、さいころが関わるどんなゲームによってでも採用されることができるプロトコルです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">DiceGameDelegate</span></code> protocol can be adopted to track the progress of a <code class="docutils literal notranslate"><span class="pre">DiceGame</span></code>. To prevent strong reference cycles, delegates are declared as weak references. For information about weak references, see <a class="reference internal" href="AutomaticReferenceCounting.html#ID51"><span class="std std-ref">Strong Reference Cycles Between Class Instances</span></a>. Marking the protocol as class-only lets the <code class="docutils literal notranslate"><span class="pre">SnakesAndLadders</span></code> class later in this chapter declare that its delegate must use a weak reference. A class-only protocol is marked by its inheritance from <code class="docutils literal notranslate"><span class="pre">AnyObject</span></code>, as discussed in <a class="reference internal" href="#ID281"><span class="std std-ref">Class-Only Protocols</span></a>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">DiceGameDelegate</span></code>プロトコルが採用されることで、<code class="docutils literal notranslate"><span class="pre">DiceGame</span></code>の進捗を追いかけることができます。強い参照循環を防ぐために、委任先は弱い参照として宣言されます。弱い参照についての詳細は、<a class="reference internal" href="AutomaticReferenceCounting.html#ID51"><span class="std std-ref">クラスインスタンス間の強い参照循環</span></a>を見てください。プロトコルをクラス専用とすることは、<code class="docutils literal notranslate"><span class="pre">SnakesAndLadders</span></code>クラスに後でこの章においてその委任先が弱い参照を使わなければならないことを宣言させます。クラス専用プロトコルは、<code class="docutils literal notranslate"><span class="pre">AnyObject</span></code>からのそれの継承によって印されます、<a class="reference internal" href="#ID281"><span class="std std-ref">クラス専用プロトコル</span></a>において議論されるように。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Here’s a version of the <em>Snakes and Ladders</em> game originally introduced in <a class="reference internal" href="ControlFlow.html"><span class="doc">Control Flow</span></a>. This version is adapted to use a <code class="docutils literal notranslate"><span class="pre">Dice</span></code> instance for its dice-rolls; to adopt the <code class="docutils literal notranslate"><span class="pre">DiceGame</span></code> protocol; and to notify a <code class="docutils literal notranslate"><span class="pre">DiceGameDelegate</span></code> about its progress:</span><!--end_enstr-->
<span class="jpstr">
<a class="reference internal" href="ControlFlow.html"><span class="doc">制御の流れ</span></a>で元々は紹介される<em>ヘビとはしご</em>ゲームのひとつの改作が、ここにあります。この版は改変され、それにより、それのさいころ振りに<code class="docutils literal notranslate"><span class="pre">Dice</span></code>インスタンスを使用します；<code class="docutils literal notranslate"><span class="pre">DiceGame</span></code>プロトコルを採用します；そして、その進歩について<code class="docutils literal notranslate"><span class="pre">DiceGameDelegate</span></code>に通知します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">class</span> <span class="nv">SnakesAndLadders</span>: <span class="nc">DiceGame</span> {
</li>
<li>    <span class="k">let</span> <span class="nv">finalSquare</span> = <span class="m">25</span>
</li>
<li>    <span class="k">let</span> <span class="nv">dice</span> = <span class="nv">Dice</span>(<span class="nv">sides</span>: <span class="m">6</span>, <span class="nv">generator</span>: <span class="nv">LinearCongruentialGenerator</span>())
</li>
<li>    <span class="k">var</span> <span class="nv">square</span> = <span class="m">0</span>
</li>
<li>    <span class="k">var</span> <span class="nv">board</span>: [<span class="nc">Int</span>]
</li>
<li>    <span class="k">init</span>() {
</li>
<li>        <span class="nv">board</span> = <span class="nv">Array</span>(<span class="nv">repeating</span>: <span class="m">0</span>, <span class="nv">count</span>: <span class="nv">finalSquare</span> + <span class="m">1</span>)
</li>
<li>        <span class="nv">board</span>[<span class="m">03</span>] = +<span class="m">08</span>; <span class="nv">board</span>[<span class="m">06</span>] = +<span class="m">11</span>; <span class="nv">board</span>[<span class="m">09</span>] = +<span class="m">09</span>; <span class="nv">board</span>[<span class="m">10</span>] = +<span class="m">02</span>
</li>
<li>        <span class="nv">board</span>[<span class="m">14</span>] = <span class="m">-10</span>; <span class="nv">board</span>[<span class="m">19</span>] = <span class="m">-11</span>; <span class="nv">board</span>[<span class="m">22</span>] = <span class="m">-02</span>; <span class="nv">board</span>[<span class="m">24</span>] = <span class="m">-08</span>
</li>
<li>    }
</li>
<li>    <span class="k">weak</span> <span class="k">var</span> <span class="nv">delegate</span>: <span class="nc">DiceGameDelegate</span>?
</li>
<li>    <span class="k">func</span> <span class="nv">play</span>() {
</li>
<li>        <span class="nv">square</span> = <span class="m">0</span>
</li>
<li>        <span class="nv">delegate</span>?.<span class="nv">gameDidStart</span>(<span class="k">self</span>)
</li>
<li>        <span class="nv">gameLoop</span>: <span class="k">while</span> <span class="nv">square</span> != <span class="nv">finalSquare</span> {
</li>
<li>            <span class="k">let</span> <span class="nv">diceRoll</span> = <span class="nv">dice</span>.<span class="nv">roll</span>()
</li>
<li>            <span class="nv">delegate</span>?.<span class="nv">game</span>(<span class="k">self</span>, <span class="nv">didStartNewTurnWithDiceRoll</span>: <span class="nv">diceRoll</span>)
</li>
<li>            <span class="k">switch</span> <span class="nv">square</span> + <span class="nv">diceRoll</span> {
</li>
<li>            <span class="k">case</span> <span class="nv">finalSquare</span>:
</li>
<li>                <span class="k">break</span> <span class="nv">gameLoop</span>
</li>
<li>            <span class="k">case</span> <span class="k">let</span> <span class="nv">newSquare</span> <span class="k">where</span> <span class="nv">newSquare</span> &gt; <span class="nv">finalSquare</span>:
</li>
<li>                <span class="k">continue</span> <span class="nv">gameLoop</span>
</li>
<li>            <span class="k">default</span>:
</li>
<li>                <span class="nv">square</span> += <span class="nv">diceRoll</span>
</li>
<li>                <span class="nv">square</span> += <span class="nv">board</span>[<span class="nv">square</span>]
</li>
<li>            }
</li>
<li>        }
</li>
<li>        <span class="nv">delegate</span>?.<span class="nv">gameDidEnd</span>(<span class="k">self</span>)
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">For a description of the <em>Snakes and Ladders</em> gameplay, see <a class="reference internal" href="ControlFlow.html#ID137"><span class="std std-ref">Break</span></a>.</span><!--end_enstr-->
<span class="jpstr">
<em>ヘビとはしご</em>のゲームプレイの解説として、<a class="reference internal" href="ControlFlow.html#ID137"><span class="std std-ref">Break</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">This version of the game is wrapped up as a class called <code class="docutils literal notranslate"><span class="pre">SnakesAndLadders</span></code>, which adopts the <code class="docutils literal notranslate"><span class="pre">DiceGame</span></code> protocol. It provides a gettable <code class="docutils literal notranslate"><span class="pre">dice</span></code> property and a <code class="docutils literal notranslate"><span class="pre">play()</span></code> method in order to conform to the protocol. (The <code class="docutils literal notranslate"><span class="pre">dice</span></code> property is declared as a constant property because it doesn’t need to change after initialization, and the protocol only requires that it must be gettable.)</span><!--end_enstr-->
<span class="jpstr">
ゲームのこの改作は、<code class="docutils literal notranslate"><span class="pre">SnakesAndLadders</span></code>と呼ばれるクラスで包まれます、それは、<code class="docutils literal notranslate"><span class="pre">DiceGame</span></code>プロトコルを採用します。それは、プロトコルに従うために取得可能な<code class="docutils literal notranslate"><span class="pre">dice</span></code>プロパティと<code class="docutils literal notranslate"><span class="pre">play()</span></code>メソッドを提供します。（<code class="docutils literal notranslate"><span class="pre">dice</span></code>プロパティは定数プロパティとして宣言されます、なぜなら、それが初期化の後に変化する必要がなく、そして、プロトコルはそれが取得可能なことを必要とするだけであるからです）。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <em>Snakes and Ladders</em> game board setup takes place within the class’s <code class="docutils literal notranslate"><span class="pre">init()</span></code> initializer. All game logic is moved into the protocol’s <code class="docutils literal notranslate"><span class="pre">play</span></code> method, which uses the protocol’s required <code class="docutils literal notranslate"><span class="pre">dice</span></code> property to provide its dice roll values.</span><!--end_enstr-->
<span class="jpstr">
<em>ヘビとはしご</em>ゲーム盤設定は、このクラスの<code class="docutils literal notranslate"><span class="pre">init()</span></code>イニシャライザ内で行われます。全てのゲーム論理は、プロトコルの<code class="docutils literal notranslate"><span class="pre">play</span></code>メソッドに引っ越します、それは、プロトコルの要求する<code class="docutils literal notranslate"><span class="pre">dice</span></code>プロパティを使ってそれのさいころ振りの値を提供します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Note that the <code class="docutils literal notranslate"><span class="pre">delegate</span></code> property is defined as an <em>optional</em> <code class="docutils literal notranslate"><span class="pre">DiceGameDelegate</span></code>, because a delegate isn’t required in order to play the game. Because it’s of an optional type, the <code class="docutils literal notranslate"><span class="pre">delegate</span></code> property is automatically set to an initial value of <code class="docutils literal notranslate"><span class="pre">nil</span></code>. Thereafter, the game instantiator has the option to set the property to a suitable delegate. Because the <code class="docutils literal notranslate"><span class="pre">DiceGameDelegate</span></code> protocol is class-only, you can declare the delegate to be <code class="docutils literal notranslate"><span class="pre">weak</span></code> to prevent reference cycles.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">delegate</span></code>プロパティが、<em>オプショナル</em>の<code class="docutils literal notranslate"><span class="pre">DiceGameDelegate</span></code>として定義される点に注意してください、delegateがゲームをプレイするために必須でないからです。それがオプショナル型であるので、<code class="docutils literal notranslate"><span class="pre">delegate</span></code>プロパティは自動的に初期値の<code class="docutils literal notranslate"><span class="pre">nilに</span></code>設定されます。その後は、このゲームのイニシャライザは、このプロパティを適当な委任先に設定する選択肢を持ちます。<code class="docutils literal notranslate"><span class="pre">DiceGameDelegate</span></code>プロトコルがクラス専用であることから、あなたは委任先を<code class="docutils literal notranslate"><span class="pre">weak</span></code>であると宣言して参照循環を防ぐことができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr"><code class="docutils literal notranslate"><span class="pre">DiceGameDelegate</span></code> provides three methods for tracking the progress of a game. These three methods have been incorporated into the game logic within the <code class="docutils literal notranslate"><span class="pre">play()</span></code> method above, and are called when a new game starts, a new turn begins, or the game ends.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">DiceGameDelegate</span></code>は、３つのメソッドをゲームの進捗を追うために提供します。これらの３つのメソッドは、上の<code class="docutils literal notranslate"><span class="pre">play()</span></code>メソッド内のゲーム論理に組み込まれています、そして、新しいゲームが始まるとき、新しいターンを開始するとき、あるいはこのゲームが終わるとき、呼ばれます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Because the <code class="docutils literal notranslate"><span class="pre">delegate</span></code> property is an <em>optional</em> <code class="docutils literal notranslate"><span class="pre">DiceGameDelegate</span></code>, the <code class="docutils literal notranslate"><span class="pre">play()</span></code> method uses optional chaining each time it calls a method on the delegate. If the <code class="docutils literal notranslate"><span class="pre">delegate</span></code> property is nil, these delegate calls fail gracefully and without error. If the <code class="docutils literal notranslate"><span class="pre">delegate</span></code> property is non-nil, the delegate methods are called, and are passed the <code class="docutils literal notranslate"><span class="pre">SnakesAndLadders</span></code> instance as a parameter.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">delegate</span></code>プロパティが<em>オプショナル</em>の<code class="docutils literal notranslate"><span class="pre">DiceGameDelegate</span></code>であるので、<code class="docutils literal notranslate"><span class="pre">play()</span></code>メソッドは、それが委任先でメソッドを呼ぶたびにオプショナル連鎖を使います。<code class="docutils literal notranslate"><span class="pre">delegate</span></code>プロパティがnilならば、これらの委任先呼び出しはエラーなしで美しく失敗します。<code class="docutils literal notranslate"><span class="pre">delegate</span></code>プロパティがnilでないならば、委任先のさまざまなメソッドが呼ばれます、そしてパラメータとして<code class="docutils literal notranslate"><span class="pre">SnakesAndLadders</span></code>インスタンスを渡されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">This next example shows a class called <code class="docutils literal notranslate"><span class="pre">DiceGameTracker</span></code>, which adopts the <code class="docutils literal notranslate"><span class="pre">DiceGameDelegate</span></code> protocol:</span><!--end_enstr-->
<span class="jpstr">
この次の例は<code class="docutils literal notranslate"><span class="pre">DiceGameTracker</span></code>と呼ばれるクラスを示します、それは、<code class="docutils literal notranslate"><span class="pre">DiceGameDelegate</span></code>プロトコルを採用します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">class</span> <span class="nv">DiceGameTracker</span>: <span class="nc">DiceGameDelegate</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">numberOfTurns</span> = <span class="m">0</span>
</li>
<li>    <span class="k">func</span> <span class="nv">gameDidStart</span>(<span class="k">_</span> <span class="nv">game</span>: <span class="nc">DiceGame</span>) {
</li>
<li>        <span class="nv">numberOfTurns</span> = <span class="m">0</span>
</li>
<li>        <span class="k">if</span> <span class="nv">game</span> <span class="k">is</span> <span class="nc">SnakesAndLadders</span> {
</li>
<li>            <span class="nv">print</span>(<span class="s">"Started a new game of Snakes and Ladders"</span>)
</li>
<li>        }
</li>
<li>        <span class="nv">print</span>(<span class="s">"The game is using a </span>\<span class="p">(</span><span class="nv">game</span>.<span class="nv">dice</span>.<span class="nv">sides</span><span class="p">)</span><span class="s">-sided dice"</span>)
</li>
<li>    }
</li>
<li>    <span class="k">func</span> <span class="nv">game</span>(<span class="k">_</span> <span class="nv">game</span>: <span class="nc">DiceGame</span>, <span class="nv">didStartNewTurnWithDiceRoll</span> <span class="nv">diceRoll</span>: <span class="nc">Int</span>) {
</li>
<li>        <span class="nv">numberOfTurns</span> += <span class="m">1</span>
</li>
<li>        <span class="nv">print</span>(<span class="s">"Rolled a </span>\<span class="p">(</span><span class="nv">diceRoll</span><span class="p">)</span><span class="s">"</span>)
</li>
<li>    }
</li>
<li>    <span class="k">func</span> <span class="nv">gameDidEnd</span>(<span class="k">_</span> <span class="nv">game</span>: <span class="nc">DiceGame</span>) {
</li>
<li>        <span class="nv">print</span>(<span class="s">"The game lasted for </span>\<span class="p">(</span><span class="nv">numberOfTurns</span><span class="p">)</span><span class="s"> turns"</span>)
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr"><code class="docutils literal notranslate"><span class="pre">DiceGameTracker</span></code> implements all three methods required by <code class="docutils literal notranslate"><span class="pre">DiceGameDelegate</span></code>. It uses these methods to keep track of the number of turns a game has taken. It resets a <code class="docutils literal notranslate"><span class="pre">numberOfTurns</span></code> property to zero when the game starts, increments it each time a new turn begins, and prints out the total number of turns once the game has ended.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">DiceGameTracker</span></code>は、<code class="docutils literal notranslate"><span class="pre">DiceGameDelegate</span></code>によって要求される３つのメソッド全てを実装します。それは、あるゲームがとったターンの数の情報を得続けるためにこれらのメソッドを使用します。それは、ゲームが始まるとき<code class="docutils literal notranslate"><span class="pre">numberOfTurns</span></code>プロパティをゼロに再設定します、新しいターンが開始するときそれぞれそれを増加させます、そしてひとたびゲームが終わってしまったならばターンの総数を出力します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The implementation of <code class="docutils literal notranslate"><span class="pre">gameDidStart(_:)</span></code> shown above uses the <code class="docutils literal notranslate"><span class="pre">game</span></code> parameter to print some introductory information about the game that’s about to be played. The <code class="docutils literal notranslate"><span class="pre">game</span></code> parameter has a type of <code class="docutils literal notranslate"><span class="pre">DiceGame</span></code>, not <code class="docutils literal notranslate"><span class="pre">SnakesAndLadders</span></code>, and so <code class="docutils literal notranslate"><span class="pre">gameDidStart(_:)</span></code> can access and use only methods and properties that are implemented as part of the <code class="docutils literal notranslate"><span class="pre">DiceGame</span></code> protocol. However, the method is still able to use type casting to query the type of the underlying instance. In this example, it checks whether <code class="docutils literal notranslate"><span class="pre">game</span></code> is actually an instance of <code class="docutils literal notranslate"><span class="pre">SnakesAndLadders</span></code> behind the scenes, and prints an appropriate message if so.</span><!--end_enstr-->
<span class="jpstr">
上で示される<code class="docutils literal notranslate"><span class="pre">gameDidStart(_:)</span></code>の実装は、<code class="docutils literal notranslate"><span class="pre">game</span></code>パラメータを使って、プレイされようとしているゲームに関する若干の紹介の情報を出力します。<code class="docutils literal notranslate"><span class="pre">game</span></code>パラメータは、型<code class="docutils literal notranslate"><span class="pre">DiceGame</span></code>を持ちます、<code class="docutils literal notranslate"><span class="pre">SnakesAndLadders</span></code>ではありません、なので、<code class="docutils literal notranslate"><span class="pre">gameDidStart(_:)</span></code>は<code class="docutils literal notranslate"><span class="pre">DiceGame</span></code>プロトコルの一部として実施されるメソッドとプロパティだけにアクセスして使用することができます。しかし、このメソッドは依然として基盤インスタンスの型についてたずねるために型キャストを使うことができます。この例では、<code class="docutils literal notranslate"><span class="pre">game</span></code>が実際に舞台裏で<code class="docutils literal notranslate"><span class="pre">SnakesAndLadders</span></code>のインスタンスであるかどうか調べて、もしそうならば適切なメッセージを出力します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">gameDidStart(_:)</span></code> method also accesses the <code class="docutils literal notranslate"><span class="pre">dice</span></code> property of the passed <code class="docutils literal notranslate"><span class="pre">game</span></code> parameter. Because <code class="docutils literal notranslate"><span class="pre">game</span></code> is known to conform to the <code class="docutils literal notranslate"><span class="pre">DiceGame</span></code> protocol, it’s guaranteed to have a <code class="docutils literal notranslate"><span class="pre">dice</span></code> property, and so the <code class="docutils literal notranslate"><span class="pre">gameDidStart(_:)</span></code> method is able to access and print the dice’s <code class="docutils literal notranslate"><span class="pre">sides</span></code> property, regardless of what kind of game is being played.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">gameDidStart(_:)</span></code>メソッドはまた、渡された<code class="docutils literal notranslate"><span class="pre">game</span></code>パラメータの<code class="docutils literal notranslate"><span class="pre">dice</span></code>プロパティにアクセスします。<code class="docutils literal notranslate"><span class="pre">game</span></code>が<code class="docutils literal notranslate"><span class="pre">DiceGame</span></code>プロトコルに従うと知られているので、それは<code class="docutils literal notranslate"><span class="pre">dice</span></code>プロパティを持つと保証されます、なので、<code class="docutils literal notranslate"><span class="pre">gameDidStart(_:)</span></code>メソッドは、どんな種類のゲームがプレイされているかに関係なく、diceの<code class="docutils literal notranslate"><span class="pre">sides</span></code>プロパティにアクセスして出力することができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Here’s how <code class="docutils literal notranslate"><span class="pre">DiceGameTracker</span></code> looks in action:</span><!--end_enstr-->
<span class="jpstr">
動作中の<code class="docutils literal notranslate"><span class="pre">DiceGameTracker</span></code>がどのように見えるかは、ここにあります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">tracker</span> = <span class="nv">DiceGameTracker</span>()
</li>
<li>
<span class="k">let</span> <span class="nv">game</span> = <span class="nv">SnakesAndLadders</span>()
</li>
<li>
<span class="nv">game</span>.<span class="nv">delegate</span> = <span class="nv">tracker</span>
</li>
<li>
<span class="nv">game</span>.<span class="nv">play</span>()
</li>
<li>
<span class="c"><span class="enstr">// Started a new game of Snakes and Ladders</span><!--end_enstr--><span class="jpstr">（ヘビとはしごの新しいゲームを始める）</span><!--end_jpstr--></span>
</li>
<li>
<span class="c"><span class="enstr">// The game is using a 6-sided dice</span><!--end_enstr--><span class="jpstr">（ゲームは、６面のさいころを使っています）</span><!--end_jpstr--></span>
</li>
<li>
<span class="c"><span class="enstr">// Rolled a 3</span><!--end_enstr--><span class="jpstr">（３を出した）</span><!--end_jpstr--></span>
</li>
<li>
<span class="c"><span class="enstr">// Rolled a 5</span><!--end_enstr--><span class="jpstr">（５を出した）</span><!--end_jpstr--></span>
</li>
<li>
<span class="c"><span class="enstr">// Rolled a 4</span><!--end_enstr--><span class="jpstr">（４を出した）</span><!--end_jpstr--></span>
</li>
<li>
<span class="c"><span class="enstr">// Rolled a 5</span><!--end_enstr--><span class="jpstr">（５を出した）</span><!--end_jpstr--></span>
</li>
<li>
<span class="c"><span class="enstr">// The game lasted for 4 turns</span><!--end_enstr--><span class="jpstr">（ゲームは、４回続きました）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
</div>
<div class="section" id="ID277">
<h2><span class="enstr">Adding Protocol Conformance with an Extension<a class="headerlink" href="#ID277" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
拡張を使ってプロトコル準拠を加える<a class="headerlink" href="#ID277" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">You can extend an existing type to adopt and conform to a new protocol, even if you don’t have access to the source code for the existing type. Extensions can add new properties, methods, and subscripts to an existing type, and are therefore able to add any requirements that a protocol may demand. For more about extensions, see <a class="reference internal" href="Extensions.html"><span class="doc">Extensions</span></a>.</span><!--end_enstr-->
<span class="jpstr">
あなたは、ある新しいプロトコルを採用して準拠することで既存の型を拡張することができます、たとえあなたが既存の型のソース・コードにアクセスをしないとしてもです。拡張は、新しいプロパティ、メソッド、そして添え字を既存の型に加えることができます、したがって、あるプロトコルが要求するであろうどんな要件でも加えることができます。拡張についてのより多くのために、<a class="reference internal" href="Extensions.html"><span class="doc">拡張</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Existing instances of a type automatically adopt and conform to a protocol when that conformance is added to the instance’s type in an extension.</span><!--end_enstr-->
<span class="jpstr">
ある型の既存のインスタンスそれらは、そのインスタンスの型に拡張の中で準拠が加えられるとき、そのプロトコルを自動的に採用して準拠します。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">For example, this protocol, called <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>, can be implemented by any type that has a way to be represented as text. This might be a description of itself, or a text version of its current state:</span><!--end_enstr-->
<span class="jpstr">
例えば、このプロトコル、<code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>と呼ばれるものは、テキストとして表わされる方法を持つどんな型によってでも実装されることができます。これは、それ自身の説明、またはテキスト版のそれの現在の状態であるかもしれません：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">protocol</span> <span class="nv">TextRepresentable</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">textualDescription</span>: <span class="nc">String</span> { <span class="k">get</span> }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">Dice</span></code> class from above can be extended to adopt and conform to <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>:</span><!--end_enstr-->
<span class="jpstr">
上の<code class="docutils literal notranslate"><span class="pre">Dice</span></code>クラスは、拡張されることで、<code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>を採用して準拠することができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">extension</span> <span class="nc">Dice</span>: <span class="nc">TextRepresentable</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">textualDescription</span>: <span class="nc">String</span> {
</li>
<li>        <span class="k">return</span> <span class="s">"A </span>\<span class="p">(</span><span class="nv">sides</span><span class="p">)</span><span class="s">-sided dice"</span>
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">This extension adopts the new protocol in exactly the same way as if <code class="docutils literal notranslate"><span class="pre">Dice</span></code> had provided it in its original implementation. The protocol name is provided after the type name, separated by a colon, and an implementation of all requirements of the protocol is provided within the extension’s curly braces.</span><!--end_enstr-->
<span class="jpstr">
この拡張は、まるで<code class="docutils literal notranslate"><span class="pre">Dice</span></code>がその最初の実装においてそれを提供したかのように、正確に同じふうに新しいプロトコルを採用します。プロトコル名は、型名の後にコロンで区切られて提供されます、そして、プロトコルの全ての要件の実装は、拡張の波括弧内で提供されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Any <code class="docutils literal notranslate"><span class="pre">Dice</span></code> instance can now be treated as <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>:</span><!--end_enstr-->
<span class="jpstr">
どんな<code class="docutils literal notranslate"><span class="pre">Dice</span></code>インスタンスでも、今や<code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>として扱われることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">d12</span> = <span class="nv">Dice</span>(<span class="nv">sides</span>: <span class="m">12</span>, <span class="nv">generator</span>: <span class="nv">LinearCongruentialGenerator</span>())
</li>
<li>
<span class="nv">print</span>(<span class="nv">d12</span>.<span class="nv">textualDescription</span>)
</li>
<li>
<span class="c"><span class="enstr">// Prints "A 12-sided dice"</span><!--end_enstr--><span class="jpstr">（「ひとつの12面さいころ」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">Similarly, the <code class="docutils literal notranslate"><span class="pre">SnakesAndLadders</span></code> game class can be extended to adopt and conform to the <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code> protocol:</span><!--end_enstr-->
<span class="jpstr">
同じように、<code class="docutils literal notranslate"><span class="pre">SnakesAndLadders</span></code>ゲーム・クラスは、拡張されることで、<code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>プロトコルを採用して準拠することができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">extension</span> <span class="nc">SnakesAndLadders</span>: <span class="nc">TextRepresentable</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">textualDescription</span>: <span class="nc">String</span> {
</li>
<li>        <span class="k">return</span> <span class="s">"A game of Snakes and Ladders with </span>\<span class="p">(</span><span class="nv">finalSquare</span><span class="p">)</span><span class="s"> squares"</span>
</li>
<li>    }
</li>
<li>}
</li>
<li>
<span class="nv">print</span>(<span class="nv">game</span>.<span class="nv">textualDescription</span>)
</li>
<li>
<span class="c"><span class="enstr">// Prints "A game of Snakes and Ladders with 25 squares"</span><!--end_enstr--><span class="jpstr">（「25ますのヘビとはしごのゲーム」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<div class="section" id="ID574">
<h3><span class="enstr">Conditionally Conforming to a Protocol<a class="headerlink" href="#ID574" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
あるプロトコルに条件付きで準拠する<a class="headerlink" href="#ID574" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">A generic type may be able to satisfy the requirements of a protocol only under certain conditions, such as when the type’s generic parameter conforms to the protocol. You can make a generic type conditionally conform to a protocol by listing constraints when extending the type. Write these constraints after the name of the protocol you’re adopting by writing a generic <code class="docutils literal notranslate"><span class="pre">where</span></code> clause. For more about generic <code class="docutils literal notranslate"><span class="pre">where</span></code> clauses, see <a class="reference internal" href="Generics.html#ID192"><span class="std std-ref">Generic Where Clauses</span></a>.</span><!--end_enstr-->
<span class="jpstr">
総称体型は、あるプロトコルの要件を満たすことが一定の条件の下でのみ可能でしょう、例えばその型のもつ総称体パラメータがそのプロトコルに準拠する場合など。あなたは、ある総称体型を条件付きでプロトコルに準拠させることが、その型を拡張する時に制約を列記することによって可能です。それらの制約を、あなたが総称体<code class="docutils literal notranslate"><span class="pre">where</span></code>節を書くことによって採用しているプロトコルの名前の後に書いてください。総称体<code class="docutils literal notranslate"><span class="pre">where</span></code>節に関する詳細は、<a class="reference internal" href="Generics.html#ID192"><span class="std std-ref">総称体where節</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The following extension makes <code class="docutils literal notranslate"><span class="pre">Array</span></code> instances conform to the <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code> protocol whenever they store elements of a type that conforms to <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>.</span><!--end_enstr-->
<span class="jpstr">
以下の拡張は、<code class="docutils literal notranslate"><span class="pre">Array</span></code>インスタンスを<code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>プロトコルに準拠させます、それが<code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>に準拠する型の要素を格納する時は必ずです。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">extension</span> <span class="nc">Array</span>: <span class="nc">TextRepresentable</span> <span class="k">where</span> <span class="nc">Element</span>: <span class="nc">TextRepresentable</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">textualDescription</span>: <span class="nc">String</span> {
</li>
<li>        <span class="k">let</span> <span class="nv">itemsAsText</span> = <span class="k">self</span>.<span class="nv">map</span> { <span class="nv">$0</span>.<span class="nv">textualDescription</span> }
</li>
<li>        <span class="k">return</span> <span class="s">"["</span> + <span class="nv">itemsAsText</span>.<span class="nv">joined</span>(<span class="nv">separator</span>: <span class="s">", "</span>) + <span class="s">"]"</span>
</li>
<li>    }
</li>
<li>}
</li>
<li>
<span class="k">let</span> <span class="nv">myDice</span> = [<span class="nv">d6</span>, <span class="nv">d12</span>]
</li>
<li>
<span class="nv">print</span>(<span class="nv">myDice</span>.<span class="nv">textualDescription</span>)
</li>
<li>
<span class="c">// Prints "[A 6-sided dice, A 12-sided dice]"</span>
</li>
</ol></div></div></div>
</div>
<div class="section" id="ID278">
<h3><span class="enstr">Declaring Protocol Adoption with an Extension<a class="headerlink" href="#ID278" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
拡張を使ってプロトコル採用を宣言する<a class="headerlink" href="#ID278" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">If a type already conforms to all of the requirements of a protocol, but hasn’t yet stated that it adopts that protocol, you can make it adopt the protocol with an empty extension:</span><!--end_enstr-->
<span class="jpstr">
ある型があるプロトコルの要件の全てにすでに準拠するが、それがそのプロトコルを採用するとまだ示していなかったならば、あなたは空の拡張を使ってそれがそのプロトコルを採用するようにできます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">struct</span> <span class="nv">Hamster</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">name</span>: <span class="nc">String</span>
</li>
<li>    <span class="k">var</span> <span class="nv">textualDescription</span>: <span class="nc">String</span> {
</li>
<li>        <span class="k">return</span> <span class="s">"A hamster named </span>\<span class="p">(</span><span class="nv">name</span><span class="p">)</span><span class="s">"</span>
</li>
<li>    }
</li>
<li>}
</li>
<li>
<span class="k">extension</span> <span class="nc">Hamster</span>: <span class="nc">TextRepresentable</span> {}
</li>
</ol></div></div></div>
<p><span class="enstr">Instances of <code class="docutils literal notranslate"><span class="pre">Hamster</span></code> can now be used wherever <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code> is the required type:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>が必要な型であるどこででも、<code class="docutils literal notranslate"><span class="pre">Hamster</span></code>のインスタンスが現在使われることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">simonTheHamster</span> = <span class="nv">Hamster</span>(<span class="nv">name</span>: <span class="s">"Simon"</span>)
</li>
<li>
<span class="k">let</span> <span class="nv">somethingTextRepresentable</span>: <span class="nc">TextRepresentable</span> = <span class="nv">simonTheHamster</span>
</li>
<li>
<span class="nv">print</span>(<span class="nv">somethingTextRepresentable</span>.<span class="nv">textualDescription</span>)
</li>
<li>
<span class="c"><span class="enstr">// Prints "A hamster named Simon"</span><!--end_enstr--><span class="jpstr">（「サイモンという名前のハムスター」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Types don’t automatically adopt a protocol just by satisfying its requirements. They must always explicitly declare their adoption of the protocol.</span><!--end_enstr-->
<span class="jpstr">
型は、単にその要件を満たすことだけによっては自動的にあるプロトコルを採用しません。それらは、常に明示的にそのプロトコルについてそれらが採用することを宣言しなければなりません。
</span><!--end_jpstr-->
</p>
</div>
</div>
</div>
<div class="section" id="ID627">
<h2><span class="enstr">Adopting a Protocol Using a Synthesized Implementation<a class="headerlink" href="#ID627" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
プロトコルを合成実装を使って採用する<a class="headerlink" href="#ID627" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">Swift can automatically provide the protocol conformance for <code class="docutils literal notranslate"><span class="pre">Equatable</span></code>, <code class="docutils literal notranslate"><span class="pre">Hashable</span></code>, and <code class="docutils literal notranslate"><span class="pre">Comparable</span></code> in many simple cases. Using this synthesized implementation means you don’t have to write repetitive boilerplate code to implement the protocol requirements yourself.</span><!--end_enstr-->
<span class="jpstr">
スウィフトは、自動的にプロトコル準拠を<code class="docutils literal notranslate"><span class="pre">Equatable</span></code>、<code class="docutils literal notranslate"><span class="pre">Hashable</span></code>、そして<code class="docutils literal notranslate"><span class="pre">Comparable</span></code>に対して提供することが多くの単純な場合において可能です。この合成実装を使うことは、あなたが繰り返しの常用文コードを書いてプロトコル要件をあなた自身で実装する必要はないのを意味します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Swift provides a synthesized implementation of <code class="docutils literal notranslate"><span class="pre">Equatable</span></code> for the following kinds of custom types:</span><!--end_enstr-->
<span class="jpstr">
スウィフトは、<code class="docutils literal notranslate"><span class="pre">Equatable</span></code>の合成実装を以下の種類のあつらえの型に提供します：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li><span class="enstr">Structures that have only stored properties that conform to the <code class="docutils literal notranslate"><span class="pre">Equatable</span></code> protocol</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Equatable</span></code>プロトコルに準拠する格納プロパティだけを持つ構造体
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Enumerations that have only associated types that conform to the <code class="docutils literal notranslate"><span class="pre">Equatable</span></code> protocol</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Equatable</span></code>プロトコルに準拠する関連型だけを持つ列挙
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Enumerations that have no associated types</span><!--end_enstr-->
<span class="jpstr">
関連型を持たない列挙
</span><!--end_jpstr-->
</li>
</ul>
<p><span class="enstr">To receive a synthesized implementation of <code class="docutils literal notranslate"><span class="pre">==</span></code>, declare conformance to <code class="docutils literal notranslate"><span class="pre">Equatable</span></code> in the file that contains the original declaration, without implementing an <code class="docutils literal notranslate"><span class="pre">==</span></code> operator yourself. The <code class="docutils literal notranslate"><span class="pre">Equatable</span></code> protocol provides a default implementation of <code class="docutils literal notranslate"><span class="pre">!=</span></code>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">==</span></code>の合成実装を受け取るには、<code class="docutils literal notranslate"><span class="pre">Equatable</span></code>への準拠を本来の宣言を含んでいるファイルにおいて宣言してください、<code class="docutils literal notranslate"><span class="pre">==</span></code>演算子をあなた自身で実装することなしに。<code class="docutils literal notranslate"><span class="pre">Equatable</span></code>プロトコルは、<code class="docutils literal notranslate"><span class="pre">!=</span></code>の省略時の実装を提供します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The example below defines a <code class="docutils literal notranslate"><span class="pre">Vector3D</span></code> structure for a three-dimensional position vector <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code>, similar to the <code class="docutils literal notranslate"><span class="pre">Vector2D</span></code> structure. Because the <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, and <code class="docutils literal notranslate"><span class="pre">z</span></code> properties are all of an <code class="docutils literal notranslate"><span class="pre">Equatable</span></code> type, <code class="docutils literal notranslate"><span class="pre">Vector3D</span></code> receives synthesized implementations of the equivalence operators.</span><!--end_enstr-->
<span class="jpstr">
下の例は、<code class="docutils literal notranslate"><span class="pre">Vector3D</span></code>構造体を３次元の位置ベクトル<code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code>に対して定義する、<code class="docutils literal notranslate"><span class="pre">Vector2D</span></code>構造体に似たものです。<code class="docutils literal notranslate"><span class="pre">x</span></code>、<code class="docutils literal notranslate"><span class="pre">y</span></code>、そして<code class="docutils literal notranslate"><span class="pre">z</span></code>プロパティはみんな<code class="docutils literal notranslate"><span class="pre">Equatable</span></code>型なので、<code class="docutils literal notranslate"><span class="pre">Vector3D</span></code>は等価演算子の合成された実装それらを受け取ります。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">struct</span> <span class="nv">Vector3D</span>: <span class="nc">Equatable</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">x</span> = <span class="m">0.0</span>, <span class="nv">y</span> = <span class="m">0.0</span>, <span class="nv">z</span> = <span class="m">0.0</span>
</li>
<li>}
</li>
<li>
</li>
<li>
<span class="k">let</span> <span class="nv">twoThreeFour</span> = <span class="nv">Vector3D</span>(<span class="nv">x</span>: <span class="m">2.0</span>, <span class="nv">y</span>: <span class="m">3.0</span>, <span class="nv">z</span>: <span class="m">4.0</span>)
</li>
<li>
<span class="k">let</span> <span class="nv">anotherTwoThreeFour</span> = <span class="nv">Vector3D</span>(<span class="nv">x</span>: <span class="m">2.0</span>, <span class="nv">y</span>: <span class="m">3.0</span>, <span class="nv">z</span>: <span class="m">4.0</span>)
</li>
<li>
<span class="k">if</span> <span class="nv">twoThreeFour</span> == <span class="nv">anotherTwoThreeFour</span> {
</li>
<li>    <span class="nv">print</span>(<span class="s">"These two vectors are also equivalent."</span>)
</li>
<li>}
</li>
<li>
<span class="c"><span class="enstr">// Prints "These two vectors are also equivalent."</span><!--end_enstr--><span class="jpstr">（「これらの２つのベクトルはまた等しいです。」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">Swift provides a synthesized implementation of <code class="docutils literal notranslate"><span class="pre">Hashable</span></code> for the following kinds of custom types:</span><!--end_enstr-->
<span class="jpstr">
スウィフトは、<code class="docutils literal notranslate"><span class="pre">Hashable</span></code>の合成実装を以下の種類のあつらえの型に提供します：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li><span class="enstr">Structures that have only stored properties that conform to the <code class="docutils literal notranslate"><span class="pre">Hashable</span></code> protocol</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Hashable</span></code>プロトコルに準拠する格納プロパティだけを持つ構造体
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Enumerations that have only associated types that conform to the <code class="docutils literal notranslate"><span class="pre">Hashable</span></code> protocol</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Hashable</span></code>プロトコルに準拠する関連型だけを持つ列挙
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Enumerations that have no associated types</span><!--end_enstr-->
<span class="jpstr">
関連型を持たない列挙
</span><!--end_jpstr-->
</li>
</ul>
<p><span class="enstr">To receive a synthesized implementation of <code class="docutils literal notranslate"><span class="pre">hash(into:)</span></code>, declare conformance to <code class="docutils literal notranslate"><span class="pre">Hashable</span></code> in the file that contains the original declaration, without implementing a <code class="docutils literal notranslate"><span class="pre">hash(into:)</span></code> method yourself.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">hash(into:)</span></code>の合成実装を受け取るには、<code class="docutils literal notranslate"><span class="pre">Hashable</span></code>への準拠を本来の宣言を含むファイルにおいて宣言してください、<code class="docutils literal notranslate"><span class="pre">hash(into:)</span></code>メソッドをあなた自身で実装することなしに。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Swift provides a synthesized implementation of <code class="docutils literal notranslate"><span class="pre">Comparable</span></code> for enumerations that don’t have a raw value. If the enumeration has associated types, they must all conform to the <code class="docutils literal notranslate"><span class="pre">Comparable</span></code> protocol. To receive a synthesized implementation of <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, declare conformance to <code class="docutils literal notranslate"><span class="pre">Comparable</span></code> in the file that contains the original enumeration declaration, without implementing a <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> operator yourself. The <code class="docutils literal notranslate"><span class="pre">Comparable</span></code> protocol’s default implementation of <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, and <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> provides the remaining comparison operators.</span><!--end_enstr-->
<span class="jpstr">
スウィフトは、<code class="docutils literal notranslate"><span class="pre">Comparable</span></code>の合成実装を生の値を持たない列挙に提供します。列挙が関連型いくつかを持つならば、それらは全て<code class="docutils literal notranslate"><span class="pre">Comparable</span></code>プロトコルに準拠しなければなりません。<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>の合成実装を受け取るには、<code class="docutils literal notranslate"><span class="pre">Comparable</span></code>への準拠を本来の列挙宣言を含むファイルにおいて宣言してください、<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>演算子をあなた自身で実装することなしに。<code class="docutils literal notranslate"><span class="pre">Comparable</span></code>プロトコルのもつ<code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>、<code class="docutils literal notranslate"><span class="pre">&gt;</span></code>、そして<code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>の省略時の実装は、残りの比較演算子を提供します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The example below defines a <code class="docutils literal notranslate"><span class="pre">SkillLevel</span></code> enumeration with cases for beginners, intermediates, and experts. Experts are additionally ranked by the number of stars they have.</span><!--end_enstr-->
<span class="jpstr">
下の例は、<code class="docutils literal notranslate"><span class="pre">SkillLevel</span></code>列挙を、初心者（beginners）、中級者（intermediates）、そして熟練者（experts）に対する事例（ケース節）で定義します。expertsは加えて、彼らが持つ星の数によってランク付けされます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">enum</span> <span class="nv">SkillLevel</span>: <span class="nc">Comparable</span> {
</li>
<li>    <span class="k">case</span> <span class="nv">beginner</span>
</li>
<li>    <span class="k">case</span> <span class="nv">intermediate</span>
</li>
<li>    <span class="k">case</span> <span class="nv">expert</span>(<span class="nv">stars</span>: <span class="nv">Int</span>)
</li>
<li>}
</li>
<li>
<span class="k">var</span> <span class="nv">levels</span> = [<span class="nv">SkillLevel</span>.<span class="nv">intermediate</span>, <span class="nv">SkillLevel</span>.<span class="nv">beginner</span>,
</li>
<li>              <span class="nv">SkillLevel</span>.<span class="nv">expert</span>(<span class="nv">stars</span>: <span class="m">5</span>), <span class="nv">SkillLevel</span>.<span class="nv">expert</span>(<span class="nv">stars</span>: <span class="m">3</span>)]
</li>
<li>
<span class="k">for</span> <span class="nv">level</span> <span class="k">in</span> <span class="nv">levels</span>.<span class="nv">sorted</span>() {
</li>
<li>    <span class="nv">print</span>(<span class="nv">level</span>)
</li>
<li>}
</li>
<li>
<span class="c">// Prints "beginner"</span>
</li>
<li>
<span class="c">// Prints "intermediate"</span>
</li>
<li>
<span class="c">// Prints "expert(stars: 3)"</span>
</li>
<li>
<span class="c">// Prints "expert(stars: 5)"</span>
</li>
</ol></div></div></div>
</div>
<div class="section" id="ID279">
<h2><span class="enstr">Collections of Protocol Types<a class="headerlink" href="#ID279" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
プロトコル型のコレクション<a class="headerlink" href="#ID279" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">A protocol can be used as the type to be stored in a collection such as an array or a dictionary, as mentioned in <a class="reference internal" href="#ID275"><span class="std std-ref">Protocols as Types</span></a>. This example creates an array of <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code> things:</span><!--end_enstr-->
<span class="jpstr">
<a class="reference internal" href="#ID275"><span class="std std-ref">型としてのプロトコル</span></a>で言及されるように、プロトコルは型として使われることで、コレクション、例えば配列や辞書などに保管されることができます。この例は、<code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>なものの配列をつくります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines"><li>
<span class="k">let</span> <span class="nv">things</span>: [<span class="nc">TextRepresentable</span>] = [<span class="nv">game</span>, <span class="nv">d12</span>, <span class="nv">simonTheHamster</span>]
</li></ol></div></div></div>
<p><span class="enstr">It’s now possible to iterate over the items in the array, and print each item’s textual description:</span><!--end_enstr-->
<span class="jpstr">
現在この配列の項目の上に繰り返して、各項目のもつ説明テキストを出力することが可能です：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">for</span> <span class="nv">thing</span> <span class="k">in</span> <span class="nv">things</span> {
</li>
<li>    <span class="nv">print</span>(<span class="nv">thing</span>.<span class="nv">textualDescription</span>)
</li>
<li>}
</li>
<li>
<span class="c"><span class="enstr">// A game of Snakes and Ladders with 25 squares</span><!--end_enstr--><span class="jpstr">（25ますのヘビとはしごのゲーム）</span><!--end_jpstr--></span>
</li>
<li>
<span class="c"><span class="enstr">// A 12-sided dice</span><!--end_enstr--><span class="jpstr">（ひとつの12面のさいころ遊び）</span><!--end_jpstr--></span>
</li>
<li>
<span class="c"><span class="enstr">// A hamster named Simon</span><!--end_enstr--><span class="jpstr">（サイモンという名前のハムスター）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">Note that the <code class="docutils literal notranslate"><span class="pre">thing</span></code> constant is of type <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>. It’s not of type <code class="docutils literal notranslate"><span class="pre">Dice</span></code>, or <code class="docutils literal notranslate"><span class="pre">DiceGame</span></code>, or <code class="docutils literal notranslate"><span class="pre">Hamster</span></code>, even if the actual instance behind the scenes is of one of those types. Nonetheless, because it’s of type <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>, and anything that’s <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code> is known to have a <code class="docutils literal notranslate"><span class="pre">textualDescription</span></code> property, it’s safe to access <code class="docutils literal notranslate"><span class="pre">thing.textualDescription</span></code> each time through the loop.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">thing</span></code>定数が型<code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>であることに注意してください。それは型<code class="docutils literal notranslate"><span class="pre">Dice</span></code>、または<code class="docutils literal notranslate"><span class="pre">DiceGame</span></code>、または<code class="docutils literal notranslate"><span class="pre">Hamster</span></code>ではありません、たとえ舞台裏の実際のインスタンスがそれらの型のうちの１つであるとしてもです。それでもなお、それが<code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>型であり、そして、<code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>であるもの全てが<code class="docutils literal notranslate"><span class="pre">textualDescription</span></code>プロパティを持つと知られているので、それがループの各回で<code class="docutils literal notranslate"><span class="pre">thing.textualDescription</span></code>にアクセスするのは安全です。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID280">
<h2><span class="enstr">Protocol Inheritance<a class="headerlink" href="#ID280" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
プロトコル継承<a class="headerlink" href="#ID280" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">A protocol can <em>inherit</em> one or more other protocols and can add further requirements on top of the requirements it inherits. The syntax for protocol inheritance is similar to the syntax for class inheritance, but with the option to list multiple inherited protocols, separated by commas:</span><!--end_enstr-->
<span class="jpstr">
プロトコルは、１つ以上の他のプロトコルを<em>継承する</em>ことができて、それが継承する要件の上に、更なる要件を加えることができます。プロトコル継承のための構文は、クラス継承のための構文に似ています、しかし複数の継承されたプロトコルをコンマで区切って列記する選択肢を持ちます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">protocol</span> <span class="nv">InheritingProtocol</span>: <span class="nc">SomeProtocol</span>, <span class="nc">AnotherProtocol</span> {
</li>
<li>    <span class="c"><span class="enstr">// protocol definition goes here</span><!--end_enstr--><span class="jpstr">（プロトコル定義が、ここにきます）</span><!--end_jpstr--></span>
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">Here’s an example of a protocol that inherits the <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code> protocol from above:</span><!--end_enstr-->
<span class="jpstr">
上の<code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>プロトコルを継承するプロトコルの例は、ここにあります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">protocol</span> <span class="nv">PrettyTextRepresentable</span>: <span class="nc">TextRepresentable</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">prettyTextualDescription</span>: <span class="nc">String</span> { <span class="k">get</span> }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">This example defines a new protocol, <code class="docutils literal notranslate"><span class="pre">PrettyTextRepresentable</span></code>, which inherits from <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>. Anything that adopts <code class="docutils literal notranslate"><span class="pre">PrettyTextRepresentable</span></code> must satisfy all of the requirements enforced by <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>, <em>plus</em> the additional requirements enforced by <code class="docutils literal notranslate"><span class="pre">PrettyTextRepresentable</span></code>. In this example, <code class="docutils literal notranslate"><span class="pre">PrettyTextRepresentable</span></code> adds a single requirement to provide a gettable property called <code class="docutils literal notranslate"><span class="pre">prettyTextualDescription</span></code> that returns a <code class="docutils literal notranslate"><span class="pre">String</span></code>.</span><!--end_enstr-->
<span class="jpstr">
この例は、ある新しいプロトコル、<code class="docutils literal notranslate"><span class="pre">PrettyTextRepresentable</span></code>を定義します、それは、<code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>から継承を受けます。<code class="docutils literal notranslate"><span class="pre">PrettyTextRepresentable</span></code>を採用するどんなものでも、<code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>によって強制される要件の全て、それに<em>加えて</em><code class="docutils literal notranslate"><span class="pre">PrettyTextRepresentable</span></code>によって強制される追加の要件を満たさなければなりません。この例では、<code class="docutils literal notranslate"><span class="pre">PrettyTextRepresentable</span></code>は１つの要件を加えて、<code class="docutils literal notranslate"><span class="pre">String</span></code>を返す<code class="docutils literal notranslate"><span class="pre">prettyTextualDescription</span></code>と呼ばれる取得可能なプロパティを提供するようにします。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">SnakesAndLadders</span></code> class can be extended to adopt and conform to <code class="docutils literal notranslate"><span class="pre">PrettyTextRepresentable</span></code>:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">SnakesAndLadders</span></code>クラスは、拡張されることで<code class="docutils literal notranslate"><span class="pre">PrettyTextRepresentable</span></code>を採用して準拠するようにできます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">extension</span> <span class="nc">SnakesAndLadders</span>: <span class="nc">PrettyTextRepresentable</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">prettyTextualDescription</span>: <span class="nc">String</span> {
</li>
<li>        <span class="k">var</span> <span class="nv">output</span> = <span class="nv">textualDescription</span> + <span class="s">":\n"</span>
</li>
<li>        <span class="k">for</span> <span class="nv">index</span> <span class="k">in</span> <span class="m">1</span>...<span class="nv">finalSquare</span> {
</li>
<li>            <span class="k">switch</span> <span class="nv">board</span>[<span class="nv">index</span>] {
</li>
<li>            <span class="k">case</span> <span class="k">let</span> <span class="nv">ladder</span> <span class="k">where</span> <span class="nv">ladder</span> &gt; <span class="m">0</span>:
</li>
<li>                <span class="nv">output</span> += <span class="s">"▲ "</span>
</li>
<li>            <span class="k">case</span> <span class="k">let</span> <span class="nv">snake</span> <span class="k">where</span> <span class="nv">snake</span> &lt; <span class="m">0</span>:
</li>
<li>                <span class="nv">output</span> += <span class="s">"▼ "</span>
</li>
<li>            <span class="k">default</span>:
</li>
<li>                <span class="nv">output</span> += <span class="s">"○ "</span>
</li>
<li>            }
</li>
<li>        }
</li>
<li>        <span class="k">return</span> <span class="nv">output</span>
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">This extension states that it adopts the <code class="docutils literal notranslate"><span class="pre">PrettyTextRepresentable</span></code> protocol and provides an implementation of the <code class="docutils literal notranslate"><span class="pre">prettyTextualDescription</span></code> property for the <code class="docutils literal notranslate"><span class="pre">SnakesAndLadders</span></code> type. Anything that’s <code class="docutils literal notranslate"><span class="pre">PrettyTextRepresentable</span></code> must also be <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>, and so the implementation of <code class="docutils literal notranslate"><span class="pre">prettyTextualDescription</span></code> starts by accessing the <code class="docutils literal notranslate"><span class="pre">textualDescription</span></code> property from the <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code> protocol to begin an output string. It appends a colon and a line break, and uses this as the start of its pretty text representation. It then iterates through the array of board squares, and appends a geometric shape to represent the contents of each square:</span><!--end_enstr-->
<span class="jpstr">
この拡張が述べるのは、それが<code class="docutils literal notranslate"><span class="pre">PrettyTextRepresentable</span></code>プロトコルを採用して<code class="docutils literal notranslate"><span class="pre">prettyTextualDescription</span></code>プロパティの実装を<code class="docutils literal notranslate"><span class="pre">SnakesAndLadders</span></code>型に提供することです。<code class="docutils literal notranslate"><span class="pre">PrettyTextRepresentable</span></code>であるものは何でも、また<code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>でなければなりません、なので<code class="docutils literal notranslate"><span class="pre">prettyTextualDescription</span></code>の実装は出力文字列を開始するために<code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>プロトコルからの<code class="docutils literal notranslate"><span class="pre">textualDescription</span></code>プロパティにアクセスすることによって始まります。それはコロンと改行を追加します、そしてそれのきれいなテキスト表示のスタートとして、これを使います。それは、それからボードの正方形の配列の端から端まで繰り返して、ある幾何学形を各正方形の内容を表わすために追加します：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li><span class="enstr">If the square’s value is greater than <code class="docutils literal notranslate"><span class="pre">0</span></code>, it’s the base of a ladder, and is represented by <code class="docutils literal notranslate"><span class="pre">▲</span></code>.</span><!--end_enstr-->
<span class="jpstr">
正方形の値が<code class="docutils literal notranslate"><span class="pre">0</span></code>より大きいならば、それははしごの基部であって、<code class="docutils literal notranslate"><span class="pre">▲</span></code>によって表されます。
</span><!--end_jpstr-->
</li>
<li><span class="enstr">If the square’s value is less than <code class="docutils literal notranslate"><span class="pre">0</span></code>, it’s the head of a snake, and is represented by <code class="docutils literal notranslate"><span class="pre">▼</span></code>.</span><!--end_enstr-->
<span class="jpstr">
正方形の値が<code class="docutils literal notranslate"><span class="pre">0</span></code>より小さいならば、それはヘビの頭であって、<code class="docutils literal notranslate"><span class="pre">▼</span></code>によって表されます。
</span><!--end_jpstr-->
</li>
<li><span class="enstr">Otherwise, the square’s value is <code class="docutils literal notranslate"><span class="pre">0</span></code>, and it’s a “free” square, represented by <code class="docutils literal notranslate"><span class="pre">○</span></code>.</span><!--end_enstr-->
<span class="jpstr">
一方、正方形の値は<code class="docutils literal notranslate"><span class="pre">0</span></code>ならば、それは「自由」な正方形であって、<code class="docutils literal notranslate"><span class="pre">○</span></code>によって表されます。
</span><!--end_jpstr-->
</li>
</ul>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">prettyTextualDescription</span></code> property can now be used to print a pretty text description of any <code class="docutils literal notranslate"><span class="pre">SnakesAndLadders</span></code> instance:</span><!--end_enstr-->
<span class="jpstr">
この<code class="docutils literal notranslate"><span class="pre">prettyTextualDescription</span></code>プロパティは、現在あらゆる<code class="docutils literal notranslate"><span class="pre">SnakesAndLadders</span></code>インスタンスのきれいなテキスト解説を出力するために使われることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="nv">print</span>(<span class="nv">game</span>.<span class="nv">prettyTextualDescription</span>)
</li>
<li>
<span class="c"><span class="enstr">// A game of Snakes and Ladders with 25 squares:</span><!--end_enstr--><span class="jpstr">（25ますのヘビとはしごのゲーム：）</span><!--end_jpstr--></span>
</li>
<li>
<span class="c">// ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○</span>
</li>
</ol></div></div></div>
</div>
<div class="section" id="ID281">
<h2><span class="enstr">Class-Only Protocols<a class="headerlink" href="#ID281" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
クラス専用プロトコル<a class="headerlink" href="#ID281" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">You can limit protocol adoption to class types (and not structures or enumerations) by adding the <code class="docutils literal notranslate"><span class="pre">AnyObject</span></code> protocol to a protocol’s inheritance list.</span><!--end_enstr-->
<span class="jpstr">
あなたは、プロトコル採用をクラス型に制限する（つまり構造体や列挙で採用しない）ことが<code class="docutils literal notranslate"><span class="pre">AnyObject</span></code>プロトコルをプロトコルのもつ継承リストに加えることによって可能です。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">protocol</span> <span class="nv">SomeClassOnlyProtocol</span>: <span class="nc">AnyObject</span>, <span class="nc">SomeInheritedProtocol</span> {
</li>
<li>    <span class="c"><span class="enstr">// class-only protocol definition goes here</span><!--end_enstr--><span class="jpstr">（クラス専用プロトコル定義が、ここにきます）</span><!--end_jpstr--></span>
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">In the example above, <code class="docutils literal notranslate"><span class="pre">SomeClassOnlyProtocol</span></code> can only be adopted by class types. It’s a compile-time error to write a structure or enumeration definition that tries to adopt <code class="docutils literal notranslate"><span class="pre">SomeClassOnlyProtocol</span></code>.</span><!--end_enstr-->
<span class="jpstr">
上の例で、<code class="docutils literal notranslate"><span class="pre">SomeClassOnlyProtocol</span></code>はクラス型によってのみ採用されることができます。<code class="docutils literal notranslate"><span class="pre">SomeClassOnlyProtocol</span></code>を採用しようと試みる構造体や列挙定義を書くことは、コンパイル時エラーになります。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Use a class-only protocol when the behavior defined by that protocol’s requirements assumes or requires that a conforming type has reference semantics rather than value semantics. For more about reference and value semantics, see <a class="reference internal" href="ClassesAndStructures.html#ID88"><span class="std std-ref">Structures and Enumerations Are Value Types</span></a> and <a class="reference internal" href="ClassesAndStructures.html#ID89"><span class="std std-ref">Classes Are Reference Types</span></a>.</span><!--end_enstr-->
<span class="jpstr">
クラス専用プロトコルを、そのプロトコルの要件によって定義される挙動が想定されるまたは必要とされる時、準拠する型が値意味論ではなく参照意味論を持つ時に、使ってください。参照および値意味論に関する詳細は、<a class="reference internal" href="ClassesAndStructures.html#ID88"><span class="std std-ref">構造体と列挙は値型です</span></a>と<a class="reference internal" href="ClassesAndStructures.html#ID89"><span class="std std-ref">クラスは、参照型です</span></a>を見てください。
</span><!--end_jpstr-->
</p>
</div>
</div>
<div class="section" id="ID282">
<h2><span class="enstr">Protocol Composition<a class="headerlink" href="#ID282" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
プロトコル合成<a class="headerlink" href="#ID282" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">It can be useful to require a type to conform to multiple protocols at the same time. You can combine multiple protocols into a single requirement with a <em>protocol composition</em>. Protocol compositions behave as if you defined a temporary local protocol that has the combined requirements of all protocols in the composition. Protocol compositions don’t define any new protocol types.</span><!--end_enstr-->
<span class="jpstr">
ある型に複数のプロトコルに一時に従うことを要求することは、役に立つことがありえます。あなたは、<em>プロトコル合成</em>を使って複数のプロトコルを１つの要件に結合することができます。プロトコル合成は、あなたが全てのプロトコルの要件を結合したものをその合成物の中に持っている一時的なローカルプロトコルを定義したかのように振る舞います。プロトコル合成は、何ら新しいプロトコル型を定義しません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Protocol compositions have the form <code class="docutils literal notranslate"><span class="pre">SomeProtocol</span> <span class="pre">&amp;</span> <span class="pre">AnotherProtocol</span></code>. You can list as many protocols as you need, separating them with ampersands (<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>). In addition to its list of protocols, a protocol composition can also contain one class type, which you can use to specify a required superclass.</span><!--end_enstr-->
<span class="jpstr">
プロトコル合成は、形式<code class="docutils literal notranslate"><span class="pre">SomeProtocol</span> <span class="pre">&amp;</span> <span class="pre">AnotherProtocol</span></code>を持ちます。あなたは、あなたが必要とするだけ多くのプロトコルを、それらをアンパサンド（<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>）で隔てて列記できます。いくつかのプロトコルからなるそれのリストに加えて、あるプロトコル合成はまた１つのクラス型を含むことができます、それはあなたが必要とされるスーパークラスを指定するのに使用します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Here’s an example that combines two protocols called <code class="docutils literal notranslate"><span class="pre">Named</span></code> and <code class="docutils literal notranslate"><span class="pre">Aged</span></code> into a single protocol composition requirement on a function parameter:</span><!--end_enstr-->
<span class="jpstr">
ここに、関数パラメータ上で<code class="docutils literal notranslate"><span class="pre">Named</span></code>と<code class="docutils literal notranslate"><span class="pre">Aged</span></code>と呼ばれる２つのプロトコルを１つのプロトコル合成要件に結合する例があります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">protocol</span> <span class="nv">Named</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">name</span>: <span class="nc">String</span> { <span class="k">get</span> }
</li>
<li>}
</li>
<li>
<span class="k">protocol</span> <span class="nv">Aged</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">age</span>: <span class="nc">Int</span> { <span class="k">get</span> }
</li>
<li>}
</li>
<li>
<span class="k">struct</span> <span class="nv">Person</span>: <span class="nc">Named</span>, <span class="nc">Aged</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">name</span>: <span class="nc">String</span>
</li>
<li>    <span class="k">var</span> <span class="nv">age</span>: <span class="nc">Int</span>
</li>
<li>}
</li>
<li>
<span class="k">func</span> <span class="nv">wishHappyBirthday</span>(<span class="nv">to</span> <span class="nv">celebrator</span>: <span class="nc">Named</span> &amp; <span class="nc">Aged</span>) {
</li>
<li>    <span class="nv">print</span>(<span class="s">"Happy birthday, </span>\<span class="p">(</span><span class="nv">celebrator</span>.<span class="nv">name</span><span class="p">)</span><span class="s">, you're </span>\<span class="p">(</span><span class="nv">celebrator</span>.<span class="nv">age</span><span class="p">)</span><span class="s">!"</span>)
</li>
<li>}
</li>
<li>
<span class="k">let</span> <span class="nv">birthdayPerson</span> = <span class="nv">Person</span>(<span class="nv">name</span>: <span class="s">"Malcolm"</span>, <span class="nv">age</span>: <span class="m">21</span>)
</li>
<li>
<span class="nv">wishHappyBirthday</span>(<span class="nv">to</span>: <span class="nv">birthdayPerson</span>)
</li>
<li>
<span class="c"><span class="enstr">// Prints "Happy birthday, Malcolm, you're 21!"</span><!--end_enstr--><span class="jpstr">（「誕生日おめでとうマルコム、あなたは21です！」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">In this example, the <code class="docutils literal notranslate"><span class="pre">Named</span></code> protocol has a single requirement for a gettable <code class="docutils literal notranslate"><span class="pre">String</span></code> property called <code class="docutils literal notranslate"><span class="pre">name</span></code>. The <code class="docutils literal notranslate"><span class="pre">Aged</span></code> protocol has a single requirement for a gettable <code class="docutils literal notranslate"><span class="pre">Int</span></code> property called <code class="docutils literal notranslate"><span class="pre">age</span></code>. Both protocols are adopted by a structure called <code class="docutils literal notranslate"><span class="pre">Person</span></code>.</span><!--end_enstr-->
<span class="jpstr">
この例において、<code class="docutils literal notranslate"><span class="pre">Named</span></code>プロトコルは、取得可能な<code class="docutils literal notranslate"><span class="pre">String</span></code>プロパティで<code class="docutils literal notranslate"><span class="pre">name</span></code>と呼ばれるものに対するただ１つの要件を持ちます。<code class="docutils literal notranslate"><span class="pre">Aged</span></code>プロトコルは、取得可能な<code class="docutils literal notranslate"><span class="pre">Int</span></code>プロパティで<code class="docutils literal notranslate"><span class="pre">age</span></code>と呼ばれるものに対するただ１つの要件を持ちます。両方のプロトコルは、<code class="docutils literal notranslate"><span class="pre">Person</span></code>と呼ばれる構造体によって採用されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The example also defines a <code class="docutils literal notranslate"><span class="pre">wishHappyBirthday(to:)</span></code> function. The type of the <code class="docutils literal notranslate"><span class="pre">celebrator</span></code> parameter is <code class="docutils literal notranslate"><span class="pre">Named</span> <span class="pre">&amp;</span> <span class="pre">Aged</span></code>, which means “any type that conforms to both the <code class="docutils literal notranslate"><span class="pre">Named</span></code> and <code class="docutils literal notranslate"><span class="pre">Aged</span></code> protocols.” It doesn’t matter which specific type is passed to the function, as long as it conforms to both of the required protocols.</span><!--end_enstr-->
<span class="jpstr">
例はまた、<code class="docutils literal notranslate"><span class="pre">wishHappyBirthday(to:)</span></code>関数を定義します。<code class="docutils literal notranslate"><span class="pre">celebrator</span></code>パラメータの型は<code class="docutils literal notranslate"><span class="pre">Named</span> <span class="pre">&amp;</span> <span class="pre">Aged</span></code>です、それは「<code class="docutils literal notranslate"><span class="pre">Named</span></code>と<code class="docutils literal notranslate"><span class="pre">Aged</span></code>プロトコルの両方に準拠する何らかの型」を意味します。どのような具体的な型が関数へ渡されるかは問題ではありません、それが必須プロトコルの両方に準拠する限りは。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The example then creates a new <code class="docutils literal notranslate"><span class="pre">Person</span></code> instance called <code class="docutils literal notranslate"><span class="pre">birthdayPerson</span></code> and passes this new instance to the <code class="docutils literal notranslate"><span class="pre">wishHappyBirthday(to:)</span></code> function. Because <code class="docutils literal notranslate"><span class="pre">Person</span></code> conforms to both protocols, this call is valid, and the <code class="docutils literal notranslate"><span class="pre">wishHappyBirthday(to:)</span></code> function can print its birthday greeting.</span><!--end_enstr-->
<span class="jpstr">
この例は、それから<code class="docutils literal notranslate"><span class="pre">birthdayPerson</span></code>と呼ばれる新しい<code class="docutils literal notranslate"><span class="pre">Person</span></code>インスタンスをつくって、この新しいインスタンスを<code class="docutils literal notranslate"><span class="pre">wishHappyBirthday(to:)</span></code>関数に渡します。<code class="docutils literal notranslate"><span class="pre">Person</span></code>が両方のプロトコルに準拠するので、これは有効な呼び出しです、それで<code class="docutils literal notranslate"><span class="pre">wishHappyBirthday(to:)</span></code>関数はその誕生日のお祝いを出力できます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Here’s an example that combines the <code class="docutils literal notranslate"><span class="pre">Named</span></code> protocol from the previous example with a <code class="docutils literal notranslate"><span class="pre">Location</span></code> class:</span><!--end_enstr-->
<span class="jpstr">
ここに１つの例があります、それは前の例からの<code class="docutils literal notranslate"><span class="pre">Named</span></code>プロトコルを<code class="docutils literal notranslate"><span class="pre">Location</span></code>クラスと結び付けます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">class</span> <span class="nv">Location</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">latitude</span>: <span class="nc">Double</span>
</li>
<li>    <span class="k">var</span> <span class="nv">longitude</span>: <span class="nc">Double</span>
</li>
<li>    <span class="k">init</span>(<span class="nv">latitude</span>: <span class="nc">Double</span>, <span class="nv">longitude</span>: <span class="nc">Double</span>) {
</li>
<li>        <span class="k">self</span>.<span class="nv">latitude</span> = <span class="nv">latitude</span>
</li>
<li>        <span class="k">self</span>.<span class="nv">longitude</span> = <span class="nv">longitude</span>
</li>
<li>    }
</li>
<li>}
</li>
<li>
<span class="k">class</span> <span class="nv">City</span>: <span class="nc">Location</span>, <span class="nc">Named</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">name</span>: <span class="nc">String</span>
</li>
<li>    <span class="k">init</span>(<span class="nv">name</span>: <span class="nc">String</span>, <span class="nv">latitude</span>: <span class="nc">Double</span>, <span class="nv">longitude</span>: <span class="nc">Double</span>) {
</li>
<li>        <span class="k">self</span>.<span class="nv">name</span> = <span class="nv">name</span>
</li>
<li>        <span class="k">super</span>.<span class="nv">init</span>(<span class="nv">latitude</span>: <span class="nv">latitude</span>, <span class="nv">longitude</span>: <span class="nv">longitude</span>)
</li>
<li>    }
</li>
<li>}
</li>
<li>
<span class="k">func</span> <span class="nv">beginConcert</span>(<span class="nv">in</span> <span class="nv">location</span>: <span class="nc">Location</span> &amp; <span class="nc">Named</span>) {
</li>
<li>    <span class="nv">print</span>(<span class="s">"Hello, </span>\<span class="p">(</span><span class="nv">location</span>.<span class="nv">name</span><span class="p">)</span><span class="s">!"</span>)
</li>
<li>}
</li>
<li>
</li>
<li>
<span class="k">let</span> <span class="nv">seattle</span> = <span class="nv">City</span>(<span class="nv">name</span>: <span class="s">"Seattle"</span>, <span class="nv">latitude</span>: <span class="m">47.6</span>, <span class="nv">longitude</span>: <span class="m">-122.3</span>)
</li>
<li>
<span class="nv">beginConcert</span>(<span class="nv">in</span>: <span class="nv">seattle</span>)
</li>
<li>
<span class="c">// Prints "Hello, Seattle!"</span>
</li>
</ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">beginConcert(in:)</span></code> function takes a parameter of type <code class="docutils literal notranslate"><span class="pre">Location</span> <span class="pre">&amp;</span> <span class="pre">Named</span></code>, which means “any type that’s a subclass of <code class="docutils literal notranslate"><span class="pre">Location</span></code> and that conforms to the <code class="docutils literal notranslate"><span class="pre">Named</span></code> protocol.” In this case, <code class="docutils literal notranslate"><span class="pre">City</span></code> satisfies both requirements.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">beginConcert(in:)</span></code>関数は、型<code class="docutils literal notranslate"><span class="pre">Location</span> <span class="pre">&amp;</span> <span class="pre">Named</span></code>のパラメータを１つとります、それは「<code class="docutils literal notranslate"><span class="pre">Location</span></code>のサブクラスであり、<code class="docutils literal notranslate"><span class="pre">Named</span></code>プロトコルに準拠する何らかの型」を意味します。この場合では、<code class="docutils literal notranslate"><span class="pre">City</span></code>は両方の要件を満たします。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Passing <code class="docutils literal notranslate"><span class="pre">birthdayPerson</span></code> to the <code class="docutils literal notranslate"><span class="pre">beginConcert(in:)</span></code> function is invalid because <code class="docutils literal notranslate"><span class="pre">Person</span></code> isn’t a subclass of <code class="docutils literal notranslate"><span class="pre">Location</span></code>. Likewise, if you made a subclass of <code class="docutils literal notranslate"><span class="pre">Location</span></code> that didn’t conform to the <code class="docutils literal notranslate"><span class="pre">Named</span></code> protocol, calling <code class="docutils literal notranslate"><span class="pre">beginConcert(in:)</span></code> with an instance of that type is also invalid.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">birthdayPerson</span></code>を<code class="docutils literal notranslate"><span class="pre">beginConcert(in:)</span></code>関数に渡すことは無効です、なぜなら<code class="docutils literal notranslate"><span class="pre">Person</span></code>は<code class="docutils literal notranslate"><span class="pre">Location</span></code>のサブクラスではないからです。同様に、あなたが<code class="docutils literal notranslate"><span class="pre">Location</span></code>のサブクラスで<code class="docutils literal notranslate"><span class="pre">Named</span></code>プロトコルに準拠しないものを作成したならば、<code class="docutils literal notranslate"><span class="pre">beginConcert(in:)</span></code>をその型のインスタンスで呼び出すことはまた無効です。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID283">
<h2><span class="enstr">Checking for Protocol Conformance<a class="headerlink" href="#ID283" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
プロトコル準拠の確認<a class="headerlink" href="#ID283" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">You can use the <code class="docutils literal notranslate"><span class="pre">is</span></code> and <code class="docutils literal notranslate"><span class="pre">as</span></code> operators described in <a class="reference internal" href="TypeCasting.html"><span class="doc">Type Casting</span></a> to check for protocol conformance, and to cast to a specific protocol. Checking for and casting to a protocol follows exactly the same syntax as checking for and casting to a type:</span><!--end_enstr-->
<span class="jpstr">
あなたは、<a class="reference internal" href="TypeCasting.html"><span class="doc">型キャスト</span></a>で記述される<code class="docutils literal notranslate"><span class="pre">is</span></code>と<code class="docutils literal notranslate"><span class="pre">as</span></code>演算子を特定のプロトコルへキャストするために使うことができます。あるプロトコルについて調べたりそれにキャストすることは、ある型について調べたりキャストするのと正確に同じ構文に従います：
</span><!--end_jpstr-->
</p>
<ul class="simple">
<li><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">is</span></code> operator returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if an instance conforms to a protocol and returns <code class="docutils literal notranslate"><span class="pre">false</span></code> if it doesn’t.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">is</span></code>演算子は、あるインスタンスがプロトコルに準拠するならば<code class="docutils literal notranslate"><span class="pre">true</span></code>を返して、それがそうしないならば<code class="docutils literal notranslate"><span class="pre">false</span></code>を返します。
</span><!--end_jpstr-->
</li>
<li><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">as?</span></code> version of the downcast operator returns an optional value of the protocol’s type, and this value is <code class="docutils literal notranslate"><span class="pre">nil</span></code> if the instance doesn’t conform to that protocol.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">as?</span></code>版のダウンキャスト演算子は、そのプロトコルの型のオプショナルの値を返します、そしてインスタンスがそのプロトコルに準拠しないならばその値は<code class="docutils literal notranslate"><span class="pre">nil</span></code>です。
</span><!--end_jpstr-->
</li>
<li><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">as!</span></code> version of the downcast operator forces the downcast to the protocol type and triggers a runtime error if the downcast doesn’t succeed.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">as!</span></code>版のダウンキャスト演算子は、そのプロトコル型へのダウンキャストを強制して、ダウンキャストが成功しなかったならば実行時エラーの引き金を引きます。
</span><!--end_jpstr-->
</li>
</ul>
<p><span class="enstr">This example defines a protocol called <code class="docutils literal notranslate"><span class="pre">HasArea</span></code>, with a single property requirement of a gettable <code class="docutils literal notranslate"><span class="pre">Double</span></code> property called <code class="docutils literal notranslate"><span class="pre">area</span></code>:</span><!--end_enstr-->
<span class="jpstr">
この例は、<code class="docutils literal notranslate"><span class="pre">area</span></code>と呼ばれる取得可能な<code class="docutils literal notranslate"><span class="pre">Double</span></code>プロパティである１つだけのプロパティ要件をもつ、<code class="docutils literal notranslate"><span class="pre">HasArea</span></code>と呼ばれるプロトコルを定義します：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">protocol</span> <span class="nv">HasArea</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">area</span>: <span class="nc">Double</span> { <span class="k">get</span> }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">Here are two classes, <code class="docutils literal notranslate"><span class="pre">Circle</span></code> and <code class="docutils literal notranslate"><span class="pre">Country</span></code>, both of which conform to the <code class="docutils literal notranslate"><span class="pre">HasArea</span></code> protocol:</span><!--end_enstr-->
<span class="jpstr">
その両方とも<code class="docutils literal notranslate"><span class="pre">HasArea</span></code>プロトコルに従う２つのクラス、<code class="docutils literal notranslate"><span class="pre">Circle</span></code>と<code class="docutils literal notranslate"><span class="pre">Country</span></code>が、ここにあります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">class</span> <span class="nv">Circle</span>: <span class="nc">HasArea</span> {
</li>
<li>    <span class="k">let</span> <span class="nv">pi</span> = <span class="m">3.1415927</span>
</li>
<li>    <span class="k">var</span> <span class="nv">radius</span>: <span class="nc">Double</span>
</li>
<li>    <span class="k">var</span> <span class="nv">area</span>: <span class="nc">Double</span> { <span class="k">return</span> <span class="nv">pi</span> * <span class="nv">radius</span> * <span class="nv">radius</span> }
</li>
<li>    <span class="k">init</span>(<span class="nv">radius</span>: <span class="nc">Double</span>) { <span class="k">self</span>.<span class="nv">radius</span> = <span class="nv">radius</span> }
</li>
<li>}
</li>
<li>
<span class="k">class</span> <span class="nv">Country</span>: <span class="nc">HasArea</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">area</span>: <span class="nc">Double</span>
</li>
<li>    <span class="k">init</span>(<span class="nv">area</span>: <span class="nc">Double</span>) { <span class="k">self</span>.<span class="nv">area</span> = <span class="nv">area</span> }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">Circle</span></code> class implements the <code class="docutils literal notranslate"><span class="pre">area</span></code> property requirement as a computed property, based on a stored <code class="docutils literal notranslate"><span class="pre">radius</span></code> property. The <code class="docutils literal notranslate"><span class="pre">Country</span></code> class implements the <code class="docutils literal notranslate"><span class="pre">area</span></code> requirement directly as a stored property. Both classes correctly conform to the <code class="docutils literal notranslate"><span class="pre">HasArea</span></code> protocol.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Circle</span></code>クラスは<code class="docutils literal notranslate"><span class="pre">area</span></code>プロパティ要件を、格納<code class="docutils literal notranslate"><span class="pre">radius</span></code>プロパティに基づいて計算プロパティとして、満たします。<code class="docutils literal notranslate"><span class="pre">Country</span></code>クラスは、<code class="docutils literal notranslate"><span class="pre">area</span></code>要件を格納プロパティとして直接に満たします。両方のクラスは、正しく<code class="docutils literal notranslate"><span class="pre">HasArea</span></code>プロトコルに従います。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Here’s a class called <code class="docutils literal notranslate"><span class="pre">Animal</span></code>, which doesn’t conform to the <code class="docutils literal notranslate"><span class="pre">HasArea</span></code> protocol:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">HasArea</span></code>プロトコルに従わない<code class="docutils literal notranslate"><span class="pre">Animal</span></code>と呼ばれるクラスが、ここにあります：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">class</span> <span class="nv">Animal</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">legs</span>: <span class="nc">Int</span>
</li>
<li>    <span class="k">init</span>(<span class="nv">legs</span>: <span class="nc">Int</span>) { <span class="k">self</span>.<span class="nv">legs</span> = <span class="nv">legs</span> }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">Circle</span></code>, <code class="docutils literal notranslate"><span class="pre">Country</span></code> and <code class="docutils literal notranslate"><span class="pre">Animal</span></code> classes don’t have a shared base class. Nonetheless, they’re all classes, and so instances of all three types can be used to initialize an array that stores values of type <code class="docutils literal notranslate"><span class="pre">AnyObject</span></code>:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Circle</span></code>、<code class="docutils literal notranslate"><span class="pre">Country</span></code>と<code class="docutils literal notranslate"><span class="pre">Animal</span></code>クラスには、共有の基盤クラスがありません。それでもなお、それらは全てクラスです、なので、３つの型全てのインスタンスは、型<code class="docutils literal notranslate"><span class="pre">AnyObject</span></code>の値を格納するある配列を初期化するために使用できます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">objects</span>: [<span class="nc">AnyObject</span>] = [
</li>
<li>    <span class="nv">Circle</span>(<span class="nv">radius</span>: <span class="m">2.0</span>),
</li>
<li>    <span class="nv">Country</span>(<span class="nv">area</span>: <span class="m">243_610</span>),
</li>
<li>    <span class="nv">Animal</span>(<span class="nv">legs</span>: <span class="m">4</span>)
</li>
<li>]
</li>
</ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">objects</span></code> array is initialized with an array literal containing a <code class="docutils literal notranslate"><span class="pre">Circle</span></code> instance with a radius of 2 units; a <code class="docutils literal notranslate"><span class="pre">Country</span></code> instance initialized with the surface area of the United Kingdom in square kilometers; and an <code class="docutils literal notranslate"><span class="pre">Animal</span></code> instance with four legs.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">objects</span></code>配列は、単位２の半径をもつ<code class="docutils literal notranslate"><span class="pre">Circle</span></code>インスタンスを含んでいる配列リテラル；平方キロメートルでの英国の面積で初期化される<code class="docutils literal notranslate"><span class="pre">Country</span></code>インスタンス；そして、４本脚の<code class="docutils literal notranslate"><span class="pre">Animal</span></code>インスタンス；を含んでいる配列リテラルで初期化されます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">objects</span></code> array can now be iterated, and each object in the array can be checked to see if it conforms to the <code class="docutils literal notranslate"><span class="pre">HasArea</span></code> protocol:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">objects</span></code>配列は、今や繰り返されることができます、そして配列の各オブジェクトはそれが<code class="docutils literal notranslate"><span class="pre">HasArea</span></code>プロトコルに従うかどうかを確認されることができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">for</span> <span class="nv">object</span> <span class="k">in</span> <span class="nv">objects</span> {
</li>
<li>    <span class="k">if</span> <span class="k">let</span> <span class="nv">objectWithArea</span> = <span class="nv">object</span> <span class="k">as</span>? <span class="nc">HasArea</span> {
</li>
<li>        <span class="nv">print</span>(<span class="s">"Area is </span>\<span class="p">(</span><span class="nv">objectWithArea</span>.<span class="nv">area</span><span class="p">)</span><span class="s">"</span>)
</li>
<li>    } <span class="k">else</span> {
</li>
<li>        <span class="nv">print</span>(<span class="s">"Something that doesn't have an area"</span>)
</li>
<li>    }
</li>
<li>}
</li>
<li>
<span class="c"><span class="enstr">// Area is 12.5663708</span><!--end_enstr--><span class="jpstr">（面積は、12.5663708です）</span><!--end_jpstr--></span>
</li>
<li>
<span class="c"><span class="enstr">// Area is 243610.0</span><!--end_enstr--><span class="jpstr">（面積は、243610.0です）</span><!--end_jpstr--></span>
</li>
<li>
<span class="c"><span class="enstr">// Something that doesn't have an area</span><!--end_enstr--><span class="jpstr">（面積を持たない何か）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">Whenever an object in the array conforms to the <code class="docutils literal notranslate"><span class="pre">HasArea</span></code> protocol, the optional value returned by the <code class="docutils literal notranslate"><span class="pre">as?</span></code> operator is unwrapped with optional binding into a constant called <code class="docutils literal notranslate"><span class="pre">objectWithArea</span></code>. The <code class="docutils literal notranslate"><span class="pre">objectWithArea</span></code> constant is known to be of type <code class="docutils literal notranslate"><span class="pre">HasArea</span></code>, and so its <code class="docutils literal notranslate"><span class="pre">area</span></code> property can be accessed and printed in a type-safe way.</span><!--end_enstr-->
<span class="jpstr">
配列のオブジェクトが<code class="docutils literal notranslate"><span class="pre">HasArea</span></code>プロトコルに準拠するときはいつでも、<code class="docutils literal notranslate"><span class="pre">as?</span></code>演算子によって返されるオプショナルの値は、オプショナル束縛によって<code class="docutils literal notranslate"><span class="pre">objectWithArea</span></code>と呼ばれる定数へとアンラップされます。定数の<code class="docutils literal notranslate"><span class="pre">objectWithArea</span></code>は、型<code class="docutils literal notranslate"><span class="pre">HasArea</span></code>であるということを知られています、なので、その<code class="docutils literal notranslate"><span class="pre">area</span></code>プロパティは型安全な方法でアクセスされて出力されることができます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Note that the underlying objects aren’t changed by the casting process. They continue to be a <code class="docutils literal notranslate"><span class="pre">Circle</span></code>, a <code class="docutils literal notranslate"><span class="pre">Country</span></code> and an <code class="docutils literal notranslate"><span class="pre">Animal</span></code>. However, at the point that they’re stored in the <code class="docutils literal notranslate"><span class="pre">objectWithArea</span></code> constant, they’re only known to be of type <code class="docutils literal notranslate"><span class="pre">HasArea</span></code>, and so only their <code class="docutils literal notranslate"><span class="pre">area</span></code> property can be accessed.</span><!--end_enstr-->
<span class="jpstr">
根底にあるオブジェクトがキャスト処理によって変更されない点に注意してください。それらは、<code class="docutils literal notranslate"><span class="pre">Circle</span></code>、<code class="docutils literal notranslate"><span class="pre">Country</span></code>、そして<code class="docutils literal notranslate"><span class="pre">Animal</span></code>であり続けます。しかし、それらが定数の<code class="docutils literal notranslate"><span class="pre">objectWithArea</span></code>に格納される時点で、それらは型<code class="docutils literal notranslate"><span class="pre">HasArea</span></code>であるということを知られているだけです、なので、それらの<code class="docutils literal notranslate"><span class="pre">area</span></code>プロパティだけがアクセスされることができます。
</span><!--end_jpstr-->
</p>
</div>
<div class="section" id="ID284">
<h2><span class="enstr">Optional Protocol Requirements<a class="headerlink" href="#ID284" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
オプショナルのプロトコル要件<a class="headerlink" href="#ID284" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">You can define <em>optional requirements</em> for protocols. These requirements don’t have to be implemented by types that conform to the protocol. Optional requirements are prefixed by the <code class="docutils literal notranslate"><span class="pre">optional</span></code> modifier as part of the protocol’s definition. Optional requirements are available so that you can write code that interoperates with Objective-C. Both the protocol and the optional requirement must be marked with the <code class="docutils literal notranslate"><span class="pre">@objc</span></code> attribute. Note that <code class="docutils literal notranslate"><span class="pre">@objc</span></code> protocols can be adopted only by classes that inherit from Objective-C classes or other <code class="docutils literal notranslate"><span class="pre">@objc</span></code> classes. They can’t be adopted by structures or enumerations.</span><!--end_enstr-->
<span class="jpstr">
あなたは、<em>オプショナル要件</em>をプロトコルに対して定義できます。それらの要件は、そのプロトコルに準拠する型によって実装される必要はありません。オプショナルの要件は、そのプロトコル定義において<code class="docutils literal notranslate"><span class="pre">optional</span></code>修飾子を前に置かれます。オプショナル要件が利用可能なことから、あなたはObjective-Cと相互運用するコードを書くことができます。プロトコルとオプショナル要件の両方は、<code class="docutils literal notranslate"><span class="pre">@objc</span></code>属性で印されなければなりません。<code class="docutils literal notranslate"><span class="pre">@objc</span></code>プロトコルがObjective-Cクラスや他の<code class="docutils literal notranslate"><span class="pre">@objc</span></code>クラスから継承するクラスによってのみ採用される点に注意してください。それは構造体や列挙によって採用されることはできません。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">When you use a method or property in an optional requirement, its type automatically becomes an optional. For example, a method of type <code class="docutils literal notranslate"><span class="pre">(Int)</span> <span class="pre">-&gt;</span> <span class="pre">String</span></code> becomes <code class="docutils literal notranslate"><span class="pre">((Int)</span> <span class="pre">-&gt;</span> <span class="pre">String)?</span></code>. Note that the entire function type is wrapped in the optional, not the method’s return value.</span><!--end_enstr-->
<span class="jpstr">
あなたがオプショナルの要件の中のメソッドやプロパティを使うとき、それの型は自動的にオプショナルになります。例えば、型<code class="docutils literal notranslate"><span class="pre">(Int)</span> <span class="pre">-&gt;</span> <span class="pre">String</span></code>のメソッドは<code class="docutils literal notranslate"><span class="pre">((Int)</span> <span class="pre">-&gt;</span> <span class="pre">String)?</span></code>になります。メソッドの戻り値ではなく、その関数型の全体がオプショナルの中のラップされることに注意してください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">An optional protocol requirement can be called with optional chaining, to account for the possibility that the requirement was not implemented by a type that conforms to the protocol. You check for an implementation of an optional method by writing a question mark after the name of the method when it’s called, such as <code class="docutils literal notranslate"><span class="pre">someOptionalMethod?(someArgument)</span></code>. For information on optional chaining, see <a class="reference internal" href="OptionalChaining.html"><span class="doc">Optional Chaining</span></a>.</span><!--end_enstr-->
<span class="jpstr">
オプショナルのプロトコル要件は、オプショナル連鎖を使って呼び出されることができます、それによってプロトコルに準拠する型によって要件が満たされなかったという可能性に対応します。あなたは、それが呼ばれるときに疑問符をそのメソッドの後に書くことによって、あるオプショナルメソッドの実装について確認することができます、例えば<code class="docutils literal notranslate"><span class="pre">someOptionalMethod?(someArgument)</span></code>のように。オプショナル連鎖に関する情報のために、<a class="reference internal" href="OptionalChaining.html"><span class="doc">オプショナル連鎖</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The following example defines an integer-counting class called <code class="docutils literal notranslate"><span class="pre">Counter</span></code>, which uses an external data source to provide its increment amount. This data source is defined by the <code class="docutils literal notranslate"><span class="pre">CounterDataSource</span></code> protocol, which has two optional requirements:</span><!--end_enstr-->
<span class="jpstr">
以下の例は<code class="docutils literal notranslate"><span class="pre">Counter</span></code>と呼ばれる整数計数クラスを定義します、それは、その増加量を提供するために外部のデータ・ソースを使います。このデータ・ソースは<code class="docutils literal notranslate"><span class="pre">CounterDataSource</span></code>プロトコルによって定義されます、それは、２つのオプショナルの要件を持ちます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">@objc</span> <span class="k">protocol</span> <span class="nv">CounterDataSource</span> {
</li>
<li>    <span class="k">@objc</span> <span class="k">optional</span> <span class="k">func</span> <span class="nv">increment</span>(<span class="nv">forCount</span> <span class="nv">count</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Int</span>
</li>
<li>    <span class="k">@objc</span> <span class="k">optional</span> <span class="k">var</span> <span class="nv">fixedIncrement</span>: <span class="nc">Int</span> { <span class="k">get</span> }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">CounterDataSource</span></code> protocol defines an optional method requirement called <code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code> and an optional property requirement called <code class="docutils literal notranslate"><span class="pre">fixedIncrement</span></code>. These requirements define two different ways for data sources to provide an appropriate increment amount for a <code class="docutils literal notranslate"><span class="pre">Counter</span></code> instance.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">CounterDataSource</span></code>プロトコルは、<code class="docutils literal notranslate"><span class="pre">incrementForCount(_:)</span></code>と呼ばれるオプショナルのメソッド要件と<code class="docutils literal notranslate"><span class="pre">fixedIncrement</span></code>と呼ばれるオプショナルのプロパティ要件を定義します。これらの要件は、データ・ソースのために<code class="docutils literal notranslate"><span class="pre">Counter</span></code>インスタンスに適切な増加量を用意する２つの異なる方法を定義します。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Strictly speaking, you can write a custom class that conforms to <code class="docutils literal notranslate"><span class="pre">CounterDataSource</span></code> without implementing <em>either</em> protocol requirement. They’re both optional, after all. Although technically allowed, this wouldn’t make for a very good data source.</span><!--end_enstr-->
<span class="jpstr">
厳密に言って、あなたは<code class="docutils literal notranslate"><span class="pre">CounterDataSource</span></code>に準拠する特注のクラスを書くことが<em>両方の</em>プロトコル要件を満たすことなく可能です。結局、それらは両方ともオプショナルです。技術的には可能であるけれども、これはあまり良いデータ・ソースにつながりません。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">Counter</span></code> class, defined below, has an optional <code class="docutils literal notranslate"><span class="pre">dataSource</span></code> property of type <code class="docutils literal notranslate"><span class="pre">CounterDataSource?</span></code>:</span><!--end_enstr-->
<span class="jpstr">
下で定義される、<code class="docutils literal notranslate"><span class="pre">Counter</span></code>クラスは、型<code class="docutils literal notranslate"><span class="pre">CounterDataSource?</span></code>のオプショナルの<code class="docutils literal notranslate"><span class="pre">dataSource</span></code>プロパティを持ちます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">class</span> <span class="nv">Counter</span> {
</li>
<li>    <span class="k">var</span> <span class="nv">count</span> = <span class="m">0</span>
</li>
<li>    <span class="k">var</span> <span class="nv">dataSource</span>: <span class="nc">CounterDataSource</span>?
</li>
<li>    <span class="k">func</span> <span class="nv">increment</span>() {
</li>
<li>        <span class="k">if</span> <span class="k">let</span> <span class="nv">amount</span> = <span class="nv">dataSource</span>?.<span class="nv">increment</span>?(<span class="nv">forCount</span>: <span class="nv">count</span>) {
</li>
<li>            <span class="nv">count</span> += <span class="nv">amount</span>
</li>
<li>        } <span class="k">else</span> <span class="k">if</span> <span class="k">let</span> <span class="nv">amount</span> = <span class="nv">dataSource</span>?.<span class="nv">fixedIncrement</span> {
</li>
<li>            <span class="nv">count</span> += <span class="nv">amount</span>
</li>
<li>        }
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">Counter</span></code> class stores its current value in a variable property called <code class="docutils literal notranslate"><span class="pre">count</span></code>. The <code class="docutils literal notranslate"><span class="pre">Counter</span></code> class also defines a method called <code class="docutils literal notranslate"><span class="pre">increment</span></code>, which increments the <code class="docutils literal notranslate"><span class="pre">count</span></code> property every time the method is called.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">Counter</span></code>クラスは、その現在の値を<code class="docutils literal notranslate"><span class="pre">count</span></code>と呼ばれる変数プロパティに保管します。<code class="docutils literal notranslate"><span class="pre">Counter</span></code>クラスはまた、<code class="docutils literal notranslate"><span class="pre">increment</span></code>と呼ばれるメソッドを定義します、それは、メソッドが呼ばれるたびに<code class="docutils literal notranslate"><span class="pre">count</span></code>プロパティを増加させます。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">increment()</span></code> method first tries to retrieve an increment amount by looking for an implementation of the <code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code> method on its data source. The <code class="docutils literal notranslate"><span class="pre">increment()</span></code> method uses optional chaining to try to call <code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code>, and passes the current <code class="docutils literal notranslate"><span class="pre">count</span></code> value as the method’s single argument.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">increment()</span></code>メソッドは、最初にそれのデータ・ソース上で<code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code>メソッドの実装を捜すことによって増加量を取り出そうと試みます。<code class="docutils literal notranslate"><span class="pre">increment()</span></code>メソッドは、オプショナル連鎖を使って<code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code>を呼ぶことを試みます、そしてメソッドのもつただ１つの引数として現在の<code class="docutils literal notranslate"><span class="pre">count</span></code>値を渡します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Note that <em>two</em> levels of optional chaining are at play here. First, it’s possible that <code class="docutils literal notranslate"><span class="pre">dataSource</span></code> may be <code class="docutils literal notranslate"><span class="pre">nil</span></code>, and so <code class="docutils literal notranslate"><span class="pre">dataSource</span></code> has a question mark after its name to indicate that <code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code> should be called only if <code class="docutils literal notranslate"><span class="pre">dataSource</span></code> isn’t <code class="docutils literal notranslate"><span class="pre">nil</span></code>. Second, even if <code class="docutils literal notranslate"><span class="pre">dataSource</span></code> <em>does</em> exist, there’s no guarantee that it implements <code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code>, because it’s an optional requirement. Here, the possibility that <code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code> might not be implemented is also handled by optional chaining. The call to <code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code> happens only if <code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code> exists—that is, if it isn’t <code class="docutils literal notranslate"><span class="pre">nil</span></code>. This is why <code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code> is also written with a question mark after its name.</span><!--end_enstr-->
<span class="jpstr">
ここで<em>２つの</em>階層のオプショナル連鎖が働いていることに注意してください。第１に、<code class="docutils literal notranslate"><span class="pre">dataSource</span></code>が<code class="docutils literal notranslate"><span class="pre">nil</span></code>かもしれない可能性があります、なので、<code class="docutils literal notranslate"><span class="pre">dataSource</span></code>はその名前の後に疑問符を持ち、<code class="docutils literal notranslate"><span class="pre">dataSource</span></code>が<code class="docutils literal notranslate"><span class="pre">nil</span></code>でない場合にのみ<code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code>が呼ばれるべきであるのを示します。第２に、たとえ<code class="docutils literal notranslate"><span class="pre">dataSource</span></code>が<em>存在する</em>としても、それが<code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code>を実装する保証はありません、それがオプショナルの要件であるからです。ここでは、<code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code>が実装されないかもしれないという可能性もまたオプショナル連鎖によって取り扱われます。<code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code>への呼び出しは、<code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code>が存在する場合にのみ起こります ― すなわち、それが<code class="docutils literal notranslate"><span class="pre">nil</span></code>でない場合。これが、<code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code>もまたその名前の後に疑問符を書かれる理由です。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Because the call to <code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code> can fail for either of these two reasons, the call returns an <em>optional</em> <code class="docutils literal notranslate"><span class="pre">Int</span></code> value. This is true even though <code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code> is defined as returning a non-optional <code class="docutils literal notranslate"><span class="pre">Int</span></code> value in the definition of <code class="docutils literal notranslate"><span class="pre">CounterDataSource</span></code>. Even though there are two optional chaining operations, one after another, the result is still wrapped in a single optional. For more information about using multiple optional chaining operations, see <a class="reference internal" href="OptionalChaining.html#ID252"><span class="std std-ref">Linking Multiple Levels of Chaining</span></a>.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code>への呼び出しがこれらの２つの理由のどちらによっても失敗する可能性があるので、呼び出しは<em>オプショナルの</em> <code class="docutils literal notranslate"><span class="pre">Int</span></code>値を返します。たとえ<code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code>が<code class="docutils literal notranslate"><span class="pre">CounterDataSource</span></code>の定義の中で非オプショナルの<code class="docutils literal notranslate"><span class="pre">Int</span></code>値を返すように定義されるとしても、これは当てはまります。たとえ２つのオプショナル連鎖演算があったとしても、後から後から、その結果は依然としてただ１つのオプショナルの中にラップされます。複数のオプショナル連鎖演算を使用することについての更なる情報として、<a class="reference internal" href="OptionalChaining.html#ID252"><span class="std std-ref">連鎖の複数の階層を結ぶ</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">After calling <code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code>, the optional <code class="docutils literal notranslate"><span class="pre">Int</span></code> that it returns is unwrapped into a constant called <code class="docutils literal notranslate"><span class="pre">amount</span></code>, using optional binding. If the optional <code class="docutils literal notranslate"><span class="pre">Int</span></code> does contain a value—that is, if the delegate and method both exist, and the method returned a value—the unwrapped <code class="docutils literal notranslate"><span class="pre">amount</span></code> is added onto the stored <code class="docutils literal notranslate"><span class="pre">count</span></code> property, and incrementation is complete.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code>呼び出しの後、それが返すオプショナルの<code class="docutils literal notranslate"><span class="pre">Int</span></code>は、オプショナル束縛を使って、<code class="docutils literal notranslate"><span class="pre">amount</span></code>と呼ばれる定数へとアンラップされます。オプショナルの<code class="docutils literal notranslate"><span class="pre">Int</span></code>が値を含むならば ― すなわち、委任先とメソッドが両方とも存在する、そしてメソッドが値を返すならば ― アンラップされた<code class="docutils literal notranslate"><span class="pre">amount</span></code>が格納<code class="docutils literal notranslate"><span class="pre">count</span></code>プロパティへと加えられます、そして増加作業は完了です。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">If it’s <em>not</em> possible to retrieve a value from the <code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code> method—either because <code class="docutils literal notranslate"><span class="pre">dataSource</span></code> is nil, or because the data source doesn’t implement <code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code>—then the <code class="docutils literal notranslate"><span class="pre">increment()</span></code> method tries to retrieve a value from the data source’s <code class="docutils literal notranslate"><span class="pre">fixedIncrement</span></code> property instead. The <code class="docutils literal notranslate"><span class="pre">fixedIncrement</span></code> property is also an optional requirement, so its value is an optional <code class="docutils literal notranslate"><span class="pre">Int</span></code> value, even though <code class="docutils literal notranslate"><span class="pre">fixedIncrement</span></code> is defined as a non-optional <code class="docutils literal notranslate"><span class="pre">Int</span></code> property as part of the <code class="docutils literal notranslate"><span class="pre">CounterDataSource</span></code> protocol definition.</span><!--end_enstr-->
<span class="jpstr">
値を<code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code>メソッドから取り出すことが可能で<em>ない</em>ならば ― <code class="docutils literal notranslate"><span class="pre">dataSource</span></code>がnilであるから、またはデータ・ソースが<code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code>を実装しないからのどちらでも ― その時<code class="docutils literal notranslate"><span class="pre">increment()</span></code>メソッドはその代わりに値をデータ・ソースの<code class="docutils literal notranslate"><span class="pre">fixedIncrement</span></code>プロパティから取り出そうとします。<code class="docutils literal notranslate"><span class="pre">fixedIncrement</span></code>プロパティもまたオプショナルの要件です、なのでその値はオプショナルの<code class="docutils literal notranslate"><span class="pre">Int</span></code>値です、たとえ<code class="docutils literal notranslate"><span class="pre">fixedIncrement</span></code>が非オプショナルの<code class="docutils literal notranslate"><span class="pre">Int</span></code>プロパティであると<code class="docutils literal notranslate"><span class="pre">CounterDataSource</span></code>プロトコル定義の部分では定義されるとしてもです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Here’s a simple <code class="docutils literal notranslate"><span class="pre">CounterDataSource</span></code> implementation where the data source returns a constant value of <code class="docutils literal notranslate"><span class="pre">3</span></code> every time it’s queried. It does this by implementing the optional <code class="docutils literal notranslate"><span class="pre">fixedIncrement</span></code> property requirement:</span><!--end_enstr-->
<span class="jpstr">
ある単純な<code class="docutils literal notranslate"><span class="pre">CounterDataSource</span></code>実装がここにあります、そこにおいて、データ・ソースは<code class="docutils literal notranslate"><span class="pre">3</span></code>の定数値をそれが問い合わされるたびに返します。それは、オプショナルの<code class="docutils literal notranslate"><span class="pre">fixedIncrement</span></code>プロパティ要件を実装することによってこれをします：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">class</span> <span class="nv">ThreeSource</span>: <span class="nc">NSObject</span>, <span class="nc">CounterDataSource</span> {
</li>
<li>    <span class="k">let</span> <span class="nv">fixedIncrement</span> = <span class="m">3</span>
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">You can use an instance of <code class="docutils literal notranslate"><span class="pre">ThreeSource</span></code> as the data source for a new <code class="docutils literal notranslate"><span class="pre">Counter</span></code> instance:</span><!--end_enstr-->
<span class="jpstr">
あなたは、<code class="docutils literal notranslate"><span class="pre">ThreeSource</span></code>のインスタンスを新しい<code class="docutils literal notranslate"><span class="pre">Counter</span></code>インスタンスのためのデータ・ソースとして使うことができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">var</span> <span class="nv">counter</span> = <span class="nv">Counter</span>()
</li>
<li>
<span class="nv">counter</span>.<span class="nv">dataSource</span> = <span class="nv">ThreeSource</span>()
</li>
<li>
<span class="k">for</span> <span class="k">_</span> <span class="k">in</span> <span class="m">1</span>...<span class="m">4</span> {
</li>
<li>    <span class="nv">counter</span>.<span class="nv">increment</span>()
</li>
<li>    <span class="nv">print</span>(<span class="nv">counter</span>.<span class="nv">count</span>)
</li>
<li>}
</li>
<li>
<span class="c">// 3</span>
</li>
<li>
<span class="c">// 6</span>
</li>
<li>
<span class="c">// 9</span>
</li>
<li>
<span class="c">// 12</span>
</li>
</ol></div></div></div>
<p><span class="enstr">The code above creates a new <code class="docutils literal notranslate"><span class="pre">Counter</span></code> instance; sets its data source to be a new <code class="docutils literal notranslate"><span class="pre">ThreeSource</span></code> instance; and calls the counter’s <code class="docutils literal notranslate"><span class="pre">increment()</span></code> method four times. As expected, the counter’s <code class="docutils literal notranslate"><span class="pre">count</span></code> property increases by three each time <code class="docutils literal notranslate"><span class="pre">increment()</span></code> is called.</span><!--end_enstr-->
<span class="jpstr">
上のコードは、新しい<code class="docutils literal notranslate"><span class="pre">Counter</span></code>インスタンスをつくり；それのデータ・ソースを新しい<code class="docutils literal notranslate"><span class="pre">ThreeSource</span></code>インスタンスであるように設定します；そして、counterの<code class="docutils literal notranslate"><span class="pre">increment()</span></code>メソッドを４回呼び出します。予想されるように、counterの<code class="docutils literal notranslate"><span class="pre">count</span></code>プロパティは、<code class="docutils literal notranslate"><span class="pre">increment()</span></code>が呼ばれるたびに３つずつ増加します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Here’s a more complex data source called <code class="docutils literal notranslate"><span class="pre">TowardsZeroSource</span></code>, which makes a <code class="docutils literal notranslate"><span class="pre">Counter</span></code> instance count up or down towards zero from its current <code class="docutils literal notranslate"><span class="pre">count</span></code> value:</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">TowardsZeroSource</span></code>と呼ばれるより複雑なデータ・ソースがここにあります、それは、<code class="docutils literal notranslate"><span class="pre">Counter</span></code>インスタンスをその現在の<code class="docutils literal notranslate"><span class="pre">count</span></code>値から上下にゼロの方へ数えます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">class</span> <span class="nv">TowardsZeroSource</span>: <span class="nc">NSObject</span>, <span class="nc">CounterDataSource</span> {
</li>
<li>    <span class="k">func</span> <span class="nv">increment</span>(<span class="nv">forCount</span> <span class="nv">count</span>: <span class="nc">Int</span>) -&gt; <span class="nc">Int</span> {
</li>
<li>        <span class="k">if</span> <span class="nv">count</span> == <span class="m">0</span> {
</li>
<li>            <span class="k">return</span> <span class="m">0</span>
</li>
<li>        } <span class="k">else</span> <span class="k">if</span> <span class="nv">count</span> &lt; <span class="m">0</span> {
</li>
<li>            <span class="k">return</span> <span class="m">1</span>
</li>
<li>        } <span class="k">else</span> {
</li>
<li>            <span class="k">return</span> <span class="m">-1</span>
</li>
<li>        }
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">TowardsZeroSource</span></code> class implements the optional <code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code> method from the <code class="docutils literal notranslate"><span class="pre">CounterDataSource</span></code> protocol and uses the <code class="docutils literal notranslate"><span class="pre">count</span></code> argument value to work out which direction to count in. If <code class="docutils literal notranslate"><span class="pre">count</span></code> is already zero, the method returns <code class="docutils literal notranslate"><span class="pre">0</span></code> to indicate that no further counting should take place.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">TowardsZeroSource</span></code>クラスは、<code class="docutils literal notranslate"><span class="pre">CounterDataSource</span></code>プロトコルからのオプショナルの<code class="docutils literal notranslate"><span class="pre">increment(forCount:)</span></code>メソッドを実装して、どの方向に数えるべきか解決するために<code class="docutils literal notranslate"><span class="pre">count</span></code>引数値を使います。<code class="docutils literal notranslate"><span class="pre">count</span></code>がすでにゼロであるならば、メソッドは<code class="docutils literal notranslate"><span class="pre">0</span></code>を返して、これ以上数えることは必要ないことを示します。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">You can use an instance of <code class="docutils literal notranslate"><span class="pre">TowardsZeroSource</span></code> with the existing <code class="docutils literal notranslate"><span class="pre">Counter</span></code> instance to count from <code class="docutils literal notranslate"><span class="pre">-4</span></code> to zero. Once the counter reaches zero, no more counting takes place:</span><!--end_enstr-->
<span class="jpstr">
あなたは、<code class="docutils literal notranslate"><span class="pre">TowardsZeroSource</span></code>のインスタンスを既存の<code class="docutils literal notranslate"><span class="pre">Counter</span></code>インスタンスとともに使って、<code class="docutils literal notranslate"><span class="pre">-4</span></code>からゼロへと数えることができます。ひとたびcounterがゼロに達するならば、それ以上数えることは起こりません：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="nv">counter</span>.<span class="nv">count</span> = <span class="m">-4</span>
</li>
<li>
<span class="nv">counter</span>.<span class="nv">dataSource</span> = <span class="nv">TowardsZeroSource</span>()
</li>
<li>
<span class="k">for</span> <span class="k">_</span> <span class="k">in</span> <span class="m">1</span>...<span class="m">5</span> {
</li>
<li>    <span class="nv">counter</span>.<span class="nv">increment</span>()
</li>
<li>    <span class="nv">print</span>(<span class="nv">counter</span>.<span class="nv">count</span>)
</li>
<li>}
</li>
<li>
<span class="c">// -3</span>
</li>
<li>
<span class="c">// -2</span>
</li>
<li>
<span class="c">// -1</span>
</li>
<li>
<span class="c">// 0</span>
</li>
<li>
<span class="c">// 0</span>
</li>
</ol></div></div></div>
</div>
<div class="section" id="ID521">
<h2><span class="enstr">Protocol Extensions<a class="headerlink" href="#ID521" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
プロトコル拡張<a class="headerlink" href="#ID521" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h2>
<p><span class="enstr">Protocols can be extended to provide method, initializer, subscript, and computed property implementations to conforming types. This allows you to define behavior on protocols themselves, rather than in each type’s individual conformance or in a global function.</span><!--end_enstr-->
<span class="jpstr">
プロトコルは拡張されることによって、準拠している型にメソッド、イニシャライザ、添え字、そして計算プロパティの実装を提供できます。これはあなたに、それぞれの型の個々の準拠においてまたはグローバル関数においてではなく、プロトコルそれ自体に振る舞いを定義することを可能にします。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">For example, the <code class="docutils literal notranslate"><span class="pre">RandomNumberGenerator</span></code> protocol can be extended to provide a <code class="docutils literal notranslate"><span class="pre">randomBool()</span></code> method, which uses the result of the required <code class="docutils literal notranslate"><span class="pre">random()</span></code> method to return a random <code class="docutils literal notranslate"><span class="pre">Bool</span></code> value:</span><!--end_enstr-->
<span class="jpstr">
例えば、<code class="docutils literal notranslate"><span class="pre">RandomNumberGenerator</span></code>プロトコルは拡張されて<code class="docutils literal notranslate"><span class="pre">randomBool()</span></code>メソッドを提供することができます、それは必須メソッドの<code class="docutils literal notranslate"><span class="pre">random()</span></code>を利用してランダムな<code class="docutils literal notranslate"><span class="pre">Bool</span></code>値を返すものです：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">extension</span> <span class="nc">RandomNumberGenerator</span> {
</li>
<li>    <span class="k">func</span> <span class="nv">randomBool</span>() -&gt; <span class="nc">Bool</span> {
</li>
<li>        <span class="k">return</span> <span class="nv">random</span>() &gt; <span class="m">0.5</span>
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">By creating an extension on the protocol, all conforming types automatically gain this method implementation without any additional modification.</span><!--end_enstr-->
<span class="jpstr">
拡張をプロトコル上に作成することによって、すべての準拠している型が自動的にこのメソッド実装をなんら追加の修正なしに手に入れます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">generator</span> = <span class="nv">LinearCongruentialGenerator</span>()
</li>
<li>
<span class="nv">print</span>(<span class="s">"Here's a random number: </span>\<span class="p">(</span><span class="nv">generator</span>.<span class="nv">random</span>()<span class="p">)</span><span class="s">"</span>)
</li>
<li>
<span class="c"><span class="enstr">// Prints "Here's a random number: 0.3746499199817101"</span><!--end_enstr--><span class="jpstr">（「ここに任意の数: 0.3746499199817101があります」を出力します）</span><!--end_jpstr--></span>
</li>
<li>
<span class="nv">print</span>(<span class="s">"And here's a random Boolean: </span>\<span class="p">(</span><span class="nv">generator</span>.<span class="nv">randomBool</span>()<span class="p">)</span><span class="s">"</span>)
</li>
<li>
<span class="c"><span class="enstr">// Prints "And here's a random Boolean: true"</span><!--end_enstr--><span class="jpstr">（「そしてここに任意のブール: trueがあります」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<p><span class="enstr">Protocol extensions can add implementations to conforming types but can’t make a protocol extend or inherit from another protocol. Protocol inheritance is always specified in the protocol declaration itself.</span><!--end_enstr-->
<span class="jpstr">
プロトコル拡張は、実装を加えることによって型に準拠が可能です、しかしあるプロトコルを別のプロトコルから拡張したり継承したりはできません。プロトコル継承は、常にプロトコル宣言それ自体の中で指定されます。
</span><!--end_jpstr-->
</p>
<div class="section" id="ID529">
<h3><span class="enstr">Providing Default Implementations<a class="headerlink" href="#ID529" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
省略時の実装を提供する<a class="headerlink" href="#ID529" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">You can use protocol extensions to provide a default implementation to any method or computed property requirement of that protocol. If a conforming type provides its own implementation of a required method or property, that implementation will be used instead of the one provided by the extension.</span><!--end_enstr-->
<span class="jpstr">
あなたはプロトコル拡張を使うことで省略時の実装をそのプロトコルのどのメソッドまたは計算プロパティ要件に対しても提供できます。準拠している型がある必須のメソッドやプロパティのそれ自身の実装を提供する場合は、その実装が拡張によって提供されるものの代わりに使用されます。
</span><!--end_jpstr-->
</p>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">Protocol requirements with default implementations provided by extensions are distinct from optional protocol requirements. Although conforming types don’t have to provide their own implementation of either, requirements with default implementations can be called without optional chaining.</span><!--end_enstr-->
<span class="jpstr">
拡張によって提供される省略時の実装を持つプロトコル要件は、オプショナルプロトコル要件とは異なったものです。どちらにおいても準拠する型がそれ自身の実装を提供しなくても良いけれども、省略時の実装を持つ要件はオプショナル連鎖なしに呼ばれることができます。
</span><!--end_jpstr-->
</p>
</div>
<p><span class="enstr">For example, the <code class="docutils literal notranslate"><span class="pre">PrettyTextRepresentable</span></code> protocol, which inherits the <code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code> protocol can provide a default implementation of its required <code class="docutils literal notranslate"><span class="pre">prettyTextualDescription</span></code> property to simply return the result of accessing the <code class="docutils literal notranslate"><span class="pre">textualDescription</span></code> property:</span><!--end_enstr-->
<span class="jpstr">
例えば、<code class="docutils literal notranslate"><span class="pre">TextRepresentable</span></code>プロトコルを継承する<code class="docutils literal notranslate"><span class="pre">prettyTextualDescription</span></code>プロパティは、それの必須プロパティ<code class="docutils literal notranslate"><span class="pre">prettyTextualDescription</span></code>の省略時の実装を提供して、単に<code class="docutils literal notranslate"><span class="pre">textualDescription</span></code>プロパティの結果を返すようにできます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">extension</span> <span class="nc">PrettyTextRepresentable</span>  {
</li>
<li>    <span class="k">var</span> <span class="nv">prettyTextualDescription</span>: <span class="nc">String</span> {
</li>
<li>        <span class="k">return</span> <span class="nv">textualDescription</span>
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
</div>
<div class="section" id="ID527">
<h3><span class="enstr">Adding Constraints to Protocol Extensions<a class="headerlink" href="#ID527" title="Permalink to this headline">¶</a></span><!--end_enstr-->
<span class="jpstr">
プロトコル拡張に制約を加える<a class="headerlink" href="#ID527" title="Permalink to this headline">¶</a>
</span><!--end_jpstr-->

</h3>
<p><span class="enstr">When you define a protocol extension, you can specify constraints that conforming types must satisfy before the methods and properties of the extension are available. You write these constraints after the name of the protocol you’re extending by writing a generic <code class="docutils literal notranslate"><span class="pre">where</span></code> clause. For more about generic <code class="docutils literal notranslate"><span class="pre">where</span></code> clauses, see <a class="reference internal" href="Generics.html#ID192"><span class="std std-ref">Generic Where Clauses</span></a>.</span><!--end_enstr-->
<span class="jpstr">
あなたがプロトコル拡張を定義するとき、あなたは準拠している型がその拡張のメソッドやプロパティが利用可能になる前に満たさなければならない制約を指定することができます。あなたはこれらの制約を、総称体<code class="docutils literal notranslate"><span class="pre">where</span></code>節を書くことによってあなたが拡張しているプロトコルの名前の後に書きます。総称体<code class="docutils literal notranslate"><span class="pre">where</span></code>節に関する詳細は、<a class="reference internal" href="Generics.html#ID192"><span class="std std-ref">総称体where節</span></a>を見てください。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">For example, you can define an extension to the <code class="docutils literal notranslate"><span class="pre">Collection</span></code> protocol that applies to any collection whose elements conform to the <code class="docutils literal notranslate"><span class="pre">Equatable</span></code> protocol. By constraining a collection’s elements to the <code class="docutils literal notranslate"><span class="pre">Equatable</span></code> protocol, a part of the standard library, you can use the <code class="docutils literal notranslate"><span class="pre">==</span></code> and <code class="docutils literal notranslate"><span class="pre">!=</span></code> operators to check for equality and inequality between two elements.</span><!--end_enstr-->
<span class="jpstr">
例えば、それの要素が<code class="docutils literal notranslate"><span class="pre">Equatable</span></code>プロトコルに準拠するあらゆるコレクションに適用される<code class="docutils literal notranslate"><span class="pre">Collection</span></code>プロトコルに対して、あなたはある拡張を定義できます。あるコレクションの持つ要素を<code class="docutils literal notranslate"><span class="pre">Equatable</span></code>プロトコル、標準ライブラリの１つ、に制約することで、あなたは<code class="docutils literal notranslate"><span class="pre">==</span></code>と<code class="docutils literal notranslate"><span class="pre">!=</span></code>演算子を使って同等性と同一性を２つの要素間で確認できます。
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">extension</span> <span class="nc">Collection</span> <span class="k">where</span> <span class="nc">Element</span>: <span class="nc">Equatable</span> {
</li>
<li>    <span class="k">func</span> <span class="nv">allEqual</span>() -&gt; <span class="nc">Bool</span> {
</li>
<li>        <span class="k">for</span> <span class="nv">element</span> <span class="k">in</span> <span class="k">self</span> {
</li>
<li>            <span class="k">if</span> <span class="nv">element</span> != <span class="k">self</span>.<span class="nv">first</span> {
</li>
<li>                <span class="k">return</span> <span class="k">false</span>
</li>
<li>            }
</li>
<li>        }
</li>
<li>        <span class="k">return</span> <span class="k">true</span>
</li>
<li>    }
</li>
<li>}
</li>
</ol></div></div></div>
<p><span class="enstr">The <code class="docutils literal notranslate"><span class="pre">allEqual()</span></code> method returns <code class="docutils literal notranslate"><span class="pre">true</span></code> only if all the elements in the collection are equal.</span><!--end_enstr-->
<span class="jpstr">
<code class="docutils literal notranslate"><span class="pre">allEqual()</span></code>メソッドが<code class="docutils literal notranslate"><span class="pre">true</span></code>を返すのは、そのコレクションの中の要素すべてが同等である場合のみです。
</span><!--end_jpstr-->
</p>
<p><span class="enstr">Consider two arrays of integers, one where all the elements are the same, and one where they aren’t:</span><!--end_enstr-->
<span class="jpstr">
いくつかの整数からなる２つの配列を考えてください、すべての要素が同じであるもの、そしてそうではないもの：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="k">let</span> <span class="nv">equalNumbers</span> = [<span class="m">100</span>, <span class="m">100</span>, <span class="m">100</span>, <span class="m">100</span>, <span class="m">100</span>]
</li>
<li>
<span class="k">let</span> <span class="nv">differentNumbers</span> = [<span class="m">100</span>, <span class="m">100</span>, <span class="m">200</span>, <span class="m">100</span>, <span class="m">200</span>]
</li>
</ol></div></div></div>
<p><span class="enstr">Because arrays conform to <code class="docutils literal notranslate"><span class="pre">Collection</span></code> and integers conform to <code class="docutils literal notranslate"><span class="pre">Equatable</span></code>, <code class="docutils literal notranslate"><span class="pre">equalNumbers</span></code> and <code class="docutils literal notranslate"><span class="pre">differentNumbers</span></code> can use the <code class="docutils literal notranslate"><span class="pre">allEqual()</span></code> method:</span><!--end_enstr-->
<span class="jpstr">
それら配列は<code class="docutils literal notranslate"><span class="pre">Collection</span></code>に準拠し、それら整数は<code class="docutils literal notranslate"><span class="pre">Equatable</span></code>に準拠することから、<code class="docutils literal notranslate"><span class="pre">equalNumbers</span></code>と<code class="docutils literal notranslate"><span class="pre">differentNumbers</span></code>は<code class="docutils literal notranslate"><span class="pre">allEqual()</span></code>メソッドを使うことができます：
</span><!--end_jpstr-->
</p>
<div class="highlight-swift notranslate"><div class="code-sample"><div class="Swift highlight"><ol class="code-lines">
<li>
<span class="nv">print</span>(<span class="nv">equalNumbers</span>.<span class="nv">allEqual</span>())
</li>
<li>
<span class="c"><span class="enstr">// Prints "true"</span><!--end_enstr--><span class="jpstr">（「true」を出力します）</span><!--end_jpstr--></span>
</li>
<li>
<span class="nv">print</span>(<span class="nv">differentNumbers</span>.<span class="nv">allEqual</span>())
</li>
<li>
<span class="c"><span class="enstr">// Prints "false"</span><!--end_enstr--><span class="jpstr">（「false」を出力します）</span><!--end_jpstr--></span>
</li>
</ol></div></div></div>
<div class="admonition note">
<p class="first admonition-title"><span class="enstr">Note</span><!--end_enstr-->
<span class="jpstr">
注意
</span><!--end_jpstr-->
</p>
<p class="last"><span class="enstr">If a conforming type satisfies the requirements for multiple constrained extensions that provide implementations for the same method or property, Swift uses the implementation corresponding to the most specialized constraints.</span><!--end_enstr-->
<span class="jpstr">
ある準拠型が同じメソッドやプロパティに対する実装を提供する複数の制約拡張に対する要件を満たすならば、スウィフトは最も特殊化した制約と一致する実装を使います。
</span><!--end_jpstr-->
</p>
</div>
</div>
</div>
</div>


    </article>
    <div class="next_previous">
        <p class="previous"><a href="Extensions.html"><span class="enstr">Extensions</span><!--end_enstr-->
<span class="jpstr">
拡張
</span><!--end_jpstr-->
</a></p>
        <p class="next"><a href="Generics.html"><span class="enstr">Generics</span><!--end_enstr-->
<span class="jpstr">
総称体
</span><!--end_jpstr-->
</a></p>
    </div>
</main>


<footer role="contentinfo">
  <aside>
    <a href="//swift.org/atom.xml" title="Subscribe to Site Updates"><i class="feed">Subscribe</i></a>
    <a href="https://twitter.com/swiftlang" rel="nofollow" title="Follow @SwiftLang on Twitter"><i class="twitter">Twitter</i></a>
  </aside>

  <p class="copyright">Copyright © 2022 Apple Inc. All rights reserved.</p>
  <p class="trademark">Swift and the Swift logo are trademarks of Apple Inc.</p>
  <p class="privacy">
    <a href="//www.apple.com/privacy/privacy-policy/">Privacy Policy</a>
    <a href="//www.apple.com/legal/privacy/en-ww/cookies/">Cookies</a>
  </p>
</footer>
<div id="jump_to_overlay"></div>
<script src="../static/javascripts/application.js"></script>
  
</body>
</html>
